var documenterSearchIndex = {"docs":
[{"location":"index.html#","page":"Home","title":"Home","text":"io = IOBuffer()\nrelease = isempty(VERSION.prerelease)\nv = \"$(VERSION.major).$(VERSION.minor)\"\n!release && (v = v*\"-$(first(VERSION.prerelease))\")\nprint(io, \"\"\"\n    # Julia $(v)  のドキュメント\n\n    Julia $(v) のドキュメントへようこそ。\n\n    \"\"\")\nif !release\n    print(io,\"\"\"\n        !!! warning \"Work in progress!\"\n            This documentation is for an unreleased, in-development, version of Julia.\n        \"\"\")\nend\nimport Markdown\nMarkdown.parse(String(take!(io)))","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"前回のリリース以降の変更内容については、リリースノートをお読みください。","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"release = isempty(VERSION.prerelease)\nfile = release ? \"julia-$(VERSION).pdf\" :\n       \"julia-$(VERSION.major).$(VERSION.minor).$(VERSION.patch)-$(first(VERSION.prerelease)).pdf\"\nurl = \"https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/$(file)\"\nimport Markdown\nMarkdown.parse(\"\"\"\n!!! note\n    ドキュメントはPDF形式で利用可能です: [$file]($url).\n\"\"\")","category":"page"},{"location":"index.html#man-introduction-1","page":"Home","title":"はじめに","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"科学技術計算は、これまでに最高のパフォーマンスを性能を要求していましたが、その分野の専門家は日々の仕事のために速度で劣る動的言語に主に移行してきました。我々はこれらのアプリケーションで動的言語が好まれる多くの理由があると信じていますし、動的言語の使用が減少するとも思っていません。幸いなことに、現代の言語設計とコンパイラ技術により、パフォーマンスのトレードオフをほとんど解消し、プロトタイピングに向く生産性と、パフォーマンス重視のアプリケーションのデプロイに向く演算効率とを、単一環境で提供することが可能です。Julia言語は、この役割を果たします。柔軟な動的言語であり、パフォーマンスは従来の静的型付け言語に匹敵し科学的・数値的な計算に適しているのです。","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"JuliaのコンパイラはPythonやRのような言語で使われているインタプリタとは異なるので、Juliaのパフォーマンスは最初は直観的ではないことがわかります。プログラムが遅いと思われる場合は、何かを試す前にパフォーマンス・ティップスセクションを読むことを強くお勧めします。Juliaのしくみを理解すれば、Cと同じくらい速いコードを書くのは簡単です。","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Juliaの特徴に、省略可能な型付け、多重ディスパッチ そして高パフォーマンスがあります。これらは、型推論とジャスト・イン・タイム(JIT)コンパイルによって達成され、LLVMを使って実装されています。Juliaはマルチパラダイム言語で、命令型、関数型、オブジェクト指向プログラムの特徴を併せ持っています。Juliaは、R・Matlab・Pythonといった言語と同じように、高度な数値計算向けの簡単で高い表現力を提供しつつ、汎用的なプログラミングもサポートします。これは、Juliaが数学的プログラム言語の系譜を踏まえつつ、Lisp, Perl, Python, Lua, Ruby など人気の動的言語から多くのアイディアをえているからです。","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"典型的な動的言語とJuliaとの主な違いは:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"言語のコア部分は最小限の機能しか提供しません。整数の四則演算のような初等演算を含む標準ライブラリはJulia自身で書かれています\nオブジェクトを作成したり説明したりするのに使うことができる、型に関する豊富な機能を提供します。プログラマ自身で型を宣言することもできます\n多重ディスパッチによってさまざまな引数の組み合わせごとに関数の振る舞いを定義できます\nそれぞれの引数の型ごとに最適化されたコードを自動生成します\nCのような静的コンパイル言語に迫る性能を実現します","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"動的言語は「型がない」と言われることがありますが、そんなことはありません。プリミティブであれユーザー定義であれ、全てのオブジェクトは何らかの型を持ちます。多くの動的言語における型宣言の欠落は、コンパイラに対して値の型を伝えられない、または型について何ら触れることができないということを意味します。一方静的言語においては、コンパイラのために型注釈をつけることができます（ほぼ必須でしょう）が、型の情報はコンパイル時にのみ存在し、実行時には操作したり取得したりすることができません。Juliaでは、型そのものが実行時オブジェクトとなり、同時にコンパイラに対して情報を伝えるために利用できます。","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"ちょっとプログラムを書きたいだけなら、わざわざ使う必要のない型や多重ディスパッチですが、 これらの昨日は実はJuliaの中核を担っています。関数はさまざまな引数の組み合わせに対して定義され、実行時には最も当てはまる定義が適用されます。 このモデルは数値計算にとても適しています。従来のオブジェクト指向ディスパッチのように、第一引数が演算子を「所有」するのは不自然です。これに対してJuliaの演算子は（特殊な記法を持った）単なる関数に過ぎません。 ユーザーが定義したデータ型に対して加算処理を追加したい場合は、 +　関数に対して新たなメソッドを定義します。 こうすることで、既存のコードをシームレスに新たなデータ型対応させることができます。","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"実行時型推論（任意の型注釈で補うこともできます）によって、またプロジェクト発足時からの性能に対する強い欲求によって、Juliaの計算効率は他の動的言語を圧倒し、静的コンパイル言語と競うレベルにあります。大規模な数値計算問題では計算速度はこれまでもこれからも、常に重大な問題です。処理されるデータ量は過去数十年にわたってムーアの法則にしたがって増え続けています。","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Juliaは、扱いやすさ・強力さ・効率性の前例のない組み合わせを1つの言語で実現しようとしています。これに加え、Julia　は以下のような長所を持ちます:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"フリーかつオープンソース（MITライセンス）\nコンパクトで組み込み型と同等の速度を持つユーザー定義型\n性能のためにコードをベクトル化する必要がありません。ベクトル化されていないコードも高速に動作します\n並列コンピューティング・分散コンピューティングを意図した設計\n軽量で”greenな”スレッドシステム([コルーチン]https://en.wikipedia.org/wiki/Coroutine)\n控えめかつ強力な型システム\n数値型他の型の、エレガントで拡張性のある変換やプロモーション\nUnicode の効率的なサポート。UTF-8 も含みますが、これに限定しません\nラッパーや特別なAPIを必要としない、Cの関数の直接の呼び出し\nシェルのような強力なプロセス管理\nLispライクなマクロやその他のメタプログラミング機構","category":"page"},{"location":"NEWS.html#Julia-v1.2-Release-Notes-1","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"","category":"section"},{"location":"NEWS.html#New-language-features-1","page":"Julia v1.2 Release Notes","title":"New language features","text":"","category":"section"},{"location":"NEWS.html#","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"Argument splatting (x...) can now be used in calls to the new pseudo-function in constructors (#30577).\nSupport for Unicode 12.0.0 (#31561).\nAdded ⋆ (\\star) as unary operator (#31604).","category":"page"},{"location":"NEWS.html#Language-changes-1","page":"Julia v1.2 Release Notes","title":"Language changes","text":"","category":"section"},{"location":"NEWS.html#","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"Empty entries in JULIA_DEPOT_PATH are now expanded to default depot entries (#31009).","category":"page"},{"location":"NEWS.html#Multi-threading-changes-1","page":"Julia v1.2 Release Notes","title":"Multi-threading changes","text":"","category":"section"},{"location":"NEWS.html#","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"The Condition type now has a thread-safe replacement, accessed as Threads.Condition. With that addition, task scheduling primitives such as ReentrantLock are now thread-safe (#30061).\nIt is possible to schedule and switch Tasks during @threads loops, and perform limited I/O (#31438).","category":"page"},{"location":"NEWS.html#Build-system-changes-1","page":"Julia v1.2 Release Notes","title":"Build system changes","text":"","category":"section"},{"location":"NEWS.html#","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"The build system now prefers downloading prebuilt binary tarballs for most dependencies on supported systems, disable by setting USE_BINARYBUILDER=0 at make time (#31441).","category":"page"},{"location":"NEWS.html#New-library-functions-1","page":"Julia v1.2 Release Notes","title":"New library functions","text":"","category":"section"},{"location":"NEWS.html#","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"getipaddrs() function returns all the IP addresses of the local machine, with IPv4 addresses sorting before IPv6 addresses ([#30349, #30604]).\ngetipaddr(addr_type) and getipaddrs(addr_type) functions returns an IP address(es) of the desired type of the local machine (#30604).\nAdded Base.hasproperty and Base.hasfield (#28850).\nOne argument !=(x), >(x), >=(x), <(x), <=(x) have been added, returning partially-applied versions of the functions, similar to the existing ==(x) and isequal(x) methods (#30915).","category":"page"},{"location":"NEWS.html#Standard-library-changes-1","page":"Julia v1.2 Release Notes","title":"Standard library changes","text":"","category":"section"},{"location":"NEWS.html#","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"Enum now behaves like a scalar when used in broadcasting (#30670).\nIf a pipeline is specified with append=true set, but no redirection, an ArgumentError is thrown, rather than a ErrorException (#27900).\nFunctions that invoke commands (e.g. run(::Cmd)) now throw a ProcessFailedException rather than an ErrorException, if those commands exit with non-zero exit code (#27900).\nThe extrema function now accepts a function argument in the same manner as minimum and maximum (#30323).\nhasmethod can now check for matching keyword argument names (#30712).\nstartswith and endswith now accept a Regex for the second argument (#29790).\nretry supports arbitrary callable objects (#30382).\nA no-argument constructor for Ptr{T} has been added which constructs a null pointer (#30919).\nstrip now accepts a function argument in the same manner as lstrip and rstrip (#31211).\nmktempdir now accepts a prefix keyword argument to customize the file name (#31230, #22922).\nkeytype and valtype now work on AbstractArray, and return the eltype of keys(...) and values(...) respectively (#27749).\nnextfloat(::BigFloat) and prevfloat(::BigFloat) now returns a value with the same precision as their argument, which means that (in particular) nextfloat(prevfloat(x)) == x whereas previously this could result in a completely different value with a different precision (#31310).\nmapreduce now accepts multiple iterators, similar to map (#31532).\nfilter now supports SkipMissing-wrapped arrays (#31235).\nObjects created by calling skipmissing on an array can now be indexed using indices from the parent at non-missing positions. This allows functions such as findall, findfirst, argmin/argmax and findmin/findmax to work with these objects, returning the index of matching non-missing elements in the parent (#31008).\ninv(::Missing) has now been added and returns missing (#31451).\nnextfloat(::BigFloat, n::Integer) and prevfloat(::BigFloat, n::Integer) methods have been added (#31310).","category":"page"},{"location":"NEWS.html#LinearAlgebra-1","page":"Julia v1.2 Release Notes","title":"LinearAlgebra","text":"","category":"section"},{"location":"NEWS.html#","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"Added keyword arguments rtol, atol to pinv and nullspace (#29998).\nUniformScaling instances are now callable such that e.g. I(3) will produce a Diagonal matrix (#30298).\nEigenvalues λ of general matrices are now sorted lexicographically by (Re λ, Im λ) (#21598).\none for structured matrices (Diagonal, Bidiagonal, Tridiagonal, Symtridiagonal) now preserves structure and type (#29777).\ndiagm(v) is now a shorthand for diagm(0 => v) (#31125).","category":"page"},{"location":"NEWS.html#SparseArrays-1","page":"Julia v1.2 Release Notes","title":"SparseArrays","text":"","category":"section"},{"location":"NEWS.html#","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"Performance improvements for sparse matrix-matrix multiplication (#30372).\nSparse vector outer products are more performant and maintain sparsity in products of the form kron(u, v'), u * v', and u .* v' where u and v are sparse vectors or column views (#24980).\nThe sprand function is now 2 to 5 times faster (#30494). As a consequence of this change, the random stream of matrices produced with sprand and sprandn has changed.","category":"page"},{"location":"NEWS.html#Sockets-1","page":"Julia v1.2 Release Notes","title":"Sockets","text":"","category":"section"},{"location":"NEWS.html#","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"getipaddrs returns IP addresses in the order provided by libuv (#32260).\ngetipaddr prefers to return the first IPv4 interface address provided by libuv (#32260).","category":"page"},{"location":"NEWS.html#Statistics-1","page":"Julia v1.2 Release Notes","title":"Statistics","text":"","category":"section"},{"location":"NEWS.html#","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"quantile now accepts in all cases collections whose eltype is not a subtype of Number (#30938).","category":"page"},{"location":"NEWS.html#Miscellaneous-1","page":"Julia v1.2 Release Notes","title":"Miscellaneous","text":"","category":"section"},{"location":"NEWS.html#","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"Since environment variables on Windows are case-insensitive, ENV now converts its keys to uppercase for display, iteration, and copying (#30593).","category":"page"},{"location":"NEWS.html#External-dependencies-1","page":"Julia v1.2 Release Notes","title":"External dependencies","text":"","category":"section"},{"location":"NEWS.html#","page":"Julia v1.2 Release Notes","title":"Julia v1.2 Release Notes","text":"libgit2 has been updated to v0.27.7 (#30584).\nOpenBLAS has been updated to v0.3.5 (#30583).\nMbedTLS has been updated to v2.16.0 (#30618).\nlibunwind has been updated to v1.3.1 (#30724).","category":"page"},{"location":"manual/getting-started.html#man-getting-started-1","page":"はじめよう","title":"はじめよう","text":"","category":"section"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"Julia のインストールは、コンパイル済みのバイナリを使用するか、ソースからコンパイルするかにかかわらず、簡単です。 [https://julialang.org/downloads/]の指示に従ってジュリアをダウンロードしてインストールしてください。","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"Julia を学習して実験する最も簡単な方法は、Julia の実行ファイルをダブルクリックするか、コマンド ラインから 「julia」を実行して対話型セッション (read-eval-print loop すなわち \"REPL\" とも呼ばれます) を開始することです:","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"io = IOBuffer()\nBase.banner(io)\nbanner = String(take!(io))\nimport Markdown\nMarkdown.parse(\"```\\n\\$ julia\\n\\n$(banner)\\njulia> 1 + 2\\n3\\n\\njulia> ans\\n3\\n```\")","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"対話型セッションを終了するには、「Ctrl-D」と入力するか (コントロール/^ キーを d キーと一緒に押す)、 exit() と入力します。対話モードで実行すると、julia はプロンプトを表示し、入力を求めます。 ユーザーが 1 + 2 などの完全な式を入力し、enter キーが押されると、対話型セッションは式を評価し、その値を示します。後ろにセミコロンをつけて式を入力した場合には、評価結果は表示されません。変数 ans は、表示されているかどうかにかかわらず、最後に評価された式の値にバインドされます。ans 変数は対話型セッションでのみバインドされ、Julia コードが他の方法で実行される場合には使えません。","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"ソース ファイル file.jl に書かれた式を評価するには、`include(\"file.jl\") と書きます。","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"ファイル内のコードを非対話的に実行するには、julia コマンドの最初の引数としてファイル名を指定します:","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"$ julia script.jl arg1 arg2...","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"この例が示すように、julia に対する次のコマンドライン引数は、グローバル定数 ARGS に渡されるプログラム script.jl に対するコマンドライン引数として解釈されます。スクリプト自体の名前は、グローバル PROGRAM_FILE として渡されます。「ARGS」は、コマンドラインの-eオプションを使用して Julia 式が指定されている場合にも設定されますが(以下の「julia」ヘルプ出力を参照)、PROGRAM_FILE は空になります。たとえば、スクリプトに与えられた引数を表示するだけの場合は、次の操作を行います:","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar\n\nfoo\nbar","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"もしくは、そのコードをスクリプトファイルにして実行することもできます:","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' > script.jl\n$ julia script.jl foo bar\nscript.jl\nfoo\nbar","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"-- 区切り文字は、スクリプト ファイルを対象とするコマンド ライン引数を Julia 用の引数から分離するために使用できます:","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"$ julia --color=yes -O -- foo.jl arg1 arg2..","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"Julia スクリプトの作成の詳細については、スクリプトの作成も参照してください。","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"Julia は-p または --machine-file オプションを使用して並列モードで起動できます。-p n は追加で n個の ワーカー プロセスを起動し、--machine-file ファイル はファイル file の各行で示された個数のワーカーを起動します fileで定義されたマシンは２つの要求を満たしている必要があります。1. 現在のホストと同じパスにJuliaがインストールされていること、2. パスワードなしのsshログインでアクセス可能なこと。各マシン定義は、[count*][user@]host[:port] [bindaddr[:port]] の形式で行います。userはデフォルトで現在のユーザー、標準の ssh ポートへのportです。countはそのノードで起動するワーカーの数で、デフォルトは 1 です。オプションのbind-to bindaddr[:port]` は、他のワーカーがこのワーカーに接続するために使用する IP アドレスとポートを指定します。","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"Julia を実行するたびに実行させたい処理は、~/.julia/config/startup.jl に追記してください:","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"$ echo 'println(\"Greetings! 你好! 안녕하세요?\")' > ~/.julia/config/startup.jl\n$ julia\nGreetings! 你好! 안녕하세요?\n\n...","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"Julia コードの実行時オプションは様々で、perl プログラムと ruby プログラムで使用できるものと似ています:","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"julia [switches] -- [programfile] [args...]","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"スイッチ 説明\n-v, --version バージョン情報の表示\n-h, --help このメッセージを印刷する\n--project[={<dir>|@.}] <dir>をホーム プロジェクト/環境として設定します。デフォルトの@.オプションは、Project.toml または JuliaProject.toml ファイルが見つかるまで、親ディレクトリを検索します。\n-J, --sysimage <file> 特定のシステム イメージ ファイルを使用して起動\n-H, --ホーム<dir> Julia 実行可能ファイルの場所を設定\n--startup-file ={yes|no} yesを選択した場合、~/.julia/config/startup.jlを読み込む\n--handle-signals={yes|no} Juliatのデフォルトのシグナルハンドラを有効または無効にする\n---sysimage-native-code={yes|no} 使用可能な場合は、システム イメージからネイティブ コードを使用する\n--compiled-modules={yes|no} モジュールの増分プリコンパイルを有効または無効にする\n-e, --eval <expr> 式<expr>を評価する\n-E, --print <expr> 式<expr>を評価し、結果を表示\n-L, --load <file> すべてのプロセッサで file を読み込む\n-p, --procs {N|auto} 整数値 N 個の追加のローカル ワーカー プロセスを起動します。auto は、ローカル CPU スレッド (論理コア) の数と同じ数のワーカーを起動します。\n--machine-file <file> <file>にリストされているホストでプロセスを実行する\n-i インタラクティブモード;REPL が実行される。このとき、isinteractive() の戻り値はtrue となる\n-q, --quiet 静かなスタートアップ:バナーなし、REPL警告を抑制\n--banner={yes|no|auto} スタートアップ バナーを有効または無効にする\n--color={yes|no|auto} テキストの色を有効または無効にする\n--history-file={yes|no} 履歴の読み込みまたは保存\n--depwarn={yes|no|error} 非推奨の構文とメソッドを使用した際の警告を有効または無効にする (error は警告をエラーに変える)\n--warn-overwrite={yes|no} メソッドの上書き警告を有効または無効にする\n-C, --cpu-target <target> 使用するCPU 機能を <target>に制限する。 使用可能なオプションを表示するには <target>にhelp を設定して Juliaを実行してください。\n-O, --optimiza={0,1,2,3} 最適化レベルを設定する (不指定の場合はデフォルト レベルが 2、レベルなしで使用する場合は 3)\n-g, -g <level> デバッグ情報生成のレベルを有効/設定する (指定されていない場合はデフォルトレベルが 1、レベルなしで使用する場合は 2)\n--inline={yes|no} @inline 宣言のオーバーライドをも含み、インライン化が許可されるかどうかを制御する\n--check-bounds={yes|no} 境界チェックを常に行うか、常に無視するかの指定。(コード上の宣言は無視されます。)\n--math-mode={ieee,fast} 安全でない浮動小数点の最適化を許可または有効にする (ここで指定した値によって、@fastmath 宣言は上書きされます )\n--code-coverage={none|user|all} ソース行の実行数をカウントする\n--code-coverage --code-coverage=userを指定するのと等価\n--track-allocation={none|user|all} 各ソース行にで割り当てたメモリのバイト数をカウントする\n--track-allocation --track-allocation=userを指定するのと等価","category":"page"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"compat: Julia1.1\nJulia 1.0 では、デフォルトの --project=@. オプションはGitレポジトリのルートディレクトリからProject.tomlを探すことはしませんでした。 Julia1.1からは、行います。","category":"page"},{"location":"manual/getting-started.html#リソース-1","page":"はじめよう","title":"リソース","text":"","category":"section"},{"location":"manual/getting-started.html#","page":"はじめよう","title":"はじめよう","text":"新しいユーザーがJuliaを始めるのに役立つ学習リソースのキュレーションリストは、Juliaのメインウェブサイトのlearningページにあります。","category":"page"},{"location":"manual/variables.html#変数-1","page":"変数","title":"変数","text":"","category":"section"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"Julia の変数は、値に関連付けられた (またはバインド) 名前です。これは、後で使用するために(たとえば、いくつかの計算の後に取得した値)を格納する場合に便利です。例えば：","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"# Assign the value 10 to the variable x\njulia> x = 10\n10\n\n# Doing math with x's value\njulia> x + 1\n11\n\n# Reassign x's value\njulia> x = 1 + 1\n2\n\n# You can assign values of other types, like strings of text\njulia> x = \"Hello World!\"\n\"Hello World!\"","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"Julia は、変数の命名システムは非常に柔軟です。変数名は大文字と小文字を区別し、意味論的な区別はありません (つまり、つけられた名前の違いよってJulia が変数の扱いをかえることは有りません)。","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"julia> x = 1.0\n1.0\n\njulia> y = -3\n-3\n\njulia> Z = \"My string\"\n\"My string\"\n\njulia> customary_phrase = \"Hello world!\"\n\"Hello world!\"\n\njulia> UniversalDeclarationOfHumanRightsStart = \"人人生而自由，在尊严和权利上一律平等。\"\n\"人人生而自由，在尊严和权利上一律平等。\"","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"ユニコード (UTF-8 エンコーディング) をもちいた命名が可能です:","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"julia> δ = 0.00001\n1.0e-5\n\njulia> 안녕하세요 = \"Hello\"\n\"Hello\"","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"Julia REPL およびその他のいくつかの Julia 編集環境では、バックスラッシュ記号付きの LaTeX シンボル名を入力して、その後にタブを入力して、多くの Unicode 数学記号を入力できます。たとえば、変数名 δ は\\delta-tabで入力できますし、α̂₂ は \\alpha-tab-\\hat- tab-\\_2-tabで入力することができます。(もし例えば誰かのコードなどで、どのように入力すればよいかわからないシンボルを見つけた場合には、REPL のヘルプ機能が教えてくれます: ?を押した後に、そのシンボルをペースすればよいのです。）","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"Julia では、必要に応じて組み込みの定数と関数を再定義することもできます (ただし、混乱の元になるため避けることをお勧めします):","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"julia> pi = 3\n3\n\njulia> pi\n3\n\njulia> sqrt = 4\n4","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"ただし、既に使用中の組み込み定数または関数を再定義しようとすると、Julia によってエラーが発生します:","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"julia> pi\nπ = 3.1415926535897...\n\njulia> pi = 3\nERROR: cannot assign a value to variable MathConstants.pi from module Main\n\njulia> sqrt(100)\n10.0\n\njulia> sqrt = 4\nERROR: cannot assign a value to variable Base.sqrt from module Main","category":"page"},{"location":"manual/variables.html#利用可能な変数名-1","page":"変数","title":"利用可能な変数名","text":"","category":"section"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"変数名は、文字 (A から Z または a-z)、アンダースコア、ユニコードの一部で、符号位置が 00A0 より大きいもの、のいずれかで始まる必要があります。特にUnicode 文字カテゴリ Lu/Ll/Lt/Lm/Lo/Nl (文字)、Sc/So (通貨およびその他の記号)、およびいくつかの他の文字 (Sm 数学記号のサブセットなど)が利用できます。二文字目以降は ,!および数字 (0 から 9 およびカテゴリ Nd/No の他の文字) だけでなく、他の符号位置のユニコードでは発音記号およびその他の修飾記号(カテゴリ Mn/Mc/Me/Sk)、一部の句読点コネクタ (カテゴリ Pc)、プライムおよびその他のいくつかの文字が利用可能です。","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"+ のような演算子も有効な識別子ですが、構文解析のされ方が特殊です。演算子は変数とおなじように扱われることもあります。たとえば、(+) は加算関数を表しますが、(+) = f のように代入もできます。Unicode の二項演算子 (カテゴリ Sm) のほとんどは、二項演算子として解析され、ユーザー定義のメソッドで使用できます (たとえば、const ⊗= kron を使用して⊗ を中置記法のクロネッカー積として定義できます)。 演算子は、修飾記号、プライム、および下付・上付文字をつけることができます。(例: +̂ₐ″は+ と同じ優先順位を持つ二項演算子として解析されます。","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"明示的に禁止されている変数名は、組み込みの予約語だけです:","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"julia> else = false\nERROR: syntax: unexpected \"else\"\n\njulia> try = \"No\"\nERROR: syntax: unexpected \"=\"","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"一部の Unicode 文字は、識別子として同等に扱われます。 文字を組み合わせた Unicode の結合文字 (アクセントなど) に対する異なる入力方法は同等のものとして扱われます (具体的には、Julia 識別子は NFC 正規化されます)。 Unicode 文字 ε (U+025B: ラテン語の小文字オープン e) と μ (U+00B5: ミクロ記号) は対応するギリシャ文字と同等として扱われます。前者がいくつかの入力方法を介して簡単にアクセスできるためです。","category":"page"},{"location":"manual/variables.html#文体上の慣習-1","page":"変数","title":"文体上の慣習","text":"","category":"section"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"Juliaの妥当な名前にはほとんど制限がありませんが、以下のような慣習に従うと役立つでしょう:","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"変数名を小文字にする。\n語句の区切るときに、アンダースコア(_)を利用してもよい。しかし、アンダースコア無しで読みづらくなるのでなければ、使わない。\n型 と モジュール の名前は大文字で始め、単語の区切りはアンダースコアの代わりにアッパーキャメルケース(単語の最初の文字を大文字にする)を使う。\n関数 と マクロ の名前は、アンダースコアなしの小文字。\n引数の内容を変更する関数は名前の最後に!をつける。こういった関数は時折、「変異(mutating)」「上書き(in-place)」関数とよばれます。 これは，関数が呼び出された後、単に値を返すだけでなく、引数に対して変化を起こそうとするからです。","category":"page"},{"location":"manual/variables.html#","page":"変数","title":"変数","text":"文体規約の詳細については、「スタイルガイド」(@ref)をご覧ください。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#integers-and-floating-point-numbers-1","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"整数と浮動小数点の値は、算術と計算の基本的な構成要素です。 このような値の組み込み表現は数値プリミティブと呼ばれ、コード内の即時値としての整数と浮動小数点数の表現は数値リテラルと呼ばれます。 たとえば、1 は整数リテラルで、1.0 は浮動小数点リテラルです。オブジェクトとしてのバイナリインメモリ表現は数値プリミティブです。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"Julia では、様々なプリミティブ数値型を提供され、そのそれぞれの型に対して、標準的な数学関数と同様に、算術演算子とビット演算子が定義されています。これら数値型や演算は、最新のコンピュータでネイティブにサポートされている数値型と演算に直接対応付けられているため、Julia は計算リソースを最大限に活用できます。さらに、Julia は任意精度演算をソフトウェア的にサポートしており、ネイティブなハードウェア表現では表現できない数値の演算を扱えますが、パフォーマンスは比較的遅くなってしまいます。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"Juliaのプリミティブ数値型を次に示します:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"整数型:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"型 符号の有無 ビット数 最小値 最大値\nInt8 ✓ 8 -2^7 2^7 - 1\nUInt8  8 0 2^8 - 1\nInt16 ✓ 16 -2^15 2^15 - 1\nUInt16  16 0 2^16 - 1\nInt32 ✓ 32 -2^31 2^31 - 1\nUInt32  32 0 2^32 - 1\nInt64 ✓ 64 -2^63 2^63 - 1\nUInt64  64 0 2^64 - 1\nInt128 ✓ 128 -2^127 2^127 - 1\nUInt128  128 0 2^128 - 1\nBool N/A 8 false (0) true (1)","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"浮動小数点型:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"型 精度 ビット数\nFloat16 half 16\nFloat32 single 32\nFloat64 double 64","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"さらに、これらのプリミティブ数値型を用いて、Juliaは 複素数と有理数 に完全対応しています。すべての数値型は明示的なキャストなしで自然に相互運用されます。これは柔軟でユーザーが拡張可能な 型昇格システムのおかげです。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#整数-1","page":"整数と浮動小数点数","title":"整数","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"整数リテラルは、標準的な方法で表現できます:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> 1\n1\n\njulia> 1234\n1234","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"整数リテラルのデフォルトの型は、ターゲット・システムが 32 ビット・アーキテクチャーと 64 ビット・アーキテクチャーのどちらであるかによって異なります:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"# 32-bit system:\njulia> typeof(1)\nInt32\n\n# 64-bit system:\njulia> typeof(1)\nInt64","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"Julia の内部変数 Sys.WORD_SIZE を見ると、ターゲット・システムが 32 ビットか 64 ビットかがわかります:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"# 32-bit system:\njulia> Sys.WORD_SIZE\n32\n\n# 64-bit system:\njulia> Sys.WORD_SIZE\n64","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"Julia には、システムの符号付きネイティブ整数型と符号なしネイティブ整数型のエイリアスである Int 型と UInt がそれぞれ定義されています:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"# 32-bit system:\njulia> Int\nInt32\njulia> UInt\nUInt32\n\n# 64-bit system:\njulia> Int\nInt64\njulia> UInt\nUInt64","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"大きな整数リテラルで、32 ビットのみを使用して表すことができず、64 ビットで表すことができるものに対しては、システムの種類に関係なく、常に 64 ビットの整数が生成されます:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"# 32-bit or 64-bit system:\njulia> typeof(3000000000)\nInt64","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"符号なしの整数の入出力には、0x プレフィックスを持つ16進数の数字 0-9a-f (大文字の数字 A-F も利用可能)を使います。符号なしの値のサイズは、使用する16進数の桁数で決まります:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> 0x1\n0x01\n\njulia> typeof(ans)\nUInt8\n\njulia> 0x123\n0x0123\n\njulia> typeof(ans)\nUInt16\n\njulia> 0x1234567\n0x01234567\n\njulia> typeof(ans)\nUInt32\n\njulia> 0x123456789abcdef\n0x0123456789abcdef\n\njulia> typeof(ans)\nUInt64\n\njulia> 0x11112222333344445555666677778888\n0x11112222333344445555666677778888\n\njulia> typeof(ans)\nUInt128","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"こうした振る舞いは、符号なし整数の16進リテラルを使用する場合、通常は、単なる整数値というよりは、固定長バイト列として使われることが多いだろうという考察に基づいています。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"変数 ans には、対話型セッションで最後に評価された式の値が格納されていることを思い出してください。これは、Julia コードが対話セッション以外の他の方法で実行されている場合にはあてはまりません。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"2進数・8進数リテラルにも対応しています:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> 0b10\n0x02\n\njulia> typeof(ans)\nUInt8\n\njulia> 0o010\n0x08\n\njulia> typeof(ans)\nUInt8\n\njulia> 0x00000000000000001111222233334444\n0x00000000000000001111222233334444\n\njulia> typeof(ans)\nUInt128","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"16進・2進・8進リテラルに対しては、符号なし整数型が生成されます。リテラルの先頭桁を 0 で埋めない場合、バイナリ データのサイズは必要最小限のサイズになります。先頭にゼロが付加されている場合、その先頭の桁が1である同じ桁数のリテラルに必要な最小サイズになります。これにより、ユーザーはデータのサイズを制御できます。 UInt128 に格納できない値は、このようなリテラルとして記述できません。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"2進・8進・16進リテラルは、リテラルの直前に - の符号をつけることができます。この場合生成されるのは、符号を付ける前の数とサイズの等しい符号なしの整数で、元の数の2の補数表現になります:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> -0x2\n0xfe\n\njulia> -0x0002\n0xfffe","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"整数などのプリミティブ数値型の最小・最大値は、typemin 関数と typemax 関数によって得られます:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> (typemin(Int32), typemax(Int32))\n(-2147483648, 2147483647)\n\njulia> for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]\n           println(\"$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]\")\n       end\n   Int8: [-128,127]\n  Int16: [-32768,32767]\n  Int32: [-2147483648,2147483647]\n  Int64: [-9223372036854775808,9223372036854775807]\n Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]\n  UInt8: [0,255]\n UInt16: [0,65535]\n UInt32: [0,4294967295]\n UInt64: [0,18446744073709551615]\nUInt128: [0,340282366920938463463374607431768211455]","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"typeminとtypemaxによって返される値は、この関数に引数として与えられた型の数値になります。(上記の式では、for ループ、文字列、式展開など、まだ紹介していない機能をいくつか使用していますが、プログラミング経験を持つユーザーにとっては十分に理解できるものでしょう。)","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#オーバーフロー時の動作-1","page":"整数と浮動小数点数","title":"オーバーフロー時の動作","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"Julia では、その型で表現可能な値の範囲を超えると、ラップアラウンド(循環)が発生します:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> x = typemax(Int64)\n9223372036854775807\n\njulia> x + 1\n-9223372036854775808\n\njulia> x + 1 == typemin(Int64)\ntrue","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"したがって、Julia の整数型での演算は、実際には モジュラー演算の一形態です。 これは、現代のコンピュータに実装されている整数の基礎となる算術演算の特徴を反映しています。オーバーフローが起こり得るアプリケーションでは、オーバーフローによって生成されるラップアラウンドを明示的にチェックすることが不可欠です。そうでなければ、代わりに任意精度演算のBigInt型を使用することをお勧めします。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#除算エラー-1","page":"整数と浮動小数点数","title":"除算エラー","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"整数除算 (div 関数) には 2つの例外的なケースがあります。一つは、0 除算、もうひとつは、最小の負の数 (typemin) の -1 除算です。どちらの場合もDivideErrorをスローします。 また、剰余関数 (rem と mod) は、2 番目の引数がゼロの場合に DivideErrorをスローします。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#浮動小数点数-1","page":"整数と浮動小数点数","title":"浮動小数点数","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"浮動小数点リテラルは、必要に応じてe-表記を使用して、標準フォーマットで表記されます:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> 1.0\n1.0\n\njulia> 1.\n1.0\n\njulia> 0.5\n0.5\n\njulia> .5\n0.5\n\njulia> -1.23\n-1.23\n\njulia> 1e10\n1.0e10\n\njulia> 2.5e-4\n0.00025","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"上記の結果はすべて Float64 値です。リテラル Float32 値は、e の代わりに f を書くことによって入力できます:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> 0.5f0\n0.5f0\n\njulia> typeof(ans)\nFloat32\n\njulia> 2.5f-4\n0.00025f0","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"値はFloat32に簡単に変換できます:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> Float32(-1.5)\n-1.5f0\n\njulia> typeof(ans)\nFloat32","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"16進表記の浮動小数点リテラルも有効ですが、基数2の指数の前に p をつけて利用し、値は Float64になります:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> 0x1p0\n1.0\n\njulia> 0x1.8p3\n12.0\n\njulia> 0x.4p-1\n0.125\n\njulia> typeof(ans)\nFloat64","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"半精度浮動小数点数(Float16)もサポートされていますが、これはソフトウェアで実装され、計算に Float32 を使用します。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> sizeof(Float16(4.))\n2\n\njulia> 2*Float16(4.)\nFloat16(8.0)","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"アンダースコア _ は、数字区切り文字として使用できます:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010\n(10000, 5.0e-9, 0xdeadbeef, 0xb2)","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#浮動小数点-の0-1","page":"整数と浮動小数点数","title":"浮動小数点 の0","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"浮動小数点数には正と負2 つのゼロがあります。これらは互いに等しい値ですが、異なる2進数表現を持っています。bitstring 関数で確認することができます:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> 0.0 == -0.0\ntrue\n\njulia> bitstring(0.0)\n\"0000000000000000000000000000000000000000000000000000000000000000\"\n\njulia> bitstring(-0.0)\n\"1000000000000000000000000000000000000000000000000000000000000000\"","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#special-floating-point-values-1","page":"整数と浮動小数点数","title":"特殊な浮動小数点の値","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"浮動小数点の値で実数の数直線上のどの点にも対応しない値が3つあります:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"Float16 Float32 Float64 名前 説明\nInf16 Inf32 Inf 正の無限大 すべての有限の浮動小数点数よりも大きい値\n-Inf16 -Inf32 -Inf 負の無限大 すべての有限の浮動小数点よりも小さい値\nNaN16 NaN32 NaN 非数 どんな浮動小数点数とも ==の成り立たない値 (自分自身とも)","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"これら非有限の浮動小数点値を互いにどのように順序付けされるかについての詳細は、数値の比較を参照してください。IEEE 754 規格では、これらの浮動小数点数の値は特定の算術演算の結果として得られます:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> 1/Inf\n0.0\n\njulia> 1/0\nInf\n\njulia> -5/0\n-Inf\n\njulia> 0.000001/0\nInf\n\njulia> 0/0\nNaN\n\njulia> 500 + Inf\nInf\n\njulia> 500 - Inf\n-Inf\n\njulia> Inf + Inf\nInf\n\njulia> Inf - Inf\nNaN\n\njulia> Inf * Inf\nInf\n\njulia> Inf / Inf\nNaN\n\njulia> 0 * Inf\nNaN","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"typemin関数とtypemax関数は浮動小数点型にも適用できます:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> (typemin(Float16),typemax(Float16))\n(-Inf16, Inf16)\n\njulia> (typemin(Float32),typemax(Float32))\n(-Inf32, Inf32)\n\njulia> (typemin(Float64),typemax(Float64))\n(-Inf, Inf)","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#マシンイプシロン-1","page":"整数と浮動小数点数","title":"マシンイプシロン","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"ほとんどの実数は浮動小数点数で正確に表現することができないため、多くの目的で、2つの隣接する浮動小数点数の間の距離を知ることは重要なことです。これは、マシンイプシロン として知られています。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"Julia では eps 関数で、各数値型を引数にとり、その型においての 1.0 という値と、その値の次に大きな浮動小数点数の間の距離を得ることができます:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> eps(Float32)\n1.1920929f-7\n\njulia> eps(Float64)\n2.220446049250313e-16\n\njulia> eps() # same as eps(Float64)\n2.220446049250313e-16","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"これらの値、2.0^-23と2.0^-52はそれぞれ Float32とFloat64の値です。eps 関数は、引数として浮動小数点数も受け取ることができ、その値と次に表される浮動小数点値との差の絶対値を返します。つまりeps(x) は x と同じ型の値を生成し、x + eps(x) は x より大きい次に表される浮動小数点値になります:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> eps(1.0)\n2.220446049250313e-16\n\njulia> eps(1000.)\n1.1368683772161603e-13\n\njulia> eps(1e-27)\n1.793662034335766e-43\n\njulia> eps(0.0)\n5.0e-324","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"隣接する 2 つの 表現可能な浮動小数点数の間の距離は一定ではなく、その距離は元の値が小さいほど小さくなり、大きいほど大きくなります。つまり、表現可能な浮動小数点数の数直線は0付近で最も密度が高く、0から遠ざかるにつれて指数関数的に疎になります。定義上、1.0 は 64 ビット浮動小数点数であるため、eps(1.0) とeps(Float64)は同じになります。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"Julia はまた、 nextfloat関数とprevfloat関数を提供します。これらはそれぞれ、引数の値に対して、その型で表現可能な、次に大きな値、次に小さな値を返します:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> x = 1.25f0\n1.25f0\n\njulia> nextfloat(x)\n1.2500001f0\n\njulia> prevfloat(x)\n1.2499999f0\n\njulia> bitstring(prevfloat(x))\n\"00111111100111111111111111111111\"\n\njulia> bitstring(x)\n\"00111111101000000000000000000000\"\n\njulia> bitstring(nextfloat(x))\n\"00111111101000000000000000000001\"","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"この例では、隣接する表現可能な浮動小数点数は、2進数表現でもおなじく隣接する、という一般的な原則を示しています。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#丸めモード-1","page":"整数と浮動小数点数","title":"丸めモード","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"浮動小数点で正確に表現できない数は、適切な表現可能な値に丸める必要があります。丸め処理の方法は、IEEE 754 規格に複数のモードが示されており、必要に応じてそのモードを変更することができます。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"デフォルトの丸めモードは、常に RoundNearest(最近接丸め)で、これは、最も近い表現可能な値に丸める方法で、仮に最近接の表現可能な数が2つある場合には、最下位ビットが偶数になるように丸めます。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#背景と参照-1","page":"整数と浮動小数点数","title":"背景と参照","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"浮動小数点演算には、低レベルの実装の詳細に慣れていないユーザーが驚くような多くの微妙な点がたくさんあります。ただし、これらの微妙な点は、科学計算に関する多くの書籍や下記の資料で詳しく説明されています:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"浮動小数点演算の最も信頼のおけるガイドは、IEEE 754-2008規格です。ただしオンライン・無料での利用はできません。\n浮動小数点数の表現について完結だが明快な解説として、John D.Cook'の記事を参照のこと。イントロダクションでは、浮動小数点数と理想化された抽象的な実数との乖離から生じる問題について書かれています。\nまた、Bruce Dawsonの浮動小数点数に関する一連のブログ記事もお勧めします。\n浮動小数点数と及び、浮動小数点数を用いた演算で遭遇する数値精度の問題についての詳細な議論については、David Goldbergの論文What Every Computer Scientists Should Know Aboutを参照してください。\n浮動小数点数の歴史、理論、問題、および数値計算における他の多くのトピックの議論について、さらに広く扱った文書については、「浮動小数点の父」として知られているWilliam Kahanの 著作集を参照してください。特に興味深いのは「浮動小数点の老人のインタビュー」(https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html)です。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#arbitrary-precision-arithmetic-1","page":"整数と浮動小数点数","title":"任意精度演算","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"任意精度の整数と浮動小数点数を使用した計算を可能にするために、Julia はGNU Multiple Precision Arithmetic Library(GMP)とGNU MPFR Libraryをラップしています。BigIntとBigFloatは、それぞれ任意の精度整数と浮動小数点数でJuliaで使用できます。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"コンストラクターは、プリミティブな数値型からこれらの型を作成するために存在し、parseはAbstractStringからそれらを構築するために使用することができます。一度こうして値を生成したら、他のすべての数値型との演算が可能です。これは Juliaの型昇格と変換メカニズムによって実現されています:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> BigInt(typemax(Int64)) + 1\n9223372036854775808\n\njulia> parse(BigInt, \"123456789012345678901234567890\") + 1\n123456789012345678901234567891\n\njulia> parse(BigFloat, \"1.23456789012345678901\")\n1.234567890123456789010000000000000000000000000000000000000000000000000000000004\n\njulia> BigFloat(2.0^66) / 3\n2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19\n\njulia> factorial(BigInt(40))\n815915283247897734345611269596115894272000000000","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"ただし、プリミティブ型と BigIntやBigFloat との型昇格は自動には行われず、明示的に記述する必要があります。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> x = typemin(Int64)\n-9223372036854775808\n\njulia> x = x - 1\n9223372036854775807\n\njulia> typeof(x)\nInt64\n\njulia> y = BigInt(typemin(Int64))\n-9223372036854775808\n\njulia> y = y - 1\n-9223372036854775809\n\njulia> typeof(y)\nBigInt","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"BigFloat 演算でのデフォルトの精度と丸めモードは、setprecisionやsetroundingを使ってグローバルに変更することができます。その後の全ての計算で、この変更の影響を受けます。もしくは、do ブロックでそれらの関数を使用し、そのコードブロック内でのみ精度や丸めモードを変更することも可能です:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> setrounding(BigFloat, RoundUp) do\n           BigFloat(1) + parse(BigFloat, \"0.1\")\n       end\n1.100000000000000000000000000000000000000000000000000000000000000000000000000003\n\njulia> setrounding(BigFloat, RoundDown) do\n           BigFloat(1) + parse(BigFloat, \"0.1\")\n       end\n1.099999999999999999999999999999999999999999999999999999999999999999999999999986\n\njulia> setprecision(40) do\n           BigFloat(1) + parse(BigFloat, \"0.1\")\n       end\n1.1000000000004","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#man-numeric-literal-coefficients-1","page":"整数と浮動小数点数","title":"数値リテラル係数","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"一般的な数式・式を明確にするために、Julia では変数の直前に数値リテラルを付けることで乗算を表すことができます。これにより、多項式の記述がはるかにクリーンになります:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> x = 3\n3\n\njulia> 2x^2 - 3x + 1\n10\n\njulia> 1.5x^2 - .5x + 1\n13.0","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"また、指数関数の記述もエレガントになります:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> 2^2x\n64","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"数値リテラル係数の優先順位は、否定などの単項演算子よりもわずかに低くなります。 したがって、-2x は (-2) * x と √2x は (√2) * x として解析されます。 ただし、数値リテラル係数は、指数関数と組み合わせると、単項演算子と同様に解析されます。 たとえば、2^3x は 2^(3x) として解析され、2x^3 は 2*(x^3) として解析されます。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"数値リテラルは、括弧付き式に対する係数としても機能します:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> 2(x-1)^2 - 3(x-1) + 1\n3","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"!!!メモ     暗黙的な乗算に使用される数値リテラル係数の優先順位は     乗算(*)、および除算 (/、\\、および //) などの他の二項演算子よりも高くなります。     これは、例えば、1 / 2im は -0.5im に等し、6 // 2(2+ 1) は 1 // 1に等しくなります。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"さらに、括弧付き式は変数への係数として使用でき、式と変数の掛け算とすることができます:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> (x-1)x\n6","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"ただし、2 つの括弧式の並べておいたり、括弧式の前に変数を配置しても、乗算とはみなされません:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> (x-1)(x+1)\nERROR: MethodError: objects of type Int64 are not callable\n\njulia> x(x+1)\nERROR: MethodError: objects of type Int64 are not callable","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"括弧式を並べる場合も、括弧式の直前に変数を置いた時も、関数の適応として解釈されます: 数値リテラルではない式の直後に括弧を付けると、括弧内の値に適用される関数として解釈されます (関数についての詳細は、関数の項を参照してください)。したがって、いずれの場合も、左側の値が関数ではないため、エラーが発生します。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"このような構文機能の強化により、一般的な数式を記述するときに発生する視覚的なノイズが大幅に低減されます。数値リテラル係数と、乗算する識別子または括弧式の間に空白が生じないことに注意してください。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#構文の競合-1","page":"整数と浮動小数点数","title":"構文の競合","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"リテラル係数を２つ並べる構文と競合するかもしれない２つの数値リテラル構文があります:16進整数リテラル と浮動小数点リテラルの指数表記です。構文上の競合が発生する状況を以下のようなものです:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"16進整数値 0xff は、数値リテラル 0 と変数 xff の掛け算と解釈できる。\n浮動小数点リテラル 1e10 は、数値リテラル 1と 変数 e10 の掛け算と解釈できる。E形式も同様。\n32 ビット浮動小数点リテラル 1.5f22 は、数値リテラル1.5 と 変数 f22 の掛け算と解釈できる。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"どの場合についても、数値リテラルとしての解釈を優先して解決されます。つまり:","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"0x で始まる式は、常に16進数リテラルです。\n数値リテラルで始まり、e または E が続く式は、常に浮動小数点リテラルです。\n数値リテラルで始まり、f が続く式は、常に 32 ビット浮動小数点リテラルです。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"歴史的な理由から数値リテラルの e に相当する E とは異なり、F は単なる文字であり、数値リテラルでは f のように動作しません。したがって、数値リテラルで始まりFが続く式は、数値リテラルに変数を掛けたものとして解釈され、例えば1.5F22は`1.5","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"F22`に等しいことを意味します。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#と1のリテラル-1","page":"整数と浮動小数点数","title":"0と1のリテラル","text":"","category":"section"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"Julia は、指定された型または特定の変数の型に対応するリテラル 0 と 1 を返す関数を提供します。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"関数 説明\nzero(x) 型 x もしくは 変数 xと同じ型を持つリテラル0\none(x) 型 x もしくは 変数 xと同じ型を持つリテラル1","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"これらの関数は、数値比較の際に、不要な 型変換 のオーバーヘッドを回避するのに役立ちます。","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"例：","category":"page"},{"location":"manual/integers-and-floating-point-numbers.html#","page":"整数と浮動小数点数","title":"整数と浮動小数点数","text":"julia> zero(Float32)\n0.0f0\n\njulia> zero(1.0)\n0.0\n\njulia> one(Int32)\n1\n\njulia> one(BigFloat)\n1.0","category":"page"},{"location":"manual/mathematical-operations.html#mathematical-operations-and-elementary-functions-1","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"Julia には、すべての数値プリミティブ型に対して基本的な算術演算子とビット演算子を一通り揃えています。また、移植性の高い、効率的な実装の標準的な数学関数も揃えています。","category":"page"},{"location":"manual/mathematical-operations.html#算術演算子-1","page":"算術演算と初等関数","title":"算術演算子","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"次の 算術演算子は、すべてのプリミティブ数値型でサポートされています:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"式 名前 説明\n+x 単項加算 恒等演算\n-x 単項減算 加算の逆元への写像\nx + y 二項加算 加算を実行\nx - y 二項減算 減算を実行\nx * y 乗算 乗算を実行\nx / y 除算 除算を実行\nx ÷ y 整数除算 x / y, 整数に切り捨て\nx \\ y 逆除算 y / xと同等\nx ^ y 累乗 x の y乗\nx % y 剰余算 rem(x,y)と同等","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"Boolタイプの否定も同様です:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"式 名前 説明\n!x 否定 true と false を逆にする","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"Julia の昇格システムは、異なる型の引数型が混在した算術演算を自然かつ自動的うまく動作させます。昇格システムの詳細については、変換と昇格を参照してください。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"算術演算子を使用した簡単な例を次に示します:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> 1 + 2 + 3\n6\n\njulia> 1 - 2\n-1\n\njulia> 3*2/12\n0.5","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"(慣習的に周りの他の演算子より先に演算を行う演算では空白を詰めることがよくあります。たとえば、-x + 2 と書くのは、最初の x に-1をかけてから2 を足すことを反映しています。)","category":"page"},{"location":"manual/mathematical-operations.html#ビット演算子-1","page":"算術演算と初等関数","title":"ビット演算子","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"次の ビット演算子は、すべてのプリミティブ整数型でサポートされています:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"式 名前\n~x 否定(not)\nx & y 論理積(and)\nx | y 論理和(or)\nx ⊻ y 排他的論理和(xor)\nx >>> y 右論理シフト\nx >> y 右算術シフト\nx << y 左 論理/算術シフト","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"ビット演算子を使用例を下記の通りです:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> ~123\n-124\n\njulia> 123 & 234\n106\n\njulia> 123 | 234\n251\n\njulia> 123 ⊻ 234\n145\n\njulia> xor(123, 234)\n145\n\njulia> ~UInt32(123)\n0xffffff84\n\njulia> ~UInt8(123)\n0x84","category":"page"},{"location":"manual/mathematical-operations.html#代入演算子-1","page":"算術演算と初等関数","title":"代入演算子","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"すべての二項演算子・ビット演算子では、操作の結果を左の演算子に代入するバージョンの演算子が存在します。二項演算子の代入バージョンは、元の演算子の直後に = をつけます。たとえば、x += 3 はx = x + 3 を書くのと同じです:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> x = 1\n1\n\njulia> x += 3\n4\n\njulia> x\n4","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"すべての二項算術演算子とビット演算子の代入バージョンは以下のとおりです:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"+=  -=  *=  /=  \\=  ÷=  %=  ^=  &=  |=  ⊻=  >>>=  >>=  <<=","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"note: Note\n代入演算子は、左辺側変数に再バインドを行います。結果、変数の方が変わることもあります。julia> x = 0x01; typeof(x)\nUInt8\n\njulia> x *= 2 # Same as x = x * 2\n2\n\njulia> typeof(x)\nInt64","category":"page"},{"location":"manual/mathematical-operations.html#man-dot-operators-1","page":"算術演算と初等関数","title":"ベクトル化した\"ドット\"演算子","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"全ての ^ のような二項演算子には、配列の各要素に対して ^を実行するドット演算子 .^が自動的に定義されます。たとえば、[1,2,3] ^ 3 は定義されていません。非正方の配列の3乗は数学的に意味を成さないからです。しかし、[1,2,3] .^ 3 は要素毎の計算として定義され、その結果は[1^3,2^3, 3^3]となります。同様に、! や √ のような単項演算子の場合も、演算子を要素的に適用する対応する .√ があります。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> [1,2,3] .^ 3\n3-element Array{Int64,1}:\n  1\n  8\n 27","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"具体的には、a.^ b は\"ドット\"呼び出し(^).(a,b)として解析されます。これは、ブロードキャスト 操作を実行します: 配列とスカラー、同一サイズの配列2つ(要素ごとの演算子適用)そして、異なるサイズの配列(例えば、行ベクトルと列ベクトルの積)でさえも組み合わせ利用できます。さらに、すべてのベクトル化された\"ドットコール\"と同様に、これらの「ドット演算子」は融合的です。たとえば、配列Aに対して 2 .* A.^2 .+ sin(A) (もしくは、@ マクロを使用して@. 2A^2 + sin(A)とも書けますが)を計算する時、Aの要素に関するループを1回実行し2a^2 + sin(a) を各要素に対して計算します。特に、f.(g.(x)) のような入れ子になったドットコールは融合され、x.+ 3 .* x.^2 のような \"隣接する\" 二項演算子は入れ子になったドットコール (+) .(x, (*).(3,(^).(x, 2)))と等価になります。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"さらに、a.+= b (または @. a += b) のような \"ドットのついた\" 代入演算子は a= a .+ b として解析され、.= は融合された インプレース 代入となります (ドット構文ドキュメントを参照してください)。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"ドット構文は、ユーザーが定義した演算子にも適用できます。 たとえば、クローネッカー積(kron)に便利なイン二項演算構文 A ⊗ Bを使うために⊗(A,B) = kron(A,B) を定義した場合 、[A,B] .⊗[C,D] は追加のコーディングなしで [A⊗B, B⊗D] を計算します。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"ドット演算子と数値リテラルの組み合わせがあいまいになる場合があります。 たとえば、1.+x が 1. +x と 1 .+ xのどちらを意味するかは自明ではありません。したがって、この構文は許可されず、このような場合は演算子の周囲にスペースを使用する必要があります。","category":"page"},{"location":"manual/mathematical-operations.html#numeric-comparisons-1","page":"算術演算と初等関数","title":"数値比較","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"すべてのプリミティブ数値型に対して標準的な比較演算子が定義されています:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"演算子 名前\n== 等号\n!=, ≠ inequality\n< 未満\n<=, ≤ 以下\n> より大きい\n>=, ≥ 以上","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"簡単な例を次に示します:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> 1 == 1\ntrue\n\njulia> 1 == 2\nfalse\n\njulia> 1 != 2\ntrue\n\njulia> 1 == 1.0\ntrue\n\njulia> 1 < 2\ntrue\n\njulia> 1.0 > 3\nfalse\n\njulia> 1 >= 1.0\ntrue\n\njulia> -1 <= 1\ntrue\n\njulia> -1 <= -1\ntrue\n\njulia> -1 <= -2\nfalse\n\njulia> 3 < -0.5\nfalse","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"整数は、標準的なビットの比較の方法で比較されます。浮動小数点数はIEEE 754標準に従って比較されます:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"有限数は通常の方法で順序付けされます。\n正のゼロは負のゼロと等しく、負のゼロより大きくはない。\nInf はそれ自体と等しく、NaN を除く他のすべてよりも大きい。\n-Inf はそれ自体に等しく、NaN を除く他のすべての数より小さい。\n「NaN」は、それ自体を含め、何とも等しくなく、大きくも小さくもない。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"最後のポイントは、ひょっとすると驚くべきことであり、したがって注目に値します:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> NaN == NaN\nfalse\n\njulia> NaN != NaN\ntrue\n\njulia> NaN < NaN\nfalse\n\njulia> NaN > NaN\nfalse","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"また、配列 では頭痛の種になりえます:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> [1 NaN] == [1 NaN]\nfalse","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"Julia では、特殊な値を検査する補助的な関数が提供されており、ハッシュ キーの比較などで役立ちます:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"関数 検査内容\nisequal(x, y) x と y が等しいか\nisfinite(x) x は有限であるか\nisinf(x) x は無限大であるか\nisnan(x) x is NaNであるか","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"isequal は NaN を互いに等しいと見なします:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> isequal(NaN, NaN)\ntrue\n\njulia> isequal([1 NaN], [1 NaN])\ntrue\n\njulia> isequal(NaN, NaN32)\ntrue","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"isequal は、符号付きゼロを区別するためにも使用できます:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> -0.0 == 0.0\ntrue\n\njulia> isequal(-0.0, 0.0)\nfalse","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"符号付き整数、符号なし整数、および浮動小数点数が混在する比較は、難しい場合があります。Julia が正しい比較を行うために、多くの注意が払われてきました。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"他の型については、isequal はデフォルトで == を呼び出すので、独自の型の等価性を定義する場合は、== メソッドを追加するだけで済みます。 さらに、isequal(x,y) が Trueとなる時に hash(x) == hash(y)でもあることを保証したいのであれば、対応する hash メソッドも定義しなければいけないでしょう。","category":"page"},{"location":"manual/mathematical-operations.html#比較の連鎖-1","page":"算術演算と初等関数","title":"比較の連鎖","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"ほとんどの言語とは異なり、Julia は比較を任意に連鎖させることができます。(ほとんどの言語と言いましたが、なんとPythonは比較の連鎖ができます。)","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5\ntrue","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"比較の連鎖は数値計算のコードで大変便利に使えることが多いです。比較の連鎖では、スカラー比較には && 演算子を使い、配列に対する要素毎の比較には & 演算子を使います。たとえば、0 .<A.<1は、配列Aの要素で0 と 1 の間にある要素に対応する位置の要素がtrueであるような真偽値の配列を返します。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"比較連鎖の振る舞いに注意してください:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> v(x) = (println(x); x)\nv (generic function with 1 method)\n\njulia> v(1) < v(2) <= v(3)\n2\n1\n3\ntrue\n\njulia> v(1) > v(2) <= v(3)\n2\n1\nfalse","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"真ん中の式は、v(1) < v(2) && v(2) <= v(3) と書かれてた場合のように2回評価されるのではなく、1回だけ評価されています。ただし、比較連鎖の中での評価の順序は未定義です。(printなどの)副作用のある表現を使用しないことを強くお勧めします。もし副作用が必要な場合は、短絡演算子 && を明示的に使用する必要があります(参照: 短絡評価)。","category":"page"},{"location":"manual/mathematical-operations.html#elementary-functions-1","page":"算術演算と初等関数","title":"初等関数","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"Juliaは一通りの数学関数と算術演算を提供します。これらの算術演算は、その意味をなす限り、整数、浮動小数点数、有理数、複素数など様々な数値クラスに対して定義されています。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"さらに、これらの関数は(他のJulia関数と同様に)、「ベクトル化」した形で配列やその他のコレクションに対して適用することができます。その際には、dot構文f.(A)を使い、例えば sin.(A)は配列Aの各要素に対してsinの値を適用します。","category":"page"},{"location":"manual/mathematical-operations.html#operator-precedence-and-associativity-1","page":"算術演算と初等関数","title":"演算子の優先順位と結合則","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"Julia では、下記の優先順位と結合則で、上から下へと演算子が適用されます:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"種別 演算子 結合則\n構文 まずは. 次に :: 左\n累乗 ^ 右\n単項演算子 + - √ 右[1]\nシフト << >> >>> 左\n分数 // 左\n乗算 * / % & \\ ÷ 左[2]\n加算 + - | ⊻ 左[2]\n構文 : .. 左\n構文 |> 左\n構文 <| 右\n比較 > < >= <= == === != !== <: 非結合\n制御 まずは && その次に || そして ? 右\n対 => 右\n代入 = += -= *= /= //= \\= ^= ÷= %= |= &= ⊻= <<= >>= >>>= 右","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"[1]: 単項演算子 + と - には、明示的に括弧をつけて、++などの演算子との曖昧性を排除する必要があります。他の単項演算子の結合は右結合として解析される。例えば、√√-a は √(√(-a))と解釈されます。.","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"[2]: 演算子 +, ++, * は、非結合的です。つまり a + b + c は +(+(a, b),c)ではなく、+(a, b, c) と解析されます。ただし、　フォールバックメソッドの+(a, b, c, d...) や *(a, b, c, d...) はどちらもデフォルトでは左結合で評価されます。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"Julia における 全ての 演算子の優先順位の完全なリストは、このファイルの上部を参照してください: src/julia-parser.scm","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"また、組み込み関数 Base.operator_precedence を使用して、特定の演算子の数値の優先順位をつきとめることもできます:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)\n(11, 13, 17)\n\njulia> Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)\n(0, 1, 1)","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"演算子を表すシンボルの結合則も組み込み関数 Base.operator_associaivity を呼び出すことによっても見つけることができます:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)\n(:left, :none, :right)\n\njulia> Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)\n(:left, :none, :right)","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":":sin などのシンボルは 0 を返します。この値は引数に与えられたシンボルが演算子として無効であることを表しているだけで、優先順位が最も低いということではありません。同様に、このような演算子には結合性は :none が割り当てられます。","category":"page"},{"location":"manual/mathematical-operations.html#数値変換-1","page":"算術演算と初等関数","title":"数値変換","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"Julia は、3 つの形式の数値変換をサポートしていますが、これらはそれぞれ厳密な変換ができないときの扱いが異なります。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"T(x) または convert(T,x) は x を型 T の値に変換します。\nT が浮動小数点型の場合、結果は最も近い表現可能な値であり、正または負の無限大になる可能性があります。\nT が整数型の場合, x が Tで表せない場合にはInexactError が発生します。.\nx % T は x を整数型 Tの、2^n を法として、xと合同な数に変換します。ここで n は Tのビット数です。言い換えると、2進数表現を T で表現できるよう切り捨てをしています。\n丸め関数 はオプションの引数として、型 T をとります。例えば, round(Int,x)は Int(round(x))の略記です。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"以下にそれぞれの例を示します。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"julia> Int8(127)\n127\n\njulia> Int8(128)\nERROR: InexactError: trunc(Int8, 128)\nStacktrace:\n[...]\n\njulia> Int8(127.0)\n127\n\njulia> Int8(3.14)\nERROR: InexactError: Int8(3.14)\nStacktrace:\n[...]\n\njulia> Int8(128.0)\nERROR: InexactError: Int8(128.0)\nStacktrace:\n[...]\n\njulia> 127 % Int8\n127\n\njulia> 128 % Int8\n-128\n\njulia> round(Int8,127.4)\n127\n\njulia> round(Int8,127.6)\nERROR: InexactError: trunc(Int8, 128.0)\nStacktrace:\n[...]","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"独自の変換と昇格を定義する方法については、変換と昇格を参照してください。","category":"page"},{"location":"manual/mathematical-operations.html#rounding-functions-1","page":"算術演算と初等関数","title":"丸め関数","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"関数 説明 戻り値の型\nround(x) x を最も近い整数に丸める typeof(x)\nround(T, x) x を最も近い整数に丸める T\nfloor(x) x を-Inf の方向に丸める typeof(x)\nfloor(T, x) x を-Inf の方向に丸める T\nceil(x) x を +Inf の方向に丸める typeof(x)\nceil(T, x) x を+Inf の方向に丸める T\ntrunc(x) x を ゼロの方向に丸める typeof(x)\ntrunc(T, x) x をゼロの方向に丸める T","category":"page"},{"location":"manual/mathematical-operations.html#除算関数-1","page":"算術演算と初等関数","title":"除算関数","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"関数 説明\ndiv(x,y), x÷y 切り落とし除算; ゼロ方向に丸めた商\nfld(x,y) floor除算; -Inf方向に丸めた商\ncld(x,y) ceil除算; +Inf方向に丸めた商\nrem(x,y) 剰余(remainder); x == div(x,y)*y + rem(x,y); 符号は x と一致\nmod(x,y) 剰余(modulus); x == fld(x,y)*y + mod(x,y); 符号は y と一致\nmod1(x,y) 1オフセットをしたmod; mod(r, y) == mod(x, y) を満たし y>0の場合 r∈(0,y]、y<0 の場合 r∈[y,0) となるような rを返す\nmod2pi(x) 2pi を法とする剰余;  0 <= mod2pi(x) < 2pi\ndivrem(x,y) (div(x,y),rem(x,y))を返す\nfldmod(x,y) (fld(x,y),mod(x,y))を返す\ngcd(x,y...) x, y,... の正の最大公約数 (greatest positive common divisor)\nlcm(x,y...) x, y,... の正の最小公倍数 (least positive common multiple)","category":"page"},{"location":"manual/mathematical-operations.html#符号関数と絶対値関数-1","page":"算術演算と初等関数","title":"符号関数と絶対値関数","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"関数 説明\nabs(x) x の絶対値\nabs2(x) x の絶対値の二乗\nsign(x) x の符号。 returning -1, 0, +1 のいずれかを返す\nsignbit(x) サインビットが立っているかどうか true/false を返す\ncopysign(x,y) sign(y) * abs(x) を返す\nflipsign(x,y) sign(x*y) * abs(x) を返す","category":"page"},{"location":"manual/mathematical-operations.html#累乗・対数・平方根-1","page":"算術演算と初等関数","title":"累乗・対数・平方根","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"関数 説明\nsqrt(x), √x x の平方根\ncbrt(x), ∛x x の三乗根\nhypot(x,y) 直角を挟む2辺の長さがx, y である直角三角形の斜辺の長さ\nexp(x) 自然指数関数 の x での値\nexpm1(x) ゼロ近傍のx に対する exp(x)-1の正確な値を返す\nldexp(x,n) 整数値 n に対する x*2^n を効率的に計算する\nlog(x) 自然対数の x での値\nlog(b,x) 底b の対数のx での値\nlog2(x) 底2 の対数のx での値\nlog10(x) 底10の対数のx での値\nlog1p(x) ゼロ近傍のx に対する log(1+x)の正確な値\nexponent(x) 浮動小数点x の 2を基数とする指数部分\nsignificand(x) 浮動小数点 x の 2を基数とする仮数部分","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"hypot、expm1、およびlog1pのような関数が必要かつ有用である理由概説については、John D. Cook の優れたブログ投稿を参照してください: expm1, log1p,erfc、および hypot。","category":"page"},{"location":"manual/mathematical-operations.html#三角関数と双曲線関数-1","page":"算術演算と初等関数","title":"三角関数と双曲線関数","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"すべての標準的な三角関数と双曲線関数も定義されています:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"sin    cos    tan    cot    sec    csc\nsinh   cosh   tanh   coth   sech   csch\nasin   acos   atan   acot   asec   acsc\nasinh  acosh  atanh  acoth  asech  acsch\nsinc   cosc","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"これらはすべて単一引数関数ですが、atanは2つの引数をとることもでき、そのときは 従来のatan2 関数の振る舞いになります。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"また、sinpi(x)とcospi(x)は、それぞれsin(pi*x)とcos(pi*x)のより正確な計算のために提供されます。","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"ラジアンの代わりに\"度\"を使用して三角関数を計算するには、関数の接尾辞を d で囲みます。たとえば、sind(x)はxが\"度\"で指定されるxのsinを計算します。 \"度\"を入力に使用した三角関数の完全なリストは次のとおりです:","category":"page"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"sind   cosd   tand   cotd   secd   cscd\nasind  acosd  atand  acotd  asecd  acscd","category":"page"},{"location":"manual/mathematical-operations.html#特殊関数-1","page":"算術演算と初等関数","title":"特殊関数","text":"","category":"section"},{"location":"manual/mathematical-operations.html#","page":"算術演算と初等関数","title":"算術演算と初等関数","text":"他の多くの特殊関数は、パッケージSpecialFunctions.jlで提供されています。","category":"page"},{"location":"manual/complex-and-rational-numbers.html#complex-and-rational-numbers-1","page":"複素数と有理数","title":"複素数と有理数","text":"","category":"section"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"Julia には、複素数と有理数の両方を組込型として持っており、それらにすべての標準 算術演算と初等関数 をサポートしています。変換と昇格 は、プリミティブまたは複合型の任意の組み合わせに対する操作が期待どおりに動作するように定義されます。","category":"page"},{"location":"manual/complex-and-rational-numbers.html#Complex-Numbers-1","page":"複素数と有理数","title":"Complex Numbers","text":"","category":"section"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"The global constant im is bound to the complex number i, representing the principal square root of -1. (Using mathematicians' i or engineers' j for this global constant were rejected since they are such popular index variable names.) Since Julia allows numeric literals to be juxtaposed with identifiers as coefficients, this binding suffices to provide convenient syntax for complex numbers, similar to the traditional mathematical notation:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> 1+2im\n1 + 2im","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"You can perform all the standard arithmetic operations with complex numbers:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> (1 + 2im)*(2 - 3im)\n8 + 1im\n\njulia> (1 + 2im)/(1 - 2im)\n-0.6 + 0.8im\n\njulia> (1 + 2im) + (1 - 2im)\n2 + 0im\n\njulia> (-3 + 2im) - (5 - 1im)\n-8 + 3im\n\njulia> (-1 + 2im)^2\n-3 - 4im\n\njulia> (-1 + 2im)^2.5\n2.729624464784009 - 6.9606644595719im\n\njulia> (-1 + 2im)^(1 + 1im)\n-0.27910381075826657 + 0.08708053414102428im\n\njulia> 3(2 - 5im)\n6 - 15im\n\njulia> 3(2 - 5im)^2\n-63 - 60im\n\njulia> 3(2 - 5im)^-1.0\n0.20689655172413796 + 0.5172413793103449im","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"The promotion mechanism ensures that combinations of operands of different types just work:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> 2(1 - 1im)\n2 - 2im\n\njulia> (2 + 3im) - 1\n1 + 3im\n\njulia> (1 + 2im) + 0.5\n1.5 + 2.0im\n\njulia> (2 + 3im) - 0.5im\n2.0 + 2.5im\n\njulia> 0.75(1 + 2im)\n0.75 + 1.5im\n\njulia> (2 + 3im) / 2\n1.0 + 1.5im\n\njulia> (1 - 3im) / (2 + 2im)\n-0.5 - 1.0im\n\njulia> 2im^2\n-2 + 0im\n\njulia> 1 + 3/4im\n1.0 - 0.75im","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"Note that 3/4im == 3/(4*im) == -(3/4*im), since a literal coefficient binds more tightly than division.","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"Standard functions to manipulate complex values are provided:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> z = 1 + 2im\n1 + 2im\n\njulia> real(1 + 2im) # real part of z\n1\n\njulia> imag(1 + 2im) # imaginary part of z\n2\n\njulia> conj(1 + 2im) # complex conjugate of z\n1 - 2im\n\njulia> abs(1 + 2im) # absolute value of z\n2.23606797749979\n\njulia> abs2(1 + 2im) # squared absolute value\n5\n\njulia> angle(1 + 2im) # phase angle in radians\n1.1071487177940904","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"通常どおり、複素数の絶対値(abs) はゼロからの距離です。 abs2 は絶対値の二乗を与え、平方根計算が行われないので複素数に特に使用されます。angle は、ラジアンの位相角度を返します (argument または arg 関数とも呼ばれます)。他の一通りの初等関数も複素数に対して定義されています:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> sqrt(1im)\n0.7071067811865476 + 0.7071067811865475im\n\njulia> sqrt(1 + 2im)\n1.272019649514069 + 0.7861513777574233im\n\njulia> cos(1 + 2im)\n2.0327230070196656 - 3.0518977991518im\n\njulia> exp(1 + 2im)\n-1.1312043837568135 + 2.4717266720048188im\n\njulia> sinh(1 + 2im)\n-0.4890562590412937 + 1.4031192506220405im","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"Note that mathematical functions typically return real values when applied to real numbers and complex values when applied to complex numbers. For example, sqrt behaves differently when applied to -1 versus `-1","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"0imeven though-1 == -1 + 0im`:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\njulia> sqrt(-1 + 0im)\n0.0 + 1.0im","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"The literal numeric coefficient notation does not work when constructing a complex number from variables. Instead, the multiplication must be explicitly written out:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> a = 1; b = 2; a + b*im\n1 + 2im","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"However, this is not recommended. Instead, use the more efficient complex function to construct a complex value directly from its real and imaginary parts:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> a = 1; b = 2; complex(a, b)\n1 + 2im","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"This construction avoids the multiplication and addition operations.","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"Inf および NaN は、特殊な浮動小数点値セクションで説明されているように、複素数の実部と虚部に伝播します:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> 1 + Inf*im\n1.0 + Inf*im\n\njulia> 1 + NaN*im\n1.0 + NaN*im","category":"page"},{"location":"manual/complex-and-rational-numbers.html#Rational-Numbers-1","page":"複素数と有理数","title":"Rational Numbers","text":"","category":"section"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"Julia has a rational number type to represent exact ratios of integers. Rationals are constructed using the // operator:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> 2//3\n2//3","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such that the denominator is non-negative:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> 6//9\n2//3\n\njulia> -4//8\n-1//2\n\njulia> 5//-15\n-1//3\n\njulia> -4//-12\n1//3","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"This normalized form for a ratio of integers is unique, so equality of rational values can be tested by checking for equality of the numerator and denominator. The standardized numerator and denominator of a rational value can be extracted using the numerator and denominator functions:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> numerator(2//3)\n2\n\njulia> denominator(2//3)\n3","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"Direct comparison of the numerator and denominator is generally not necessary, since the standard arithmetic and comparison operations are defined for rational values:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> 2//3 == 6//9\ntrue\n\njulia> 2//3 == 9//27\nfalse\n\njulia> 3//7 < 1//2\ntrue\n\njulia> 3//4 > 2//3\ntrue\n\njulia> 2//4 + 1//6\n2//3\n\njulia> 5//12 - 1//4\n1//6\n\njulia> 5//8 * 3//12\n5//32\n\njulia> 6//5 / 10//7\n21//25","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"Rationals can easily be converted to floating-point numbers:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> float(3//4)\n0.75","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"Conversion from rational to floating-point respects the following identity for any integral values of a and b, with the exception of the case a == 0 and b == 0:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> a = 1; b = 2;\n\njulia> isequal(float(a//b), a/b)\ntrue","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"Constructing infinite rational values is acceptable:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> 5//0\n1//0\n\njulia> -3//0\n-1//0\n\njulia> typeof(ans)\nRational{Int64}","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"Trying to construct a NaN rational value, however, is invalid:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> 0//0\nERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)\nStacktrace:\n[...]","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"As usual, the promotion system makes interactions with other numeric types effortless:","category":"page"},{"location":"manual/complex-and-rational-numbers.html#","page":"複素数と有理数","title":"複素数と有理数","text":"julia> 3//5 + 1\n8//5\n\njulia> 3//5 - 0.5\n0.09999999999999998\n\njulia> 2//7 * (1 + 2im)\n2//7 + 4//7*im\n\njulia> 2//7 * (1.5 + 2im)\n0.42857142857142855 + 0.5714285714285714im\n\njulia> 3//2 / (1 + 2im)\n3//10 - 3//5*im\n\njulia> 1//2 + 2im\n1//2 + 2//1*im\n\njulia> 1 + 2//3im\n1//1 - 2//3*im\n\njulia> 0.5 == 1//2\ntrue\n\njulia> 0.33 == 1//3\nfalse\n\njulia> 0.33 < 1//3\ntrue\n\njulia> 1//3 - 0.33\n0.0033333333333332993","category":"page"},{"location":"manual/strings.html#man-strings-1","page":"文字列","title":"文字列","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字列は、文字の有限列です。しかし文字とは何であるか、と問うてみると問題は複雑であることに気づきます。英語を話す人にとってよく知る文字とは、文字A、B、C等と数字や一般的な句読点です。これらの文字と0から127までの整数値とのマッピングはASCII標準によって標準化されています。もちろん、文字には、英語以外で使われる数々の文字が含まれるわけです。アクセントやその他の変更を加えた変形ASCII文字、キリル文字やギリシャ語などの関連スクリプト、ASCIIや英語とは全く関係のない言語体系である、アラビア語、中国語、ヘブライ語、ヒンディー語、日本語、韓国語などです。Unicode標準は、文字が正確に何であるかの複雑さに取り組み、この問題に対処する決定的な標準として広く受け入れられています。ニーズに応じて、これらの複雑さを完全に無視して、ASCII 文字のみが存在するふりをするか、ASCII 以外のテキストを処理するときに発生する可能性のある文字またはエンコーディングを扱うコードを記述できます。Julia はプレーンな ASCII テキストをシンプルかつ効率的に処理し、Unicode の処理も可能な限りシンプルで効率的に処理します。特に、ASCII 文字列を処理するときには、C スタイルの文字列コードを記述でき、パフォーマンスとセマンティクスの両方で期待どおりに動作します。このようなコードで ASCII 以外のテキストが検出された場合は、間違った結果をただ返すのではなく明確なエラー メッセージで正常に失敗します。この場合、ASCII 以外のデータを処理するようにコードを変更するのは簡単です。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"Juliaには、文字列に関係するいくつかの注目すべき高度な機能があります:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"ジュリアの文字列 (および文字列リテラル) に使用される組み込みの具体的な型は Stringです。 これはUTF-8エンコーディングによるUnicodeの全範囲をサポートしています。(他の Unicode エンコーディングとの間で変換するためにtranscode 関数が提供されます。\nすべての文字列型は抽象型 AbstractStringのサブタイプであり、外部パッケージは追加の AbstractString サブタイプを定義します (例えば他のエンコーディング用などに)。 文字列引数を必要とする関数を定義する場合は、任意の文字列型を受け入れるために、型を AbstractString として宣言する必要があります。\nC や Java と同様に、そしてほとんどの動的言語とは異なり、Julia にはAbstractCharと呼ばれる単一の文字を表すファーストクラスの型があります。AbstractChar の組み込みの Char サブタイプは、任意の Unicode 文字を表すことができる 32 ビット プリミティブ型です (UTF-8 エンコーディングに基づいています)。\nJava と同様に、文字列は不変(イミュータブル)であり、AbstractString オブジェクトの値は変更できません。 別の文字列値を作成するには、他の文字列の一部から新しい文字列を作成します。\n概念的には、文字列はインデックスから文字への 部分関数 です。これにより、文字インデックスではなく、エンコードされた表現のバイト インデックスによって文字列に効率的にインデックスを作成できます。","category":"page"},{"location":"manual/strings.html#man-characters-1","page":"文字列","title":"文字","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"Char型の値は単一の文字を表します: これは、特別なリテラル表現と適切な算術動作を持つ 32 ビットプリミティブ型であり、Unicode コードポイントを表す数値に変換できます。 (JuliaパッケージはAbstractCharの他のサブタイプを定義することができます。例えば 他のテキストエンコーディングの操作の最適化などのために) Char 値の入力方法を次に示します:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> 'x'\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> typeof(ans)\nChar","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"Char を整数値(コード ポイント)に簡単に変換できます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> Int('x')\n120\n\njulia> typeof(ans)\nInt64","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"32 ビット アーキテクチャでは、typeof(ans) は Int32になります。整数値を Char に簡単に変換できます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> Char(120)\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"すべての整数値が有効な Unicode コード ポイントであるとは言えませんが、パフォーマンス向上のため、Char 変換では、すべての引数が有効なコードポイントであるかの確認は行いません。変換された各値が有効なコード ポイントであるか確認する場合は、isvalid 関数を使用します:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> Char(0x110000)\n'\\U110000': Unicode U+110000 (category In: Invalid, too high)\n\njulia> isvalid(Char, 0x110000)\nfalse","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"現時点では、有効な Unicode コード ポイントは U+00 から U+d7ff と U+e000 から U+10ffff です。これらはすべてまだわかりやすい意味を割り当てられていないし、アプリケーションによって必ずしも解釈できるわけではありませんが、これらの値はすべて有効な Unicode 文字と見なされます。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"単一引用符の中で、\\u を使用してその後に16進数で最大 4桁、または \\U の後に16進数で最大 8 桁(最長有効値は 6 桁)で、任意のUnicode 文字を入力できます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> '\\u0'\n'\\0': ASCII/Unicode U+0000 (category Cc: Other, control)\n\njulia> '\\u78'\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> '\\u2200'\n'∀': Unicode U+2200 (category Sm: Symbol, math)\n\njulia> '\\U10ffff'\n'\\U10ffff': Unicode U+10ffff (category Cn: Other, not assigned)","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"Julia は、システムのロケールと言語の設定を使用して、どの文字をそのまま支障なく出力できるか、どの文字が、\\u や \\U を使った一般系で出力する必要があるかを判断します。これらの Unicode エスケープ形式に加えて、C言語のエスケープ形式 もすべて使用できます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> Int('\\0')\n0\n\njulia> Int('\\t')\n9\n\njulia> Int('\\n')\n10\n\njulia> Int('\\e')\n27\n\njulia> Int('\\x7f')\n127\n\njulia> Int('\\177')\n127","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"Char値では、いくつかの限定された算術演算と比較演算を行うことができます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> 'A' < 'a'\ntrue\n\njulia> 'A' <= 'a' <= 'Z'\nfalse\n\njulia> 'A' <= 'X' <= 'Z'\ntrue\n\njulia> 'x' - 'a'\n23\n\njulia> 'A' + 1\n'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)","category":"page"},{"location":"manual/strings.html#文字列の基礎-1","page":"文字列","title":"文字列の基礎","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字列リテラルは、二重引用符または三重引用符で区切られます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> str = \"Hello, world.\\n\"\n\"Hello, world.\\n\"\n\njulia> \"\"\"Contains \"quote\" characters\"\"\"\n\"Contains \\\"quote\\\" characters\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字列から文字を抽出する場合は、その文字列にインデックスを使います:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> str[1]\n'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n\njulia> str[6]\n',': ASCII/Unicode U+002c (category Po: Punctuation, other)\n\njulia> str[end]\n'\\n': ASCII/Unicode U+000a (category Cc: Other, control)","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字列を含む多くの Julia オブジェクトは、整数でインデックスづけができます。最初の要素(文字列の最初の文字)のインデックスは firstindex(str)で、最後の要素(文字)のインデックスは lastindex(str)で取得できます。キーワード end は、インデックス操作時に、指定された次元の最後のインデックスを示す短縮形として使用できます。 文字列のインデクス付は、Julia のほとんどのインデックスづけと同様に、 1 から始まります: どんなAbsdtractString型に対しても、firstindex はいつも 1 を返します。 (後で示しますが、しかしながら、lastindex(str)は length(str)とは一般的に同じでは ありません。一部のユニコード文字は、複数の符号単位を専有することがあるからです)","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"通常の値と同様に、endに対して算術演算やその他の演算を実行できます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> str[end-1]\n'.': ASCII/Unicode U+002e (category Po: Punctuation, other)\n\njulia> str[end÷2]\n' ': ASCII/Unicode U+0020 (category Zs: Separator, space)","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"1より小さいインデックスや、end より大きいインデックスを使うとエラーが発生します:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> str[0]\nERROR: BoundsError: attempt to access \"Hello, world.\\n\"\n  at index [0]\n[...]\n\njulia> str[end+1]\nERROR: BoundsError: attempt to access \"Hello, world.\\n\"\n  at index [15]\nStacktrace:\n[...]","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"範囲インデックスを使用して部分文字列を抽出することもできます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> str[4:9]\n\"lo, wo\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"str[k] と str[k:k] は同じ結果を与えないことに注意してください:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> str[6]\n',': ASCII/Unicode U+002c (category Po: Punctuation, other)\n\njulia> str[6:6]\n\",\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"前者はChar型の単一の文字値で、後者は 1 文字だけを含む文字列値です。Julia ではこれらは全く異なるものです。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"範囲インデックスによる配列の参照は元の文字列の選択部分のコピーを作成します。 または、型 SubString を使用して、文字列に対するビューを作成することもできます。例えば:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> str = \"long string\"\n\"long string\"\n\njulia> substr = SubString(str, 1, 4)\n\"long\"\n\njulia> typeof(substr)\nSubString{String}","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"chop, chomp や strip のような いくつかの標準的な関数は戻り値として SubStringを返します。","category":"page"},{"location":"manual/strings.html#UnicodeとUTF-8-1","page":"文字列","title":"UnicodeとUTF-8","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"Julia はUnicode 文字と Unicode 文字列を完全にサポートしています。前述のように、文字リテラルでは、すべての標準 C エスケープ シーケンスと同様に、Unicode \\u ,\\U エスケープ シーケンスを使ってUnicode の符号位置を表現することができます。すべての標準 C エスケープ シーケンスを使用して表すことができます。これらは文字列リテラルの書き込みでも同様です:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> s = \"\\u2200 x \\u2203 y\"\n\"∀ x ∃ y\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"これら Unicode 文字がエスケープされて表示されるか、特殊文字として表示されるかは、ターミナルのロケール設定と Unicode への対応状況によって異なります。文字列リテラルは、UTF-8 でエンコードされます。UTF-8 は可変長エンコーディングであり、すべての文字が同じバイト数でエンコードされるわけではありません。UTF-8 では、ASCII 文字 (コード ポイントが 0x80 (128) 未満の文字は、ASCIIの場合と同様に1 バイトでエンコードされます。コード ポイント 0x80 以上は複数のバイト(1 字あたり最大 4文字まで)を使用してエンコードされます。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"Juliaにおける文字列のインデックス付は、符号単位(=UTF-8のバイト)を参照します。これは、固定長の構成要素で、任意の文字(コードポイント)をエンコードするのに使われます。つまり、UTF-8 文字列に入るすべてのバイトインデックスが必ずしも文字の有効なインデックスであるとは限りません。このような無効なバイト インデックスで文字列にインデックスを作成すると、エラーがスローされます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> s[1]\n'∀': Unicode U+2200 (category Sm: Symbol, math)\n\njulia> s[2]\nERROR: StringIndexError(\"∀ x ∃ y\", 2)\n[...]\n\njulia> s[3]\nERROR: StringIndexError(\"∀ x ∃ y\", 3)\nStacktrace:\n[...]\n\njulia> s[4]\n' ': ASCII/Unicode U+0020 (category Zs: Separator, space)","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"この場合、文字 ∀は 3 バイト文字なので、インデックス 2 と 3 は無効で、次の文字のインデックスは 4 です。これはnextind(s,1)で計算でき、さらにその次の文字のインデックスはnextind(s,4)と続きます。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"Since end is always the last valid index into a collection, end-1 references an invalid byte index if the second-to-last character is multibyte.","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> s[end-1]\n' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n\njulia> s[end-2]\nERROR: StringIndexError(\"∀ x ∃ y\", 9)\nStacktrace:\n[...]\n\njulia> s[prevind(s, end, 2)]\n'∃': Unicode U+2203 (category Sm: Symbol, math)","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"The first case works, because the last character y and the space are one-byte characters, whereas end-2 indexes into the middle of the ∃ multibyte representation. The correct way for this case is using prevind(s, lastindex(s), 2) or, if you're using that value to index into s you can write s[prevind(s, end, 2)] and end expands to lastindex(s).","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"部分文字列を取り出す範囲インデックスでも、有効なバイト インデックスが与えられることが想定されており、それが満たされない場合はエラーがスローされます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> s[1:1]\n\"∀\"\n\njulia> s[1:2]\nERROR: StringIndexError(\"∀ x ∃ y\", 2)\nStacktrace:\n[...]\n\njulia> s[1:4]\n\"∀ \"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"可変長エンコーディングのため、文字列内の文字数 (length(s))は、最後のインデックスと常に同じであるとは限りません。インデックス 1 から lastindex(s) に至るまで、文字列sへのインデックス呼び出しを繰り返すと 適正なインデックスでは、s を構成うる一連の文字が返され、それ以外ではエラーが投げられます。したがって、文字列内のそれぞれの文字は固有のインデックスを持っているため、バイトインデックスと文字列の各文字を同一視する対応関係 length(s)<= lastindex(s)が得られるわけです。以下は非効率かつ冗長ではありますが、文字列 s に対する反復を行う方法です:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> for i = firstindex(s):lastindex(s)\n           try\n               println(s[i])\n           catch\n               # ignore the index error\n           end\n       end\n∀\n\nx\n\n∃\n\ny","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"空白行には実際には空白文字があります。幸いなことに、文字列内の文字を反復処理する場合は、文字列を反復可能オブジェクトとして使用できるので、例外処理は必要なく、上記の厄介なイディオムは不要です:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> for c in s\n           println(c)\n       end\n∀\n\nx\n\n∃\n\ny","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"If you need to obtain valid indices for a string, you can use the nextind and prevind functions to increment/decrement to the next/previous valid index, as mentioned above.  You can also use the eachindex function to iterate over the valid character indices:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> collect(eachindex(s))\n7-element Array{Int64,1}:\n  1\n  4\n  5\n  6\n  7\n 10\n 11","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"To access the raw code units (bytes for UTF-8) of the encoding, you can use the codeunit(s,i)  function, where the index i runs consecutively from 1 to ncodeunits(s).  The codeunits(s)  function returns an AbstractVector{UInt8} wrapper that lets you access these raw codeunits (bytes) as an array.","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"Julia の文字列には、無効なUTF-8コード単位シーケンスを含めることができます。この仕組みによって、任意のバイト シーケンスを String として扱うことができます。このような状況では、左から右の文字までのコード単位のシーケンスを解析する場合、文字列は、次のいずれかのビット パターンの先頭に一致し、最も長い8 ビット コード単位のシーケンスよって形成されます (各 x は 0 または 1 になります)。:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"0xxxxxxx;\n110xxxxx 10xxxxxx;\n1110xxxx 10xxxxxx 10xxxxxx;\n11110xxx 10xxxxxx 10xxxxxx 10xxxxxx;\n10xxxxxx;\n11111xxx.","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"特に、これは、冗長だったり、値が大きすぎるコードや、その接頭辞が、複数の不正文字ではなく、単一の不正文字として扱われることを意味します。 実例で説明するほうがよく理解できるでしょう:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> s = \"\\xc0\\xa0\\xe2\\x88\\xe2|\"\n\"\\xc0\\xa0\\xe2\\x88\\xe2|\"\n\njulia> foreach(display, s)\n'\\xc0\\xa0': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)\n'\\xe2\\x88': Malformed UTF-8 (category Ma: Malformed, bad data)\n'\\xe2': Malformed UTF-8 (category Ma: Malformed, bad data)\n'|': ASCII/Unicode U+007c (category Sm: Symbol, math)\n\njulia> isvalid.(collect(s))\n4-element BitArray{1}:\n 0\n 0\n 0\n 1\n\njulia> s2 = \"\\xf7\\xbf\\xbf\\xbf\"\n\"\\U1fffff\"\n\njulia> foreach(display, s2)\n'\\U1fffff': Unicode U+1fffff (category In: Invalid, too high)","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字列sのはじめの２つの符号単位は、空白文字の冗長なエンコーディングです。これは無効なものですが、文字列の中では1バイト文字として受け入れられます。その次（３，４番め)の符号単位は、3バイトのUTFF-8文字の始まりとして有効ですが、5つめの符号単位\\xe2はその続きとして無効です。したがって３，４番めの符号単位も文字列の一部として不正な形式ということになります。5つめの符号単位の続きに|がくることはなく有効でないので、5番目の符号単位も不正な形式です。最後に、文字列s2は、符号位置が大きすぎます。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"Julia はデフォルトで UTF-8 エンコーディングを使用しますが、パッケージを加えて、その他に新しいエンコーディングのサポートを追加することができます。 たとえば、LegacyStrings.jlパッケージはUTF16String と UTF32String 型を実装します。他のエンコーディングとそのサポートの実装方法については、当面はこのドキュメントでは説明しません。UTF-8 エンコーディングの問題の詳細については、以下のバイト配列リテラルのセクションを参照してください。 transcode関数は、主に外部データやライブラリを操作するために、さまざまなUTF-xxエンコーディング間でデータを変換するために提供されます。","category":"page"},{"location":"manual/strings.html#man-concatenation-1","page":"文字列","title":"連結","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"最も一般的で有用な文字列操作の 1 つは、連結です:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> greet = \"Hello\"\n\"Hello\"\n\njulia> whom = \"world\"\n\"world\"\n\njulia> string(greet, \", \", whom, \".\\n\")\n\"Hello, world.\\n\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"無効な UTF-8 文字列を連結する場合など起こりうる潜在的な危険に注意をはらうことは重要です。 連結後の文字列には、入力文字列とは異なる文字が含まれている場合があり、その文字数は連結文字列の文字数の合計よりも小さくなる場合があります。例えば:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> a, b = \"\\xe2\\x88\", \"\\x80\"\n(\"\\xe2\\x88\", \"\\x80\")\n\njulia> c = a*b\n\"∀\"\n\njulia> collect.([a, b, c])\n3-element Array{Array{Char,1},1}:\n ['\\xe2\\x88']\n ['\\x80']\n ['∀']\n\njulia> length.([a, b, c])\n3-element Array{Int64,1}:\n 1\n 1\n 1","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"このようなことが起こるのは、無効な UTF-8 文字列のときだけです。有効な UTF-8 文字列の連結では、文字列内のすべての文字も、文字列の文字数の合計も保持されます。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"ジュリアは、文字列連結に * も使うことができます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> greet * \", \" * whom * \".\\n\"\n\"Hello, world.\\n\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字列連結に + を使う言語のユーザーにとって、これは驚くべき選択肢のように思えるかもしれませんが、この * の使用は、特に抽象代数での先例があります。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"数学では、+ は通常、可換演算を示し、そこでは、オペランド順序は関係ありません。これに対応する例は、行列の足し算で、同じ形状を持つ行列 A と Bに対して A + B = B + A が成り立ちます。対照的に、* は通常、非可換演算を示し、そこでは、オペランドの順序が重要です。これに対応する例は行列の乗算で、一般的には A * B != B * A です。行列乗算と同様に、文字列連結は非可換です: 挨拶 * 誰が *誰が * 挨拶するそのため、* は、一般的な数学での使用例とも一致し、文字列連結の二項演算子として、より自然な選択です。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"より正確には、すべての有限長文字列 S と文字列連結演算子 * は 自由モノイド(S、*)を形成します。このセットの 単位元は空文字列 \"\" です。自由モノイドが非可換のときはいつでも、演算子の表記には\\cdot、*、またはそれらと同様に非可換の演算に対応する記号を用います。通常は可換である+は使われません。","category":"page"},{"location":"manual/strings.html#string-interpolation-1","page":"文字列","title":"文字列展開","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"連結を使用して文字列を構築することは少し面倒な場合があります。string関数の冗長な呼び出しや、乗算を何度も行うことが必要になる機会を減らすため、Julia は Perl のように $ を使用して文字列リテラルの展開ができます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> \"$greet, $whom.\\n\"\n\"Hello, world.\\n\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"これは、読みやすく便利で、上記の文字列連結と等価です。システムはこの見かけ上単一な文字列リテラルを string(greet, \",\",whom, \"\\n\") の呼び出しに書き換えます。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"$ に続く最短の完全な式が、値を文字列に展開する対象になります。かっこを使用すれば任意の式を文字列展開の対象にできます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> \"1 + 2 = $(1 + 2)\"\n\"1 + 2 = 3\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"連結と文字列展開は、オブジェクトを文字列形式に変換するためにstringを呼び出します。string は単に print の出力を返すだけですが、新しい型を定義するときには、string ではなく、print や showにメソッドを追加しなければなりません。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"AbstractString ではないオブジェクトは、大体の場合 そのオブジェクトがリテラル式として入力されるときの書き方に近い文字列に変換されます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> v = [1,2,3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> \"v: $v\"\n\"v: [1, 2, 3]\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"string は AbstractString および AbstractChar に対しては、恒等写像的に働くので、引用符を取り去り、エスケープが処理された文字列に展開されます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> c = 'x'\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> \"hi, $c\"\n\"hi, x\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字列リテラルに $ を含めるには、バックスラッシュでエスケープします:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> print(\"I have \\$100 in my account.\\n\")\nI have $100 in my account.","category":"page"},{"location":"manual/strings.html#三重引用符文字列リテラル-1","page":"文字列","title":"三重引用符文字列リテラル","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字列を三重引用符 (\"\"\"...\"\"\") を使用して作成すると、長いテキスト ブロックを作成するのに役立つ特殊な挙動をします。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"まず、三重引用符で囲まれた文字列も、最もインデントの少ない行までデデントされます。 これは、インデントされたコード内で文字列を定義する場合に便利です。例えば：","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> str = \"\"\"\n           Hello,\n           world.\n         \"\"\"\n\"  Hello,\\n  world.\\n\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"この場合、文字列終了時の \"\"\" の手前の(空)行が基準インデントレベルとして設定されます。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"デデントのレベルは、文字列リテラル中の全行が共通に持つスペースやタブの最長幅で決まります。ただし、文字列開始行が\"\"\" の後、スペースまたはタブしか持たない場合、文字列開始行を除いた全ての行(ちなみに、文字列終了の\"\"\"を含む行は常に含まれます)において判断されます。そして、文字列開始行の \"\"\"の後のテキストを除くすべての行 (スペースとタブのみを含む行も含む) から、上述の共通の開始シーケンスが削除されます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> \"\"\"    This\n         is\n           a test\"\"\"\n\"    This\\nis\\n  a test\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"次に、文字列開始の \"\"\"のすぐ後の改行は、結果の文字列から削除されます。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"\"\"\"hello\"\"\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"と","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"\"\"\"\nhello\"\"\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"は、等価ですが","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"\"\"\"\n\nhello\"\"\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"は、文字列のはじめに改行リテラルを含みます。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"改行削除は、デデントの後に実行されます。例えば:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> \"\"\"\n         Hello,\n         world.\"\"\"\n\"Hello,\\nworld.\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"末尾の空白は変更されません。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"三重引用符で囲まれた文字列リテラルには、エスケープせずに \" 記号を含めることができます。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"注意すべきなのは、文字列内に改行 (LF) 文字 \\n になるということです。単一引用符と三 重引用符のどちらを使用する場合でも、エディターが改行 \\r (CR) や、 CRLF を使用して行を終了する場合でも、この動作は変わりません。CR を文字列に含めるには、明示的なエスケープ \\r を使用します。たとえば、リテラル文字列 \"CRLF 行末\\r\\n\"というような文字列リテラルが入力できます。","category":"page"},{"location":"manual/strings.html#よくある文字列操作-1","page":"文字列","title":"よくある文字列操作","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字列を辞書的に比較するには、標準の比較演算子を使用します:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> \"abracadabra\" < \"xylophone\"\ntrue\n\njulia> \"abracadabra\" == \"xylophone\"\nfalse\n\njulia> \"Hello, world.\" != \"Goodbye, world.\"\ntrue\n\njulia> \"1 + 2 = 3\" == \"1 + 2 = $(1 + 2)\"\ntrue","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"特定の文字のインデックスを検索するときには、findfirstおよびfindlast関数を使用します:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> findfirst(isequal('o'), \"xylophone\")\n4\n\njulia> findlast(isequal('o'), \"xylophone\")\n7\n\njulia> findfirst(isequal('z'), \"xylophone\")","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"特定のオフセットで文字の検索を開始するには、関数 findnextとfindprevを使用します:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> findnext(isequal('o'), \"xylophone\", 1)\n4\n\njulia> findnext(isequal('o'), \"xylophone\", 5)\n7\n\njulia> findprev(isequal('o'), \"xylophone\", 5)\n4\n\njulia> findnext(isequal('o'), \"xylophone\", 8)","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字列内中に特定の部分文字列のあるかどうか確認するには、occursin 関数を使用します:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> occursin(\"world\", \"Hello, world.\")\ntrue\n\njulia> occursin(\"o\", \"Xylophon\")\ntrue\n\njulia> occursin(\"a\", \"Xylophon\")\nfalse\n\njulia> occursin('o', \"Xylophon\")\ntrue","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"最後の例は、occursinも文字リテラルを探すことができる、という例です。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"repeatとjoinはまた別の便利な文字列関数です:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> repeat(\".:Z:.\", 10)\n\".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.\"\n\njulia> join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\n\"apples, bananas and pineapples\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"その他の便利な機能には、次のようなものがあります:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"firstindex(str) は、str の最小 (バイト) インデックスが得られます (文字列の場合は常に 1 ですが、他のコンテナでは必ずしも当てはまりません)。\nlastindex(str) はstr の最大の(バイト)インデックスが得られます。\nlength(str) str の文字数。\nlength(str, i, j) は str のインデックス i から jまでの間にある、有効な文字インデックスの数が得られます。\nncodeunits(str) 文字列中の符号単位の数 。\ncodeunit(str, i) は str のインデックス i の符号単位の値が得られます。\nthisind(str, i) は 任意のバイトインデックス i に対して、そのインデックスが指すバイトデータが属する文字の最初のインデックスが得られます。\nnextind(str, i, n=1) でインデックスi から後ろに数えて、n個めの文字の最初のインデックスが得られます。\nprevind(str, i, n=1) でインデックスi から前に数えて、n個めの文字の最初のインデックスが得られます。","category":"page"},{"location":"manual/strings.html#non-standard-string-literals-1","page":"文字列","title":"非標準文字列リテラル","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字列を作成さいたり使用するけれども、標準的な文字列構成の振る舞いが、その時必要とされているものとは違う、という状況があるでしょう。このような状況のために、Julia は 非標準文字列リテラルを提供しています。非標準の文字列リテラルは、通常の二重引用符で囲まれた文字列リテラルのように見えますが、リテラルの前に識別子がつけられていて、通常の文字列リテラルとは異なる動作をします。正規表現、バイト配列リテラル、およびバージョン番号リテラルは、以下に説明するように、非標準文字列リテラルの例です。その他の例はメタプログラミングセクションで示されています。","category":"page"},{"location":"manual/strings.html#正規表現-1","page":"文字列","title":"正規表現","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"Julia には Perl 互換の正規表現 (正規表現) があり、PCRE ライブラリによって提供されます。(構文に関する説明は、ここを参照)正規表現は 2 つの点で文字列に関連しています: 明らかな関連は、正規表現が文字列内の規則的なパターンを見つけるために使用されるということです。もう 1 つは、正規表現自体が文字列として入力され、文字列内のパターンを効率的に検索するためのステート マシンとして解析されることです。Julia では、正規表現は r で始まるさまざまな識別子を接頭辞に持つ非標準文字列リテラルを使用して入力されます。オプションを有効にしていない最も基本的な正規表現リテラルは、r\"...\"とします:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> r\"^\\s*(?:#|$)\"\nr\"^\\s*(?:#|$)\"\n\njulia> typeof(ans)\nRegex","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字列の中に正規表現がとマッチするパターンがあるかを確認するには、occursin を使用します:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> occursin(r\"^\\s*(?:#|$)\", \"not a comment\")\nfalse\n\njulia> occursin(r\"^\\s*(?:#|$)\", \"# a comment\")\ntrue","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"ここでわかるように、occursinは単に true または false を返し、指定された正規表現にマッチするパターンが文字列内にあるかどうかを示します。しかし、一般的には、マッチしているかどうかだけでなく、どのように マッチしているかどうかを知りたいでしょう。そのためには、代わりに match 関数を使用します:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> match(r\"^\\s*(?:#|$)\", \"not a comment\")\n\njulia> match(r\"^\\s*(?:#|$)\", \"# a comment\")\nRegexMatch(\"#\")","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"正規表現が指定された文字列にマッチしない場合、match は nothing を返します。これは対話型プロンプトで何も出力がされない特別な値です。出力がされない以外は、完全に正常な値であり、プログラムでテストできます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"m = match(r\"^\\s*(?:#|$)\", line)\nif m === nothing\n    println(\"not a comment\")\nelse\n    println(\"blank or comment\")\nend","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"正規表現がマッチする場合、match によって返される値は RegexMatchオブジェクトです。このオブジェクトは、どの様にその式がマッチしたかを記録します。例えば、パターンと一致する部分文字列全体や、パターンを構成する要素と一致した(これを今後「補足」といいます)部分文字列の情報などです。この例では、部分文字列を補足するだけですが、コメントの後の、空白以外の文字列も補足したいでしょう。その場合は、以下のようにします:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> m = match(r\"^\\s*(?:#\\s*(.*?)\\s*$|$)\", \"# a comment \")\nRegexMatch(\"# a comment \", 1=\"a comment\")","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"matchを呼び出すときには、検索を開始位置をインデックスで指定することができます。例えば:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",1)\nRegexMatch(\"1\")\n\njulia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",6)\nRegexMatch(\"2\")\n\njulia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",11)\nRegexMatch(\"3\")","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"RegexMatch オブジェクトからは以下の情報を抽出できます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"マッチした部分文字列の全体: m.match\n文字列の配列として補足された部分文字列: m.captures\n最初のマッチ開始位置であるオフセットインデックス: m.offset\n補足された部分文字列それぞれに対するオフセット値をベクトルの形式で : m.offsets","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"正規表現バターンの各要素のうち、部分文字列として補足されるものがない場合、その補足されなかったパターン要素に対応する位置で、m.captures はnothing を、m.offsets は オフセット0 を要素に持ちます。(Julia のインデックスは 1 から始まっているので、文字列へのゼロ オフセットは無効です)。やや工夫された例を次に示します:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> m = match(r\"(a|b)(c)?(d)\", \"acd\")\nRegexMatch(\"acd\", 1=\"a\", 2=\"c\", 3=\"d\")\n\njulia> m.match\n\"acd\"\n\njulia> m.captures\n3-element Array{Union{Nothing, SubString{String}},1}:\n \"a\"\n \"c\"\n \"d\"\n\njulia> m.offset\n1\n\njulia> m.offsets\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> m = match(r\"(a|b)(c)?(d)\", \"ad\")\nRegexMatch(\"ad\", 1=\"a\", 2=nothing, 3=\"d\")\n\njulia> m.match\n\"ad\"\n\njulia> m.captures\n3-element Array{Union{Nothing, SubString{String}},1}:\n \"a\"\n nothing\n \"d\"\n\njulia> m.offset\n1\n\njulia> m.offsets\n3-element Array{Int64,1}:\n 1\n 0\n 2","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"補足したもの一つ一つをばらけてローカル変数に束縛できるよう、配列として返せると便利です:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> first, second, third = m.captures; first\n\"a\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"補足したものは、RegexMatch オブジェクトの補足したグループを数字や名前でインデックスづけして取り出すこともできます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> m=match(r\"(?<hour>\\d+):(?<minute>\\d+)\",\"12:45\")\nRegexMatch(\"12:45\", hour=\"12\", minute=\"45\")\n\njulia> m[:minute]\n\"45\"\n\njulia> m[2]\n\"45\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"replace を使用して文字列置換を行う場合にも、キャプチャは参照することができます。n番目の補足グループは\\nで参照できます。置換文字列には sを接頭辞として付けます。0番目の補足グループは一致したオブジェクト全体を参照するのに使います。名前付けした補足グループは、g<groupname>の形式で置換の中で参照できます。例えば:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> replace(\"first second\", r\"(\\w+) (?<agroup>\\w+)\" => s\"\\g<agroup> \\1\")\n\"second first\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"曖昧さを避ける為に、番号付けした補足グループもg<n>で、参照することができます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> replace(\"a\", r\".\" => s\"\\g<0>1\")\n\"a1\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"正規表現の動作は、閉じる側の二重引用符の後にフラグ i、m、s、および x の組み合わせを付けて変更できます。これらのフラグは、Perlの意味と同じです:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"i   大文字と小文字を区別しないでパターンマッチを行います。\n\n    ロケールマッチングが有効な場合、符号位置 255以下に対しては、現在のロケールから、255より大きな符号位置に対しては、ユニコードのルールからケースマップが作成されます。\nただし ユニコードルールと、非ユニコードルールの境界をまたぐ(符号位置が 255以下と 256以上) 場合のマッチは失敗するでしょう。\n\nm   文字列を複数行とみなします。つまり、\"^\" と \"$\" の解釈を 文字列の開始と終了とマッチするのではなく、文字列内のどの行の開始・終了ともマッチするような動作になります。\n\ns   文字列を1行とみなします。つまり、 \".\" が、どんな文字ともマッチするようになります。それがたとえ、改行のように通常マッチしない文字だったとしてもです。\n\n    as r\"\"ms, というように、mとsが一緒に使われると、\".\" はどんな文字ともマッチしながら、\"^\" と\"$\" はそれぞれ、改行の前後とマッチするようになります。\n\nx   正規表現パーサに、バックスラッシュ付きもしく文字列クラス内の空白を除いたほとんどの空白を無視するよう指示します。これによって、正規表現を部分毎に分けて(少しだけ)見やすくすることができます。'#' もコメントを導入するメタ文字として扱われます。一般的なコードと同様ですね。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"たとえば、次の正規表現では、3 つのフラグがすべてオンになっています:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> r\"a+.*b+.*?d$\"ism\nr\"a+.*b+.*?d$\"ims\n\njulia> match(r\"a+.*b+.*?d$\"ism, \"Goodbye,\\nOh, angry,\\nBad world\\n\")\nRegexMatch(\"angry,\\nBad world\")","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"r\"...\" リテラルは、展開とエスケープ処理を行いません。 (エスケープする必要があります 引用符 \"' は除きます)。以下は、標準の文字列リテラルとの違いを示す例です:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> x = 10\n10\n\njulia> r\"$x\"\nr\"$x\"\n\njulia> \"$x\"\n\"10\"\n\njulia> r\"\\x\"\nr\"\\x\"\n\njulia> \"\\x\"\nERROR: syntax: invalid escape sequence","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"r\"\"\"...\"\"\"で書かれる三重引用符で囲まれた正規表現文字列もサポートされています (引用符や改行を含む正規表現の場合に便利な場合があります)。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"Regex() コンストラクターを使用して、プログラムで有効な正規表現文字列を作成できます。 これにより、正規表現文字列を構築するときに、文字列変数やその他の文字列操作の結果を使用できます。これまでに見てきた正規表現はいずれも、単一の文字列引数で Regex() に使用できます。いくつかの例を次に示します:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> using Dates\n\njulia> d = Date(1962,7,10)\n1962-07-10\n\njulia> regex_d = Regex(\"Day \" * string(day(d)))\nr\"Day 10\"\n\njulia> match(regex_d, \"It happened on Day 10\")\nRegexMatch(\"Day 10\")\n\njulia> name = \"Jon\"\n\"Jon\"\n\njulia> regex_name = Regex(\"[\\\"( ]$name[\\\") ]\")  # interpolate value of name\nr\"[\\\"( ]Jon[\\\") ]\"\n\njulia> match(regex_name,\" Jon \")\nRegexMatch(\" Jon \")\n\njulia> match(regex_name,\"[Jon]\") === nothing\ntrue","category":"page"},{"location":"manual/strings.html#man-byte-array-literals-1","page":"文字列","title":"バイト配列リテラル","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"もう 1 つの便利な非標準文字列リテラルは、バイト配列文字列リテラルです。b\"...\" のように書きます。この形式では、読み取り専用のリテラルバイト配列、つまりUInt8 値の配列を表すのに、文字列表記を使用することができます。これらのオブジェクトの型はCodeUnits{UInt8, String}です。 バイト配列リテラルの規則は次のとおりです:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"ASCII 文字と ASCII エスケープは、1 バイトを生成します。\n\\x および8進としてエスケープした文字は、エスケープ値に対応する バイト を生成します。\nUnicode エスケープ列はは、UTF-8 の符号位置をエンコードしたバイト列を生成します。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"\\x と 0x80 (128) 未満の8進エスケープの動作は最初の 2 つのルールの両方でカバーされるので、ルールの間には重なりがある、といえますが、これらの規則の間に矛盾はありません。これらの規則を組み合わせることで、ASCII 文字、任意のバイト値、および UTF-8 シーケンスを簡単に使用してバイトの配列を生成できます。3 つすべてを使用する例を次に示します:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> b\"DATA\\xff\\u2200\"\n8-element Base.CodeUnits{UInt8,String}:\n 0x44\n 0x41\n 0x54\n 0x41\n 0xff\n 0xe2\n 0x88\n 0x80","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"ASCII 文字列 \"DATA\" は、バイト 68、65、84、65 に対応します。\\xff は単一バイト 255 を生成します。 Unicode エスケープ \\u2200 は UTF-8 で 3 バイト 226、136、128 としてエンコードされます。結果のバイト配列は、有効な UTF-8 文字列に対応しないことに注意してください:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> isvalid(\"DATA\\xff\\u2200\")\nfalse","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"前述のように、CodeUnits{UInt8,String}型の振る舞いは読み取り専用のUInt8配列です。もし、標準的なベクトルの振る舞いが必要ならば、Vector{UInt8}を使って変換してください:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> x = b\"123\"\n3-element Base.CodeUnits{UInt8,String}:\n 0x31\n 0x32\n 0x33\n\njulia> x[1]\n0x31\n\njulia> x[1] = 0x32\nERROR: setindex! not defined for Base.CodeUnits{UInt8,String}\n[...]\n\njulia> Vector{UInt8}(x)\n3-element Array{UInt8,1}:\n 0x31\n 0x32\n 0x33","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"また、\\xff と \\uff には重大な違いがあります: 前者のエスケープ シーケンスは バイト 255をエンコードしますが、後者のエスケープ シーケンスは符号位置 255 を表し、UTF-8 では 2 バイトとしてエンコードされます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> b\"\\xff\"\n1-element Base.CodeUnits{UInt8,String}:\n 0xff\n\njulia> b\"\\uff\"\n2-element Base.CodeUnits{UInt8,String}:\n 0xc3\n 0xbf","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"文字リテラルも同じ動作をします。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"符号位置が\\u80 より小さい場合は、各符号位置での UTF-8 エンコーディングは、対応する \\x エスケープによって生成される単一バイトにすぎません。この違いを無視しても問題ありません。ただし、エスケープ \\x80 から \\xff までを、\\u80から\\uffまでと比較すると大きな違いがあります: 前者はすべて単一バイトにエンコードされますが、ごく一部のバイト列を除いて無効なUTF-8データになります。後者はすべてUnicodeの符号位置を表現し、2 バイトエンコーディングされます。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"もし このことに大変混乱しているようならば、 \"The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets\"を読んでみてください。UnicodeとUTF-8に関する優れた入門記事なので、混乱を軽減する助けになるでしょう。","category":"page"},{"location":"manual/strings.html#man-version-number-literals-1","page":"文字列","title":"バージョン番号リテラル","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"バージョン番号は、v\"...\"とう形式の非標準文字列リテラルで簡単に表現できます。 バージョン番号リテラルはVersionNumberオブジェクトを作成します。これは、セマンティック・バージョニングの仕様に従って、メジャー、マイナー、パッチの数値で構成され、その後、プレリリースとビルドの英数字による注釈が続きます。たとえば、v\"0.2.1-rc1+win64はメジャーバージョン0、マイナーバージョン2、パッチバージョン1、プレリリースrc1、ビルドwin64に分割されます。バージョンリテラルを入力する場合、メジャーバージョン番号以外のすべてがオプションです。 「v\"0.2\"」は「v」0.2.0\"(空のプレリリース/ビルドア釈付き)、\"v\"2\"``は\"v\"2.0.0\"と同等です。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"VersionNumber オブジェクトは、2 つ以上のバージョンを簡単かつ正確に比較するのに役立ちます。 たとえば、定数 VERSION は Julia バージョン番号を VersionNumber オブジェクトとして保持するため、単純なステートメントを使用してバージョン固有の動作を次のように定義できます:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"if v\"0.2\" <= VERSION < v\"0.3-\"\n    # do something specific to 0.2 release series\nend","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"上記の例では、非標準バージョン番号 v\"0.3-\"が使用され、末尾に-が使われているのに注意してください: この表記法Juliaによる標準の拡張で、そのバージョンが全てのプレリリースを含み、0.3のリリースよりバージョンが低いことを示します。したがって、上記のコード例の意味は、ifで囲まれたコードが、安定版の0.2のみで実行可能で、v\"0.3.0-rc1などのバージョンでは実行されないということになります。また、不安定な(すなわちプレリリースの)0.2バージョンも許可するには、下限チェッを次のように変更してください:v\"0.2-\" <= VERSION`。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"別の非標準のバージョン仕様拡張機能として、末尾に +をつけてビルドバージョンの上限(例えば)を表すことができます。例えば、 VERSION > v\"0.2-rc1+\"は、0.2-rc1以上の任意のバージョンを表すので、例えば v\"0.2-rc1+win64\"に対しては false を返し、v\"0.2-rc2\"に対してtrueを返します。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"このような特別なバージョンを使った比較は非常に実践的です(特に、後続の - は、正当な理由がない限り常に上限で使用する必要があります)が、セマンティック バージョニングの方式としては無効なものなので、実際のバージョン番号として使用してはなりません。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"VERSION 定数に使う以外に、VersionNumber オブジェクトはPkg でパッケージのバージョンとその依存関係を指定するのに広く使われています。","category":"page"},{"location":"manual/strings.html#man-raw-string-literals-1","page":"文字列","title":"生文字列リテラル","text":"","category":"section"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"式展開やエスケープ処理のない生文字列は、raw\"...'' という形式の非標準文字列リテラルで表現できます。生文字列リテラルは、引用符の中身を式展開やエスケープ処理することなくそのまま含んだ通常のStringオブジェクトを作成します。これは、$ または \\ を特殊文字として使用する他言語のコードまたはマークアップ言語を含む文字列に便利です。","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"例外は、引用符をエスケープする必要がある場合です。例えばraw\"\\\"\" は\"\\\"\"と同等です。 すべての文字列を表現しようとすると、引用符文字の直前に表示される場合だけですが、バックスラッシュもエスケープする必要があります:","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"julia> println(raw\"\\\\ \\\\\\\"\")\n\\\\ \\\"","category":"page"},{"location":"manual/strings.html#","page":"文字列","title":"文字列","text":"最初の 2 つのバックスラッシュは、引用符文字の前にないため、そのまま出力されることに注意してください。 ただし、次のバックスラッシュは、その後に続くバックスラッシュをエスケープし、最後のバックスラッシュは引用符の前に表示されるので、引用符をエスケープします。","category":"page"},{"location":"manual/functions.html#man-functions-1","page":"関数","title":"関数","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"Julia では、関数は引数値のタプルを受け取って、戻り値を返すオブジェクトです。Julia 関数は、グローバル変数の状態を変えたり、グローバル変数の状態に影響を受けたりするという点で、純粋な数学関数ではありません。関数を定義する基本的な構文は次のとおりです:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> function f(x,y)\n           x + y\n       end\nf (generic function with 1 method)","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"もっと簡潔に関数を定義する第二の構文があります。上記に示した従来の関数宣言構文と次のようなコンパクトな代入方式は同等の関数定義を行います:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> f(x,y) = x + y\nf (generic function with 1 method)","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"代入方式では、関数の本体は単一の式である必要がありますが、複合式を指定できます (複合式を参照)。短くて単純な関数定義は、Julia でよく使われます。この構文は非常に慣用的であり、コーディング時のタイプ量と視覚的なノイズの両方を大幅に削減してくれます。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"関数は、従来の括弧構文を使用して呼び出されます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> f(2,3)\n5","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"括弧を使用しない場合、式 f は関数オブジェクトを参照し、任意の値と同様に変数に渡すことができます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> g = f;\n\njulia> g(2,3)\n5","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"変数と同様に、関数名にもUnicode を使用できます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> ∑(x,y) = x + y\n∑ (generic function with 1 method)\n\njulia> ∑(2, 3)\n5","category":"page"},{"location":"manual/functions.html#引数渡しの振る舞い-1","page":"関数","title":"引数渡しの振る舞い","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"Julia 関数の引数は、\"共有渡し\" と呼ばれる慣例に従います。関数に渡した引数はコピーされません。関数引数そのものは、新しい変数 バインディング (値を参照できる新しい場所) として振る舞いますが、参照する値は渡された値と同一のものです。ミュータブル(変更可能)な値(配列など)に対して、関数内で行われた変更は呼び出し側からも見えます。これは、Scheme、ほとんどのLisp 、Python、Ruby、Perlその他の動的言語で見られる動作と同じです。","category":"page"},{"location":"manual/functions.html#the-return-keyword-1","page":"関数","title":"return キーワード","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"関数の戻り値は、最後に評価された式の値であり、デフォルトでは関数定義の本体の最後の式です。前節で挙げた 関数 fの例では式 x + y がこれに当たります。C や他のほとんどの命令型言語や関数型言語の大部分はが、return キーワードによって、関数の実行が即時に終了し、指定された式を戻り値とします:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"function g(x,y)\n    return x * y\n    x + y\nend","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"関数定義は対話型セッションで入力できるため、これらの定義を簡単に比較できます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> f(x,y) = x + y\nf (generic function with 1 method)\n\njulia> function g(x,y)\n           return x * y\n           x + y\n       end\ng (generic function with 1 method)\n\njulia> f(2,3)\n5\n\njulia> g(2,3)\n6","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"もちろん、純粋な線形関数 gでは、return をつかう意味はありません。x + y という式は評価されず、単にx * y を関数の最後の式にすれば return を省略できるためです。ただし、他の制御フローと組み合わる場合、return は実用的です。たとえば、オーバーフローを回避しながら x と y の辺を持つ直角三角形の斜辺の長さを計算する関数は下記のようになります:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> function hypot(x,y)\n           x = abs(x)\n           y = abs(y)\n           if x > y\n               r = y/x\n               return x*sqrt(1+r*r)\n           end\n           if y == 0\n               return zero(x)\n           end\n           r = x/y\n           return y*sqrt(1+r*r)\n       end\nhypot (generic function with 1 method)\n\njulia> hypot(3, 4)\n5.0","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"この関数から、呼び出し側に戻るポイントは 3 箇所あり、x と y の値に応じて 3 つの異なる式の値を返します。最後の行の return は最後の式であるため省略できます。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"戻り値の型は、:: 演算子を使用して関数宣言で指定することもできます。これにより、戻り値が指定された型に変換されます。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> function g(x, y)::Int8\n           return x * y\n       end;\n\njulia> typeof(g(1, 2))\nInt8","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"この関数は、x と y の型に関係なく、常に Int8 を返します。 戻り値の型の詳細については、型宣言を参照してください。","category":"page"},{"location":"manual/functions.html#演算子は関数である-1","page":"関数","title":"演算子は関数である","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"Julia では、ほとんどの演算子は特殊な構文をサポートする関数にすぎません。(例外は、&& や ||です。短絡評価は、演算子の評価が行われる前には、オペランドが評価されていないことを要求し、これは関数の振る舞いとは異なります) したがって、他の関数と同様に、括弧付き引数リストを使用して演算子を適用することもできます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> 1 + 2 + 3\n6\n\njulia> +(1,2,3)\n6","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"上記コードにおける１つ目の例の二項演算形式は、２つ目の例の関数適用形式と全く同等です。実は、前者は内部で関数呼び出しを行っているのです。これはまた、他の関数と同様に+や*]などの演算子は、代入や受け渡しが可能だということです:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> f = +;\n\njulia> f(1,2,3)\n6","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"ただし、f という名前では、この関数は二項演算形式を利用できません。","category":"page"},{"location":"manual/functions.html#特殊な名前の演算子-1","page":"関数","title":"特殊な名前の演算子","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"通常の用法では見た目からはわからない名前で関数呼び出しできる特殊な式がいくつかあります:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"式 呼び出し名\n[A B C ...] hcat\n[A; B; C; ...] vcat\n[A B; C D; ...] hvcat\nA' adjoint\nA[i] getindex\nA[i] = x setindex!\nA.n getproperty\nA.n = x setproperty!","category":"page"},{"location":"manual/functions.html#man-anonymous-functions-1","page":"関数","title":"無名関数","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"Julia では 関数はファーストクラスのオブジェクトです。:変数に代入ができ、代入された変数から標準的な関数呼び出し構文を使って関数を呼び出すことができます。これらは関数の引数としても、戻り値としても使うことができます。また、 下記の構文のいずれかを使用して、名前を付けず作成することができます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> x -> x^2 + 2x - 1\n#1 (generic function with 1 method)\n\njulia> function (x)\n           x^2 + 2x - 1\n       end\n#3 (generic function with 1 method)","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"これにより、引数 x を受け取って、その値を用いて計算した、多項式 x^2 + 2x - 1の値を返す関数が作成されます。ここで生成される関数は、汎化関数ですが、コンパイラで生成した通し番号に基づいた名前を持つ点に注意してください。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"無名関数の主な用途は、他の関数を引数に取る関数に渡すことです。典型的な例は[map(@ref)]で、配列の各値に対して関数を適用し、その結果を新しい配列として返します:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> map(round, [1.2,3.5,1.7])\n3-element Array{Float64,1}:\n 1.0\n 4.0\n 2.0","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"もし、変換を行う名前付きの関数があって、map関数の第一引数に渡せるのであれば、問題は有りません。しかし、多くの場合、すぐに使用できる名前付き関数は存在しません。このような状況では、無名関数nの機能を使えば、その時限りの、名前を必要としない関数オブジェクトを簡単に生成することができます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> map(x -> x^2 + 2x - 1, [1,3,-1])\n3-element Array{Int64,1}:\n  2\n 14\n -2","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"複数の引数を受けとる無名関数は、(x,y,z)->2x+y-zのような構文を使用して記述できます。ゼロ引数の匿名関数は ()->3 のように書かれます。引数のない関数の考えは奇妙に見えるかもしれませんが、計算を「遅らせる」ために役立ちます。この使用法では、コードブロックを後でゼロ引数関数で囲っておき、後でf のように呼んで実行します。","category":"page"},{"location":"manual/functions.html#タプル-1","page":"関数","title":"タプル","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"Julia には、関数引数と戻り値に密接に関連する tuple と呼ばれる組み込みのデータ構造があります。 タプルは、任意の値を保持できる固定長のコンテナーですが、その中身を変更することはできません (immutable)。 タプルはカンマと括弧で構成され、インデックスつかってアクセスすることができます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> (1, 1+1)\n(1, 2)\n\njulia> (1,)\n(1,)\n\njulia> x = (0.0, \"hello\", 6*7)\n(0.0, \"hello\", 42)\n\njulia> x[2]\n\"hello\"","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"長さ 1 のタプルは後ろにカンマを付けて、(1,)とすることに注意してください。(1) は括弧付きの値にすぎないから(タプルであることが示すためにはカンマが必要)です。 () は空の (長さ-0) タプルを表します。","category":"page"},{"location":"manual/functions.html#名前付きタプル-1","page":"関数","title":"名前付きタプル","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"タプルの各要素にはオプションで名前をつけることができます。このばあい、名前付きタプルが生成されます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> x = (a=1, b=1+1)\n(a = 1, b = 2)\n\njulia> x.a\n1","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"名前付きタプルはタプルに非常によく似ていますが、そのフィールドに対して、ドット構文 (x.a) を使用して名前でアクセスできます。","category":"page"},{"location":"manual/functions.html#複数の戻り値-1","page":"関数","title":"複数の戻り値","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"Julia では、複数の値をもつタプルを返すことで、擬似的に複数の値を返すことができます。ただし、タプルは括弧を使わなくても作成および分割できるため、コード上、単一のタプル値ではなく複数の値が返されているような錯覚を与えます。たとえば、次の関数は、値のペアを返します:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> function foo(a,b)\n           a+b, a*b\n       end\nfoo (generic function with 1 method)","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"戻り値をどの変数にも代入せずに、対話型セッションで呼び出すとタプルが返されます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> foo(2,3)\n(5, 6)","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"ただし、このように戻り値を組みにして返す用法をよく使うのは、それぞれの値を取り出して変数に代入する場合でしょう。Julia では、これを容易にする単純なタプルの分割をサポートしています:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> x, y = foo(2,3)\n(5, 6)\n\njulia> x\n5\n\njulia> y\n6","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"return キーワードを明示的に使用して複数の値を返すこともできます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"function foo(a,b)\n    return a+b, a*b\nend","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"これは既出の foo の定義と同等の効果があります。","category":"page"},{"location":"manual/functions.html#引数の分割-1","page":"関数","title":"引数の分割","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"引数の分割機能は、関数引数の中でも使用できます。 関数引数名が単なる記号ではなくタプル (例: (x, y))  のように書かれている場合、代入関数 (x, y) = 引数 が挿入されます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> minmax(x, y) = (y < x) ? (y, x) : (x, y)\n\njulia> range((min, max)) = max - min\n\njulia> range(minmax(10, 2))\n8","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"range の定義で余計な括弧があるのに注目してください。これがなければ、range は 2 引数関数になり、この例では機能しません。","category":"page"},{"location":"manual/functions.html#Varargs-Functions-1","page":"関数","title":"可変引数関数","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"任意の個数の引数を取る関数を記述できると便利なことがよくあります。 このような関数は、伝統的に\"varargs\"関数として知られており、これは\"variable number of arguments\" (変数数の引数) の略です。varargs 関数を定義するには、最後の引数の後に、省略記号をつけると定義できます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> bar(a,b,x...) = (a,b,x)\nbar (generic function with 1 method)","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"変数 a と b は通常どおり最初の 2 つの引数の値にバインドされ、変数 x は最初の 2 つの引数の後に bar に渡された 0 個以上の値のイテラブルなコレクションにバインドされます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> bar(1,2)\n(1, 2, ())\n\njulia> bar(1,2,3)\n(1, 2, (3,))\n\njulia> bar(1, 2, 3, 4)\n(1, 2, (3, 4))\n\njulia> bar(1,2,3,4,5,6)\n(1, 2, (3, 4, 5, 6))","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"いずれの場合も、x は bar に渡された後続の値からなるタプルにバインドされます。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"可変引数として渡される値の数を制限することが可能です。これについては、後で[パラメータ制限付きの可変引数メソッド](@ref parametrically-constrained-varargs-methods]で説明します。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"また、多くの場合、イテラブル コレクションに含まれる値と関数呼び出しに個別の引数とを \"接合\" すると便利です。これを行うには、関数呼び出しで ... を使用します:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> x = (3, 4)\n(3, 4)\n\njulia> bar(1,2,x...)\n(1, 2, (3, 4))","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"この場合は、タプルの値が可変引数呼び出しに接合されていますが、引数の数がタプルの要素数と等しいので、接合する必要はありません:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> x = (2, 3, 4)\n(2, 3, 4)\n\njulia> bar(1,x...)\n(1, 2, (3, 4))\n\njulia> x = (1, 2, 3, 4)\n(1, 2, 3, 4)\n\njulia> bar(x...)\n(1, 2, (3, 4))","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"さらに、関数呼び出しと接合するイテラブルオブジェクトはタプルである必要がありません:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> x = [3,4]\n2-element Array{Int64,1}:\n 3\n 4\n\njulia> bar(1,2,x...)\n(1, 2, (3, 4))\n\njulia> x = [1,2,3,4]\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> bar(x...)\n(1, 2, (3, 4))","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"また、引数を接合する関数は、可変引数でなくても構いません(可変引数であることの方が多いですが):","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> baz(a,b) = a + b;\n\njulia> args = [1,2]\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> baz(args...)\n3\n\njulia> args = [1,2,3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> baz(args...)\nERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)\nClosest candidates are:\n  baz(::Any, ::Any) at none:1","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"この通り、接合するコンテナの要素数が適切でない場合、関数呼び出しは失敗します。明示的に与える引数が多い場合と同じです。","category":"page"},{"location":"manual/functions.html#オプション引数-1","page":"関数","title":"オプション引数","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"多くの場合、関数引数には適切なデフォルト値があるため、すべての呼び出しで明示的に渡す必要はないかもしれません。たとえば、 DatesモジュールのDate(y, [m, d]) 関数は、特定のy年m月d日の Date 型を構成しますが、m と d 引数は省略可能で、デフォルト値は 1です。 この動作は、次のように簡潔に表すことができます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"function Date(y::Int64, m::Int64=1, d::Int64=1)\n    err = validargs(Date, y, m, d)\n    err === nothing || throw(err)\n    return Date(UTD(totaldays(y, m, d)))\nend","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"見ての通り、この定義は、UTInstant{Day} 型の 1 つの引数を受け取る Date 関数の別のメソッドを呼び出します。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"この定義によって，関数は 1 つ、2 つ、または 3 つの引数で呼び出され、引数のいずれかが指定されていない場合には 1 が自動的に渡されます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> using Dates\n\njulia> Date(2000, 12, 12)\n2000-12-12\n\njulia> Date(2000, 12)\n2000-12-01\n\njulia> Date(2000)\n2000-01-01","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"オプション引数は、実際には、異なる数の引数を持つ複数のメソッド定義を記述するための便利な構文です (オプション引数・キーワード引数に関する注記を参照)。 これはmethods関数を呼び出すことによって、例に挙げたDate関数の例をチェックすることができます。","category":"page"},{"location":"manual/functions.html#キーワード引数-1","page":"関数","title":"キーワード引数","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"関数の中には、引数の数が多いもの、多数の挙動を持つものがあり、このような関数の呼び出し方法を覚えておくのは難しいことがあります。キーワード引数を使用すると、引数を位置だけではなく名前で識別できるようになるので、これらの複雑なインターフェイスを使いやすくし、拡張も容易になります。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"たとえば、線をプロットする関数 plot を考えてみましょう。この関数には、線のスタイル、幅、色などを制御するための多くのオプションがあります。キーワード引数を受け入れる場合、可能な呼び出しは plot(x, y, width=2) のようになり、線の太さのみを指定することができます。キーワード引数には2 つの目的があることに注意して下さい。引数に意味を付けることができるため、関数コールの可読性が上がります。また、多数の引数の任意の部分集合を任意の順序で渡すことができます。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"キーワード引数を持つ関数は、シグネチャ内のセミコロンを使用して定義されます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"function plot(x, y; style=\"solid\", width=1, color=\"black\")\n    ###\nend","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"関数が呼び出す時に、セミコロンは省略可能です: 呼び出し方は、plot(x, y, width=2) または plot(x, y; width=2)ですが、前者ga より一般的です。以下に説明するように varargs または計算済みのキーワードを渡す場合には、明示的なセミコロンが必要になります。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"キーワード引数のデフォルト値は、必要な場合 (対応する値が渡されずに)、必要になったときだけ、左から右の順番で評価されます。したがって、デフォルトの式は評価済みのキーワード引数を参照しても構いません。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"キーワード引数の型は、次のように明示的に指定できます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"function f(;x::Int=1)\n    ###\nend","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"追加のキーワード引数はvarargs 関数のように ... を使用して収集できます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"function f(x; y=0, kwargs...)\n    ###\nend","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"例の関数f の内部では、kwargs は名前付きタプル上でのkey-value イテレータとして処理されます。名前付きタプルは、(Symbolをキーに持つ辞書と同じ様に) キーワード引数として関数にわたすことができて、呼び出時にはセミコロンを使います。(例: f(x、 z=1; kwargs...))","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"キーワード引数がメソッド定義にデフォルト値を割り当てられていない場合、その引数は必須ということになります。呼び出し元で値を割り当てなければ、UndefKeywordError 例外がスローされます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"function f(x; y)\n    ###\nend\nf(3, y=5) # ok, y is assigned\nf(3)      # throws UndefKeywordError(:y)","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"セミコロンの後に key => valueの形式で渡すこともできます。たとえば、plot(x, y; :width => 2)はplot(x, y, width=2)と同等です。これは、実行時に、キーワード名が計算される場合に便利です。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"キーワード引数の性質上、同じ引数を複数回指定することが可能です。 たとえば、plot(x, y; options..., width=2) という呼び出しでは、options 構造体にも width の値が含まれている可能性があります。このような場合、一番右で入力された値が優先されます。この例では、width 必ず2になります。ただし、plot(x,y, width=2, width=3)のようにキーワード引数を複数回明示的に指定することは許可されず、構文エラーが発生します。","category":"page"},{"location":"manual/functions.html#デフォルト値の評価スコープ-1","page":"関数","title":"デフォルト値の評価スコープ","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"オプション引数とキーワード引数のデフォルトの式が評価される時、スコープに入るのは、既出の 引数のみです。 たとえば、次の関数定義では:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"function f(x, a=b, b=1)\n    ###\nend","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"a=b の b は、後続の引数 b ではなく、外側のスコープ内の b を指します。","category":"page"},{"location":"manual/functions.html#関数引数の対するDoのブロック構文-1","page":"関数","title":"関数引数の対するDoのブロック構文","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"関数を他の関数に引数として渡すことは強力な手法ですが、その構文は必ずしも手軽ではありません。関数引数が複数行を必要とする場合、このような呼び出しは特に扱いにくいです。たとえば、いくつかのケースを持つ関数で map を呼び出すとすると:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"map(x->begin\n           if x < 0 && iseven(x)\n               return 0\n           elseif x == 0\n               return 1\n           else\n               return x\n           end\n       end,\n    [A, B, C])","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"Julia は、このコードをより明確に書き直すための予約語 do を提供します:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"map([A, B, C]) do x\n    if x < 0 && iseven(x)\n        return 0\n    elseif x == 0\n        return 1\n    else\n        return x\n    end\nend","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"do x 構文は引数 x を持つ無名関数を作成し、その関数を mapへ最初の引数として渡します。同様に、do a,b は 2 引数の無名関数を作成し、単に do と書けば、引数の無い () -> ... という形の無名関数であることを宣言になります。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"これらの引数がどのように初期化されるかは、外側の 関数によって異なります。ここで、mapは、構文 map(func,[A,B,C])とした時と同様にxをA、B、Cに順番に設定し、その都度無名関数が呼び出されます。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"この構文を使用すると、関数呼び出しは通常のコード ブロックのように見えるため、簡単に、効果的に言語を拡張しやすくなります。システム状態の管理など、mapとは大きく異なる用途が多く考えられまるでしょう。たとえば、開かれたファイルが最終的に閉じられることを確認するように open に手を加えることができます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"open(\"outfile\", \"w\") do io\n    write(io, data)\nend","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"次の様に定義をすればよいです:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"function open(f::Function, args...)\n    io = open(args...)\n    try\n        f(io)\n    finally\n        close(io)\n    end\nend","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"ここで、open は、まず書き込み用のファイルを開き、出力ストリームを do...end ブロックで定義された無名関数に渡します。関数が終了した後、open はストリームが適切に閉じれれたかどうかを確認します。 これは、無名関数が正常に終了するのか、例外が投げられたかに関わらず、です。(try/finally については制御フローで説明します)","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"do ブロック構文を使用すると、ドキュメントまたは実装をチェックして、ユーザー関数の引数がどのように初期化されるかを理解するの助けになります。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"do ブロックは、他の内部関数と同様に、取り囲むスコープの変数を補足することができます。たとえば、上記の例の open...doで変数dataを外側のスコープから補足しています。キャプチャされます。キャプチャすると、パフォーマンス・ティップスで説明するように、パフォーマンス上の困難が生じる可能性があります。","category":"page"},{"location":"manual/functions.html#Function-composition-and-piping-1","page":"関数","title":"Function composition and piping","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"Functions in Julia can be combined by composing or piping (chaining) them together.","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"Function composition is when you combine functions together and apply the resulting composition to arguments.  You use the function composition operator (∘) to compose the functions, so (f ∘ g)(args...) is the same as f(g(args...)).","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"You can type the composition operator at the REPL and suitably-configured editors using \\circ<tab>.","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"For example, the sqrt and + functions can be composed like this:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> (sqrt ∘ +)(3, 6)\n3.0","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"This adds the numbers first, then finds the square root of the result.","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"The next example composes three functions and maps the result over an array of strings:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> map(first ∘ reverse ∘ uppercase, split(\"you can compose functions like this\"))\n6-element Array{Char,1}:\n 'U'\n 'N'\n 'E'\n 'S'\n 'E'\n 'S'","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"Function chaining (sometimes called \"piping\" or \"using a pipe\" to send data to a subsequent function) is when you apply a function to the previous function's output:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> 1:10 |> sum |> sqrt\n7.416198487095663","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"Here, the total produced by sum is passed to the sqrt function. The equivalent composition would be:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> (sqrt ∘ sum)(1:10)\n7.416198487095663","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"The pipe operator can also be used with broadcasting, as .|>, to provide a useful combination of the chaining/piping and dot vectorization syntax (described next).","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> [\"a\", \"list\", \"of\", \"strings\"] .|> [uppercase, reverse, titlecase, length]\n4-element Array{Any,1}:\n  \"A\"\n  \"tsil\"\n  \"Of\"\n 7","category":"page"},{"location":"manual/functions.html#man-vectorized-1","page":"関数","title":"関数をベクトル化するDot構文","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"技術計算向けのプログラミング言語では、関数の「ベクトル化」バージョンがあることが一般的です。これは所与の関数 f(x) を配列 A の各要素に適用するもので、f(A) と書く新しい配列を生成します。この種の構文はデータ処理に便利ですが、他の言語では、パフォーマンスを得るためにも必要になることがあります。もし、ループ処理が遅ければ、「ベクトル化」バージョンの関数がより低水準な言語で書かれた速いライブラリーコードを呼ぶのです。Julia では、ベクター化された関数はパフォーマンスに必要なのではありません。実際に自分でループを書いた方がよいこともあります (パフォーマンス・ティップス参照)が、それでも、ベクトル化ができるのは便利です。そのような利便性のため、すべての Julia 関数 f は、f.(A) という構文で任意の配列 (またはその他のコレクション) に要素毎に関数を適用できます。 たとえば、ベクトル A のすべての要素に sin を以下のように適用できます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> A = [1.0, 2.0, 3.0]\n3-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0\n\njulia> sin.(A)\n3-element Array{Float64,1}:\n 0.8414709848078965\n 0.9092974268256817\n 0.1411200080598672","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"もちろん、fの特殊な「ベクトル」版メソッド、例えばf(A:AbstractArray)= map(f,A)を自作して使用すればドットを省略することもでき、演算効率も同じになります。しかし、この方法では、どの関数をベクトル化したいのか事前に決めておく必要があります。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"より一般的には、f.(args...) は実際には broadcast(f, args...) に相当します。これは、複数のアレイ(異なる形状であってもよい)、または配列とスカラーの組み合わせを操作するものです。(ブロードキャストを参照)。たとえば、f(x,y) = 3x + 4y を定義した場合、f.(pi,A) は A の各要素 a に対する f(pi,a) からなる新しい配列を返し、f.(vector1,vector2)の場合は各インデックス f(vector1[i]、vector2)からなる新しいベクトルを返します(ベクトルの長さが異なるときには例外を投げます)","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> f(x,y) = 3x + 4y;\n\njulia> A = [1.0, 2.0, 3.0];\n\njulia> B = [4.0, 5.0, 6.0];\n\njulia> f.(pi, A)\n3-element Array{Float64,1}:\n 13.42477796076938\n 17.42477796076938\n 21.42477796076938\n\njulia> f.(A, B)\n3-element Array{Float64,1}:\n 19.0\n 26.0\n 33.0","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"さらに、ネストした f.(args...) の呼出は、単一のブロードキャストのループに融合されます。例えば、sin.(cos.(X))は、broadcast(x->sin(cos(x)), X) と等価で、[sin(cos(x)) for x in X] に似ています。これは配列Xに対する一重のループになっており、計算結果の配列を一つだけアロケートします。[対象的に、通常のベクトル化した言語では、sin(cos(X)) とすると、まずはじめにtmp=cos(X)に対してテンポラリの配列のためにメモリをアロケートし、その後、sin(tmp)を別のループで計算、結果を格納する第二の配列を生成します。] Julia でのこのループ融合は、起こる場合も起こらない場合もあるような、コンパイルの最適化ではなく、ネストした f(args...) 呼出がある時に構文的に保証されているものです。技術的には、この融合は、「ドットを使わない関数呼び出し」に出会うと直ちにストップします。例えば、sin(sort(cos(X))) では、sin と cosのループはsort関数を挟んでいるため、融合されません。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"最後に、演算効率が最大となるのは、通常、ベクトル化した操作の出力配列が 事前に確保されており、関数を何度も呼び出す度に、新しい出力用の配列をアロケートしなくてもよいときです。(出力の事前割当 参照)。これを行うための便利な構文が、X .= ... です。これは broadcast!(identity, X, ...)と等価ですが、broadcast! ループはどんなにネストされた\"dot\" 呼び出しとも融合される点だけ異なります。たとえば、X .= sin は、broadcast!(sin, X, Y) と等価で、Xをsin(Y)で上書きします。左辺が配列インデックス式である場合、例えばX[2:end] .= sin.(Y)は、viewに対するbroadcast! に変換されます。例えば、 broadcast!(sin, view(X, 2:lastindex(X))、Y) で、左辺がインプレースで更新されます。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"たくさんの演算子や関数の呼び出しにドットをつけると式が長ったらしくなり、可読性も低下するため、 @.マクロが提供されています。これを使うと、行内の全ての関数よびだし、演算子、代入が「ドット付き」バージョンになります。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> Y = [1.0, 2.0, 3.0, 4.0];\n\njulia> X = similar(Y); # pre-allocate output array\n\njulia> @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))\n4-element Array{Float64,1}:\n  0.5143952585235492\n -0.4042391538522658\n -0.8360218615377305\n -0.6080830096407656","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":".+のような二項 (もしくは単項)演算子は、同じ仕組みで扱われます。これは broadcast呼出と同等で、他のネストした「ドット」呼び出しと融合します。X .+= Y は X .= X .+ Y と同等で、融合した上書き代入を行います。 ドット演算子も参照のこと 。","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"次の例のように、|>を使用してドット操作と関数の連鎖を組み合わせることもできます:","category":"page"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"julia> [1:5;] .|> [x->x^2, inv, x->2*x, -, isodd]\n5-element Array{Real,1}:\n    1\n    0.5\n    6\n   -4\n true","category":"page"},{"location":"manual/functions.html#参考文献-1","page":"関数","title":"参考文献","text":"","category":"section"},{"location":"manual/functions.html#","page":"関数","title":"関数","text":"本節の説明は、関数定義の完全な全体像からはほど遠いということを言わねばなりません。Julia は洗練された型システムを持ち、引数型に対して多重ディスパッチ利用可能です。本節で示した例はいずれも、引数に対する型アノテーションをつけておらず、すべての型の引数に適用できます。型システムについては型セクションで説明されています。実行時引数の型による多重ディスパッチを行い、そこで選択されるメソッドに関して関数を定義する方法についてはメソッドで説明されています。","category":"page"},{"location":"manual/control-flow.html#Control-Flow-1","page":"制御フロー","title":"制御フロー","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Julia は、さまざまな制御フロー構造を提供します:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Compound Expressions: begin and (;).\nConditional Evaluation: if-elseif-else and ?: (ternary operator).\n短絡評価: &&, || と比較の連鎖。\nRepeated Evaluation: Loops: while and for.\n例外処理: try-catch、errorとthrow。\nTasks (aka Coroutines): yieldto.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"The first five control flow mechanisms are standard to high-level programming languages. Tasks are not so standard: they provide non-local control flow, making it possible to switch between temporarily-suspended computations. This is a powerful construct: both exception handling and cooperative multitasking are implemented in Julia using tasks. Everyday programming requires no direct usage of tasks, but certain problems can be solved much more easily by using tasks.","category":"page"},{"location":"manual/control-flow.html#man-compound-expressions-1","page":"制御フロー","title":"Compound Expressions","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Sometimes it is convenient to have a single expression which evaluates several subexpressions in order, returning the value of the last subexpression as its value. There are two Julia constructs that accomplish this: begin blocks and (;) chains. The value of both compound expression constructs is that of the last subexpression. Here's an example of a begin block:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> z = begin\n           x = 1\n           y = 2\n           x + y\n       end\n3","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Since these are fairly small, simple expressions, they could easily be placed onto a single line, which is where the (;) chain syntax comes in handy:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> z = (x = 1; y = 2; x + y)\n3","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"This syntax is particularly useful with the terse single-line function definition form introduced in Functions. Although it is typical, there is no requirement that begin blocks be multiline or that (;) chains be single-line:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> begin x = 1; y = 2; x + y end\n3\n\njulia> (x = 1;\n        y = 2;\n        x + y)\n3","category":"page"},{"location":"manual/control-flow.html#man-conditional-evaluation-1","page":"制御フロー","title":"Conditional Evaluation","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the if-elseif-else conditional syntax:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"if x < y\n    println(\"x is less than y\")\nelseif x > y\n    println(\"x is greater than y\")\nelse\n    println(\"x is equal to y\")\nend","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"If the condition expression x < y is true, then the corresponding block is evaluated; otherwise the condition expression x > y is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the else block is evaluated. Here it is in action:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> function test(x, y)\n           if x < y\n               println(\"x is less than y\")\n           elseif x > y\n               println(\"x is greater than y\")\n           else\n               println(\"x is equal to y\")\n           end\n       end\ntest (generic function with 1 method)\n\njulia> test(1, 2)\nx is less than y\n\njulia> test(2, 1)\nx is greater than y\n\njulia> test(1, 1)\nx is equal to y","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"The elseif and else blocks are optional, and as many elseif blocks as desired can be used.  The condition expressions in the if-elseif-else construct are evaluated until the first one evaluates to true, after which the associated block is evaluated, and no further condition expressions or blocks are evaluated.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"if blocks are \"leaky\", i.e. they do not introduce a local scope. This means that new variables defined inside the if clauses can be used after the if block, even if they weren't defined before. So, we could have defined the test function above as","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> function test(x,y)\n           if x < y\n               relation = \"less than\"\n           elseif x == y\n               relation = \"equal to\"\n           else\n               relation = \"greater than\"\n           end\n           println(\"x is \", relation, \" y.\")\n       end\ntest (generic function with 1 method)\n\njulia> test(2, 1)\nx is greater than y.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"The variable relation is declared inside the if block, but used outside. However, when depending on this behavior, make sure all possible code paths define a value for the variable. The following change to the above function results in a runtime error","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> function test(x,y)\n           if x < y\n               relation = \"less than\"\n           elseif x == y\n               relation = \"equal to\"\n           end\n           println(\"x is \", relation, \" y.\")\n       end\ntest (generic function with 1 method)\n\njulia> test(1,2)\nx is less than y.\n\njulia> test(2,1)\nERROR: UndefVarError: relation not defined\nStacktrace:\n [1] test(::Int64, ::Int64) at ./none:7","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"if blocks also return a value, which may seem unintuitive to users coming from many other languages.  This value is simply the return value of the last executed statement in the branch that was chosen, so","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> x = 3\n3\n\njulia> if x > 0\n           \"positive!\"\n       else\n           \"negative...\"\n       end\n\"positive!\"","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Note that very short conditional statements (one-liners) are frequently expressed using Short-Circuit Evaluation in Julia, as outlined in the next section.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Unlike C, MATLAB, Perl, Python, and Ruby – but like Java, and a few other stricter, typed languages – it is an error if the value of a conditional expression is anything but true or false:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> if 1\n           println(\"true\")\n       end\nERROR: TypeError: non-boolean (Int64) used in boolean context","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"This error indicates that the conditional was of the wrong type: Int64 rather than the required Bool.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"The so-called \"ternary operator\", ?:, is closely related to the if-elseif-else syntax, but is used where a conditional choice between single expression values is required, as opposed to conditional execution of longer blocks of code. It gets its name from being the only operator in most languages taking three operands:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"a ? b : c","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"The expression a, before the ?, is a condition expression, and the ternary operation evaluates the expression b, before the :, if the condition a is true or the expression c, after the :, if it is false. Note that the spaces around ? and : are mandatory: an expression like a?b:c is not a valid ternary expression (but a newline is acceptable after both the ? and the :).","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"The easiest way to understand this behavior is to see an example. In the previous example, the println call is shared by all three branches: the only real choice is which literal string to print. This could be written more concisely using the ternary operator. For the sake of clarity, let's try a two-way version first:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> x = 1; y = 2;\n\njulia> println(x < y ? \"less than\" : \"not less than\")\nless than\n\njulia> x = 1; y = 0;\n\njulia> println(x < y ? \"less than\" : \"not less than\")\nnot less than","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"If the expression x < y is true, the entire ternary operator expression evaluates to the string \"less than\" and otherwise it evaluates to the string \"not less than\". The original three-way example requires chaining multiple uses of the ternary operator together:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> test(x, y) = println(x < y ? \"x is less than y\"    :\n                            x > y ? \"x is greater than y\" : \"x is equal to y\")\ntest (generic function with 1 method)\n\njulia> test(1, 2)\nx is less than y\n\njulia> test(2, 1)\nx is greater than y\n\njulia> test(1, 1)\nx is equal to y","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"To facilitate chaining, the operator associates from right to left.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"It is significant that like if-elseif-else, the expressions before and after the : are only evaluated if the condition expression evaluates to true or false, respectively:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> v(x) = (println(x); x)\nv (generic function with 1 method)\n\njulia> 1 < 2 ? v(\"yes\") : v(\"no\")\nyes\n\"yes\"\n\njulia> 1 > 2 ? v(\"yes\") : v(\"no\")\nno\n\"no\"","category":"page"},{"location":"manual/control-flow.html#short-circuit-evaluation-1","page":"制御フロー","title":"短絡評価","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Short-circuit evaluation is quite similar to conditional evaluation. The behavior is found in most imperative programming languages having the && and || boolean operators: in a series of boolean expressions connected by these operators, only the minimum number of expressions are evaluated as are necessary to determine the final boolean value of the entire chain. Explicitly, this means that:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"In the expression a && b, the subexpression b is only evaluated if a evaluates to true.\nIn the expression a || b, the subexpression b is only evaluated if a evaluates to false.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"The reasoning is that a && b must be false if a is false, regardless of the value of b, and likewise, the value of a || b must be true if a is true, regardless of the value of b. Both && and || associate to the right, but && has higher precedence than || does.  It's easy to experiment with this behavior:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> t(x) = (println(x); true)\nt (generic function with 1 method)\n\njulia> f(x) = (println(x); false)\nf (generic function with 1 method)\n\njulia> t(1) && t(2)\n1\n2\ntrue\n\njulia> t(1) && f(2)\n1\n2\nfalse\n\njulia> f(1) && t(2)\n1\nfalse\n\njulia> f(1) && f(2)\n1\nfalse\n\njulia> t(1) || t(2)\n1\ntrue\n\njulia> t(1) || f(2)\n1\ntrue\n\njulia> f(1) || t(2)\n1\n2\ntrue\n\njulia> f(1) || f(2)\n1\n2\nfalse","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"You can easily experiment in the same way with the associativity and precedence of various combinations of && and || operators.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"This behavior is frequently used in Julia to form an alternative to very short if statements. Instead of if <cond> <statement> end, one can write <cond> && <statement> (which could be read as: <cond> and then <statement>). Similarly, instead of if ! <cond> <statement> end, one can write <cond> || <statement> (which could be read as: <cond> or else <statement>).","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"For example, a recursive factorial routine could be defined like this:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> function fact(n::Int)\n           n >= 0 || error(\"n must be non-negative\")\n           n == 0 && return 1\n           n * fact(n-1)\n       end\nfact (generic function with 1 method)\n\njulia> fact(5)\n120\n\njulia> fact(0)\n1\n\njulia> fact(-1)\nERROR: n must be non-negative\nStacktrace:\n [1] error at ./error.jl:33 [inlined]\n [2] fact(::Int64) at ./none:2\n [3] top-level scope","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"ブール演算 なし の短絡評価は、算術演算と初等関数で導入されたビット毎のブール演算子で行うことができます: &と|です。これらは通常の関数で、二項演算子構文をサポートしますが、常に引数を評価します:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> f(1) & t(2)\n1\n2\nfalse\n\njulia> t(1) | t(2)\n1\n2\ntrue","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Just like condition expressions used in if, elseif or the ternary operator, the operands of && or || must be boolean values (true or false). Using a non-boolean value anywhere except for the last entry in a conditional chain is an error:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> 1 && true\nERROR: TypeError: non-boolean (Int64) used in boolean context","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"On the other hand, any type of expression can be used at the end of a conditional chain. It will be evaluated and returned depending on the preceding conditionals:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> true && (x = (1, 2, 3))\n(1, 2, 3)\n\njulia> false && (x = (1, 2, 3))\nfalse","category":"page"},{"location":"manual/control-flow.html#man-loops-1","page":"制御フロー","title":"Repeated Evaluation: Loops","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"There are two constructs for repeated evaluation of expressions: the while loop and the for loop. Here is an example of a while loop:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> i = 1;\n\njulia> while i <= 5\n           println(i)\n           global i += 1\n       end\n1\n2\n3\n4\n5","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"The while loop evaluates the condition expression (i <= 5 in this case), and as long it remains true, keeps also evaluating the body of the while loop. If the condition expression is false when the while loop is first reached, the body is never evaluated.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"The for loop makes common repeated evaluation idioms easier to write. Since counting up and down like the above while loop does is so common, it can be expressed more concisely with a for loop:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> for i = 1:5\n           println(i)\n       end\n1\n2\n3\n4\n5","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Here the 1:5 is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. The for loop iterates through these values, assigning each one in turn to the variable i. One rather important distinction between the previous while loop form and the for loop form is the scope during which the variable is visible. If the variable i has not been introduced in another scope, in the for loop form, it is visible only inside of the for loop, and not outside/afterwards. You'll either need a new interactive session instance or a different variable name to test this:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> for j = 1:5\n           println(j)\n       end\n1\n2\n3\n4\n5\n\njulia> j\nERROR: UndefVarError: j not defined","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"See Scope of Variables for a detailed explanation of variable scope and how it works in Julia.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"In general, the for loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword in or ∈ is typically used instead of =, since it makes the code read more clearly:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> for i in [1,4,0]\n           println(i)\n       end\n1\n4\n0\n\njulia> for s ∈ [\"foo\",\"bar\",\"baz\"]\n           println(s)\n       end\nfoo\nbar\nbaz","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Various types of iterable containers will be introduced and discussed in later sections of the manual (see, e.g., Multi-dimensional Arrays).","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"It is sometimes convenient to terminate the repetition of a while before the test condition is falsified or stop iterating in a for loop before the end of the iterable object is reached.  This can be accomplished with the break keyword:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> i = 1;\n\njulia> while true\n           println(i)\n           if i >= 5\n               break\n           end\n           global i += 1\n       end\n1\n2\n3\n4\n5\n\njulia> for j = 1:1000\n           println(j)\n           if j >= 5\n               break\n           end\n       end\n1\n2\n3\n4\n5","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Without the break keyword, the above while loop would never terminate on its own, and the for loop would iterate up to 1000. These loops are both exited early by using break.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The continue keyword accomplishes this:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> for i = 1:10\n           if i % 3 != 0\n               continue\n           end\n           println(i)\n       end\n3\n6\n9","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"This is a somewhat contrived example since we could produce the same behavior more clearly by negating the condition and placing the println call inside the if block. In realistic usage there is more code to be evaluated after the continue, and often there are multiple points from which one calls continue.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Multiple nested for loops can be combined into a single outer loop, forming the cartesian product of its iterables:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> for i = 1:2, j = 3:4\n           println((i, j))\n       end\n(1, 3)\n(1, 4)\n(2, 3)\n(2, 4)","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"With this syntax, iterables may still refer to outer loop variables; e.g. for i = 1:n, j = 1:i is valid.  However a break statement inside such a loop exits the entire nest of loops, not just the inner one.  Both variables (i and j) are set to their current iteration values each time the inner loop runs.  Therefore, assignments to i will not be visible to subsequent iterations:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> for i = 1:2, j = 3:4\n           println((i, j))\n           i = 0\n       end\n(1, 3)\n(1, 4)\n(2, 3)\n(2, 4)","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"If this example were rewritten to use a for keyword for each variable, then the output would be different: the second and fourth values would contain 0.","category":"page"},{"location":"manual/control-flow.html#exception-handlin-1","page":"制御フロー","title":"例外処理","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"予想外の状況が発生すると、関数が呼び出し元に妥当な値を返すことができないことがあります。このような事態に対する最善の策は、プログラムを終了させることかもしれませんし、状況報告のエラーメッセージを出力することかもしれません。あるいは、もしプログラマがこのような例外的な状況を上手く扱うコードを提供しているならば、そのコードが適切なアクションを実行できるようにするのがよいかもしれません。","category":"page"},{"location":"manual/control-flow.html#組み込みの例外-1","page":"制御フロー","title":"組み込みの例外","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"例外は、予期しない状態が発生したときにスローされます。以下に示す組み込みのExceptionは、通常の制御フローを中断します。","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Exception\nArgumentError\nBoundsError\nCompositeException\nDivideError\nDomainError\nEOFError\nErrorException\nInexactError\nInitError\nInterruptException\nInvalidStateException\nKeyError\nLoadError\nOutOfMemoryError\nReadOnlyMemoryError\nRemoteException\nMethodError\nOverflowError\nMeta.ParseError\nSystemError\nTypeError\nUndefRefError\nUndefVarError\nStringIndexError","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"たとえば、sqrt 関数は、負の実値に適用された場合に DomainError をスローします:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"独自の例外は、次の方法で定義できます:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> struct MyCustomException <: Exception end","category":"page"},{"location":"manual/control-flow.html#[throw](@ref)-関数-1","page":"制御フロー","title":"throw 関数","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"例外は throwを使用して明示的に発生させられます。たとえば、負以外の数値に対してのみ定義された関数は、引数が負の場合はDomainErrorをthrow するようにコーディングされます:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> f(x) = x>=0 ? exp(-x) : throw(DomainError(x, \"argument must be nonnegative\"))\nf (generic function with 1 method)\n\njulia> f(1)\n0.36787944117144233\n\njulia> f(-1)\nERROR: DomainError with -1:\nargument must be nonnegative\nStacktrace:\n [1] f(::Int64) at ./none:1","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"DomainError は括弧をつけない場合は、例外ではなく、例外の型を表す点に注意してください。 例外オブジェクトを取得するには、括弧を付けて関数呼び出しを行う必要があります:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> typeof(DomainError(nothing)) <: Exception\ntrue\n\njulia> typeof(DomainError) <: Exception\nfalse","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"さらに、一部の例外の型は、エラー報告に使用される 1 つ以上の引数を受け取ります:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> throw(UndefVarError(:x))\nERROR: UndefVarError: x not defined","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"独自の例外型を書いて、UndefVarError と同様の仕組みを実装するのは簡単です:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> struct MyUndefVarError <: Exception\n           var::Symbol\n       end\n\njulia> Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, \" not defined\")","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"note: Note\nエラーメッセージを書くときには、最初の文字を小文字で書くことが好ましいです。例えば、","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"size(A) == size(B) || throw(DimensionMismatch(\"size of A not equal to size of B\"))","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"の方が\n\n`size(A) == size(B) || throw(DimensionMismatch(\"Size of A not equal to size of B\"))`.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"より好ましいです。","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"ただし、意図的に最初の文字を大文字にすることもあります。例えば、関数の引数が大文字の場合:\n`size(A,1) == size(B,2) || throw(DimensionMismatch(\"A has first dimension...\"))`.","category":"page"},{"location":"manual/control-flow.html#エラー-1","page":"制御フロー","title":"エラー","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"error 関数は、制御の通常の流れを中断する ErrorException を生成するために使用されます。","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"負の数の平方根が取得された場合、すぐに実行を停止するとします。 これを行うには、引数が負の場合にエラーを発生させる小うるさいバージョンの sqrt 関数を定義できます:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> fussy_sqrt(x) = x >= 0 ? sqrt(x) : error(\"negative x not allowed\")\nfussy_sqrt (generic function with 1 method)\n\njulia> fussy_sqrt(2)\n1.4142135623730951\n\njulia> fussy_sqrt(-1)\nERROR: negative x not allowed\nStacktrace:\n [1] error at ./error.jl:33 [inlined]\n [2] fussy_sqrt(::Int64) at ./none:1\n [3] top-level scope","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"fussy_sqrt が別の関数から負の値で呼び出された場合、(fussy_sqrt 以降の)関数呼び出し続けようとせず、すぐにreturnして、対話型セッションにエラー メッセージを表示します:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> function verbose_fussy_sqrt(x)\n           println(\"before fussy_sqrt\")\n           r = fussy_sqrt(x)\n           println(\"after fussy_sqrt\")\n           return r\n       end\nverbose_fussy_sqrt (generic function with 1 method)\n\njulia> verbose_fussy_sqrt(2)\nbefore fussy_sqrt\nafter fussy_sqrt\n1.4142135623730951\n\njulia> verbose_fussy_sqrt(-1)\nbefore fussy_sqrt\nERROR: negative x not allowed\nStacktrace:\n [1] error at ./error.jl:33 [inlined]\n [2] fussy_sqrt at ./none:1 [inlined]\n [3] verbose_fussy_sqrt(::Int64) at ./none:3\n [4] top-level scope","category":"page"},{"location":"manual/control-flow.html#try/catch文-1","page":"制御フロー","title":"try/catch文","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"The try/catch statement allows for Exceptions to be tested for, and for the graceful handling of things that may ordinarily break your application. For example, in the below code the function for square root would normally throw an exception. By placing a try/catch block around it we can mitigate that here. You may choose how you wish to handle this exception, whether logging it, return a placeholder value or as in the case below where we just printed out a statement. One thing to think about when deciding how to handle unexpected situations is that using a try/catch block is much slower than using conditional branching to handle those situations.  Below there are more examples of handling exceptions with a try/catch block:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> try\n           sqrt(\"ten\")\n       catch e\n           println(\"You should have entered a numeric value\")\n       end\nYou should have entered a numeric value","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"try/catch 文では、例外を変数に保存することもできます。以下の例では、不自然ではありますが、x がインデックス可能な場合は x の 2 番目の要素の平方根を計算し、それ以外の場合は x が実数であると仮定し、その平方根を返します:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> sqrt_second(x) = try\n           sqrt(x[2])\n       catch y\n           if isa(y, DomainError)\n               sqrt(complex(x[2], 0))\n           elseif isa(y, BoundsError)\n               sqrt(x)\n           end\n       end\nsqrt_second (generic function with 1 method)\n\njulia> sqrt_second([1 4])\n2.0\n\njulia> sqrt_second([1 -4])\n0.0 + 2.0im\n\njulia> sqrt_second(9)\n3.0\n\njulia> sqrt_second(-9)\nERROR: DomainError with -9.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"catch に続くシンボルは常に例外の名前として解釈されるので、try/catch 式を1 行で記述する場合は注意が必要です。次のコードは、エラーが発生した場合に x の値を返しません:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"try bad() catch x end","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"代わりに、catch の後にセミコロンを使用するか改行を挿入します:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"try bad() catch; x end\n\ntry bad()\ncatch\n    x\nend","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"try/catchの威力は、深くネストされた計算から、関数コールのスタックにおいてはるかに上のレベルに飛び越えて戻ることができる点にあります。エラーが発生していない場合でも、スタックを飛び越えて戻り、より上の階層に値を渡せる機能は欲しい物です。Juliaは、rethrow、[backtrace(@ref)]、catch_backtraceそしてBase.catch_stackといったより高度なエラー処理のための関数を提供します。","category":"page"},{"location":"manual/control-flow.html#finally節-1","page":"制御フロー","title":"finally節","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"状態変化を生じるコード、ファイルなどのリソースを使用するコードでは、通常、コードの終了時に実行するべきクリーンアップ作業 (ファイルを閉じるなど) があります。例外を使うとこのようなタスクを複雑になる可能性があります。というのも、例外によって、対象のコードブロックが、正常終了処理に至る前に、実行が終了されしまう可能性があるからです。finally キーワードは、終了方法に関係なく、特定のコード ブロックが終了したときにいくつかのコードを実行する方法を提供します。","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"ここでは、開いたファイルを必ず閉じることを保証するコード例を挙げます:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"f = open(\"file\")\ntry\n    # operate on file f\nfinally\n    close(f)\nend","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"プログラム制御が tryブロックを離れる時 (たとえばreturnによる場合、または正常終了の場合など)、close(f) が実行されます。try ブロックが例外によって終了した場合、例外は引き続き伝播します。catchブロックは、try, finallyと組み合わせても構いません。この場合、finally ブロックは catch がエラーを処理した後に実行されます。","category":"page"},{"location":"manual/control-flow.html#man-tasks-1","page":"制御フロー","title":"Tasks (aka Coroutines)","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible manner. This feature is sometimes called by other names, such as symmetric coroutines, lightweight threads, cooperative multitasking, or one-shot continuations.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"When a piece of computing work (in practice, executing a particular function) is designated as a Task, it becomes possible to interrupt it by switching to another Task.  The original Task can later be resumed, at which point it will pick up right where it left off. At first, this may seem similar to a function call. However there are two key differences.  First, switching tasks does not use any space, so any number of task switches can occur without consuming the call stack. Second, switching among tasks can occur in any order, unlike function calls, where the called function must finish executing before control returns to the calling function.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"This kind of control flow can make it much easier to solve certain problems. In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious \"caller\" or \"callee\" among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Julia provides a Channel mechanism for solving this problem.  A Channel is a waitable first-in first-out queue which can have multiple tasks reading from and writing to it.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Let's define a producer task, which produces values via the put! call.  To consume values, we need to schedule the producer to run in a new task. A special Channel  constructor which accepts a 1-arg function as an argument can be used to run a task bound to a channel.  We can then take! values repeatedly from the channel object:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> function producer(c::Channel)\n           put!(c, \"start\")\n           for n=1:4\n               put!(c, 2n)\n           end\n           put!(c, \"stop\")\n       end;\n\njulia> chnl = Channel(producer);\n\njulia> take!(chnl)\n\"start\"\n\njulia> take!(chnl)\n2\n\njulia> take!(chnl)\n4\n\njulia> take!(chnl)\n6\n\njulia> take!(chnl)\n8\n\njulia> take!(chnl)\n\"stop\"","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"One way to think of this behavior is that producer was able to return multiple times. Between calls to put!, the producer's execution is suspended and the consumer has control.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"The returned Channel can be used as an iterable object in a for loop, in which case the loop variable takes on all the produced values. The loop is terminated when the channel is closed.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"julia> for x in Channel(producer)\n           println(x)\n       end\nstart\n2\n4\n6\n8\nstop","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Note that we did not have to explicitly close the channel in the producer. This is because the act of binding a Channel to a Task associates the open lifetime of a channel with that of the bound task. The channel object is closed automatically when the task terminates. Multiple channels can be bound to a task, and vice-versa.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"While the Task constructor expects a 0-argument function, the Channel  method which creates a channel bound task expects a function that accepts a single argument of type Channel. A common pattern is for the producer to be parameterized, in which case a partial function application is needed to create a 0 or 1 argument anonymous function.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"For Task objects this can be done either directly or by use of a convenience macro:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"function mytask(myarg)\n    ...\nend\n\ntaskHdl = Task(() -> mytask(7))\n# or, equivalently\ntaskHdl = @task mytask(7)","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"To orchestrate more advanced work distribution patterns, bind and schedule  can be used in conjunction with Task and Channel  constructors to explicitly link a set of channels with a set of producer/consumer tasks.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Note that currently Julia tasks are not scheduled to run on separate CPU cores.  True kernel threads are discussed under the topic of Parallel Computing.","category":"page"},{"location":"manual/control-flow.html#Core-task-operations-1","page":"制御フロー","title":"Core task operations","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Let us explore the low level construct yieldto to understand how task switching works.  yieldto(task,value) suspends the current task, switches to the specified task, and causes that task's last yieldto call to return the specified value. Notice that yieldto  is the only operation required to use task-style control flow; instead of calling and returning we are always just switching to a different task. This is why this feature is also called \"symmetric coroutines\"; each task is switched to and from using the same mechanism.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"yieldto is powerful, but most uses of tasks do not invoke it directly. Consider why this might be. If you switch away from the current task, you will probably want to switch back to it at some point, but knowing when to switch back, and knowing which task has the responsibility of switching back, can require considerable coordination. For example, put! and take!  are blocking operations, which, when used in the context of channels maintain state to remember who the consumers are. Not needing to manually keep track of the consuming task is what makes put!  easier to use than the low-level yieldto.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"In addition to yieldto, a few other basic functions are needed to use tasks effectively.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"current_task gets a reference to the currently-running task.\nistaskdone queries whether a task has exited.\nistaskstarted queries whether a task has run yet.\ntask_local_storage manipulates a key-value store specific to the current task.","category":"page"},{"location":"manual/control-flow.html#Tasks-and-events-1","page":"制御フロー","title":"Tasks and events","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Most task switches occur as a result of waiting for events such as I/O requests, and are performed by a scheduler included in Julia Base. The scheduler maintains a queue of runnable tasks, and executes an event loop that restarts tasks based on external events such as message arrival.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"The basic function for waiting for an event is wait. Several objects implement wait; for example, given a Process object, wait will wait for it to exit. wait  is often implicit; for example, a wait can happen inside a call to read  to wait for data to be available.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"In all of these cases, wait ultimately operates on a Condition object, which is in charge of queueing and restarting tasks. When a task calls wait on a Condition, the task is marked as non-runnable, added to the condition's queue, and switches to the scheduler.  The scheduler will then pick another task to run, or block waiting for external events. If all goes well, eventually an event handler will call notify on the condition, which causes tasks waiting for that condition to become runnable again.","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"A task created explicitly by calling Task is initially not known to the scheduler. This allows you to manage tasks manually using yieldto if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect. It is also possible to make the scheduler run a task whenever it can, without necessarily waiting for any events. This is done by calling schedule, or using the @async  macro (see Parallel Computing for more details).","category":"page"},{"location":"manual/control-flow.html#Task-states-1","page":"制御フロー","title":"Task states","text":"","category":"section"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Tasks have a state field that describes their execution status. A Task state is one of the following symbols:","category":"page"},{"location":"manual/control-flow.html#","page":"制御フロー","title":"制御フロー","text":"Symbol Meaning\n:runnable Currently running, or able to run\n:done Successfully finished executing\n:failed Finished with an uncaught exception","category":"page"},{"location":"manual/variables-and-scoping.html#scope-of-variables-1","page":"Scope of Variables","title":"Scope of Variables","text":"","category":"section"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"The scope of a variable is the region of code within which a variable is visible. Variable scoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have arguments called x without the two x's referring to the same thing. Similarly, there are many other cases where different blocks of code can use the same name without referring to the same thing. The rules for when the same variable name does or doesn't refer to the same thing are called scope rules; this section spells them out in detail.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Certain constructs in the language introduce scope blocks, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, global scope and local scope. The latter can be nested. The constructs introducing scope blocks are:","category":"page"},{"location":"manual/variables-and-scoping.html#man-scope-table-1","page":"Scope of Variables","title":"Scope constructs","text":"","category":"section"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Construct Scope type Scope blocks it may be nested in\nmodule, baremodule global global\ninteractive prompt (REPL) global global\n(mutable) struct, macro local global\nfor, while, try-catch-finally, let local global or local\nfunctions (either syntax, anonymous & do-blocks) local global or local\ncomprehensions, broadcast-fusing local global or local","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Notably missing from this table are begin blocks and if blocks which do not introduce new scopes.  Both types of scopes follow somewhat different rules which will be explained below.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Julia uses lexical scoping, meaning that a function's scope does not inherit from its caller's scope, but from the scope in which the function was defined. For example, in the following code the x inside foo refers to the x in the global scope of its module Bar:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> module Bar\n           x = 1\n           foo() = x\n       end;","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"and not a x in the scope where foo is used:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> import .Bar\n\njulia> x = -1;\n\njulia> Bar.foo()\n1","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Thus lexical scope means that the scope of variables can be inferred from the source code alone.","category":"page"},{"location":"manual/variables-and-scoping.html#Global-Scope-1","page":"Scope of Variables","title":"Global Scope","text":"","category":"section"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Each module introduces a new global scope, separate from the global scope of all other modules; there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the using or import statements or through qualified access using the dot-notation, i.e. each module is a so-called namespace. Note that variable bindings can only be changed within their global scope and not from an outside module.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> module A\n           a = 1 # a global in A's scope\n       end;\n\njulia> module B\n           module C\n               c = 2\n           end\n           b = C.c    # can access the namespace of a nested global scope\n                      # through a qualified access\n           import ..A # makes module A available\n           d = A.a\n       end;\n\njulia> module D\n           b = a # errors as D's global scope is separate from A's\n       end;\nERROR: UndefVarError: a not defined\n\njulia> module E\n           import ..A # make module A available\n           A.a = 2    # throws below error\n       end;\nERROR: cannot assign variables in other modules","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Note that the interactive prompt (aka REPL) is in the global scope of the module Main.","category":"page"},{"location":"manual/variables-and-scoping.html#Local-Scope-1","page":"Scope of Variables","title":"Local Scope","text":"","category":"section"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"A new local scope is introduced by most code blocks (see above table for a complete list).  A local scope inherits all the variables from a parent local scope, both for reading and writing.  Unlike global scopes, local scopes are not namespaces, thus variables in an inner scope cannot be retrieved from the parent scope through some sort of qualified access.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"The following rules and examples pertain to local scopes.  A newly introduced variable in a local scope cannot be referenced by a parent scope.  For example, here the z is not introduced into the top-level scope:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> for i = 1:10\n           z = i\n       end\n\njulia> z\nERROR: UndefVarError: z not defined","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"note: Note\nIn this and all following examples it is assumed that their top-level is a global scope with a clean workspace, for instance a newly started REPL.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Inner local scopes can, however, update variables in their parent scopes:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> for i = 1:1\n           z = i\n           for j = 1:1\n               z = 0\n           end\n           println(z)\n       end\n0","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Inside a local scope a variable can be forced to be a new local variable using the local keyword:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> for i = 1:1\n           x = i + 1\n           for j = 1:1\n               local x = 0\n           end\n           println(x)\n       end\n2","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Inside a local scope a global variable can be assigned to by using the keyword global:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> for i = 1:10\n           global z\n           z = i\n       end\n\njulia> z\n10","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"The location of both the local and global keywords within the scope block is irrelevant.  The following is equivalent to the last example (although stylistically worse):","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> for i = 1:10\n           z = i\n           global z\n       end\n\njulia> z\n10","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"The local and global keywords can also be applied to destructuring assignments, e.g.  local x, y = 1, 2. In this case the keyword affects all listed variables.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"In a local scope, all variables are inherited from its parent global scope block unless:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"an assignment would result in a modified global variable, or\na variable is specifically marked with the keyword local.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Thus global variables are only inherited for reading, not for writing:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> x, y = 1, 2;\n\njulia> function foo()\n           x = 2        # assignment introduces a new local\n           return x + y # y refers to the global\n       end;\n\njulia> foo()\n4\n\njulia> x\n1","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"An explicit global is needed to assign to a global variable:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"sidebar: Avoiding globals\nAvoiding changing the value of global variables is considered by many to be a programming best-practice. Changing the value of a global variable can cause \"action at a distance\", making the behavior of a program harder to reason about. This is why the scope blocks that introduce local scope require the global keyword to declare the intent to modify a global variable.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> x = 1;\n\njulia> function foobar()\n           global x = 2\n       end;\n\njulia> foobar();\n\njulia> x\n2","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Note that nested functions can modify their parent scope's local variables:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> x, y = 1, 2;\n\njulia> function baz()\n           x = 2 # introduces a new local\n           function bar()\n               x = 10       # modifies the parent's x\n               return x + y # y is global\n           end\n           return bar() + x # 12 + 10 (x is modified in call of bar())\n       end;\n\njulia> baz()\n22\n\njulia> x, y # verify that global x and y are unchanged\n(1, 2)","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"The reason to allow modifying local variables of parent scopes in nested functions is to allow constructing closures which have private state, for instance the state variable in the following example:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> let state = 0\n           global counter() = (state += 1)\n       end;\n\njulia> counter()\n1\n\njulia> counter()\n2","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"See also the closures in the examples in the next two sections. A variable, such as x in the first example and state in the second, that is inherited from the enclosing scope by the inner function is sometimes called a captured variable. Captured variables can present performance challenges discussed in performance tips.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"The distinction between inheriting global scope and nesting local scope can lead to some slight differences between functions defined in local versus global scopes for variable assignments.  Consider the modification of the last example by moving bar to the global scope:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> x, y = 1, 2;\n\njulia> function bar()\n           x = 10 # local, no longer a closure variable\n           return x + y\n       end;\n\njulia> function quz()\n           x = 2 # local\n           return bar() + x # 12 + 2 (x is not modified)\n       end;\n\njulia> quz()\n14\n\njulia> x, y # verify that global x and y are unchanged\n(1, 2)","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Note that the above nesting rules do not pertain to type and macro definitions as they can only appear at the global scope. There are special scoping rules concerning the evaluation of default and keyword function arguments which are described in the Function section.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"An assignment introducing a variable used inside a function, type or macro definition need not come before its inner usage:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> f = y -> y + a;\n\njulia> f(3)\nERROR: UndefVarError: a not defined\nStacktrace:\n[...]\n\njulia> a = 1\n1\n\njulia> f(3)\n4","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"This behavior may seem slightly odd for a normal variable, but allows for named functions – which are just normal variables holding function objects – to be used before they are defined. This allows functions to be defined in whatever order is intuitive and convenient, rather than forcing bottom up ordering or requiring forward declarations, as long as they are defined by the time they are actually called. As an example, here is an inefficient, mutually recursive way to test if positive integers are even or odd:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> even(n) = (n == 0) ? true : odd(n - 1);\n\njulia> odd(n) = (n == 0) ? false : even(n - 1);\n\njulia> even(3)\nfalse\n\njulia> odd(3)\ntrue","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Julia provides built-in, efficient functions to test for oddness and evenness called iseven  and isodd so the above definitions should only be considered to be examples of scope, not efficient design.","category":"page"},{"location":"manual/variables-and-scoping.html#Let-Blocks-1","page":"Scope of Variables","title":"Let Blocks","text":"","category":"section"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Unlike assignments to local variables, let statements allocate new variable bindings each time they run. An assignment modifies an existing value location, and let creates new locations.  This difference is usually not important, and is only detectable in the case of variables that outlive their scope via closures. The let syntax accepts a comma-separated series of assignments and variable names:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> x, y, z = -1, -1, -1;\n\njulia> let x = 1, z\n           println(\"x: $x, y: $y\") # x is local variable, y the global\n           println(\"z: $z\") # errors as z has not been assigned yet but is local\n       end\nx: 1, y: -1\nERROR: UndefVarError: z not defined","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like let x = x since the two x variables are distinct and have separate storage.  Here is an example where the behavior of let is needed:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> Fs = Vector{Any}(undef, 2); i = 1;\n\njulia> while i <= 2\n           Fs[i] = ()->i\n           global i += 1\n       end\n\njulia> Fs[1]()\n3\n\njulia> Fs[2]()\n3","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Here we create and store two closures that return variable i. However, it is always the same variable i, so the two closures behave identically. We can use let to create a new binding for i:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> Fs = Vector{Any}(undef, 2); i = 1;\n\njulia> while i <= 2\n           let i = i\n               Fs[i] = ()->i\n           end\n           global i += 1\n       end\n\njulia> Fs[1]()\n1\n\njulia> Fs[2]()\n2","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Since the begin construct does not introduce a new scope, it can be useful to use a zero-argument let to just introduce a new scope block without creating any new bindings:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> let\n           local x = 1\n           let\n               local x = 2\n           end\n           x\n       end\n1","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Since let introduces a new scope block, the inner local x is a different variable than the outer local x.","category":"page"},{"location":"manual/variables-and-scoping.html#For-Loops-and-Comprehensions-1","page":"Scope of Variables","title":"For Loops and Comprehensions","text":"","category":"section"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"for loops, while loops, and Comprehensions have the following behavior: any new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a let block:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> Fs = Vector{Any}(undef, 2);\n\njulia> for j = 1:2\n           Fs[j] = ()->j\n       end\n\njulia> Fs[1]()\n1\n\njulia> Fs[2]()\n2","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"A for loop or comprehension iteration variable is always a new variable:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> function f()\n           i = 0\n           for i = 1:3\n           end\n           return i\n       end;\n\njulia> f()\n0","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"However, it is occasionally useful to reuse an existing local variable as the iteration variable.  This can be done conveniently by adding the keyword outer:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> function f()\n           i = 0\n           for outer i = 1:3\n           end\n           return i\n       end;\n\njulia> f()\n3","category":"page"},{"location":"manual/variables-and-scoping.html#Constants-1","page":"Scope of Variables","title":"Constants","text":"","category":"section"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"A common use of variables is giving names to specific, unchanging values. Such variables are only assigned once. This intent can be conveyed to the compiler using the const keyword:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> const e  = 2.71828182845904523536;\n\njulia> const pi = 3.14159265358979323846;","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Multiple variables can be declared in a single const statement:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> const a, b = 1, 2\n(1, 2)","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"The const declaration should only be used in global scope on globals.  It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a const declaration solves this performance problem.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Local constants are quite different. The compiler is able to determine automatically when a local variable is constant, so local constant declarations are not necessary, and in fact are currently not supported.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Special top-level assignments, such as those performed by the function and struct keywords, are constant by default.","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Note that const only affects the variable binding; the variable may be bound to a mutable object (such as an array), and that object may still be modified. Additionally when one tries to assign a value to a variable that is declared constant the following scenarios are possible:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"if a new value has a different type than the type of the constant then an error is thrown:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> const x = 1.0\n1.0\n\njulia> x = 1\nERROR: invalid redefinition of constant x","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"if a new value has the same type as the constant then a warning is printed:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> const y = 1.0\n1.0\n\njulia> y = 2.0\nWARNING: redefining constant y\n2.0","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"if an assignment would not result in the change of variable value no message is given:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> const z = 100\n100\n\njulia> z = 100\n100","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"The last rule applies for immutable objects even if the variable binding would change, e.g.:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> const s1 = \"1\"\n\"1\"\n\njulia> s2 = \"1\"\n\"1\"\n\njulia> pointer.([s1, s2], 1)\n2-element Array{Ptr{UInt8},1}:\n Ptr{UInt8} @0x00000000132c9638\n Ptr{UInt8} @0x0000000013dd3d18\n\njulia> s1 = s2\n\"1\"\n\njulia> pointer.([s1, s2], 1)\n2-element Array{Ptr{UInt8},1}:\n Ptr{UInt8} @0x0000000013dd3d18\n Ptr{UInt8} @0x0000000013dd3d18","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"However, for mutable objects the warning is printed as expected:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> const a = [1]\n1-element Array{Int64,1}:\n 1\n\njulia> a = [1]\nWARNING: redefining constant a\n1-element Array{Int64,1}:\n 1","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"Note that although sometimes possible, changing the value of a const variable is strongly discouraged, and is intended only for convenience during interactive use.  Changing constants can cause various problems or unexpected behaviors.  For instance, if a method references a constant and is already compiled before the constant is changed then it might keep using the old value:","category":"page"},{"location":"manual/variables-and-scoping.html#","page":"Scope of Variables","title":"Scope of Variables","text":"julia> const x = 1\n1\n\njulia> f() = x\nf (generic function with 1 method)\n\njulia> f()\n1\n\njulia> x = 2\nWARNING: redefining constant x\n2\n\njulia> f()\n1","category":"page"},{"location":"manual/types.html#man-types-1","page":"型","title":"型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"型システムは、従来、2 つの全く異なる陣営に分類されてきました。: 静的型システムと動的型システムです。静的型システムでは、 すべてのプログラムの式は、プログラムの実行前に算出可能な型を持つ必要があります。一方動的型システムでは、プログラムによって処理されるされる実際の値が使用可能になる実行時まで、型については何もわかりません。オブジェクト志向プログラミングをすれば、静的型付け言語でも、コンパイル時に正確な値の型が分からなくてもコードを記述でき、あるていど柔軟性は高くなります。複数の異なる型を操作できるコードを記述する機能は、ポリモーフィズムと呼ばれます。 従来の動的型付け言語のすべてのコードはポリモーフィックです: 型に制約が生じるのは、明示的な型検査を行う場合もしくは、オブジェクトが実行時に操作に対応できなくなった場合です。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Julia の型システムは動的ですが、特定の値が特定の型であることを明示することで、静的型システムの利点の一部を得ることができます。これは効率的なコードを生成する上で大いに助けになるのですが、さらに重要なことに、関数引数の型に対するメソッドディスパッチを言語と深く統合できるのです。メソッドディスパッチはメソッドで詳しく説明しますが、ここで説明する型システムに根ざしています。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"型を省略した場合の Julia の既定の挙動では、値に対して任意の型が許容されます。したがって、型を明示的に使用しなくても、多くの便利な Julia 関数を記述できます。ただし、追加の表現力が必要な場合は、元の \"型指定されていない\" コードに対して明示的な型注釈を徐々に導入することは簡単です。型注釈の目的は主に3つあります。Julia の強力な多重ディスパッチ メカニズムを利用すること、人間にとって読みやすくすること、プログラマのエラーを補足できるようにすることです。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Julia を、型システムの言葉で説明するならば、動的で、公称的で、パラメトリック、といういことになります。ジェネリック型はパラメータ化でき、型同士が持つ階層的な関係は互換性のある構造によって暗示されるのではなく、明示的に宣言されます。Julia の型システムの特に特徴的な特徴の 1 つは、具象型が互いに互いのサブタイプにはできないということです。全ての具体型は全てファイナル(下の階層を持たない)で、具象型のサブタイプ(上の階層)は抽象型のみです。最初は過度な制限に見えるかもしれませんが、この制約は驚くほど欠点が少なく、多くの有益な結果を導きます。動作を継承できることは、構造を継承するよりもはるかに重要であり、その両方を継承すると、従来のオブジェクト指向言語のように大きな困難が生じます。前もって言及すべきJuliaの型システムの他の高レベルの側面は次のとおりです:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"オブジェクトか非オブジェクトかという区分はありません: Julia のすべての値は、単一の完全に接続された型グラフに属する型を持つ真のオブジェクトであり、すべてのノードは型として等しくファーストクラスです。\n「コンパイル時の型」という考え方は意味がありません: 値が持つ型は、プログラムの実行中の実際の型だけです。静的コンパイルとポリモーフィズムの組み合わせで成り立つオブジェクト指向の言語においては、コンパイル時/実行中の型の区別が重要になり、実行中の型のことは「ランタイム型」と呼びます。\n変数ではなく値だけが型を持ちます。変数は単に値にバインドされた名前です。\n抽象型と具象型の両方を他の型でパラメータ化できます。また、シンボル、値でその型が isbitsで true が返されるもの(本質的には、数値や真偽値などで、他のオブジェクトへのポインタを持たないC型やstructなどに格納されているもの)、およびそれらのタプルなどによってパラメータ化することもできます。型パラメーターは、参照や制限をする必要がない場合には省略できます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Julia の型システムは、強力で表現力豊かでありながら、明確で直感的で控えめであるように設計されています。 Julia プログラマの多くは、型を明示的に使用するコードを記述する必要性を感じないかもしれません。ただし、ある種のプログラミングでは、宣言された型を使用すると、より明確で、よりシンプルで、より速く、より堅牢になります。","category":"page"},{"location":"manual/types.html#type-declarations-1","page":"型","title":"型宣言","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"演算子 :: を使用すると、プログラム内の式や変数に型注釈をつけることができます。これを行う理由は主に2 つです:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"プログラムが期待どおりに動作することを確認するためのアサーションとして、\nコンパイラに追加の型情報を提供し、状況によってはパフォーマンスを向上できるようにすること","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"計算式に追加した::演算子は \"is an instance of\" と読み下すことができます。この演算子はどこでも使用することができ、演算子の左側の式の値が右側の型のインスタンスであることを表明します。演算子の右側の型が具象型の場合、左側の値はその型の実装でなければなりません。全ての具象型は、ファイナルで、その実装は他のどの具象型のサブタイプにもならないことを思い出してください。一方、演算子の右側の型が抽象型の場合、演算子の左側の値は、抽象型のサブタイプである具体的な型によって実装されれていれば十分です。型アサーションが 真でない場合は、例外が投げられますが、それ以外の場合は演算子の左側の値が返されます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> (1+2)::AbstractFloat\nERROR: TypeError: in typeassert, expected AbstractFloat, got Int64\n\njulia> (1+2)::Int\n3","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"これにより、型アサーションを任意の式に差し込むことができます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"代入文の左辺や、local 宣言の一部に追加すると、:: 演算子の持つ意味が少し変わります。C言語のような、静的型付き言語の型宣言のように、常に指定された型を持つ変数を宣言になります。変数に割り当てられた値はすべて、convert() を使用して宣言された型に変換されます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> function foo()\n           x::Int8 = 100\n           x\n       end\nfoo (generic function with 1 method)\n\njulia> foo()\n100\n\njulia> typeof(ans)\nInt8","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"この機能は、変数への代入を行って、 値が想定しない型に変更されてしまった時に起こることのある、パフォーマンス上の 「落とし穴」 を回避するのに役立ちます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"この 「宣言」の動作は、特定のコンテキストでのみ発生します:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"local x::Int8  # in a local declaration\nx::Int8 = 10   # as the left-hand side of an assignment","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"そして、宣言の前であっても、現在のスコープ全体に適用されます。現在、Julia には定数型グローバルがないため、型宣言は REPL などのグローバル スコープでは使用できません。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"また、宣言を、関数定義に差し込むこともできます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"function sinc(x)::Float64\n    if x == 0\n        return 1\n    end\n    return sin(pi*x)/(pi*x)\nend","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"この関数の戻り値は、宣言された型の変数への代入と同じ様に処理されます。値は常にFloat64 に変換されます。","category":"page"},{"location":"manual/types.html#抽象型-1","page":"型","title":"抽象型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"抽象型はインスタンス化できず、型グラフ内のノードとしてのみ機能するだけですが、だからこそ関連する具象型の集合(抽象型の子孫である具象型)を説明できます。型の説明は抽象型から始めます。インスタンス化はできないですが、抽象型は型システムのバックボーンだからです。抽象型は概念的な(型の)階層を形成します。この階層が、Julia No型システムを単なるオブジェクト実装の寄せ集め以上のものにしているのです。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"整数と浮動小数点数では、さまざまな具体的な数値を導入しました: Int8、UInt8、Int16、UInt16、Int32、UInt32、Int64、[UInt64](@ref)、Int128、UInt128、Float16、Float32、およびFloat64です。表現のサイズは異なりますが、Int8、Int16、Int32、Int64、Int128 には、すべて整数型が符号付き型であるという共通点があります。同様に、UInt8、UInt16、UInt32、UInt64およびUInt128は符号なし整数型であり、Float16、Float32、Float64は整数ではなく浮動小数点型とは異なります。たとえば、引数が何らかの整数である場合にのみ、コードの一部が意味をなすのが一般的ですが、実際には整数の特定の 種類 に依存しません。たとえば、最大公約数を求めるアルゴリズムは、あらゆる種類の整数に対して機能しますが、浮動小数点数では機能しません。抽象型を使用すると、型の階層を構築でき、具体的な型が適合するコンテキストを提供できます。これにより、たとえば、アルゴリズムを特定の整数に制限することなく、整数である任意の型に対してプログラミングすることが簡単にできます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"抽象型はabstract typeキーワードを使用して宣言されます。抽象型を宣言するための一般的な構文は次のとおりです:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"abstract type «name» end\nabstract type «name» <: «supertype» end","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"abstract type キーワードは、名前が «name» で指定される新しい抽象型を導入します。この型名の後には、<: と 既存の型が続くことがあり、これは新しく宣言された抽象型が、\"親\"とするサブタイプであることを示します。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"スーパータイプが指定されていない場合、デフォルトのスーパータイプは Any です。これは、定義済みの抽象型で、全てのオブジェクトはAnyのインスタンスであり、すべての型がAnyのサブタイプになります。型理論でAnyは、型グラフの頂点にあるため、一般的に 「トップ」 と呼ばれます。Julia には定義済の抽象型の 「ボトム」もあります。これは、型のグラフの最下層にあって、Union{} と書きます。これは Any の正反対です: 全てのオブジェクトは Union{} のインスタンスではなく、、すべての型は Union{} のスーパータイプです。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Julia の数値型の階層を構成する抽象型のいくつかを考えてみましょう:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"abstract type Number end\nabstract type Real     <: Number end\nabstract type AbstractFloat <: Real end\nabstract type Integer  <: Real end\nabstract type Signed   <: Integer end\nabstract type Unsigned <: Integer end","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Numberは「Any」の直接の子です。Realはそのさらに子に当たります。そして、Real には2人の子供がいます(本当はもっとありますが、ここでは2つだけ示します。他のものは後述します): 一つは Integer、もう一つはAbstractFloat です。数の世界を整数と実数の表現に分けます。実数の表現には、もちろん浮動小数点型が含まれるのですが、有理数など他の型もあります。したがって、AbstractFloatは Real の真のサブタイプで、実数の浮動小数点表現のみを含みます。整数はさらにsignedとunsigned に細分されます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"<: 演算子は一般に\"is a subtype of\" を意味しており、次のように宣言で使用します。演算子の右側の型が、新しく宣言した型のスーパータイプである、という宣言をします。また、式の中では　サブタイプ演算子として利用することもでき、左のオペランドが、右のオペランドのサブタイプである場合に trueを返します:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Integer <: Number\ntrue\n\njulia> Integer <: AbstractFloat\nfalse","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"抽象型の重要な使用方法に、具象型の既定の実装の提供があります。簡単な例として、以下を考えてみましょう:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"function myplus(x,y)\n    x+y\nend","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"最初に注意すべき点は、上記の引数宣言は、 x::Any および y::Any としたのに相当する、ということです。この関数がmyplus(2,5)のように呼び出されると、ディスパッチャーは指定された引数に一致する myplusという名前の最も具体的なメソッドを選択します。(多重ディスパッチの詳細については、メソッドを参照してください。）","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"上記のメソッドより具体的なメソッドが見つからない場合、Julia は次に内部で myplusという名前のメソッドを定義しコンパイルします。この例では、定義・コンパイルされるメソッドは、上記のジェネリック関数から、引数2個をInt型に特化させたものです。つまり、定義とコンパイルは暗黙裡に行われます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"function myplus(x::Int,y::Int)\n    x+y\nend","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"最後に、この特化したメソッドを呼び出します。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"このように、抽象型を使用することでプログラマはジェネリック関数を書くことができます。これは後に、具象型を組み合わせて使う時の、既定のメソッドとして使うことができるのです。多重ディスパッチのおかげで、プログラマはデフォルトの関数を使うか、より特化したメソッドを使うかを完全に制御できます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"注意すべき重要な点は、プログラマが　引数が抽象型の引数を持つ関数使っても、パフォーマンスが低下しない、ということです。このメソッドが呼び出される毎に、具象型の引数のタプルそれぞれに対してメソッドが再コンパイルするからです。(ただし、関数の引数が抽象型のコンテナーであるは、パフォーマンス上の問題が発生するかもしれません パフォーマンス・ティップスを参照のこと。)","category":"page"},{"location":"manual/types.html#プリミティブ型-1","page":"型","title":"プリミティブ型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"プリミティブ型は、データが普通ビットで構成される具象型です。プリミティブ型の典型的な例は、整数と浮動小数点の値です。ほとんどの言語とは異なり、Julia では、組み込みの決められたセットのみを提供するのではなく、独自のプリミティブ型を宣言できます。実際、標準のプリミティブ型はすべて(C言語ではなく)Julia 言語自体で定義されています:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"primitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end\n\nprimitive type Bool <: Integer 8 end\nprimitive type Char <: AbstractChar 32 end\n\nprimitive type Int8    <: Signed   8 end\nprimitive type UInt8   <: Unsigned 8 end\nprimitive type Int16   <: Signed   16 end\nprimitive type UInt16  <: Unsigned 16 end\nprimitive type Int32   <: Signed   32 end\nprimitive type UInt32  <: Unsigned 32 end\nprimitive type Int64   <: Signed   64 end\nprimitive type UInt64  <: Unsigned 64 end\nprimitive type Int128  <: Signed   128 end\nprimitive type UInt128 <: Unsigned 128 end","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"プリミティブ型を宣言するための一般的な構文は次のとおりです:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"primitive type «name» «bits» end\nprimitive type «name» <: «supertype» «bits» end","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"ビット数 «bits»は、その型に必要なストレージの量です。名前 «name» は新しい型につける名前です。プリミティブ型は、必要に応じて、いくつかのスーパータイプのサブタイプとして宣言できます。スーパータイプを省略した場合、その型はデフォルトで Any を直接のスーパータイプとして設定します。したがって、上記の Bool の宣言は、ブール値を格納するのに 8 ビットかかり、Integer を直接のスーパータイプとして持っていることを意味します。現在、8 ビットの倍数のサイズのみがサポートされています。したがって、ブール値は実際には 1 ビットしか必要としませんが、8 ビットより小さい値を宣言することはできません。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Bool、Int8およびUInt8の型はすべて同じ表現を持っています: どれも8ビットのメモリチャンクです。しかし、Juliaの型システムは公称的であるため、同一の構造であっても互換性はありません。これらの基本的な違いは、異なるスーパータイプを持っているということです:Boolの直接スーパータイプは[Integer](@ref)、[Int8](@ref)は[Signed](@ref)、UInt8(@ref)は[Unsigned](@ref)です。[Bool](@ref)、[Int8](@ref)、および[UInt8](@ref)のその他違いはすべて挙動に関するものです。これらの型のオブジェクトを引数として指定した場合に関数の挙動がどう定義されているかの違いです。もし、型の構造によって挙動が決まってしまうのであれば、[Int8](@ref)または[UInt8](@ref)とは異なる動作をする[Bool`](@ref)を作ることは不可能なるでしょう。","category":"page"},{"location":"manual/types.html#Composite-Types-1","page":"型","title":"複合型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"複合型 は様々な言語で、レコード、構造体、またはオブジェクトと呼ばれます。複合型は名前付きフィールドのコレクションで、そのインスタンスは単一の値として扱うことができます。多くの言語では、複合型はユーザー定義可能な型の唯一の種類であり、Julia でも最も一般的に使用されるユーザー定義型です。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"C++、Java、Python、Rubyなどの主流のオブジェクト指向言語では、複合型は、名前付けされた関数が関連付けられており、その組み合わせは \"オブジェクト\" と呼ばれます。Ruby や Smalltalk などの純粋なオブジェクト指向言語では、それが複合型であろうとなかろうと、すべての値がオブジェクトです。C++ や Java を含む純粋でないオブジェクト指向言語では、整数や浮動小数点値などの一部の値はオブジェクトではなく、ユーザー定義の複合型のインスタンスは真のオブジェクトで、関連付けられたメソッドを持ちます。Julia では、すべての値はオブジェクトですが、関数は操作対象のオブジェクトにバンドルされていません。これは、Juliaが多重ディスパッチで使用する関数のメソッドを選択するためです。これは、関数の最初の引数だけでなく、全ての引数がメソッド選択の際に考慮されるということを意味しています(メソッドとディスパッチについての詳細は メソッド 参照)。したがって、関数がその最初の引数だけに 「属している」という考え方は不適切です。各オブジェクトの「内部に」名前付きのメソッドのバッグ(メソッドの集合）を持つのではなく、メソッドを関数オブジェクトに編成する、ということをします。これは、Julia の言語設計の非常に有益な側面です。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"複合型は struct キーワードの後にフィールド名のブロックが付加され、必要に応じて :: 演算子を使用して型にアノテーションがされます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> struct Foo\n           bar\n           baz::Int\n           qux::Float64\n       end","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"型アノテーションのないフィールドはデフォルトで Anyになります。それに応じて任意の型の値を保持できます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"型Fooの新しいオブジェクトは、関数のような Foo 型のオブジェクトを関数のようにしてフィールドの値に適用することで作成できます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> foo = Foo(\"Hello, world.\", 23, 1.5)\nFoo(\"Hello, world.\", 23, 1.5)\n\njulia> typeof(foo)\nFoo","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"型が関数のように適用される時、これは コンストラクターと呼ばれています。2 つのコンストラクターが自動的に生成されます (これらは デフォルト コンストラクターと呼ばれています)。1 つは引数を受け入れ、フィールドの型に変換するために convert を呼び出し、もう 1 つはフィールドの型と完全に一致する引数だけを受け入れます。これらの両方が生成される理由は、誤って既定のコンストラクタを置き換えることなく、新しい定義を簡単に追加できるからです。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"barフィールドには型の制約はないので、値は何でも構いません。ただし、bazの値はIntに変換できる必要があります:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Foo((), 23.5, 1)\nERROR: InexactError: Int64(23.5)\nStacktrace:\n[...]","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"fieldnames関数をつかって、フィールド名の一覧を取得できます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> fieldnames(Foo)\n(:bar, :baz, :qux)","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"従来の表記法 foo.barを使用して、複合オブジェクトのフィールド値にアクセスできます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> foo.bar\n\"Hello, world.\"\n\njulia> foo.baz\n23\n\njulia> foo.qux\n1.5","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"struct で宣言された複合型オブジェクトは 不変です。作成後に変更できません。これは最初は奇妙に見えるかもしれませんが、いくつかの利点があります:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"より効率的になることがあります。一部の構造体は配列に効率的にパックでき、場合によってはコンパイラは不変オブジェクト全体を別のメモリに割り当てることを回避できることがあります。\n型コンストラクタで規定される不変性を破ることはできません。\n不変オブジェクトを使用するコードは、推論しやすくなります。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"不変オブジェクトには、配列などの変更可能なオブジェクトがフィールドに含まれている場合があります。含まれるオブジェクトは変更可能なままです。その不変オブジェクト自体フィールドが、異なるオブジェクトを指すよう変更することができなくなるだけです。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"必要に応じて、次のセクションで説明するキーワード mutable struct で、変更可能な複合オブジェクトを宣言できます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"フィールドのない不変複合型はシングルトンです。このような型のインスタンスは 1 つだけです:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> struct NoFields\n       end\n\njulia> NoFields() === NoFields()\ntrue","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"=== によって、NoFieldsの「２つの」インスタンスが、実際には一つで同じものであることを確認できます。 シングルトンタイプについては、以下 でさらに詳しく説明します。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"複合型のインスタンスがどのように生成されるかについては、まだまだ説明すべきことがありますが、その議論は [パラメトリック型(@ref Parametric-types)とメソッドの両方にも関わりがあり、とても重要な事項なので、コンストラクタ という独立のセクションを設けてそこで扱うことにします。","category":"page"},{"location":"manual/types.html#Mutable-Composite-Types-1","page":"型","title":"可変複合型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"複合型が、struct ではなく mutable struct キーワードで宣言されていれば、その型のインスタンスは変更可能です:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> mutable struct Bar\n           baz\n           qux::Float64\n       end\n\njulia> bar = Bar(\"Hello\", 1.5);\n\njulia> bar.qux = 2.0\n2.0\n\njulia> bar.baz = 1//2\n1//2","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"変更に対応できるように、このようなオブジェクトは、一般にヒープ上に割り当てられ、メモリアドレスが一定になっています。可変オブジェクトは、時間によって値の変わりうる小さなコンテナのようなもので、アドレスだけで確実に識別できます。対称的に、変更不可能な型のインスタンスは、特定のフィールド値に関連付けられています。フィールド値だけで、オブジェクトに関する全てがわかります。型を可変にするかどうかを決めるには、同じフィールド値を持つ2つのインスタンスは同一だとみなせるか、あるいは時間とともに別々に変更する必要があるかを考えます。同一であるとみなせるならば、おそらくその型は不変にすべきでしょう。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"まとめると、Julia では2 つの重要な特性で不変性を定義できます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"不変型の値を変更することはできません。\nビット型(プリミティブ型)の場合、一度設定された値のビット パターンは決して変わらず、その値はその型で恒等的であることを意味します。\n複合型の場合、フィールドの値の恒等性は決して変わらないことを意味します。フィールドがビット型の場合、そのビットは決して変わらず、フィールドが配列のような変更可能な型である場合、その変更可能な型の中身は変わっても、そのフィールドは常に同じ可変の値を参照することを意味します。\n不変型のオブジェクトは、コンパイラが自由にコピーすることができます。というのも、不変性によって、元のオブジェクトとコピーしたものを見分けることができないからです。\n特に、十分(メモリを専有する領域が)小さな 整数や浮動小数点数などの不変型は、通常はレジスタ (または割り当てられたスタック) にある関数にそのまま渡されます。\n変更可能な値は、(配列など、一般にメモリの使用量が大きくなり得るので)一方でヒープに割り当てられ、その配置された値へのポインタとして関数に渡されます。ただし、このような事象が起こっているかどうかを判別することがどうやっても不可能な状況だとコンパイラが判断した場合には、その限りではありません。","category":"page"},{"location":"manual/types.html#宣言型-1","page":"型","title":"宣言型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"上記セクションで説明した 3 種類の型 (抽象、プリミティブ型、複合型) は、実際には密接に関連しています。これらは、共通する重要な特徴を持ちます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"明示的に宣言されます。\n名前を持っています。\nスーパータイプを明示的に宣言します。\nパラメータを付けることができます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"こうした共通の特徴を持つため、これらの型は、内部的に同じ概念の DataType のインスタンスとして表現されます。DataType これら3つの型のいずれかをさします:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> typeof(Real)\nDataType\n\njulia> typeof(Int)\nDataType","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"DataTypeは抽象型、具象型どちらでもかまいません。具象型ならば、特定のサイズ、格納領域上のレイアウト、(場合によっては）フィールド名などがあります。プリミティブ型はゼロ以外のサイズの DataType ですが、フィールド名はありません。複合型は、フィールド名を持つか、、または空 (ゼロ サイズ)のDataTypeです。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"システム内のすべての具象型の値は、なんらかの DataType のインスタンスです。","category":"page"},{"location":"manual/types.html#合併型-1","page":"型","title":"合併型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"合併型は特殊な抽象型で、引数のいずれかの型のインスタンスが全てオブジェクトとして含みます。特殊なキーワードUnionを使って構築します:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> IntOrString = Union{Int,AbstractString}\nUnion{Int64, AbstractString}\n\njulia> 1 :: IntOrString\n1\n\njulia> \"Hello!\" :: IntOrString\n\"Hello!\"\n\njulia> 1.0 :: IntOrString\nERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"多くの言語のコンパイラには、型推論のために内部で使う合併構文があります。Juliaは単にそれをプログラマにも公開しているというわけです。Julia のコンパイラは、少数の型 の Union 型 を使うと効率的なコードを生成することがあります[1]。なりうる型すべてに個別に特化したコードを生成するためです。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"合併型のユースケースで特に便利なのは、Uniton{T, Nothing}です。ここでTは、任意の型を指定でき、Nothingは、唯一のインスタンスが nothingオブジェクトである、シングルトン型です。Julia のこのパターンは、他の言語のNullable, Option, Maybe 型などと同等です。関数の引数やフィールドをUniton{T, Nothing}として宣言すると型Tの値か、値がないことを示すnothingのどちらかに設定することができます。詳細については、FATのこの項目を見てください。","category":"page"},{"location":"manual/types.html#Parametric-Types-1","page":"型","title":"パラメトリック型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"Juliaの型システムの重要かつ強力な特徴は、型がパラメトリックであるということです: 型にパラメータをとることができます。そうすると型宣言は、実質的にとりうるそれぞれのパラメータの組み合わせに対応して、新しい型の一族を導入します。多くの言語が、何らかの形で汎化プログラミングをサポートしていますが、この汎化プログラミングでは、必要な型を正確にしなくても、処理すべきデータ構造とアルゴリズムを指定することができます。 たとえば、ML、Haskell、Ada、Eiffel、C++、Java、C#、F#、Scala には、何らかの形の汎化プログラミングを取り入れています。これらの言語の中には、真のパラメトリック多相性をサポートするものもあれば(ML、Haskell、Scalaなど)、アドホックなテンプレートベースの汎用プログラミングスタイルをサポートするもの(例えばC++、Java)もあります。さまざまな言語で多種多様な汎化プログラミングとパラメトリック型が使われているので、ここでは、それらと、Julia のパラメトリック型を比較するのではなく、Julia のシステムを単体について説明することに焦点を当てます。ただし、Julia は動的に型付け言語であり、コンパイル時にすべての型決定を行う必要がないため、静的パラメトリック型システムで発生する多くの従来の困難は比較的簡単に処理できることに注意してください。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"すべての宣言型 (DataType の仲間) は、それぞれ同じ構文でパラメータ化できます。最初に、パラメトリック複合型、次にパラメトリック抽象型、最後にパラメトリック プリミティブ型の順で説明します。","category":"page"},{"location":"manual/types.html#パラメトリック複合型-1","page":"型","title":"パラメトリック複合型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"型パラメータは、型名の直後に導入され、中かっこで囲みます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> struct Point{T}\n           x::T\n           y::T\n       end","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"この宣言では、タイプ T の 2 つの 「座標」を保持する新しいパラメトリック型 Point{T} を定義しています。「T」って何だ?と思うかもしれませんが、まあ、これがまさにパラメトリック型のポイントです: どんな型(またはプリミティブ型でも構いませんが、ここでは実際には明らかな型が使われています)でも構いません。Point{Float64} は、Point の定義で T を Float64 に置き換えたものと同等の具象型です。したがって、この一つの宣言文が実質的には、Point{Float64}、Point{AbstractString}、Point{Int64}など、無数の型に対する宣言に相当します。そして、それぞれが具象型として利用することができます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Point{Float64}\nPoint{Float64}\n\njulia> Point{AbstractString}\nPoint{AbstractString}","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Point{Float64}という型は座標が64ビット浮動小数点の値を持つ点であり、Point{AbstractString}という型は「座標」が文字列オブジェクトである「ポイント」です(文字列 を参照)。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Point (型パラメータ無しの単体) も有効な型オブジェクトで、Point{Float64}、Point{AbstractString}などすべてのインスタンスをサブタイプとして含んでいます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Point{Float64} <: Point\ntrue\n\njulia> Point{AbstractString} <: Point\ntrue","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"他の型は当然Pointのサブタイプではありません:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Float64 <: Point\nfalse\n\njulia> AbstractString <: Point\nfalse","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"異なる T の値がついた具象型Pointは決して互いにサブタイプになることはありません:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Point{Float64} <: Point{Int64}\nfalse\n\njulia> Point{Float64} <: Point{Real}\nfalse","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"!!! 警告     この最後のポイントは 非常に 重要です: Float64 <: Realは成り立ちますが、Point{Float64} <: Point{Real} は成り立ちません","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"型理論の述語で言い換えると、Julia の型パラメータは、共変 (もしくは反変) ではなく、不変 です。これには現実的な理由があります: Point{Float64}のインスタンスはPoint{Real}のインスタンスと概念的には似ていますが、2つの型のメモリ上での表現は異なります:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Point{Float64} のインスタンスは、64 ビット値の即時ペアとしてコンパクトかつ効率的に表現できます;\nPoint{Real} のインスタンスは、Real のインスタンスの任意のペアを保持できる必要があります。 Real のインスタンスであるオブジェクトは任意のサイズと構造を持つことができるため、実際にはPoint{Real} のインスタンスは、個別に割り当てられた Real オブジェクトへのポインタのペアとして表す必要があります。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Point{Float64} に値を直接格納できることで得られる効率は、配列の場合は非常に大きくなります: Array{Float64} は 64 ビット浮動小数点値の連続したメモリ ブロックとして格納されますが、Array{Real}は、個別に割り当てられたRealオブジェクトへのポインタの配列でなければなりません。抽象型Realに宣言されたオブジェクトの実装は、64ビット浮動小数点数がボックス化されている場合も、任意の大きさの複雑なオブジェクトである場合も許容しなくてはいけません。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Point{Float64} は Point{Real} のサブタイプではないため、次のメソッドは Point{Float64} 型の引数には適用できません:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"function norm(p::Point{Real})\n    sqrt(p.x^2 + p.y^2)\nend","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"T が Real のサブタイプである Point{T}のすべての引数を許容するメソッドの正しい定義方法は下記の通りです:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"function norm(p::Point{<:Real})\n    sqrt(p.x^2 + p.y^2)\nend","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"(同等の定義として、function norm(p::Point{T} where T<:Real) や、function norm(p::Point{T}) where T<:Real も可能です; 全合併型を参照。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"後の メソッド で、より多くの例を説明します。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Point オブジェクトはどのように構築されるでしょうか? コンストラクターで詳しく説明しますが、複合型に対して独自のコンストラクタを定義することは可能ですが、特別にコンストラクタの宣言をしない場合にも、デフォルトで新しい複合型オブジェクトを作成する方法が2つあります。1つは型パラメータを明示的に与えるもの、もう1つはオブジェクトコンストラクタへの引数から暗黙裡に推定されるものです。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"型 Point{Float64} は T の代わりに Float64 を使って宣言したPoint と同等の具象型であるため、それに応じてコンストラクタとしてそのまま適用できます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Point{Float64}(1.0, 2.0)\nPoint{Float64}(1.0, 2.0)\n\njulia> typeof(ans)\nPoint{Float64}","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"デフォルトのコンストラクタでは、フィールドごとに 引数を指定する必要があります:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Point{Float64}(1.0)\nERROR: MethodError: no method matching Point{Float64}(::Float64)\n[...]\n\njulia> Point{Float64}(1.0,2.0,3.0)\nERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)\n[...]","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"パラメトリック型では、デフォルトのコンストラクターは 1 つだけしか生成されません。オーバーライドできないため、このコンストラクターは任意の引数を受け取り、フィールドの型に変換します。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"多くの場合、生成しようとする Point オブジェクトの型を指定することは冗長です。コンストラクター呼び出しの引数の型には既に型情報が隠れているからです。そのため、パラメーター型 T を推論可能で曖昧さがない場合は、Point 自体をコンストラクタとして適用することもできます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Point(1.0,2.0)\nPoint{Float64}(1.0, 2.0)\n\njulia> typeof(ans)\nPoint{Float64}\n\njulia> Point(1,2)\nPoint{Int64}(1, 2)\n\njulia> typeof(ans)\nPoint{Int64}","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Point の場合、2 つの引数が同じ型である場合にのみ、T の型は明確に推論されます。そうでない場合、コンストラクタは失敗して MethodErrorが発生します:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Point(1,2.5)\nERROR: MethodError: no method matching Point(::Int64, ::Float64)\nClosest candidates are:\n  Point(::T, !Matched::T) where T at none:2","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"このように型が混在するケースを適切に処理するコンストラクター メソッドは定義できますが、後で コンストラクタに議論は譲ります。","category":"page"},{"location":"manual/types.html#パラメトリック抽象型-1","page":"型","title":"パラメトリック抽象型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"パラメトリック抽象型の宣言もほぼ同じ方法で、抽象型の一群に対して型宣言を行います:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> abstract type Pointy{T} end","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"この宣言では、Pointy{T} は、型や整数値を表す Tそれぞれに対して別々の抽象型になります。パラメトリ複合型と同様に、各インスタンスはPointyのサブタイプです:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Pointy{Int64} <: Pointy\ntrue\n\njulia> Pointy{1} <: Pointy\ntrue","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"パラメトリック抽象型は、パラメトリックな複合型と同じく 不変です:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Pointy{Float64} <: Pointy{Real}\nfalse\n\njulia> Pointy{Real} <: Pointy{Float64}\nfalse","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Pointy{<:Real}の表記で共変型のようなものを、Point{>:Int} の表記で反変型のようなものを表現できますが、技術的には、これらは型の集合を表しています。(全合併型参照)","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Pointy{Float64} <: Pointy{<:Real}\ntrue\n\njulia> Pointy{Real} <: Pointy{>:Int}\ntrue","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"通常の抽象型は、具象型に対して役に立つ型の階層を作成するのに使われるのに対して、パラメトリック抽象型は、パラメトリック複合型と同じような目的に使います。例えば、Point{T} を Pointy{T}のサブタイプとする宣言は次のように宣言します:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> struct Point{T} <: Pointy{T}\n           x::T\n           y::T\n       end","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"この宣言で、それぞれ選んだ T に対して、Pointy{T}のサブタイプであるPoint{T} を使うことができます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Point{Float64} <: Pointy{Float64}\ntrue\n\njulia> Point{Real} <: Pointy{Real}\ntrue\n\njulia> Point{AbstractString} <: Pointy{AbstractString}\ntrue","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"以下の関係も不変です:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Point{Float64} <: Pointy{Real}\nfalse\n\njulia> Point{Float64} <: Pointy{<:Real}\ntrue","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Pointy のようなパラメトリック抽象型の目的はなんでしょうか? Point が対角線 x=y上にあり、座標が1つあれば十分な場合における 点のような実装を考えてみると:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> struct DiagPoint{T} <: Pointy{T}\n           x::T\n       end","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"ここで、Point{Float64} と DiagPoint{Float64} は、抽象型Pointf{Float64} の実装です。これは Tに他の取りうる型を選んでも同じです。これによって、PointとDiagPoint のどちらを実装するにしても Pointy オブジェクトを共通のインターフェイスにするプログラミングが可能になります。これについての、完全な解説は、メソッドとディスパッチを導入する次の メソッド の章に譲ります。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"どんな型でも、型パラメータがとりうるようにしてしまうと、意味を成さない場合があります。そのような状況では次のように、 Tの範囲を制限することができます :","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> abstract type Pointy{T<:Real} end","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"この宣言では、Tが任意のRealのサブタイプの場合に許容され、そうでないものはは許容されません:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Pointy{Float64}\nPointy{Float64}\n\njulia> Pointy{Real}\nPointy{Real}\n\njulia> Pointy{AbstractString}\nERROR: TypeError: in Pointy, in T, expected T<:Real, got Type{AbstractString}\n\njulia> Pointy{1}\nERROR: TypeError: in Pointy, in T, expected T<:Real, got Int64","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"パラメトリック複合型の型パラメータも同じ方法で制限できます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"struct Point{T<:Real} <: Pointy{T}\n    x::T\n    y::T\nend","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"現実世界での、パラメータ型がどれほど役に立つかの例として、ここでは、整数の比を表す Rational という不変型が、Juliaでどの様に定義されているかを示します。(単純化のため、ここではコンストラクタは省略):","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"struct Rational{T<:Integer} <: Real\n    num::T\n    den::T\nend","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"これは、整数値の比率になるときだけ 有理数としての意味をなすので、パラメータの型Tは、Integerのサブタイプに限定されています。整数の比は数直線上の値を表現するので、任意のRationalは、抽象型Realのインスタンスです。","category":"page"},{"location":"manual/types.html#Tuple-Types-1","page":"型","title":"タプル型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"タプルとは、関数本体から、引数だけを抜き取りだしたものです。関数の引数の顕著な特徴は、順序と型です。そのため、タプル型は、不変なパラメータ複合型で、かつ各パラメータがフィールドの型に対応しているものに似ています。例えば、2要素のタプル型は、次の複合型に似ています:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"struct Tuple2{A,B}\n    a::A\n    b::B\nend","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"ただし、重要な違いが3 つあります:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"タプル型は、任意の数のパラメータを持つことができます。\nタプル型は、そのパラメータと 共変 です: Tuple{int} は Tuple{Any} のサブタイプです。したがって、Tuple{Any} は抽象型とみなされ、タプル型はそのパラメータが具象型の場合にのみ、具象型である、ということになります。\nタプルにフィールド名はありません; フィールドはインデックスでのみアクセスできます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"タプルの値は、括弧とカンマを使って書かれます。タプルが生成されたとき、必要に応じて適切なタプル型が生成されます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> typeof((1,\"foo\",2.5))\nTuple{Int64,String,Float64}","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"暗黙的に共変となることに注目してください:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Tuple{Int,AbstractString} <: Tuple{Real,Any}\ntrue\n\njulia> Tuple{Int,AbstractString} <: Tuple{Real,Real}\nfalse\n\njulia> Tuple{Int,AbstractString} <: Tuple{Real,}\nfalse","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"直感的には、これは関数の引数の型が関数のシグネチャのサブタイプであることに相当します。(シグネチャが適合する場合)。","category":"page"},{"location":"manual/types.html#可変引数タプル型-1","page":"型","title":"可変引数タプル型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"タプル型の最後のパラメータは、特殊な型 Varargにすることが可能です。Varargは、任意個数の後続の要素を表します:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> mytupletype = Tuple{AbstractString,Vararg{Int}}\nTuple{AbstractString,Vararg{Int64,N} where N}\n\njulia> isa((\"1\",), mytupletype)\ntrue\n\njulia> isa((\"1\",1), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2,3.0), mytupletype)\nfalse","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Vararg{T}は、0個以上の型Tに対応することに注意してください。可変引数タプル型は、可変引数メソッドによって受け入れられる引数を表すために使用されます。(可変引数関数を参照。)","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"型Vararg{T,N} は、ちょうどN個の型Tに対応します。NTuple{N,T} は Tuple{Vararg{T,N}}の便利なエイリアスです。つまり、型Tの要素をちょうどN個含むタプル型です。","category":"page"},{"location":"manual/types.html#名前付きタプル型-1","page":"型","title":"名前付きタプル型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"名前付きタプル型は、NamedTuple 型のインスタンスで、2 つのパラメータを取ります。シンボルのタプルはフィールド名、型のタプルはフィールドの型を与えます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> typeof((a=1,b=\"hello\"))\nNamedTuple{(:a, :b),Tuple{Int64,String}}","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"NamedTuple型は、コンストラクタとしても利用可能で、1 個のタプルを引数としてとります。生成されたNamedTupleの型は、両方のパラメータの指定された具象型か、フィールド名だけが指定された型になります:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> NamedTuple{(:a, :b),Tuple{Float32, String}}((1,\"\"))\n(a = 1.0f0, b = \"\")\n\njulia> NamedTuple{(:a, :b)}((1,\"\"))\n(a = 1, b = \"\")","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"フィールドの型を指定すると、引数が変換されます。そうでない場合は、引数の型がそのまま使われます。","category":"page"},{"location":"manual/types.html#man-singleton-types-1","page":"型","title":"シングルトン型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"ここで、特殊なパラメータ抽象型であるシングルトン型について触れておくべきでしょう。型 T それぞれに対して、「シングルトン型」 Type{T} は、インスタンスが T一つだけの抽象型です。定義を構文的に説明するのは難しいので、例をいくつか見てみましょう:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> isa(Float64, Type{Float64})\ntrue\n\njulia> isa(Real, Type{Float64})\nfalse\n\njulia> isa(Real, Type{Real})\ntrue\n\njulia> isa(Float64, Type{Real})\nfalse","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"つまり、isa(A,Type{B})が真を返すのは、AとBが同じオブジェクトで、そのオブジェクトが型である場合に限る、ということです。パラメータ無しの Typeは、単なる抽象型で、全てのオブジェクトはTypeのインスタンスです(もちろんシングルトン型も含みます):","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> isa(Type{Float64}, Type)\ntrue\n\njulia> isa(Float64, Type)\ntrue\n\njulia> isa(Real, Type)\ntrue","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"型でないオブジェクトは、Typeのインスタンスではありません:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> isa(1, Type)\nfalse\n\njulia> isa(\"foo\", Type)\nfalse","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"パラメトリックメソッド と 変換 の議論をする前に、シングルトン型の仕組みがどう役に立つかを説明することは難しいのですが、手短にいうと、関数の挙動を特定の型の値だけに特化することができます。これが役に立つのは、挙動が型によってきまる(特にパラメトリックな)メソッドを書く時で、しかもその型が勝手に推論されるのでなく、わざわざ引数として与える場合です。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Haskell, Scala, Rubyなどの人気のある言語はシングルトン型があります。一般的な使用方法では、「シングルトン型」という用語は、唯一のインスタンスが単一の値である型のことを指します。この意味はJuliaのシングルトン型にも当てはまっていますが、型オブジェクトだけがシングルトン型になるという点が特殊なので注意してください。","category":"page"},{"location":"manual/types.html#パラメトリックプリミティブ型-1","page":"型","title":"パラメトリックプリミティブ型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"プリミティグ型にもパラメータをつけて宣言することができます。例えば、ポインタはプリミティブ型として表現ができ、Juliaでは以下のように宣言します:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"# 32-bit system:\nprimitive type Ptr{T} 32 end\n\n# 64-bit system:\nprimitive type Ptr{T} 64 end","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"一般的なパラメトリック複合型とは比べて、これらの宣言には少し変な特徴があります。それは、型パラメータTがその型自体の定義の中で使われていないとうことです。パラメータは単なる抽象的なタグであり、全く同一の構造である型ファミリー全体を本質的に定義します。その型ファミリーのそれぞれは、型パラメータのみで差別化されています。そのため、Ptr{Float64} と Ptr{Int64} は、まったく同じ表現であっても型としては異なります。そしてもちろん、全ての個別ポインタ型は、包括型Ptrのサブタイプです:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Ptr{Float64} <: Ptr\ntrue\n\njulia> Ptr{Int64} <: Ptr\ntrue","category":"page"},{"location":"manual/types.html#UnionAll-Types-1","page":"型","title":"全合併型","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"上述のように、Ptr のようなパラメトリック型は、すべてのインスタンス (Ptr{Int64} など) のスーパータイプとして機能します。その具体的な振る舞いはどのようなものでしょうか? Ptr 自体は、通常のデータ型ではありません。というのも、参照されるデータの型を知らなければ、明らかにその型をメモリ操作に使用できないからです。答えは、Ptr (またはArrayのような他のパラメトリック型) は、全合併 型と呼ばれる種類の異なる型です。この型は、あるパラメーターをすべての値に対して、繰り返し合併した 反復共用体 を表現します。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"全合併型は通常、キーワード where を使用して書かれます。たとえば、Ptr は より正確にはPtr{T} where Tと書くことができて、その意味は、「あるTという値によってPtr{T} のようにかける型をもつ値全て」ということです。この文脈では、パラメータ T は型にまたぐ変数のようなもので、\"型変数\" とも呼ばれます。 それぞれの where は単一の型変数を導入するので、これらの式は複数のパラメーターを持つ場合、例えば Array{T,N} where N where T のように型に対してネストネストされます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"型の適用構文 A{B,C} では A が 全合併型にする必要があります。最初に A の最も外側の型変数を B で置き換えます。 その結果は別の 全合併型になることが想定され、C に置き換えられます。よって A{B,C} は A{B}{C} に相当します。 これは、Array{Float64} のように型を部分的にインスタンス化することが可能である理由の説明になっています。: 最初のパラメーター値は固定されていますが、2 番目のパラメーターは全てのとりうる値にまたがっているからです。 明示的な where 構文を使用すると、どんなパラメーターのサブセットにでも固定できます。たとえば、すべての 1 次元配列の型は、Array{T,1} where T と書くことができます。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"型変数は、サブタイプの関係をつかって制限することができます。 Array{T}  where T <: Integer で、要素の型が Integerのいずれかである配列すべてを指しています。 構文 Array{<: Integer} は、Array{T} where  T<:Integer の便利な簡略表記です。 型変数は、下限と上限の両方を指定することができます。 Array{T} where Int<:T<:Number は、Number の配列でIntを含むもの全てを指します。(T は少なくとも Int 以上の大きさでなければいけません)。構文 where T>:Int はまた、型変数の下限のみを指定しています。Array{>:Int}は、Array{T} where T>:Int と同等です。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"where 式は入れ子にできるので、型変数の境界は外側の型変数を参照できます。 たとえば、Tuple{T,Array{S}} where S<:AbstractArray{T} where T<:Real は、次の2要素タプルを参照します:  第一要素は Real のいずれか、第二要素は、 各要素が第一要素と同じ型を要素に持つ配列。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"where キーワード自体は、より複雑な宣言の内側で入れ子にすることができます。たとえば、次の宣言によって作成された 2 つの型について考えてみましょう:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> const T1 = Array{Array{T,1} where T, 1}\nArray{Array{T,1} where T,1}\n\njulia> const T2 = Array{Array{T,1}, 1} where T\nArray{Array{T,1},1} where T","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"型 T1 は、1 次元配列を要素とする 1 次元配列を定義します:  内側の配列のかたは T で表されていますが、内側の配列を1つ抜き出してくるとその各要素の型は同じだということで、また別の内側の配列を取り出し来たとき、その要素は別の型の場合があります。 一方、型T2は、内部配列の内側の配列のすべてが 1 次元配列の方が等しい 1次元配列の1 次元配列を定義します。 T2 は抽象型であり、例えばArray{Array{Int,1},1} <: T2 であるのに対して、T1 は具象型です。その結果、T1 はゼロ引数コンストラクタ a=T1() で構築できますが、T2 ではできません。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"関数定義構文の短い形式と同様に、このような型に名前を付ける便利な構文があります:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Vector{T} = Array{T,1}","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"これはconst Vector = 配列{T,1} Tと同等です。 Vector{Float64} の書き込みは Array{Float64,1} を書くのと同じで、包括型の Vector は、要素の型に関係なく、2 番目のパラメーター (配列ディメンションの数) が 1 であるすべての Array オブジェクトをインスタンスとして持ちます。パラメトリック型を常に完全に指定する必要がある言語では、これは特に役に立ちませんが、Julia では、Vector と書くだけで、任意の要素型のすべての 1 次元の密な配列を含む抽象型を表現することができます。","category":"page"},{"location":"manual/types.html#型エイリアス-1","page":"型","title":"型エイリアス","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"既に表現可能な型に新しい名前を導入すると便利な場合があります。 これは、単純な代入文で行うことができます。 たとえば、UInt は、システム上のポインターのサイズに適した UInt32 または UInt64 のいずれかに別名です:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"# 32-bit system:\njulia> UInt\nUInt32\n\n# 64-bit system:\njulia> UInt\nUInt64","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"これはbase/boot.jlの以下のコードで実現されています:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"if Int === Int64\n    const UInt = UInt64\nelse\n    const UInt = UInt32\nend","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"もちろん、これは Int がInt32または Int64) のどちらの別名なのかで変わりますが、この別名は正しい方になるよう事前に定義されています。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"(Int とは異なり、Float は特定のサイズの AbstractFloatの型の別名が存在しないことに注意してください。'Int' のサイズがそのマシン上のネイティブ ポインターのサイズを反映する整数レジスタとは異なり、浮動小数点レジスタ のサイズは IEEE-754 標準で規定されています。)","category":"page"},{"location":"manual/types.html#型に対する演算-1","page":"型","title":"型に対する演算","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"Julia の型はそれ自体がオブジェクトであるため、通常の関数を作用させられます。 型の操作や探索に特に役立つ関数が既に導入されています。 <: 演算子などは、左手のオペランドが、右側のオペランドのサブタイプであるかどうかを示す演算子です。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"isa 関数は、オブジェクトが指定された型であるかを検査し、真偽値を返します:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> isa(1, Int)\ntrue\n\njulia> isa(1, AbstractFloat)\nfalse","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"typeof 関数は、すでにこのマニュアルを通して使われていますが、引数で与えられたオブジェクトの型を返します。前述のように、型はオブジェクトであるため、型も型を持ち、typeof の引数として型を与えるおｋとができます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> typeof(Rational{Int})\nDataType\n\njulia> typeof(Union{Real,String})\nUnion","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"この操作をを繰り返したらどうなるでしょうか? 型の型の型は何でしょう? すでに見たように、型はすべて複合型の値なので、すべてDataType型になります:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> typeof(DataType)\nDataType\n\njulia> typeof(Union)\nDataType","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"DataTypeは自身の型でもあります。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"一部の型に適用することのある、もう 1 つの操作はsupertypeです。引数の型のスーパータイプを明らかにします。宣言型 (DataType ) のみが、明確なスーパータイプを持っています:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> supertype(Float64)\nAbstractFloat\n\njulia> supertype(Number)\nAny\n\njulia> supertype(AbstractString)\nAny\n\njulia> supertype(Any)\nAny","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"supertypeを他の型オブジェクト(または型ではないオブジェクト)に適用すると、MethodErrorが発生します:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> supertype(Union{Float64,Int64})\nERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})\nClosest candidates are:\n  supertype(!Matched::DataType) at operators.jl:42\n  supertype(!Matched::UnionAll) at operators.jl:47","category":"page"},{"location":"manual/types.html#man-custom-pretty-printing-1","page":"型","title":"独自の整形表示","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"型のインスタンスの表示方法をカスタマイズしたくい場合がよくあります。これはshow関数をオーバーロードすることによって実現されます。 たとえば、極座標形式で複素数を表す型を定義したとします:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> struct Polar{T<:Real} <: Number\n           r::T\n           Θ::T\n       end\n\njulia> Polar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)\nPolar","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"ここでは、異なる Real 型の引数を受け取り、それらを共通の型に昇格できるようにカスタム コンストラクター関数を追加しました (コンストラクターと変換と昇格を参照)。 (もちろん、Number 型と同じ用に動作させるためには、他の多くのメソッドを定義する必要があるでしょう。例えば、+、*、one、zero、昇格のルールなど。既定では、この型のインスタンスは、単に、型名とフィールド値に関する情報を`Polar{Float64}(3.0,4.0))と表示します。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"代わりに 3.0 * exp(4.0im) として表示したい場合は、特定の出力オブジェクト io(ファイル、端末、バッファなどを表します。 ネットワークとストリームを参照) にオブジェクトを出力する次のメソッドを定義します:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Base.show(io::IO, z::Polar) = print(io, z.r, \" * exp(\", z.Θ, \"im)\")","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Polarオブジェクトの表示をより細かく制御することができます。特に、REPL などの対話型環境で単一のオブジェクトを表示するのに使用される冗長な複数行印刷形式と、オブジェクトを別の(配列などの)オブジェクトの一部としてprint するシンプルな単一行形式 の両方が必要な場合があります。デフォルトでは show(io,z) 関数がどちらの場合も呼び出されますが、ユーザー定義の 別の 複数形式で表示するためには、3引数をとるshow関数で、2番めの引数に text/plain MIME タイプ (Multimedia I/O参照)をとるものをオーバーロードします。例えば:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Base.show(io::IO, ::MIME\"text/plain\", z::Polar{T}) where{T} =\n           print(io, \"Polar{$T} complex number:\\n   \", z)","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"(ここで print(...,z) は 2 引数 のshow(io,z) メソッドを呼び出すことに注意。) この結果は、下記のとおりです:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Polar(3, 4.0)\nPolar{Float64} complex number:\n   3.0 * exp(4.0im)\n\njulia> [Polar(3, 4.0), Polar(4.0,5.3)]\n2-element Array{Polar{Float64},1}:\n 3.0 * exp(4.0im)\n 4.0 * exp(5.3im)","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"ここで、単一行の show(io,z) 形式はPolar 値の配列に引き続き使用されますています。 技術的には REPL が display(z) を呼び出して行を実行した結果を表示します。複数行印刷形式では、show(stdout, MIME(\"text/plain\"), z)  単一行形式はshow(stdout,z) がデフォルトになります。 しかし、新しいマルチメディア表示ハンドラを定義しない限りは(Multimedia I/Oを参照)、新しい displayメソッドを定義すべきではありません。 ","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"さらに、IJulia などの環境で、オブジェクトのより豊かな表示(HTML、画像など)をするために、他の MIME タイプの showメソッドを定義することもできます。  例えば、Polarオブジェクトに対して、書式付きのHTML表示を定義して、上付き文字と斜体を使うには以下のようにします:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> Base.show(io::IO, ::MIME\"text/html\", z::Polar{T}) where {T} =\n           println(io, \"<code>Polar{$T}</code> complex number: \",\n                   z.r, \" <i>e</i><sup>\", z.Θ, \" <i>i</i></sup>\")","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Polarオブジェクトは、HTML 表示をサポートする環境では、 HTMLを使用して自動的に表示されますが、必要に応じて手動で show を呼び出して HTML 出力を取得できます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> show(stdout, \"text/html\", Polar(3.0,4.0))\n<code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup>","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"<p>An HTML renderer would display this as: <code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup></p>","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"経験則として、単一行の show メソッドは、表示されたオブジェクトを作成する、有効な Julia 式を表示すべきです。上記の Polar の単一行の show メソッドに乗算演算子 (*) などの二項演算子が含まれている場合、別のオブジェクトの一部として表示する際に、正しく解析されないことがあります。 これを確認するために、Polar 型の具体的なインスタンスの二乗の式オブジェクト (プログラムの表現を参照)を考えます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> a = Polar(3, 4.0)\nPolar{Float64} complex number:\n   3.0 * exp(4.0im)\n\njulia> print(:($a^2))\n3.0 * exp(4.0im) ^ 2","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"演算子 ^ の優先順位は * よりも高いため (演算子の優先順位と結合則を参照)、この出力は (3.0 * exp(4.0im)) ^ 2 と等しいはずの式 a ^ 2 を忠実に表示しません。 この問題を解決するには、出力時に式オブジェクトによって内部的に呼び出される Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)のカスタムメソッドを作成する必要があります:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> function Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)\n           if Base.operator_precedence(:*) <= precedence\n               print(io, \"(\")\n               show(io, z)\n               print(io, \")\")\n           else\n               show(io, z)\n           end\n       end\n\njulia> :($a^2)\n:((3.0 * exp(4.0im)) ^ 2)","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"上記で定義したメソッドは、呼び出し元演算子の優先順位が乗算の優先順位以上である場合に、括弧を追加します。 この検査によって、括弧なしでも正しく解析する式 (:($a + 2)や:($a =2)など) では、括弧を省略して表示できます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> :($a + 2)\n:(3.0 * exp(4.0im) + 2)\n\njulia> :($a == 2)\n:(3.0 * exp(4.0im) == 2)","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"場合によっては、コンテキストに応じて show メソッドの動作を調整すると便利です。これはIOContext型で実現可能です。ラップされた IO ストリームと共にコンテキストプロパティを渡すことができます。 たとえば、:compact プロパティが true に設定されている場合は、show メソッドで短い表現を作成し、false または指定なしだと、長い表現になるというようなことができます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> function Base.show(io::IO, z::Polar)\n           if get(io, :compact, false)\n               print(io, z.r, \"ℯ\", z.Θ, \"im\")\n           else\n               print(io, z.r, \" * exp(\", z.Θ, \"im)\")\n           end\n       end","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"この新しい簡潔な表現は、渡された IO ストリームが :compact プロパティ セットを持つ IOContext オブジェクトである場合に使用されます。特に、水平方向の幅が制限されていて、配列を何段かで表示する場合などに役立ちます:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> show(IOContext(stdout, :compact=>true), Polar(3, 4.0))\n3.0ℯ4.0im\n\njulia> [Polar(3, 4.0) Polar(4.0,5.3)]\n1×2 Array{Polar{Float64},2}:\n 3.0ℯ4.0im  4.0ℯ5.3im","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"表示の調整に使用できる一般的なプロパティの一覧については、IOContextのドキュメントを参照してください。","category":"page"},{"location":"manual/types.html#\"Value-types\"-1","page":"型","title":"\"値型\"","text":"","category":"section"},{"location":"manual/types.html#","page":"型","title":"型","text":"Julia では、true や falseなどの値を関数ディスパッチに使用できません。ただし、パラメトリック型によるディスパッチは可能で、その型パラメータとして 「普通の」値 (型、シンボル、整数、浮動小数点数、タプルなど) を使うことができます。 一般的な例はArray{T,N}の次元パラメータです。Tは型 (例えば、Float64)ですが、Nは単なるInt型の値です。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"値をパラメーターとして受け取る独自の型を作成し、それらを使用してディスパッチを制御できます。この考え方を説明するために、パラメトリック型の Val{x}とコンストラクター Val(x) = Val{x}()を導入しましょう。手の混んだ階層を必要としないときには、この手法にはこの型を慣用的に用います。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Valは次のように定義します:","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> struct Val{x}\n       end\n\njulia> Val(x) = Val{x}()\nVal","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Valの実装はこれ以上ありません。 Julia の標準ライブラリの関数には、Val型のインスタンスを引数にとるものがあり、独自の関数を書くときにも Val 型を利用できます。例えば:  例えば：","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"julia> firstlast(::Val{true}) = \"First\"\nfirstlast (generic function with 1 method)\n\njulia> firstlast(::Val{false}) = \"Last\"\nfirstlast (generic function with 2 methods)\n\njulia> firstlast(Val(true))\n\"First\"\n\njulia> firstlast(Val(false))\n\"Last\"","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Julia 全体で一貫性を保つために、呼び出し側で常に Valtypeを使用するのではなく、Valのインスタンスを渡します。つまり、呼び方は、foo(Val{:bar}) ではなく foo(Val(:bar)) です。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"Valを含むパラメトリックな「値」型は、非常に誤用しやすいので注意して下さい。 ひどいときは、コードのパフォーマンスを大幅に低下させる可能性があります。  特に、上記のようなコードを、実用的に使いたいと思うことはないでしょう。 適切(および不適切)なValの使用方法野詳細については、パフォーマンス・ティップスの広範な議論を読んでください。","category":"page"},{"location":"manual/types.html#","page":"型","title":"型","text":"[1]: ここでいう、\"少数\" はMAX_UNION_SPLITTING定数で定義され、現在 4 に設定されています。","category":"page"},{"location":"manual/methods.html#Methods-1","page":"メソッド","title":"メソッド","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Recall from Functions that a function is an object that maps a tuple of arguments to a return value, or throws an exception if no appropriate value can be returned. It is common for the same conceptual function or operation to be implemented quite differently for different types of arguments: adding two integers is very different from adding two floating-point numbers, both of which are distinct from adding an integer to a floating-point number. Despite their implementation differences, these operations all fall under the general concept of \"addition\". Accordingly, in Julia, these behaviors all belong to a single object: the + function.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"To facilitate using many different implementations of the same concept smoothly, functions need not be defined all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of argument types and counts. A definition of one possible behavior for a function is called a method. Thus far, we have presented only examples of functions defined with a single method, applicable to all types of arguments. However, the signatures of method definitions can be annotated to indicate the types of arguments in addition to their number, and more than a single method definition may be provided. When a function is applied to a particular tuple of arguments, the most specific method applicable to those arguments is applied. Thus, the overall behavior of a function is a patchwork of the behaviors of its various method definitions.  If the patchwork is well designed, even though the implementations of the methods may be quite different, the outward behavior of the function will appear seamless and consistent.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"The choice of which method to execute when a function is applied is called dispatch. Julia allows the dispatch process to choose which of a function's methods to call based on the number of arguments given, and on the types of all of the function's arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument.  [1] Using all of a function's arguments to choose which method should be invoked, rather than just the first, is known as multiple dispatch.  Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to \"belong\" to one argument more than any of the others: does the addition operation in x + y belong to x any more than it does to y? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"[1]: In C++ or Java, for example, in a method call like obj.meth(arg1,arg2), the object obj \"receives\" the method call and is implicitly passed to the method via the this keyword, rather than as an explicit method argument. When the current this object is the receiver of a method call, it can be omitted altogether, writing just meth(arg1,arg2), with this implied as the receiving object.","category":"page"},{"location":"manual/methods.html#Defining-Methods-1","page":"メソッド","title":"Defining Methods","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Until now, we have, in our examples, defined only functions with a single method having unconstrained argument types. Such functions behave just like they would in traditional dynamically typed languages.  Nevertheless, we have used multiple dispatch and methods almost continually without being aware of it: all of Julia's standard functions and operators, like the aforementioned + function, have many methods defining their behavior over various possible combinations of argument type and count.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"When defining a function, one can optionally constrain the types of parameters it is applicable to, using the :: type-assertion operator, introduced in the section on Composite Types:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> f(x::Float64, y::Float64) = 2x + y\nf (generic function with 1 method)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"This function definition applies only to calls where x and y are both values of type Float64:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> f(2.0, 3.0)\n7.0","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Applying it to any other types of arguments will result in a MethodError:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> f(2.0, 3)\nERROR: MethodError: no method matching f(::Float64, ::Int64)\nClosest candidates are:\n  f(::Float64, !Matched::Float64) at none:1\n\njulia> f(Float32(2.0), 3.0)\nERROR: MethodError: no method matching f(::Float32, ::Float64)\nClosest candidates are:\n  f(!Matched::Float64, ::Float64) at none:1\n\njulia> f(2.0, \"3.0\")\nERROR: MethodError: no method matching f(::Float64, ::String)\nClosest candidates are:\n  f(::Float64, !Matched::Float64) at none:1\n\njulia> f(\"2.0\", \"3.0\")\nERROR: MethodError: no method matching f(::String, ::String)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"As you can see, the arguments must be precisely of type Float64. Other numeric types, such as integers or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because Float64 is a concrete type and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type Float64. It may often be useful, however, to write more general methods where the declared parameter types are abstract:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> f(x::Number, y::Number) = 2x - y\nf (generic function with 2 methods)\n\njulia> f(2.0, 3)\n1.0","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"This method definition applies to any pair of arguments that are instances of Number.  They need not be of the same type, so long as they are each numeric values. The problem of handling disparate numeric types is delegated to the arithmetic operations in the expression 2x - y.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"To define a function with multiple methods, one simply defines the function multiple times, with different numbers and types of arguments. The first method definition for a function creates the function object, and subsequent method definitions add new methods to the existing function object.  The most specific method definition matching the number and types of the arguments will be executed when the function is applied. Thus, the two method definitions above, taken together, define the behavior for f over all pairs of instances of the abstract type Number – but with a different behavior specific to pairs of Float64 values. If one of the arguments is a 64-bit float but the other one is not, then the f(Float64,Float64) method cannot be called and the more general f(Number,Number) method must be used:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> f(2.0, 3.0)\n7.0\n\njulia> f(2, 3.0)\n1.0\n\njulia> f(2.0, 3)\n1.0\n\njulia> f(2, 3)\n1","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"2x + y の定義は最初のケースでのみ使用され、2x - y の定義は他のケースで使用されます。関数の引数の自動キャストや変換は実行されません: Julia のすべての変換に魔術は無く、完全に明示的です。しかしながら、変換と昇格は、十分高度な技術を巧妙に応用することでが魔法と区別できなくなることを示しています。[Clarke61]","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"For non-numeric values, and for fewer or more than two arguments, the function f remains undefined, and applying it will still result in a MethodError:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> f(\"foo\", 3)\nERROR: MethodError: no method matching f(::String, ::Int64)\nClosest candidates are:\n  f(!Matched::Number, ::Number) at none:1\n\njulia> f()\nERROR: MethodError: no method matching f()\nClosest candidates are:\n  f(!Matched::Float64, !Matched::Float64) at none:1\n  f(!Matched::Number, !Matched::Number) at none:1","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"You can easily see which methods exist for a function by entering the function object itself in an interactive session:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> f\nf (generic function with 2 methods)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"This output tells us that f is a function object with two methods. To find out what the signatures of those methods are, use the methods function:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> methods(f)\n# 2 methods for generic function \"f\":\n[1] f(x::Float64, y::Float64) in Main at none:1\n[2] f(x::Number, y::Number) in Main at none:1","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"which shows that f has two methods, one taking two Float64 arguments and one taking arguments of type Number. It also indicates the file and line number where the methods were defined: because these methods were defined at the REPL, we get the apparent line number none:1.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"In the absence of a type declaration with ::, the type of a method parameter is Any by default, meaning that it is unconstrained since all values in Julia are instances of the abstract type Any. Thus, we can define a catch-all method for f like so:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> f(x,y) = println(\"Whoa there, Nelly.\")\nf (generic function with 3 methods)\n\njulia> f(\"foo\", 1)\nWhoa there, Nelly.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"This catch-all is less specific than any other possible method definition for a pair of parameter values, so it will only be called on pairs of arguments to which no other method definition applies.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language. Core operations typically have dozens of methods:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> methods(+)\n# 180 methods for generic function \"+\":\n[1] +(x::Bool, z::Complex{Bool}) in Base at complex.jl:227\n[2] +(x::Bool, y::Bool) in Base at bool.jl:89\n[3] +(x::Bool) in Base at bool.jl:86\n[4] +(x::Bool, y::T) where T<:AbstractFloat in Base at bool.jl:96\n[5] +(x::Bool, z::Complex) in Base at complex.jl:234\n[6] +(a::Float16, b::Float16) in Base at float.jl:373\n[7] +(x::Float32, y::Float32) in Base at float.jl:375\n[8] +(x::Float64, y::Float64) in Base at float.jl:376\n[9] +(z::Complex{Bool}, x::Bool) in Base at complex.jl:228\n[10] +(z::Complex{Bool}, x::Real) in Base at complex.jl:242\n[11] +(x::Char, y::Integer) in Base at char.jl:40\n[12] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:307\n[13] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:392\n[14] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:391\n[15] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:390\n[16] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:361\n[17] +(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:398\n...\n[180] +(a, b, c, xs...) in Base at operators.jl:424","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Multiple dispatch together with the flexible parametric type system give Julia its ability to abstractly express high-level algorithms decoupled from implementation details, yet generate efficient, specialized code to handle each case at run time.","category":"page"},{"location":"manual/methods.html#man-ambiguities-1","page":"メソッド","title":"Method Ambiguities","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> g(x::Float64, y) = 2x + y\ng (generic function with 1 method)\n\njulia> g(x, y::Float64) = x + 2y\ng (generic function with 2 methods)\n\njulia> g(2.0, 3)\n7.0\n\njulia> g(2, 3.0)\n8.0\n\njulia> g(2.0, 3.0)\nERROR: MethodError: g(::Float64, ::Float64) is ambiguous. Candidates:\n  g(x, y::Float64) in Main at none:1\n  g(x::Float64, y) in Main at none:1\nPossible fix, define\n  g(::Float64, ::Float64)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Here the call g(2.0, 3.0) could be handled by either the g(Float64, Any) or the g(Any, Float64) method, and neither is more specific than the other. In such cases, Julia raises a MethodError  rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> g(x::Float64, y::Float64) = 2x + 2y\ng (generic function with 3 methods)\n\njulia> g(2.0, 3)\n7.0\n\njulia> g(2, 3.0)\n8.0\n\njulia> g(2.0, 3.0)\n10.0","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if transiently, until the more specific method is defined.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further below.","category":"page"},{"location":"manual/methods.html#parametric-methods-1","page":"メソッド","title":"パラメトリックメソッド","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Method definitions can optionally have type parameters qualifying the signature:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> same_type(x::T, y::T) where {T} = true\nsame_type (generic function with 1 method)\n\njulia> same_type(x,y) = false\nsame_type (generic function with 2 methods)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"The first method applies whenever both arguments are of the same concrete type, regardless of what type that is, while the second method acts as a catch-all, covering all other cases. Thus, overall, this defines a boolean function that checks whether its two arguments are of the same type:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> same_type(1, 2)\ntrue\n\njulia> same_type(1, 2.0)\nfalse\n\njulia> same_type(1.0, 2.0)\ntrue\n\njulia> same_type(\"foo\", 2.0)\nfalse\n\njulia> same_type(\"foo\", \"bar\")\ntrue\n\njulia> same_type(Int32(1), Int64(2))\nfalse","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Such definitions correspond to methods whose type signatures are UnionAll types (see UnionAll Types).","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"This kind of definition of function behavior by dispatch is quite common – idiomatic, even – in Julia. Method type parameters are not restricted to being used as the types of arguments: they can be used anywhere a value would be in the signature of the function or body of the function.  Here's an example where the method type parameter T is used as the type parameter to the parametric type Vector{T} in the method signature:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> myappend(v::Vector{T}, x::T) where {T} = [v..., x]\nmyappend (generic function with 1 method)\n\njulia> myappend([1,2,3],4)\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> myappend([1,2,3],2.5)\nERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)\nClosest candidates are:\n  myappend(::Array{T,1}, !Matched::T) where T at none:1\n\njulia> myappend([1.0,2.0,3.0],4.0)\n4-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0\n 4.0\n\njulia> myappend([1.0,2.0,3.0],4)\nERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64)\nClosest candidates are:\n  myappend(::Array{T,1}, !Matched::T) where T at none:1","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"As you can see, the type of the appended element must match the element type of the vector it is appended to, or else a MethodError is raised. In the following example, the method type parameter T is used as the return value:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> mytypeof(x::T) where {T} = T\nmytypeof (generic function with 1 method)\n\njulia> mytypeof(1)\nInt64\n\njulia> mytypeof(1.0)\nFloat64","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Just as you can put subtype constraints on type parameters in type declarations (see Parametric Types), you can also constrain type parameters of methods:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> same_type_numeric(x::T, y::T) where {T<:Number} = true\nsame_type_numeric (generic function with 1 method)\n\njulia> same_type_numeric(x::Number, y::Number) = false\nsame_type_numeric (generic function with 2 methods)\n\njulia> same_type_numeric(1, 2)\ntrue\n\njulia> same_type_numeric(1, 2.0)\nfalse\n\njulia> same_type_numeric(1.0, 2.0)\ntrue\n\njulia> same_type_numeric(\"foo\", 2.0)\nERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)\nClosest candidates are:\n  same_type_numeric(!Matched::T<:Number, ::T<:Number) where T<:Number at none:1\n  same_type_numeric(!Matched::Number, ::Number) at none:1\n\njulia> same_type_numeric(\"foo\", \"bar\")\nERROR: MethodError: no method matching same_type_numeric(::String, ::String)\n\njulia> same_type_numeric(Int32(1), Int64(2))\nfalse","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"The same_type_numeric function behaves much like the same_type function defined above, but is only defined for pairs of numbers.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Parametric methods allow the same syntax as where expressions used to write types (see UnionAll Types). If there is only a single parameter, the enclosing curly braces (in where {T}) can be omitted, but are often preferred for clarity. Multiple parameters can be separated with commas, e.g. where {T, S<:Real}, or written using nested where, e.g. where S<:Real where T.","category":"page"},{"location":"manual/methods.html#Redefining-Methods-1","page":"メソッド","title":"Redefining Methods","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"When redefining a method or adding new methods, it is important to realize that these changes don't take effect immediately.  This is key to Julia's ability to statically infer and compile code to run fast, without the usual JIT tricks and overhead.  Indeed, any new method definition won't be visible to the current runtime environment, including Tasks and Threads (and any previously defined @generated functions).  Let's start with an example to see what this means:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> function tryeval()\n           @eval newfun() = 1\n           newfun()\n       end\ntryeval (generic function with 1 method)\n\njulia> tryeval()\nERROR: MethodError: no method matching newfun()\nThe applicable method may be too new: running in world age xxxx1, while current world is xxxx2.\nClosest candidates are:\n  newfun() at none:1 (method too new to be called from this world context.)\n in tryeval() at none:1\n ...\n\njulia> newfun()\n1","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"In this example, observe that the new definition for newfun has been created, but can't be immediately called.  The new global is immediately visible to the tryeval function, so you could write return newfun (without parentheses).  But neither you, nor any of your callers, nor the functions they call, or etc.  can call this new method definition!","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"But there's an exception: future calls to newfun from the REPL work as expected, being able to both see and call the new definition of newfun.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"However, future calls to tryeval will continue to see the definition of newfun as it was at the previous statement at the REPL, and thus before that call to tryeval.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"You may want to try this for yourself to see how it works.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"The implementation of this behavior is a \"world age counter\".  This monotonically increasing value tracks each method definition operation. This allows describing \"the set of method definitions visible to a given runtime environment\" as a single number, or \"world age\".  It also allows comparing the methods available in two worlds just by comparing their ordinal value.  In the example above, we see that the \"current world\" (in which the method newfun exists), is one greater than the task-local \"runtime world\" that was fixed when the execution of tryeval started.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Sometimes it is necessary to get around this (for example, if you are implementing the above REPL).  Fortunately, there is an easy solution: call the function using Base.invokelatest:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> function tryeval2()\n           @eval newfun2() = 2\n           Base.invokelatest(newfun2)\n       end\ntryeval2 (generic function with 1 method)\n\njulia> tryeval2()\n2","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Finally, let's take a look at some more complex examples where this rule comes into play.  Define a function f(x), which initially has one method:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> f(x) = \"original definition\"\nf (generic function with 1 method)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Start some other operations that use f(x):","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> g(x) = f(x)\ng (generic function with 1 method)\n\njulia> t = @async f(wait()); yield();","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Now we add some new methods to f(x):","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> f(x::Int) = \"definition for Int\"\nf (generic function with 2 methods)\n\njulia> f(x::Type{Int}) = \"definition for Type{Int}\"\nf (generic function with 3 methods)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Compare how these results differ:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> f(1)\n\"definition for Int\"\n\njulia> g(1)\n\"definition for Int\"\n\njulia> fetch(schedule(t, 1))\n\"original definition\"\n\njulia> t = @async f(wait()); yield();\n\njulia> fetch(schedule(t, 1))\n\"definition for Int\"","category":"page"},{"location":"manual/methods.html#Design-Patterns-with-Parametric-Methods-1","page":"メソッド","title":"Design Patterns with Parametric Methods","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"While complex dispatch logic is not required for performance or usability, sometimes it can be the best way to express some algorithm.  Here are a few common design patterns that come up sometimes when using dispatch in this way.","category":"page"},{"location":"manual/methods.html#Extracting-the-type-parameter-from-a-super-type-1","page":"メソッド","title":"Extracting the type parameter from a super-type","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Here is the correct code template for returning the element-type T of any arbitrary subtype of AbstractArray:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"abstract type AbstractArray{T, N} end\neltype(::Type{<:AbstractArray{T}}) where {T} = T","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"using so-called triangular dispatch.  Note that if T is a UnionAll type, as e.g. eltype(Array{T} where T <: Integer), then Any is returned (as does the the version of eltype in Base).","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Another way, which used to be the only correct way before the advent of triangular dispatch in Julia v0.6, is:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"abstract type AbstractArray{T, N} end\neltype(::Type{AbstractArray}) = Any\neltype(::Type{AbstractArray{T}}) where {T} = T\neltype(::Type{AbstractArray{T, N}}) where {T, N} = T\neltype(::Type{A}) where {A<:AbstractArray} = eltype(supertype(A))","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Another possibility is the following, which could useful to adapt to cases where the parameter T would need to be matched more narrowly:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"eltype(::Type{AbstractArray{T, N} where {T<:S, N<:M}}) where {M, S} = Any\neltype(::Type{AbstractArray{T, N} where {T<:S}}) where {N, S} = Any\neltype(::Type{AbstractArray{T, N} where {N<:M}}) where {M, T} = T\neltype(::Type{AbstractArray{T, N}}) where {T, N} = T\neltype(::Type{A}) where {A <: AbstractArray} = eltype(supertype(A))","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"One common mistake is to try and get the element-type by using introspection:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"eltype_wrong(::Type{A}) where {A<:AbstractArray} = A.parameters[1]","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"However, it is not hard to construct cases where this will fail:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"struct BitVector <: AbstractArray{Bool, 1}; end","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Here we have created a type BitVector which has no parameters, but where the element-type is still fully specified, with T equal to Bool!","category":"page"},{"location":"manual/methods.html#Building-a-similar-type-with-a-different-type-parameter-1","page":"メソッド","title":"Building a similar type with a different type parameter","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"When building generic code, there is often a need for constructing a similar object with some change made to the layout of the type, also necessitating a change of the type parameters.  For instance, you might have some sort of abstract array with an arbitrary element type and want to write your computation on it with a specific element type.  We must implement a method for each AbstractArray{T} subtype that describes how to compute this type transform.  There is no general transform of one subtype into another subtype with a different parameter.  (Quick review: do you see why this is?)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"The subtypes of AbstractArray typically implement two methods to achieve this: A method to convert the input array to a subtype of a specific AbstractArray{T, N} abstract type; and a method to make a new uninitialized array with a specific element type.  Sample implementations of these can be found in Julia Base.  Here is a basic example usage of them, guaranteeing that input and output are of the same type:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"input = convert(AbstractArray{Eltype}, input)\noutput = similar(input, Eltype)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"As an extension of this, in cases where the algorithm needs a copy of the input array, convert is insufficient as the return value may alias the original input.  Combining similar (to make the output array) and copyto! (to fill it with the input data)  is a generic way to express the requirement for a mutable copy of the input argument:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"copy_with_eltype(input, Eltype) = copyto!(similar(input, Eltype), input)","category":"page"},{"location":"manual/methods.html#Iterated-dispatch-1","page":"メソッド","title":"Iterated dispatch","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch into distinct functions.  This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"For example, trying to dispatch on the element-type of an array will often run into ambiguous situations.  Instead, commonly code will dispatch first on the container type, then recurse down to a more specific method based on eltype.  In most cases, the algorithms lend themselves conveniently to this hierarchical approach, while in other cases, this rigor must be resolved manually.  This dispatching branching can be observed, for example, in the logic to sum two matrices:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"# First dispatch selects the map algorithm for element-wise summation.\n+(a::Matrix, b::Matrix) = map(+, a, b)\n# Then dispatch handles each element and selects the appropriate\n# common element type for the computation.\n+(a, b) = +(promote(a, b)...)\n# Once the elements have the same type, they can be added.\n# For example, via primitive operations exposed by the processor.\n+(a::Float64, b::Float64) = Core.add(a, b)","category":"page"},{"location":"manual/methods.html#Trait-based-dispatch-1","page":"メソッド","title":"Trait-based dispatch","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"A natural extension to the iterated dispatch above is to add a layer to method selection that allows to dispatch on sets of types which are independent from the sets defined by the type hierarchy.  We could construct such a set by writing out a Union of the types in question, but then this set would not be extensible as Union-types cannot be altered after creation.  However, such an extensible set can be programmed with a design pattern often referred to as a \"Holy-trait\".","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"This pattern is implemented by defining a generic function which computes a different singleton value (or type) for each trait-set to which the function arguments may belong to.  If this function is pure there is no impact on performance compared to normal dispatch.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"The example in the previous section glossed over the implementation details of map and promote, which both operate in terms of these traits.  When iterating over a matrix, such as in the implementation of map, one important question is what order to use to traverse the data. When AbstractArray subtypes implement the Base.IndexStyle trait, other functions such as map can dispatch on this information to pick the best algorithm (see Abstract Array Interface). This means that each subtype does not need to implement a custom version of map, since the generic definitions + trait classes will enable the system to select the fastest version.  Here a toy implementation of map illustrating the trait-based dispatch:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"map(f, a::AbstractArray, b::AbstractArray) = map(Base.IndexStyle(a, b), f, a, b)\n# generic implementation:\nmap(::Base.IndexCartesian, f, a::AbstractArray, b::AbstractArray) = ...\n# linear-indexing implementation (faster)\nmap(::Base.IndexLinear, f, a::AbstractArray, b::AbstractArray) = ...","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"This trait-based approach is also present in the promote mechanism employed by the scalar +.  It uses promote_type, which returns the optimal common type to compute the operation given the two types of the operands.  This makes it possible to reduce the problem of implementing every function for every pair of possible type arguments, to the much smaller problem of implementing a conversion operation from each type to a common type, plus a table of preferred pair-wise promotion rules.","category":"page"},{"location":"manual/methods.html#Output-type-computation-1","page":"メソッド","title":"Output-type computation","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"The discussion of trait-based promotion provides a transition into our next design pattern: computing the output element type for a matrix operation.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"For implementing primitive operations, such as addition, we use the promote_type function to compute the desired output type.  (As before, we saw this at work in the promote call in the call to +).","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"For more complex functions on matrices, it may be necessary to compute the expected return type for a more complex sequence of operations.  This is often performed by the following steps:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Write a small function op that expresses the set of operations performed by the kernel of the algorithm.\nCompute the element type R of the result matrix as promote_op(op, argument_types...), where argument_types is computed from eltype applied to each input array.\nBuild the output matrix as similar(R, dims), where dims are the desired dimensions of the output array.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"For a more specific example, a generic square-matrix multiply pseudo-code might look like:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"function matmul(a::AbstractMatrix, b::AbstractMatrix)\n    op = (ai, bi) -> ai * bi + ai * bi\n\n    ## this is insufficient because it assumes `one(eltype(a))` is constructable:\n    # R = typeof(op(one(eltype(a)), one(eltype(b))))\n\n    ## this fails because it assumes `a[1]` exists and is representative of all elements of the array\n    # R = typeof(op(a[1], b[1]))\n\n    ## this is incorrect because it assumes that `+` calls `promote_type`\n    ## but this is not true for some types, such as Bool:\n    # R = promote_type(ai, bi)\n\n    # this is wrong, since depending on the return value\n    # of type-inference is very brittle (as well as not being optimizable):\n    # R = Base.return_types(op, (eltype(a), eltype(b)))\n\n    ## but, finally, this works:\n    R = promote_op(op, eltype(a), eltype(b))\n    ## although sometimes it may give a larger type than desired\n    ## it will always give a correct type\n\n    output = similar(b, R, (size(a, 1), size(b, 2)))\n    if size(a, 2) > 0\n        for j in 1:size(b, 2)\n            for i in 1:size(a, 1)\n                ## here we don't use `ab = zero(R)`,\n                ## since `R` might be `Any` and `zero(Any)` is not defined\n                ## we also must declare `ab::R` to make the type of `ab` constant in the loop,\n                ## since it is possible that typeof(a * b) != typeof(a * b + a * b) == R\n                ab::R = a[i, 1] * b[1, j]\n                for k in 2:size(a, 2)\n                    ab += a[i, k] * b[k, j]\n                end\n                output[i, j] = ab\n            end\n        end\n    end\n    return output\nend","category":"page"},{"location":"manual/methods.html#Separate-convert-and-kernel-logic-1","page":"メソッド","title":"Separate convert and kernel logic","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"One way to significantly cut down on compile-times and testing complexity is to isolate the logic for converting to the desired type and the computation.  This lets the compiler specialize and inline the conversion logic independent from the rest of the body of the larger kernel.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"This is a common pattern seen when converting from a larger class of types to the one specific argument type that is actually supported by the algorithm:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"complexfunction(arg::Int) = ...\ncomplexfunction(arg::Any) = complexfunction(convert(Int, arg))\n\nmatmul(a::T, b::T) = ...\nmatmul(a, b) = matmul(promote(a, b)...)","category":"page"},{"location":"manual/methods.html#[パラメータ制限付きの可変引数メソッド](@id-parametrically-constrained-varargs-methods]-1","page":"メソッド","title":"[パラメータ制限付きの可変引数メソッド](@id parametrically-constrained-varargs-methods]","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Function parameters can also be used to constrain the number of arguments that may be supplied to a \"varargs\" function (Varargs Functions). The notation Vararg{T,N} is used to indicate such a constraint.  For example:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> bar(a,b,x::Vararg{Any,2}) = (a,b,x)\nbar (generic function with 1 method)\n\njulia> bar(1,2,3)\nERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)\nClosest candidates are:\n  bar(::Any, ::Any, ::Any, !Matched::Any) at none:1\n\njulia> bar(1,2,3,4)\n(1, 2, (3, 4))\n\njulia> bar(1,2,3,4,5)\nERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\nClosest candidates are:\n  bar(::Any, ::Any, ::Any, ::Any) at none:1","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"More usefully, it is possible to constrain varargs methods by a parameter. For example:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"function getindex(A::AbstractArray{T,N}, indices::Vararg{Number,N}) where {T,N}","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"would be called only when the number of indices matches the dimensionality of the array.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"When only the type of supplied arguments needs to be constrained Vararg{T} can be equivalently written as T.... For instance f(x::Int...) = x is a shorthand for f(x::Vararg{Int}) = x.","category":"page"},{"location":"manual/methods.html#note-on-optional-and-keyword-arguments-1","page":"メソッド","title":"オプション引数・キーワード引数に関する注記","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"As mentioned briefly in Functions, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"f(a=1,b=2) = a+2b","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"translates to the following three methods:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"f(a,b) = a+2b\nf(a) = f(a,2)\nf() = f(1,2)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"This means that calling f() is equivalent to calling f(1,2). In this case the result is 5, because f(1,2) invokes the first method of f above. However, this need not always be the case.  If you define a fourth method that is more specialized for integers:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"f(a::Int,b::Int) = a-2b","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"then the result of both f() and f(1,2) is -3. In other words, optional arguments are tied to a function, not to any specific method of that function. It depends on the types of the optional arguments which method is invoked. When optional arguments are defined in terms of a global variable, the type of the optional argument may even change at run-time.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not participate in method dispatch. Methods are dispatched based only on positional arguments, with keyword arguments processed after the matching method is identified.","category":"page"},{"location":"manual/methods.html#Function-like-objects-1","page":"メソッド","title":"Function-like objects","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Methods are associated with types, so it is possible to make any arbitrary Julia object \"callable\" by adding methods to its type. (Such \"callable\" objects are sometimes called \"functors.\")","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function evaluating the polynomial:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> struct Polynomial{R}\n           coeffs::Vector{R}\n       end\n\njulia> function (p::Polynomial)(x)\n           v = p.coeffs[end]\n           for i = (length(p.coeffs)-1):-1:1\n               v = v*x + p.coeffs[i]\n           end\n           return v\n       end\n\njulia> (p::Polynomial)() = p(5)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Notice that the function is specified by type instead of by name. As with normal functions there is a terse syntax form. In the function body, p will refer to the object that was called. A Polynomial can be used as follows:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"julia> p = Polynomial([1,10,100])\nPolynomial{Int64}([1, 10, 100])\n\njulia> p(3)\n931\n\njulia> p()\n2551","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"This mechanism is also the key to how type constructors and closures (inner functions that refer to their surrounding environment) work in Julia.","category":"page"},{"location":"manual/methods.html#Empty-generic-functions-1","page":"メソッド","title":"Empty generic functions","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Occasionally it is useful to introduce a generic function without yet adding methods. This can be used to separate interface definitions from implementations. It might also be done for the purpose of documentation or code readability. The syntax for this is an empty function block without a tuple of arguments:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"function emptyfunc\nend","category":"page"},{"location":"manual/methods.html#man-method-design-ambiguities-1","page":"メソッド","title":"Method design and the avoidance of ambiguities","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges.  In particular, in more complex method hierarchies it is not uncommon for ambiguities to arise.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Above, it was pointed out that one can resolve ambiguities like","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"f(x, y::Int) = 1\nf(x::Int, y) = 2","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"by defining a method","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"f(x::Int, y::Int) = 3","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"This is often the right strategy; however, there are circumstances where following this advice blindly can be counterproductive. In particular, the more methods a generic function has, the more possibilities there are for ambiguities. When your method hierarchies get more complicated than this simple example, it can be worth your while to think carefully about alternative strategies.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Below we discuss particular challenges and some alternative ways to resolve such issues.","category":"page"},{"location":"manual/methods.html#Tuple-and-NTuple-arguments-1","page":"メソッド","title":"Tuple and NTuple arguments","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Tuple (and NTuple) arguments present special challenges. For example,","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"f(x::NTuple{N,Int}) where {N} = 1\nf(x::NTuple{N,Float64}) where {N} = 2","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"are ambiguous because of the possibility that N == 0: there are no elements to determine whether the Int or Float64 variant should be called. To resolve the ambiguity, one approach is define a method for the empty tuple:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"f(x::Tuple{}) = 3","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Alternatively, for all methods but one you can insist that there is at least one element in the tuple:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"f(x::NTuple{N,Int}) where {N} = 1           # this is the fallback\nf(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64","category":"page"},{"location":"manual/methods.html#man-methods-orthogonalize-1","page":"メソッド","title":"Orthogonalize your design","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"When you might be tempted to dispatch on two or more arguments, consider whether a \"wrapper\" function might make for a simpler design. For example, instead of writing multiple variants:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"f(x::A, y::A) = ...\nf(x::A, y::B) = ...\nf(x::B, y::A) = ...\nf(x::B, y::B) = ...","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"you might consider defining","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"f(x::A, y::A) = ...\nf(x, y) = f(g(x), g(y))","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"where g converts the argument to type A. This is a very specific example of the more general principle of orthogonal design, in which separate concepts are assigned to separate methods. Here, g will most likely need a fallback definition","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"g(x::A) = x","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"A related strategy exploits promote to bring x and y to a common type:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"f(x::T, y::T) where {T} = ...\nf(x, y) = f(promote(x, y)...)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"One risk with this design is the possibility that if there is no suitable promotion method converting x and y to the same type, the second method will recurse on itself infinitely and trigger a stack overflow. The non-exported function Base.promote_noncircular can be used as an alternative; when promotion fails it will still throw an error, but one that fails faster with a more specific error message.","category":"page"},{"location":"manual/methods.html#Dispatch-on-one-argument-at-a-time-1","page":"メソッド","title":"Dispatch on one argument at a time","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all possible variants, then consider introducing a \"name cascade\" where (for example) you dispatch on the first argument and then call an internal method:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"f(x::A, y) = _fA(x, y)\nf(x::B, y) = _fB(x, y)","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Then the internal methods _fA and _fB can dispatch on y without concern about ambiguities with each other with respect to x.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users to further customize the behavior of f by defining further specializations of your exported function f. Instead, they have to define specializations for your internal methods _fA and _fB, and this blurs the lines between exported and internal methods.","category":"page"},{"location":"manual/methods.html#Abstract-containers-and-element-types-1","page":"メソッド","title":"Abstract containers and element types","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Where possible, try to avoid defining methods that dispatch on specific element types of abstract containers. For example,","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"-(A::AbstractArray{T}, b::Date) where {T<:Date}","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"generates ambiguities for anyone who defines a method","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"-(A::MyArrayType{T}, b::T) where {T}","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"The best approach is to avoid defining either of these methods: instead, rely on a generic method -(A::AbstractArray, b) and make sure this method is implemented with generic calls (like similar and -) that do the right thing for each container type and element type separately. This is just a more complex variant of the advice to orthogonalize your methods.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"When this approach is not possible, it may be worth starting a discussion with other developers about resolving the ambiguity; just because one method was defined first does not necessarily mean that it can't be modified or eliminated.  As a last resort, one developer can define the \"band-aid\" method","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"-(A::MyArrayType{T}, b::Date) where {T<:Date} = ...","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"that resolves the ambiguity by brute force.","category":"page"},{"location":"manual/methods.html#Complex-method-\"cascades\"-with-default-arguments-1","page":"メソッド","title":"Complex method \"cascades\" with default arguments","text":"","category":"section"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"If you are defining a method \"cascade\" that supplies defaults, be careful about dropping any arguments that correspond to potential defaults. For example, suppose you're writing a digital filtering algorithm and you have a method that handles the edges of the signal by applying padding:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"function myfilter(A, kernel, ::Replicate)\n    Apadded = replicate_edges(A, size(kernel))\n    myfilter(Apadded, kernel)  # now perform the \"real\" computation\nend","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"This will run afoul of a method that supplies default padding:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"myfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by default","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Together, these two methods generate an infinite recursion with A constantly growing bigger.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"The better design would be to define your call hierarchy like this:","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"struct NoPad end  # indicate that no padding is desired, or that it's already applied\n\nmyfilter(A, kernel) = myfilter(A, kernel, Replicate())  # default boundary conditions\n\nfunction myfilter(A, kernel, ::Replicate)\n    Apadded = replicate_edges(A, size(kernel))\n    myfilter(Apadded, kernel, NoPad())  # indicate the new boundary conditions\nend\n\n# other padding methods go here\n\nfunction myfilter(A, kernel, ::NoPad)\n    # Here's the \"real\" implementation of the core computation\nend","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"NoPad is supplied in the same argument position as any other kind of padding, so it keeps the dispatch hierarchy well organized and with reduced likelihood of ambiguities. Moreover, it extends the \"public\" myfilter interface: a user who wants to control the padding explicitly can call the NoPad variant directly.","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"[Clarke61]: Arthur C. Clarke, Profiles of the Future (1961): Clarke's","category":"page"},{"location":"manual/methods.html#","page":"メソッド","title":"メソッド","text":"Third Law.","category":"page"},{"location":"manual/constructors.html#man-constructors-1","page":"Constructors","title":"Constructors","text":"","category":"section"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Constructors [1] are functions that create new objects – specifically, instances of Composite Types.  In Julia, type objects also serve as constructor functions: they create new instances of themselves when applied to an argument tuple as a function. This much was already mentioned briefly when composite types were introduced. For example:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> struct Foo\n           bar\n           baz\n       end\n\njulia> foo = Foo(1, 2)\nFoo(1, 2)\n\njulia> foo.bar\n1\n\njulia> foo.baz\n2","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"For many types, forming new objects by binding their field values together is all that is ever needed to create instances. However, in some cases more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or by transforming them. Recursive data structures, especially those that may be self-referential, often cannot be constructed cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from object creation. Sometimes, it's just convenient to be able to construct objects with fewer or different types of parameters than they have fields. Julia's system for object construction addresses all of these cases and more.","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"[1]: Nomenclature: while the term \"constructor\" generally refers to the entire function which constructs objects of a type, it is common to abuse terminology slightly and refer to specific constructor methods as \"constructors\". In such situations, it is generally clear from the context that the term is used to mean \"constructor method\" rather than \"constructor function\", especially as it is often used in the sense of singling out a particular method of the constructor from all of the others.","category":"page"},{"location":"manual/constructors.html#Outer-Constructor-Methods-1","page":"Constructors","title":"Outer Constructor Methods","text":"","category":"section"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let's say you want to add a constructor method for Foo objects that takes only one argument and uses the given value for both the bar and baz fields. This is simple:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> Foo(x) = Foo(x,x)\nFoo\n\njulia> Foo(1)\nFoo(1, 1)","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"You could also add a zero-argument Foo constructor method that supplies default values for both of the bar and baz fields:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> Foo() = Foo(0)\nFoo\n\njulia> Foo()\nFoo(0, 0)","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called outer constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.","category":"page"},{"location":"manual/constructors.html#Inner-Constructor-Methods-1","page":"Constructors","title":"Inner Constructor Methods","text":"","category":"section"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"While outer constructor methods succeed in addressing the problem of providing additional convenience methods for constructing objects, they fail to address the other two use cases mentioned in the introduction of this chapter: enforcing invariants, and allowing construction of self-referential objects. For these problems, one needs inner constructor methods. An inner constructor method is like an outer constructor method, except for two differences:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"It is declared inside the block of a type declaration, rather than outside of it like normal methods.\nIt has access to a special locally existent function called new that creates objects of the block's type.","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> struct OrderedPair\n           x::Real\n           y::Real\n           OrderedPair(x,y) = x > y ? error(\"out of order\") : new(x,y)\n       end","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Now OrderedPair objects can only be constructed such that x <= y:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> OrderedPair(1, 2)\nOrderedPair(1, 2)\n\njulia> OrderedPair(2,1)\nERROR: out of order\nStacktrace:\n [1] error at ./error.jl:33 [inlined]\n [2] OrderedPair(::Int64, ::Int64) at ./none:4\n [3] top-level scope","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"If the type were declared mutable, you could reach in and directly change the field values to violate this invariant. Of course, messing around with an object's internals uninvited is bad practice.  You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type's invariants.","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object's fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to new, returning the resulting object:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> struct Foo\n           bar\n           baz\n           Foo(bar,baz) = new(bar,baz)\n       end\n","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"This declaration has the same effect as the earlier definition of the Foo type without an explicit inner constructor method. The following two types are equivalent – one with a default constructor, the other with an explicit constructor:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> struct T1\n           x::Int64\n       end\n\njulia> struct T2\n           x::Int64\n           T2(x) = new(x)\n       end\n\njulia> T1(1)\nT1(1)\n\njulia> T2(1)\nT2(1)\n\njulia> T1(1.0)\nT1(1)\n\njulia> T2(1.0)\nT2(1)","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"It is good practice to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is typically quite natural.","category":"page"},{"location":"manual/constructors.html#Incomplete-Initialization-1","page":"Constructors","title":"Incomplete Initialization","text":"","category":"section"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"The final problem which has still not been addressed is construction of self-referential objects, or more generally, recursive data structures. Since the fundamental difficulty may not be immediately obvious, let us briefly explain it. Consider the following recursive type declaration:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> mutable struct SelfReferential\n           obj::SelfReferential\n       end\n","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"This type may appear innocuous enough, until one considers how to construct an instance of it.  If a is an instance of SelfReferential, then a second instance can be created by the call:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> b = SelfReferential(a)","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"But how does one construct the first instance when no instance exists to provide as a valid value for its obj field? The only solution is to allow creating an incompletely initialized instance of SelfReferential with an unassigned obj field, and using that incomplete instance as a valid value for the obj field of another instance, such as, for example, itself.","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"To allow for the creation of incompletely initialized objects, Julia allows the new function to be called with fewer than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use the incomplete object, finishing its initialization before returning it. Here, for example, is another attempt at defining the SelfReferential type, this time using a zero-argument inner constructor returning instances having obj fields pointing to themselves:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> mutable struct SelfReferential\n           obj::SelfReferential\n           SelfReferential() = (x = new(); x.obj = x)\n       end\n","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"We can verify that this constructor works and constructs objects that are, in fact, self-referential:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> x = SelfReferential();\n\njulia> x === x\ntrue\n\njulia> x === x.obj\ntrue\n\njulia> x === x.obj.obj\ntrue","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Although it is generally a good idea to return a fully initialized object from an inner constructor, it is possible to return incompletely initialized objects:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> mutable struct Incomplete\n           data\n           Incomplete() = new()\n       end\n\njulia> z = Incomplete();","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"While you are allowed to create objects with uninitialized fields, any access to an uninitialized reference is an immediate error:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> z.data\nERROR: UndefRefError: access to undefined reference","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"This avoids the need to continually check for null values. However, not all object fields are references. Julia considers some types to be \"plain data\", meaning all of their data is self-contained and does not reference other objects. The plain data types consist of primitive types (e.g. Int) and immutable structs of other plain data types. The initial contents of a plain data type is undefined:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> struct HasPlain\n           n::Int\n           HasPlain() = new()\n       end\n\njulia> HasPlain()\nHasPlain(438103441441)","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Arrays of plain data types exhibit the same behavior.","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"You can pass incomplete objects to other functions from inner constructors to delegate their completion:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> mutable struct Lazy\n           data\n           Lazy(v) = complete_me(new(), v)\n       end","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"As with incomplete objects returned from constructors, if complete_me or any of its callees try to access the data field of the Lazy object before it has been initialized, an error will be thrown immediately.","category":"page"},{"location":"manual/constructors.html#Parametric-Constructors-1","page":"Constructors","title":"Parametric Constructors","text":"","category":"section"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Parametric types add a few wrinkles to the constructor story. Recall from Parametric Types  that, by default, instances of parametric composite types can be constructed either with explicitly given type parameters or with type parameters implied by the types of the arguments given to the constructor. Here are some examples:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> struct Point{T<:Real}\n           x::T\n           y::T\n       end\n\njulia> Point(1,2) ## implicit T ##\nPoint{Int64}(1, 2)\n\njulia> Point(1.0,2.5) ## implicit T ##\nPoint{Float64}(1.0, 2.5)\n\njulia> Point(1,2.5) ## implicit T ##\nERROR: MethodError: no method matching Point(::Int64, ::Float64)\nClosest candidates are:\n  Point(::T<:Real, ::T<:Real) where T<:Real at none:2\n\njulia> Point{Int64}(1, 2) ## explicit T ##\nPoint{Int64}(1, 2)\n\njulia> Point{Int64}(1.0,2.5) ## explicit T ##\nERROR: InexactError: Int64(2.5)\nStacktrace:\n[...]\n\njulia> Point{Float64}(1.0, 2.5) ## explicit T ##\nPoint{Float64}(1.0, 2.5)\n\njulia> Point{Float64}(1,2) ## explicit T ##\nPoint{Float64}(1.0, 2.0)","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: Point{Int64}(1,2) works, but Point{Int64}(1.0,2.5) raises an InexactError when converting 2.5 to Int64. When the type is implied by the arguments to the constructor call, as in Point(1,2), then the types of the arguments must agree – otherwise the T cannot be determined – but any pair of real arguments with matching type may be given to the generic Point constructor.","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"What's really going on here is that Point, Point{Float64} and Point{Int64} are all different constructor functions. In fact, Point{T} is a distinct constructor function for each type T. Without any explicitly provided inner constructors, the declaration of the composite type Point{T<:Real} automatically provides an inner constructor, Point{T}, for each possible type T<:Real, that behaves just like non-parametric default inner constructors do. It also provides a single general outer Point constructor that takes pairs of real arguments, which must be of the same type. This automatic provision of constructors is equivalent to the following explicit declaration:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> struct Point{T<:Real}\n           x::T\n           y::T\n           Point{T}(x,y) where {T<:Real} = new(x,y)\n       end\n\njulia> Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Notice that each definition looks like the form of constructor call that it handles.  The call Point{Int64}(1,2) will invoke the definition Point{T}(x,y) inside the struct block.  The outer constructor declaration, on the other hand, defines a method for the general Point constructor which only applies to pairs of values of the same real type. This declaration makes constructor calls without explicit type parameters, like Point(1,2) and Point(1.0,2.5), work. Since the method declaration restricts the arguments to being of the same type, calls like Point(1,2.5), with arguments of different types, result in \"no method\" errors.","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Suppose we wanted to make the constructor call Point(1,2.5) work by \"promoting\" the integer value 1 to the floating-point value 1.0. The simplest way to achieve this is to define the following additional outer constructor method:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> Point(x::Int64, y::Float64) = Point(convert(Float64,x),y);","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"This method uses the convert function to explicitly convert x to Float64  and then delegates construction to the general constructor for the case where both arguments are Float64. With this method definition what was previously a MethodError now successfully creates a point of type Point{Float64}:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> Point(1,2.5)\nPoint{Float64}(1.0, 2.5)\n\njulia> typeof(ans)\nPoint{Float64}","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"However, other similar calls still don't work:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> Point(1.5,2)\nERROR: MethodError: no method matching Point(::Float64, ::Int64)\nClosest candidates are:\n  Point(::T<:Real, !Matched::T<:Real) where T<:Real at none:1","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"For a more general way to make all such calls work sensibly, see Conversion and Promotion.  At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general Point constructor work as one would expect:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> Point(x::Real, y::Real) = Point(promote(x,y)...);","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"The promote function converts all its arguments to a common type – in this case Float64.  With this method definition, the Point constructor promotes its arguments the same way that numeric operators like + do, and works for all kinds of real numbers:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> Point(1.5,2)\nPoint{Float64}(1.5, 2.0)\n\njulia> Point(1,1//2)\nPoint{Rational{Int64}}(1//1, 1//2)\n\njulia> Point(1.0,1//2)\nPoint{Float64}(1.0, 0.5)","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior is typically quite simple.","category":"page"},{"location":"manual/constructors.html#Case-Study:-Rational-1","page":"Constructors","title":"Case Study: Rational","text":"","category":"section"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Perhaps the best way to tie all these pieces together is to present a real world example of a parametric composite type and its constructor methods. To that end, we implement our own rational number type OurRational, similar to Julia's built-in Rational type, defined in rational.jl:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> struct OurRational{T<:Integer} <: Real\n           num::T\n           den::T\n           function OurRational{T}(num::T, den::T) where T<:Integer\n               if num == 0 && den == 0\n                    error(\"invalid rational: 0//0\")\n               end\n               g = gcd(den, num)\n               num = div(num, g)\n               den = div(den, g)\n               new(num, den)\n           end\n       end\n\njulia> OurRational(n::T, d::T) where {T<:Integer} = OurRational{T}(n,d)\nOurRational\n\njulia> OurRational(n::Integer, d::Integer) = OurRational(promote(n,d)...)\nOurRational\n\njulia> OurRational(n::Integer) = OurRational(n,one(n))\nOurRational\n\njulia> ⊘(n::Integer, d::Integer) = OurRational(n,d)\n⊘ (generic function with 1 method)\n\njulia> ⊘(x::OurRational, y::Integer) = x.num ⊘ (x.den*y)\n⊘ (generic function with 2 methods)\n\njulia> ⊘(x::Integer, y::OurRational) = (x*y.den) ⊘ y.num\n⊘ (generic function with 3 methods)\n\njulia> ⊘(x::Complex, y::Real) = complex(real(x) ⊘ y, imag(x) ⊘ y)\n⊘ (generic function with 4 methods)\n\njulia> ⊘(x::Real, y::Complex) = (x*y') ⊘ real(y*y')\n⊘ (generic function with 5 methods)\n\njulia> function ⊘(x::Complex, y::Complex)\n           xy = x*y'\n           yy = real(y*y')\n           complex(real(xy) ⊘ yy, imag(xy) ⊘ yy)\n       end\n⊘ (generic function with 6 methods)","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"The first line – struct OurRational{T<:Integer} <: Real – declares that OurRational takes one type parameter of an integer type, and is itself a real type. The field declarations num::T and den::T indicate that the data held in a OurRational{T} object are a pair of integers of type T, one representing the rational value's numerator and the other representing its denominator.","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Now things get interesting. OurRational has a single inner constructor method which checks that both of num and den aren't zero and ensures that every rational is constructed in \"lowest terms\" with a non-negative denominator. This is accomplished by dividing the given numerator and denominator values by their greatest common divisor, computed using the gcd function. Since gcd returns the greatest common divisor of its arguments with sign matching the first argument (den here), after this division the new value of den is guaranteed to be non-negative. Because this is the only inner constructor for OurRational, we can be certain that OurRational objects are always constructed in this normalized form.","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"OurRational also provides several outer constructor methods for convenience. The first is the \"standard\" general constructor that infers the type parameter T from the type of the numerator and denominator when they have the same type. The second applies when the given numerator and denominator values have different types: it promotes them to a common type and then delegates construction to the outer constructor for arguments of matching type. The third outer constructor turns integer values into rationals by supplying a value of 1 as the denominator.","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Following the outer constructor definitions, we defined a number of methods for the ⊘ operator, which provides a syntax for writing rationals (e.g. 1 ⊘ 2). Julia's Rational type uses the // operator for this purpose. Before these definitions, ⊘ is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in Rational Numbers – its entire behavior is defined in these few lines.  The first and most basic definition just makes a ⊘ b construct a OurRational by applying the OurRational constructor to a and b when they are integers. When one of the operands of ⊘ is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer.  Finally, applying ⊘ to complex integral values creates an instance of Complex{OurRational} – a complex number whose real and imaginary parts are rationals:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> z = (1 + 2im) ⊘ (1 - 2im);\n\njulia> typeof(z)\nComplex{OurRational{Int64}}\n\njulia> typeof(z) <: Complex{OurRational}\nfalse","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"Thus, although the ⊘ operator usually returns an instance of OurRational, if either of its arguments are complex integers, it will return an instance of Complex{OurRational} instead.  The interested reader should consider perusing the rest of rational.jl: it is short, self-contained, and implements an entire basic Julia type.","category":"page"},{"location":"manual/constructors.html#Outer-only-constructors-1","page":"Constructors","title":"Outer-only constructors","text":"","category":"section"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to Point{Int} but not to Point. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a Point{Int} from the call Point(1,2). Outer constructors call inner constructors to actually make instances. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"For example, say we define a type that stores a vector along with an accurate representation of its sum:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> struct SummedArray{T<:Number,S<:Number}\n           data::Vector{T}\n           sum::S\n       end\n\njulia> SummedArray(Int32[1; 2; 3], Int32(6))\nSummedArray{Int32,Int32}(Int32[1, 2, 3], 6)","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"The problem is that we want S to be a larger type than T, so that we can sum many elements with less information loss. For example, when T is Int32, we would like S to be Int64. Therefore we want to avoid an interface that allows the user to construct instances of the type SummedArray{Int32,Int32}. One way to do this is to provide a constructor only for SummedArray, but inside the struct definition block to suppress generation of default constructors:","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"julia> struct SummedArray{T<:Number,S<:Number}\n           data::Vector{T}\n           sum::S\n           function SummedArray(a::Vector{T}) where T\n               S = widen(T)\n               new{T,S}(a, sum(S, a))\n           end\n       end\n\njulia> SummedArray(Int32[1; 2; 3], Int32(6))\nERROR: MethodError: no method matching SummedArray(::Array{Int32,1}, ::Int32)\nClosest candidates are:\n  SummedArray(::Array{T,1}) where T at none:5","category":"page"},{"location":"manual/constructors.html#","page":"Constructors","title":"Constructors","text":"This constructor will be invoked by the syntax SummedArray(a). The syntax new{T,S} allows specifying parameters for the type to be constructed, i.e. this call will return a SummedArray{T,S}.  new{T,S} can be used in any constructor definition, but for convenience the parameters to new{} are automatically derived from the type being constructed when possible.","category":"page"},{"location":"manual/conversion-and-promotion.html#conversion-and-promotion-1","page":"変換と昇格","title":"変換と昇格","text":"","category":"section"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Juliaは、数学演算子の引数を共通の型に昇格させるシステムを持っています。このことは、整数と浮動小数点数、算術演算と初等関数など、型、およびメソッドなど、さまざまなセクションで言及されています。このセクションでは、この型の昇格システムの仕組みと、それを新しい型に拡張して、組み込みの数学演算子やそれ以外の関数に適用する方法について説明します。従来、プログラミング言語は、算術引数の昇格をどのように扱うかで、2 つの陣営に分類されます:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Automatic promotion for built-in arithmetic types and operators. In most languages, built-in numeric types, when used as operands to arithmetic operators with infix syntax, such as +, -, *, and /, are automatically promoted to a common type to produce the expected results.  C, Java, Perl, and Python, to name a few, all correctly compute the sum 1 + 1.5 as the floating-point value 2.5, even though one of the operands to + is an integer. These systems are convenient and designed carefully enough that they are generally all-but-invisible to the programmer: hardly anyone consciously thinks of this promotion taking place when writing such an expression, but compilers and interpreters must perform conversion before addition since integers and floating-point values cannot be added as-is. Complex rules for such automatic conversions are thus inevitably part of specifications and implementations for such languages.\nNo automatic promotion. This camp includes Ada and ML – very \"strict\" statically typed languages.  In these languages, every conversion must be explicitly specified by the programmer. Thus, the example expression 1 + 1.5 would be a compilation error in both Ada and ML. Instead one must write real(1) + 1.5, explicitly converting the integer 1 to a floating-point value before performing addition. Explicit conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic conversion: integer literals are promoted to the expected integer type automatically, and floating-point literals are similarly promoted to appropriate floating-point types.","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"In a sense, Julia falls into the \"no automatic promotion\" category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted.  However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch – something which Julia's dispatch and type systems are particularly well-suited to handle. \"Automatic\" promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.","category":"page"},{"location":"manual/conversion-and-promotion.html#Conversion-1","page":"変換と昇格","title":"Conversion","text":"","category":"section"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"The standard way to obtain a value of a certain type T is to call the type's constructor, T(x).  However, there are cases where it's convenient to convert a value from one type to another without the programmer asking for it explicitly.  One example is assigning a value into an array: if A is a Vector{Float64}, the expression A[1] = 2 should work by automatically converting the 2 from Int to Float64, and storing the result in the array.  This is done via the convert function.","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"The convert function generally takes two arguments: the first is a type object and the second is a value to convert to that type. The returned value is the value converted to an instance of given type.  The simplest way to understand this function is to see it in action:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"julia> x = 12\n12\n\njulia> typeof(x)\nInt64\n\njulia> convert(UInt8, x)\n0x0c\n\njulia> typeof(ans)\nUInt8\n\njulia> convert(AbstractFloat, x)\n12.0\n\njulia> typeof(ans)\nFloat64\n\njulia> a = Any[1 2 3; 4 5 6]\n2×3 Array{Any,2}:\n 1  2  3\n 4  5  6\n\njulia> convert(Array{Float64}, a)\n2×3 Array{Float64,2}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Conversion isn't always possible, in which case a no method error is thrown indicating that convert doesn't know how to perform the requested conversion:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"julia> convert(AbstractFloat, \"foo\")\nERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat\n[...]","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Some languages consider parsing strings as numbers or formatting numbers as strings to be conversions (many dynamic languages will even perform conversion for you automatically), however Julia does not: even though some strings can be parsed as numbers, most strings are not valid representations of numbers, and only a very limited subset of them are. Therefore in Julia the dedicated parse  function must be used to perform this operation, making it more explicit.","category":"page"},{"location":"manual/conversion-and-promotion.html#When-is-convert-called?-1","page":"変換と昇格","title":"When is convert called?","text":"","category":"section"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"The following language constructs call convert:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Assigning to an array converts to the array's element type.\nAssigning to a field of an object converts to the declared type of the field.\nConstructing an object with new converts to the object's declared field types.\nAssigning to a variable with a declared type (e.g. local x::T) converts to that type.\nA function with a declared return type converts its return value to that type.\nPassing a value to ccall converts it to the corresponding argument type.","category":"page"},{"location":"manual/conversion-and-promotion.html#Conversion-vs.-Construction-1","page":"変換と昇格","title":"Conversion vs. Construction","text":"","category":"section"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Note that the behavior of convert(T, x) appears to be nearly identical to T(x).  Indeed, it usually is.  However, there is a key semantic difference: since convert can be called implicitly, its methods are restricted to cases that are considered \"safe\" or \"unsurprising\".  convert will only convert between types that represent the same basic kind of thing (e.g. different representations of numbers, or different string encodings). It is also usually lossless; converting a value to a different type and back again should result in the exact same value.","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"There are four general kinds of cases where constructors differ from convert:","category":"page"},{"location":"manual/conversion-and-promotion.html#Constructors-for-types-unrelated-to-their-arguments-1","page":"変換と昇格","title":"Constructors for types unrelated to their arguments","text":"","category":"section"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Some constructors don't implement the concept of \"conversion\".  For example, Timer(2) creates a 2-second timer, which is not really a \"conversion\" from an integer to a timer.","category":"page"},{"location":"manual/conversion-and-promotion.html#Mutable-collections-1","page":"変換と昇格","title":"Mutable collections","text":"","category":"section"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"convert(T, x) is expected to return the original x if x is already of type T.  In contrast, if T is a mutable collection type then T(x) should always make a new collection (copying elements from x).","category":"page"},{"location":"manual/conversion-and-promotion.html#Wrapper-types-1","page":"変換と昇格","title":"Wrapper types","text":"","category":"section"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"For some types which \"wrap\" other values, the constructor may wrap its argument inside a new object even if it is already of the requested type. For example Some(x) wraps x to indicate that a value is present (in a context where the result might be a Some or nothing).  However, x itself might be the object Some(y), in which case the result is Some(Some(y)), with two levels of wrapping.  convert(Some, x), on the other hand, would just return x since it is already a Some.","category":"page"},{"location":"manual/conversion-and-promotion.html#Constructors-that-don't-return-instances-of-their-own-type-1","page":"変換と昇格","title":"Constructors that don't return instances of their own type","text":"","category":"section"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"In very rare cases it might make sense for the constructor T(x) to return an object not of type T.  This could happen if a wrapper type is its own inverse (e.g. Flip(Flip(x)) === x), or to support an old calling syntax for backwards compatibility when a library is restructured.  But convert(T, x) should always return a value of type T.","category":"page"},{"location":"manual/conversion-and-promotion.html#Defining-New-Conversions-1","page":"変換と昇格","title":"Defining New Conversions","text":"","category":"section"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"When defining a new type, initially all ways of creating it should be defined as constructors.  If it becomes clear that implicit conversion would be useful, and that some constructors meet the above \"safety\" criteria, then convert methods can be added.  These methods are typically quite simple, as they only need to call the appropriate constructor.  Such a definition might look like this:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"convert(::Type{MyType}, x) = MyType(x)","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"The type of the first argument of this method is a singleton type, Type{MyType}, the only instance of which is MyType. Thus, this method is only invoked when the first argument is the type value MyType. Notice the syntax used for the first argument: the argument name is omitted prior to the :: symbol, and only the type is given.  This is the syntax in Julia for a function argument whose type is specified but whose value does not need to be referenced by name. In this example, since the type is a singleton, we already know its value without referring to an argument name.","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"All instances of some abstract types are by default considered \"sufficiently similar\" that a universal convert definition is provided in Julia Base. For example, this definition states that it's valid to convert any Number type to any other by calling a 1-argument constructor:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"convert(::Type{T}, x::Number) where {T<:Number} = T(x)","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"This means that new Number types only need to define constructors, since this definition will handle convert for them.  An identity conversion is also provided to handle the case where the argument is already of the requested type:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"convert(::Type{T}, x::T) where {T<:Number} = x","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Similar definitions exist for AbstractString, AbstractArray, and AbstractDict.","category":"page"},{"location":"manual/conversion-and-promotion.html#Promotion-1","page":"変換と昇格","title":"Promotion","text":"","category":"section"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Promotion refers to converting values of mixed types to a single common type. Although it is not strictly necessary, it is generally implied that the common type to which the values are converted can faithfully represent all of the original values. In this sense, the term \"promotion\" is appropriate since the values are converted to a \"greater\" type – i.e. one which can represent all of the input values in a single common type. It is important, however, not to confuse this with object-oriented (structural) super-typing, or Julia's notion of abstract super-types: promotion has nothing to do with the type hierarchy, and everything to do with converting between alternate representations.  For instance, although every Int32 value can also be represented as a Float64 value, Int32 is not a subtype of Float64.","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Promotion to a common \"greater\" type is performed in Julia by the promote function, which takes any number of arguments, and returns a tuple of the same number of values, converted to a common type, or throws an exception if promotion is not possible. The most common use case for promotion is to convert numeric arguments to a common type:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"julia> promote(1, 2.5)\n(1.0, 2.5)\n\njulia> promote(1, 2.5, 3)\n(1.0, 2.5, 3.0)\n\njulia> promote(2, 3//4)\n(2//1, 3//4)\n\njulia> promote(1, 2.5, 3, 3//4)\n(1.0, 2.5, 3.0, 0.75)\n\njulia> promote(1.5, im)\n(1.5 + 0.0im, 0.0 + 1.0im)\n\njulia> promote(1 + 2im, 3//4)\n(1//1 + 2//1*im, 3//4 + 0//1*im)","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Floating-point values are promoted to the largest of the floating-point argument types. Integer values are promoted to the larger of either the native machine word size or the largest integer argument type. Mixtures of integers and floating-point values are promoted to a floating-point type big enough to hold all the values. Integers mixed with rationals are promoted to rationals.  Rationals mixed with floats are promoted to floats. Complex values mixed with real values are promoted to the appropriate kind of complex value.","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"That is really all there is to using promotions. The rest is just a matter of clever application, the most typical \"clever\" application being the definition of catch-all methods for numeric operations like the arithmetic operators +, -, * and /. Here are some of the catch-all method definitions given in promotion.jl:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"+(x::Number, y::Number) = +(promote(x,y)...)\n-(x::Number, y::Number) = -(promote(x,y)...)\n*(x::Number, y::Number) = *(promote(x,y)...)\n/(x::Number, y::Number) = /(promote(x,y)...)","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying and dividing pairs of numeric values, promote the values to a common type and then try again. That's all there is to it: nowhere else does one ever need to worry about promotion to a common numeric type for arithmetic operations – it just happens automatically. There are definitions of catch-all promotion methods for a number of other arithmetic and mathematical functions in promotion.jl, but beyond that, there are hardly any calls to promote required in Julia Base. The most common usages of promote occur in outer constructors methods, provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate common type. For example, recall that rational.jl provides the following outer constructor method:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Rational(n::Integer, d::Integer) = Rational(promote(n,d)...)","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"This allows calls like the following to work:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"julia> Rational(Int8(15),Int32(-5))\n-3//1\n\njulia> typeof(ans)\nRational{Int32}","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"For most user-defined types, it is better practice to require programmers to supply the expected types to constructor functions explicitly, but sometimes, especially for numeric problems, it can be convenient to do promotion automatically.","category":"page"},{"location":"manual/conversion-and-promotion.html#Defining-Promotion-Rules-1","page":"変換と昇格","title":"Defining Promotion Rules","text":"","category":"section"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Although one could, in principle, define methods for the promote function directly, this would require many redundant definitions for all possible permutations of argument types. Instead, the behavior of promote is defined in terms of an auxiliary function called promote_rule, which one can provide methods for. The promote_rule function takes a pair of type objects and returns another type object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"promote_rule(::Type{Float64}, ::Type{Float32}) = Float64","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"one declares that when 64-bit and 32-bit floating-point values are promoted together, they should be promoted to 64-bit floating-point. The promotion type does not need to be one of the argument types, however; the following promotion rules both occur in Julia Base:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"promote_rule(::Type{BigInt}, ::Type{Float64}) = BigFloat\npromote_rule(::Type{BigInt}, ::Type{Int8}) = BigInt","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"In the latter case, the result type is BigInt since BigInt is the only type large enough to hold integers for arbitrary-precision integer arithmetic. Also note that one does not need to define both promote_rule(::Type{A}, ::Type{B}) and promote_rule(::Type{B}, ::Type{A}) – the symmetry is implied by the way promote_rule is used in the promotion process.","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"The promote_rule function is used as a building block to define a second function called promote_type, which, given any number of type objects, returns the common type to which those values, as arguments to promote should be promoted. Thus, if one wants to know, in absence of actual values, what type a collection of values of certain types would promote to, one can use promote_type:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"julia> promote_type(Int8, Int64)\nInt64","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Internally, promote_type is used inside of promote to determine what type argument values should be converted to for promotion. It can, however, be useful in its own right. The curious reader can read the code in promotion.jl, which defines the complete promotion mechanism in about 35 lines.","category":"page"},{"location":"manual/conversion-and-promotion.html#Case-Study:-Rational-Promotions-1","page":"変換と昇格","title":"Case Study: Rational Promotions","text":"","category":"section"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"Finally, we finish off our ongoing case study of Julia's rational number type, which makes relatively sophisticated use of the promotion mechanism with the following promotion rules:","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}\npromote_rule(::Type{Rational{T}}, ::Type{Rational{S}}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}\npromote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:AbstractFloat} = promote_type(T,S)","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"The first rule says that promoting a rational number with any other integer type promotes to a rational type whose numerator/denominator type is the result of promotion of its numerator/denominator type with the other integer type. The second rule applies the same logic to two different types of rational numbers, resulting in a rational of the promotion of their respective numerator/denominator types. The third and final rule dictates that promoting a rational with a float results in the same type as promoting the numerator/denominator type with the float.","category":"page"},{"location":"manual/conversion-and-promotion.html#","page":"変換と昇格","title":"変換と昇格","text":"This small handful of promotion rules, together with the type's constructors and the default convert method for numbers, are sufficient to make rational numbers interoperate completely naturally with all of Julia's other numeric types – integers, floating-point numbers, and complex numbers. By providing appropriate conversion methods and promotion rules in the same manner, any user-defined numeric type can interoperate just as naturally with Julia's predefined numerics.","category":"page"},{"location":"manual/interfaces.html#Interfaces-1","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"A lot of the power and extensibility in Julia comes from a collection of informal interfaces.  By extending a few specific methods to work for a custom type, objects of that type not only receive those functionalities, but they are also able to be used in other methods that are written to generically build upon those behaviors.","category":"page"},{"location":"manual/interfaces.html#man-interface-iteration-1","page":"Interfaces","title":"Iteration","text":"","category":"section"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Required methods  Brief description\niterate(iter)  Returns either a tuple of the first item and initial state or nothing if empty\niterate(iter, state)  Returns either a tuple of the next item and next state or nothing if no items remain\nImportant optional methods Default definition Brief description\nIteratorSize(IterType) HasLength() One of HasLength(), HasShape{N}(), IsInfinite(), or SizeUnknown() as appropriate\nIteratorEltype(IterType) HasEltype() Either EltypeUnknown() or HasEltype() as appropriate\neltype(IterType) Any The type of the first entry of the tuple returned by iterate()\nlength(iter) (undefined) The number of items, if known\nsize(iter, [dim]) (undefined) The number of items in each dimension, if known","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Value returned by IteratorSize(IterType) Required Methods\nHasLength() length(iter)\nHasShape{N}() length(iter)  and size(iter, [dim])\nIsInfinite() (none)\nSizeUnknown() (none)","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Value returned by IteratorEltype(IterType) Required Methods\nHasEltype() eltype(IterType)\nEltypeUnknown() (none)","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Sequential iteration is implemented by the iterate function. Instead of mutating objects as they are iterated over, Julia iterators may keep track of the iteration state externally from the object. The return value from iterate is always either a tuple of a value and a state, or nothing if no elements remain.  The state object will be passed back to the iterate function on the next iteration and is generally considered an implementation detail private to the iterable object.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Any object that defines this function is iterable and can be used in the many functions that rely upon iteration. It can also be used directly in a for loop since the syntax:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"for i in iter   # or  \"for i = iter\"\n    # body\nend","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"is translated into:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"next = iterate(iter)\nwhile next !== nothing\n    (i, state) = next\n    # body\n    next = iterate(iter, state)\nend","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"A simple example is an iterable sequence of square numbers with a defined length:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> struct Squares\n           count::Int\n       end\n\njulia> Base.iterate(S::Squares, state=1) = state > S.count ? nothing : (state*state, state+1)","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"With only iterate definition, the Squares type is already pretty powerful.  We can iterate over all the elements:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> for i in Squares(7)\n           println(i)\n       end\n1\n4\n9\n16\n25\n36\n49","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"We can use many of the builtin methods that work with iterables, like in, or mean and std from the Statistics standard library module:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> 25 in Squares(10)\ntrue\n\njulia> using Statistics\n\njulia> mean(Squares(100))\n3383.5\n\njulia> std(Squares(100))\n3024.355854282583","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"There are a few more methods we can extend to give Julia more information about this iterable collection.  We know that the elements in a Squares sequence will always be Int. By extending the eltype method, we can give that information to Julia and help it make more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend length, too:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type\n\njulia> Base.length(S::Squares) = S.count","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Now, when we ask Julia to collect all the elements into an array it can preallocate a Vector{Int} of the right size instead of blindly push!ing each element into a Vector{Any}:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> collect(Squares(4))\n4-element Array{Int64,1}:\n  1\n  4\n  9\n 16","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"While we can rely upon generic implementations, we can also extend specific methods where we know there is a simpler algorithm. For example, there's a formula to compute the sum of squares, so we can override the generic iterative version with a more performant solution:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)\n\njulia> sum(Squares(1803))\n1955361914","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"This is a very common pattern throughout Julia Base: a small set of required methods define an informal interface that enable many fancier behaviors. In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be used in their specific case.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"It is also often useful to allow iteration over a collection in reverse order by iterating over Iterators.reverse(iterator).  To actually support reverse-order iteration, however, an iterator type T needs to implement iterate for Iterators.Reverse{T}.  (Given r::Iterators.Reverse{T}, the underling iterator of type T is r.itr.) In our Squares example, we would implement Iterators.Reverse{Squares} methods:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count) = state < 1 ? nothing : (state*state, state-1)\n\njulia> collect(Iterators.reverse(Squares(4)))\n4-element Array{Int64,1}:\n 16\n  9\n  4\n  1","category":"page"},{"location":"manual/interfaces.html#Indexing-1","page":"Interfaces","title":"Indexing","text":"","category":"section"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Methods to implement Brief description\ngetindex(X, i) X[i], indexed element access\nsetindex!(X, v, i) X[i] = v, indexed assignment\nfirstindex(X) The first index\nlastindex(X) The last index, used in X[end]","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"For the Squares iterable above, we can easily compute the ith element of the sequence by squaring it.  We can expose this as an indexing expression S[i]. To opt into this behavior, Squares simply needs to define getindex:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> function Base.getindex(S::Squares, i::Int)\n           1 <= i <= S.count || throw(BoundsError(S, i))\n           return i*i\n       end\n\njulia> Squares(100)[23]\n529","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Additionally, to support the syntax S[end], we must define lastindex to specify the last valid index. It is recommended to also define firstindex to specify the first valid index:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> Base.firstindex(S::Squares) = 1\n\njulia> Base.lastindex(S::Squares) = length(S)\n\njulia> Squares(23)[end]\n529","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Note, though, that the above only defines getindex with one integer index. Indexing with anything other than an Int will throw a MethodError saying that there was no matching method.  In order to support indexing with ranges or vectors of Ints, separate methods must be written:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]\n\njulia> Base.getindex(S::Squares, I) = [S[i] for i in I]\n\njulia> Squares(10)[[3,4.,5]]\n3-element Array{Int64,1}:\n  9\n 16\n 25","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"While this is starting to support more of the indexing operations supported by some of the builtin types, there's still quite a number of behaviors missing. This Squares sequence is starting to look more and more like a vector as we've added behaviors to it. Instead of defining all these behaviors ourselves, we can officially define it as a subtype of an AbstractArray.","category":"page"},{"location":"manual/interfaces.html#man-interface-array-1","page":"Interfaces","title":"Abstract Arrays","text":"","category":"section"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Methods to implement  Brief description\nsize(A)  Returns a tuple containing the dimensions of A\ngetindex(A, i::Int)  (if IndexLinear) Linear scalar indexing\ngetindex(A, I::Vararg{Int, N})  (if IndexCartesian, where N = ndims(A)) N-dimensional scalar indexing\nsetindex!(A, v, i::Int)  (if IndexLinear) Scalar indexed assignment\nsetindex!(A, v, I::Vararg{Int, N})  (if IndexCartesian, where N = ndims(A)) N-dimensional scalar indexed assignment\nOptional methods Default definition Brief description\nIndexStyle(::Type) IndexCartesian() Returns either IndexLinear() or IndexCartesian(). See the description below.\ngetindex(A, I...) defined in terms of scalar getindex Multidimensional and nonscalar indexing\nsetindex!(A, I...) defined in terms of scalar setindex! Multidimensional and nonscalar indexed assignment\niterate defined in terms of scalar getindex Iteration\nlength(A) prod(size(A)) Number of elements\nsimilar(A) similar(A, eltype(A), size(A)) Return a mutable array with the same shape and element type\nsimilar(A, ::Type{S}) similar(A, S, size(A)) Return a mutable array with the same shape and the specified element type\nsimilar(A, dims::Dims) similar(A, eltype(A), dims) Return a mutable array with the same element type and size dims\nsimilar(A, ::Type{S}, dims::Dims) Array{S}(undef, dims) Return a mutable array with the specified element type and size\nNon-traditional indices Default definition Brief description\naxes(A) map(OneTo, size(A)) Return the AbstractUnitRange of valid indices\nsimilar(A, ::Type{S}, inds) similar(A, S, Base.to_shape(inds)) Return a mutable array with the specified indices inds (see below)\nsimilar(T::Union{Type,Function}, inds) T(Base.to_shape(inds)) Return an array similar to T with the specified indices inds (see below)","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"If a type is defined as a subtype of AbstractArray, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access.  See the arrays manual page and the Julia Base section for more supported methods.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"A key part in defining an AbstractArray subtype is IndexStyle. Since indexing is such an important part of an array and often occurs in hot loops, it's important to make both indexing and indexed assignment as efficient as possible.  Array data structures are typically defined in one of two ways: either it most efficiently accesses its elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified for every dimension.  These two modalities are identified by Julia as IndexLinear() and IndexCartesian().  Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-based mechanism to enable efficient generic code for all array types.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"This distinction determines which scalar indexing methods the type must define. IndexLinear() arrays are simple: just define getindex(A::ArrayType, i::Int).  When the array is subsequently indexed with a multidimensional set of indices, the fallback getindex(A::AbstractArray, I...)() efficiently converts the indices into one linear index and then calls the above method. IndexCartesian() arrays, on the other hand, require methods to be defined for each supported dimensionality with ndims(A) Int indices. For example, SparseMatrixCSC from the SparseArrays standard library module, only supports two dimensions, so it just defines getindex(A::SparseMatrixCSC, i::Int, j::Int). The same holds for setindex!.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Returning to the sequence of squares from above, we could instead define it as a subtype of an AbstractArray{Int, 1}:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> struct SquaresVector <: AbstractArray{Int, 1}\n           count::Int\n       end\n\njulia> Base.size(S::SquaresVector) = (S.count,)\n\njulia> Base.IndexStyle(::Type{<:SquaresVector}) = IndexLinear()\n\njulia> Base.getindex(S::SquaresVector, i::Int) = i*i","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Note that it's very important to specify the two parameters of the AbstractArray; the first defines the eltype, and the second defines the ndims. That supertype and those three methods are all it takes for SquaresVector to be an iterable, indexable, and completely functional array:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> s = SquaresVector(4)\n4-element SquaresVector:\n  1\n  4\n  9\n 16\n\njulia> s[s .> 8]\n2-element Array{Int64,1}:\n  9\n 16\n\njulia> s + s\n4-element Array{Int64,1}:\n  2\n  8\n 18\n 32\n\njulia> sin.(s)\n4-element Array{Float64,1}:\n  0.8414709848078965\n -0.7568024953079282\n  0.4121184852417566\n -0.2879033166650653","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"As a more complicated example, let's define our own toy N-dimensional sparse-like array type built on top of Dict:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> struct SparseArray{T,N} <: AbstractArray{T,N}\n           data::Dict{NTuple{N,Int}, T}\n           dims::NTuple{N,Int}\n       end\n\njulia> SparseArray(::Type{T}, dims::Int...) where {T} = SparseArray(T, dims);\n\njulia> SparseArray(::Type{T}, dims::NTuple{N,Int}) where {T,N} = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);\n\njulia> Base.size(A::SparseArray) = A.dims\n\njulia> Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)\n\njulia> Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))\n\njulia> Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Notice that this is an IndexCartesian array, so we must manually define getindex and setindex!  at the dimensionality of the array. Unlike the SquaresVector, we are able to define setindex!, and so we can mutate the array:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> A = SparseArray(Float64, 3, 3)\n3×3 SparseArray{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> fill!(A, 2)\n3×3 SparseArray{Float64,2}:\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n\njulia> A[:] = 1:length(A); A\n3×3 SparseArray{Float64,2}:\n 1.0  4.0  7.0\n 2.0  5.0  8.0\n 3.0  6.0  9.0","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"The result of indexing an AbstractArray can itself be an array (for instance when indexing by an AbstractRange). The AbstractArray fallback methods use similar to allocate an Array of the appropriate size and element type, which is filled in using the basic indexing method described above. However, when implementing an array wrapper you often want the result to be wrapped as well:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> A[1:2,:]\n2×3 SparseArray{Float64,2}:\n 1.0  4.0  7.0\n 2.0  5.0  8.0","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"In this example it is accomplished by defining Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims) to create the appropriate wrapped array. (Note that while similar supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it's important that SparseArray is mutable (supports setindex!). Defining similar, getindex and setindex! for SparseArray also makes it possible to copy the array:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> copy(A)\n3×3 SparseArray{Float64,2}:\n 1.0  4.0  7.0\n 2.0  5.0  8.0\n 3.0  6.0  9.0","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in Julia Base for AbstractArrays:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> A[SquaresVector(3)]\n3-element SparseArray{Float64,1}:\n 1.0\n 4.0\n 9.0\n\njulia> sum(A)\n45.0","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize axes. You should also specialize similar  so that the dims argument (ordinarily a Dims size-tuple) can accept AbstractUnitRange objects, perhaps range-types Ind of your own design. For more information, see Arrays with custom indices.","category":"page"},{"location":"manual/interfaces.html#man-interface-strided-arrays-1","page":"Interfaces","title":"Strided Arrays","text":"","category":"section"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Methods to implement  Brief description\nstrides(A)  Return the distance in memory (in number of elements) between adjacent elements in each dimension as a tuple. If A is an AbstractArray{T,0}, this should return an empty tuple.\nBase.unsafe_convert(::Type{Ptr{T}}, A)  Return the native address of an array.\nOptional methods Default definition Brief description\nstride(A, i::Int) strides(A)[i] Return the distance in memory (in number of elements) between adjacent elements in dimension k.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"A strided array is a subtype of AbstractArray whose entries are stored in memory with fixed strides.  Provided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines for more efficient linear algebra routines.  A typical example of a user-defined strided array is one that wraps a standard Array with additional structure.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Warning: do not implement these methods if the underlying storage is not actually strided, as it may lead to incorrect results or segmentation faults.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Here are some examples to demonstrate which type of arrays are strided and which are not:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"1:5   # not strided (there is no storage associated with this array.)\nVector(1:5)  # is strided with strides (1,)\nA = [1 5; 2 6; 3 7; 4 8]  # is strided with strides (1,4)\nV = view(A, 1:2, :)   # is strided with strides (1,4)\nV = view(A, 1:2:3, 1:2)   # is strided with strides (2,4)\nV = view(A, [1,2,4], :)   # is not strided, as the spacing between rows is not fixed.","category":"page"},{"location":"manual/interfaces.html#man-interfaces-broadcasting-1","page":"Interfaces","title":"Customizing broadcasting","text":"","category":"section"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"| Methods to implement | Brief description | |:–––––––––– |:––––––––- | | Base.BroadcastStyle(::Type{SrcType}) = SrcStyle() | Broadcasting behavior of SrcType | | Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType}) | Allocation of output container | | Optional methods | | | | Base.BroadcastStyle(::Style1, ::Style2) = Style12() | Precedence rules for mixing styles | | Base.axes(x) | Declaration of the indices of x, as per axes(x). | | Base.broadcastable(x) | Convert x to an object that has axes and supports indexing | | Bypassing default machinery | | | Base.copy(bc::Broadcasted{DestStyle}) | Custom implementation of broadcast | | Base.copyto!(dest, bc::Broadcasted{DestStyle}) | Custom implementation of broadcast!, specializing on DestStyle | | Base.copyto!(dest::DestType, bc::Broadcasted{Nothing}) | Custom implementation of broadcast!, specializing on DestType | | Base.Broadcast.broadcasted(f, args...) | Override the default lazy behavior within a fused expression | | Base.Broadcast.instantiate(bc::Broadcasted{DestStyle}) | Override the computation of the lazy broadcast's axes |","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Broadcasting is triggered by an explicit call to broadcast or broadcast!, or implicitly by \"dot\" operations like A .+ b or f.(x, y). Any object that has axes and supports indexing can participate as an argument in broadcasting, and by default the result is stored in an Array. This basic framework is extensible in three major ways:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Ensuring that all arguments support broadcast\nSelecting an appropriate output array for the given set of arguments\nSelecting an efficient implementation for the given set of arguments","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Not all types support axes and indexing, but many are convenient to allow in broadcast.  The Base.broadcastable function is called on each argument to broadcast, allowing it to return something different that supports axes and indexing. By default, this is the identity function for all AbstractArrays and Numbers — they already support axes and indexing. For a handful of other types (including but not limited to types themselves, functions, special singletons like missing and nothing, and dates), Base.broadcastable returns the argument wrapped in a Ref to act as a 0-dimensional \"scalar\" for the purposes of broadcasting. Custom types can similarly specialize Base.broadcastable to define their shape, but they should follow the convention that collect(Base.broadcastable(x)) == collect(x). A notable exception is AbstractString; strings are special-cased to behave as scalars for the purposes of broadcast even though they are iterable collections of their characters (see Strings for more).","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"The next two steps (selecting the output array and implementation) are dependent upon determining a single answer for a given set of arguments. Broadcast must take all the varied types of its arguments and collapse them down to just one output array and one implementation. Broadcast calls this single answer a \"style.\" Every broadcastable object each has its own preferred style, and a promotion-like system is used to combine these styles into a single answer — the \"destination style\".","category":"page"},{"location":"manual/interfaces.html#Broadcast-Styles-1","page":"Interfaces","title":"Broadcast Styles","text":"","category":"section"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Base.BroadcastStyle is the abstract type from which all broadcast styles are derived. When used as a function it has two possible forms, unary (single-argument) and binary. The unary variant states that you intend to implement specific broadcasting behavior and/or output type, and do not wish to rely on the default fallback Broadcast.DefaultArrayStyle.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"To override these defaults, you can define a custom BroadcastStyle for your object:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"struct MyStyle <: Broadcast.BroadcastStyle end\nBase.BroadcastStyle(::Type{<:MyType}) = MyStyle()","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"In some cases it might be convenient not to have to define MyStyle, in which case you can leverage one of the general broadcast wrappers:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Base.BroadcastStyle(::Type{<:MyType}) = Broadcast.Style{MyType}() can be used for arbitrary types.\nBase.BroadcastStyle(::Type{<:MyType}) = Broadcast.ArrayStyle{MyType}() is preferred if MyType is an AbstractArray.\nFor AbstractArrays that only support a certain dimensionality, create a subtype of Broadcast.AbstractArrayStyle{N} (see below).","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"When your broadcast operation involves several arguments, individual argument styles get combined to determine a single DestStyle that controls the type of the output container.  For more details, see below.","category":"page"},{"location":"manual/interfaces.html#Selecting-an-appropriate-output-array-1","page":"Interfaces","title":"Selecting an appropriate output array","text":"","category":"section"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"The broadcast style is computed for every broadcasting operation to allow for dispatch and specialization. The actual allocation of the result array is handled by similar, using the Broadcasted object as its first argument.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"The fallback definition is","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"similar(bc::Broadcasted{DefaultArrayStyle{N}}, ::Type{ElType}) where {N,ElType} =\n    similar(Array{ElType}, axes(bc))","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"However, if needed you can specialize on any or all of these arguments. The final argument bc is a lazy representation of a (potentially fused) broadcast operation, a Broadcasted object.  For these purposes, the most important fields of the wrapper are f and args, describing the function and argument list, respectively.  Note that the argument list can — and often does — include other nested Broadcasted wrappers.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"For a complete example, let's say you have created a type, ArrayAndChar, that stores an array and a single character:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"struct ArrayAndChar{T,N} <: AbstractArray{T,N}\n    data::Array{T,N}\n    char::Char\nend\nBase.size(A::ArrayAndChar) = size(A.data)\nBase.getindex(A::ArrayAndChar{T,N}, inds::Vararg{Int,N}) where {T,N} = A.data[inds...]\nBase.setindex!(A::ArrayAndChar{T,N}, val, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] = val\nBase.showarg(io::IO, A::ArrayAndChar, toplevel) = print(io, typeof(A), \" with char '\", A.char, \"'\")","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"You might want broadcasting to preserve the char \"metadata.\" First we define","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Base.BroadcastStyle(::Type{<:ArrayAndChar}) = Broadcast.ArrayStyle{ArrayAndChar}()","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"This means we must also define a corresponding similar method:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"function Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{ArrayAndChar}}, ::Type{ElType}) where ElType\n    # Scan the inputs for the ArrayAndChar:\n    A = find_aac(bc)\n    # Use the char field of A to create the output\n    ArrayAndChar(similar(Array{ElType}, axes(bc)), A.char)\nend\n\n\"`A = find_aac(As)` returns the first ArrayAndChar among the arguments.\"\nfind_aac(bc::Base.Broadcast.Broadcasted) = find_aac(bc.args)\nfind_aac(args::Tuple) = find_aac(find_aac(args[1]), Base.tail(args))\nfind_aac(x) = x\nfind_aac(a::ArrayAndChar, rest) = a\nfind_aac(::Any, rest) = find_aac(rest)","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"From these definitions, one obtains the following behavior:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"julia> a = ArrayAndChar([1 2; 3 4], 'x')\n2×2 ArrayAndChar{Int64,2} with char 'x':\n 1  2\n 3  4\n\njulia> a .+ 1\n2×2 ArrayAndChar{Int64,2} with char 'x':\n 2  3\n 4  5\n\njulia> a .+ [5,10]\n2×2 ArrayAndChar{Int64,2} with char 'x':\n  6   7\n 13  14","category":"page"},{"location":"manual/interfaces.html#extending-in-place-broadcast-1","page":"Interfaces","title":"Extending broadcast with custom implementations","text":"","category":"section"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"In general, a broadcast operation is represented by a lazy Broadcasted container that holds onto the function to be applied alongside its arguments. Those arguments may themselves be more nested Broadcasted containers, forming a large expression tree to be evaluated. A nested tree of Broadcasted containers is directly constructed by the implicit dot syntax; 5 .+ 2.*x is transiently represented by Broadcasted(+, 5, Broadcasted(*, 2, x)), for example. This is invisible to users as it is immediately realized through a call to copy, but it is this container that provides the basis for broadcast's extensibility for authors of custom types. The built-in broadcast machinery will then determine the result type and size based upon the arguments, allocate it, and then finally copy the realization of the Broadcasted object into it with a default copyto!(::AbstractArray, ::Broadcasted) method. The built-in fallback broadcast and broadcast! methods similarly construct a transient Broadcasted representation of the operation so they can follow the same codepath. This allows custom array implementations to provide their own copyto! specialization to customize and optimize broadcasting. This is again determined by the computed broadcast style. This is such an important part of the operation that it is stored as the first type parameter of the Broadcasted type, allowing for dispatch and specialization.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"For some types, the machinery to \"fuse\" operations across nested levels of broadcasting is not available or could be done more efficiently incrementally. In such cases, you may need or want to evaluate x .* (x .+ 1) as if it had been written broadcast(*, x, broadcast(+, x, 1)), where the inner operation is evaluated before tackling the outer operation. This sort of eager operation is directly supported by a bit of indirection; instead of directly constructing Broadcasted objects, Julia lowers the fused expression x .* (x .+ 1) to Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1)). Now, by default, broadcasted just calls the Broadcasted constructor to create the lazy representation of the fused expression tree, but you can choose to override it for a particular combination of function and arguments.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"As an example, the builtin AbstractRange objects use this machinery to optimize pieces of broadcasted expressions that can be eagerly evaluated purely in terms of the start, step, and length (or stop) instead of computing every single element. Just like all the other machinery, broadcasted also computes and exposes the combined broadcast style of its arguments, so instead of specializing on broadcasted(f, args...), you can specialize on broadcasted(::DestStyle, f, args...) for any combination of style, function, and arguments.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"For example, the following definition supports the negation of ranges:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"broadcasted(::DefaultArrayStyle{1}, ::typeof(-), r::OrdinalRange) = range(-first(r), step=-step(r), length=length(r))","category":"page"},{"location":"manual/interfaces.html#extending-in-place-broadcast-2","page":"Interfaces","title":"Extending in-place broadcasting","text":"","category":"section"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"In-place broadcasting can be supported by defining the appropriate copyto!(dest, bc::Broadcasted) method. Because you might want to specialize either on dest or the specific subtype of bc, to avoid ambiguities between packages we recommend the following convention.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"If you wish to specialize on a particular style DestStyle, define a method for","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"copyto!(dest, bc::Broadcasted{DestStyle})","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Optionally, with this form you can also specialize on the type of dest.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"If instead you want to specialize on the destination type DestType without specializing on DestStyle, then you should define a method with the following signature:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"copyto!(dest::DestType, bc::Broadcasted{Nothing})","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"This leverages a fallback implementation of copyto! that converts the wrapper into a Broadcasted{Nothing}. Consequently, specializing on DestType has lower precedence than methods that specialize on DestStyle.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Similarly, you can completely override out-of-place broadcasting with a copy(::Broadcasted) method.","category":"page"},{"location":"manual/interfaces.html#Working-with-Broadcasted-objects-1","page":"Interfaces","title":"Working with Broadcasted objects","text":"","category":"section"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"In order to implement such a copy or copyto!, method, of course, you must work with the Broadcasted wrapper to compute each element. There are two main ways of doing so:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Broadcast.flatten recomputes the potentially nested operation into a single function and flat list of arguments. You are responsible for implementing the broadcasting shape rules yourself, but this may be helpful in limited situations.\nIterating over the CartesianIndices of the axes(::Broadcasted) and using indexing with the resulting CartesianIndex object to compute the result.","category":"page"},{"location":"manual/interfaces.html#writing-binary-broadcasting-rules-1","page":"Interfaces","title":"Writing binary broadcasting rules","text":"","category":"section"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"The precedence rules are defined by binary BroadcastStyle calls:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Base.BroadcastStyle(::Style1, ::Style2) = Style12()","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"where Style12 is the BroadcastStyle you want to choose for outputs involving arguments of Style1 and Style2. For example,","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Base.BroadcastStyle(::Broadcast.Style{Tuple}, ::Broadcast.AbstractArrayStyle{0}) = Broadcast.Style{Tuple}()","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"indicates that Tuple \"wins\" over zero-dimensional arrays (the output container will be a tuple).  It is worth noting that you do not need to (and should not) define both argument orders of this call; defining one is sufficient no matter what order the user supplies the arguments in.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"For AbstractArray types, defining a BroadcastStyle supersedes the fallback choice, Broadcast.DefaultArrayStyle. DefaultArrayStyle and the abstract supertype, AbstractArrayStyle, store the dimensionality as a type parameter to support specialized array types that have fixed dimensionality requirements.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"DefaultArrayStyle \"loses\" to any other AbstractArrayStyle that has been defined because of the following methods:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"BroadcastStyle(a::AbstractArrayStyle{Any}, ::DefaultArrayStyle) = a\nBroadcastStyle(a::AbstractArrayStyle{N}, ::DefaultArrayStyle{N}) where N = a\nBroadcastStyle(a::AbstractArrayStyle{M}, ::DefaultArrayStyle{N}) where {M,N} =\n    typeof(a)(_max(Val(M),Val(N)))","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"You do not need to write binary BroadcastStyle rules unless you want to establish precedence for two or more non-DefaultArrayStyle types.","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"If your array type does have fixed dimensionality requirements, then you should subtype AbstractArrayStyle. For example, the sparse array code has the following definitions:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"struct SparseVecStyle <: Broadcast.AbstractArrayStyle{1} end\nstruct SparseMatStyle <: Broadcast.AbstractArrayStyle{2} end\nBase.BroadcastStyle(::Type{<:SparseVector}) = SparseVecStyle()\nBase.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatStyle()","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"Whenever you subtype AbstractArrayStyle, you also need to define rules for combining dimensionalities, by creating a constructor for your style that takes a Val(N) argument.  For example:","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"SparseVecStyle(::Val{0}) = SparseVecStyle()\nSparseVecStyle(::Val{1}) = SparseVecStyle()\nSparseVecStyle(::Val{2}) = SparseMatStyle()\nSparseVecStyle(::Val{N}) where N = Broadcast.DefaultArrayStyle{N}()","category":"page"},{"location":"manual/interfaces.html#","page":"Interfaces","title":"Interfaces","text":"These rules indicate that the combination of a SparseVecStyle with 0- or 1-dimensional arrays yields another SparseVecStyle, that its combination with a 2-dimensional array yields a SparseMatStyle, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework. These rules allow broadcasting to keep the sparse representation for operations that result in one or two dimensional outputs, but produce an Array for any other dimensionality.","category":"page"},{"location":"manual/modules.html#modules-1","page":"モジュール","title":"モジュール","text":"","category":"section"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"Julia のモジュールは独立した変数のワークスペースであり、新しいグローバル スコープを導入します。モジュールは、module Name ... end で構文的に区切られています。 モジュールを使用すると、(グローバル変数として知られる)最上位の定義を行うことができて、かつ、自分のコードと他のユーザーのコードとを一緒に使用する際に名前の競合を心配しなくてすみます。モジュール内では、他のモジュールから参照する名前を (インポートして) 制御し、自分のモジュール内のどの名前を(エクスポートで) パブリックにするかを指定することができます。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"次の例は、モジュールの主な機能を示しています。これは説明用のためのもので、実際に実行するために書かれたコードではありません:","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"module MyModule\nusing Lib\n\nusing BigLib: thing1, thing2\n\nimport Base.show\n\nexport MyType, foo\n\nstruct MyType\n    x\nend\n\nbar(x) = 2x\nfoo(a::MyType) = bar(a.x) + 1\n\nshow(io::IO, a::MyType) = print(io, \"MyType $(a.x)\")\nend","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"表記スタイル上の注意点は、モジュールの本体をインデントしないということでしょう。インデントするとなると、通常はファイル全体がインデントされることになってしまいます。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"このモジュールでは、型 MyType と 2 つの関数を定義されています。関数 foo と型 MyType がエクスポートされ、他のモジュールへのインポートに使用できるようになります。 関数 bar は MyModule 内でのみ使用するプライベートな関数です。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"using Libと宣言することで、必要に応じて Lib というモジュールを使用して名前を解決します。現在のモジュールに定義がないグローバル変数が検出されると、システムはLib によってエクスポートされた変数の中からその変数を検索し、そこに見つかった場合はインポートします。 つまり、現在のモジュール内でグローバル変数を使うと全てLib 内の同名の変数定義によって解決されることを意味します。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"using BigLib: thing1, thing2 とう宣言で、thing1 と thing2 という識別子が BigLib から現在のスコープに持ち込まれる。もしそれらの名前が、関数を参照するものならば、メソッドの追加は許されません(メソッドを使用するだけで、拡張は許されない)。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"import キーワードは using と同じ構文をサポートしますが、一度に 1 つの名前でのみ動作します。usingのようにモジュール全体を検索対象に追加することはできません。import を使用してインポートされた関数は新しいメソッドで拡張できるという点で、using とは異なります。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"上記のMyModuleでは、標準のshow関数にメソッドを追加したかったので、import Base.showと書く必要が有りました。名前が using を介してのみ参照できる関数は拡張できません。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"using または import を使用して変数が一度参照されると、その変数と同じ名前を持つ変数を、モジュール内に独自に定義することはできなくなります。インポートされた変数は読み取り専用です。グローバル変数に代入は、常に現在のモジュールが所有する変数に対するものです。そうでなければエラーが発生します。","category":"page"},{"location":"manual/modules.html#モジュールの使用法のまとめ-1","page":"モジュール","title":"モジュールの使用法のまとめ","text":"","category":"section"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"モジュールを読み込むには、using と import の2つの主要キーワードが利用できます。両者の違いを理解するには、次の例を考えてください:","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"module MyModule\n\nexport x, y\n\nx() = \"x\"\ny() = \"y\"\np() = \"p\"\n\nend","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"このモジュールは、関数 x と 関数 y を(キーワード exportを用いて) エクスポートし、それとは別にエクスポートされていない関数 p も定義されています。モジュールとその内部関数を現在のワークスペースにロードするには、いくつかの異なる方法があります:","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"インポートするコマンド スコープに導入されるもの メソッド拡張に利用できるもの\nusing MyModule All exported names (x and y), MyModule.x, MyModule.y and MyModule.p MyModule.x, MyModule.y and MyModule.p\nusing MyModule: x, p x and p \nimport MyModule MyModule.x, MyModule.y and MyModule.p MyModule.x, MyModule.y and MyModule.p\nimport MyModule.x, MyModule.p x and p x and p\nimport MyModule: x, p x and p x and p","category":"page"},{"location":"manual/modules.html#モジュールとファイル-1","page":"モジュール","title":"モジュールとファイル","text":"","category":"section"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"ファイルとファイル名は、ほとんどモジュールとは無関係です。モジュールはモジュール式にのみ関連付けられています。1 つのモジュールが複数のファイルをまたぐこともできますし、複数のモジュールを同じ1つのファイルに定義することもできます:","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"module Foo\n\ninclude(\"file1.jl\")\ninclude(\"file2.jl\")\n\nend","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"異なるモジュールに同じコードを含めると、mixin のような動作が提供されます。これを使用して、異なる基本定義で同じコードを実行できます。例えば、それを実行することである処理を「安全バージョン」実行してコードを検査することができます:","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"module Normal\ninclude(\"mycode.jl\")\nend\n\nmodule Testing\ninclude(\"safe_operators.jl\")\ninclude(\"mycode.jl\")\nend","category":"page"},{"location":"manual/modules.html#標準モジュール-1","page":"モジュール","title":"標準モジュール","text":"","category":"section"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"There are three important standard modules: * Core contains all functionality \"built into\" the language.  * Base contains basic functionality that is useful in almost all cases.  * Main is the top-level module and the current module, when Julia is started.","category":"page"},{"location":"manual/modules.html#デフォルトの最上位定義とベアモジュール-1","page":"モジュール","title":"デフォルトの最上位定義とベアモジュール","text":"","category":"section"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"using Baseに加えて、モジュールには eval関数と include 関数の定義も自動的に含まれ、そのモジュールのグローバルスコープ内の式やファイルを評価します。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"これらのデフォルトの定義が不要な場合は、代わりにキーワード baremodule を使用してモジュールを定義できます (注: baremoduleキーワードを使っても Core はインポートされます)。baremodule の使用、という観点から、標準的なモジュールの動作を見てみると:","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"baremodule Mod\n\nusing Base\n\neval(x) = Core.eval(Mod, x)\ninclude(p) = Base.include(Mod, p)\n\n...\n\nend","category":"page"},{"location":"manual/modules.html#相対モジュールパスと絶対モジュールパス-1","page":"モジュール","title":"相対モジュールパスと絶対モジュールパス","text":"","category":"section"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"using Foo 文を記述されていると、システムは最上位モジュールの内部テーブルを参照して Foo という名前のモジュールを探します。モジュールが存在しない場合、システムは require(:Foo) を試み、通常はインストールされたパッケージからコードを読み込みます。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"しかし、一部のモジュールにはサブモジュールが含むものがあり、最上位以外の(Mainから直接アクセスできない)モジュールにアクセスする必要がある場合があります。これを行うには 2 つの方法があります。1 つ目は、using Base.Sort などのように絶対パスを使用することです。2 つ目は相対パスを使用する方法で、現在のモジュールや、サブモジュールを含むモジュールから、サブモジュールのインポートを簡単におこなえます:","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"module Parent\n\nmodule Utils\n...\nend\n\nusing .Utils\n\n...\nend","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"ここではモジュール Parent にはサブモジュール Utils が含まれており、Parent のコードは Utils の内容を参照する必要があります。これは、using 対象のパスをピリオドから開始することによって行われます。先頭にさらにもう一つピリオドを追加すると、モジュール階層のレベルが上がります。たとえば、using ..UtilsはParentモジュール自体ではなく、またさらにその上のParentモジュールを含むモジュール階層で、Utils を探します。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"相対インポート修飾子はusing ステートメントと import ステートメントでのみ有効です。","category":"page"},{"location":"manual/modules.html#名前空間に関する雑記-1","page":"モジュール","title":"名前空間に関する雑記","text":"","category":"section"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"名前が修飾されている場合 (例: Base.sin) は、エクスポートされていない場合でもアクセスできます。 これは、多くの場合、デバッグ時に便利です。修飾名を関数名として使用してメソッドを追加することもできます。ただし、構文のあいまいさが生じるため、別のモジュールに含まれる関数で、例えば演算子Base.+のように関数名が記号のみで構成されるものにメソッドを追加したいときには、その関数を参照するのに Base.:+ を使用してください。演算子が複数文字の場合は、次のように括弧で囲んでください: Base.:(==).","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"インポートおよびエクスポート文の中で、マクロ名は@を付けてimport Mod.@macのように書かれます。他のモジュールのマクロはMod.@mac または @Mod.mac のようにして呼び出すことができます。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"構文 M.x = y という構文では、別のモジュールのグローバル変数に代入をすることはできません。グローバル変数の代入は常にローカルなモジュールで行われます。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"変数名は、global x のように最上位で宣言することで、変数への代入を行うこと無く、名前を予約することができます。これにより、ロード後に初期化されるグローバル変数名の競合を防ぐことができます。","category":"page"},{"location":"manual/modules.html#Module-initialization-and-precompilation-1","page":"モジュール","title":"モジュールの初期化とプリコンパイル","text":"","category":"section"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"大きなモジュールの読み込みには数秒かかることがあります。モジュール内のすべてのステートメントを実行するには、多くの場合、大量のコードをコンパイルする必要があるためです。 Julia は、この時間を短縮するために、モジュールの事前コンパイル済みキャッシュファイルを作成しておいて、この時間を短縮します。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"インクリメンタルプリコンパイルされたモジュールファイルは、import や using が使われてモジュールがロードする際に自動的に作成されます。これにより、初めてインポートしたときに自動的にコンパイルされます。または、手動で Base.compilecache(Module Name)としてコンパイルさせることもできます。得られたキャッシュファイルは、DEPOT_PATH[1]/compiled/ に格納されます。その後、依存関係が変更されるたびに、モジュールは自動的に usingまたはimport時に再コンパイルされます。ここでいう依存関係とは、インポートするモジュール、Julia のビルド、include されｒファイル、またはモジュール ファイル内の include_dependency(path) によって宣言された明示的な依存関係などのことです。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"ファイルの依存関係については、依存関係の変更があったかどうかは、include によって読み込まれたり、include_dependency によって明示的に追加された各ファイルについて、その更新時刻 (mtime) が変わっていないかどうか、あるいは (1秒以下の精度でmtime をコピーできないシステムに対応するために)最も近い秒に切り捨てられた変更時間と等しいかどうかで判断されます。また、require の検索ロジックで選択されたファイルへのパスが、プリコンパイル ファイルを作成したパスと一致するかどうかも考慮されます。また、現在のプロセスが既に読み込んでいる一連の依存関係も考慮されます。実行中のシステムとプリコンパイル キャッシュの間に不整合が生じないように、実行中にファイルが変更されたり削除されても、それらのモジュールを再コンパイルしません。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"モジュールを事前コンパイルするのが安全でないことがわかっている場合 (その理由の一例はこの後に述べますが) 、モジュール ファイル(通常はファイルの上部)に __precompile__(false)を記入してください。 これにより、Base.compilecache がエラーをスローして、using / import が現在のプロセスに直接そのモジュールを読み込み、プリコンパイルとキャッシュをスキップします。 これにより、モジュールが他のプリコンパイル済みモジュールによってインポートされるのを防ぐことができます。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"モジュールのコードを書いているときには、増分共有ライブラリの作成に固有の特定の動作に注意する必要があります。たとえば、外部状態は保持されません。 これに対応するために、実行時 に 処理される必要のある初期化ステップと、コンパイル時に処理してもよいステップとを明示的に分離してください。Julia では、モジュールに __init__()関数を定義し、ここに、実行時に処理される必要がある初期化ステップを書くことができます。この関数は(--output-*による)コンパイル中には呼び出されず、 コードが実行されている間に 1 回だけ実行されると想定できます。 もちろん、必要に応じて手動で呼び出すこともできますが、デフォルトでは、この関数が、処理を実行中マシンの計算状態を扱っていると想定できます。ここでいう計算状態とは、プリコンパイルイメージに含まれる必要がない","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"むしろ含まれてはいけない ようなモノを表します。この","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"__init__()関数は、モジュールがプロセスにロードされたあとで、呼ばれます。これは、インクリメンタル コンパイル (-output-incremental=yes) でロードされる場合も該当しますが、フルコンパイルプロセスにロードされる場合は該当しません。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"特に、モジュール内に__init__()関数を定義した場合、(例えば、import、using、requireなどを用いて)モジュールがロードされた直後、初めての実行時に __init__()関数が呼ばれます。 (つまり、モジュール内のすべての文が実行された後に__init__ は 1 回だけ呼び出されます)。モジュールが完全にインポートされた後に呼び出されるため、サブモジュールやその他のインポートされたモジュールの __init__()関数はそれを囲むモジュールの__init__よりも 前に 呼び出されます。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"__init__ の 2 つの典型的な用途は、外部 C ライブラリのランタイム初期化関数を呼び出し、外部ライブラリによって返されるポインターを含むグローバル定数を初期化することです。 たとえば、実行時に foo_init() 初期化関数を呼び出す必要がある C ライブラリ libfoo を呼び出すとします。libfoo で定義された void *foo_data() 関数の戻り値を保持するグローバル定数 foo_data_ptr も定義するとします。この時、ポインタのアドレスは実行するごとに変わるため、foo_data_ptr は(コンパイル時ではなく)実行時に初期化する必要があります。これは、モジュール内に次のような__init__関数を定義すれば、実行できます:","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"const foo_data_ptr = Ref{Ptr{Cvoid}}(0)\nfunction __init__()\n    ccall((:foo_init, :libfoo), Cvoid, ())\n    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())\n    nothing\nend","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"__init__のような関数内でグローバルにシンボルを定義することは可能であることに注目してください。これは動的言語を使用する利点の 1 つですが、グローバルスコープで定数とすることで、コンパイラが型を認識し、より最適化されたコードを生成できるようになります。明らかに、モジュール内の他のグローバルも foo_data_ptr に依存するものについては、__init__ で初期化する必要があります。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"ccall を使わずに生成されるほとんどの Julia オブジェクトを含む定数は__init__ に配置する必要はありません。 そういう定数の定義は、プリコンパイルでき、キャッシュされたモジュールイメージからロードすることができます。これには、配列のようにヒープを割り当てられた複雑なオブジェクトも含まれますが、生のポインター値を返すルーチンは、プリコンパイルがうまく動作するように実行時に呼び出す必要があります(Ptr オブジェクトは、isbits オブジェクト内に隠されていない限り、null ポインターに なります)。これには、Julia 関数 cfunction と pointerの戻り値が含まれます。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"辞書型、集合型、または一般にhash(key)メソッドの出力に何らか依存するものは取り扱いが厄介なケースです。key が数値、文字列、シンボル、範囲、Expr、またはこれらの型の複合型 (配列、タプル、集合、Pairなどを介して) である一般的なケースでは、プリコンパイルしても安全です。 ただし、いくつかのキー型、例えば Function、DataType  そして hashメソッドを定義していない汎用ユーザー定義の型などについは、フォールバック hashメソッドは、(objectid を介する) オブジェクトのメモリ アドレスに依存しており、実行するたびに変更されるかもしれません。これらのキータイプのいずれかを持っている場合、または安全であると確信が持てない場合は、__init__ 関数内からこの辞書を初期化できます。あるいは、IdDict辞書型を使うこともできます。これはコンパイル時に安全に初期化できるように、プリコンパイルによって特殊な処理がされます。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"プリコンパイルを使用する場合は、コンパイル フェーズと実行フェーズの違いを明確に理解しておく必要があります。このモードでは、Julia がコンパイル済みコードを生成するスタンドアロンインタプリタではなく、任意の Julia コードの実行を可能にするコンパイラであることが明らかになることがよくあります。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"その他既知の失敗しがちなシナリオは下記の通りです:","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"グローバルカウンター(例えば、オブジェクトを一意に識別する)について、次のコードを考えてみましょう:\nmutable struct UniquedById\n    myid::Int\n    let counter = 0\n        UniquedById() = new(counter += 1)\n    end\nend\nこのコードの目的は、すべてのインスタンスに一意の ID を与えるものでしたが、コンパイルの最後にカウンタ値はが記録されます。このあとで、インクリメンタルコンパイルされたモジュールが使われるときはいつも、同じカウンタ値から起動します。\nobjectid は、メモリポインタをハッシュするものですが、似たような問題があることに注意 ( 下記の Dict 用法参照 ) 。\nもう 1 つの方法は、マクロを使用して @__MODULE__ をキャプチャし、現在の 'カウンタ' 値を使用して単独で格納することです。ただし、このグローバル状態に依存しないようにコードを再設計するほうがよいかもしれません。\n連想コレクション (Dict や Set など) は __init__で再ハッシュする必要があります。(将来的には、初期化関数を登録するメカニズムが提供されるかもしれません)。\nコンパイル時の副作用の影響はは実行時にも残ります。例: 他の Julia モジュールの配列またはその他の変数の内容の変更、ファイルまたはデバイスを開くためにハンドルの保持、他のシステム リソース (メモリを含む) へのポインターの格納。\nルックアップパスではなく、直接参照をすることで、別のモジュールからグローバルな状態の「コピー」を意図せず作成してしまうこと。例えば、(グローバルスコープでは):\n#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#\n# instead use accessor functions:\ngetstdout() = Base.stdout #= best option =#\n# or move the assignment into the runtime:\n__init__() = global mystdout = Base.stdout #= also works =#","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"コードのプリコンパイル中に可能な処理には様々な制限が課されます。ユーザーが間違った状況を避けるのを支援するためです:","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"別のモジュールで副作用を引き起こすevalの呼び出し。また、インクリメンタルなプリコンパイルのフラグが設定されている時には警告が出力されます。\n__init__()が処理開始された後の ローカルスコープからの global const 宣言 (これに対してエラーを発生させようという計画については、issue #12010 を参照)\nモジュールの置き換えは、増分プリコンパイルの実行中にランタイム エラーを引き起こします。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"その他の注意点は次のとおりです:","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"ソース ファイル自体に変更が加えられた(Pkg.update 含む)後に 、コードの再読み込み/キャッシュの無効化は実行されません 、Pkg.rm の後にクリーンアップは行われません\nReshape された配列のメモリ共有動作は、プリコンパイルによって無視されます (各ビューは独自のコピーを取得します)\nコンパイル時と実行時の間にファイルシステムが変更されないことを期待するもの: 例えば、@__FILE__/source_path()で実行時にリソースを探すためとか、BinDeps の @checked_lib マクロなど。こういうことは避けられないことがあります。ただし、可能であれば、コンパイル時にリソースをモジュールにコピーしておいて、実行時にそのリソースを探す必要を無くしておくのはよいプラクティスです。\nWeakRef オブジェクトとファイナライザは、現在シリアライザーによって適切に処理されていません (これは今後のリリースで修正されます)。\n通常は、シリアライザーを混乱させ、望まぬ結果を導く可能性があるため、Method, MethodInstance, MethodTable, TypeMapLeve, TypeMapEntry そしてこれらのオブジェクトのフィールドなどの、内部メタデータオブジェクトのインスタンスへの参照を補足しないようにすることをお考めします。参照を補足することは必ずしもエラーではありませんが、システムがこれらの一部をコピーし、単一・唯一のインスタンスを作成するようにすればよい話です。","category":"page"},{"location":"manual/modules.html#","page":"モジュール","title":"モジュール","text":"モジュールの開発中に、インクリメンタルプリコンパイルをオフにすると便利な場合があります。コマンドラインフラグ --compiled-modules={yes|no} を使用すると、モジュールのプリコンパイルのオンとオフを切り替うことができます。Julia が --compiled-modules=no で起動すると、モジュールとモジュールの依存関係を読み込むときに、コンパイル キャッシュ内のシリアル化されたモジュールは無視されます。--compiled-modules=noにしていてもBase.compilecache は手動で呼び出すことができます。このコマンド ライン フラグの状態は Pkg.build に渡され、パッケージのインストール、更新、および明示的なビルド時に自動プリコンパイルトリガを無効にします。","category":"page"},{"location":"manual/documentation.html#Documentation-1","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"パッケージ開発者やユーザーは、Julia v0.4 以降で組み込みのドキュメントシステムを使って、関数、型、およびその他のオブジェクトのドキュメンテーションを簡単に行えます。","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"基本的な構文は単純です: オブジェクト (関数、マクロ、型、またはインスタンス)の直前・最上位の文字列を書くと その文字列はドキュメントと解釈されます (これらは docstringsと呼ばれます)。 docstring とドキュメント化したいオブジェクトの間に、空白行やコメントがないようにしてください。基本的な例は以下の通りです:","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"Tell whether there are too foo items in the array.\"\nfoo(xs::Array) = ...","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"ドキュメンテーションはMarkdownとして解釈されます。そのため、インデントやコードフェンスを使って、テキストとコード例を分けて書くことができます。技術的には、全てのオブジェクトをメタデータとして、別のオブジェクトに関連付けることができます。デフォルトでは、ドキュメントはマークダウンとして解釈されますが、他の文字列のマクロを定義して、@docマクロに渡してドキュメントとすることもできます。","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"!!! メモ     Markdown サポートは Markdown 標準ライブラリで実装されています。サポートされている構文一覧は Markdownのドキュメント を参照してください","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Markdownを使用した、より複雑な例を次に示します:","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"\"\"\n    bar(x[, y])\n\nCompute the Bar index between `x` and `y`. If `y` is missing, compute\nthe Bar index between all pairs of columns of `x`.\n\n# Examples\n```julia-repl\njulia> bar([1, 2], [1, 2])\n1\n```\n\"\"\"\nfunction bar(x, y) ...","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"上記の例と同様に、ドキュメントを作成する際には、いくつかの簡単な規則に従うことをお勧めします:","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"ドキュメントの上部に関数のシグネチャを常に表示し、スペース4つのインデントを使用して、Julia コードとして印刷します。\nここでの表記は、Juliaコードのシグネチャと全く同じにしてもよいですし (mean(x::AbstractArray)などのように)、簡略表記としてもよいしょう。 オプション引数は、可能な場合は実際のJuliaの構文に従って、デフォルト値も示すべきです(つまりf(x, y=1)のように)。 デフォルト値を持たないオプション引数は、括弧内に入れてください (つまり、f(x[,y])や f(x[,y[,z]]のように)。 その他の方法としては、複数行を使用することです: 1行を通常引数に、ほかの行をオプション引数に使う、ということです。 この方法は、ある関数に対して、いくつかの関連するメソッドのドキュメンテーションにも使用ですまう。 関数が多くのキーワード引数を持つ時には、<keyword arguments>プレースホルダのみをシグネチャに含むシグネチャに含めて (すなわちf(x;<keyword arguments>))、完全な引数リストを #Arguments セクション以下に書いてください(ポイント4参照)。\n簡略化されたシグニチャの後には、関数の振る舞い、やオブジェクトが何者であるか、1行で説明しましょう 必要に応じて、1行空けたあとの段落でより詳細について記述してください。\n関数の1 行説明は、3単現のsを付けずに、命令形で書いてください。最後にピリオドを付けます。 関数の意味を簡単に要約できない場合は、関数の構成要素を分割するとよいかもしれません(絶対的な要件ではなく、あくまで一例です)。\n繰り返しを避けましょう(DRY)。\n関数名はシグネチャによって与えられるので、「関数barは..」という文言でドキュメントを開始する必要はありません: はじめから要点を書いてください。同様に、シグネチャで引数の型が指定されているならば、説明で型に言及することは冗長です。\n本当に必要な場合にのみ引数リストを書きます。\n単純な関数の場合、関数の目的を説明する際に直接 引数の役割に言及する方が明らかにわかりやすいことがあります。 (そのような場合、)引数リストは、他の場所で言及された情報を繰り返すだけです ただし、多くの引数(特にキーワード引数)を使う、複雑な関数に対しては、引数リストを書くのはよいアイディアです。 その場合、一般的な関数説明の後、#Arguments ヘッダの下に引数リストを挿入します。引数1つずつに対して - の箇条書きを使いましょう。 リストには、引数の型と既定値 (ある場合) を指定する必要があります。\n\"\"\"\n...\n# Arguments\n- `n::Integer`: the number of elements to compute.\n- `dim::Integer=1`: the dimensions along which to perform the computation.\n...\n\"\"\"\n関連する関数にヒント(see. also)を加えましょう。\n関連する機能をもつ関数がある場合は、適切な関数を発見して貰う可能性を高めるために、See also: の段落でに関連する関数の短いリストを加えましょう。\nSee also: [`bar!`](@ref), [`baz`](@ref), [`baaz`](@ref)\n# Examplesセクションになんからのコード例を示しましょう。\n例は、可能な限り doctestsとして記述する必要があります。doctest はフェンスで囲まれたコードブロックです(コードブロック 参照) 。 ```jldoctestで始まり、任意の数の julia> プロンプトが、その入出力とともに含まれます。ここでの出力はJuliaのREPLであれば与えられた入力に対して、この出力を出すだろうという期待値です。\n!!!メモ     doctest はDocumenter.jlによって有効化されます。     詳細なドキュメントについては、Documenter のマニュアルを見てください。\nたとえば、次の docstring では変数 a が定義され、期待される結果が Julia のREPLにプリント出力されるのと同じように後で表示されます。\n\"\"\"\nSome nice documentation here.\n\n# Examples\n```jldoctest\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n```\n\"\"\"\n!!!警告     rand およびその他の RNG 関連の関数の呼び出しは、doctest では避けて下さい。     RNG関連の関数は、異なる Julia セッションで一貫した出力を生成しないからです。何らかの乱数生成関連の機能を示したい場合の一つの選択肢は、MersenneTwister(もしくはその他の疑似乱数生成の関数)に明示的にシードを与え、その結果をdoctest を書いている関数に与えることです。\nオペレーティング システムのワードサイズ ([`Int32`](@ref) または [`Int64`](@ref))とパス区切り記号の違い\n(`/` または `\\`) は、一部のdoctestの再現性にも影響します。\n\ndoctest の空白は重要です。doctest は例えば配列のpritty-printの出力位置が(期待値と)ずれていると失敗します。\nJuliaのマニュアルとAPIドキュメントではコードexampleが確実に機能します。 すべてのdoctestを実行するには make -C doctest=trueを実行してください\n出力結果が切り捨てられることを示すには、チェックを停止すべき行で[...]と書くことができます。 これは、doctest で何か例外がスローされたとき、スタックトレース(これは、Julia のコード行への非永続的な参照を含みます) を非表示にするのに役立ちます。例えば:\n```jldoctest\njulia> div(1, 0)\nERROR: DivideError: integer division error\n[...]\n```\nExamples that are untestable should be written within fenced code blocks starting with ```julia so that they are highlighted correctly in the generated documentation.\ntip: Tip\nWherever possible examples should be self-contained and runnable so that readers are able to try them out without having to include any dependencies.\nUse backticks to identify code and equations.\nJulia identifiers and code excerpts should always appear between backticks ` to enable highlighting. Equations in the LaTeX syntax can be inserted between double backticks ``. Use Unicode characters rather than their LaTeX escape sequence, i.e. ``α = 1`` rather than ``\\\\alpha = 1``.\nPlace the starting and ending \"\"\" characters on lines by themselves.\nThat is, write:\n\"\"\"\n...\n\n...\n\"\"\"\nf(x, y) = ...\nrather than:\n\"\"\"...\n\n...\"\"\"\nf(x, y) = ...\nThis makes it more clear where docstrings start and end.\nRespect the line length limit used in the surrounding code.\nDocstrings are edited using the same tools as code. Therefore, the same conventions should apply. It is advised to add line breaks after 92 characters.\nProvide information allowing custom types to implement the function in an # Implementation section. These implementation details intended for developers rather than users, explaining e.g. which functions should be overridden and which functions automatically use appropriate fallbacks, are better kept separate from the main description of the function's behavior.","category":"page"},{"location":"manual/documentation.html#ドキュメントへのアクセス-1","page":"ドキュメンテーション","title":"ドキュメントへのアクセス","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Documentation can be accessed at the REPL or in IJulia  by typing ? followed by the name of a function or macro, and pressing Enter. For example,","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"?cos\n?@time\n?r\"\"","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"will bring up docs for the relevant function, macro or string macro respectively. In Juno  using Ctrl-J, Ctrl-D will bring up documentation for the object under the cursor.","category":"page"},{"location":"manual/documentation.html#関数とメソッド-1","page":"ドキュメンテーション","title":"関数とメソッド","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Functions in Julia may have multiple implementations, known as methods. While it's good practice for generic functions to have a single purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or even the function itself (i.e. the object created without any methods by function bar end). Specific methods should only be documented if their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"\"\"\n    *(x, y, z...)\n\nMultiplication operator. `x * y * z *...` calls this function with multiple\narguments, i.e. `*(x, y, z...)`.\n\"\"\"\nfunction *(x, y, z...)\n    # ... [implementation sold separately] ...\nend\n\n\"\"\"\n    *(x::AbstractString, y::AbstractString, z::AbstractString...)\n\nWhen applied to strings, concatenates them.\n\"\"\"\nfunction *(x::AbstractString, y::AbstractString, z::AbstractString...)\n    # ... [insert secret sauce here] ...\nend\n\nhelp?> *\nsearch: * .*\n\n  *(x, y, z...)\n\n  Multiplication operator. x * y * z *... calls this function with multiple\n  arguments, i.e. *(x,y,z...).\n\n  *(x::AbstractString, y::AbstractString, z::AbstractString...)\n\n  When applied to strings, concatenates them.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"When retrieving documentation for a generic function, the metadata for each method is concatenated with the catdoc function, which can of course be overridden for custom types.","category":"page"},{"location":"manual/documentation.html#高度な使い方-1","page":"ドキュメンテーション","title":"高度な使い方","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"The @doc macro associates its first argument with its second in a per-module dictionary called META. By default, documentation is expected to be written in Markdown, and the doc\"\" string macro simply creates an object representing the Markdown content. In the future it is likely to do more advanced things such as allowing for relative image or link paths.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"To make it easier to write documentation, the parser treats the macro name @doc specially: if a call to @doc has one argument, but another expression appears after a single line break, then that additional expression is added as an argument to the macro.  Therefore the following syntax is parsed as a 2-argument call to @doc:","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"@doc raw\"\"\"\n...\n\"\"\"\nf(x) = x","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"This makes it easy to use an arbitrary object (here a raw string) as a docstring.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"When used for retrieving documentation, the @doc macro (or equally, the doc function) will search all META dictionaries for metadata relevant to the given object and return it. The returned object (some Markdown content, for example) will by default display itself intelligently. This design also makes it easy to use the doc system in a programmatic way; for example, to re-use documentation between different versions of a function:","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"@doc \"...\" foo!\n@doc (@doc foo!) foo","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Or for use with Julia's metaprogramming functionality:","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))\n    @eval begin\n        $f(a,b) = $op(a,b)\n    end\nend\n@doc \"`add(a,b)` adds `a` and `b` together\" add\n@doc \"`subtract(a,b)` subtracts `b` from `a`\" subtract","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Documentation written in non-toplevel blocks, such as begin, if, for, and let, is added to the documentation system as blocks are evaluated. For example:","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"if condition()\n    \"...\"\n    f(x) = x\nend","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"will add documentation to f(x) when condition() is true. Note that even if f(x) goes out of scope at the end of the block, its documentation will remain.","category":"page"},{"location":"manual/documentation.html#動的ドキュメント-1","page":"ドキュメンテーション","title":"動的ドキュメント","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Sometimes the appropriate documentation for an instance of a type depends on the field values of that instance, rather than just on the type itself. In these cases, you can add a method to Docs.getdoc for your custom type that returns the documentation on a per-instance basis. For instance,","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"struct MyType\n    value::String\nend\n\nDocs.getdoc(t::MyType) = \"Documentation for MyType with value $(t.value)\"\n\nx = MyType(\"x\")\ny = MyType(\"y\")","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"?x will display \"Documentation for MyType with value x\" while ?y will display \"Documentation for MyType with value y\".","category":"page"},{"location":"manual/documentation.html#構文ガイド-1","page":"ドキュメンテーション","title":"構文ガイド","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"A comprehensive overview of all documentable Julia syntax.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"In the following examples \"...\" is used to illustrate an arbitrary docstring.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"doc\"\" should only be used when the docstring contains $ or \\ characters that should not be parsed by Julia such as LaTeX syntax or Julia source code examples containing interpolation.","category":"page"},{"location":"manual/documentation.html#関数とメソッド-2","page":"ドキュメンテーション","title":"関数とメソッド","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\nfunction f end\n\n\"...\"\nf","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Adds docstring \"...\" to the function f. The first version is the preferred syntax, however both are equivalent.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\nf(x) = x\n\n\"...\"\nfunction f(x)\n    x\nend\n\n\"...\"\nf(x)","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Adds docstring \"...\" to the method f(::Any).","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\nf(x, y = 1) = x + y","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Adds docstring \"...\" to two Methods, namely f(::Any) and f(::Any, ::Any).","category":"page"},{"location":"manual/documentation.html#マクロ-1","page":"ドキュメンテーション","title":"マクロ","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\nmacro m(x) end","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Adds docstring \"...\" to the @m(::Any) macro definition.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\n:(@m)","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Adds docstring \"...\" to the macro named @m.","category":"page"},{"location":"manual/documentation.html#型-1","page":"ドキュメンテーション","title":"型","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\nabstract type T1 end\n\n\"...\"\nmutable struct T2\n    ...\nend\n\n\"...\"\nstruct T3\n    ...\nend","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Adds the docstring \"...\" to types T1, T2, and T3.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\nstruct T\n    \"x\"\n    x\n    \"y\"\n    y\nend","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Adds docstring \"...\" to type T, \"x\" to field T.x and \"y\" to field T.y. Also applicable to mutable struct types.","category":"page"},{"location":"manual/documentation.html#モジュール-1","page":"ドキュメンテーション","title":"モジュール","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\nmodule M end\n\nmodule M\n\n\"...\"\nM\n\nend","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Adds docstring \"...\" to the ModuleM. Adding the docstring above the Module is the preferred syntax, however both are equivalent.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\nbaremodule M\n# ...\nend\n\nbaremodule M\n\nimport Base: @doc\n\n\"...\"\nf(x) = x\n\nend","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Documenting a baremodule by placing a docstring above the expression automatically imports @doc into the module. These imports must be done manually when the module expression is not documented. Empty baremodules cannot be documented.","category":"page"},{"location":"manual/documentation.html#グローバル変数-1","page":"ドキュメンテーション","title":"グローバル変数","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\nconst a = 1\n\n\"...\"\nb = 2\n\n\"...\"\nglobal c = 3","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Adds docstring \"...\" to the Bindings a, b, and c.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Bindings are used to store a reference to a particular Symbol in a Module without storing the referenced value itself.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"note: Note\nWhen a const definition is only used to define an alias of another definition, such as is the case with the function div and its alias ÷ in Base, do not document the alias and instead document the actual function.If the alias is documented and not the real definition then the docsystem (? mode) will not return the docstring attached to the alias when the real definition is searched for.For example you should write\"...\"\nf(x) = x + 1\nconst alias = frather thanf(x) = x + 1\n\"...\"\nconst alias = f","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\nsym","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Adds docstring \"...\" to the value associated with sym. Users should prefer documenting sym at its definition.","category":"page"},{"location":"manual/documentation.html#Multiple-Objects-1","page":"ドキュメンテーション","title":"Multiple Objects","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\na, b","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Adds docstring \"...\" to a and b each of which should be a documentable expression. This syntax is equivalent to","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\na\n\n\"...\"\nb","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Any number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions f and f!.","category":"page"},{"location":"manual/documentation.html#Macro-generated-code-1","page":"ドキュメンテーション","title":"Macro-generated code","text":"","category":"section"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"\"...\"\n@m expression","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Adds docstring \"...\" to expression generated by expanding @m expression. This allows for expressions decorated with @inline, @noinline, @generated, or any other macro to be documented in the same way as undecorated expressions.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Macro authors should take note that only macros that generate a single expression will automatically support docstrings. If a macro returns a block containing multiple subexpressions then the subexpression that should be documented must be marked using the @__doc__ macro.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"The @enum macro makes use of @__doc__ to allow for documenting Enums.  Examining its definition should serve as an example of how to use @__doc__ correctly.","category":"page"},{"location":"manual/documentation.html#","page":"ドキュメンテーション","title":"ドキュメンテーション","text":"Core.@__doc__","category":"page"},{"location":"manual/documentation.html#Core.@__doc__","page":"ドキュメンテーション","title":"Core.@__doc__","text":"@__doc__(ex)\n\nLow-level macro used to mark expressions returned by a macro that should be documented. If more than one expression is marked then the same docstring is applied to each expression.\n\nmacro example(f)\n    quote\n        $(f)() = 0\n        @__doc__ $(f)(x) = 1\n        $(f)(x, y) = 2\n    end |> esc\nend\n\n@__doc__ has no effect when a macro that uses it is not documented.\n\n\n\n\n\n","category":"macro"},{"location":"manual/metaprogramming.html#Metaprogramming-1","page":"メタプログラミング","title":"メタプログラミング","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style macros operating at the level of abstract syntax trees.  In contrast, preprocessor \"macro\" systems, like that of C and C++, perform textual manipulation and substitution before any actual parsing or interpretation occurs. Because all data types and code in Julia are represented by Julia data structures, powerful reflection capabilities are available to explore the internals of a program and its types just like any other data.","category":"page"},{"location":"manual/metaprogramming.html#Program-representation-1","page":"メタプログラミング","title":"プログラムの表現","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Every Julia program starts life as a string:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> prog = \"1 + 1\"\n\"1 + 1\"","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"What happens next?","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The next step is to parse each string into an object called an expression, represented by the Julia type Expr:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> ex1 = Meta.parse(prog)\n:(1 + 1)\n\njulia> typeof(ex1)\nExpr","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Expr objects contain two parts:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"a Symbol identifying the kind of expression. A symbol is an interned string identifier (more discussion below).","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> ex1.head\n:call","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"the expression arguments, which may be symbols, other expressions, or literal values:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> ex1.args\n3-element Array{Any,1}:\n  :+\n 1\n 1","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Expressions may also be constructed directly in prefix notation:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> ex2 = Expr(:call, :+, 1, 1)\n:(1 + 1)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The two expressions constructed above – by parsing and by direct construction – are equivalent:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> ex1 == ex2\ntrue","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The key point here is that Julia code is internally represented as a data structure that is accessible from the language itself.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The dump function provides indented and annotated display of Expr objects:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> dump(ex2)\nExpr\n  head: Symbol call\n  args: Array{Any}((3,))\n    1: Symbol +\n    2: Int64 1\n    3: Int64 1","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Expr objects may also be nested:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> ex3 = Meta.parse(\"(4 + 4) / 2\")\n:((4 + 4) / 2)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Another way to view expressions is with Meta.show_sexpr, which displays the S-expression  form of a given Expr, which may look very familiar to users of Lisp. Here's an example illustrating the display on a nested Expr:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> Meta.show_sexpr(ex3)\n(:call, :/, (:call, :+, 4, 4), 2)","category":"page"},{"location":"manual/metaprogramming.html#Symbols-1","page":"メタプログラミング","title":"Symbols","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The : character has two syntactic purposes in Julia. The first form creates a Symbol, an interned string used as one building-block of expressions:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> :foo\n:foo\n\njulia> typeof(ans)\nSymbol","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The Symbol constructor takes any number of arguments and creates a new symbol by concatenating their string representations together:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> :foo == Symbol(\"foo\")\ntrue\n\njulia> Symbol(\"func\",10)\n:func10\n\njulia> Symbol(:var,'_',\"sym\")\n:var_sym","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate scope.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Sometimes extra parentheses around the argument to : are needed to avoid ambiguity in parsing:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> :(:)\n:(:)\n\njulia> :(::)\n:(::)","category":"page"},{"location":"manual/metaprogramming.html#Expressions-and-evaluation-1","page":"メタプログラミング","title":"Expressions and evaluation","text":"","category":"section"},{"location":"manual/metaprogramming.html#Quoting-1","page":"メタプログラミング","title":"Quoting","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The second syntactic purpose of the : character is to create expression objects without using the explicit Expr constructor. This is referred to as quoting. The : character, followed by paired parentheses around a single statement of Julia code, produces an Expr object based on the enclosed code. Here is example of the short form used to quote an arithmetic expression:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> ex = :(a+b*c+1)\n:(a + b * c + 1)\n\njulia> typeof(ex)\nExpr","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"(to view the structure of this expression, try ex.head and ex.args, or use dump  as above or Meta.@dump)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Note that equivalent expressions may be constructed using Meta.parse or the direct Expr form:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia>      :(a + b*c + 1)       ==\n       Meta.parse(\"a + b*c + 1\") ==\n       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)\ntrue","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Expressions provided by the parser generally only have symbols, other expressions, and literal values as their args, whereas expressions constructed by Julia code can have arbitrary run-time values without literal forms as args. In this specific example, + and a are symbols, *(b,c) is a subexpression, and 1 is a literal 64-bit signed integer.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"There is a second syntactic form of quoting for multiple expressions: blocks of code enclosed in quote ... end.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> ex = quote\n           x = 1\n           y = 2\n           x + y\n       end\nquote\n    #= none:2 =#\n    x = 1\n    #= none:3 =#\n    y = 2\n    #= none:4 =#\n    x + y\nend\n\njulia> typeof(ex)\nExpr","category":"page"},{"location":"manual/metaprogramming.html#Interpolation-1","page":"メタプログラミング","title":"Interpolation","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Direct construction of Expr objects with value arguments is powerful, but Expr constructors can be tedious compared to \"normal\" Julia syntax. As an alternative, Julia allows interpolation of literals or expressions into quoted expressions. Interpolation is indicated by a prefix $.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"In this example, the value of variable a is interpolated:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> a = 1;\n\njulia> ex = :($a + b)\n:(1 + b)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Interpolating into an unquoted expression is not supported and will cause a compile-time error:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> $a + b\nERROR: syntax: \"$\" expression outside quote","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"In this example, the tuple (1,2,3) is interpolated as an expression into a conditional test:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> ex = :(a in $:((1,2,3)) )\n:(a in (1, 2, 3))","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The use of $ for expression interpolation is intentionally reminiscent of string interpolation  and command interpolation. Expression interpolation allows convenient, readable programmatic construction of complex Julia expressions.","category":"page"},{"location":"manual/metaprogramming.html#Splatting-interpolation-1","page":"メタプログラミング","title":"Splatting interpolation","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Notice that the $ interpolation syntax allows inserting only a single expression into an enclosing expression.  Occasionally, you have an array of expressions and need them all to become arguments of the surrounding expression.  This can be done with the syntax $(xs...).  For example, the following code generates a function call where the number of arguments is determined programmatically:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> args = [:x, :y, :z];\n\njulia> :(f(1, $(args...)))\n:(f(1, x, y, z))","category":"page"},{"location":"manual/metaprogramming.html#Nested-quote-1","page":"メタプログラミング","title":"Nested quote","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Naturally, it is possible for quote expressions to contain other quote expressions.  Understanding how interpolation works in these cases can be a bit tricky.  Consider this example:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> x = :(1 + 2);\n\njulia> e = quote quote $x end end\nquote\n    #= none:1 =#\n    $(Expr(:quote, quote\n    #= none:1 =#\n    $(Expr(:$, :x))\nend))\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Notice that the result contains Expr(:$, :x), which means that x has not been evaluated yet.  In other words, the $ expression \"belongs to\" the inner quote expression, and so its argument is only evaluated when the inner quote expression is:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> eval(e)\nquote\n    #= none:1 =#\n    1 + 2\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"However, the outer quote expression is able to interpolate values inside the $ in the inner quote.  This is done with multiple $s:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> e = quote quote $$x end end\nquote\n    #= none:1 =#\n    $(Expr(:quote, quote\n    #= none:1 =#\n    $(Expr(:$, :(1 + 2)))\nend))\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Notice that :(1 + 2) now appears in the result instead of the symbol :x.  Evaluating this expression yields an interpolated 3:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> eval(e)\nquote\n    #= none:1 =#\n    3\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The intuition behind this behavior is that x is evaluated once for each $: one $ works similarly to eval(:x), giving x's value, while two $s do the equivalent of eval(eval(:x)).","category":"page"},{"location":"manual/metaprogramming.html#QuoteNode-1","page":"メタプログラミング","title":"QuoteNode","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The usual representation of a quote form in an AST is an Expr with head :quote:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> dump(Meta.parse(\":(1+2)\"))\nExpr\n  head: Symbol quote\n  args: Array{Any}((1,))\n    1: Expr\n      head: Symbol call\n      args: Array{Any}((3,))\n        1: Symbol +\n        2: Int64 1\n        3: Int64 2","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"As we have seen, such expressions support interpolation with $.  However, in some situations it is necessary to quote code without performing interpolation.  This kind of quoting does not yet have syntax, but is represented internally as an object of type QuoteNode.  The parser yields QuoteNodes for simple quoted items like symbols:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> dump(Meta.parse(\":x\"))\nQuoteNode\n  value: Symbol x","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"QuoteNode can also be used for certain advanced metaprogramming tasks.","category":"page"},{"location":"manual/metaprogramming.html#[eval](@ref)-and-effects-1","page":"メタプログラミング","title":"eval and effects","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Given an expression object, one can cause Julia to evaluate (execute) it at global scope using eval:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> :(1 + 2)\n:(1 + 2)\n\njulia> eval(ans)\n3\n\njulia> ex = :(a + b)\n:(a + b)\n\njulia> eval(ex)\nERROR: UndefVarError: b not defined\n[...]\n\njulia> a = 1; b = 2;\n\njulia> eval(ex)\n3","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Every module has its own eval function that evaluates expressions in its global scope. Expressions passed to eval are not limited to returning values – they can also have side-effects that alter the state of the enclosing module's environment:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> ex = :(x = 1)\n:(x = 1)\n\njulia> x\nERROR: UndefVarError: x not defined\n\njulia> eval(ex)\n1\n\njulia> x\n1","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Here, the evaluation of an expression object causes a value to be assigned to the global variable x.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Since expressions are just Expr objects which can be constructed programmatically and then evaluated, it is possible to dynamically generate arbitrary code which can then be run using eval.  Here is a simple example:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> a = 1;\n\njulia> ex = Expr(:call, :+, a, :b)\n:(1 + b)\n\njulia> a = 0; b = 2;\n\njulia> eval(ex)\n3","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The value of a is used to construct the expression ex which applies the + function to the value 1 and the variable b. Note the important distinction between the way a and b are used:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The value of the variable a at expression construction time is used as an immediate value in the expression. Thus, the value of a when the expression is evaluated no longer matters: the value in the expression is already 1, independent of whatever the value of a might be.\nOn the other hand, the symbol :b is used in the expression construction, so the value of the variable b at that time is irrelevant – :b is just a symbol and the variable b need not even be defined. At expression evaluation time, however, the value of the symbol :b is resolved by looking up the value of the variable b.","category":"page"},{"location":"manual/metaprogramming.html#Functions-on-Expressions-1","page":"メタプログラミング","title":"Functions on Expressions","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have already seen one example of a function returning Expr  objects: the parse function, which takes a string of Julia code and returns the corresponding Expr. A function can also take one or more Expr objects as arguments, and return another Expr. Here is a simple, motivating example:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> function math_expr(op, op1, op2)\n           expr = Expr(:call, op, op1, op2)\n           return expr\n       end\nmath_expr (generic function with 1 method)\n\njulia>  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))\n:(1 + 4 * 5)\n\njulia> eval(ex)\n21","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"As another example, here is a function that doubles any numeric argument, but leaves expressions alone:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> function make_expr2(op, opr1, opr2)\n           opr1f, opr2f = map(x -> isa(x, Number) ? 2*x : x, (opr1, opr2))\n           retexpr = Expr(:call, op, opr1f, opr2f)\n           return retexpr\n       end\nmake_expr2 (generic function with 1 method)\n\njulia> make_expr2(:+, 1, 2)\n:(2 + 4)\n\njulia> ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))\n:(2 + 5 * 8)\n\njulia> eval(ex)\n42","category":"page"},{"location":"manual/metaprogramming.html#man-macros-1","page":"メタプログラミング","title":"Macros","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Macros provide a method to include generated code in the final body of a program. A macro maps a tuple of arguments to a returned expression, and the resulting expression is compiled directly rather than requiring a runtime eval call. Macro arguments may include expressions, literal values, and symbols.","category":"page"},{"location":"manual/metaprogramming.html#Basics-1","page":"メタプログラミング","title":"Basics","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Here is an extraordinarily simple macro:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> macro sayhello()\n           return :( println(\"Hello, world!\") )\n       end\n@sayhello (macro with 1 method)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Macros have a dedicated character in Julia's syntax: the @ (at-sign), followed by the unique name declared in a macro NAME ... end block. In this example, the compiler will replace all instances of @sayhello with:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":":( println(\"Hello, world!\") )","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"When @sayhello is entered in the REPL, the expression executes immediately, thus we only see the evaluation result:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> @sayhello()\nHello, world!","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Now, consider a slightly more complex macro:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> macro sayhello(name)\n           return :( println(\"Hello, \", $name) )\n       end\n@sayhello (macro with 1 method)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"This macro takes one argument: name. When @sayhello is encountered, the quoted expression is expanded to interpolate the value of the argument into the final expression:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> @sayhello(\"human\")\nHello, human","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"We can view the quoted return expression using the function macroexpand (important note: this is an extremely useful tool for debugging macros):","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> ex = macroexpand(Main, :(@sayhello(\"human\")) )\n:(Main.println(\"Hello, \", \"human\"))\n\njulia> typeof(ex)\nExpr","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"We can see that the \"human\" literal has been interpolated into the expression.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"There also exists a macro @macroexpand that is perhaps a bit more convenient than the macroexpand function:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> @macroexpand @sayhello \"human\"\n:(println(\"Hello, \", \"human\"))","category":"page"},{"location":"manual/metaprogramming.html#Hold-up:-why-macros?-1","page":"メタプログラミング","title":"Hold up: why macros?","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"We have already seen a function f(::Expr...) -> Expr in a previous section. In fact, macroexpand is also such a function. So, why do macros exist?","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Macros are necessary because they execute when code is parsed, therefore, macros allow the programmer to generate and include fragments of customized code before the full program is run. To illustrate the difference, consider the following example:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> macro twostep(arg)\n           println(\"I execute at parse time. The argument is: \", arg)\n           return :(println(\"I execute at runtime. The argument is: \", $arg))\n       end\n@twostep (macro with 1 method)\n\njulia> ex = macroexpand(Main, :(@twostep :(1, 2, 3)) );\nI execute at parse time. The argument is: $(Expr(:quote, :((1, 2, 3))))","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The first call to println is executed when macroexpand is called. The resulting expression contains only the second println:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> typeof(ex)\nExpr\n\njulia> ex\n:(println(\"I execute at runtime. The argument is: \", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))\n\njulia> eval(ex)\nI execute at runtime. The argument is: (1, 2, 3)","category":"page"},{"location":"manual/metaprogramming.html#Macro-invocation-1","page":"メタプログラミング","title":"Macro invocation","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Macros are invoked with the following general syntax:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"@name expr1 expr2 ...\n@name(expr1, expr2, ...)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Note the distinguishing @ before the macro name and the lack of commas between the argument expressions in the first form, and the lack of whitespace after @name in the second form. The two styles should not be mixed. For example, the following syntax is different from the examples above; it passes the tuple (expr1, expr2, ...) as one argument to the macro:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"@name (expr1, expr2, ...)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"An alternative way to invoke a macro over an array literal (or comprehension) is to juxtapose both without using parentheses. In this case, the array will be the only expression fed to the macro. The following syntax is equivalent (and different from @name [a b] * v):","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"@name[a b] * v\n@name([a b]) * v","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"It is important to emphasize that macros receive their arguments as expressions, literals, or symbols. One way to explore macro arguments is to call the show function within the macro body:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> macro showarg(x)\n           show(x)\n           # ... remainder of macro, returning an expression\n       end\n@showarg (macro with 1 method)\n\njulia> @showarg(a)\n:a\n\njulia> @showarg(1+1)\n:(1 + 1)\n\njulia> @showarg(println(\"Yo!\"))\n:(println(\"Yo!\"))","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"In addition to the given argument list, every macro is passed extra arguments named __source__ and __module__.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The argument __source__ provides information (in the form of a LineNumberNode object) about the parser location of the @ sign from the macro invocation.  This allows macros to include better error diagnostic information, and is commonly used by logging, string-parser macros, and docs, for example, as well as to implement the @__LINE__, @__FILE__, and @__DIR__ macros.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The location information can be accessed by referencing __source__.line and __source__.file:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> macro __LOCATION__(); return QuoteNode(__source__); end\n@__LOCATION__ (macro with 1 method)\n\njulia> dump(\n            @__LOCATION__(\n       ))\nLineNumberNode\n  line: Int64 2\n  file: Symbol none","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The argument __module__ provides information (in the form of a Module object)  about the expansion context of the macro invocation.  This allows macros to look up contextual information, such as existing bindings, or to insert the value as an extra argument to a runtime function call doing self-reflection in the current module.","category":"page"},{"location":"manual/metaprogramming.html#Building-an-advanced-macro-1","page":"メタプログラミング","title":"Building an advanced macro","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Here is a simplified definition of Julia's @assert macro:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> macro assert(ex)\n           return :( $ex ? nothing : throw(AssertionError($(string(ex)))) )\n       end\n@assert (macro with 1 method)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"This macro can be used like this:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> @assert 1 == 1.0\n\njulia> @assert 1 == 0\nERROR: AssertionError: 1 == 0","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"In place of the written syntax, the macro call is expanded at parse time to its returned result.  This is equivalent to writing:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"1 == 1.0 ? nothing : throw(AssertionError(\"1 == 1.0\"))\n1 == 0 ? nothing : throw(AssertionError(\"1 == 0\"))","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"That is, in the first call, the expression :(1 == 1.0) is spliced into the test condition slot, while the value of string(:(1 == 1.0)) is spliced into the assertion message slot. The entire expression, thus constructed, is placed into the syntax tree where the @assert macro call occurs.  Then at execution time, if the test expression evaluates to true, then nothing is returned, whereas if the test is false, an error is raised indicating the asserted expression that was false.  Notice that it would not be possible to write this as a function, since only the value of the condition is available and it would be impossible to display the expression that computed it in the error message.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The actual definition of @assert in Julia Base is more complicated. It allows the user to optionally specify their own error message, instead of just printing the failed expression.  Just like in functions with a variable number of arguments (Varargs Functions), this is specified with an ellipses following the last argument:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> macro assert(ex, msgs...)\n           msg_body = isempty(msgs) ? ex : msgs[1]\n           msg = string(msg_body)\n           return :($ex ? nothing : throw(AssertionError($msg)))\n       end\n@assert (macro with 1 method)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Now @assert has two modes of operation, depending upon the number of arguments it receives! If there's only one argument, the tuple of expressions captured by msgs will be empty and it will behave the same as the simpler definition above. But now if the user specifies a second argument, it is printed in the message body instead of the failing expression. You can inspect the result of a macro expansion with the aptly named @macroexpand macro:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> @macroexpand @assert a == b\n:(if Main.a == Main.b\n        Main.nothing\n    else\n        Main.throw(Main.AssertionError(\"a == b\"))\n    end)\n\njulia> @macroexpand @assert a==b \"a should equal b!\"\n:(if Main.a == Main.b\n        Main.nothing\n    else\n        Main.throw(Main.AssertionError(\"a should equal b!\"))\n    end)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"There is yet another case that the actual @assert macro handles: what if, in addition to printing \"a should equal b,\" we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., @assert a==b \"a ($a) should equal b ($b)!\", but this won't work as expected with the above macro. Can you see why? Recall from string interpolation that an interpolated string is rewritten to a call to string. Compare:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> typeof(:(\"a should equal b\"))\nString\n\njulia> typeof(:(\"a ($a) should equal b ($b)!\"))\nExpr\n\njulia> dump(:(\"a ($a) should equal b ($b)!\"))\nExpr\n  head: Symbol string\n  args: Array{Any}((5,))\n    1: String \"a (\"\n    2: Symbol a\n    3: String \") should equal b (\"\n    4: Symbol b\n    5: String \")!\"","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"So now instead of getting a plain string in msg_body, the macro is receiving a full expression that will need to be evaluated in order to display as expected. This can be spliced directly into the returned expression as an argument to the string call; see error.jl for the complete implementation.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The @assert macro makes great use of splicing into quoted expressions to simplify the manipulation of expressions inside the macro body.","category":"page"},{"location":"manual/metaprogramming.html#Hygiene-1","page":"メタプログラミング","title":"Hygiene","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"An issue that arises in more complex macros is that of hygiene.  In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often expected to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as msg in @assert above) follow the normal scoping block behavior.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"To demonstrate these issues, let us consider writing a @time macro that takes an expression as its argument, records the time, evaluates the expression, records the time again, prints the difference between the before and after times, and then has the value of the expression as its final value. The macro might look like this:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"macro time(ex)\n    return quote\n        local t0 = time()\n        local val = $ex\n        local t1 = time()\n        println(\"elapsed time: \", t1-t0, \" seconds\")\n        val\n    end\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Here, we want t0, t1, and val to be private temporary variables, and we want time to refer to the time function in Julia Base, not to any time variable the user might have (the same applies to println). Imagine the problems that could occur if the user expression ex also contained assignments to a variable called t0, or defined its own time variable. We might get errors, or mysteriously incorrect behavior.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Julia's macro expander solves these problems in the following way. First, variables within a macro result are classified as either local or global. A variable is considered local if it is assigned to (and not declared global), declared local, or used as a function argument name. Otherwise, it is considered global. Local variables are then renamed to be unique (using the gensym  function, which generates new symbols), and global variables are resolved within the macro definition environment. Therefore both of the above concerns are handled; the macro's locals will not conflict with any user variables, and time and println will refer to the Julia Base definitions.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"One problem remains however. Consider the following use of this macro:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"module MyModule\nimport Base.@time\n\ntime() = ... # compute something\n\n@time time()\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Here the user expression ex is a call to time, but not the same time function that the macro uses. It clearly refers to MyModule.time. Therefore we must arrange for the code in ex to be resolved in the macro call environment. This is done by \"escaping\" the expression with esc:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"macro time(ex)\n    ...\n    local val = $(esc(ex))\n    ...\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be resolved in the macro call environment.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"This escaping mechanism can be used to \"violate\" hygiene when necessary, in order to introduce or manipulate user variables. For example, the following macro sets x to zero in the call environment:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> macro zerox()\n           return esc(:(x = 0))\n       end\n@zerox (macro with 1 method)\n\njulia> function foo()\n           x = 1\n           @zerox\n           return x # is zero\n       end\nfoo (generic function with 1 method)\n\njulia> foo()\n0","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"This kind of manipulation of variables should be used judiciously, but is occasionally quite handy.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Getting the hygiene rules correct can be a formidable challenge. Before using a macro, you might want to consider whether a function closure would be sufficient. Another useful strategy is to defer as much work as possible to runtime. For example, many macros simply wrap their arguments in a QuoteNode or other similar Expr. Some examples of this include @task body which simply returns schedule(Task(() -> $body)), and @eval expr, which simply returns eval(QuoteNode(expr)).","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"To demonstrate, we might rewrite the @time example above as:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"macro time(expr)\n    return :(timeit(() -> $(esc(expr))))\nend\nfunction timeit(f)\n    t0 = time()\n    val = f()\n    t1 = time()\n    println(\"elapsed time: \", t1-t0, \" seconds\")\n    return val\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"However, we don't do this for a good reason: wrapping the expr in a new scope block (the anonymous function)  also slightly changes the meaning of the expression (the scope of any variables in it), while we want @time to be usable with minimum impact on the wrapped code.","category":"page"},{"location":"manual/metaprogramming.html#Macros-and-dispatch-1","page":"メタプログラミング","title":"Macros and dispatch","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Macros, just like Julia functions, are generic. This means they can also have multiple method definitions, thanks to multiple dispatch:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> macro m end\n@m (macro with 0 methods)\n\njulia> macro m(args...)\n           println(\"$(length(args)) arguments\")\n       end\n@m (macro with 1 method)\n\njulia> macro m(x,y)\n           println(\"Two arguments\")\n       end\n@m (macro with 2 methods)\n\njulia> @m \"asd\"\n1 arguments\n\njulia> @m 1 2\nTwo arguments","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"However one should keep in mind, that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST evaluates to at runtime:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> macro m(::Int)\n           println(\"An Integer\")\n       end\n@m (macro with 3 methods)\n\njulia> @m 2\nAn Integer\n\njulia> x = 2\n2\n\njulia> @m x\n1 arguments","category":"page"},{"location":"manual/metaprogramming.html#Code-Generation-1","page":"メタプログラミング","title":"Code Generation","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"When a significant amount of repetitive boilerplate code is required, it is common to generate it programmatically to avoid redundancy. In most languages, this requires an extra build step, and a separate program to generate the repetitive code. In Julia, expression interpolation and eval allow such code generation to take place in the normal course of program execution.  For example, consider the following custom type","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"struct MyNumber\n    x::Float64\nend\n# output\n","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"for which we want to add a number of methods to. We can do this programmatically in the following loop:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"for op = (:sin, :cos, :tan, :log, :exp)\n    eval(quote\n        Base.$op(a::MyNumber) = MyNumber($op(a.x))\n    end)\nend\n# output\n","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"and we can now use those functions with our custom type:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> x = MyNumber(π)\nMyNumber(3.141592653589793)\n\njulia> sin(x)\nMyNumber(1.2246467991473532e-16)\n\njulia> cos(x)\nMyNumber(-1.0)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"In this manner, Julia acts as its own preprocessor, and allows code generation from inside the language. The above code could be written slightly more tersely using the : prefix quoting form:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"for op = (:sin, :cos, :tan, :log, :exp)\n    eval(:(Base.$op(a::MyNumber) = MyNumber($op(a.x))))\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"This sort of in-language code generation, however, using the eval(quote(...)) pattern, is common enough that Julia comes with a macro to abbreviate this pattern:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"for op = (:sin, :cos, :tan, :log, :exp)\n    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The @eval macro rewrites this call to be precisely equivalent to the above longer versions.  For longer blocks of generated code, the expression argument given to @eval can be a block:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"@eval begin\n    # multiple lines\nend","category":"page"},{"location":"manual/metaprogramming.html#Non-Standard-String-Literals-1","page":"メタプログラミング","title":"Non-Standard String Literals","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Recall from Strings that string literals prefixed by an identifier are called non-standard string literals, and can have different semantics than un-prefixed string literals. For example:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"r\"^\\s*(?:#|$)\" produces a regular expression object rather than a string\nb\"DATA\\xff\\u2200\" is a byte array literal for [68,65,84,65,255,226,136,128].","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Perhaps surprisingly, these behaviors are not hard-coded into the Julia parser or compiler. Instead, they are custom behaviors provided by a general mechanism that anyone can use: prefixed string literals are parsed as calls to specially-named macros. For example, the regular expression macro is just the following:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"macro r_str(p)\n    Regex(p)\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"That's all. This macro says that the literal contents of the string literal r\"^\\s*(?:#|$)\" should be passed to the @r_str macro and the result of that expansion should be placed in the syntax tree where the string literal occurs. In other words, the expression r\"^\\s*(?:#|$)\" is equivalent to placing the following object directly into the syntax tree:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Regex(\"^\\\\s*(?:#|\\$)\")","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Not only is the string literal form shorter and far more convenient, but it is also more efficient: since the regular expression is compiled and the Regex object is actually created when the code is compiled, the compilation occurs only once, rather than every time the code is executed. Consider if the regular expression occurs in a loop:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"for line = lines\n    m = match(r\"^\\s*(?:#|$)\", line)\n    if m === nothing\n        # non-comment\n    else\n        # comment\n    end\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Since the regular expression r\"^\\s*(?:#|$)\" is compiled and inserted into the syntax tree when this code is parsed, the expression is only compiled once instead of each time the loop is executed.  In order to accomplish this without macros, one would have to write this loop like this:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"re = Regex(\"^\\\\s*(?:#|\\$)\")\nfor line = lines\n    m = match(re, line)\n    if m === nothing\n        # non-comment\n    else\n        # comment\n    end\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Moreover, if the compiler could not determine that the regex object was constant over all loops, certain optimizations might not be possible, making this version still less efficient than the more convenient literal form above. Of course, there are still situations where the non-literal form is more convenient: if one needs to interpolate a variable into the regular expression, one must take this more verbose approach; in cases where the regular expression pattern itself is dynamic, potentially changing upon each loop iteration, a new regular expression object must be constructed on each iteration. In the vast majority of use cases, however, regular expressions are not constructed based on run-time data. In this majority of cases, the ability to write regular expressions as compile-time values is invaluable.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Like non-standard string literals, non-standard command literals exist using a prefixed variant of the command literal syntax. The command literal custom`literal` is parsed as @custom_cmd \"literal\".  Julia itself does not contain any non-standard command literals, but packages can make use of this syntax. Aside from the different syntax and the _cmd suffix instead of the _str suffix, non-standard command literals behave exactly like non-standard string literals.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"In the event that two modules provide non-standard string or command literals with the same name, it is possible to qualify the string or command literal with a module name. For instance, if both Foo and Bar provide non-standard string literal @x_str, then one can write Foo.x\"literal\" or Bar.x\"literal\" to disambiguate between the two.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The mechanism for user-defined string literals is deeply, profoundly powerful. Not only are Julia's non-standard literals implemented using it, but also the command literal syntax (`echo \"Hello, $person\"`)  is implemented with the following innocuous-looking macro:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"macro cmd(str)\n    :(cmd_gen($(shell_parse(str)[1])))\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Of course, a large amount of complexity is hidden in the functions used in this macro definition, but they are just functions, written entirely in Julia. You can read their source and see precisely what they do – and all they do is construct expression objects to be inserted into your program's syntax tree.","category":"page"},{"location":"manual/metaprogramming.html#Generated-functions-1","page":"メタプログラミング","title":"Generated functions","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"A very special macro is @generated, which allows you to define so-called generated functions.  These have the capability to generate specialized code depending on the types of their arguments with more flexibility and/or less code than what can be achieved with multiple dispatch. While macros work with expressions at parse time and cannot access the types of their inputs, a generated function gets expanded at a time when the types of the arguments are known, but the function is not yet compiled.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Instead of performing some calculation or action, a generated function declaration returns a quoted expression which then forms the body for the method corresponding to the types of the arguments.  When a generated function is called, the expression it returns is compiled and then run.  To make this efficient, the result is usually cached. And to make this inferable, only a limited subset of the language is usable. Thus, generated functions provide a flexible way to move work from run time to compile time, at the expense of greater restrictions on allowed constructs.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"When defining generated functions, there are four main differences to ordinary functions:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"You annotate the function declaration with the @generated macro. This adds some information to the AST that lets the compiler know that this is a generated function.\nIn the body of the generated function you only have access to the types of the arguments – not their values – and any function that was defined before the definition of the generated function.\nInstead of calculating something or performing some action, you return a quoted expression which, when evaluated, does what you want.\nGenerated functions must not mutate or observe any non-constant global state (including, for example, IO, locks, non-local dictionaries, or using hasmethod).  This means they can only read global constants, and cannot have any side effects.  In other words, they must be completely pure.  Due to an implementation limitation, this also means that they currently cannot define a closure or generator.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"It's easiest to illustrate this with an example. We can declare a generated function foo as","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> @generated function foo(x)\n           Core.println(x)\n           return :(x * x)\n       end\nfoo (generic function with 1 method)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Note that the body returns a quoted expression, namely :(x * x), rather than just the value of x * x.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"From the caller's perspective, this is identical to a regular function; in fact, you don't have to know whether you're calling a regular or generated function. Let's see how foo behaves:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> x = foo(2); # note: output is from println() statement in the body\nInt64\n\njulia> x           # now we print x\n4\n\njulia> y = foo(\"bar\");\nString\n\njulia> y\n\"barbar\"","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"So, we see that in the body of the generated function, x is the type of the passed argument, and the value returned by the generated function, is the result of evaluating the quoted expression we returned from the definition, now with the value of x.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"What happens if we evaluate foo again with a type that we have already used?","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> foo(4)\n16","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Note that there is no printout of Int64. We can see that the body of the generated function was only executed once here, for the specific set of argument types, and the result was cached.  After that, for this example, the expression returned from the generated function on the first invocation was re-used as the method body. However, the actual caching behavior is an implementation-defined performance optimization, so it is invalid to depend too closely on this behavior.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The number of times a generated function is generated might be only once, but it might also be more often, or appear to not happen at all. As a consequence, you should never write a generated function with side effects","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"when, and how often, the side effects occur is undefined. (This is true","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"for macros too - and just like for macros, the use of eval in a generated function is a sign that you're doing something the wrong way.) However, unlike macros, the runtime system cannot correctly handle a call to eval, so it is disallowed.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"It is also important to see how @generated functions interact with method redefinition.  Following the principle that a correct @generated function must not observe any mutable state or cause any mutation of global state, we see the following behavior.  Observe that the generated function cannot call any method that was not defined prior to the definition of the generated function itself.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Initially f(x) has one definition","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> f(x) = \"original definition\";","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Define other operations that use f(x):","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> g(x) = f(x);\n\njulia> @generated gen1(x) = f(x);\n\njulia> @generated gen2(x) = :(f(x));","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"We now add some new definitions for f(x):","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> f(x::Int) = \"definition for Int\";\n\njulia> f(x::Type{Int}) = \"definition for Type{Int}\";","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"and compare how these results differ:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> f(1)\n\"definition for Int\"\n\njulia> g(1)\n\"definition for Int\"\n\njulia> gen1(1)\n\"original definition\"\n\njulia> gen2(1)\n\"definition for Int\"","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Each method of a generated function has its own view of defined functions:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> @generated gen1(x::Real) = f(x);\n\njulia> gen1(1)\n\"definition for Type{Int}\"","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The example generated function foo above did not do anything a normal function foo(x) = x * x could not do (except printing the type on the first invocation, and incurring higher overhead).  However, the power of a generated function lies in its ability to compute different quoted expressions depending on the types passed to it:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> @generated function bar(x)\n           if x <: Integer\n               return :(x ^ 2)\n           else\n               return :(x)\n           end\n       end\nbar (generic function with 1 method)\n\njulia> bar(4)\n16\n\njulia> bar(\"baz\")\n\"baz\"","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"(although of course this contrived example would be more easily implemented using multiple dispatch...)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Abusing this will corrupt the runtime system and cause undefined behavior:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> @generated function baz(x)\n           if rand() < .9\n               return :(x^2)\n           else\n               return :(\"boo!\")\n           end\n       end\nbaz (generic function with 1 method)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Since the body of the generated function is non-deterministic, its behavior, and the behavior of all subsequent code is undefined.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Don't copy these examples!","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"These examples are hopefully helpful to illustrate how generated functions work, both in the definition end and at the call site; however, don't copy them, for the following reasons:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"the foo function has side-effects (the call to Core.println), and it is undefined exactly when, how often or how many times these side-effects will occur\nthe bar function solves a problem that is better solved with multiple dispatch - defining bar(x) = x and bar(x::Integer) = x ^ 2 will do the same thing, but it is both simpler and faster.\nthe baz function is pathological","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Note that the set of operations that should not be attempted in a generated function is unbounded, and the runtime system can currently only detect a subset of the invalid operations. There are many other operations that will simply corrupt the runtime system without notification, usually in subtle ways not obviously connected to the bad definition. Because the function generator is run during inference, it must respect all of the limitations of that code.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Some operations that should not be attempted include:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Caching of native pointers.\nInteracting with the contents or methods of Core.Compiler in any way.\nObserving any mutable state.\nInference on the generated function may be run at any time, including while your code is attempting to observe or mutate this state.\nTaking any locks: C code you call out to may use locks internally, (for example, it is not problematic to call malloc, even though most implementations require locks internally) but don't attempt to hold or acquire any while executing Julia code.\nCalling any function that is defined after the body of the generated function. This condition is relaxed for incrementally-loaded precompiled modules to allow calling any function in the module.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Alright, now that we have a better understanding of how generated functions work, let's use them to build some more advanced (and valid) functionality...","category":"page"},{"location":"manual/metaprogramming.html#An-advanced-example-1","page":"メタプログラミング","title":"An advanced example","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Julia's base library has a an internal sub2ind function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index i that can be used to index into an array A using A[i], instead of A[x,y,z,...]. One possible implementation is the following:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> function sub2ind_loop(dims::NTuple{N}, I::Integer...) where N\n           ind = I[N] - 1\n           for i = N-1:-1:1\n               ind = I[i]-1 + dims[i]*ind\n           end\n           return ind + 1\n       end\nsub2ind_loop (generic function with 1 method)\n\njulia> sub2ind_loop((3, 5), 1, 2)\n4","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"The same thing can be done using recursion:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> sub2ind_rec(dims::Tuple{}) = 1;\n\njulia> sub2ind_rec(dims::Tuple{}, i1::Integer, I::Integer...) =\n           i1 == 1 ? sub2ind_rec(dims, I...) : throw(BoundsError());\n\njulia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer) = i1;\n\njulia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer, I::Integer...) =\n           i1 + dims[1] * (sub2ind_rec(Base.tail(dims), I...) - 1);\n\njulia> sub2ind_rec((3, 5), 1, 2)\n4","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Both these implementations, although different, do essentially the same thing: a runtime loop over the dimensions of the array, collecting the offset in each dimension into the final index.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"However, all the information we need for the loop is embedded in the type information of the arguments.  Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance, we use generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating the linear index, we build up an expression that calculates the index:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\n           ex = :(I[$N] - 1)\n           for i = (N - 1):-1:1\n               ex = :(I[$i] - 1 + dims[$i] * $ex)\n           end\n           return :($ex + 1)\n       end\nsub2ind_gen (generic function with 1 method)\n\njulia> sub2ind_gen((3, 5), 1, 2)\n4","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"What code will this generate?","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"An easy way to find out is to extract the body into another (regular) function:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\n           return sub2ind_gen_impl(dims, I...)\n       end\nsub2ind_gen (generic function with 1 method)\n\njulia> function sub2ind_gen_impl(dims::Type{T}, I...) where T <: NTuple{N,Any} where N\n           length(I) == N || return :(error(\"partial indexing is unsupported\"))\n           ex = :(I[$N] - 1)\n           for i = (N - 1):-1:1\n               ex = :(I[$i] - 1 + dims[$i] * $ex)\n           end\n           return :($ex + 1)\n       end\nsub2ind_gen_impl (generic function with 1 method)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"We can now execute sub2ind_gen_impl and examine the expression it returns:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"julia> sub2ind_gen_impl(Tuple{Int,Int}, Int, Int)\n:(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1)","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"So, the method body that will be used here doesn't include a loop at all - just indexing into the two tuples, multiplication and addition/subtraction. All the looping is performed compile-time, and we avoid looping during execution entirely. Thus, we only loop once per type, in this case once per N (except in edge cases where the function is generated more than once - see disclaimer above).","category":"page"},{"location":"manual/metaprogramming.html#Optionally-generated-functions-1","page":"メタプログラミング","title":"Optionally-generated functions","text":"","category":"section"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Generated functions can achieve high efficiency at run time, but come with a compile time cost: a new function body must be generated for every combination of concrete argument types.  Typically, Julia is able to compile \"generic\" versions of functions that will work for any arguments, but with generated functions this is impossible.  This means that programs making heavy use of generated functions might be impossible to statically compile.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"To solve this problem, the language provides syntax for writing normal, non-generated alternative implementations of generated functions.  Applied to the sub2ind example above, it would look like this:","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\n    if N != length(I)\n        throw(ArgumentError(\"Number of dimensions must match number of indices.\"))\n    end\n    if @generated\n        ex = :(I[$N] - 1)\n        for i = (N - 1):-1:1\n            ex = :(I[$i] - 1 + dims[$i] * $ex)\n        end\n        return :($ex + 1)\n    else\n        ind = I[N] - 1\n        for i = (N - 1):-1:1\n            ind = I[i] - 1 + dims[i]*ind\n        end\n        return ind + 1\n    end\nend","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Internally, this code creates two implementations of the function: a generated one where the first block in if @generated is used, and a normal one where the else block is used.  Inside the then part of the if @generated block, code has the same semantics as other generated functions: argument names refer to types, and the code should return an expression. Multiple if @generated blocks may occur, in which case the generated implementation uses all of the then blocks and the alternate implementation uses all of the else blocks.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"Notice that we added an error check to the top of the function.  This code will be common to both versions, and is run-time code in both versions (it will be quoted and returned as an expression from the generated version). That means that the values and types of local variables are not available at code generation time –- the code-generation code can only see the types of arguments.","category":"page"},{"location":"manual/metaprogramming.html#","page":"メタプログラミング","title":"メタプログラミング","text":"In this style of definition, the code generation feature is essentially an optional optimization.  The compiler will use it if convenient, but otherwise may choose to use the normal implementation instead.  This style is preferred, since it allows the compiler to make more decisions and compile programs in more ways, and since normal code is more readable than code-generating code.  However, which implementation is used depends on compiler implementation details, so it is essential for the two implementations to behave identically.","category":"page"},{"location":"manual/arrays.html#man-multi-dim-arrays-1","page":"多次元配列","title":"多次元配列","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's also possible to define custom array types by inheriting from AbstractArray. See the manual section on the AbstractArray interface for more details on implementing a custom array type.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"An array is a collection of objects stored in a multi-dimensional grid. In the most general case, an array may contain objects of type Any. For most computational purposes, arrays should contain objects of a more specific type, such as Float64 or Int32.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for performance. Julia's compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing performance, and using less memory at times.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"In Julia, all arguments to functions are passed by sharing (i.e. by pointers). Some technical computing languages pass arrays by value, and while this prevents accidental modification by callees of a value in the caller, it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a ! indicates that it will mutate or destroy the value of one or more of its arguments (compare, for example, sort and sort!).  Callees must make explicit copies to ensure that they don't modify inputs that they don't intend to change. Many non- mutating functions are implemented by calling a function of the same name with an added ! at the end on an explicit copy of the input, and returning that copy.","category":"page"},{"location":"manual/arrays.html#Basic-Functions-1","page":"多次元配列","title":"Basic Functions","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Function Description\neltype(A) the type of the elements contained in A\nlength(A) the number of elements in A\nndims(A) the number of dimensions of A\nsize(A) a tuple containing the dimensions of A\nsize(A,n) the size of A along dimension n\naxes(A) a tuple containing the valid indices of A\naxes(A,n) a range expressing the valid indices along dimension n\neachindex(A) an efficient iterator for visiting each position in A\nstride(A,k) the stride (linear index distance between adjacent elements) along dimension k\nstrides(A) a tuple of the strides in each dimension","category":"page"},{"location":"manual/arrays.html#Construction-and-Initialization-1","page":"多次元配列","title":"Construction and Initialization","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Many functions for constructing and initializing arrays are provided. In the following list of such functions, calls with a dims... argument can either take a single tuple of dimension sizes or a series of dimension sizes passed as a variable number of arguments. Most of these functions also accept a first input T, which is the element type of the array. If the type T is omitted it will default to Float64.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Function Description\nArray{T}(undef, dims...) an uninitialized dense Array\nzeros(T, dims...) an Array of all zeros\nones(T, dims...) an Array of all ones\ntrues(dims...) a BitArray with all values true\nfalses(dims...) a BitArray with all values false\nreshape(A, dims...) an array containing the same data as A, but with different dimensions\ncopy(A) copy A\ndeepcopy(A) copy A, recursively copying its elements\nsimilar(A, T, dims...) an uninitialized array of the same type as A (dense, sparse, etc.), but with the specified element type and dimensions. The second and third arguments are both optional, defaulting to the element type and dimensions of A if omitted.\nreinterpret(T, A) an array with the same binary data as A, but with element type T\nrand(T, dims...) an Array with random, iid [1] and uniformly distributed values in the half-open interval 0 1)\nrandn(T, dims...) an Array with random, iid and standard normally distributed values\nMatrix{T}(I, m, n) m-by-n identity matrix\nrange(start, stop=stop, length=n) range of n linearly spaced elements from start to stop\nfill!(A, x) fill the array A with the value x\nfill(x, dims...) an Array filled with the value x","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"[1]: iid, independently and identically distributed.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The syntax [A, B, C, ...] constructs a 1-d array (i.e., a vector) of its arguments. If all arguments have a common promotion type then they get converted to that type using convert.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"To see the various ways we can pass dimensions to these constructors, consider the following examples:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> zeros(Int8, 2, 3)\n2×3 Array{Int8,2}:\n 0  0  0\n 0  0  0\n\njulia> zeros(Int8, (2, 3))\n2×3 Array{Int8,2}:\n 0  0  0\n 0  0  0\n\njulia> zeros((2, 3))\n2×3 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Here, (2, 3) is a Tuple.","category":"page"},{"location":"manual/arrays.html#Concatenation-1","page":"多次元配列","title":"Concatenation","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Arrays can be constructed and also concatenated using the following functions:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Function Description\ncat(A...; dims=k) concatenate input arrays along dimension(s) k\nvcat(A...) shorthand for cat(A...; dims=1)\nhcat(A...) shorthand for cat(A...; dims=2)","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Scalar values passed to these functions are treated as 1-element arrays. For example,","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> vcat([1, 2], 3)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> hcat([1 2], 3)\n1×3 Array{Int64,2}:\n 1  2  3","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The concatenation functions are used so often that they have special syntax:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Expression Calls\n[A; B; C; ...] vcat\n[A B C ...] hcat\n[A B; C D; ...] hvcat","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"hvcat concatenates in both dimension 1 (with semicolons) and dimension 2 (with spaces).  Consider these examples of this syntax:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> [[1; 2]; [3, 4]]\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> [[1 2] [3 4]]\n1×4 Array{Int64,2}:\n 1  2  3  4\n\njulia> [[1 2]; [3 4]]\n2×2 Array{Int64,2}:\n 1  2\n 3  4","category":"page"},{"location":"manual/arrays.html#Typed-array-initializers-1","page":"多次元配列","title":"Typed array initializers","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"An array with a specific element type can be constructed using the syntax T[A, B, C, ...]. This will construct a 1-d array with element type T, initialized to contain elements A, B, C, etc. For example, Any[x, y, z] constructs a heterogeneous array that can contain any values.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Concatenation syntax can similarly be prefixed with a type to specify the element type of the result.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> [[1 2] [3 4]]\n1×4 Array{Int64,2}:\n 1  2  3  4\n\njulia> Int8[[1 2] [3 4]]\n1×4 Array{Int8,2}:\n 1  2  3  4","category":"page"},{"location":"manual/arrays.html#Comprehensions-1","page":"多次元配列","title":"Comprehensions","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to set construction notation in mathematics:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"A = [ F(x,y,...) for x=rx, y=ry, ... ]","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The meaning of this form is that F(x,y,...) is evaluated with the variables x, y, etc. taking on each value in their given list of values. Values can be specified as any iterable object, but will commonly be ranges like 1:n or 2:(n-1), or explicit arrays of values like [1.2, 3.4, 5.7].  The result is an N-d dense array with dimensions that are the concatenation of the dimensions of the variable ranges rx, ry, etc. and each F(x,y,...) evaluation returns a scalar.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The following example computes a weighted average of the current element and its left and right neighbor along a 1-d grid. :","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> x = rand(8)\n8-element Array{Float64,1}:\n 0.843025\n 0.869052\n 0.365105\n 0.699456\n 0.977653\n 0.994953\n 0.41084\n 0.809411\n\njulia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]\n6-element Array{Float64,1}:\n 0.736559\n 0.57468\n 0.685417\n 0.912429\n 0.8446\n 0.656511","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The resulting array type depends on the types of the computed elements. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]","category":"page"},{"location":"manual/arrays.html#Generator-Expressions-1","page":"多次元配列","title":"Generator Expressions","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see Iteration). For example, the following expression sums a series without allocating memory:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> sum(1/n^2 for n=1:1000)\n1.6439345666815615","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"When writing a generator expression with multiple dimensions inside an argument list, parentheses are needed to separate the generator from subsequent arguments:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])\nERROR: syntax: invalid iteration specification","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"All comma-separated expressions after for are interpreted as ranges. Adding parentheses lets us add a third argument to map:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])\n2×2 Array{Tuple{Float64,Int64},2}:\n (0.5, 1)       (0.333333, 3)\n (0.333333, 2)  (0.25, 4)","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be \"captured\" in the inner function.  For example, sum(p[i] - q[i] for i=1:n) captures the three variables p, q and n from the enclosing scope. Captured variables can present performance challenges; see performance tips.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Ranges in generators and comprehensions can depend on previous ranges by writing multiple for keywords:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> [(i,j) for i=1:3 for j=1:i]\n6-element Array{Tuple{Int64,Int64},1}:\n (1, 1)\n (2, 1)\n (2, 2)\n (3, 1)\n (3, 2)\n (3, 3)","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"In such cases, the result is always 1-d.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Generated values can be filtered using the if keyword:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> [(i,j) for i=1:3 for j=1:i if i+j == 4]\n2-element Array{Tuple{Int64,Int64},1}:\n (2, 2)\n (3, 1)","category":"page"},{"location":"manual/arrays.html#man-array-indexing-1","page":"多次元配列","title":"Indexing","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The general syntax for indexing into an n-dimensional array A is:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"X = A[I_1, I_2, ..., I_n]","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"where each I_k may be a scalar integer, an array of integers, or any other supported index. This includes Colon (:) to select all indices within the entire dimension, ranges of the form a:c or a:b:c to select contiguous or strided subsections, and arrays of booleans to select elements at their true indices.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"If all the indices are scalars, then the result X is a single element from the array A. Otherwise, X is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"If all indices I_k are vectors, for example, then the shape of X would be (length(I_1), length(I_2), ..., length(I_n)), with location i_1, i_2, ..., i_n of X containing the value A[I_1[i_1], I_2[i_2], ..., I_n[i_n]].","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Example:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> A = reshape(collect(1:16), (2, 2, 2, 2))\n2×2×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\n[:, :, 2, 1] =\n 5  7\n 6  8\n\n[:, :, 1, 2] =\n  9  11\n 10  12\n\n[:, :, 2, 2] =\n 13  15\n 14  16\n\njulia> A[1, 2, 1, 1] # all scalar indices\n3\n\njulia> A[[1, 2], [1], [1, 2], [1]] # all vector indices\n2×1×2×1 Array{Int64,4}:\n[:, :, 1, 1] =\n 1\n 2\n\n[:, :, 2, 1] =\n 5\n 6\n\njulia> A[[1, 2], [1], [1, 2], 1] # a mix of index types\n2×1×2 Array{Int64,3}:\n[:, :, 1] =\n 1\n 2\n\n[:, :, 2] =\n 5\n 6","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Note how the size of the resulting array is different in the last two cases.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"If I_1 is changed to a two-dimensional matrix, then X becomes an n+1-dimensional array of shape (size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n)). The matrix adds a dimension.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Example:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> A = reshape(collect(1:16), (2, 2, 2, 2));\n\njulia> A[[1 2; 1 2]]\n2×2 Array{Int64,2}:\n 1  2\n 1  2\n\njulia> A[[1 2; 1 2], 1, 2, 1]\n2×2 Array{Int64,2}:\n 5  6\n 5  6","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The location i_1, i_2, i_3, ..., i_{n+1} contains the value at A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]].  All dimensions indexed with scalars are dropped. For example, if J is an array of indices, then the result of A[2, J, 3] is an array with size size(J). Its jth element is populated by A[2, J[j], 3].","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"As a special part of this syntax, the end keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax without the end keyword is equivalent to a call to getindex:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"X = getindex(A, I_1, I_2, ..., I_n)","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Example:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> x = reshape(1:16, 4, 4)\n4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> x[2:3, 2:end-1]\n2×2 Array{Int64,2}:\n 6  10\n 7  11\n\njulia> x[1, [2 3; 4 1]]\n2×2 Array{Int64,2}:\n  5  9\n 13  1","category":"page"},{"location":"manual/arrays.html#Assignment-1","page":"多次元配列","title":"Assignment","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The general syntax for assigning values in an n-dimensional array A is:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"A[I_1, I_2, ..., I_n] = X","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"where each I_k may be a scalar integer, an array of integers, or any other supported index. This includes Colon (:) to select all indices within the entire dimension, ranges of the form a:c or a:b:c to select contiguous or strided subsections, and arrays of booleans to select elements at their true indices.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"If all indices I_k are integers, then the value in location I_1, I_2, ..., I_n of A is overwritten with the value of X, converting to the eltype of A if necessary.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"If any index I_k selects more than one location, then the right hand side X must be an array with the same shape as the result of indexing A[I_1, I_2, ..., I_n] or a vector with the same number of elements. The value in location I_1[i_1], I_2[i_2], ..., I_n[i_n] of A is overwritten with the value X[I_1, I_2, ..., I_n], converting if necessary. The element-wise assignment operator .= may be used to broadcast X across the selected locations:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"A[I_1, I_2, ..., I_n] .= X","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Just as in Indexing, the end keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the end keyword is equivalent to a call to setindex!:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"setindex!(A, X, I_1, I_2, ..., I_n)","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Example:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> x = collect(reshape(1:9, 3, 3))\n3×3 Array{Int64,2}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> x[3, 3] = -9;\n\njulia> x[1:2, 1:2] = [-1 -4; -2 -5];\n\njulia> x\n3×3 Array{Int64,2}:\n -1  -4   7\n -2  -5   8\n  3   6  -9","category":"page"},{"location":"manual/arrays.html#man-supported-index-types-1","page":"多次元配列","title":"Supported index types","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"In the expression A[I_1, I_2, ..., I_n], each I_k may be a scalar index, an array of scalar indices, or an object that represents an array of scalar indices and can be converted to such by to_indices:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"A scalar index. By default this includes:\nNon-boolean integers\nCartesianIndex{N}s, which behave like an N-tuple of integers spanning multiple dimensions (see below for more details)\nAn array of scalar indices. This includes:\nVectors and multidimensional arrays of integers\nEmpty arrays like [], which select no elements\nRanges like a:c or a:b:c, which select contiguous or strided subsections from a to c (inclusive)\nAny custom array of scalar indices that is a subtype of AbstractArray\nArrays of CartesianIndex{N} (see below for more details)\nAn object that represents an array of scalar indices and can be converted to such by to_indices. By default this includes:\nColon() (:), which represents all indices within an entire dimension or across the entire array\nArrays of booleans, which select elements at their true indices (see below for more details)","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Some examples:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> A = reshape(collect(1:2:18), (3, 3))\n3×3 Array{Int64,2}:\n 1   7  13\n 3   9  15\n 5  11  17\n\njulia> A[4]\n7\n\njulia> A[[2, 5, 8]]\n3-element Array{Int64,1}:\n  3\n  9\n 15\n\njulia> A[[1 4; 3 8]]\n2×2 Array{Int64,2}:\n 1   7\n 5  15\n\njulia> A[[]]\n0-element Array{Int64,1}\n\njulia> A[1:2:5]\n3-element Array{Int64,1}:\n 1\n 5\n 9\n\njulia> A[2, :]\n3-element Array{Int64,1}:\n  3\n  9\n 15\n\njulia> A[:, 3]\n3-element Array{Int64,1}:\n 13\n 15\n 17","category":"page"},{"location":"manual/arrays.html#Cartesian-indices-1","page":"多次元配列","title":"Cartesian indices","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The special CartesianIndex{N} object represents a scalar index that behaves like an N-tuple of integers spanning multiple dimensions.  For example:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> A = reshape(1:32, 4, 4, 2);\n\njulia> A[3, 2, 1]\n7\n\njulia> A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7\ntrue","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Considered alone, this may seem relatively trivial; CartesianIndex simply gathers multiple integers together into one object that represents a single multidimensional index. When combined with other indexing forms and iterators that yield CartesianIndexes, however, this can produce very elegant and efficient code. See Iteration below, and for some more advanced examples, see this blog post on multidimensional algorithms and iteration.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Arrays of CartesianIndex{N} are also supported. They represent a collection of scalar indices that each span N dimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first \"page\" of A from above:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> page = A[:,:,1]\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> page[[CartesianIndex(1,1),\n             CartesianIndex(2,2),\n             CartesianIndex(3,3),\n             CartesianIndex(4,4)]]\n4-element Array{Int64,1}:\n  1\n  6\n 11\n 16","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"This can be expressed much more simply with dot broadcasting  and by combining it with a normal integer index (instead of extracting the first page from A as a separate step). It can even be combined with a : to extract both diagonals from the two pages at the same time:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]\n4-element Array{Int64,1}:\n  1\n  6\n 11\n 16\n\njulia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]\n4×2 Array{Int64,2}:\n  1  17\n  6  22\n 11  27\n 16  32","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"warning: Warning\nCartesianIndex and arrays of CartesianIndex are not compatible with the end keyword to represent the last index of a dimension. Do not use end in indexing expressions that may contain either CartesianIndex or arrays thereof.","category":"page"},{"location":"manual/arrays.html#Logical-indexing-1","page":"多次元配列","title":"Logical indexing","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Often referred to as logical indexing or indexing with a logical mask, indexing by a boolean array selects elements at the indices where its values are true.  Indexing by a boolean vector B is effectively the same as indexing by the vector of integers that is returned by findall(B). Similarly, indexing by a N-dimensional boolean array is effectively the same as indexing by the vector of CartesianIndex{N}s where its values are true. A logical index must be a vector of the same length as the dimension it indexes into, or it must be the only index provided and match the size and dimensionality of the array it indexes into. It is generally more efficient to use boolean arrays as indices directly instead of first calling findall.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> x = reshape(1:16, 4, 4)\n4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> x[[false, true, true, false], :]\n2×4 Array{Int64,2}:\n 2  6  10  14\n 3  7  11  15\n\njulia> mask = map(ispow2, x)\n4×4 Array{Bool,2}:\n 1  0  0  0\n 1  0  0  0\n 0  0  0  0\n 1  1  0  1\n\njulia> x[mask]\n5-element Array{Int64,1}:\n  1\n  2\n  4\n  8\n 16","category":"page"},{"location":"manual/arrays.html#Number-of-indices-1","page":"多次元配列","title":"Number of indices","text":"","category":"section"},{"location":"manual/arrays.html#Cartesian-indexing-1","page":"多次元配列","title":"Cartesian indexing","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The ordinary way to index into an N-dimensional array is to use exactly N indices; each index selects the position(s) in its particular dimension. For example, in the three-dimensional array A = rand(4, 3, 2), A[2, 3, 1] will select the number in the second row of the third column in the first \"page\" of the array. This is often referred to as cartesian indexing.","category":"page"},{"location":"manual/arrays.html#Linear-indexing-1","page":"多次元配列","title":"Linear indexing","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"When exactly one index i is provided, that index no longer represents a location in a particular dimension of the array. Instead, it selects the ith element using the column-major iteration order that linearly spans the entire array. This is known as linear indexing. It essentially treats the array as though it had been reshaped into a one-dimensional vector with vec.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> A = [2 6; 4 7; 3 1]\n3×2 Array{Int64,2}:\n 2  6\n 4  7\n 3  1\n\njulia> A[5]\n7\n\njulia> vec(A)[5]\n7","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"A linear index into the array A can be converted to a CartesianIndex for cartesian indexing with CartesianIndices(A)[i] (see CartesianIndices), and a set of N cartesian indices can be converted to a linear index with LinearIndices(A)[i_1, i_2, ..., i_N] (see LinearIndices).","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> CartesianIndices(A)[5]\nCartesianIndex(2, 2)\n\njulia> LinearIndices(A)[2, 2]\n5","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"It's important to note that there's a very large assymmetry in the performance of these conversions. Converting a linear index to a set of cartesian indices requires dividing and taking the remainder, whereas going the other way is just multiplies and adds. In modern processors, integer division can be 10-50 times slower than multiplication. While some arrays — like Array itself — are implemented using a linear chunk of memory and directly use a linear index in their implementations, other arrays — like Diagonal — need the full set of cartesian indices to do their lookup (see IndexStyle to introspect which is which). As such, when iterating over an entire array, it's much better to iterate over eachindex(A) instead of 1:length(A).  Not only will the former be much faster in cases where A is IndexCartesian, but it will also support OffsetArrays, too.","category":"page"},{"location":"manual/arrays.html#Omitted-and-extra-indices-1","page":"多次元配列","title":"Omitted and extra indices","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"In addition to linear indexing, an N-dimensional array may be indexed with fewer or more than N indices in certain situations.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words, trailing indices can be omitted only if there is only one possible value that those omitted indices could be for an in-bounds indexing expression. For example, a four-dimensional array with size (3, 4, 2, 1) may be indexed with only three indices as the dimension that gets skipped (the fourth dimension) has length one. Note that linear indexing takes precedence over this rule.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> A = reshape(1:24, 3, 4, 2, 1)\n3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64:\n[:, :, 1, 1] =\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\n[:, :, 2, 1] =\n 13  16  19  22\n 14  17  20  23\n 15  18  21  24\n\njulia> A[1, 3, 2] # Omits the fourth dimension (length 1)\n19\n\njulia> A[1, 3] # Attempts to omit dimensions 3 & 4 (lengths 2 and 1)\nERROR: BoundsError: attempt to access 3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64 at index [1, 3]\n\njulia> A[19] # Linear indexing\n19","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"When omitting all indices with A[], this semantic provides a simple idiom to retrieve the only element in an array and simultaneously ensure that there was only one element.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Similarly, more than N indices may be provided if all the indices beyond the dimensionality of the array are 1 (or more generally are the first and only element of axes(A, d) where d is that particular dimension number). This allows vectors to be indexed like one-column matrices, for example:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> A = [8,6,7]\n3-element Array{Int64,1}:\n 8\n 6\n 7\n\njulia> A[2,1]\n6","category":"page"},{"location":"manual/arrays.html#Iteration-1","page":"多次元配列","title":"Iteration","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The recommended ways to iterate over a whole array are","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"for a in A\n    # Do something with the element a\nend\n\nfor i in eachindex(A)\n    # Do something with i and/or A[i]\nend","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The first construct is used when you need the value, but not index, of each element. In the second construct, i will be an Int if A is an array type with fast linear indexing; otherwise, it will be a CartesianIndex:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> A = rand(4,3);\n\njulia> B = view(A, 1:3, 2:3);\n\njulia> for i in eachindex(B)\n           @show i\n       end\ni = CartesianIndex(1, 1)\ni = CartesianIndex(2, 1)\ni = CartesianIndex(3, 1)\ni = CartesianIndex(1, 2)\ni = CartesianIndex(2, 2)\ni = CartesianIndex(3, 2)","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"In contrast with for i = 1:length(A), iterating with eachindex provides an efficient way to iterate over any array type.","category":"page"},{"location":"manual/arrays.html#Array-traits-1","page":"多次元配列","title":"Array traits","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"If you write a custom AbstractArray type, you can specify that it has fast linear indexing using","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"This setting will cause eachindex iteration over a MyArray to use integers. If you don't specify this trait, the default value IndexCartesian() is used.","category":"page"},{"location":"manual/arrays.html#Array-and-Vectorized-Operators-and-Functions-1","page":"多次元配列","title":"Array and Vectorized Operators and Functions","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The following operators are supported for arrays:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Unary arithmetic – -, +\nBinary arithmetic – -, +, *, /, \\, ^\nComparison – ==, !=, ≈ (isapprox), ≉","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"To enable convenient vectorization of mathematical and other operations, Julia provides the dot syntax f.(args...), e.g. sin.(x) or min.(x,y), for elementwise operations over arrays or mixtures of arrays and scalars (a Broadcasting operation); these have the additional advantage of \"fusing\" into a single loop when combined with other dot calls, e.g. sin.(cos.(x)).","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Also, every binary operator supports a dot version  that can be applied to arrays (and combinations of arrays and scalars) in such fused broadcasting operations, e.g. z .== sin.(x .* y).","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Note that comparisons such as == operate on whole arrays, giving a single boolean answer. Use dot operators like .== for elementwise comparisons. (For comparison operations like <, only the elementwise .< version is applicable to arrays.)","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Also notice the difference between max.(a,b), which broadcasts max  elementwise over a and b, and maximum(a), which finds the largest value within a. The same relationship holds for min.(a,b) and minimum(a).","category":"page"},{"location":"manual/arrays.html#Broadcasting-1","page":"多次元配列","title":"ブロードキャスト","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as adding a vector to each column of a matrix. An inefficient way to do this would be to replicate the vector to the size of the matrix:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> a = rand(2,1); A = rand(2,3);\n\njulia> repeat(a,1,3)+A\n2×3 Array{Float64,2}:\n 1.20813  1.82068  1.25387\n 1.56851  1.86401  1.67846","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"This is wasteful when dimensions get large, so Julia provides broadcast, which expands singleton dimensions in array arguments to match the corresponding dimension in the other array without using extra memory, and applies the given function elementwise:","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> broadcast(+, a, A)\n2×3 Array{Float64,2}:\n 1.20813  1.82068  1.25387\n 1.56851  1.86401  1.67846\n\njulia> b = rand(1,2)\n1×2 Array{Float64,2}:\n 0.867535  0.00457906\n\njulia> broadcast(+, a, b)\n2×2 Array{Float64,2}:\n 1.71056  0.847604\n 1.73659  0.873631","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Dotted operators such as .+ and .* are equivalent to broadcast calls (except that they fuse, as described below). There is also a broadcast! function to specify an explicit destination (which can also be accessed in a fusing fashion by .= assignment). In fact, f.(args...) is equivalent to broadcast(f, args...), providing a convenient syntax to broadcast any function (dot syntax). Nested \"dot calls\" f.(...) (including calls to .+ etcetera)  automatically fuse into a single broadcast call.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"Additionally, broadcast is not limited to arrays (see the function documentation), it also handles tuples and treats any argument that is not an array, tuple or Ref  (except for Ptr) as a \"scalar\".","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> convert.(Float32, [1, 2])\n2-element Array{Float32,1}:\n 1.0\n 2.0\n\njulia> ceil.((UInt8,), [1.2 3.4; 5.6 6.7])\n2×2 Array{UInt8,2}:\n 0x02  0x04\n 0x06  0x07\n\njulia> string.(1:3, \". \", [\"First\", \"Second\", \"Third\"])\n3-element Array{String,1}:\n \"1. First\"\n \"2. Second\"\n \"3. Third\"","category":"page"},{"location":"manual/arrays.html#Implementation-1","page":"多次元配列","title":"Implementation","text":"","category":"section"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The base array type in Julia is the abstract type AbstractArray{T,N}. It is parameterized by the number of dimensions N and the element type T. AbstractVector and AbstractMatrix are aliases for the 1-d and 2-d cases. Operations on AbstractArray objects are defined using higher level operators and functions, in a way that is independent of the underlying storage. These operations generally work correctly as a fallback for any specific array implementation.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The AbstractArray type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete AbstractArray{T,N} type should generally implement at least size(A) (returning an Int tuple), getindex(A,i) and getindex(A,i1,...,iN); mutable arrays should also implement setindex!. It is recommended that these operations have nearly constant time complexity, or technically Õ(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a similar(A,T=eltype(A),dims=size(A))  method, which is used to allocate a similar array for copy and other out-of-place operations. No matter how an AbstractArray{T,N} is represented internally, T is the type of object returned by integer indexing (A[1, ..., 1], when A is not empty) and N should be the length of the tuple returned by size. For more details on defining custom AbstractArray implementations, see the array interface guide in the interfaces chapter.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"DenseArray is an abstract subtype of AbstractArray intended to include all arrays where elements are stored contiguously in column-major order (see additional notes in Performance Tips). The Array type is a specific instance of DenseArray; Vector and Matrix are aliases for the 1-d and 2-d cases.  Very few operations are implemented specifically for Array beyond those that are required for all AbstractArrays; much of the array library is implemented in a generic manner that allows all custom arrays to behave similarly.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"SubArray is a specialization of AbstractArray that performs indexing by sharing memory with the original array rather than by copying it. A SubArray is created with the view function, which is called the same way as getindex (with an array and a series of index arguments). The result of view looks the same as the result of getindex, except the data is left in place. view stores the input index vectors in a SubArray object, which can later be used to index the original array indirectly.  By putting the @views macro in front of an expression or block of code, any array[...] slice in that expression will be converted to create a SubArray view instead.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"BitArrays are space-efficient \"packed\" boolean arrays, which store one bit per boolean value.  They can be used similarly to Array{Bool} arrays (which store one byte per boolean value), and can be converted to/from the latter via Array(bitarray) and BitArray(array), respectively.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"A \"strided\" array is stored in memory with elements laid out in regular offsets such that an instance with a supported isbits element type can be passed to external C and Fortran functions that expect this memory layout. Strided arrays must define a strides(A) method that returns a tuple of \"strides\" for each dimension; a provided stride(A,k) method accesses the kth element within this tuple. Increasing the index of dimension k by 1 should increase the index i of getindex(A,i) by stride(A,k). If a pointer conversion method Base.unsafe_convert(Ptr{T}, A) is provided, the memory layout must correspond in the same way to these strides. DenseArray is a very specific example of a strided array where the elements are arranged contiguously, thus it provides its subtypes with the appropriate definition of strides. More concrete examples can be found within the interface guide for strided arrays. StridedVector and StridedMatrix are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"The following example computes the QR decomposition of a small section of a larger array, without creating any temporaries, and by calling the appropriate LAPACK function with the right leading dimension size and stride parameters.","category":"page"},{"location":"manual/arrays.html#","page":"多次元配列","title":"多次元配列","text":"julia> a = rand(10, 10)\n10×10 Array{Float64,2}:\n 0.517515  0.0348206  0.749042   0.0979679  …  0.75984     0.950481   0.579513\n 0.901092  0.873479   0.134533   0.0697848     0.0586695   0.193254   0.726898\n 0.976808  0.0901881  0.208332   0.920358      0.288535    0.705941   0.337137\n 0.657127  0.0317896  0.772837   0.534457      0.0966037   0.700694   0.675999\n 0.471777  0.144969   0.0718405  0.0827916     0.527233    0.173132   0.694304\n 0.160872  0.455168   0.489254   0.827851   …  0.62226     0.0995456  0.946522\n 0.291857  0.769492   0.68043    0.629461      0.727558    0.910796   0.834837\n 0.775774  0.700731   0.700177   0.0126213     0.00822304  0.327502   0.955181\n 0.9715    0.64354    0.848441   0.241474      0.591611    0.792573   0.194357\n 0.646596  0.575456   0.0995212  0.038517      0.709233    0.477657   0.0507231\n\njulia> b = view(a, 2:2:8,2:2:4)\n4×2 view(::Array{Float64,2}, 2:2:8, 2:2:4) with eltype Float64:\n 0.873479   0.0697848\n 0.0317896  0.534457\n 0.455168   0.827851\n 0.700731   0.0126213\n\njulia> (q, r) = qr(b);\n\njulia> q\n4×4 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:\n -0.722358    0.227524  -0.247784    -0.604181\n -0.0262896  -0.575919  -0.804227     0.144377\n -0.376419   -0.75072    0.540177    -0.0541979\n -0.579497    0.230151  -0.00552346   0.781782\n\njulia> r\n2×2 Array{Float64,2}:\n -1.20921  -0.383393\n  0.0      -0.910506","category":"page"},{"location":"manual/missing.html#missing-1","page":"Missing Values","title":"Missing Values","text":"","category":"section"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Julia provides support for representing missing values in the statistical sense, that is for situations where no value is available for a variable in an observation, but a valid value theoretically exists.  Missing values are represented via the missing object, which is the singleton instance of the type Missing. missing is equivalent to NULL in SQL and NA in R, and behaves like them in most situations.","category":"page"},{"location":"manual/missing.html#Propagation-of-Missing-Values-1","page":"Missing Values","title":"Propagation of Missing Values","text":"","category":"section"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"The behavior of missing values follows one basic rule: missing values propagate automatically when passed to standard operators and functions, in particular mathematical functions. Uncertainty about the value of one of the operands induces uncertainty about the result. In practice, this means an operation involving a missing value generally returns missing","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> missing + 1\nmissing\n\njulia> \"a\" * missing\nmissing\n\njulia> abs(missing)\nmissing","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"As missing is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type Missing, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a missing value to a function for which no method accepting arguments of type Missing is defined throws a MethodError, just like for any other type.","category":"page"},{"location":"manual/missing.html#Equality-and-Comparison-Operators-1","page":"Missing Values","title":"Equality and Comparison Operators","text":"","category":"section"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Standard equality and comparison operators follow the propagation rule presented above: if any of the operands is missing, the result is missing.  Here are a few examples","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> missing == 1\nmissing\n\njulia> missing == missing\nmissing\n\njulia> missing < 1\nmissing\n\njulia> 2 >= missing\nmissing","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"In particular, note that missing == missing returns missing, so == cannot be used to test whether a value is missing. To test whether x is missing, use ismissing(x).","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Special comparison operators isequal and === are exceptions to the propagation rule: they always return a Bool value, even in the presence of missing values, considering missing as equal to missing and as different from any other value. They can therefore be used to test whether a value is missing","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> missing === 1\nfalse\n\njulia> isequal(missing, 1)\nfalse\n\njulia> missing === missing\ntrue\n\njulia> isequal(missing, missing)\ntrue","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"The isless operator is another exception: missing is considered as greater than any other value. This operator is used by sort, which therefore places missing values after all other values.","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> isless(1, missing)\ntrue\n\njulia> isless(missing, Inf)\nfalse\n\njulia> isless(missing, missing)\nfalse","category":"page"},{"location":"manual/missing.html#Logical-operators-1","page":"Missing Values","title":"Logical operators","text":"","category":"section"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Logical (or boolean) operators |, & and xor are another special case, as they only propagate missing values when it is logically required. For these operators, whether or not the result is uncertain depends on the particular operation, following the well-established rules of three-valued logic which are also implemented by NULL in SQL and NA in R. This abstract definition actually corresponds to a relatively natural behavior which is best explained via concrete examples.","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Let us illustrate this principle with the logical \"or\" operator |.  Following the rules of boolean logic, if one of the operands is true, the value of the other operand does not have an influence on the result, which will always be true","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> true | true\ntrue\n\njulia> true | false\ntrue\n\njulia> false | true\ntrue","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Based on this observation, we can conclude that if one of the operands is true and the other missing, we know that the result is true in spite of the uncertainty about the actual value of one of the operands. If we had been able to observe the actual value of the second operand, it could only be true or false, and in both cases the result would be true. Therefore, in this particular case, missingness does not propagate","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> true | missing\ntrue\n\njulia> missing | true\ntrue","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"On the contrary, if one of the operands is false, the result could be either true or false depending on the value of the other operand. Therefore, if that operand is missing, the result has to be missing too","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> false | true\ntrue\n\njulia> true | false\ntrue\n\njulia> false | false\nfalse\n\njulia> false | missing\nmissing\n\njulia> missing | false\nmissing","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"The behavior of the logical \"and\" operator & is similar to that of the | operator, with the difference that missingness does not propagate when one of the operands is false. For example, when that is the case of the first operand","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> false & false\nfalse\n\njulia> false & true\nfalse\n\njulia> false & missing\nfalse","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"On the other hand, missingness propagates when one of the operands is true, for example the first one","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> true & true\ntrue\n\njulia> true & false\nfalse\n\njulia> true & missing\nmissing","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Finally, the \"exclusive or\" logical operator xor always propagates missing values, since both operands always have an effect on the result. Also note that the negation operator ! returns missing when the operand is missing just like other unary operators.","category":"page"},{"location":"manual/missing.html#Control-Flow-and-Short-Circuiting-Operators-1","page":"Missing Values","title":"Control Flow and Short-Circuiting Operators","text":"","category":"section"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Control flow operators including if, while and the ternary operator x ? y : z do not allow for missing values. This is because of the uncertainty about whether the actual value would be true or false if we could observe it, which implies that we do not know how the program should behave. A TypeError  is thrown as soon as a missing value is encountered in this context","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> if missing\n           println(\"here\")\n       end\nERROR: TypeError: non-boolean (Missing) used in boolean context","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"For the same reason, contrary to logical operators presented above, the short-circuiting boolean operators && and || do not allow for missing values in situations where the value of the operand determines whether the next operand is evaluated or not. For example","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> missing || false\nERROR: TypeError: non-boolean (Missing) used in boolean context\n\njulia> missing && false\nERROR: TypeError: non-boolean (Missing) used in boolean context\n\njulia> true && missing && false\nERROR: TypeError: non-boolean (Missing) used in boolean context","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"On the other hand, no error is thrown when the result can be determined without the missing values. This is the case when the code short-circuits before evaluating the missing operand, and when the missing operand is the last one","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> true && missing\nmissing\n\njulia> false && missing\nfalse","category":"page"},{"location":"manual/missing.html#Arrays-With-Missing-Values-1","page":"Missing Values","title":"Arrays With Missing Values","text":"","category":"section"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Arrays containing missing values can be created like other arrays","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> [1, missing]\n2-element Array{Union{Missing, Int64},1}:\n 1\n  missing","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"As this example shows, the element type of such arrays is Union{Missing, T}, with T the type of the non-missing values. This simply reflects the fact that array entries can be either of type T (here, Int64) or of type Missing.  This kind of array uses an efficient memory storage equivalent to an Array{T} holding the actual values combined with an Array{UInt8} indicating the type of the entry (i.e. whether it is Missing or T).","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Arrays allowing for missing values can be constructed with the standard syntax.  Use Array{Union{Missing, T}}(missing, dims) to create arrays filled with missing values:","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> Array{Union{Missing, String}}(missing, 2, 3)\n2×3 Array{Union{Missing, String},2}:\n missing  missing  missing\n missing  missing  missing","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"An array allowing for missing values but which does not contain any such value can be converted back to an array which does not allow for missing values using convert. If the array contains missing values, a MethodError is thrown during conversion","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> x = Union{Missing, String}[\"a\", \"b\"]\n2-element Array{Union{Missing, String},1}:\n \"a\"\n \"b\"\n\njulia> convert(Array{String}, x)\n2-element Array{String,1}:\n \"a\"\n \"b\"\n\njulia> y = Union{Missing, String}[missing, \"b\"]\n2-element Array{Union{Missing, String},1}:\n missing\n \"b\"\n\njulia> convert(Array{String}, y)\nERROR: MethodError: Cannot `convert` an object of type Missing to an object of type String","category":"page"},{"location":"manual/missing.html#Skipping-Missing-Values-1","page":"Missing Values","title":"Skipping Missing Values","text":"","category":"section"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Since missing values propagate with standard mathematical operators, reduction functions return missing when called on arrays which contain missing values","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> sum([1, missing])\nmissing","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"In this situation, use the skipmissing function to skip missing values","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> sum(skipmissing([1, missing]))\n1","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"This convenience function returns an iterator which filters out missing values efficiently. It can therefore be used with any function which supports iterators","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> x = skipmissing([3, missing, 2, 1])\nBase.SkipMissing{Array{Union{Missing, Int64},1}}(Union{Missing, Int64}[3, missing, 2, 1])\n\njulia> maximum(x)\n3\n\njulia> mean(x)\n2.0\n\njulia> mapreduce(sqrt, +, x)\n4.146264369941973","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Objects created by calling skipmissing on an array can be indexed using indices from the parent array. Indices corresponding to missing values are not valid for these objects and an error is thrown when trying to use them (they are also skipped by keys and eachindex)","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> x[1]\n3\n\njulia> x[2]\nERROR: MissingException: the value at index (2,) is missing\n[...]","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"This allows functions which operate on indices to work in combination with skipmissing.  This is notably the case for search and find functions, which return indices valid for the object returned by skipmissing which are also the indices of the matching entries in the parent array","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> findall(==(1), x)\n1-element Array{Int64,1}:\n 4\n\njulia> findfirst(!iszero, x)\n1\n\njulia> argmax(x)\n1","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Use collect to extract non-missing values and store them in an array","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> collect(x)\n3-element Array{Int64,1}:\n 3\n 2\n 1","category":"page"},{"location":"manual/missing.html#Logical-Operations-on-Arrays-1","page":"Missing Values","title":"Logical Operations on Arrays","text":"","category":"section"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"The three-valued logic described above for logical operators is also used by logical functions applied to arrays. Thus, array equality tests using the == operator return missing whenever the result cannot be determined without knowing the actual value of the missing entry. In practice, this means that missing is returned if all non-missing values of the compared arrays are equal, but one or both arrays contain missing values (possibly at different positions)","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> [1, missing] == [2, missing]\nfalse\n\njulia> [1, missing] == [1, missing]\nmissing\n\njulia> [1, 2, missing] == [1, missing, 2]\nmissing","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"As for single values, use isequal to treat missing values as equal to other missing values but different from non-missing values","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> isequal([1, missing], [1, missing])\ntrue\n\njulia> isequal([1, 2, missing], [1, missing, 2])\nfalse","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"Functions any and all also follow the rules of three-valued logic, returning missing when the result cannot be determined","category":"page"},{"location":"manual/missing.html#","page":"Missing Values","title":"Missing Values","text":"julia> all([true, missing])\nmissing\n\njulia> all([false, missing])\nfalse\n\njulia> any([true, missing])\ntrue\n\njulia> any([false, missing])\nmissing","category":"page"},{"location":"manual/networking-and-streams.html#networking-and-streams-1","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"","category":"section"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"Julia は、端末、パイプ、TCP ソケットなどのストリーミング I/O オブジェクトを扱う豊富なインターフェイスを提供します。このインターフェイスは、システム レベルでは非同期ですが、プログラマに同期的に提示され、通常は背後にある非同期処理を考える必要はありません。これは、Julia 協調スレッド(coroutine)機能を多用することによって達成されます。","category":"page"},{"location":"manual/networking-and-streams.html#Basic-Stream-I/O-1","page":"ネットワークとストリーム","title":"Basic Stream I/O","text":"","category":"section"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"All Julia streams expose at least a read and a write method, taking the stream as their first argument, e.g.:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> write(stdout, \"Hello World\");  # suppress return value 11 with ;\nHello World\njulia> read(stdin, Char)\n\n'\\n': ASCII/Unicode U+000a (category Cc: Other, control)","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"Note that write returns 11, the number of bytes (in \"Hello World\") written to stdout, but this return value is suppressed with the ;.","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, write takes the data to write as its second argument, while read  takes the type of the data to be read as the second argument.","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"For example, to read a simple byte array, we could do:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> x = zeros(UInt8, 4)\n4-element Array{UInt8,1}:\n 0x00\n 0x00\n 0x00\n 0x00\n\njulia> read!(stdin, x)\nabcd\n4-element Array{UInt8,1}:\n 0x61\n 0x62\n 0x63\n 0x64","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> read(stdin, 4)\nabcd\n4-element Array{UInt8,1}:\n 0x61\n 0x62\n 0x63\n 0x64","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"or if we had wanted to read the entire line instead:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> readline(stdin)\nabcd\n\"abcd\"","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"Note that depending on your terminal settings, your TTY may be line buffered and might thus require an additional enter before the data is sent to Julia.","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"To read every line from stdin you can use eachline:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"for line in eachline(stdin)\n    print(\"Found $line\")\nend","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"or read if you wanted to read by character instead:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"while !eof(stdin)\n    x = read(stdin, Char)\n    println(\"Found: $x\")\nend","category":"page"},{"location":"manual/networking-and-streams.html#Text-I/O-1","page":"ネットワークとストリーム","title":"Text I/O","text":"","category":"section"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"Note that the write method mentioned above operates on binary streams. In particular, values do not get converted to any canonical text representation but are written out as is:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> write(stdout, 0x61);  # suppress return value 1 with ;\na","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"Note that a is written to stdout by the write function and that the returned value is 1 (since 0x61 is one byte).","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"For text I/O, use the print or show methods, depending on your needs (see the documentation for these two methods for a detailed discussion of the difference between them):","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> print(stdout, 0x61)\n97","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"See Custom pretty-printing for more information on how to implement display methods for custom types.","category":"page"},{"location":"manual/networking-and-streams.html#IO-Output-Contextual-Properties-1","page":"ネットワークとストリーム","title":"IO Output Contextual Properties","text":"","category":"section"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"Sometimes IO output can benefit from the ability to pass contextual information into show methods. The IOContext object provides this framework for associating arbitrary metadata with an IO object. For example, :compact => true adds a hinting parameter to the IO object that the invoked show method should print a shorter output (if applicable). See the IOContext documentation for a list of common properties.","category":"page"},{"location":"manual/networking-and-streams.html#Working-with-Files-1","page":"ネットワークとストリーム","title":"Working with Files","text":"","category":"section"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"Like many other environments, Julia has an open function, which takes a filename and returns an IOStream object that you can use to read and write things from the file. For example, if we have a file, hello.txt, whose contents are Hello, World!:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> f = open(\"hello.txt\")\nIOStream(<file hello.txt>)\n\njulia> readlines(f)\n1-element Array{String,1}:\n \"Hello, World!\"","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"If you want to write to a file, you can open it with the write (\"w\") flag:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> f = open(\"hello.txt\",\"w\")\nIOStream(<file hello.txt>)\n\njulia> write(f,\"Hello again.\")\n12","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"If you examine the contents of hello.txt at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the IOStream must be closed before the write is actually flushed to disk:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> close(f)","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"Examining hello.txt again will show its contents have been changed.","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"Opening a file, doing something to its contents, and closing it again is a very common pattern.  To make this easier, there exists another invocation of open which takes a function as its first argument and filename as its second, opens the file, calls the function with the file as an argument, and then closes it again. For example, given a function:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"function read_and_capitalize(f::IOStream)\n    return uppercase(read(f, String))\nend","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"You can call:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> open(read_and_capitalize, \"hello.txt\")\n\"HELLO AGAIN.\"","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"to open hello.txt, call read_and_capitalize on it, close hello.txt and return the capitalized contents.","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"To avoid even having to define a named function, you can use the do syntax, which creates an anonymous function on the fly:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> open(\"hello.txt\") do f\n           uppercase(read(f, String))\n       end\n\"HELLO AGAIN.\"","category":"page"},{"location":"manual/networking-and-streams.html#簡単な-TCP-の例-1","page":"ネットワークとストリーム","title":"簡単な TCP の例","text":"","category":"section"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"ここで、TCP ソケットを含む簡単な例に飛び込んで見ましょう。この機能は、Sockets と呼ばれる標準ライブラリ パッケージにあります。 最初に単純なサーバーを作成してみましょう:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> using Sockets\n\njulia> @async begin\n           server = listen(2000)\n           while true\n               sock = accept(server)\n               println(\"Hello World\\n\")\n           end\n       end\nTask (runnable) @0x00007fd31dc11ae0","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"Unix ソケット API に精通している人にとって親しみやすいメソッド名ですが、その使用法は生の Unix ソケット API よりもいくらかシンプルです。listen への最初の呼び出しは、この場合、指定されたポート (2000) 上の着信接続を待機するサーバーを作成します。同じ機能を使用して、他のさまざまな種類のサーバーを作成することもできます:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> listen(2000) # Listens on localhost:2000 (IPv4)\nSockets.TCPServer(active)\n\njulia> listen(ip\"127.0.0.1\",2000) # Equivalent to the first\nSockets.TCPServer(active)\n\njulia> listen(ip\"::1\",2000) # Listens on localhost:2000 (IPv6)\nSockets.TCPServer(active)\n\njulia> listen(IPv4(0),2001) # Listens on port 2001 on all IPv4 interfaces\nSockets.TCPServer(active)\n\njulia> listen(IPv6(0),2001) # Listens on port 2001 on all IPv6 interfaces\nSockets.TCPServer(active)\n\njulia> listen(\"testsocket\") # Listens on a UNIX domain socket\nSockets.PipeServer(active)\n\njulia> listen(\"\\\\\\\\.\\\\pipe\\\\testsocket\") # Listens on a Windows named pipe\nSockets.PipeServer(active)","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"最後の呼び出しの戻り値の型が異なることに注意してください。これは、このサーバーが TCP ではなく、名前付きパイプ (Windows) または UNIX ドメイン ソケットでリッスンするためです。また、Windows の名前付きパイプ形式は、名前プレフィックス (\\\\.\\pipe\\) が ファイルの種類 を一意に識別するように特定のパターンである必要があります。TCP と名前付きパイプまたは UNIX ドメイン ソケットの違いはわずかで、accept メソッドと connect メソッドに関係しています。accept メソッドは、作成したサーバーに接続をしようとしているクライアントとの接続を受け入れます。connect 関数は指定されたメソッドを使ってサーバーに接続します。connect 関数はlistenと同じ引数を受け取るので、環境(ホスト、現在のカレントディレクトリなど)が同じであると仮定すると、接続を確立するために行ったのと同じ引数をconnectに渡すことができるはずです。(上記のサーバーを作成した後)それを試してみましょう:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> connect(2000)\nTCPSocket(open, 0 bytes waiting)\n\njulia> Hello World","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"予想通り\"Hello World\" が(サーバー側に)プリントされました。それでは、舞台裏で何が起こったのかを実際に分析してみましょう。connectを呼ぶと、作成したサーバーに接続します。一方、accept 関数は、新しく作成されたソケットへのサーバー側からの接続を返し、接続が成功したことを示す \"Hello World\" を出力します。","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"Julia の大きな強みは、I/O が実際に非同期的に発生しているにもかかわらず、API が同期的に公開されるので、コールバックを心配したり、サーバーが確実に実行されることを確認したりする必要がなかったことです。connectを呼び出すと、現在のタスクは接続が確立されるのを待ち、その後も実行を続行しました。この一時停止では、サーバー タスクが実行を再開し (接続要求が利用可能になったため)、接続を受け入れ、メッセージを印刷し、次のクライアントを待機しました。ReadとWriteは同じように機能します。 これを確認するために次の単純なエコー サーバーを考えてみましょう:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> @async begin\n           server = listen(2001)\n           while true\n               sock = accept(server)\n               @async while isopen(sock)\n                   write(sock, readline(sock, keep=true))\n               end\n           end\n       end\nTask (runnable) @0x00007fd31dc12e60\n\njulia> clientside = connect(2001)\nTCPSocket(RawFD(28) open, 0 bytes waiting)\n\njulia> @async while isopen(clientside)\n           write(stdout, readline(clientside, keep=true))\n       end\nTask (runnable) @0x00007fd31dc11870\n\njulia> println(clientside,\"Hello World from the Echo Server\")\nHello World from the Echo Server","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"他のストリームと同様に、closeを使用してソケットを切断します:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> close(clientside)","category":"page"},{"location":"manual/networking-and-streams.html#IP-アドレスの解決-1","page":"ネットワークとストリーム","title":"IP アドレスの解決","text":"","category":"section"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"listen メソッドと組み合わせて使われるconnect メソッドの他にconnect(host::String,port)の形式のものがあります。これは、hostパラメータで指定されたホストに対して、portで指定されたポートを使って接続します。次のように使い方です:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> connect(\"google.com\", 80)\nTCPSocket(RawFD(30) open, 0 bytes waiting)","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"この機能のベースになっているのはgetaddrinfoで、適切なアドレス解決を行います:","category":"page"},{"location":"manual/networking-and-streams.html#","page":"ネットワークとストリーム","title":"ネットワークとストリーム","text":"julia> getaddrinfo(\"google.com\")\nip\"74.125.226.225\"","category":"page"},{"location":"manual/parallel-computing.html#Parallel-Computing-1","page":"並列コンピューティング","title":"並列コンピューティング","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"マルチスレッドコンピューティングと並列コンピューティングの初心者にとっては、Julia が提供する並列処理のさまざまなレベルを最初に理解すると便利です。Julia の並列処理は3つの主要なカテゴリに分類することができます:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia コルーチン(グリーンスレッド)\nマルチスレッド\nマルチコア処理または分散処理","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"まず、Julia タスク(別名 コルーチン)","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"とJuliaランタイムライブラリに依存する他のモジュールを検討し、直接OSのスケジューラとやりとりをすることなく、タスク間の通信を完全に制御して計算を中断および再開できるようにします。 また、Julia はwaitや fetch などの操作を通じたタスク間通信をサポートしています。通信とデータの同期は、タスク間通信を提供する導管である Channels を介して管理されます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia は 実験的なマルチスレッド もサポートしています。実験的なマルチスレッドでは処理の実行がフォークされ、無名関数がすべてのスレッドで実行されます。 フォーク結合アプローチと呼ばれるもので、並行スレッドは独立して実行されますが、最終的には逐次実行を続行できるようにJulia のメイン スレッドに結合する必要があります。 マルチスレッドは、 Base.Threads モジュールでサポートされていますが、Julia がまだ完全にスレッドセーフではなく、実験段階のものです。特に、I/O 操作およびタスクの切り替え中にセグメンテーションフォールトが発生する可能性があります。最新情報を得るには Issue tracker","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"を参照してください。マルチスレッドを使うには、グローバル変数、ロック、およびアトミックを考慮しなくてはなりません。以下でこれらについて説明します。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"最後に、分散コンピューティングと並列コンピューティングに対する Julia のアプローチを紹介します。科学的計算での利用を念頭に、Julia はネイティブにインターフェイスを実装しており、複数のコアまたはマシンにプロセスを分散します。 また、MPI.jlやDistributedArrays.jlなどの分散プログラミングに役立つ外部パッケージについても言及します。","category":"page"},{"location":"manual/parallel-computing.html#コルーチン-1","page":"並列コンピューティング","title":"コルーチン","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia の並列プログラミング プラットフォームでは、 タスク (別名 Coroutines) を使用して複数の計算を切り替えます。 軽量スレッド間で実行順序を指定するには、通信プリミティブが必要です。 Julia には Channel(func::Function, ctype=Any, csize=0, taskref=nothing) という関数があります。funcから新しいタスクを作成し、型ctypeとサイズcsizeの新しいチャネルにタスクをバインド・スケジュールします。 Channels はタスク間の通信方法として機能するもので、Channel{T}(sz:Int) が型 T とサイズ sz のバッファリングチャネルを作成するようにします。コードが fetch や wait などの通信操作を実行するたびに、現在のタスクは中断され、スケジューラは実行する別のタスクを選択します。 タスクは、待機中のイベントが完了するとまた続きの処理を開始します。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"多くの問題では、タスクのことを直接考える必要はありません。ただし、タスクは、同時に処理される複数のイベントを待機するのに使用できるため、動的スケジューリングを行うことができます。動的スケジューリングでは、プログラムは、他のジョブがいつ終了するかに基づいて、何を計算するか、またはどこで計算するかを決定します。これは、予測不能なワークロードや不均衡なワークロードに必要です。こうした状況では、プロセスが現在のタスクを完了した時だけ、暇になったプロセスにより多くのタスクを割り当てる、というようなことをやりたくなります。","category":"page"},{"location":"manual/parallel-computing.html#Channels-1","page":"並列コンピューティング","title":"チャンネル","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"制御フローのページの タスク セクションでは、協調的に動作する複数の関数の実行について議論しました。Channelは、実行中のタスク、特に I/O 操作を含むタスク間でデータを渡すのに非常に役立ちます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"I/O に関連する操作の例としては、ファイルの読み取り/書き込み、Web サービスへのアクセス、外部プログラムの実行などがあります。いずれの場合も、ファイルの読み取り中、または外部サービス/プログラムの完了を待機している間に他のタスクを実行できる場合は、全体的な実行時間を改善できます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"チャネルはパイプとみなすことができます。つまり、チャンネルは \"write end\" と \"read end\"を持ちます:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"異なるタスクの複数のWriter が、put! 関数の呼び出し経由で同じチャネルに同時に書き込みできます。\n異なるタスクの複数のReader は、take!呼び出しを介して同時にデータを読み取ることができます。\n例:\n# Given Channels c1 and c2,\nc1 = Channel(32)\nc2 = Channel(32)\n\n# and a function `foo` which reads items from c1, processes the item read\n# and writes a result to c2,\nfunction foo()\n    while true\n        data = take!(c1)\n        [...]               # process data\n        put!(c2, result)    # write out result\n    end\nend\n\n# we can schedule `n` instances of `foo` to be active concurrently.\nfor _ in 1:n\n    @async foo()\nend\nチャンネルは、Channel{T}(sz) コンストラクタで生成されます。チャンネルは、型Tのオブジェクトのみを保持します。 型が指定されなかった場合は、チャンネルは、どんな型も保持することができます。 sz は、チャンネルでいつでも保持できる最大要素数です。例えば、Channel(32) で生成されるのは、任意の型のオブジェクトを最大32個保持できるチャンネルを生成します。   Channel{MyType}(64) は、MyTypeのオブジェクトを 64個まで、いつでも保持できます。\nChannel が空であれば、readerは( take! 関数をよんでも)データが利用可能になるまでブロックされます。\nChannel がいっぱいの場合 writerは、(put! を読んでも) データを書くスペースができるまでブロックされます。\nisready は、チャンネル内の任意のオブジェクトの有無についてチェックする関数で、 wait 関数はオブジェクトが利用可能になるまで待機するための関数です。\nChannel は、最初はオープンの状態です。つまり、take! 関数や、 put! 関数経由で、自由に読み書きできる状態で、close で、チャンネルをクローズできます。 クローズされたチャンネルでは、put! は失敗します。例えば:\njulia> c = Channel(2);\n\njulia> put!(c, 1) # `put!` on an open channel succeeds\n1\n\njulia> close(c);\n\njulia> put!(c, 2) # `put!` on a closed channel throws an exception.\nERROR: InvalidStateException(\"Channel is closed.\",:closed)\nStacktrace:\n[...]\nクローズされたチャンネルへの、take! と fetch (値を取得はしても、削除しません)は、チャンネルが空になるまで、チャンネルに存在する値を正常に返します。\njulia> fetch(c) # Any number of `fetch` calls succeed.\n1\n\njulia> fetch(c)\n1\n\njulia> take!(c) # The first `take!` removes the value.\n1\n\njulia> take!(c) # No more data available on a closed channel.\nERROR: InvalidStateException(\"Channel is closed.\",:closed)\nStacktrace:\n[...]","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"チャンネルは、forループないのイテラブルオブジェクトとして使うことができ、チャンネルがデータを持つか、オープンされている状態である限り、ループが回ります。ループ変数はチャンネルに追加された全ての値を引き受けます。forループが終了されるのは、チャンネルが閉じられ、データが空になったときです。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"たとえば、次の場合、for ループは(訳注: チャンネルが閉じられていないため) さらなるデータを待機します:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> c = Channel{Int}(10);\n\njulia> foreach(i->put!(c, i), 1:3) # add a few entries\n\njulia> data = [i for i in c]","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"対して、こちらは、チャンネル内の全てのデータを読んだらリターンします:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> c = Channel{Int}(10);\n\njulia> foreach(i->put!(c, i), 1:3); # add a few entries\n\njulia> close(c);                    # `for` loops can exit\n\njulia> data = [i for i in c]\n3-element Array{Int64,1}:\n 1\n 2\n 3","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"タスク間通信にチャネルを使用する簡単な例を考えてみましょう。私たちは、単一のjobsチャネルからデータを処理する4つのタスクを開始します。ID (job_id) によって識別されるジョブは、チャネルに書き込まれます。 このシミュレーションの各タスクはjob_idを読み取り、ランダムな時間をウェイトしてから、job_id のタプルとシミュレートされた時間の長さを 結果チャネルに書き戻します。最後に、すべてのresults が印刷されます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> const jobs = Channel{Int}(32);\n\njulia> const results = Channel{Tuple}(32);\n\njulia> function do_work()\n           for job_id in jobs\n               exec_time = rand()\n               sleep(exec_time)                # simulates elapsed time doing actual work\n                                               # typically performed externally.\n               put!(results, (job_id, exec_time))\n           end\n       end;\n\njulia> function make_jobs(n)\n           for i in 1:n\n               put!(jobs, i)\n           end\n       end;\n\njulia> n = 12;\n\njulia> @async make_jobs(n); # feed the jobs channel with \"n\" jobs\n\njulia> for i in 1:4 # start 4 tasks to process requests in parallel\n           @async do_work()\n       end\n\njulia> @elapsed while n > 0 # print out results\n           job_id, exec_time = take!(results)\n           println(\"$job_id finished in $(round(exec_time; digits=2)) seconds\")\n           global n = n - 1\n       end\n4 finished in 0.22 seconds\n3 finished in 0.45 seconds\n1 finished in 0.5 seconds\n7 finished in 0.14 seconds\n2 finished in 0.78 seconds\n5 finished in 0.9 seconds\n9 finished in 0.36 seconds\n6 finished in 0.87 seconds\n8 finished in 0.79 seconds\n10 finished in 0.64 seconds\n12 finished in 0.5 seconds\n11 finished in 0.97 seconds\n0.029772311","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"現在のバージョンの Julia は、すべてのタスクを単一の OS スレッドに多重化します。したがって、I/O 操作を含むタスクは並列実行の恩恵を受けますが、バインドされたタスクは単一の OS スレッドで効果的に順番に実行されます。Julia の将来のバージョンでは、複数のスレッドでのタスクのスケジューリングがサポートされるかもしれません。","category":"page"},{"location":"manual/parallel-computing.html#man-multithreading-1","page":"並列コンピューティング","title":"マルチスレッド(実験的実装)","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"タスクに加えて、Julia はマルチスレッドをネイティブにサポートします。 このセクションは実験的なものであり、インターフェイスは将来変更される可能性があることに注意してください。","category":"page"},{"location":"manual/parallel-computing.html#セットアップ-1","page":"並列コンピューティング","title":"セットアップ","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"デフォルトでは、Julia は単一の実行スレッドで起動します。これは、コマンド Threads.nthreads() を使用して確認できます:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> Threads.nthreads()\n1","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia が開始するスレッドの数は、JULIA_NUM_THREADS という環境変数によって制御されます。 さて、4つのスレッドでジュリアを起動してみましょう:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"export JULIA_NUM_THREADS=4","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"(上記のコマンドは、Linux および OSX 上のボーンシェルで動作します。これらのプラットフォームで C シェルを使用している場合は、exportの代わりに set というキーワードを使用する必要があります。Windows を使用している場合は、julia.exe の場所でコマンド ラインを起動し、export の代わりに set を使用します。)","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"4つのスレッドがあることを確認してみましょう。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> Threads.nthreads()\n4","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"しかし、現在はマスタースレッドに入っています。確認するには、関数 Threads.threadidを使用します","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> Threads.threadid()\n1","category":"page"},{"location":"manual/parallel-computing.html#The-@threads-マクロ-1","page":"並列コンピューティング","title":"The @threads マクロ","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"ネイティブスレッドを使用して簡単な例を見てみましょう。ゼロの配列を作成してみましょう:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> a = zeros(10)\n10-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"4つのスレッドを使用して、この配列を同時に操作してみましょう。各スレッドで各要素にスレッド ID を書き込みます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia はThreads.@threadsマクロを使用した並列ループをサポートしています。このマクロをfor ループの前に追加すると、ループがマルチスレッドで実行すべき領域であることを Julia に指示できます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> Threads.@threads for i = 1:10\n           a[i] = Threads.threadid()\n       end","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"イテレーションスペースはスレッド間で分割され、その後、各スレッドは割り当てられた場所にスレッド ID を書き込みます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> a\n10-element Array{Float64,1}:\n 1.0\n 1.0\n 1.0\n 2.0\n 2.0\n 2.0\n 3.0\n 3.0\n 4.0\n 4.0","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Threads.@threadsには、@distributedのようなオプションの縮小パラメーターがないことに注意してください。","category":"page"},{"location":"manual/parallel-computing.html#アトミック操作-1","page":"並列コンピューティング","title":"アトミック操作","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia は、アトミックな、つまり、競合状態を避けるためのスレッドセーフな方法で、値のアクセスと変更をサポートしています 。アトミックにアクセスする必要があることを示す値 (プリミティブ型である必要があります) を Threads.Atomic としてラップできます。 例を見てみましょう:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> i = Threads.Atomic{Int}(0);\n\njulia> ids = zeros(4);\n\njulia> old_is = zeros(4);\n\njulia> Threads.@threads for id in 1:4\n           old_is[id] = Threads.atomic_add!(i, id)\n           ids[id] = id\n       end\n\njulia> old_is\n4-element Array{Float64,1}:\n 0.0\n 1.0\n 7.0\n 3.0\n\njulia> ids\n4-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0\n 4.0","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"アトミックタグなしで加算を試すと、競合によって間違った答えが得られたかもしれません。競合を避けなかった場合にどうなるかの例は下記の通りです:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> using Base.Threads\n\njulia> nthreads()\n4\n\njulia> acc = Ref(0)\nBase.RefValue{Int64}(0)\n\njulia> @threads for i in 1:1000\n          acc[] += 1\n       end\n\njulia> acc[]\n926\n\njulia> acc = Atomic{Int64}(0)\nAtomic{Int64}(0)\n\njulia> @threads for i in 1:1000\n          atomic_add!(acc, 1)\n       end\n\njulia> acc[]\n1000","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"!!!メモ     すべてのプリミティブ型を Atomic タグでラップできるわけではありません。     サポートされている型はInt8、Int16、Int32、Int64、Int128、UInt8、UInt16、UInt32、UInt64、UInt128、Float16、Float32、およびFloat64です。     さらに Int128 および UInt128 は AAarch32 および ppc64le ではサポートされていません。","category":"page"},{"location":"manual/parallel-computing.html#副作用と変更可能な関数引数-1","page":"並列コンピューティング","title":"副作用と変更可能な関数引数","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"マルチスレッドを使用時、純粋 でない関数を使う場合には、間違った答えが得られる可能性があるので、注意が必要です。例えば、 名前が!で終わる関数は、慣習的に引数に指定された値を書き換えるため、純粋な関数ではありません。しかし、副作用を持つにも関わらず、その名前が!で終わらない関数があります。例えば、 findfirst(regex, str) は、引数 regexを変更しますし、rand() は、Base.GLOBAL_RNGを変更します :","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> using Base.Threads\n\njulia> nthreads()\n4\n\njulia> function f()\n           s = repeat([\"123\", \"213\", \"231\"], outer=1000)\n           x = similar(s, Int)\n           rx = r\"1\"\n           @threads for i in 1:3000\n               x[i] = findfirst(rx, s[i]).start\n           end\n           count(v -> v == 1, x)\n       end\nf (generic function with 1 method)\n\njulia> f() # the correct result is 1000\n1017\n\njulia> function g()\n           a = zeros(1000)\n           @threads for i in 1:1000\n               a[i] = rand()\n           end\n           length(unique(a))\n       end\ng (generic function with 1 method)\n\njulia> Random.seed!(1); g() # the result for a single thread is 1000\n781","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"このような場合は、競合状態に陥るの可能性を避けるためにコードを再設計するか、同期プリミティブを使ってください。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"たとえば、上記の findfirst の例を解決するには、スレッドごとに変数rxを別々にコピーして使う必要があります:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> function f_fix()\n             s = repeat([\"123\", \"213\", \"231\"], outer=1000)\n             x = similar(s, Int)\n             rx = [Regex(\"1\") for i in 1:nthreads()]\n             @threads for i in 1:3000\n                 x[i] = findfirst(rx[threadid()], s[i]).start\n             end\n             count(v -> v == 1, x)\n         end\nf_fix (generic function with 1 method)\n\njulia> f_fix()\n1000","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"r\"1\"の代わりにRegex(\"1\")を使って Julia が rxベクトルのそれぞれのエントリに対して、別々のRegexオブジェクトを生成するようにしています。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"randの例については、もう少し複雑です。各スレッドが重複しない擬似乱数シーケンスを使用するようにする必要があるためです。これは、単に Future.randjump 関数を使用して保証することができます:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> using Random; import Future\n\njulia> function g_fix(r)\n           a = zeros(1000)\n           @threads for i in 1:1000\n               a[i] = rand(r[threadid()])\n           end\n           length(unique(a))\n       end\ng_fix (generic function with 1 method)\n\njulia>  r = let m = MersenneTwister(1)\n                [m; accumulate(Future.randjump, fill(big(10)^20, nthreads()-1), init=m)]\n            end;\n\njulia> g_fix(r)\n1000","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"rベクトルをg_fixに渡しているのは、複数の RGN を生成するのがコストのかかる処理であるためで、関数を実行するたびにRGNの生成を繰り返す必要はありません。","category":"page"},{"location":"manual/parallel-computing.html#@threadcall(実験的な実装)-1","page":"並列コンピューティング","title":"@threadcall(実験的な実装)","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia では、すべての I/O タスク、タイマー、REPL コマンドなどは、イベント ループを介して 1 つの OS スレッドに多重化されています。これは、libuv ([http://docs.libuv.org/en/v1.x/])のパッチバージョンで提供している機能です。\"yield\" は、複数のタスクを同じ OS スレッドに同時にスケジューリングするための機能を提供します。I/O タスクとタイマーはイベントが発生するのを待機している間に暗黙的に生成されます。yieldを呼び出すと、(訳者註: 現在処理しているタスクが中止されるので) 他のタスクがスケジュールされるように明示的に許可を与えることができます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"したがって、ccallを実行するタスクは、呼び出しから制御が戻るまで Julia スケジューラが他のタスクを実行するのを効果的に防ぎます。これは、外部ライブラリへのすべての呼び出しに当てはまります。例外は、逆にJulia を呼び出すカスタム C コードを呼び出す場合 (その後、あとから yield する可能性があります) または jl_yield()(これはyield のCバージョンです) を呼び出すCコードを、呼び出す場合です。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia コードは(既定では) 単一のスレッド で実行されますが、Julia が使用するライブラリは独自の内部スレッドを起動する場合があることに注意してください。たとえば、BLAS ライブラリは、マシン上のコアと同じ数のスレッドを開始できます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"@threadcall マクロは、 ccallが、Juliaのメインイベントループをブロックして欲しくない時に使うことができます。別のスレッドで実行する C 関数をスケジュールします。これには、デフォルト・サイズが 4 のスレッド・プールが使用されます。スレッドプールのサイズは、環境変数 UV_THREADPOOL_SIZE で設定できます。スレッドが空くのを待機している間、およびスレッドが使用可能になって関数が実行されている間に、(メイン Julia イベント ループ上で)C関数のコールを要求するタスクは他のタスクにyield します。@threadcallを使うと、その実行完了まで制御が戻らないことに注意してくださいしたがって、ユーザーの観点から見ると、他の Julia API と同様にブロッキング呼び出しが行われますように見えます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"非常に重要なことですが、呼び出された関数がセグメンテーションフォルトになっても、Julia にコールバックしません。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"@threadcallは、Julia 将来のバージョンで削除/変更される可能性があります。","category":"page"},{"location":"manual/parallel-computing.html#マルチコア処理または分散処理-1","page":"並列コンピューティング","title":"マルチコア処理または分散処理","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia 付属の標準ライブラリの一部である、モジュール 'Distributed' を用いて、分散メモリ並列処理を実装できます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"現代のコンピュータの多くは複数の CPU を搭載しており、複数のコンピュータをクラスタ内で組み合わせることができます。これらの複数の CPU のパワーを利用することで、多くの計算をより迅速に完了できます。パフォーマンスに影響を与える主な要因には、CPU 自体の速度とメモリへのアクセス速度の 2 つがあります。クラスタでは、ある CPU が最速でアクセスできるのは、CPUと同じコンピュータ(ノード)内のRAMであることは明らかです。より驚くべきことに、典型的なマルチコアラップトップでも、メインメモリとキャッシュの速度の違いによって同様の問題が起きています。したがって、優れたマルチプロセッシング環境では、特定の CPU によるメモリチャンクの「所有権」を制御できる必要があります。 Julia は、メッセージ・パッシングに基づくマルチプロセッシング環境を提供し、プログラムが別々のメモリ・ドメイン内の複数のプロセスで一度に実行できるようにします。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia のメッセージパッシングの実装は、MPI [1] などの他の環境とは異なります。 Julia の通信は一般に\"一方向\" です。プログラマが明示的に管理する必要があるのは、2 つのプロセスのうち、1 つのプロセスのみです。さらに通常、これらの操作は見かけ上、\"メッセージ送信\" や \"メッセージ受信\" のような形でなく、ユーザー関数の呼び出しのような高レベルの操作に似た形になります。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia の分散プログラミングは、リモート参照 と リモート呼び出しの 2 つのプリミティブに基づいて構築されています。 リモート参照は、任意のプロセスから特定のプロセスに格納されているオブジェクトを参照するために使用できるオブジェクトです。リモート呼び出しとは、あるプロセスが別の (おそらく同じ) プロセスの特定の引数に対して特定の関数を呼び出すリクエストのことです。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"リモート参照には、FutureとRemoteChannelの2つのフレーバーがあります。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"リモート呼び出しを行うと、Futureが戻り値として得られ、さらに、プロセスの制御は、呼び出し側に直ちに返されます; すなわち、呼び出しを行ったプロセスは、リモート呼び出しが別の場所で行われる間、次の操作に進みます。リモート呼び出しから返された Future に対する wait 関数を呼び出すことで、呼び出したプロセスが終了するのを待つことができます。また、fetchを使って呼び出したプロセスの結果全ての値を取得することができます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"一方、RemoteChannelは書き換え可能です。たとえば、複数のプロセスが同じリモートの 'Channel' を参照して処理を調整することができます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"各プロセスには、識別子が関連付けられます。インタラクティブなJulia プロンプトを提供するプロセスは、常に1に等しいidを持っています。並列処理にデフォルトで使用されるプロセスは、\"ワーカー\" と呼ばれます。プロセスが 1 つしかない場合、プロセス 1 はワーカーと見なされます。それ以外の場合、ワーカーはプロセス 1 以外のすべてのプロセスと見なされます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"それではやってみましょう。julia -p n と juliaを起動することで、ローカルマシン上のn個のワーカープロセスを使うことができます。一般に、'n' がマシン上の CPU スレッド (論理コア) の数と等しくするのが理にかなっているでしょう。オプション引数 -p は Distributed モジュールを暗黙的に読み込むことに注意してください。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"$ ./julia -p 2\n\njulia> r = remotecall(rand, 2, 2, 2)\nFuture(2, 1, 4, nothing)\n\njulia> s = @spawnat 2 1 .+ fetch(r)\nFuture(2, 1, 5, nothing)\n\njulia> fetch(s)\n2×2 Array{Float64,2}:\n 1.18526  1.50912\n 1.16296  1.60607","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"remotecallの最初の引数は、リモートで呼び出す関数です。Julia のほとんどの並列プログラミングでは、特定のプロセスや使用可能なプロセスの数は参照されませんが、remotecallは、細かい制御を提供する低レベルのインターフェイスで、2番目の引数で、作業を行うプロセスのidを指定できます。残りの引数は呼び出される関数に渡されます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"ご覧の通り、最初の行ではプロセス 2 に 2✕2 のランダム行列を作成するよう依頼し、2 行目では 1 を追加するように依頼しました。両方の計算の結果は、r と s の 2 つのfutureで使用できます。@spawnat マクロは、第一引数で指定されたプロセスid で、第二引数で指定された式を評価します。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"場合によっては、リモートで計算された値がすぐに必要になる場合があります。典型例は、次のローカル操作でリモートの処理結果が必要になり、リモート オブジェクトから値を読み取る必要がある、という場合で、こういう時には、remotecall_fetch が使えます。これは fetch(remotecall(...))とするのと同等ですが、より効率的です(訳者註: 効率的というのはタイプ量が減るという意味で? それとも余計なオブジェクトができない、というリソース的な意味で? )。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> remotecall_fetch(getindex, 2, r, 1, 1)\n0.18526337335308085","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"getindex(r,1,1) は、r[1,1]と等しいことを覚えて置いてください。この呼び出しはfutureのrの最初の要素をフィッチします。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"remotecallの構文は特に便利ではなく、マクロ@spawn は物事を容易にします。関数でなく式を指定することができますし、操作を実行するプロセッサも選択できます:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> r = @spawn rand(2,2)\nFuture(2, 1, 4, nothing)\n\njulia> s = @spawn 1 .+ fetch(r)\nFuture(3, 1, 5, nothing)\n\njulia> fetch(s)\n2×2 Array{Float64,2}:\n 1.38854  1.9098\n 1.20939  1.57158","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"1 .+ rではなく、 1 .+ fetch(r)を使ったところに注意してください。 これは、コードがどこで実行されるかわからないため、一般的に、加算を行うプロセスに r を移動するために fetch が必要になる場合があります。この場合、@spawnはrを所有するプロセスで計算を実行するのに十分にスマートな方法になっていて、fetchはno-op(作業は行われない)ことになります。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"( @spawn は組み込み関数ではなく、Julia でマクロとして定義されていること注目する価値があります。このような仕組みを自分で独自に定義することは可能です。)","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"覚えておくべき重要なことは、一度結果がフェッチされると、Future はその値をローカルにキャッシュするということです。さらにfetch 呼び出しは、ネットワークホップを伴いません。一度、Futures のすべての参照が取得されると、リモートに保存された値は削除されます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"@spawnに似たものに、@asyncがありますが、@async でタスクが実行できるのはローカルプロセスのみです。@async を使うと、タスク毎にフィーダータスクが生成されます。それぞれのタスクは、計算する必要があるインデックスを選択し、そのプロセスが終了するのを待つ、ということを、インデックスがなくなるまで繰り返します。フィーダー タスクは、メインタスクが @sync ブロックの最後に達するまで実行を開始せず、その時点で制御が放棄され、関数から戻る前にすべてのローカル タスクが完了するのを待つことに注意してください。 Julia の v0.7 以降では、フィーダー タスクはすべて同じプロセスで実行されるため、nextidxを介して各タスクの状態を共有できます。 タスクが協調的にスケジュールされている場合でも、非同期 I/Oのように、ロックが必要な場合があります。 つまり、コンテキストスイッチは、remotecall_fetchが呼び出されたときに、明確に定義されたポイントでのみ発生します: これは現在の実装の状態であり、将来的には変更されるかもしれませんが、現在は、M個のプロセスに対してN個のタスクを実行することが可能なように実装されています。これを別名M:Nスレッドと言います。ロックの取得/リリースモデルをnextidx に対して用いる必要があります。複数のプロセスが、同時にリソースを読み書きできるのは危険なためです。","category":"page"},{"location":"manual/parallel-computing.html#code-availability-1","page":"並列コンピューティング","title":"コードの可用性とパッケージの読み込み","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"何かコードを実行するならば、実行プロセスからそのコードが利用可能でなければなりません。例えば、Julia のプロンプトに次のように入力してみましょう:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> function rand2(dims...)\n           return 2*rand(dims...)\n       end\n\njulia> rand2(2,2)\n2×2 Array{Float64,2}:\n 0.153756  0.368514\n 1.15119   0.918912\n\njulia> fetch(@spawn rand2(2,2))\nERROR: RemoteException(2, CapturedException(UndefVarError(Symbol(\"#rand2\"))\nStacktrace:\n[...]","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"プロセス1は rand2関数を知っていましたが、プロセス2は知りませんでした。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"大抵の場合は、コードをファイルやパッケージからロードすることで、あなたはかなり柔軟にプロセスがロードするコードを制御することができます。下記のコードを含む、DummyModule.jl というファイルを考えてみましょう:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"module DummyModule\n\nexport MyType, f\n\nmutable struct MyType\n    a::Int\nend\n\nf(x) = x^2+1\n\nprintln(\"loaded\")\n\nend","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"すべてのプロセスで MyType を参照するには、すべてのプロセスに DummyModule.jl をロードする必要があります。 include(\"DummyModule.jl\")を呼び出すと、単一のプロセスでのみ、コードが読み込まれます。すべてのプロセスにロードするには、@everywhereマクロを使用します(Juliaを julia -p 2 で開始して):","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> @everywhere include(\"DummyModule.jl\")\nloaded\n      From worker 3:    loaded\n      From worker 2:    loaded","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"いつも(シングルコアのケース)と同様に、上記は、DummyModule を全てのプロセスでスコープ内に持ち込むものでありません。using や import をする必要があります。さらに、あるプロセスで DummyModuleがスコープに入ったからと言って、他のプロセスのスコープに DummyModuleはありません:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> using .DummyModule\n\njulia> MyType(7)\nMyType(7)\n\njulia> fetch(@spawnat 2 MyType(7))\nERROR: On worker 2:\nUndefVarError: MyType not defined\n⋮\n\njulia> fetch(@spawnat 2 DummyModule.MyType(7))\nMyType(7)","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"ただし、DummyModule がスコープになくても、ロードされていれば、そのプロセスに対して、例えば、MyType を送信することは可能です:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> put!(RemoteChannel(2), MyType(7))\nRemoteChannel{Channel{Any}}(2, 1, 13)","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"また、ファイルは、Julia 起動時に、-Lフラグオプションで複数プロセスにプリロードでき、実行対象の\"driver.jl\" スクリプトが 計算を駆動することができます:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia -p <n> -L file1.jl -L file2.jl driver.jl","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"上記の例で、ドライバスクリプトを実行している Julia プロセスは、対話型プロンプトを提供するプロンプトと同様にプロセスid 1です。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"最後に、もし、DummyModule.jlが、スタンドアロンのファイルではなくパッケージだった場合 using DummyModuleとすると、DummyModule.jlのコードは全てのプロセスで ロード されますが、DummyModuleがスコープにはいるのは、usingが実行されたプロセスだけになります。","category":"page"},{"location":"manual/parallel-computing.html#ワーカー-プロセスの開始と管理-1","page":"並列コンピューティング","title":"ワーカー プロセスの開始と管理","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia をインストールすると、以下2種類のクラスタをサポートする機能が含まれています:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"上述の -p オプションで指定するローカルクラスタ (ノード内マルチコア)。\n--machine-file オプションをつかった複数計算機をまたぐクラスタ。これはパスワード無しのssh ログインを使って、現在のホストと同じ経路で、指定された計算機のJulia のワーカープロセスを起動します。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"addprocs, rmprocs, workersなどの関数で、クラスタ内のプロセスを追加・削除・問い合わせするプログラミング手段が提供されます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> using Distributed\n\njulia> addprocs(2)\n2-element Array{Int64,1}:\n 2\n 3","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Distributed モジュールは、addprocsを呼び出す前に、マスターとなるプロセスに明示的にロードする必要があります。 ワーカー プロセスで自動的に使用可能になります。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"ワーカーは ~/.julia/config/startup.jlの起動スクリプトを実行せず、グローバル状態 (グローバル変数、新しいメソッド定義、読み込まれたモジュールなど) も他の実行中プロセスと同期されないことに注意が必要です。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"他のタイプのクラスターは、ClusterManager セクションで説明するように、独自のClusterManager を記述することによってサポートできます。","category":"page"},{"location":"manual/parallel-computing.html#データの移動-1","page":"並列コンピューティング","title":"データの移動","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"メッセージの送信とデータの移動は、分散プログラムのオーバーヘッドの大部分を占めています。パフォーマンスとスケーラビリティを実現するには、メッセージの数と送信されるデータ量を減らすことが重要です。 そのためには、Julia のさまざまな分散プログラミングコンストラクトによって実行されるデータ移動を理解することが重要です。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"fetchは、オブジェクトをローカル マシンに移動することを直接要求するため、明示的なデータ移動操作と見なすことができます。@spawn(およびいくつかの関連する構成要素) もデータを移動しますが、これは明示的でないため、暗黙的なデータ移動操作と呼ぶことができます。ランダム行列を構築および二乗する方法を以下の2つ考えてみましょう:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"方法 1:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> A = rand(1000,1000);\n\njulia> Bref = @spawn A^2;\n\n[...]\n\njulia> fetch(Bref);","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"方法 2:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> Bref = @spawn rand(1000,1000)^2;\n\n[...]\n\njulia> fetch(Bref);","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"違いは些細に見えますが、実際には@spawnの動作を考えると非常に重要な違いです。 最初の方法では、ランダム行列がローカルで構築され、その後、別のプロセス送信されて、そこで2乗されます。2 番目の方法では、ランダム行列が別のプロセスで構築された後二乗されます。したがって、2 番目のメソッドのデータ送信量は、最初のメソッドでの送信量よりはるかに少ないです。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"このToy example では、これら2つの方法を区別し、選択するのは簡単です。しかし、実際のプログラムでデータの移動を設計するには、より多くのことを考慮し、おそらくはなんらかの測定が必要になる場合があります。たとえば、最初のプロセスに行列 A が必要な場合は、最初のメソッドの方が適している可能性があります。または、A の計算が高価で、現在のプロセス(ローカルのプロセス)だけでそれが計算されているのならば、別のプロセスへのデータ転送は避けられないかもしれません。または、現在のプロセスで @spawnと fetch(Bref) の間で行うことはほとんどない場合は、並列処理を完全に排除する方が良いかもしれません。または、rand(1000,1000)がより高価な操作に置き換えられると想像してみてください。次に、この手順に@spawn ステートメントを追加するのが理にかなっている場合があります。","category":"page"},{"location":"manual/parallel-computing.html#グローバル変数-1","page":"並列コンピューティング","title":"グローバル変数","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"@spawnを介してリモートで実行される式、または remotecall を使用してリモート実行用に指定されたクロージャは、グローバル変数を参照できます。モジュール Main のグローバル バインディングは、他のモジュールのグローバル バインディングとは少し異なる方法で扱われます。次のコード スニペットについて考えてみましょう:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"A = rand(10,10)\nremotecall_fetch(()->sum(A), 2)","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"この場合、sum はリモート プロセスで定義する必要があります。 A は、ローカル ワークスペースで定義されたグローバル変数であることに注意してください。ワーカープロセス 2 は、Mainの下で呼び出された変数Aを所有していません。クロージャー ()->sum(A) をワーカープロセス2 に送られた結果として、Main.A がワーカプロセス2に定義されます。 remotecall_fetch から制御がローカルに戻ったあとも、main.A はワーカープロセス 2 に存在し続けます。 埋め込みグローバル参照 (Mainモジュールのみ) を伴う、リモート呼び出しは、グローバル変数を下記のように管理します:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"新しいグローバルバインディングがリモート呼び出しの一部として参照されている場合には、そのグローバルバインディングは、ワーカー上に作成されます。\nグローバル定数は、リモート ノードでも定数として宣言されます。\nグローバルは、ワーカープロセスに再送信されるのは、リモート呼び出しのコンテキストで、さらにその値が変更された場合にのみです。また、クラスターはノード間でグローバル バインディングを同期しません。 例えば：\nA = rand(10,10)\nremotecall_fetch(()->sum(A), 2) # worker 2\nA = rand(10,10)\nremotecall_fetch(()->sum(A), 3) # worker 3\nA = nothing\n上記のスニペットを実行すると、ノード 1 の 'Main.A' の値は \"nothing\" に設定されているのですが、ワーカー 2のMain.Aは、ワーカー3のそれと異なる値を持ちます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"これでお分かりのように、グローバルに関連付けられたメモリはマスターで別の値が代入されたときにに収集される可能性がありますが、ワーカーではそのようなアクションは実行されません。バインディングが引き続き有効だからです。 clear! を使用すると、リモートノード上の特定のグローバルを、不要になったときに手動で nothingを再代入できます。これにより、通常のガベージ コレクション サイクルの一部として、それらに関連付けられているすべてのメモリが解放されます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"したがって、プログラムではリモート呼び出しでのグローバル参照をする時は、注意が必要です。実際には、可能であればリモートでのグローバル参照は完全に避けるのが好ましいです。グローバルを参照する必要がある場合は、let ブロックを使用してグローバル変数をローカライズすることを検討してください。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"例えば:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> A = rand(10,10);\n\njulia> remotecall_fetch(()->A, 2);\n\njulia> B = rand(10,10);\n\njulia> let B = B\n           remotecall_fetch(()->B, 2)\n       end;\n\njulia> @fetchfrom 2 InteractiveUtils.varinfo()\nname           size summary\n––––––––– ––––––––– ––––––––––––––––––––––\nA         800 bytes 10×10 Array{Float64,2}\nBase                Module\nCore                Module\nMain                Module","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"ここでわかるように、グローバル変数 A は、ワーカー2で定義されていますが、Bはローカル変数として補足されるため、ワーカー2では Bのバインディングは存在しません。","category":"page"},{"location":"manual/parallel-computing.html#並行マップと並行ループ-1","page":"並列コンピューティング","title":"並行マップと並行ループ","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"幸いにも、便利な並列計算の多くは、データの移動を必要としません。一般的な例は、複数のプロセスが独立したシミュレーション試行を同時に処理できるモンテカルロシミュレーションです。2つのプロセスでコインを反転させるために@spawnを使用することができます。まず、count_heads.jl に次の関数を書きます:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"function count_heads(n)\n    c::Int = 0\n    for i = 1:n\n        c += rand(Bool)\n    end\n    c\nend","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"関数 count_heads は単に n 個のランダムビットの和をとります。2 台のマシンで試行を実行し、それぞれの結果の和をとる方法を次に説明します:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> @everywhere include_string(Main, $(read(\"count_heads.jl\", String)), \"count_heads.jl\")\n\njulia> a = @spawn count_heads(100000000)\nFuture(2, 1, 6, nothing)\n\njulia> b = @spawn count_heads(100000000)\nFuture(3, 1, 7, nothing)\n\njulia> fetch(a)+fetch(b)\n100001564","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"この例で示されているのは、、並列プログラミングにおける、強力かつ頻出のパターンです。多くのイテレーションは複数のプロセスで独立に実行され、その結果は何らかの関数を使用して統合されます。その統合のプロセスはreduceと呼ばれます。その処理は、一般的にテンソルランク低減で、数値ベクトルが単一の数値に減少するとか、行列が単一の行または列などに減らされるような処理だからです。コードでは、通常、xがアキュムレータ、fがreduce関数、v[i] が削減される要素であるパターンで、 x= f(x,v[i])のようなコードになります。f は、操作が実行される順序に関係ない、つまり結合律を満たすことが望ましいです。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"count_heads を使用したこのパターンの使用は一般化できることに注意してください。2 つの明示的な @spawn ステートメントを使用して、並列処理を 2 つのプロセスに制限しました。任意の数のプロセスで実行するには、分散メモリで実行される parallel for loop を、次のように @distributed を使って書くことができます:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"nheads = @distributed (+) for i = 1:200000000\n    Int(rand(Bool))\nend","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"このコンストラクトは、繰り返し処理を複数のプロセスに計算させて、その結果を、指定された reduce 処理(この場合は (+))を使って統合する 実装パターンを実現しています。各反復の結果としてループ内の最後の式の値が受け取られます。並列ループ式全体が、最終的な計算結果として評価されます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"並行処理の for ループは、逐次処理の for ループと似ているようにみえますが、その動作は大きく異なることに注意が必要です。特に、反復は指定された順序で行われないこと、反復が異なるプロセスで実行されるので、変数または配列への書き込みはグローバルからは見えないこと等に注意しましょう。並列ループ内で使用される変数すべては、各プロセスにコピーされ、ブロードキャストされます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"たとえば、次のコードは意図したとおりに機能しません:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"a = zeros(100000)\n@distributed for i = 1:100000\n    a[i] = i\nend","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"このコードは、a の全ての要素を初期化できません。各プロセスには個別のコピーがあるからです。このような並行 for ループは避けなければいけません。さいわい、 Shared Array を使用して、この制限を回避できます:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"using SharedArrays\n\na = SharedArray{Float64}(10)\n@distributed for i = 1:10\n    a[i] = i\nend","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"並列ループにおける \"外部\" 変数の使用は、変数が読み取り専用の場合に全く問題有りません:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"a = randn(1000)\n@distributed (+) for i = 1:100000\n    f(a[rand(1:end)])\nend","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"ここでは、各反復は、すべてのプロセスで共有されるベクトル a からランダムに選択されたサンプルに f を適用します。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"ご覧の通り、reduce 演算子は必要ない場合は省略できます。その場合、ループは非同期的に実行され、つまり使用可能なすべてのワーカーに対して独立したタスクが生成され、完了を待たずにすぐに Future の配列を返します。呼び出し元は、fetch を呼び出して Futureの完了を後で待つこともできますし、@sync をつけて、つまり、 @sync @distributed for ループを使って、ループの最後で完了を待つことができます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"場合によっては、reduce 演算子は必要なく、ある範囲のすべての整数 (または一般的には、一部のコレクション内のすべての要素) に関数を適用するだけということもあるでしょう。これは、パラレル マップと呼ばれる便利な処理で、Julia ではpmap 関数として実装されています。たとえば、複数の大きなランダム行列の特異値を次のように並列に計算できます:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> M = Matrix{Float64}[rand(1000,1000) for i = 1:10];\n\njulia> pmap(svdvals, M);","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia のpmapは、1回の関数呼び出しのなかで大量の処理を行う場合を想定して設計されています。対して、@distributed for は、各反復が小さく、おそらく単に 2 つの数値を合計するだけのような状況を処理できます。並列計算にはpmapと@distributed for の両方でワーカー プロセスのみが使用されます。@distributedの場合、最終的なreduce処理は呼び出しプロセスで行われます。","category":"page"},{"location":"manual/parallel-computing.html#リモート参照と抽象チャネル-1","page":"並列コンピューティング","title":"リモート参照と抽象チャネル","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"リモート参照は常にAbstractChannelの実装を指します。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"抽象チャンネル(「チャネル」など)の具体的な実装は、put!、take!、fetch、isready 、wait をインストールするのに必要です。  Future が参照するリモートオブジェクトは、 Channel{Any}(1) すなわち サイズ1でAny型を保持するチャンネルです。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"RemoteChannelは、再書き込み可能であり、チャネルの任意のタイプとサイズ、またはAbstractChannelの他の実装を指すことができます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"コンストラクタ RemoteChannel(f::Function,pid)() を使用すると、特定の型の複数の値を保持するチャネルへの参照を構築できます。f は pid で実行される関数であり、AbstractChannel を返す必要があります。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"たとえば、RemoteChannel(()->Channel{Int}(10), pid) は、Int型でサイズ　10のチャネルへの参照を返します。 チャネルはワーカー pid に存在します。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"RemoteChannel上のメソッド put!, take!, fetch, isready and wait はリモートプロセスのバッキングストアにプロキシされます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"よって、RemoteChannel はユーザーが実装した AbstractChannel オブジェクトを参照するのに使うことができます。これのシンプルな例はExamples repositoryのdictchannel.jlに見ることができます。これは辞書をリモートストアとして辞書を使うような例です。","category":"page"},{"location":"manual/parallel-computing.html#チャネルとリモートチャネル-1","page":"並列コンピューティング","title":"チャネルとリモートチャネル","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Channelは、プロセスに対してローカルなものです。ワーカー2は、ワーカー3の Channelを直接参照することはできません。ただし、RemoteChannelは、ワーカーをまたいで値のput/takeを行うことができます。\nRemoteChannel は、Channelに対する ハンドル と考えることができます。\nRemoteChannelに関連付けられたプロセスID pid は、バッキングストア、すなわち \"backing Channel\" が存在するプロセスを識別します。\nRemoteChannelを参照するプロセスは、RemoteChannelから、値の put/take を行うことができます。 データはRemoteChannelが関連付けられているプロセスに自動的に送信(または取得)されます。\nChannelをシリアル化すると、チャネルに存在するデータもシリアル化されます。したがって、逆シリアル化すると、元のオブジェクトのコピーを効果的に作成できます。\n一方、RemoteChannelのシリアル化には、ハンドルによって参照されるChannelの場所とインスタンスを識別する識別子のシリアル化のみが含まれます。任意のワーカー上の 逆シリアル化された RemoteChannel オブジェクトは、元のバッキング ストアと同じバッキング ストアを指します。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"上記のチャネル例は、以下に示すように、プロセス間通信用に変更できます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"ここでは、ジョブを格納する 単一のリモートチャネルを処理するために4つのワーカーを立ち上げます。ID (job_id) によって識別されるジョブは、チャネルに書き込まれます。このシミュレーションでリモートで実行している各タスクは job_idを読み取り、ランダムな時間だけ待機し、job_idのタプル、時間、および独自のpidを \"results\" チャネルに書き戻します。最後に、すべての結果がマスタープロセスにプリント出力されます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> addprocs(4); # add worker processes\n\njulia> const jobs = RemoteChannel(()->Channel{Int}(32));\n\njulia> const results = RemoteChannel(()->Channel{Tuple}(32));\n\njulia> @everywhere function do_work(jobs, results) # define work function everywhere\n           while true\n               job_id = take!(jobs)\n               exec_time = rand()\n               sleep(exec_time) # simulates elapsed time doing actual work\n               put!(results, (job_id, exec_time, myid()))\n           end\n       end\n\njulia> function make_jobs(n)\n           for i in 1:n\n               put!(jobs, i)\n           end\n       end;\n\njulia> n = 12;\n\njulia> @async make_jobs(n); # feed the jobs channel with \"n\" jobs\n\njulia> for p in workers() # start tasks on the workers to process requests in parallel\n           remote_do(do_work, p, jobs, results)\n       end\n\njulia> @elapsed while n > 0 # print out results\n           job_id, exec_time, where = take!(results)\n           println(\"$job_id finished in $(round(exec_time; digits=2)) seconds on worker $where\")\n           global n = n - 1\n       end\n1 finished in 0.18 seconds on worker 4\n2 finished in 0.26 seconds on worker 5\n6 finished in 0.12 seconds on worker 4\n7 finished in 0.18 seconds on worker 4\n5 finished in 0.35 seconds on worker 5\n4 finished in 0.68 seconds on worker 2\n3 finished in 0.73 seconds on worker 3\n11 finished in 0.01 seconds on worker 3\n12 finished in 0.02 seconds on worker 3\n9 finished in 0.26 seconds on worker 5\n8 finished in 0.57 seconds on worker 4\n10 finished in 0.58 seconds on worker 2\n0.055971741","category":"page"},{"location":"manual/parallel-computing.html#リモート参照と分散ガベージ-コレクション-1","page":"並列コンピューティング","title":"リモート参照と分散ガベージ コレクション","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"リモート参照で参照されるオブジェクトは、クラスター内に保持されている全ての 参照が削除された場合にのみ解放できます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"値が格納されているノードは、どのワーカーがその値を参照しているかを追跡します。 RemoteChannelまたは(フェッチされていない)Futureがワーカーにシリアル化されるたびに、参照によって指し示されたノードが通知されます。また、RemoteChannelまたは(フェッチされていない)Futureがローカルに収集されるたびに、値を所有するノードが再度通知されます。これは、内部クラスター対応シリアライザーで実装されます。リモート参照は、実行中のクラスターのコンテキストでのみ有効です。通常の IOオブジェクトからの参照、通常の IOオブジェクトへの参照のシリアル化と逆シリアル化はサポートされていません。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"通知は、「トラッキング」メッセージの送信を介して行われます。このメッセージとは、参照が別のプロセスにシリアル化されるときには、「参照の追加」メッセージであり、参照がローカルのガベージ コレクションで処理されたときには「参照を削除」メッセージに相当します。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Futureは、書き込みが一度で、ローカルにキャッシュされるので、 fetchの振る舞いは、その値を所有しているノードの参照追跡情報の更新も行います。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"値を所有するノードは、値へのすべての参照がクリアされると、値(のメモリを)解放します。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Futureを使用すると、既にフェッチされた Future を別のノードにシリアル化すると、(参照だけでなく)値そのものも送信されます。元のリモート ストアが現時点までの間に値を収集した可能性があるためです。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"いつオブジェクトがローカルに収集されるかは、オブジェクトのサイズとシステム内の現在のメモリ負荷によって異なる、ということは注意すべきです。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"リモート参照の場合、リモートノードにある値が非常に大きくなる可能性があるのですが、ローカル参照オブジェクトのサイズは非常に小さくなります。ローカルオブジェクトはすぐに収集されないことがあるため、RemoteChannelのローカルインスタンスや、フェッチされていないFutureに対して、finalize を明示的に呼ぶのはよいアイディアです。Futureに対してfetchを呼ぶと、その参照もリモートストアから削除されてしまうので、フェッチされたFutureについては、finalizeする必要はありません。明示的にfinalizeを呼ぶとリモートノードに対してすぐにメッセージが送信されて、処理が先に進み、値への参照が削除されます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"いったんファイナライズされると、参照は無効になり、それ以降の呼び出しでは使用できません。","category":"page"},{"location":"manual/parallel-computing.html#man-distributed-local-invocations-1","page":"並列コンピューティング","title":"ローカル呼び出し","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"データは、処理が実行されるリモートノードに必ずコピーされます。これは、remotecallされた場合、データがRemoteChannel に格納されたり別のノードで Futureが呼ばれた場合でも同様です。予想できるように、これはリモートノードでのシリアル化されたオブジェクトのコピーとなります。すなわち、呼び出しを行うプロセスのIDと、リモートのノードのIDは同じで、ローカル呼び出しとして実行されます。大抵の場合(常に、ではありません)は、別のタスクで実行され、しかしそこではデータのシリアライズ/逆シリアライズの処理は発生しません。呼び出しでは、受け渡されたオブジェクトインスタンスと全く同じものを参照して、コピーはつくられません。ここで述べた振る舞いは、以下の例でよく分かります:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> using Distributed;\n\njulia> rc = RemoteChannel(()->Channel(3));   # RemoteChannel created on local node\n\njulia> v = [0];\n\njulia> for i in 1:3\n           v[1] = i                          # Reusing `v`\n           put!(rc, v)\n       end;\n\njulia> result = [take!(rc) for _ in 1:3];\n\njulia> println(result);\nArray{Int64,1}[[3], [3], [3]]\n\njulia> println(\"Num Unique objects : \", length(unique(map(objectid, result))));\nNum Unique objects : 1\n\njulia> addprocs(1);\n\njulia> rc = RemoteChannel(()->Channel(3), workers()[1]);   # RemoteChannel created on remote node\n\njulia> v = [0];\n\njulia> for i in 1:3\n           v[1] = i\n           put!(rc, v)\n       end;\n\njulia> result = [take!(rc) for _ in 1:3];\n\njulia> println(result);\nArray{Int64,1}[[1], [2], [3]]\n\njulia> println(\"Num Unique objects : \", length(unique(map(objectid, result))));\nNum Unique objects : 3","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"ご覧の通り、ローカルで所有されたRemoteChannelとv に対してput! を(複数回)呼ぶ場合、その複数回の呼び出しの間に v を修正すると、単一のオブジェクトインスタンスが格納されます。対象的に、rc を所有するノードが別のノードである時、(その時々の)vのコピーが生成されるのと対象的です。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"この振る舞いは、一般的には大した問題にはならないと思ってください。この振る舞いを考慮する必要があるとすれば、それは、オブジェクトがローカルに格納され、その後 (put!などの)呼び出しの後で、そのオブジェクトが変更された状況だけです。このような場合は、オブジェクトの「ディープコピー」を保存するのが適切でしょう。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"これは、次の例に示すように、ローカル ノードのremotecallにも当てはまります:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> using Distributed; addprocs(1);\n\njulia> v = [0];\n\njulia> v2 = remotecall_fetch(x->(x[1] = 1; x), myid(), v);     # Executed on local node\n\njulia> println(\"v=$v, v2=$v2, \", v === v2);\nv=[1], v2=[1], true\n\njulia> v = [0];\n\njulia> v2 = remotecall_fetch(x->(x[1] = 1; x), workers()[1], v); # Executed on remote node\n\njulia> println(\"v=$v, v2=$v2, \", v === v2);\nv=[0], v2=[1], false","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"ここでもまたご覧の通り、ローカル ノードへの remotecall は、直接呼び出しと同様に機能します。 ローカルノードへの remotecall は、引数として渡されたローカル オブジェクトを変更します。リモート呼び出しでは、引数のコピーに対する処理になります。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"繰り返しますが、一般的にこのふるまいが問題になることはありません。もし、ローカル ノードがコンピューティング ノードとしても使用され、引数が ローカル呼び出しの後にも使用されるとすれば、ここで触れた振る舞いを考慮する必要があります。具体的には、必要に応じて引数のディープコピーを用意してローカルノードで呼び出された呼び出しに渡す必要があります。しかし、リモート ノードの呼び出しは、常に引数のコピーで動作します。","category":"page"},{"location":"manual/parallel-computing.html#man-shared-arrays-1","page":"並列コンピューティング","title":"共有配列","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Shared Arrays use system shared memory to map the same array across many processes. While there are some similarities to a DArray, the behavior of a SharedArray is quite different. In a DArray, each process has local access to just a chunk of the data, and no two processes share the same chunk; in contrast, in a SharedArray each \"participating\" process has access to the entire array.  A SharedArray is a good choice when you want to have a large amount of data jointly accessible to two or more processes on the same machine.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Shared Array support is available via module SharedArrays which must be explicitly loaded on all participating workers.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"SharedArray indexing (assignment and accessing values) works just as with regular arrays, and is efficient because the underlying memory is available to the local process. Therefore, most algorithms work naturally on SharedArrays, albeit in single-process mode. In cases where an algorithm insists on an Array input, the underlying array can be retrieved from a SharedArray by calling sdata. For other AbstractArray types, sdata  just returns the object itself, so it's safe to use sdata on any Array-type object.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"The constructor for a shared array is of the form:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"SharedArray{T,N}(dims::NTuple; init=false, pids=Int[])","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"which creates an N-dimensional shared array of a bits type T and size dims across the processes specified by pids. Unlike distributed arrays, a shared array is accessible only from those participating workers specified by the pids named argument (and the creating process too, if it is on the same host).","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"If an init function, of signature initfn(S::SharedArray), is specified, it is called on all the participating workers. You can specify that each worker runs the init function on a distinct portion of the array, thereby parallelizing initialization.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Here's a brief example:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> using Distributed\n\njulia> addprocs(3)\n3-element Array{Int64,1}:\n 2\n 3\n 4\n\njulia> @everywhere using SharedArrays\n\njulia> S = SharedArray{Int,2}((3,4), init = S -> S[localindices(S)] = myid())\n3×4 SharedArray{Int64,2}:\n 2  2  3  4\n 2  3  3  4\n 2  3  4  4\n\njulia> S[3,2] = 7\n7\n\njulia> S\n3×4 SharedArray{Int64,2}:\n 2  2  3  4\n 2  3  3  4\n 2  7  4  4","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"SharedArrays.localindices provides disjoint one-dimensional ranges of indices, and is sometimes convenient for splitting up tasks among processes. You can, of course, divide the work any way you wish:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> S = SharedArray{Int,2}((3,4), init = S -> S[indexpids(S):length(procs(S)):length(S)] = myid())\n3×4 SharedArray{Int64,2}:\n 2  2  2  2\n 3  3  3  3\n 4  4  4  4","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Since all processes have access to the underlying data, you do have to be careful not to set up conflicts. For example:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"@sync begin\n    for p in procs(S)\n        @async begin\n            remotecall_wait(fill!, p, S, p)\n        end\n    end\nend","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"would result in undefined behavior. Because each process fills the entire array with its own pid, whichever process is the last to execute (for any particular element of S) will have its pid retained.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"As a more extended and complex example, consider running the following \"kernel\" in parallel:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"q[i,j,t+1] = q[i,j,t] + u[i,j,t]","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if q[i,j,t] is near the end of the block assigned to one worker and q[i,j,t+1] is near the beginning of the block assigned to another, it's very likely that q[i,j,t] will not be ready at the time it's needed for computing q[i,j,t+1]. In such cases, one is better off chunking the array manually. Let's split along the second dimension.  Define a function that returns the (irange, jrange) indices assigned to this worker:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> @everywhere function myrange(q::SharedArray)\n           idx = indexpids(q)\n           if idx == 0 # This worker is not assigned a piece\n               return 1:0, 1:0\n           end\n           nchunks = length(procs(q))\n           splits = [round(Int, s) for s in range(0, stop=size(q,2), length=nchunks+1)]\n           1:size(q,1), splits[idx]+1:splits[idx+1]\n       end","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Next, define the kernel:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> @everywhere function advection_chunk!(q, u, irange, jrange, trange)\n           @show (irange, jrange, trange)  # display so we can see what's happening\n           for t in trange, j in jrange, i in irange\n               q[i,j,t+1] = q[i,j,t] + u[i,j,t]\n           end\n           q\n       end","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"We also define a convenience wrapper for a SharedArray implementation","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> @everywhere advection_shared_chunk!(q, u) =\n           advection_chunk!(q, u, myrange(q)..., 1:size(q,3)-1)","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Now let's compare three different versions, one that runs in a single process:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> advection_serial!(q, u) = advection_chunk!(q, u, 1:size(q,1), 1:size(q,2), 1:size(q,3)-1);","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"one that uses @distributed:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> function advection_parallel!(q, u)\n           for t = 1:size(q,3)-1\n               @sync @distributed for j = 1:size(q,2)\n                   for i = 1:size(q,1)\n                       q[i,j,t+1]= q[i,j,t] + u[i,j,t]\n                   end\n               end\n           end\n           q\n       end;","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"and one that delegates in chunks:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> function advection_shared!(q, u)\n           @sync begin\n               for p in procs(q)\n                   @async remotecall_wait(advection_shared_chunk!, p, q, u)\n               end\n           end\n           q\n       end;","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"If we create SharedArrays and time these functions, we get the following results (with julia -p 4):","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> q = SharedArray{Float64,3}((500,500,500));\n\njulia> u = SharedArray{Float64,3}((500,500,500));","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Run the functions once to JIT-compile and @time them on the second run:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> @time advection_serial!(q, u);\n(irange,jrange,trange) = (1:500,1:500,1:499)\n 830.220 milliseconds (216 allocations: 13820 bytes)\n\njulia> @time advection_parallel!(q, u);\n   2.495 seconds      (3999 k allocations: 289 MB, 2.09% gc time)\n\njulia> @time advection_shared!(q,u);\n        From worker 2:       (irange,jrange,trange) = (1:500,1:125,1:499)\n        From worker 4:       (irange,jrange,trange) = (1:500,251:375,1:499)\n        From worker 3:       (irange,jrange,trange) = (1:500,126:250,1:499)\n        From worker 5:       (irange,jrange,trange) = (1:500,376:500,1:499)\n 238.119 milliseconds (2264 allocations: 169 KB)","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"The biggest advantage of advection_shared! is that it minimizes traffic among the workers, allowing each to compute for an extended time on the assigned piece.","category":"page"},{"location":"manual/parallel-computing.html#Shared-Arrays-and-Distributed-Garbage-Collection-1","page":"並列コンピューティング","title":"Shared Arrays and Distributed Garbage Collection","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Like remote references, shared arrays are also dependent on garbage collection on the creating node to release references from all participating workers. Code which creates many short lived shared array objects would benefit from explicitly finalizing these objects as soon as possible.  This results in both memory and file handles mapping the shared segment being released sooner.","category":"page"},{"location":"manual/parallel-computing.html#クラスタマネージャ-1","page":"並列コンピューティング","title":"クラスタマネージャ","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia プロセスの起動、管理、および論理クラスタへのネットワーキングは、クラスタ マネージャを介して行われます。ClusterManager が担当するのは","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"クラスタ環境でワーカープロセスを起動する\n各ワーカーの有効期間中のイベントの管理\n必要に応じて、データ転送を提供する","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia クラスターには、次の特徴があります:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"masterとも呼ばれる最初のJuliaプロセスは特別であり、1のidを持っています。\nワーカープロセスを追加または削除できるのはmasterプロセスだけです。\nすべてのプロセスは、互いに直接通信できます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"(組み込みの TCP/IP トランスポートを使用して) ワーカー間の接続は、次の方法で確立されます:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"addprocs は、ClusterManager オブジェクトを持つマスター・プロセスで呼び出されます。\naddprocs は、要求された数のワーカープロセスを適切なマシン上で起動する適切な launch メソッドを呼び出します。\n各ワーカーは空きポートでリッスンを開始し、ホストとポートの情報を stdoutに書き出します。\nクラスタ マネージャは、各ワーカーの stdoutをキャプチャし、マスタープロセスで使用できるようにします。\nマスタ プロセスは、この情報を解析し、各ワーカーへの TCP/IP 接続を設定します。\nすべてのワーカーには、クラスター内の他のワーカーの情報が知らされます。\n各ワーカーは、id がそのワーカー自身の id より小さいすべてのワーカーに接続します。\nこのようにしてメッシュ ネットワークが確立され、すべてのワーカーが他のすべてのワーカーと直接接続されます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"既定のトランスポート層では、プレーン TCPSocketが使われますが、Julia クラスターが独自のトランスポートを提供する場合があります。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia は、次の 2 つの組み込みクラスタ マネージャを提供します:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"LocalManager:   addprocs() もしくは addprocs(np::Integer) が呼び出された時に使われます\nSSHManager:  addprocs(hostnames::Array) が hostname のリストを伴って呼び出された時に使われます","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"LocalManager は、同じホスト上で追加のワーカーを起動するために使用され、マルチコアおよびマルチプロセッサ ハードウェアを活用します。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"したがって、最小限のクラスタ マネージャーは次のことが必要になります:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"抽象型 ClusterManager のサブタイプである\n新しいワーカーを立ち上げるメソッド launch を実装する\nワーカーの有効期間中にさまざまなイベントで呼び出される manage を実装する (例えば、割り込み信号の送信など)","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"addprocs(manager::FooManager) が正しく処理されるためには FooManager に次の関数が実装されている必要があります:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"function launch(manager::FooManager, params::Dict, launched::Array, c::Condition)\n    [...]\nend\n\nfunction manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)\n    [...]\nend","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"例として、同じホストでワーカーを開始するマネージャLocalManagerがどのように実装されているかを見てみましょう:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"struct LocalManager <: ClusterManager\n    np::Integer\nend\n\nfunction launch(manager::LocalManager, params::Dict, launched::Array, c::Condition)\n    [...]\nend\n\nfunction manage(manager::LocalManager, id::Integer, config::WorkerConfig, op::Symbol)\n    [...]\nend","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"launch メソッドは、次の引数を受け取ります:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"manager::ClusterManager: このクラスターマネージャを用いて、addprocs が呼ばれます\nparams::Dict: addprocsに渡されるすべてのキーワード引数を格納します\nlaunched::Array: 1 つ以上の WorkerConfigオブジェクトを追加する配列\nc::Condition: ワーカーが起動されたときに通知される条件変数","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"launch メソッドは、独立したタスクで非同期的に呼び出されます。このタスクが終了したということは、要求されたすべてのワーカーが起動されたということです。したがって、launch 関数は、要求されたすべてのワーカーが起動されるとすぐに終了する必要があります。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"新しく起動されたワーカーは、互いにワーカー同士で、そしてマスタープロセスと 網羅的に接続されます。 コマンドライン引数 --worker[=<cookie>]を指定すると、起動されたプロセスが自分自身をワーカーとして初期化し、接続がTCP/IP ソケットを介してセットアップされます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"クラスター内のすべてのワーカーは、マスターと同じ cookie を共有します。 クッキーが指定されていない、つまり--workerオプションを使用すると、ワーカーは標準入力からクッキーを読み取ろうとします。  LocalManagerとSSHManagerの両方が、新しく立ち上げたワーカーに標準入力を介してクッキーを渡します。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"既定では、ワーカーは getipaddr()の呼び出しによって返されるアドレスで空きポートをリッスンします。 リッスンする特定のアドレスは、オプション引数 --bind-to bind_addr[:port]で指定できます。 これは、マルチホームド(複数のネットワークアドレスを持つ)ホストでの利用に役立ちます。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"TCP/IPトランスポート以外の例としては、MPI を利用した実装が考えられます。MPI利用においては、--worker オプションによる指定を使っていはいけません。全ての並行処理の構成要素が用いられる前に、新しく起動したワーカーは、init_worker(cookie) を呼び Cookieの指定をしなくてはなりません。","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"起動するすべてのワーカーに対して、launch メソッドは、(適切なフィールドを初期化した) workerConfig オブジェクト を launched に追加する必要があります","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"mutable struct WorkerConfig\n    # Common fields relevant to all cluster managers\n    io::Union{IO, Nothing}\n    host::Union{AbstractString, Nothing}\n    port::Union{Integer, Nothing}\n\n    # Used when launching additional workers at a host\n    count::Union{Int, Symbol, Nothing}\n    exename::Union{AbstractString, Cmd, Nothing}\n    exeflags::Union{Cmd, Nothing}\n\n    # External cluster managers can use this to store information at a per-worker level\n    # Can be a dict if multiple fields need to be stored.\n    userdata::Any\n\n    # SSHManager / SSH tunnel connections to workers\n    tunnel::Union{Bool, Nothing}\n    bind_addr::Union{AbstractString, Nothing}\n    sshflags::Union{Cmd, Nothing}\n    max_parallel::Union{Integer, Nothing}\n\n    # Used by Local/SSH managers\n    connect_at::Any\n\n    [...]\nend","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"WorkerConfig のフィールドのほとんどは、組み込みのマネージャによって使用されます。独自実装のクラスタ マネージャーは、通常、io または host / port のみを指定します:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"io が指定されている場合は、ホスト/ポート情報の読み取りに使用されます。Julia のワーカーは、起動時にバインドされた IPアドレスとポートをプリント出力します。これにより、Julia ワーカーは、ワーカー のポートを手動で設定する代わりに、使用可能な任意の空きポートをリッスンできます。\nio が指定されていない場合は、host, port を使用して接続します。\ncount, exename , exeflags は、ワーカーから別の追加のワーカーを起動する機能に関連するもので。例えば、クラスターマネージャーがノード毎に1つのワーカーを起動し、そのワーカーに追加のワーカーを起動させることができます。\ncount は  整数値 nを指定すると、そのマシンで合計n 個のワーカーを起動します。\ncount に :auto値を指定すると、そのマシンのCPUスレッド(論理コア)数と同じだけのワーカーを起動します。\nexename は、フルパスを含む juliaプログラムの名前です。\nexeflags には、新しいワーカに必要なコマンドライン引数を設定する必要があります。.\ntunnel, bind_addr, sshflags , max_parallel は、ssh トンネルがマスタープロセスからワーカーに接続する必要があるときに用いられます\nuserdata は、独自実装のクラスターマネージャーが、ワーカー固有の情報を取得・保持する目的で提供されます","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol) is called at different times during the worker's lifetime with appropriate op values:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"with :register/:deregister when a worker is added / removed from the Julia worker pool.\nwith :interrupt when interrupt(workers) is called. The ClusterManager should signal the appropriate worker with an interrupt signal.\nwith :finalize for cleanup purposes.","category":"page"},{"location":"manual/parallel-computing.html#カスタム-トランスポートを使用したクラスタ-マネージャ-1","page":"並列コンピューティング","title":"カスタム トランスポートを使用したクラスタ マネージャ","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Replacing the default TCP/IP all-to-all socket connections with a custom transport layer is a little more involved. Each Julia process has as many communication tasks as the workers it is connected to. For example, consider a Julia cluster of 32 processes in an all-to-all mesh network:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Each Julia process thus has 31 communication tasks.\nEach task handles all incoming messages from a single remote worker in a message-processing loop.\nThe message-processing loop waits on an IO object (for example, a TCPSocket in the default implementation), reads an entire message, processes it and waits for the next one.\nSending messages to a process is done directly from any Julia task–not just communication tasks–again, via the appropriate IO object.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Replacing the default transport requires the new implementation to set up connections to remote workers and to provide appropriate IO objects that the message-processing loops can wait on.  The manager-specific callbacks to be implemented are:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"connect(manager::FooManager, pid::Integer, config::WorkerConfig)\nkill(manager::FooManager, pid::Int, config::WorkerConfig)","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"The default implementation (which uses TCP/IP sockets) is implemented as connect(manager::ClusterManager, pid::Integer, config::WorkerConfig).","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"connect should return a pair of IO objects, one for reading data sent from worker pid, and the other to write data that needs to be sent to worker pid. Custom cluster managers can use an in-memory BufferStream as the plumbing to proxy data between the custom, possibly non-IO transport and Julia's in-built parallel infrastructure.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"A BufferStream is an in-memory IOBuffer which behaves like an IO–it is a stream which can be handled asynchronously.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"The folder clustermanager/0mq in the Examples repository  contains an example of using ZeroMQ to connect Julia workers in a star topology with a 0MQ broker in the middle. Note: The Julia processes are still all logically connected to each other–any worker can message any other worker directly without any awareness of 0MQ being used as the transport layer.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"When using custom transports:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia workers must NOT be started with --worker. Starting with --worker will result in the newly launched workers defaulting to the TCP/IP socket transport implementation.\nFor every incoming logical connection with a worker, Base.process_messages(rd::IO, wr::IO)() must be called. This launches a new task that handles reading and writing of messages from/to the worker represented by the IO objects.\ninit_worker(cookie, manager::FooManager) must be called as part of worker process initialization.\nField connect_at::Any in WorkerConfig can be set by the cluster manager when launch  is called. The value of this field is passed in in all connect callbacks. Typically, it carries information on how to connect to a worker. For example, the TCP/IP socket transport uses this field to specify the (host, port) tuple at which to connect to a worker.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"kill(manager, pid, config) is called to remove a worker from the cluster. On the master process, the corresponding IO objects must be closed by the implementation to ensure proper cleanup.  The default implementation simply executes an exit() call on the specified remote worker.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"The Examples folder clustermanager/simple is an example that shows a simple implementation using UNIX domain sockets for cluster setup.","category":"page"},{"location":"manual/parallel-computing.html#LocalManager-と-SSHManager-のネットワーク要件-1","page":"並列コンピューティング","title":"LocalManager と SSHManager のネットワーク要件","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Julia のクラスターは、ローカルラップトップ、部門のクラスタ、クラウドなどのインフラ上で既にセキュリティで保護されている環境を想定して設計されています。　この節では、組み込みのLocalManager と SSHManagerのネットワークのセキュリティ要件について説明します:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"The master process does not listen on any port. It only connects out to the workers.\nEach worker binds to only one of the local interfaces and listens on an ephemeral port number assigned by the OS.\nLocalManager, used by addprocs(N), by default binds only to the loopback interface. This means that workers started later on remote hosts (or by anyone with malicious intentions) are unable to connect to the cluster. An addprocs(4) followed by an addprocs([\"remote_host\"]) will fail.  Some users may need to create a cluster comprising their local system and a few remote systems.  This can be done by explicitly requesting LocalManager to bind to an external network interface via the restrict keyword argument: addprocs(4; restrict=false).\nSSHManager, used by addprocs(list_of_remote_hosts), launches workers on remote hosts via SSH.  By default SSH is only used to launch Julia workers. Subsequent master-worker and worker-worker connections use plain, unencrypted TCP/IP sockets. The remote hosts must have passwordless login enabled. Additional SSH flags or credentials may be specified via keyword argument sshflags.\naddprocs(list_of_remote_hosts; tunnel=true, sshflags=<ssh keys and other flags>) is useful when we wish to use SSH connections for master-worker too. A typical scenario for this is a local laptop running the Julia REPL (i.e., the master) with the rest of the cluster on the cloud, say on Amazon EC2. In this case only port 22 needs to be opened at the remote cluster coupled with SSH client authenticated via public key infrastructure (PKI). Authentication credentials can be supplied via sshflags, for example sshflags=`-i <keyfile>`.\nIn an all-to-all topology (the default), all workers connect to each other via plain TCP sockets. The security policy on the cluster nodes must thus ensure free connectivity between workers for the ephemeral port range (varies by OS).\nSecuring and encrypting all worker-worker traffic (via SSH) or encrypting individual messages can be done via a custom ClusterManager.","category":"page"},{"location":"manual/parallel-computing.html#man-cluster-cookie-1","page":"並列コンピューティング","title":"クラスタークッキー","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"cluster_cookie() returns the cookie, while cluster_cookie(cookie)() sets it and returns the new cookie.\nAll connections are authenticated on both sides to ensure that only workers started by the master are allowed to connect to each other.\nThe cookie may be passed to the workers at startup via argument --worker=<cookie>. If argument --worker is specified without the cookie, the worker tries to read the cookie from its standard input (stdin). The stdin is closed immediately after the cookie is retrieved.\nClusterManagers can retrieve the cookie on the master by calling cluster_cookie().  Cluster managers not using the default TCP/IP transport (and hence not specifying --worker)  must call init_worker(cookie, manager) with the same cookie as on the master.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Note that environments requiring higher levels of security can implement this via a custom ClusterManager.  For example, cookies can be pre-shared and hence not specified as a startup argument.","category":"page"},{"location":"manual/parallel-computing.html#ネットワーク-トポロジの指定-(実験的実装)-1","page":"並列コンピューティング","title":"ネットワーク トポロジの指定 (実験的実装)","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"The keyword argument topology passed to addprocs is used to specify how the workers must be connected to each other:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":":all_to_all, the default: all workers are connected to each other.\n:master_worker: only the driver process, i.e. pid 1, has connections to the workers.\n:custom: the launch method of the cluster manager specifies the connection topology via the fields ident and connect_idents in WorkerConfig. A worker with a cluster-manager-provided identity ident will connect to all workers specified in connect_idents.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Keyword argument lazy=true|false only affects topology option :all_to_all. If true, the cluster starts off with the master connected to all workers. Specific worker-worker connections are established at the first remote invocation between two workers. This helps in reducing initial resources allocated for intra-cluster communication. Connections are setup depending on the runtime requirements of a parallel program. Default value for lazy is true.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Currently, sending a message between unconnected workers results in an error. This behaviour, as with the functionality and interface, should be considered experimental in nature and may change in future releases.","category":"page"},{"location":"manual/parallel-computing.html#注目に値する外部パッケージ-1","page":"並列コンピューティング","title":"注目に値する外部パッケージ","text":"","category":"section"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Outside of Julia parallelism there are plenty of external packages that should be mentioned.  For example MPI.jl is a Julia wrapper for the MPI protocol, or DistributedArrays.jl, as presented in Shared Arrays.  A mention must be made of Julia's GPU programming ecosystem, which includes:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Low-level (C kernel) based operations OpenCL.jl and CUDAdrv.jl which are respectively an OpenCL interface and a CUDA wrapper.\nLow-level (Julia Kernel) interfaces like CUDAnative.jl which is a Julia native CUDA implementation.\nHigh-level vendor-specific abstractions like CuArrays.jl and CLArrays.jl\nHigh-level libraries like ArrayFire.jl and GPUArrays.jl","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"In the following example we will use both DistributedArrays.jl and CuArrays.jl to distribute an array across multiple processes by first casting it through distribute() and CuArray().","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Remember when importing DistributedArrays.jl to import it across all processes using @everywhere","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"$ ./julia -p 4\n\njulia> addprocs()\n\njulia> @everywhere using DistributedArrays\n\njulia> using CuArrays\n\njulia> B = ones(10_000) ./ 2;\n\njulia> A = ones(10_000) .* π;\n\njulia> C = 2 .* A ./ B;\n\njulia> all(C .≈ 4*π)\ntrue\n\njulia> typeof(C)\nArray{Float64,1}\n\njulia> dB = distribute(B);\n\njulia> dA = distribute(A);\n\njulia> dC = 2 .* dA ./ dB;\n\njulia> all(dC .≈ 4*π)\ntrue\n\njulia> typeof(dC)\nDistributedArrays.DArray{Float64,1,Array{Float64,1}}\n\njulia> cuB = CuArray(B);\n\njulia> cuA = CuArray(A);\n\njulia> cuC = 2 .* cuA ./ cuB;\n\njulia> all(cuC .≈ 4*π);\ntrue\n\njulia> typeof(cuC)\nCuArray{Float64,1}","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Keep in mind that some Julia features are not currently supported by CUDAnative.jl [2] , especially some functions like sin will need to be replaced with CUDAnative.sin(cc: @maleadt).","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"In the following example we will use both DistributedArrays.jl and CuArrays.jl to distribute an array across multiple processes and call a generic function on it.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"function power_method(M, v)\n    for i in 1:100\n        v = M*v\n        v /= norm(v)\n    end\n\n    return v, norm(M*v) / norm(v)  # or  (M*v) ./ v\nend","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"power_method repeatedly creates a new vector and normalizes it. We have not specified any type signature in function declaration, let's see if it works with the aforementioned datatypes:","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"julia> M = [2. 1; 1 1];\n\njulia> v = rand(2)\n2-element Array{Float64,1}:\n0.40395\n0.445877\n\njulia> power_method(M,v)\n([0.850651, 0.525731], 2.618033988749895)\n\njulia> cuM = CuArray(M);\n\njulia> cuv = CuArray(v);\n\njulia> curesult = power_method(cuM, cuv);\n\njulia> typeof(curesult)\nCuArray{Float64,1}\n\njulia> dM = distribute(M);\n\njulia> dv = distribute(v);\n\njulia> dC = power_method(dM, dv);\n\njulia> typeof(dC)\nTuple{DistributedArrays.DArray{Float64,1,Array{Float64,1}},Float64}","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"To end this short exposure to external packages, we can consider MPI.jl, a Julia wrapper of the MPI protocol. As it would take too long to consider every inner function, it would be better to simply appreciate the approach used to implement the protocol.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"Consider this toy script which simply calls each subprocess, instantiate its rank and when the master process is reached, performs the ranks' sum","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"import MPI\n\nMPI.Init()\n\ncomm = MPI.COMM_WORLD\nMPI.Barrier(comm)\n\nroot = 0\nr = MPI.Comm_rank(comm)\n\nsr = MPI.Reduce(r, MPI.SUM, root, comm)\n\nif(MPI.Comm_rank(comm) == root)\n   @printf(\"sum of ranks: %s\\n\", sr)\nend\n\nMPI.Finalize()","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"mpirun -np 4 ./julia example.jl","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"[1]: In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding rma to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see https://mpi-forum.org/docs.","category":"page"},{"location":"manual/parallel-computing.html#","page":"並列コンピューティング","title":"並列コンピューティング","text":"[2]: Julia GPU man pages","category":"page"},{"location":"manual/running-external-programs.html#Running-External-Programs-1","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"","category":"section"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"Julia は、 shell, Perl, Ruby と同じく、バックティック (\"...\")表記をコマンド呼び出しに使います。しかし Julia では","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> `echo hello`\n`echo hello`","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"と書くのは、いくつもの側面で、いろいろなshell, Perl, あるいは Ruby の振る舞いとは異なります:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"バックティックは、すぐにコマンドを実行するのではなく、コマンドを表す、Cmd オブジェクトを生成します。このオブジェクトを用いて、そのコマンドと他のコマンドをパイプで接続し、それを実行したり、読んだり、書いたりできます。\nコマンドを実行すると、特にそのように手配しない限りは、Julia はその出力を補足しません。代わりに、デフォルトでコマンドの出力はlibcの system でコマンドを呼び出しを使用するのと同様にstdoutに出力されます。\nコマンドはシェルで実行されることはありません。代わりに、Julia はコマンド構文を直接解析し、変数を適切に展開し、シェルの引用符構文を尊重して、シェルのように単語を分割します。 コマンドは、forkと execの呼び出しを使用して、Julia の直接の子プロセスとして実行されます。","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"外部プログラムを実行する簡単な例を次に示します:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> mycommand = `echo hello`\n`echo hello`\n\njulia> typeof(mycommand)\nCmd\n\njulia> run(mycommand);\nhello","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"hello は echo コマンドの出力が、stdoutに送られたものです。run メソッドそれ自体は、nothingを返し、もし外部コマンドがうまく実行されなかったときには、ErrorExceptionを投げます。","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"外部コマンドの出力を読み取る場合は、代わりに read を使用します:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> a = read(`echo hello`, String)\n\"hello\\n\"\n\njulia> chomp(a) == \"hello\"\ntrue","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"より一般的には、openを使用して、外部コマンドの読み取りまたは書き込みを行うことができます。","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> open(`less`, \"w\", stdout) do io\n           for i = 1:3\n               println(io, i)\n           end\n       end\n1\n2\n3","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"コマンド内のプログラム名と個々の引数は、コマンドが文字列の配列であるかのように、アクセス・反復処理ができます:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> collect(`echo \"foo bar\"`)\n2-element Array{String,1}:\n \"echo\"\n \"foo bar\"\n\njulia> `echo \"foo bar\"`[2]\n\"foo bar\"","category":"page"},{"location":"manual/running-external-programs.html#command-interpolation-1","page":"外部プログラムの実行","title":"式展開","text":"","category":"section"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"何かもう少し複雑なことをやりたい場合を想定してみましょう。変数 file に格納されたファイル名をコマンド引数として使いたいとします。このばあい、文字列リテラルでやったのと同じように$ を式展開に使う事ができます。( 文字列参照):","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> file = \"/etc/passwd\"\n\"/etc/passwd\"\n\njulia> `sort $file`\n`sort /etc/passwd`","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"外部コマンドをシェル経由で実行するばあいによく陥る落とし穴は、ファイル名が シェルにとって特別な文字を含む場合に、望まない減少がおきることです。例えば、/etc/passwd でなく、/Volumes/External HD/data.csv の中身をソートしたい場合を想定してみます。やってみましょう:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> file = \"/Volumes/External HD/data.csv\"\n\"/Volumes/External HD/data.csv\"\n\njulia> `sort $file`\n`sort '/Volumes/External HD/data.csv'`","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"How did the file name get quoted? Julia knows that file is meant to be interpolated as a single argument, so it quotes the word for you. Actually, that is not quite accurate: the value of file is never interpreted by a shell, so there's no need for actual quoting; the quotes are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> path = \"/Volumes/External HD\"\n\"/Volumes/External HD\"\n\njulia> name = \"data\"\n\"data\"\n\njulia> ext = \"csv\"\n\"csv\"\n\njulia> `sort $path/$name.$ext`\n`sort '/Volumes/External HD/data.csv'`","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"As you can see, the space in the path variable is appropriately escaped. But what if you want to interpolate multiple words? In that case, just use an array (or any other iterable container):","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> files = [\"/etc/passwd\",\"/Volumes/External HD/data.csv\"]\n2-element Array{String,1}:\n \"/etc/passwd\"\n \"/Volumes/External HD/data.csv\"\n\njulia> `grep foo $files`\n`grep foo /etc/passwd '/Volumes/External HD/data.csv'`","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"If you interpolate an array as part of a shell word, Julia emulates the shell's {a,b,c} argument generation:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> names = [\"foo\",\"bar\",\"baz\"]\n3-element Array{String,1}:\n \"foo\"\n \"bar\"\n \"baz\"\n\njulia> `grep xylophone $names.txt`\n`grep xylophone foo.txt bar.txt baz.txt`","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"Moreover, if you interpolate multiple arrays into the same word, the shell's Cartesian product generation behavior is emulated:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> names = [\"foo\",\"bar\",\"baz\"]\n3-element Array{String,1}:\n \"foo\"\n \"bar\"\n \"baz\"\n\njulia> exts = [\"aux\",\"log\"]\n2-element Array{String,1}:\n \"aux\"\n \"log\"\n\njulia> `rm -f $names.$exts`\n`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"Since you can interpolate literal arrays, you can use this generative functionality without needing to create temporary array objects first:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> `rm -rf $[\"foo\",\"bar\",\"baz\",\"qux\"].$[\"aux\",\"log\",\"pdf\"]`\n`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`","category":"page"},{"location":"manual/running-external-programs.html#Quoting-1","page":"外部プログラムの実行","title":"Quoting","text":"","category":"section"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary to use quotes. Here's a simple example of a Perl one-liner at a shell prompt:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"sh$ perl -le '$|=1; for (0..3) { print }'\n0\n1\n2\n3","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"The Perl expression needs to be in single quotes for two reasons: so that spaces don't break the expression into multiple shell words, and so that uses of Perl variables like $| (yes, that's the name of a variable in Perl), don't cause interpolation. In other instances, you may want to use double quotes so that interpolation does occur:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"sh$ first=\"A\"\nsh$ second=\"B\"\nsh$ perl -le '$|=1; print for @ARGV' \"1: $first\" \"2: $second\"\n1: A\n2: B","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the shell's. The only difference is that the interpolation is integrated and aware of Julia's notion of what is a single string value, and what is a container for multiple values. Let's try the above two examples in Julia:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> A = `perl -le '$|=1; for (0..3) { print }'`\n`perl -le '$|=1; for (0..3) { print }'`\n\njulia> run(A);\n0\n1\n2\n3\n\njulia> first = \"A\"; second = \"B\";\n\njulia> B = `perl -le 'print for @ARGV' \"1: $first\" \"2: $second\"`\n`perl -le 'print for @ARGV' '1: A' '2: B'`\n\njulia> run(B);\n1: A\n2: B","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"The results are identical, and Julia's interpolation behavior mimics the shell's with some improvements due to the fact that Julia supports first-class iterable objects while most shells use strings split on spaces for this, which introduces ambiguities. When trying to port shell commands to Julia, try cut and pasting first. Since Julia shows commands to you before running them, you can easily and safely just examine its interpretation without doing any damage.","category":"page"},{"location":"manual/running-external-programs.html#Pipelines-1","page":"外部プログラムの実行","title":"Pipelines","text":"","category":"section"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"Shell metacharacters, such as |, &, and >, need to be quoted (or escaped) inside of Julia's backticks:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> run(`echo hello '|' sort`);\nhello | sort\n\njulia> run(`echo hello \\| sort`);\nhello | sort","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"This expression invokes the echo command with three words as arguments: hello, |, and sort.  The result is that a single line is printed: hello | sort. How, then, does one construct a pipeline? Instead of using '|' inside of backticks, one uses pipeline:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> run(pipeline(`echo hello`, `sort`));\nhello","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"This pipes the output of the echo command to the sort command. Of course, this isn't terribly interesting since there's only one line to sort, but we can certainly do much more interesting things:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))\n210\n211\n212\n213\n214","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"This prints the highest five user IDs on a UNIX system. The cut, sort and tail commands are all spawned as immediate children of the current julia process, with no intervening shell process. Julia itself does the work to setup pipes and connect file descriptors that is normally done by the shell. Since Julia does this itself, it retains better control and can do some things that shells cannot.","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"Julia can run multiple commands in parallel:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> run(`echo hello` & `echo world`);\nworld\nhello","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"The order of the output here is non-deterministic because the two echo processes are started nearly simultaneously, and race to make the first write to the stdout descriptor they share with each other and the julia parent process. Julia lets you pipe the output from both of these processes to another program:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> run(pipeline(`echo world` & `echo hello`, `sort`));\nhello\nworld","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"In terms of UNIX plumbing, what's happening here is that a single UNIX pipe object is created and written to by both echo processes, and the other end of the pipe is read from by the sort command.","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"IO redirection can be accomplished by passing keyword arguments stdin, stdout, and stderr to the pipeline function:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"pipeline(`do_work`, stdout=pipeline(`sort`, \"out.txt\"), stderr=\"errs.txt\")","category":"page"},{"location":"manual/running-external-programs.html#Avoiding-Deadlock-in-Pipelines-1","page":"外部プログラムの実行","title":"Avoiding Deadlock in Pipelines","text":"","category":"section"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"When reading and writing to both ends of a pipeline from a single process, it is important to avoid forcing the kernel to buffer all of the data.","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"For example, when reading all of the output from a command, call read(out, String), not wait(process), since the former will actively consume all of the data written by the process, whereas the latter will attempt to store the data in the kernel's buffers while waiting for a reader to be connected.","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"Another common solution is to separate the reader and writer of the pipeline into separate Tasks:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"writer = @async write(process, \"data\")\nreader = @async do_compute(read(process, String))\nwait(process)\nfetch(reader)","category":"page"},{"location":"manual/running-external-programs.html#Complex-Example-1","page":"外部プログラムの実行","title":"Complex Example","text":"","category":"section"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"The combination of a high-level programming language, a first-class command abstraction, and automatic setup of pipes between processes is a powerful one. To give some sense of the complex pipelines that can be created easily, here are some more sophisticated examples, with apologies for the excessive use of Perl one-liners:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> prefixer(prefix, sleep) = `perl -nle '$|=1; print \"'$prefix' \", $_; sleep '$sleep';'`;\n\njulia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`, prefixer(\"A\",2) & prefixer(\"B\",2)));\nB 0\nA 1\nB 2\nA 3\nB 4\nA 5","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"This is a classic example of a single producer feeding two concurrent consumers: one perl process generates lines with the numbers 0 through 5 on them, while two parallel processes consume that output, one prefixing lines with the letter \"A\", the other with the letter \"B\". Which consumer gets the first line is non-deterministic, but once that race has been won, the lines are consumed alternately by one process and then the other. (Setting $|=1 in Perl causes each print statement to flush the stdout handle, which is necessary for this example to work. Otherwise all the output is buffered and printed to the pipe at once, to be read by just one consumer process.)","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"Here is an even more complex multi-stage producer-consumer example:","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"julia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`,\n           prefixer(\"X\",3) & prefixer(\"Y\",3) & prefixer(\"Z\",3),\n           prefixer(\"A\",2) & prefixer(\"B\",2)));\nA X 0\nB Y 1\nA Z 2\nB X 3\nA Y 4\nB Z 5","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"This example is similar to the previous one, except there are two stages of consumers, and the stages have different latency so they use a different number of parallel workers, to maintain saturated throughput.","category":"page"},{"location":"manual/running-external-programs.html#","page":"外部プログラムの実行","title":"外部プログラムの実行","text":"We strongly encourage you to try all these examples to see how they work.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Calling-C-and-Fortran-Code-1","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"ほとんどのコードは Julia で記述できますが、C と Fortran で既に記述されている数値計算用の高品質で成熟したライブラリが多数あります。この既存のコードを簡単に使用できるように、Julia は C 関数と Fortran 関数を簡単かつ効率的に呼び出すことができます。Julia は「定型文なし」の哲学を持っています:関数は「接着剤」コードやコード生成もしくはコンパイルなしでJulia から直接呼び出すことができます。– 対話プロンプトからでも、です。通常の関数呼び出しのように見える ccall 構文を使用して適切な呼び出しを行うだけで実現することができます。","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Julia から呼び出されるコードは、共有ライブラリとして使用できなければなりません。ほとんどの C ライブラリと Fortran ライブラリは既に共有ライブラリとしてコンパイルされていますが、GCC (または Clang) を使用してコードを自分でコンパイルする場合は、-shared および fPIC オプションを使用してください。Julia の JIT によって生成されるマシン命令はネイティブ C 呼び出しと同じなので、結果として生じるオーバーヘッドは C コードからライブラリ関数を呼び出すのと同じです。(C と Julia の両方の非ライブラリ関数呼び出しはインライン化できるため、共有ライブラリ関数の呼び出しよりもオーバーヘッドが少ない場合があります。ライブラリと実行可能ファイルの両方が LLVM によって生成される場合、この境界を越えて最適化できるプログラム全体の最適化を実行することもできますが、Julia はまだサポートしていません。ただし、将来的にはそれが行えるようになり、パフォーマンスがさらに向上する可能性があります。）","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"共有ライブラリと関数は、(:function, \"library\") or (\"function\", \"library\") の書式のタプルで参照できます。ここで 、function は、C出エクスポートされた関数名、library` は共有ライブラリの名前です: ライブラリ読み込みパス(プラットフォーム固有の物も含む)中の共用ライブラリーはその名前のみで解決されますが、必要に応じて直接パスを指定することもできます。","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"関数名は、タプルの代わりに単独で(単に :function または \"function\" として) 使用できます。この場合、名前は現在のプロセス内で解決されます。この形式を使用できるのは、C ライブラリ関数、Julia ランタイムの関数、または Julia にリンクされたアプリケーションの関数のいずれかを呼び出す時です。","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"デフォルトでは、Fortran コンパイラはマングリングされた名前を生成するので (たとえば、関数名を小文字または大文字に変換し、アンダースコアを追加する）、ccall経由でFortranの関数を呼ぶためには、Fortran コンパイラが従うルールに対応してマングリングされた関数名を渡す必要があります。 また、Fortran 関数を呼び出す時は、すべての入力をヒープまたはスタックに割り当てられた値へのポインターとして渡す必要があります。これは、通常ヒープ割り当てされる配列やその他のミュータブルなオブジェクトだけでなく、通常スタック割り当てられ、C または Julia 呼び出し規約を使用する時にレジスタに一般的に渡される整数や浮動小数点数などのスカラー値についても同様です。","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"最後に、ccallを使用して、ライブラリ関数の呼び出しを行う実際に生成することができます。ccallの引数は次のとおりです:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"(:function, \"library\") を定数リテラルとして書く,\nもしくは\n:functionと関数名シンボルで書くか、\"function\" と関数名文字列として書き、現在のプロセスの内部で解決する,\nもしくは\n関数ポインタ(例えば、dlsym 関数から).\n戻り値の型（Cの型からJuliaへのマッピングについては後述）\nこの引数は、対象のメソッドが定義されたとき、コンパイル時に評価されます。\nA tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression.\nこの引数は、対象のメソッドが定義されたとき、コンパイル時に評価されます。\nそのあとに続く引数(もしあれば)は、その関数に実際に渡される引数の値です。","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"上記全ての内容を含むシンプルな例ですが、次の関数は標準 C ライブラリから clock 関数を呼び出します:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"julia> t = ccall((:clock, \"libc\"), Int32, ())\n2292761\n\njulia> t\n2292761\n\njulia> typeof(ans)\nInt32","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"clock は引数を受け取らず、Int32を返します。よくある落とし穴1 つは、1要素の タプルにも末尾のコンマが必要になる点です。たとえば、getenv 関数を呼び出して環境変数の値へのポインターを取得するには、次のような呼び出しを行います:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"julia> path = ccall((:getenv, \"libc\"), Cstring, (Cstring,), \"SHELL\")\nCstring(@0x00007fff5fbffc45)\n\njulia> unsafe_string(path)\n\"/bin/bash\"","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Note that the argument type tuple must be written as (Cstring,), rather than (Cstring). This is because (Cstring) is just the expression Cstring surrounded by parentheses, rather than a 1-tuple containing Cstring:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"julia> (Cstring)\nCstring\n\njulia> (Cstring,)\n(Cstring,)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"実際には、特に再利用可能な機能を提供する場合の話ですが、ccallを使用するコードに対して、引数を設定して、CまたはFortranのターゲット関数の振る舞いのエラーチェックをして、例外をJulia側にまで伝播させるようなラッパー関数を準備することが多いです。C API と Fortran API は、エラー条件を示す方法に関して一貫性がないため、これは特に重要です。たとえば、getenv C ライブラリ関数は、env.jl から実際の定義の簡略化されたバージョンである次の Julia 関数にラップされます:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"function getenv(var::AbstractString)\n    val = ccall((:getenv, \"libc\"),\n                Cstring, (Cstring,), var)\n    if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n    end\n    unsafe_string(val)\nend","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"C言語の getenv 関数は NULL を返すことによってエラーを示しますが、他の標準 C 関数は-1、0、1 およびその他の特殊値を返すなど、さまざまな方法でエラーを示します。 このラッパーは、呼び出し元が存在しない環境変数を取得しようとした場合に問題を明確に示す例外をスローします:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"julia> getenv(\"SHELL\")\n\"/bin/bash\"\n\njulia> getenv(\"FOOBAR\")\ngetenv: undefined variable: FOOBAR","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"ローカル マシンのホスト名を検出するもう少し複雑な例を次に示します:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"function gethostname()\n    hostname = Vector{UInt8}(undef, 128)\n    ccall((:gethostname, \"libc\"), Int32,\n          (Ptr{UInt8}, Csize_t),\n          hostname, sizeof(hostname))\n    hostname[end] = 0; # ensure null-termination\n    return unsafe_string(pointer(hostname))\nend","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"次の使用例は、最初にバイトの配列を割り当て、次に C ライブラリ関数 gethostname を呼び出して配列をホスト名で埋め、ホスト名バッファーへのポインターを取得し、NULL 終端 C 文字列であると仮定してJulia 文字列にポインタを変換します。C ライブラリでは、呼び出し元にメモリを割り当てて、呼び出し先に渡して入力するように要求するこのパターンを使用するのが一般的です。このような Julia からのメモリの割り当ては、一般に、初期化されていない配列を作成し、そのデータへのポインタを C 関数に渡すことによって行われます。配列が初期化されていないため、NULL バイトを含むことができるため、ここで Cstring 型を使用しない理由です。ccallの一部としてCstringに変換すると、含まれる NULL バイトがチェックされるため、変換エラーがスローされる可能性があります。","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#C言語コンパチな-Julia関数のポインタをつくる-1","page":"C, Fortran コードの呼び出し","title":"C言語コンパチな Julia関数のポインタをつくる","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"It is possible to pass Julia functions to native C functions that accept function pointer arguments.  For example, to match C prototypes of the form:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"typedef returntype (*functiontype)(argumenttype, ...)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The macro @cfunction generates the C-compatible function pointer for a call to a Julia function. Arguments to @cfunction are as follows:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"A Julia Function\nReturn type\nA literal tuple of input types","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Like ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Currently, only the platform-default C calling convention is supported. This means that @cfunction-generated pointers cannot be used in calls where WINAPI expects stdcall function on 32-bit windows, but can be used on WIN64 (where stdcall is unified with the C calling convention).","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"A classic example is the standard C library qsort function, declared as:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"void qsort(void *base, size_t nmemb, size_t size,\n           int (*compare)(const void*, const void*));","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The base argument is a pointer to an array of length nmemb, with elements of size bytes each. compare is a callback function which takes pointers to two elements a and b and returns an integer less/greater than zero if a should appear before/after b (or zero if any order is permitted). Now, suppose that we have a 1d array A of values in Julia that we want to sort using the qsort function (rather than Julia's built-in sort function). Before we worry about calling qsort and passing arguments, we need to write a comparison function that works for some arbitrary objects (which define <):","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"julia> function mycompare(a, b)::Cint\n           return (a < b) ? -1 : ((a > b) ? +1 : 0)\n       end\nmycompare (generic function with 1 method)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Notice that we have to be careful about the return type: qsort expects a function returning a C int, so we annotate the return type of the function to be sure it returns a Cint.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"In order to pass this function to C, we obtain its address using the macro @cfunction:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"julia> mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"@cfunction requires three arguments: the Julia function (mycompare), the return type (Cint), and a literal tuple of the input argument types, in this case to sort an array of Cdouble (Float64) elements.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The final call to qsort looks like this:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"julia> A = [1.3, -2.7, 4.4, 3.1]\n4-element Array{Float64,1}:\n  1.3\n -2.7\n  4.4\n  3.1\n\njulia> ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),\n             A, length(A), sizeof(eltype(A)), mycompare_c)\n\njulia> A\n4-element Array{Float64,1}:\n -2.7\n  1.3\n  3.1\n  4.4","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"As can be seen, A is changed to the sorted array [-2.7, 1.3, 3.1, 4.4]. Note that Julia knows how to convert an array into a Ptr{Cdouble}, how to compute the size of a type in bytes (identical to C's sizeof operator), and so on. For fun, try inserting a println(\"mycompare($a, $b)\") line into mycompare, which will allow you to see the comparisons that qsort is performing (and to verify that it is really calling the Julia function that you passed to it).","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Mapping-C-Types-to-Julia-1","page":"C, Fortran コードの呼び出し","title":"Mapping C Types to Julia","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file. (The Clang package can be used to auto-generate Julia code from a C header file.)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Auto-conversion:-1","page":"C, Fortran コードの呼び出し","title":"Auto-conversion:","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Julia automatically inserts calls to the Base.cconvert function to convert each argument to the specified type. For example, the following call:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"ccall((:foo, \"libfoo\"), Cvoid, (Int32, Float64), x, y)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"will behave as if the following were written:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"ccall((:foo, \"libfoo\"), Cvoid, (Int32, Float64),\n      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Base.cconvert normally just calls convert, but can be defined to return an arbitrary new object more appropriate for passing to C.  This should be used to perform all allocations of memory that will be accessed by the C code.  For example, this is used to convert an Array of objects (e.g. strings) to an array of pointers.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Base.unsafe_convert handles conversion to Ptr types. It is considered unsafe because converting an object to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Type-Correspondences:-1","page":"C, Fortran コードの呼び出し","title":"Type Correspondences:","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"First, a review of some relevant Julia type terminology:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Syntax / Keyword Example Description\nmutable struct BitSet \"Leaf Type\" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no TypeVars are allowed) in order for the instance to be constructed.\nabstract type Any, AbstractArray{T, N}, Complex{T} \"Super Type\" :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.\nT{A} Vector{Int} \"Type Parameter\" :: A specialization of a type (typically used for dispatch or storage optimization).\n  \"TypeVar\" :: The T in the type parameter declaration is referred to as a TypeVar (short for type variable).\nprimitive type Int, Float64 \"Primitive Type\" :: A type with no fields, but a size. It is stored and defined by-value.\nstruct Pair{Int, Int} \"Struct\" :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.\n ComplexF64 (isbits) \"Is-Bits\"   :: A primitive type, or a struct type where all fields are other isbits types. It is defined by-value, and is stored without a type-tag.\nstruct ...; end nothing \"Singleton\" :: a Leaf Type or Struct with no fields.\n(...) or tuple(...) (1, 2, 3) \"Tuple\" :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#man-bits-types-1","page":"C, Fortran コードの呼び出し","title":"Bits Types","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"There are several special types to be aware of, as no other type can be defined to behave the same:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Float32\nExactly corresponds to the float type in C (or REAL*4 in Fortran).\nFloat64\nExactly corresponds to the double type in C (or REAL*8 in Fortran).\nComplexF32\nExactly corresponds to the complex float type in C (or COMPLEX*8 in Fortran).\nComplexF64\nExactly corresponds to the complex double type in C (or COMPLEX*16 in Fortran).\nSigned\nExactly corresponds to the signed type annotation in C (or any INTEGER type in Fortran). Any Julia type that is not a subtype of Signed is assumed to be unsigned.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Ref{T}\nBehaves like a Ptr{T} that can manage its memory via the Julia GC.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Array{T,N}\nWhen an array is passed to C as a Ptr{T} argument, it is not reinterpret-cast: Julia requires that the element type of the array matches T, and the address of the first element is passed.\nTherefore, if an Array contains data in the wrong format, it will have to be explicitly converted using a call such as trunc(Int32, a).\nTo pass an array A as a pointer of a different type without converting the data beforehand (for example, to pass a Float64 array to a function that operates on uninterpreted bytes), you can declare the argument as Ptr{Cvoid}.\nIf an array of eltype Ptr{T} is passed as a Ptr{Ptr{T}} argument, Base.cconvert will attempt to first make a null-terminated copy of the array with each element replaced by its Base.cconvert version. This allows, for example, passing an argv pointer array of type Vector{String} to an argument of type Ptr{Ptr{Cchar}}.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C.  This can help for writing portable code (and remembering that an int in C is not the same as an Int in Julia).","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"System Independent:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"C name Fortran name Standard Julia Alias Julia Base Type\nunsigned char CHARACTER Cuchar UInt8\nbool (only in C++)  Cuchar UInt8\nshort INTEGER*2, LOGICAL*2 Cshort Int16\nunsigned short  Cushort UInt16\nint, BOOL (C, typical) INTEGER*4, LOGICAL*4 Cint Int32\nunsigned int  Cuint UInt32\nlong long INTEGER*8, LOGICAL*8 Clonglong Int64\nunsigned long long  Culonglong UInt64\nintmax_t  Cintmax_t Int64\nuintmax_t  Cuintmax_t UInt64\nfloat REAL*4i Cfloat Float32\ndouble REAL*8 Cdouble Float64\ncomplex float COMPLEX*8 ComplexF32 Complex{Float32}\ncomplex double COMPLEX*16 ComplexF64 Complex{Float64}\nptrdiff_t  Cptrdiff_t Int\nssize_t  Cssize_t Int\nsize_t  Csize_t UInt\nvoid   Cvoid\nvoid and [[noreturn]] or _Noreturn   Union{}\nvoid*   Ptr{Cvoid}\nT* (where T represents an appropriately defined type)   Ref{T}\nchar* (or char[], e.g. a string) CHARACTER*N  Cstring if NUL-terminated, or Ptr{UInt8} if not\nchar** (or *char[])   Ptr{Ptr{UInt8}}\njl_value_t* (any Julia Type)   Any\njl_value_t** (a reference to a Julia Type)   Ref{Any}\nva_arg   Not supported\n... (variadic function specification)   T... (where T is one of the above types, variadic functions of different argument types are not supported)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The Cstring type is essentially a synonym for Ptr{UInt8}, except the conversion to Cstring throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator).  If you are passing a char* to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use Ptr{UInt8} as the argument type. Cstring can also be used as the ccall return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"System-dependent:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"C name Standard Julia Alias Julia Base Type\nchar Cchar Int8 (x86, x86_64), UInt8 (powerpc, arm)\nlong Clong Int (UNIX), Int32 (Windows)\nunsigned long Culong UInt (UNIX), UInt32 (Windows)\nwchar_t Cwchar_t Int32 (UNIX), UInt16 (Windows)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"note: Note\nWhen calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated values, so all type correspondences above should contain an additional Ptr{..} or Ref{..} wrapper around their type specification.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"warning: Warning\nFor string arguments (char*) the Julia type should be Cstring (if NUL- terminated data is expected) or either Ptr{Cchar} or Ptr{UInt8} otherwise (these two pointer types have the same effect), as described above, not String. Similarly, for array arguments (T[] or T*), the Julia type should again be Ptr{T}, not Vector{T}.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"warning: Warning\nJulia's Char type is 32 bits, which is not the same as the wide character type (wchar_t or wint_t) on all platforms.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"warning: Warning\nA return type of Union{} means the function will not return i.e. C++11 [[noreturn]] or C11 _Noreturn (e.g. jl_throw or longjmp). Do not use this for functions that return no value (void) but do return, use Cvoid instead.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"note: Note\nFor wchar_t* arguments, the Julia type should be Cwstring (if the C routine expects a NUL-terminated string) or Ptr{Cwchar_t} otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the Cwstring type will cause an error to be thrown if the string itself contains NUL characters).","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"note: Note\nC functions that take an argument of the type char** can be called by using a Ptr{Ptr{UInt8}} type within Julia. For example, C functions of the form:int main(int argc, char **argv);can be called via the following Julia code:argv = [ \"a.out\", \"arg1\", \"arg2\" ]\nccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"note: Note\nFor Fortran functions taking variable length strings of type character(len=*) the string lengths are provided as hidden arguments. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using Csize_t as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others optionally permit placing hidden arguments directly after the character argument (Intel,PGI). For example, Fortran subroutines of the formsubroutine test(str1, str2)\ncharacter(len=*) :: str1,str2can be called via the following Julia code, where the lengths are appendedstr1 = \"foo\"\nstr2 = \"bar\"\nccall(:test, Void, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),\n                    str1, str2, sizeof(str1), sizeof(str2))","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"warning: Warning\nFortran compilers may also add other hidden arguments for pointers, assumed-shape (:) and assumed-size (*) arrays. Such behaviour can be avoided by using ISO_C_BINDING and including bind(c) in the definition of the subroutine, which is strongly recommended for interoperable code. In this case there will be no hidden arguments, at the cost of some language features (e.g. only character(len=1) will be permitted to pass strings).","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"note: Note\nA C function declared to return Cvoid will return the value nothing in Julia.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Struct-Type-correspondences-1","page":"C, Fortran コードの呼び出し","title":"Struct Type correspondences","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Composite types, aka struct in C or TYPE in Fortran90 (or STRUCTURE / RECORD in some variants of F77), can be mirrored in Julia by creating a struct definition with the same field layout.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"When used recursively, isbits types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare an isbits struct type and use that instead. Unnamed structs are not possible in the translation to Julia.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Packed structs and union declarations are not supported by Julia.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"You can get a near approximation of a union if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Arrays of parameters can be expressed with NTuple:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"in C:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"struct B {\n    int A[3];\n};\nb_a_2 = B.A[2];","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"in Julia:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"struct B\n    A::NTuple{3, Cint}\nend\nb_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Arrays of unknown size (C99-compliant variable length structs specified by [] or [0]) are not directly supported.  Often the best way to deal with these is to deal with the byte offsets directly.  For example, if a C library declared a proper string type and returned a pointer to it:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"struct String {\n    int strlen;\n    char data[];\n};","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"In Julia, we can access the parts independently to make a copy of that string:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"str = from_c::Ptr{Cvoid}\nlen = unsafe_load(Ptr{Cint}(str))\nunsafe_string(str + Core.sizeof(Cint), len)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Type-Parameters-1","page":"C, Fortran コードの呼び出し","title":"Type Parameters","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The type arguments to ccall and @cfunction are evaluated statically, when the method containing the usage is defined.  They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment.  The static parameters of the function may be used as type parameters in the call signature, as long as they don't affect the layout of the type.  For example, f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x) is valid, since Ptr is always a word-size primitive type.  But, g(x::T) where {T} = ccall(:notvalid, T, (T,), x) is not valid, since the type layout of T is not known statically.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#SIMD-Values-1","page":"C, Fortran コードの呼び出し","title":"SIMD Values","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of VecElement that naturally maps to the SIMD type.  Specifically:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The tuple must be the same size as the SIMD type. For example, a tuple representing an __m128 on x86 must have a size of 16 bytes.\nThe element type of the tuple must be an instance of VecElement{T} where T is a primitive type that is 1, 2, 4 or 8 bytes.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"For instance, consider this C routine that uses AVX intrinsics:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"#include <immintrin.h>\n\n__m256 dist( __m256 a, __m256 b ) {\n    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n                                        _mm256_mul_ps(b, b)));\n}","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The following Julia code calls dist using ccall:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"const m256 = NTuple{8, VecElement{Float32}}\n\na = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))\nb = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))\n\nfunction call_dist(a::m256, b::m256)\n    ccall((:dist, \"libdist\"), m256, (m256, m256), a, b)\nend\n\nprintln(call_dist(a,b))","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The host machine must have the requisite SIMD registers.  For example, the code above will not work on hosts without AVX support.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Memory-Ownership-1","page":"C, Fortran コードの呼び出し","title":"Memory Ownership","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"malloc/free","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with Libc.free in Julia, as this may result in the free function being called via the wrong libc library and cause Julia to crash. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#When-to-use-T,-Ptr{T}-and-Ref{T}-1","page":"C, Fortran コードの呼び出し","title":"When to use T, Ptr{T} and Ref{T}","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type T inside the ccall, as they are passed by value.  For C code accepting pointers, Ref{T} should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to Base.cconvert.  In contrast, pointers returned by the C function called should be declared to be of output type Ptr{T}, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type Ptr{T} within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type Ref{T}, as Fortran passes all variables by pointers to memory locations. The return type should either be Cvoid for Fortran subroutines, or a T for Fortran functions returning the type T.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Mapping-C-Functions-to-Julia-1","page":"C, Fortran コードの呼び出し","title":"Mapping C Functions to Julia","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#ccall-/-@cfunction-argument-translation-guide-1","page":"C, Fortran コードの呼び出し","title":"ccall / @cfunction argument translation guide","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"For translating a C argument list to Julia:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"T, where T is one of the primitive types: char, int, long, short, float, double, complex, enum or any of their typedef equivalents\nT, where T is an equivalent Julia Bits Type (per the table above)\nif T is an enum, the argument type should be equivalent to Cint or Cuint\nargument value will be copied (passed by value)\nstruct T (including typedef to a struct)\nT, where T is a Julia leaf type\nargument value will be copied (passed by value)\nvoid*\ndepends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list\nthis argument may be declared as Ptr{Cvoid}, if it really is just an unknown pointer\njl_value_t*\nAny\nargument value must be a valid Julia object\njl_value_t**\nRef{Any}\nargument value must be a valid Julia object (or C_NULL)\nT*\nRef{T}, where T is the Julia type corresponding to T\nargument value will be copied if it is an isbits type otherwise, the value must be a valid Julia object\nT (*)(...) (e.g. a pointer to a function)\nPtr{Cvoid} (you may need to use @cfunction explicitly to create this pointer)\n... (e.g. a vararg)\nT..., where T is the Julia type\ncurrently unsupported by @cfunction\nva_arg\nnot supported by ccall or @cfunction","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#ccall-/-@cfunction-return-type-translation-guide-1","page":"C, Fortran コードの呼び出し","title":"ccall / @cfunction return type translation guide","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"For translating a C return type to Julia:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"void\nCvoid (this will return the singleton instance nothing::Cvoid)\nT, where T is one of the primitive types: char, int, long, short, float, double, complex, enum or any of their typedef equivalents\nT, where T is an equivalent Julia Bits Type (per the table above)\nif T is an enum, the argument type should be equivalent to Cint or Cuint\nargument value will be copied (returned by-value)\nstruct T (including typedef to a struct)\nT, where T is a Julia Leaf Type\nargument value will be copied (returned by-value)\nvoid*\ndepends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list\nthis argument may be declared as Ptr{Cvoid}, if it really is just an unknown pointer\njl_value_t*\nAny\nargument value must be a valid Julia object\njl_value_t**\nPtr{Any} (Ref{Any} is invalid as a return type)\nargument value must be a valid Julia object (or C_NULL)\nT*\nIf the memory is already owned by Julia, or is an isbits type, and is known to be non-null:\nRef{T}, where T is the Julia type corresponding to T\na return type of Ref{Any} is invalid, it should either be Any (corresponding to jl_value_t*)  or Ptr{Any} (corresponding to jl_value_t**)\nC MUST NOT modify the memory returned via Ref{T} if T is an isbits type\nIf the memory is owned by C:\nPtr{T}, where T is the Julia type corresponding to T\nT (*)(...) (e.g. a pointer to a function)\nPtr{Cvoid} (you may need to use @cfunction explicitly to create this pointer)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Passing-Pointers-for-Modifying-Inputs-1","page":"C, Fortran コードの呼び出し","title":"Passing Pointers for Modifying Inputs","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a ccall, you need to first encapsulate the value inside a Ref{T} of the appropriate type. When you pass this Ref object as an argument, Julia will automatically pass a C pointer to the encapsulated data:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"width = Ref{Cint}(0)\nrange = Ref{Cfloat}(0)\nccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Upon return, the contents of width and range can be retrieved (if they were changed by foo)  by width[] and range[]; that is, they act like zero-dimensional arrays.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Special-Reference-Syntax-for-ccall-(deprecated):-1","page":"C, Fortran コードの呼び出し","title":"Special Reference Syntax for ccall (deprecated):","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The & syntax is deprecated, use the Ref{T} argument type instead.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"A prefix & is used on an argument to ccall to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n    @assert length(DX) == length(DY)\n    n = length(DX)\n    incx = incy = 1\n    product = ccall((:ddot_, \"libLAPACK\"),\n                    Float64,\n                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),\n                    n, DX, incx, DY, incy)\n    return product\nend","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The meaning of prefix & is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via mutable struct). However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, & may be used with any expression, such as &0 or &f(x).","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"When a scalar value is passed with & as an argument of type Ptr{T}, the value will first be converted to type T.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Some-Examples-of-C-Wrappers-1","page":"C, Fortran コードの呼び出し","title":"Some Examples of C Wrappers","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Here is a simple example of a C wrapper that returns a Ptr type:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"mutable struct gsl_permutation\nend\n\n# The corresponding C signature is\n#     gsl_permutation * gsl_permutation_alloc (size_t n);\nfunction permutation_alloc(n::Integer)\n    output_ptr = ccall(\n        (:gsl_permutation_alloc, :libgsl), # name of C function and library\n        Ptr{gsl_permutation},              # output type\n        (Csize_t,),                        # tuple of input types\n        n                                  # name of Julia variable to pass in\n    )\n    if output_ptr == C_NULL # Could not allocate memory\n        throw(OutOfMemoryError())\n    end\n    return output_ptr\nend","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The GNU Scientific Library (here assumed to be accessible through :libgsl) defines an opaque pointer, gsl_permutation *, as the return type of the C function gsl_permutation_alloc. As user code never has to look inside the gsl_permutation struct, the corresponding Julia wrapper simply needs a new type declaration, gsl_permutation, that has no internal fields and whose sole purpose is to be placed in the type parameter of a Ptr type.  The return type of the ccall is declared as Ptr{gsl_permutation}, since the memory allocated and pointed to by output_ptr is controlled by C (and not Julia).","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The input n is passed by value, and so the function's input signature is simply declared as (Csize_t,) without any Ref or Ptr necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be (Ref{Csize_t},), since Fortran variables are passed by pointers.) Furthermore, n can be any type that is convertible to a Csize_t integer; the ccall implicitly calls Base.cconvert(Csize_t, n).","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Here is a second example wrapping the corresponding destructor:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"# The corresponding C signature is\n#     void gsl_permutation_free (gsl_permutation * p);\nfunction permutation_free(p::Ref{gsl_permutation})\n    ccall(\n        (:gsl_permutation_free, :libgsl), # name of C function and library\n        Cvoid,                             # output type\n        (Ref{gsl_permutation},),          # tuple of input types\n        p                                 # name of Julia variable to pass in\n    )\nend","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Here, the input p is declared to be of type Ref{gsl_permutation}, meaning that the memory that p points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type Ptr{gsl_permutation}, but it is convertible using Base.cconvert and therefore can be used in the same (covariant) context of the input argument to a ccall. A pointer to memory allocated by Julia must be of type Ref{gsl_permutation}, to ensure that the memory address pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed to correctly. Therefore, the Ref{gsl_permutation} declaration allows pointers managed by C or Julia to be used.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using p::Ptr{gsl_permutation} for the method signature of the wrapper and similarly in the ccall  is also acceptable.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Here is a third example passing Julia arrays:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"# The corresponding C signature is\n#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n#                                double result_array[])\nfunction sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n    if nmax < nmin\n        throw(DomainError())\n    end\n    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)\n    errorcode = ccall(\n        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library\n        Cint,                               # output type\n        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types\n        nmin, nmax, x, result_array         # names of Julia variables to pass in\n    )\n    if errorcode != 0\n        error(\"GSL error code $errorcode\")\n    end\n    return result_array\nend","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array result_array. This variable can only be used with corresponding input type declaration Ref{Cdouble}, since its memory is allocated and managed by Julia, not C. The implicit call to Base.cconvert(Ref{Cdouble}, result_array) unpacks the Julia pointer to a Julia array data structure into a form understandable by C.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Note that for this code to work correctly, result_array must be declared to be of type Ref{Cdouble} and not Ptr{Cdouble}. The memory is managed by Julia and the Ref signature alerts Julia's garbage collector to keep managing the memory for result_array while the ccall executes. If Ptr{Cdouble} were used instead, the ccall may still work, but Julia's garbage collector would not be aware that the memory declared for result_array is being used by the external C function. As a result, the code may produce a memory leak if result_array never gets freed by the garbage collector, or if the garbage collector prematurely frees result_array, the C function may end up throwing an invalid memory access exception.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Garbage-Collection-Safety-1","page":"C, Fortran コードの呼び出し","title":"Garbage Collection Safety","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"When passing data to a ccall, it is best to avoid using the pointer function.  Instead define a convert method and pass the variables directly to the ccall. ccall  automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the ccall  returns, you must arrange that the object remains visible to the garbage collector. The suggested way to handle this is to make a global variable of type Array{Ref,1} to hold these values, until the C library notifies you that it is finished with them.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Whenever you have created a pointer to Julia data, you must ensure the original data exists until you are done with using the pointer. Many methods in Julia such as unsafe_load and String make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is unsafe_wrap  which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The garbage collector does not guarantee any order of finalization. That is, if a contained a reference to b and both a and b are due for garbage collection, there is no guarantee that b would be finalized after a. If proper finalization of a depends on b being valid, it must be handled in other ways.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Non-constant-Function-Specifications-1","page":"C, Fortran コードの呼び出し","title":"Non-constant Function Specifications","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"A (name, library) function specification must be a constant expression. However, it is possible to use computed values as function names by staging through eval as follows:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"@eval ccall(($(string(\"a\", \"b\")), \"lib\"), ...","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"This expression constructs a name using string, then substitutes this name into a new ccall  expression, which is then evaluated. Keep in mind that eval only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with $). For this reason, eval is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions.  A similar example can be constructed for @cfunction.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading.  The next section discusses how to use indirect calls to efficiently accomplish a similar effect.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Indirect-Calls-1","page":"C, Fortran コードの呼び出し","title":"Indirect Calls","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The first argument to ccall can also be an expression evaluated at run time. In this case, the expression must evaluate to a Ptr, which will be used as the address of the native function to call. This behavior occurs when the first ccall argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"For example, you might look up the function via dlsym, then cache it in a shared reference for that session. For example:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"macro dlsym(func, lib)\n    z = Ref{Ptr{Cvoid}}(C_NULL)\n    quote\n        let zlocal = $z[]\n            if zlocal == C_NULL\n                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}\n                $z[] = $zlocal\n            end\n            zlocal\n        end\n    end\nend\n\nmylibvar = Libdl.dlopen(\"mylib\")\nccall(@dlsym(\"myfunc\", mylibvar), Cvoid, ())","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Closure-cfunctions-1","page":"C, Fortran コードの呼び出し","title":"Closure cfunctions","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The first argument to @cfunction can be marked with a $, in which case the return value will instead be a struct CFunction which closes over the argument.  You must ensure that this return object is kept alive until all uses of it are done.  The contents and code at the cfunction pointer will be erased via a finalizer  when this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don't provide a separate closure environment parameter.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"function qsort(a::Vector{T}, cmp) where T\n    isbits(T) || throw(ArgumentError(\"this method can only qsort isbits arrays\"))\n    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})\n    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}\n    # (and protected against finalization) by the ccall\n    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),\n        a, length(a), Base.elsize(a), callback)\n    # We could instead use:\n    #    GC.@preserve callback begin\n    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))\n    #    end\n    # if we needed to use it outside of a `ccall`\n    return a\nend","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Closing-a-Library-1","page":"C, Fortran コードの呼び出し","title":"Closing a Library","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"It is sometimes useful to close (unload) a library so that it can be reloaded.  For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the Libdl functions to manage the library explicitly, such as:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"lib = Libdl.dlopen(\"./my_lib.so\") # Open the library explicitly.\nsym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.\nccall(sym, ...) # Use the pointer `sym` instead of the (symbol, library) tuple (remaining arguments are the same).\nLibdl.dlclose(lib) # Close the library explicitly.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Note that when using ccall with the tuple input (e.g., ccall((:my_fcn, \"./my_lib.so\"), ...)), the library is opened implicitly and it may not be explicitly closed.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Calling-Convention-1","page":"C, Fortran コードの呼び出し","title":"Calling Convention","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The second argument to ccall can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used.  Other supported conventions are: stdcall, cdecl, fastcall, and thiscall (no-op on 64-bit Windows). For example (from base/libc.jl) we see the same gethostnameccall as above, but with the correct signature for Windows:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"hn = Vector{UInt8}(undef, 256)\nerr = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"For more information, please see the LLVM Language Reference.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"There is one additional special calling convention llvmcall, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs.  For example, for CUDA, we need to be able to read the thread index:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"ccall(\"llvm.nvvm.read.ptx.sreg.tid.x\", llvmcall, Int32, ())","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"As with any ccall, it is essential to get the argument signature exactly correct.  Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by Core.Intrinsics.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Accessing-Global-Variables-1","page":"C, Fortran コードの呼び出し","title":"Accessing Global Variables","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Global variables exported by native libraries can be accessed by name using the cglobal  function. The arguments to cglobal are a symbol specification identical to that used by ccall, and a type describing the value stored in the variable:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"julia> cglobal((:errno, :libc), Int32)\nPtr{Int32} @0x00007f418d0816b8","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The result is a pointer giving the address of the value. The value can be manipulated through this pointer using unsafe_load and unsafe_store!.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Accessing-Data-through-a-Pointer-1","page":"C, Fortran コードの呼び出し","title":"Accessing Data through a Pointer","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The following methods are described as \"unsafe\" because a bad pointer or type declaration can cause Julia to terminate abruptly.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Given a Ptr{T}, the contents of type T can generally be copied from the referenced memory into a Julia object using unsafe_load(ptr, [index]). The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of getindex and setindex! (e.g. [] access syntax).","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"If T is Any, then the memory is assumed to contain a reference to a Julia object (a jl_value_t*), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector.  If the Ptr itself is actually a jl_value_t*, it can be converted back to a Julia object reference by unsafe_pointer_to_objref(ptr). (Julia values v can be converted to jl_value_t* pointers, as Ptr{Cvoid}, by calling pointer_from_objref(v).)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The reverse operation (writing data to a Ptr{T}), can be performed using unsafe_store!(ptr, value, [index]).  Currently, this is only supported for primitive types or other pointer-free (isbits) immutable struct types.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"If the pointer of interest is a plain-data array (primitive type or immutable struct), the function unsafe_wrap(Array, ptr,dims, own = false)  may be more useful. The final parameter should be true if Julia should \"take ownership\" of the underlying buffer and call free(ptr) when the returned Array object is finalized.  If the own parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Arithmetic on the Ptr type in Julia (e.g. using +) does not behave the same as C's pointer arithmetic. Adding an integer to a Ptr in Julia always moves the pointer by some number of bytes, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#Thread-safety-1","page":"C, Fortran コードの呼び出し","title":"Thread-safety","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Some C libraries execute their callbacks from a different thread, and since Julia isn't thread-safe you'll need to take some extra precautions. In particular, you'll need to set up a two-layered system: the C callback should only schedule (via Julia's event loop) the execution of your \"real\" callback. To do this, create an AsyncCondition object and wait on it:","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"cond = Base.AsyncCondition()\nwait(cond)","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"The callback you pass to C should only execute a ccall to :uv_async_send, passing cond.handle as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"Note that events may be coalesced, so multiple calls to uv_async_send may result in a single wakeup notification to the condition.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#More-About-Callbacks-1","page":"C, Fortran コードの呼び出し","title":"More About Callbacks","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"For more details on how to pass callbacks to C libraries, see this blog post.","category":"page"},{"location":"manual/calling-c-and-fortran-code.html#C-1","page":"C, Fortran コードの呼び出し","title":"C++","text":"","category":"section"},{"location":"manual/calling-c-and-fortran-code.html#","page":"C, Fortran コードの呼び出し","title":"C, Fortran コードの呼び出し","text":"For direct C++ interfacing, see the Cxx package. For tools to create C++ bindings, see the CxxWrap package.","category":"page"},{"location":"manual/handling-operating-system-variation.html#Handling-Operating-System-Variation-1","page":"Handling Operating System Variation","title":"Handling Operating System Variation","text":"","category":"section"},{"location":"manual/handling-operating-system-variation.html#","page":"Handling Operating System Variation","title":"Handling Operating System Variation","text":"When writing cross-platform applications or libraries, it is often necessary to allow for differences between operating systems. The variable Sys.KERNEL can be used to handle such cases. There are several functions in the Sys module intended to make this easier, such as isunix, islinux, isapple, isbsd, isfreebsd, and iswindows. These may be used as follows:","category":"page"},{"location":"manual/handling-operating-system-variation.html#","page":"Handling Operating System Variation","title":"Handling Operating System Variation","text":"if Sys.iswindows()\n    windows_specific_thing(a)\nend","category":"page"},{"location":"manual/handling-operating-system-variation.html#","page":"Handling Operating System Variation","title":"Handling Operating System Variation","text":"Note that islinux, isapple, and isfreebsd are mutually exclusive subsets of isunix.  Additionally, there is a macro @static which makes it possible to use these functions to conditionally hide invalid code, as demonstrated in the following examples.","category":"page"},{"location":"manual/handling-operating-system-variation.html#","page":"Handling Operating System Variation","title":"Handling Operating System Variation","text":"Simple blocks:","category":"page"},{"location":"manual/handling-operating-system-variation.html#","page":"Handling Operating System Variation","title":"Handling Operating System Variation","text":"ccall((@static Sys.iswindows() ? :_fopen : :fopen), ...)","category":"page"},{"location":"manual/handling-operating-system-variation.html#","page":"Handling Operating System Variation","title":"Handling Operating System Variation","text":"Complex blocks:","category":"page"},{"location":"manual/handling-operating-system-variation.html#","page":"Handling Operating System Variation","title":"Handling Operating System Variation","text":"@static if Sys.islinux()\n    linux_specific_thing(a)\nelse\n    generic_thing(a)\nend","category":"page"},{"location":"manual/handling-operating-system-variation.html#","page":"Handling Operating System Variation","title":"Handling Operating System Variation","text":"When chaining conditionals (including if/elseif/end), the @static must be repeated for each level (parentheses optional, but recommended for readability):","category":"page"},{"location":"manual/handling-operating-system-variation.html#","page":"Handling Operating System Variation","title":"Handling Operating System Variation","text":"@static Sys.iswindows() ? :a : (@static Sys.isapple() ? :b : :c)","category":"page"},{"location":"manual/environment-variables.html#Environment-Variables-1","page":"Environment Variables","title":"Environment Variables","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"Julia can be configured with a number of environment variables, set either in the usual way for each operating system, or in a portable way from within Julia.  Supposing that you want to set the environment variable JULIA_EDITOR to vim, you can type ENV[\"JULIA_EDITOR\"] = \"vim\" (for instance, in the REPL) to make this change on a case by case basis, or add the same to the user configuration file ~/.julia/config/startup.jl in the user's home directory to have a permanent effect. The current value of the same environment variable can be determined by evaluating ENV[\"JULIA_EDITOR\"].","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The environment variables that Julia uses generally start with JULIA. If InteractiveUtils.versioninfo is called with the keyword verbose=true, then the output will list defined environment variables relevant for Julia, including those for which JULIA appears in the name.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"note: Note\nSome variables, such as JULIA_NUM_THREADS and JULIA_PROJECT, need to be set before Julia starts, therefore adding these to ~/.julia/config/startup.jl is too late in the startup process. In Bash, environment variables can either be set manually by running, e.g., export JULIA_NUM_THREADS=4 before starting Julia, or by adding the same command to -/.bashrc or ~/.bash_profile to set the variable each time Bash is started.","category":"page"},{"location":"manual/environment-variables.html#File-locations-1","page":"Environment Variables","title":"File locations","text":"","category":"section"},{"location":"manual/environment-variables.html#JULIA_BINDIR-1","page":"Environment Variables","title":"JULIA_BINDIR","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The absolute path of the directory containing the Julia executable, which sets the global variable Sys.BINDIR. If $JULIA_BINDIR is not set, then Julia determines the value Sys.BINDIR at run-time.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The executable itself is one of","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"$JULIA_BINDIR/julia\n$JULIA_BINDIR/julia-debug","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"by default.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The global variable Base.DATAROOTDIR determines a relative path from Sys.BINDIR to the data directory associated with Julia. Then the path","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"$JULIA_BINDIR/$DATAROOTDIR/julia/base","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"determines the directory in which Julia initially searches for source files (via Base.find_source_file()).","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"Likewise, the global variable Base.SYSCONFDIR determines a relative path to the configuration file directory. Then Julia searches for a startup.jl file at","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"$JULIA_BINDIR/$SYSCONFDIR/julia/startup.jl\n$JULIA_BINDIR/../etc/julia/startup.jl","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"by default (via Base.load_julia_startup()).","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"For example, a Linux installation with a Julia executable located at /bin/julia, a DATAROOTDIR of ../share, and a SYSCONFDIR of ../etc will have JULIA_BINDIR set to /bin, a source-file search path of","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"/share/julia/base","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"and a global configuration search path of","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"/etc/julia/startup.jl","category":"page"},{"location":"manual/environment-variables.html#JULIA_PROJECT-1","page":"Environment Variables","title":"JULIA_PROJECT","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"A directory path that indicates which project should be the initial active project.  Setting this environment variable has the same effect as specifying the --project start-up option, but --project has higher precedence. If the variable is set to @. then Julia tries to find a project directory that contains Project.toml or JuliaProject.toml file from the current directory and its parents. See also the chapter on Code Loading.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"note: Note\nJULIA_PROJECT must be defined before starting julia; defining it in startup.jl is too late in the startup process.","category":"page"},{"location":"manual/environment-variables.html#JULIA_LOAD_PATH-1","page":"Environment Variables","title":"JULIA_LOAD_PATH","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The JULIA_LOAD_PATH environment variable is used to populate the global Julia LOAD_PATH variable, which determines which packages can be loaded via import and using (see Code Loading).","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"Unlike the shell PATH variable, empty entries in JULIA_LOAD_PATH are expanded to the default value of LOAD_PATH, [\"@\", \"@v#.#\", \"@stdlib\"] when populating LOAD_PATH. This allows easy appending, prepending, etc. of the load path value in shell scripts regardless of whether JULIA_LOAD_PATH is already set or not. For example, to prepend the directory /foo/bar to LOAD_PATH just do","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"export JULIA_LOAD_PATH=\"/foo/bar:$JULIA_LOAD_PATH\"","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"If the JULIA_LOAD_PATH environment variable is already set, its old value will be prepended with /foo/bar. On the other hand, if JULIA_LOAD_PATH is not set, then it will be set to /foo/bar: which will expand to a LOAD_PATH value of [\"/foo/bar\", \"@\", \"@v#.#\", \"@stdlib\"]. If JULIA_LOAD_PATH is set to the empty string, it expands to an empty LOAD_PATH array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string.  This behavior was chosen so that it would be possible to set an empty load path via the environment variable. If you want the default load path, either unset the environment variable or if it must have a value, set it to the string :.","category":"page"},{"location":"manual/environment-variables.html#JULIA_DEPOT_PATH-1","page":"Environment Variables","title":"JULIA_DEPOT_PATH","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The JULIA_DEPOT_PATH environment variable is used to populate the global Julia DEPOT_PATH variable, which controls where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"Unlike the shell PATH variable but similar to JULIA_LOAD_PATH, empty entries in JULIA_DEPOT_PATH are expanded to the default value of DEPOT_PATH. This allows easy appending, prepending, etc. of the depot path value in shell scripts regardless of whether JULIA_DEPOT_PATH is already set or not. For example, to prepend the directory /foo/bar to DEPOT_PATH just do","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"export JULIA_DEPOT_PATH=\"/foo/bar:$JULIA_DEPOT_PATH\"","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"If the JULIA_DEPOT_PATH environment variable is already set, its old value will be prepended with /foo/bar. On the other hand, if JULIA_DEPOT_PATH is not set, then it will be set to /foo/bar: which will have the effect of prepending /foo/bar to the default depot path. If JULIA_DEPOT_PATH is set to the empty string, it expands to an empty DEPOT_PATH array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty depot path via the environment variable. If you want the default depot path, either unset the environment variable or if it must have a value, set it to the string :.","category":"page"},{"location":"manual/environment-variables.html#JULIA_HISTORY-1","page":"Environment Variables","title":"JULIA_HISTORY","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The absolute path REPL.find_hist_file() of the REPL's history file. If $JULIA_HISTORY is not set, then REPL.find_hist_file() defaults to","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"$HOME/.julia/logs/repl_history.jl","category":"page"},{"location":"manual/environment-variables.html#JULIA_PKGRESOLVE_ACCURACY-1","page":"Environment Variables","title":"JULIA_PKGRESOLVE_ACCURACY","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"A positive Int that determines how much time the max-sum subroutine MaxSum.maxsum() of the package dependency resolver will devote to attempting satisfying constraints before giving up: this value is by default 1, and larger values correspond to larger amounts of time.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"Suppose the value of $JULIA_PKGRESOLVE_ACCURACY is n. Then","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"the number of pre-decimation iterations is 20*n,\nthe number of iterations between decimation steps is 10*n, and\nat decimation steps, at most one in every 20*n packages is decimated.","category":"page"},{"location":"manual/environment-variables.html#External-applications-1","page":"Environment Variables","title":"External applications","text":"","category":"section"},{"location":"manual/environment-variables.html#JULIA_SHELL-1","page":"Environment Variables","title":"JULIA_SHELL","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The absolute path of the shell with which Julia should execute external commands (via Base.repl_cmd()). Defaults to the environment variable $SHELL, and falls back to /bin/sh if $SHELL is unset.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"note: Note\nOn Windows, this environment variable is ignored, and external commands are executed directly.","category":"page"},{"location":"manual/environment-variables.html#JULIA_EDITOR-1","page":"Environment Variables","title":"JULIA_EDITOR","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The editor returned by InteractiveUtils.editor() and used in, e.g., InteractiveUtils.edit, referring to the command of the preferred editor, for instance vim.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"$JULIA_EDITOR takes precedence over $VISUAL, which in turn takes precedence over $EDITOR. If none of these environment variables is set, then the editor is taken to be open on Windows and OS X, or /etc/alternatives/editor if it exists, or emacs otherwise.","category":"page"},{"location":"manual/environment-variables.html#Parallelization-1","page":"Environment Variables","title":"Parallelization","text":"","category":"section"},{"location":"manual/environment-variables.html#JULIA_CPU_THREADS-1","page":"Environment Variables","title":"JULIA_CPU_THREADS","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"Overrides the global variable Base.Sys.CPU_THREADS, the number of logical CPU cores available.","category":"page"},{"location":"manual/environment-variables.html#JULIA_WORKER_TIMEOUT-1","page":"Environment Variables","title":"JULIA_WORKER_TIMEOUT","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"A Float64 that sets the value of Distributed.worker_timeout() (default: 60.0).  This function gives the number of seconds a worker process will wait for a master process to establish a connection before dying.","category":"page"},{"location":"manual/environment-variables.html#JULIA_NUM_THREADS-1","page":"Environment Variables","title":"JULIA_NUM_THREADS","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"An unsigned 64-bit integer (uint64_t) that sets the maximum number of threads available to Julia. If $JULIA_NUM_THREADS exceeds the number of available physical CPU cores, then the number of threads is set to the number of cores. If $JULIA_NUM_THREADS is not positive or is not set, or if the number of CPU cores cannot be determined through system calls, then the number of threads is set to 1.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"note: Note\nJULIA_NUM_THREADS must be defined before starting julia; defining it in startup.jl is too late in the startup process.","category":"page"},{"location":"manual/environment-variables.html#JULIA_THREAD_SLEEP_THRESHOLD-1","page":"Environment Variables","title":"JULIA_THREAD_SLEEP_THRESHOLD","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"If set to a string that starts with the case-insensitive substring \"infinite\", then spinning threads never sleep. Otherwise, $JULIA_THREAD_SLEEP_THRESHOLD is interpreted as an unsigned 64-bit integer (uint64_t) and gives, in nanoseconds, the amount of time after which spinning threads should sleep.","category":"page"},{"location":"manual/environment-variables.html#JULIA_EXCLUSIVE-1","page":"Environment Variables","title":"JULIA_EXCLUSIVE","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"If set to anything besides 0, then Julia's thread policy is consistent with running on a dedicated machine: the master thread is on proc 0, and threads are affinitized. Otherwise, Julia lets the operating system handle thread policy.","category":"page"},{"location":"manual/environment-variables.html#REPL-formatting-1","page":"Environment Variables","title":"REPL formatting","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"Environment variables that determine how REPL output should be formatted at the terminal. Generally, these variables should be set to ANSI terminal escape sequences. Julia provides a high-level interface with much of the same functionality; see the section on The Julia REPL.","category":"page"},{"location":"manual/environment-variables.html#JULIA_ERROR_COLOR-1","page":"Environment Variables","title":"JULIA_ERROR_COLOR","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The formatting Base.error_color() (default: light red, \"\\033[91m\") that errors should have at the terminal.","category":"page"},{"location":"manual/environment-variables.html#JULIA_WARN_COLOR-1","page":"Environment Variables","title":"JULIA_WARN_COLOR","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The formatting Base.warn_color() (default: yellow, \"\\033[93m\") that warnings should have at the terminal.","category":"page"},{"location":"manual/environment-variables.html#JULIA_INFO_COLOR-1","page":"Environment Variables","title":"JULIA_INFO_COLOR","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The formatting Base.info_color() (default: cyan, \"\\033[36m\") that info should have at the terminal.","category":"page"},{"location":"manual/environment-variables.html#JULIA_INPUT_COLOR-1","page":"Environment Variables","title":"JULIA_INPUT_COLOR","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The formatting Base.input_color() (default: normal, \"\\033[0m\") that input should have at the terminal.","category":"page"},{"location":"manual/environment-variables.html#JULIA_ANSWER_COLOR-1","page":"Environment Variables","title":"JULIA_ANSWER_COLOR","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The formatting Base.answer_color() (default: normal, \"\\033[0m\") that output should have at the terminal.","category":"page"},{"location":"manual/environment-variables.html#JULIA_STACKFRAME_LINEINFO_COLOR-1","page":"Environment Variables","title":"JULIA_STACKFRAME_LINEINFO_COLOR","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The formatting Base.stackframe_lineinfo_color() (default: bold, \"\\033[1m\")  that line info should have during a stack trace at the terminal.","category":"page"},{"location":"manual/environment-variables.html#JULIA_STACKFRAME_FUNCTION_COLOR-1","page":"Environment Variables","title":"JULIA_STACKFRAME_FUNCTION_COLOR","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"The formatting Base.stackframe_function_color() (default: bold, \"\\033[1m\")  that function calls should have during a stack trace at the terminal.","category":"page"},{"location":"manual/environment-variables.html#Debugging-and-profiling-1","page":"Environment Variables","title":"Debugging and profiling","text":"","category":"section"},{"location":"manual/environment-variables.html#JULIA_GC_ALLOC_POOL,-JULIA_GC_ALLOC_OTHER,-JULIA_GC_ALLOC_PRINT-1","page":"Environment Variables","title":"JULIA_GC_ALLOC_POOL, JULIA_GC_ALLOC_OTHER, JULIA_GC_ALLOC_PRINT","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"If set, these environment variables take strings that optionally start with the character 'r', followed by a string interpolation of a colon-separated list of three signed 64-bit integers (int64_t). This triple of integers a:b:c represents the arithmetic sequence a, a + b, a + 2*b, ... c.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"If it's the nth time that jl_gc_pool_alloc() has been called, and   n belongs to the arithmetic sequence represented by   $JULIA_GC_ALLOC_POOL, then garbage collection is forced.\nIf it's the nth time that maybe_collect() has been called, and n   belongs to the arithmetic sequence represented by   $JULIA_GC_ALLOC_OTHER, then garbage collection is forced.\nIf it's the nth time that jl_gc_collect() has been called, and n   belongs to the arithmetic sequence represented by   $JULIA_GC_ALLOC_PRINT, then counts for the number of calls to   jl_gc_pool_alloc() and maybe_collect() are printed.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"If the value of the environment variable begins with the character 'r', then the interval between garbage collection events is randomized.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"note: Note\nThese environment variables only have an effect if Julia was compiled with garbage-collection debugging (that is, if WITH_GC_DEBUG_ENV is set to 1 in the build configuration).","category":"page"},{"location":"manual/environment-variables.html#JULIA_GC_NO_GENERATIONAL-1","page":"Environment Variables","title":"JULIA_GC_NO_GENERATIONAL","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"If set to anything besides 0, then the Julia garbage collector never performs \"quick sweeps\" of memory.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"note: Note\nThis environment variable only has an effect if Julia was compiled with garbage-collection debugging (that is, if WITH_GC_DEBUG_ENV is set to 1 in the build configuration).","category":"page"},{"location":"manual/environment-variables.html#JULIA_GC_WAIT_FOR_DEBUGGER-1","page":"Environment Variables","title":"JULIA_GC_WAIT_FOR_DEBUGGER","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"If set to anything besides 0, then the Julia garbage collector will wait for a debugger to attach instead of aborting whenever there's a critical error.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"note: Note\nThis environment variable only has an effect if Julia was compiled with garbage-collection debugging (that is, if WITH_GC_DEBUG_ENV is set to 1 in the build configuration).","category":"page"},{"location":"manual/environment-variables.html#ENABLE_JITPROFILING-1","page":"Environment Variables","title":"ENABLE_JITPROFILING","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"If set to anything besides 0, then the compiler will create and register an event listener for just-in-time (JIT) profiling.","category":"page"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"note: Note\nThis environment variable only has an effect if Julia was compiled with JIT profiling support, using eitherIntel's VTune™ Amplifier (USE_INTEL_JITEVENTS set to 1 in the build configuration), or\nOProfile (USE_OPROFILE_JITEVENTS set to 1 in the build configuration).","category":"page"},{"location":"manual/environment-variables.html#JULIA_LLVM_ARGS-1","page":"Environment Variables","title":"JULIA_LLVM_ARGS","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"Arguments to be passed to the LLVM backend.","category":"page"},{"location":"manual/environment-variables.html#JULIA_DEBUG_LOADING-1","page":"Environment Variables","title":"JULIA_DEBUG_LOADING","text":"","category":"section"},{"location":"manual/environment-variables.html#","page":"Environment Variables","title":"Environment Variables","text":"If set, then Julia prints detailed information about the cache in the loading process of Base.require.","category":"page"},{"location":"manual/embedding.html#embedding-julia-1","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"「C と Fortran Code を呼び出す」(@ref Calling-C-and-Fortran-Code)で見てきたように、Julia には C で書かれた関数を呼び出す簡単で効率的な方法があります。しかし、逆のことが必要な状況もあるでしょう C コードから Julia 関数を呼び出すということです。これは、Julia 関数をC/C++ ですべてを書き換えることなく、Julia コードをより大きな C/C+プロジェクトに統合するために使用できます。ジュリアはこれを可能にするC APIを持っています。ほとんどすべてのプログラミング言語はC関数を呼び出す何らかの方法を持っているので、Julia C APIを使用して、さらに言語ブリッジを構築することもできます(例えば、PythonやC#からJuliaを呼び出すなど)。","category":"page"},{"location":"manual/embedding.html#High-Level-Embedding-1","page":"Julia の埋め込み","title":"High-Level Embedding","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Note: This section covers embedding Julia code in C on Unix-like operating systems. For doing this on Windows, please see the section following this.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"We start with a simple C program that initializes Julia and calls some Julia code:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"#include <julia.h>\nJULIA_DEFINE_FAST_TLS() // only define this once, in an executable (not in a shared library) if you want fast code.\n\nint main(int argc, char *argv[])\n{\n    /* required: setup the Julia context */\n    jl_init();\n\n    /* run Julia commands */\n    jl_eval_string(\"print(sqrt(2.0))\");\n\n    /* strongly recommended: notify Julia that the\n         program is about to terminate. this allows\n         Julia time to cleanup pending write requests\n         and run all finalizers\n    */\n    jl_atexit_hook(0);\n    return 0;\n}","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"In order to build this program you have to put the path to the Julia header into the include path and link against libjulia. For instance, when Julia is installed to $JULIA_DIR, one can compile the above test program test.c with gcc using:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib test.c -ljulia $JULIA_DIR/lib/julia/libstdc++.so.6","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Then if the environment variable JULIA_BINDIR is set to $JULIA_DIR/bin, the output test program can be executed.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Alternatively, look at the embedding.c program in the Julia source tree in the test/embedding/ folder.  The file ui/repl.c program is another simple example of how to set jl_options options while linking against libjulia.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling jl_init, which tries to automatically determine Julia's install location. If you need to specify a custom location, or specify which system image to load, use jl_init_with_image instead.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"The second statement in the test program evaluates a Julia statement using a call to jl_eval_string.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Before the program terminates, it is strongly recommended to call jl_atexit_hook.  The above example program calls this before returning from main.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"note: Note\nCurrently, dynamically linking with the libjulia shared library requires passing the RTLD_GLOBAL option. In Python, this looks like:>>> julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)\n>>> julia.jl_init.argtypes = []\n>>> julia.jl_init()\n250593296","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"note: Note\nIf the julia program needs to access symbols from the main executable, it may be necessary to add -Wl,--export-dynamic linker flag at compile time on Linux in addition to the ones generated by julia-config.jl described below. This is not necessary when compiling a shared library.","category":"page"},{"location":"manual/embedding.html#Using-julia-config-to-automatically-determine-build-parameters-1","page":"Julia の埋め込み","title":"Using julia-config to automatically determine build parameters","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"The script julia-config.jl was created to aid in determining what build parameters are required by a program that uses embedded Julia.  This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution.  This script is located in the Julia shared data directory.","category":"page"},{"location":"manual/embedding.html#Example-1","page":"Julia の埋め込み","title":"Example","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"#include <julia.h>\n\nint main(int argc, char *argv[])\n{\n    jl_init();\n    (void)jl_eval_string(\"println(sqrt(2.0))\");\n    jl_atexit_hook(0);\n    return 0;\n}","category":"page"},{"location":"manual/embedding.html#On-the-command-line-1","page":"Julia の埋め込み","title":"On the command line","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"A simple use of this script is from the command line.  Assuming that julia-config.jl is located in /usr/local/julia/share/julia, it can be invoked on the command line directly and takes any combination of 3 flags:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"/usr/local/julia/share/julia/julia-config.jl\nUsage: julia-config [--cflags|--ldflags|--ldlibs]","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"If the above example source is saved in the file embed_example.c, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute clang for gcc.:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c","category":"page"},{"location":"manual/embedding.html#Use-in-Makefiles-1","page":"Julia の埋め込み","title":"Use in Makefiles","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well – assuming GNU make because of the use of the shell macro expansions.  Additionally, though many times julia-config.jl may be found in the directory /usr/local, this is not necessarily the case, but Julia can be used to locate julia-config.jl too, and the makefile can be used to take advantage of that.  The above example is extended to use a Makefile:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"JL_SHARE = $(shell julia -e 'print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, \"julia\"))')\nCFLAGS   += $(shell $(JL_SHARE)/julia-config.jl --cflags)\nCXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)\nLDFLAGS  += $(shell $(JL_SHARE)/julia-config.jl --ldflags)\nLDLIBS   += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)\n\nall: embed_example","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Now the build command is simply make.","category":"page"},{"location":"manual/embedding.html#High-Level-Embedding-on-Windows-with-Visual-Studio-1","page":"Julia の埋め込み","title":"High-Level Embedding on Windows with Visual Studio","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"If the JULIA_DIR environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The bin folder under JULIA_DIR should be on the system PATH.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"We start by opening Visual Studio and creating a new Console Application project. To the 'stdafx.h' header file, add the following lines at the end:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"#define JULIA_ENABLE_THREADING\n#include <julia.h>","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Then, replace the main() function in the project with this code:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"int main(int argc, char *argv[])\n{\n    /* required: setup the Julia context */\n    jl_init();\n\n    /* run Julia commands */\n    jl_eval_string(\"print(sqrt(2.0))\");\n\n    /* strongly recommended: notify Julia that the\n         program is about to terminate. this allows\n         Julia time to cleanup pending write requests\n         and run all finalizers\n    */\n    jl_atexit_hook(0);\n    return 0;\n}","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"The next step is to set up the project to find the Julia include files and the libraries. It's important to know whether the Julia installation is 32- or 64-bits. Remove any platform configuration that doesn't correspond to the Julia installation before proceeding.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Using the project Properties dialog, go to C/C++ | General and add $(JULIA_DIR)\\include\\julia\\ to the Additional Include Directories property. Then, go to the Linker | General section and add $(JULIA_DIR)\\lib to the Additional Library Directories property. Finally, under Linker | Input, add libjulia.dll.a;libopenlibm.dll.a; to the list of libraries.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"At this point, the project should build and run.","category":"page"},{"location":"manual/embedding.html#Converting-Types-1","page":"Julia の埋め込み","title":"Converting Types","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Real applications will not just need to execute expressions, but also return their values to the host program. jl_eval_string returns a jl_value_t*, which is a pointer to a heap-allocated Julia object. Storing simple data types like Float64 in this way is called boxing, and extracting the stored primitive data is called unboxing. Our improved sample program that calculates the square root of 2 in Julia and reads back the result in C looks as follows:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_value_t *ret = jl_eval_string(\"sqrt(2.0)\");\n\nif (jl_typeis(ret, jl_float64_type)) {\n    double ret_unboxed = jl_unbox_float64(ret);\n    printf(\"sqrt(2.0) in C: %e \\n\", ret_unboxed);\n}\nelse {\n    printf(\"ERROR: unexpected return type from sqrt(::Float64)\\n\");\n}","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"In order to check whether ret is of a specific Julia type, we can use the jl_isa, jl_typeis, or jl_is_... functions.  By typing typeof(sqrt(2.0)) into the Julia shell we can see that the return type is Float64 (double in C). To convert the boxed Julia value into a C double the jl_unbox_float64 function is used in the above code snippet.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Corresponding jl_box_... functions are used to convert the other way:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_value_t *a = jl_box_float64(3.0);\njl_value_t *b = jl_box_float32(3.0f);\njl_value_t *c = jl_box_int32(3);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"As we will see next, boxing is required to call Julia functions with specific arguments.","category":"page"},{"location":"manual/embedding.html#Calling-Julia-Functions-1","page":"Julia の埋め込み","title":"Calling Julia Functions","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"While jl_eval_string allows C to obtain the result of a Julia expression, it does not allow passing arguments computed in C to Julia. For this you will need to invoke Julia functions directly, using jl_call:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_function_t *func = jl_get_function(jl_base_module, \"sqrt\");\njl_value_t *argument = jl_box_float64(2.0);\njl_value_t *ret = jl_call1(func, argument);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"In the first step, a handle to the Julia function sqrt is retrieved by calling jl_get_function.  The first argument passed to jl_get_function is a pointer to the Base module in which sqrt is defined. Then, the double value is boxed using jl_box_float64. Finally, in the last step, the function is called using jl_call1. jl_call0, jl_call2, and jl_call3 functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use jl_call:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Its second argument args is an array of jl_value_t* arguments and nargs is the number of arguments.","category":"page"},{"location":"manual/embedding.html#Memory-Management-1","page":"Julia の埋め込み","title":"Memory Management","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that we are holding a reference to a Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"The GC can only run when Julia objects are allocated. Calls like jl_box_float64 perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between jl_... calls. But in order to make sure that values can survive jl_... calls, we have to tell Julia that we hold a reference to a Julia value. This can be done using the JL_GC_PUSH macros:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_value_t *ret = jl_eval_string(\"sqrt(2.0)\");\nJL_GC_PUSH1(&ret);\n// Do something with ret\nJL_GC_POP();","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"The JL_GC_POP call releases the references established by the previous JL_GC_PUSH. Note that JL_GC_PUSH stores references on the C stack, so it must be exactly paired with a JL_GC_POP before the scope is exited. That is, before the function returns, or control flow otherwise leaves the block in which the JL_GC_PUSH was invoked.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Several Julia values can be pushed at once using the JL_GC_PUSH2 , JL_GC_PUSH3 , JL_GC_PUSH4 , JL_GC_PUSH5 , and JL_GC_PUSH6 macros. To push an array of Julia values one can use the JL_GC_PUSHARGS macro, which can be used as follows:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_value_t **args;\nJL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects\nargs[0] = some_value;\nargs[1] = some_other_value;\n// Do something with args (e.g. call jl_... functions)\nJL_GC_POP();","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Each scope must have only one call to JL_GC_PUSH*. Hence, if all variables cannot be pushed once by a single call to JL_GC_PUSH*, or if there are more than 6 variables to be pushed and using an array of arguments is not an option, then one can use inner blocks:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_value_t *ret1 = jl_eval_string(\"sqrt(2.0)\");\nJL_GC_PUSH1(&ret1);\njl_value_t *ret2 = 0;\n{\n    jl_function_t *func = jl_get_function(jl_base_module, \"exp\");\n    ret2 = jl_call1(func, ret1);\n    JL_GC_PUSH1(&ret2);\n    // Do something with ret2.\n    JL_GC_POP();    // This pops ret2.\n}\nJL_GC_POP();    // This pops ret1.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use JL_GC_PUSH*. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global IdDict that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"// This functions shall be executed only once, during the initialization.\njl_value_t* refs = jl_eval_string(\"refs = IdDict()\");\njl_function_t* setindex = jl_get_function(jl_base_module, \"setindex!\");\n\n...\n\n// `var` is the variable we want to protect between function calls.\njl_value_t* var = 0;\n\n...\n\n// `var` is a `Vector{Float64}`, which is mutable.\nvar = jl_eval_string(\"[sqrt(2.0); sqrt(4.0); sqrt(6.0)]\");\n\n// To protect `var`, add its reference to `refs`.\njl_call3(setindex, refs, var, var);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a RefValue{Any} before it is pushed to IdDict. In this approach, the container has to be created or filled in via C code using, for example, the function jl_new_struct. If the container is created by jl_call*, then you will need to reload the pointer to be used in C code.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"// This functions shall be executed only once, during the initialization.\njl_value_t* refs = jl_eval_string(\"refs = IdDict()\");\njl_function_t* setindex = jl_get_function(jl_base_module, \"setindex!\");\njl_datatype_t* reft = (jl_datatype_t*)jl_eval_string(\"Base.RefValue{Any}\");\n\n...\n\n// `var` is the variable we want to protect between function calls.\njl_value_t* var = 0;\n\n...\n\n// `var` is a `Float64`, which is immutable.\nvar = jl_eval_string(\"sqrt(2.0)\");\n\n// Protect `var` until we add its reference to `refs`.\nJL_GC_PUSH1(&var);\n\n// Wrap `var` in `RefValue{Any}` and push to `refs` to protect it.\njl_value_t* rvar = jl_new_struct(reft, var);\nJL_GC_POP();\n\njl_call3(setindex, refs, rvar, rvar);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"The GC can be allowed to deallocate a variable by removing the reference to it from refs using the function delete!, provided that no other reference to the variable is kept anywhere:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_function_t* delete = jl_get_function(jl_base_module, \"delete!\");\njl_call2(delete, refs, rvar);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"As an alternative for very simple cases, it is possible to just create a global container of type Vector{Any} and fetch the elements from that when necessary, or even to create one global variable per pointer using","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_set_global(jl_main_module, jl_symbol(\"var\"), var);","category":"page"},{"location":"manual/embedding.html#Updating-fields-of-GC-managed-objects-1","page":"Julia の埋め込み","title":"Updating fields of GC-managed objects","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"The garbage collector operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the jl_gc_wb (write barrier) function like so:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_value_t *parent = some_old_value, *child = some_young_value;\n((some_specific_type*)parent)->field = child;\njl_gc_wb(parent, child);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the parent object was just allocated and garbage collection was not run since then. Remember that most jl_... functions can sometimes invoke garbage collection.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"The write barrier is also necessary for arrays of pointers when updating their data directly.  For example:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_array_t *some_array = ...; // e.g. a Vector{Any}\nvoid **data = (void**)jl_array_data(some_array);\njl_value_t *some_value = ...;\ndata[0] = some_value;\njl_gc_wb(some_array, some_value);","category":"page"},{"location":"manual/embedding.html#Manipulating-the-Garbage-Collector-1","page":"Julia の埋め込み","title":"Manipulating the Garbage Collector","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"There are some functions to control the GC. In normal use cases, these should not be necessary.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Function Description\njl_gc_collect() Force a GC run\njl_gc_enable(0) Disable the GC, return previous state as int\njl_gc_enable(1) Enable the GC,  return previous state as int\njl_gc_is_enabled() Return current state as int","category":"page"},{"location":"manual/embedding.html#Working-with-Arrays-1","page":"Julia の埋め込み","title":"Working with Arrays","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Julia and C can share array data without copying. The next example will show how this works.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Julia arrays are represented in C by the datatype jl_array_t*. Basically, jl_array_t is a struct that contains:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Information about the datatype\nA pointer to the data block\nInformation about the sizes of the array","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"To keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is done by:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);\njl_array_t* x          = jl_alloc_array_1d(array_type, 10);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"double *existingArray = (double*)malloc(sizeof(double)*10);\njl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call free on the data pointer when the array is no longer referenced.","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"In order to access the data of x, we can use jl_array_data:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"double *xData = (double*)jl_array_data(x);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Now we can fill the array:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"for(size_t i=0; i<jl_array_len(x); i++)\n    xData[i] = i;","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Now let us call a Julia function that performs an in-place operation on x:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_function_t *func = jl_get_function(jl_base_module, \"reverse!\");\njl_call1(func, (jl_value_t*)x);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"By printing the array, one can verify that the elements of x are now reversed.","category":"page"},{"location":"manual/embedding.html#Accessing-Returned-Arrays-1","page":"Julia の埋め込み","title":"Accessing Returned Arrays","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"If a Julia function returns an array, the return value of jl_eval_string and jl_call can be cast to a jl_array_t*:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_function_t *func  = jl_get_function(jl_base_module, \"reverse\");\njl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Now the content of y can be accessed as before using jl_array_data. As always, be sure to keep a reference to the array while it is in use.","category":"page"},{"location":"manual/embedding.html#Multidimensional-Arrays-1","page":"Julia の埋め込み","title":"Multidimensional Arrays","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"// Create 2D array of float64 type\njl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);\njl_array_t *x  = jl_alloc_array_2d(array_type, 10, 5);\n\n// Get array pointer\ndouble *p = (double*)jl_array_data(x);\n// Get number of dimensions\nint ndims = jl_array_ndims(x);\n// Get the size of the i-th dim\nsize_t size0 = jl_array_dim(x,0);\nsize_t size1 = jl_array_dim(x,1);\n\n// Fill array with data\nfor(size_t i=0; i<size1; i++)\n    for(size_t j=0; j<size0; j++)\n        p[j + size0*i] = i + j;","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling jl_array_dim) in order to read as idiomatic C code.","category":"page"},{"location":"manual/embedding.html#Exceptions-1","page":"Julia の埋め込み","title":"Exceptions","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"Julia code can throw exceptions. For example, consider:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_eval_string(\"this_function_does_not_exist()\");","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"This call will appear to do nothing. However, it is possible to check whether an exception was thrown:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"if (jl_exception_occurred())\n    printf(\"%s \\n\", jl_typeof_str(jl_exception_occurred()));","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into libjulia with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.","category":"page"},{"location":"manual/embedding.html#Throwing-Julia-Exceptions-1","page":"Julia の埋め込み","title":"Throwing Julia Exceptions","text":"","category":"section"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions to indicate errors. A typical type check looks like:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"if (!jl_typeis(val, jl_float64_type)) {\n    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);\n}","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"General exceptions can be raised using the functions:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"void jl_error(const char *str);\nvoid jl_errorf(const char *fmt, ...);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_error takes a C string, and jl_errorf is called like printf:","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"jl_errorf(\"argument x = %d is too large\", x);","category":"page"},{"location":"manual/embedding.html#","page":"Julia の埋め込み","title":"Julia の埋め込み","text":"where in this example x is assumed to be an integer.","category":"page"},{"location":"manual/code-loading.html#Code-Loading-1","page":"Code Loading","title":"Code Loading","text":"","category":"section"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"note: Note\nThis chapter covers the technical details of package loading. To install packages, use Pkg, Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write import X or using X, as described in the Modules documentation.","category":"page"},{"location":"manual/code-loading.html#Definitions-1","page":"Code Loading","title":"Definitions","text":"","category":"section"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Julia has two mechanisms for loading code:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Code inclusion: e.g. include(\"source.jl\"). Inclusion allows you to split a single program across multiple source files. The expression include(\"source.jl\") causes the contents of the file source.jl to be evaluated in the global scope of the module where the include call occurs. If include(\"source.jl\") is called multiple times, source.jl is evaluated multiple times. The included path, source.jl, is interpreted relative to the file where the include call occurs. This makes it simple to relocate a subtree of source files. In the REPL, included paths are interpreted relative to the current working directory, pwd().\nPackage loading: e.g. import X or using X. The import mechanism allows you to load a package—i.e. an independent, reusable collection of Julia code, wrapped in a module—and makes the resulting module available by the name X inside of the importing module. If the same X package is imported multiple times in the same Julia session, it is only loaded the first time—on subsequent imports, the importing module gets a reference to the same module. Note though, that import X can load different packages in different contexts: X can refer to one package named X in the main project but potentially to different packages also named X in each dependency. More on this below.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is built on top of code inclusion and serves a different purpose. The rest of this chapter focuses on the behavior and mechanics of package loading.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"A package is a source tree with a standard layout providing functionality that can be reused by other Julia projects. A package is loaded by import X or using X statements. These statements also make the module named X—which results from loading the package code—available within the module where the import statement occurs. The meaning of X in import X is context-dependent: which X package is loaded depends on what code the statement occurs in. Thus, handling of import X happens in two stages: first, it determines what package is defined to be X in this context; second, it determines where that particular X package is found.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"These questions are answered by searching through the project environments listed in LOAD_PATH for project files (Project.toml or JuliaProject.toml), manifest files (Manifest.toml or JuliaManifest.toml), or folders of source files.","category":"page"},{"location":"manual/code-loading.html#Federation-of-packages-1","page":"Code Loading","title":"Federation of packages","text":"","category":"section"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Most of the time, a package is uniquely identifiable simply from its name. However, sometimes a project might encounter a situation where it needs to use two different packages that share the same name. While you might be able fix this by renaming one of the packages, being forced to do so can be highly disruptive in a large, shared code base. Instead, Julia's code loading mechanism allows the same package name to refer to different packages in different components of an application.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Julia supports federated package management, which means that multiple independent parties can maintain both public and private packages and registries of packages, and that projects can depend on a mix of public and private packages from different registries. Packages from various registries are installed and managed using a common set of tools and workflows. The Pkg package manager that ships with Julia lets you install and manage your projects' dependencies. It assists in creating and manipulating project files (which describe what other projects that your project depends on), and manifest files (which snapshot exact versions of your project's complete dependency graph).","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"One consequence of federation is that there cannot be a central authority for package naming. Different entities may use the same name to refer to unrelated packages. This possibility is unavoidable since these entities do not coordinate and may not even know about each other. Because of the lack of a central naming authority, a single project may end up depending on different packages that have the same name. Julia's package loading mechanism does not require package names to be globally unique, even within the dependency graph of a single project. Instead, packages are identified by universally unique identifiers (UUIDs), which get assigned when each package is created. Usually you won't have to work directly with these somewhat cumbersome 128-bit identifiers since Pkg will take care of generating and tracking them for you. However, these UUIDs provide the definitive answer to the question of \"what package does X refer to?\"","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Since the decentralized naming problem is somewhat abstract, it may help to walk through a concrete scenario to understand the issue. Suppose you're developing an application called App, which uses two packages: Pub and Priv. Priv is a private package that you created, whereas Pub is a public package that you use but don't control. When you created Priv, there was no public package by the name Priv. Subsequently, however, an unrelated package also named Priv has been published and become popular. In fact, the Pub package has started to use it. Therefore, when you next upgrade Pub to get the latest bug fixes and features, App will end up depending on two different packages named Priv—through no action of yours other than upgrading. App has a direct dependency on your private Priv package, and an indirect dependency, through Pub, on the new public Priv package. Since these two Priv packages are different but are both required for App to continue working correctly, the expression import Priv must refer to different Priv packages depending on whether it occurs in App's code or in Pub's code. To handle this, Julia's package loading mechanism distinguishes the two Priv packages by their UUID and picks the correct one based on its context (the module that called import). How this distinction works is determined by environments, as explained in the following sections.","category":"page"},{"location":"manual/code-loading.html#Environments-1","page":"Code Loading","title":"Environments","text":"","category":"section"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"An environment determines what import X and using X mean in various code contexts and what files these statements cause to be loaded. Julia understands two kinds of environments:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"A project environment is a directory with a project file and an optional manifest file, and forms an explicit environement. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.\nA package directory is a directory containing the source trees of a set of packages as subdirectories, and forms an implicit environment. If X is a subdirectory of a package directory and X/src/X.jl exists, then the package X is available in the package directory environment and X/src/X.jl is the source file by which it is loaded.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"These can be intermixed to create a stacked environment: an ordered set of project environments and package directories, overlaid to make a single composite environment. The precedence and visibility rules then combine to determine which packages are available and where they get loaded from. Julia's load path forms a stacked environment, for example.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"These environment each serve a different purpose:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Project environments provide reproducibility. By checking a project environment into version control—e.g. a git repository—along with the rest of the project's source code, you can reproduce the exact state of the project and all of its dependencies. The manifest file, in particular, captures the exact version of every dependency, identified by a cryptographic hash of its source tree, which makes it possible for Pkg to retrieve the correct versions and be sure that you are running the exact code that was recorded for all dependencies.\nPackage directories provide convenience when a full carefully-tracked project environment is unnecessary. They are useful when you want to put a set of packages somewhere and be able to directly use them, without needing to create a project environment for them.\nStacked environments allow for adding tools to the primary environment. You can push an environment of development tools onto the end of the stack to make them available from the REPL and scripts, but not from inside packages.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"At a high-level, each environment conceptually defines three maps: roots, graph and paths. When resolving the meaning of import X, the roots and graph maps are used to determine the identity of X, while the paths map is used to locate the source code of X. The specific roles of the three maps are:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"roots: name::Symbol ⟶ uuid::UUID\nAn environment's roots map assigns package names to UUIDs for all the top-level dependencies that the environment makes available to the main project (i.e. the ones that can be loaded in Main). When Julia encounters import X in the main project, it looks up the identity of X as roots[:X].\ngraph: context::UUID ⟶ name::Symbol ⟶ uuid::UUID\nAn environment's graph is a multilevel map which assigns, for each context UUID, a map from names to UUIDs, similar to the roots map but specific to that context. When Julia sees import X in the code of the package whose UUID is context, it looks up the identity of X as graph[context][:X]. In particular, this means that import X can refer to different packages depending on context.\npaths: uuid::UUID × name::Symbol ⟶ path::String\nThe paths map assigns to each package UUID-name pair, the location of that package's entry-point source file. After the identity of X in import X has been resolved to a UUID via roots or graph (depending on whether it is loaded from the main project or a dependency), Julia determines what file to load to acquire X by looking up paths[uuid,:X] in the environment. Including this file should define a module named X. Once this package is loaded, any subsequent import resolving to the same uuid will create a new binding to the already-loaded package module.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Each kind of environment defines these three maps differently, as detailed in the following sections.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"note: Note\nFor ease of understanding, the examples throughout this chapter show full data structures for roots, graph and paths. However, Julia's package loading code does not explicitly create these. Instead, it lazily computes only as much of each structure as it needs to load a given package.","category":"page"},{"location":"manual/code-loading.html#Project-environments-1","page":"Code Loading","title":"Project environments","text":"","category":"section"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"A project environment is determined by a directory containing a project file called Project.toml, and optionally a manifest file called Manifest.toml. These files may also be called JuliaProject.toml and JuliaManifest.toml, in which case Project.toml and Manifest.toml are ignored. This allows for coexistence with other tools that might consider files called Project.toml and Manifest.toml significant. For pure Julia projects, however, the names Project.toml and Manifest.toml are preferred.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"The roots, graph and paths maps of a project environment are defined as follows:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"The roots map of the environment is determined by the contents of the project file, specifically, its top-level name and uuid entries and its [deps] section (all optional). Consider the following example project file for the hypothetical application, App, as described earlier:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"name = \"App\"\nuuid = \"8f986787-14fe-4607-ba5d-fbff2944afa9\"\n\n[deps]\nPriv = \"ba13f791-ae1d-465a-978b-69c3ad90f72b\"\nPub  = \"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"This project file implies the following roots map, if it was represented by a Julia dictionary:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"roots = Dict(\n    :App  => UUID(\"8f986787-14fe-4607-ba5d-fbff2944afa9\"),\n    :Priv => UUID(\"ba13f791-ae1d-465a-978b-69c3ad90f72b\"),\n    :Pub  => UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"),\n)","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Given this roots map, in App's code the statement import Priv will cause Julia to look up roots[:Priv], which yields ba13f791-ae1d-465a-978b-69c3ad90f72b, the UUID of the Priv package that is to be loaded in that context. This UUID identifies which Priv package to load and use when the main application evaluates import Priv.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"The dependency graph of a project environment is determined by the contents of the manifest file, if present. If there is no manifest file, graph is empty. A manifest file contains a stanza for each of a project's direct or indirect dependencies. For each dependency, the file lists the package's UUID and a source tree hash or an explicit path to the source code. Consider the following example manifest file for App:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"[[Priv]] # the private one\ndeps = [\"Pub\", \"Zebra\"]\nuuid = \"ba13f791-ae1d-465a-978b-69c3ad90f72b\"\npath = \"deps/Priv\"\n\n[[Priv]] # the public one\nuuid = \"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"\ngit-tree-sha1 = \"1bf63d3be994fe83456a03b874b409cfd59a6373\"\nversion = \"0.1.5\"\n\n[[Pub]]\nuuid = \"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"\ngit-tree-sha1 = \"9ebd50e2b0dd1e110e842df3b433cb5869b0dd38\"\nversion = \"2.1.4\"\n\n  [Pub.deps]\n  Priv = \"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"\n  Zebra = \"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"\n\n[[Zebra]]\nuuid = \"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"\ngit-tree-sha1 = \"e808e36a5d7173974b90a15a353b564f3494092f\"\nversion = \"3.4.2\"","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"This manifest file describes a possible complete dependency graph for the App project:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"There are two different packages named Priv that the application uses. It uses a private package, which is a root dependency, and a public one, which is an indirect dependency through Pub. These are differentiated by their distinct UUIDs, and they have different deps:\nThe private Priv depends on the Pub and Zebra packages.\nThe public Priv has no dependencies.\nThe application also depends on the Pub package, which in turn depends on the public Priv and the same Zebra package that the private Priv package depends on.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"This dependency graph represented as a dictionary, looks like this:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"graph = Dict(\n    # Priv – the private one:\n    UUID(\"ba13f791-ae1d-465a-978b-69c3ad90f72b\") => Dict(\n        :Pub   => UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"),\n        :Zebra => UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"),\n    ),\n    # Priv – the public one:\n    UUID(\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\") => Dict(),\n    # Pub:\n    UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\") => Dict(\n        :Priv  => UUID(\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"),\n        :Zebra => UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"),\n    ),\n    # Zebra:\n    UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\") => Dict(),\n)","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Given this dependency graph, when Julia sees import Priv in the Pub package—which has UUID c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1—it looks up:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"graph[UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\")][:Priv]","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"and gets 2d15fe94-a1f7-436c-a4d8-07a9a496e01c, which indicates that in the context of the Pub package, import Priv refers to the public Priv package, rather than the private one which the app depends on directly. This is how the name Priv can refer to different packages in the main project than it does in one of its package's dependencies, which allows for duplicate names in the package ecosystem.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"What happens if import Zebra is evaluated in the main App code base? Since Zebra does not appear in the project file, the import will fail even though Zebra does appear in the manifest file. Moreover, if import Zebra occurs in the public Priv package—the one with UUID 2d15fe94-a1f7-436c-a4d8-07a9a496e01c—then that would also fail since that Priv package has no declared dependencies in the manifest file and therefore cannot load any packages. The Zebra package can only be loaded by packages for which it appear as an explicit dependency in the manifest file: the Pub package and one of the Priv packages.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"The paths map of a project environment is extracted from the manifest file. The path of a package uuid named X is determined by these rules (in order):","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"If the project file in the directory matches uuid and name X, then either:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"It has a toplevel path entry, then uuid will be mapped to that path, interpreted relative to the directory containing the project file.\nOtherwise, uuid is mapped to  src/X.jl relative to the directory containing the project file.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"If the above is not the case and the project file has a corresponding manifest file and the manifest contains a stanza matching uuid then:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"If it has a path entry, use that path (relative to the directory containing the manifest file).\nIf it has a git-tree-sha1 entry, compute a deterministic hash function of uuid and git-tree-sha1—call it slug—and look for a directory named packages/X/$slug in each directory in the Julia DEPOT_PATH global array. Use the first such directory that exists.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"If any of these result in success, the path to the source code entry point will be either that result, the relative path from that result plus src/X.jl; otherwise, there is no path mapping for uuid. When loading X, if no source code path is found, the lookup will fail, and the user may be prompted to install the appropriate package version or to take other corrective action (e.g. declaring X as a dependency).","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"In the example manifest file above, to find the path of the first Priv package—the one with UUID ba13f791-ae1d-465a-978b-69c3ad90f72b—Julia looks for its stanza in the manifest file, sees that it has a path entry, looks at deps/Priv relative to the App project directory—let's suppose the App code lives in /home/me/projects/App—sees that /home/me/projects/App/deps/Priv exists and therefore loads Priv from there.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"If, on the other hand, Julia was loading the other Priv package—the one with UUID 2d15fe94-a1f7-436c-a4d8-07a9a496e01c—it finds its stanza in the manifest, see that it does not have a path entry, but that it does have a git-tree-sha1 entry. It then computes the slug for this UUID/SHA-1 pair, which is HDkrT (the exact details of this computation aren't important, but it is consistent and deterministic). This means that the path to this Priv package will be packages/Priv/HDkrT/src/Priv.jl in one of the package depots. Suppose the contents of DEPOT_PATH is [\"/home/me/.julia\", \"/usr/local/julia\"], then Julia will look at the following paths to see if they exist:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"/home/me/.julia/packages/Priv/HDkrT\n/usr/local/julia/packages/Priv/HDkrT","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Julia uses the first of these that exists to try to load the public Priv package from the file packages/Priv/HDKrT/src/Priv.jl in the depot where it was found.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Here is a representation of a possible paths map for our example App project environment, as provided in the Manifest given above for the dependency graph, after searching the local file system:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"paths = Dict(\n    # Priv – the private one:\n    (UUID(\"ba13f791-ae1d-465a-978b-69c3ad90f72b\"), :Priv) =>\n        # relative entry-point inside `App` repo:\n        \"/home/me/projects/App/deps/Priv/src/Priv.jl\",\n    # Priv – the public one:\n    (UUID(\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"), :Priv) =>\n        # package installed in the system depot:\n        \"/usr/local/julia/packages/Priv/HDkr/src/Priv.jl\",\n    # Pub:\n    (UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"), :Pub) =>\n        # package installed in the user depot:\n        \"/home/me/.julia/packages/Pub/oKpw/src/Pub.jl\",\n    # Zebra:\n    (UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"), :Zebra) =>\n        # package installed in the system depot:\n        \"/usr/local/julia/packages/Zebra/me9k/src/Zebra.jl\",\n)","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"This example map includes three different kinds of package locations (the first and third are part of the default load path):","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"The private Priv package is \"vendored\" inside the App repository.\nThe public Priv and Zebra packages are in the system depot, where packages installed and managed by the system administrator live. These are available to all users on the system.\nThe Pub package is in the user depot, where packages installed by the user live. These are only available to the user who installed them.","category":"page"},{"location":"manual/code-loading.html#Package-directories-1","page":"Code Loading","title":"Package directories","text":"","category":"section"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Package directories provide a simpler kind of environment without the ability to handle name collisions. In a package directory, the set of top-level packages is the set of subdirectories that \"look like\" packages. A package X is exists in a package directory if the directory contains one of the following \"entry point\" files:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"X.jl - X/src/X.jl - X.jl/src/X.jl","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Which dependencies a package in a package directory can import depends on whether the package contains a project file:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"If it has a project file, it can only import those packages which are identified in the [deps] section of the project file.\nIf it does not have a project file, it can import any top-level package—i.e. the same packages that can be loaded in Main or the REPL.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"The roots map is determined by examining the contents of the package directory to generate a list of all packages that exist. Additionally, a UUID will be assigned to each entry as follows: For a given package found inside the folder X...","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"If X/Project.toml exists and has a uuid entry, then uuid is that value.\nIf X/Project.toml exists and but does not have a top-level UUID entry, uuid is a dummy UUID generated by hashing the canonical (real) path to X/Project.toml.\nOtherwise (if Project.toml does not exist), then uuid is the all-zero nil UUID.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"The dependency graph of a project directory is determined by the presence and contents of project files in the subdirectory of each package. The rules are:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"If a package subdirectory has no project file, then it is omitted from","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"graph and import statements in its code are treated as top-level, the same as the main project and REPL.  - If a package subdirectory has a project file, then the graph entry for its UUID is the [deps] map of the project file, which is considered to be empty if the section is absent.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"As an example, suppose a package directory has the following structure and content:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Aardvark/\n    src/Aardvark.jl:\n        import Bobcat\n        import Cobra\n\nBobcat/\n    Project.toml:\n        [deps]\n        Cobra = \"4725e24d-f727-424b-bca0-c4307a3456fa\"\n        Dingo = \"7a7925be-828c-4418-bbeb-bac8dfc843bc\"\n\n    src/Bobcat.jl:\n        import Cobra\n        import Dingo\n\nCobra/\n    Project.toml:\n        uuid = \"4725e24d-f727-424b-bca0-c4307a3456fa\"\n        [deps]\n        Dingo = \"7a7925be-828c-4418-bbeb-bac8dfc843bc\"\n\n    src/Cobra.jl:\n        import Dingo\n\nDingo/\n    Project.toml:\n        uuid = \"7a7925be-828c-4418-bbeb-bac8dfc843bc\"\n\n    src/Dingo.jl:\n        # no imports","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Here is a corresponding roots structure, represented as a dictionary:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"roots = Dict(\n    :Aardvark => UUID(\"00000000-0000-0000-0000-000000000000\"), # no project file, nil UUID\n    :Bobcat   => UUID(\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\"), # dummy UUID based on path\n    :Cobra    => UUID(\"4725e24d-f727-424b-bca0-c4307a3456fa\"), # UUID from project file\n    :Dingo    => UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\"), # UUID from project file\n)","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Here is the corresponding graph structure, represented as a dictionary:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"graph = Dict(\n    # Bobcat:\n    UUID(\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\") => Dict(\n        :Cobra => UUID(\"4725e24d-f727-424b-bca0-c4307a3456fa\"),\n        :Dingo => UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\"),\n    ),\n    # Cobra:\n    UUID(\"4725e24d-f727-424b-bca0-c4307a3456fa\") => Dict(\n        :Dingo => UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\"),\n    ),\n    # Dingo:\n    UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\") => Dict(),\n)","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"A few general rules to note:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"A package without a project file can depend on any top-level dependency, and since every package in a package directory is available at the top-level, it can import all packages in the environment.\nA package with a project file cannot depend on one without a project file since packages with project files can only load packages in graph and packages without project files do not appear in graph.\nA package with a project file but no explicit UUID can only be depended on by packages without project files since dummy UUIDs assigned to these packages are strictly internal.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Observe the following specific instances of these rules in our example:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Aardvark can import on any of Bobcat, Cobra or Dingo; it does import Bobcat and Cobra.\nBobcat can and does import both Cobra and Dingo, which both have project files with UUIDs and are declared as dependencies in Bobcat's [deps] section.\nBobcat cannot depend on Aardvark since Aardvark does not have a project file.\nCobra can and does import Dingo, which has a project file and UUID, and is declared as a dependency in Cobra's [deps] section.\nCobra cannot depend on Aardvark or Bobcat since neither have real UUIDs.\nDingo cannot import anything because it has a project file without a [deps] section.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"The paths map in a package directory is simple: it maps subdirectory names to their corresponding entry-point paths. In other words, if the path to our example project directory is /home/me/animals then the paths map could be represented by this dictionary:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"paths = Dict(\n    (UUID(\"00000000-0000-0000-0000-000000000000\"), :Aardvark) =>\n        \"/home/me/AnimalPackages/Aardvark/src/Aardvark.jl\",\n    (UUID(\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\"), :Bobcat) =>\n        \"/home/me/AnimalPackages/Bobcat/src/Bobcat.jl\",\n    (UUID(\"4725e24d-f727-424b-bca0-c4307a3456fa\"), :Cobra) =>\n        \"/home/me/AnimalPackages/Cobra/src/Cobra.jl\",\n    (UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\"), :Dingo) =>\n        \"/home/me/AnimalPackages/Dingo/src/Dingo.jl\",\n)","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Since all packages in a package directory environment are, by definition, subdirectories with the expected entry-point files, their paths map entries always have this form.","category":"page"},{"location":"manual/code-loading.html#Environment-stacks-1","page":"Code Loading","title":"Environment stacks","text":"","category":"section"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"The third and final kind of environment is one that combines other environments by overlaying several of them, making the packages in each available in a single composite environment. These composite environments are called environment stacks. The Julia LOAD_PATH global defines an environment stack—the environment in which the Julia process operates. If you want your Julia process to have access only to the packages in one project or package directory, make it the only entry in LOAD_PATH. It is often quite useful, however, to have access to some of your favorite tools—standard libraries, profilers, debuggers, personal utilities, etc.—even if they are not dependencies of the project you're working on. By adding an environment containing these tools to the load path, you immediately have access to them in top-level code without needing to add them to your project.","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"The mechanism for combining the roots, graph and paths data structures of the components of an environment stack is simple: they are merged as dictionaries, favoring earlier entries over later ones in the case of key collisions. In other words, if we have stack = [env₁, env₂, …] then we have:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"roots = reduce(merge, reverse([roots₁, roots₂, …]))\ngraph = reduce(merge, reverse([graph₁, graph₂, …]))\npaths = reduce(merge, reverse([paths₁, paths₂, …]))","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"The subscripted rootsᵢ, graphᵢ and pathsᵢ variables correspond to the subscripted environments, envᵢ, contained in stack. The reverse is present because merge favors the last argument rather than first when there are collisions between keys in its argument dictionaries. There are a couple of noteworthy features of this design:","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"The primary environment—i.e. the first environment in a stack—is faithfully embedded in a stacked environment. The full dependency graph of the first environment in a stack is guaranteed to be included intact in the stacked environment including the same versions of all dependencies.\nPackages in non-primary environments can end up using incompatible versions of their dependencies even if their own environments are entirely compatible. This can happen when one of their dependencies is shadowed by a version in an earlier environment in the stack (either by graph or path, or both).","category":"page"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Since the primary environment is typically the environment of a project you're working on, while environments later in the stack contain additional tools, this is the right trade-off: it's better to break your development tools but keep the project working. When such incompatibilities occur, you'll typically want to upgrade your dev tools to versions that are compatible with the main project.","category":"page"},{"location":"manual/code-loading.html#Conclusion-1","page":"Code Loading","title":"Conclusion","text":"","category":"section"},{"location":"manual/code-loading.html#","page":"Code Loading","title":"Code Loading","text":"Federated package management and precise software reproducibility are difficult but worthy goals in a package system. In combination, these goals lead to a more complex package loading mechanism than most dynamic languages have, but it also yields scalability and reproducibility that is more commonly associated with static languages. Typically, Julia users should be able to use the built-in package manager to manage their projects without needing a precise understanding of these interactions. A call to Pkg.add(\"X\") will add to the appropriate project and manifest files, selected via Pkg.activate(\"Y\"), so that a future call to import X will load X without further thought.","category":"page"},{"location":"manual/profile.html#Profiling-1","page":"プロファイリング","title":"プロファイリング","text":"","category":"section"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"Profileモジュールには、開発者がコードのパフォーマンスを向上させるのに役立つツールが用意されています。使用すると、実行中のコードを測定し、各行の演算にどれくらいの時間が費やされているかを理解するのに役立つ出力を生成します。最も一般的な使用法は、最適化のターゲットとして「ボトルネック」を特定することです。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"Profileには、「サンプリング」すなわち、統計的プロファイラーとして知られているものを実装されています。  これは、任意のタスクの実行中に定期的にバックトレースを取ることによって動作します。 各バックトレースは、現在実行中の関数と行番号、そして、この行の実行につながる関数呼び出しの完全な連鎖を補足します。そのため、(バックトレースで得られる状態は)現在の実行状態の \"スナップショット\" になります。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"実行時間の多くが特定のコード行の実行に費やされている場合、この行はすべてのバックトレースのセットに頻繁に現れます。言い換えれば、特定の行の「コスト」、つまり、この行を含む関数の一連の呼び出しのコストは、すべてのバックトレースのセットに表示される頻度に比例します。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"サンプリング プロファイラは、1行1行の実行に対する完全なカバレッジを提供しません。バックトレースが一定時間間隔で発生するからです(既定では、Unix システムで 1 ミリ秒、Windows では 10 ミリ秒ですが、実際のスケジューリングはオペレーティング システムの負荷の影響を受けます)。さらに、後で説明するように、サンプルは全実行ポイントに対してサンプル数のまばらな部分集合として収集されるため、サンプリング プロファイラによって収集されたデータは統計的ノイズの影響を受けます。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"これらの制限にもかかわらず、サンプリング プロファイラには大きな強みがあります:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"演算時間測定を行うためにコードを変更する必要はありません(代替手段である インストルメンテーションプロファイラとは対照的です)。\nJuliaのコアコードの中まで、さらには(オプションで)CおよびFortranライブラリの中もプロファイルすることができます。\n\"まれに\" 実行する分には、パフォーマンスのオーバーヘッドはほとんどありません。プロファイリング中は、コードはほぼネイティブの速度で実行できます。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"このような理由から、代替案を検討する前に、組み込みのサンプリング プロファイラを使用することをお勧めします。","category":"page"},{"location":"manual/profile.html#基本的な使い方-1","page":"プロファイリング","title":"基本的な使い方","text":"","category":"section"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"簡単なテストケースを試してみましょう:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"julia> function myfunc()\n           A = rand(200, 200, 400)\n           maximum(A)\n       end","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"プロファイルするコードを少なくとも 1 回実行しておくのはよいアイディアです (Julia の JIT コンパイラをプロファイリングする場合を除く):","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"julia> myfunc() # run once to force compilation","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"これで、この関数をプロファイルする準備ができました:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"julia> using Profile\n\njulia> @profile myfunc()","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"プロファイリング結果を確認するには、グラフィカルブラウザを使用できますが、ここでは標準ライブラリに付属のテキストベースの表示を使用します:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"julia> Profile.print()\n80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\n 80 ./REPL.jl:97; macro expansion\n  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)\n   80 ./boot.jl:235; eval(::Module, ::Any)\n    80 ./<missing>:?; anonymous\n     80 ./profile.jl:23; macro expansion\n      52 ./REPL[1]:2; myfunc()\n       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...\n        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...\n       14 ./random.jl:278; rand\n        14 ./random.jl:277; rand\n         14 ./random.jl:366; rand\n          14 ./random.jl:369; rand\n      28 ./REPL[1]:3; myfunc()\n       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...\n        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...\n        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"この表示の各行は、コード内の特定のスポット (行番号) を表します。インデントは、入れ子になった関数呼び出しのシーケンスを示すために使用され、よりインデントされた行は呼び出しのシーケンスの中でより深くなります。各行で、最初の「フィールド」は、この行またはこの行で実行される関数で受け取られたバックトレース(サンプル)の数です。 2 番目のフィールドはファイル名と行番号で、3 番目のフィールドは関数名です。 ジュリアのコードが変更されるにつれて、特定の行番号が変更される可能性があることに注意してください。この後の話についていくために、この例を自分で実行するのがベストです。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"この例では、呼び出される最上位関数がファイル event.jl にあることがわかります。これは、Julia 起動時に REPL を実行する関数です。REPL.jl の 97 行を調べると、eval_user_input() 関数が呼び出される場所であることが分かります。これはREPLで入力した内容を評価する関数です。今は 対話的に作業しているので、@profile myfunc() をREPLから入力したときに、これら(訳注: eval_user_input()のことだろうが、なぜ複数?) の関数が呼び出されました。次の行は[@profile`](@ref)マクロで実行されたアクションを反映しています。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"最初の行はevent.jlの73行目で80個のバックトレースが取られたことを示していますが、この行自体の演算コストが高いわけでは有りません。: 3行目を見れば、これらのバックトレースの80個すべてが実際にeval_user_inputへの呼び出しの中でトリガされたことが明らかです。実際に時間がかかっている操作を調べるには、コール チェーンをより深く調べる必要があります。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"この出力の最初の \"重要な\" 行はこれです:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"52 ./REPL[1]:2; myfunc()","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"REPL は、REPL で myfunc を定義したという事実を指します。ファイルにmyfuncが定義されたというわけではありません。ファイルを使用していた場合は、(REPLの代わりに)ファイル名が表示されます。[1] は、関数 myfunc がこの REPL セッションで評価された最初の式であることを示しています。myfunc() の 2 行目には rand の呼び出しが含まれており、この行で発生したバックトレースは 52 (80 のうち) でした。その下には、dSFMT.jl 内のdSfmt_fill_array_close_open! の呼び出しがあります。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"もう少し下に行くと、下記の行が見つかります:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"28 ./REPL[1]:3; myfunc()","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"myfunc の 3 行目にはmaximumの呼び出しがあり、ここで 28 (80 件中) のバックトレースがカウントされています。その下には、このタイプの入力データに対するmaximum 関数内の時間のかかる処理を実行している、base/reduce.jlのある場所を確認できます。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"全体として、乱数の生成は、最大の要素を見つける処理の約2倍のコストがかかると暫定的に結論付けることができます。より多くのサンプルを収集することで、この結果に対する確信を深めることができました:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"julia> @profile (for i = 1:100; myfunc(); end)\n\njulia> Profile.print()\n[....]\n 3821 ./REPL[1]:2; myfunc()\n  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...\n   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...\n  310  ./random.jl:278; rand\n   [....]\n 2893 ./REPL[1]:3; myfunc()\n  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...\n   [....]","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"一般に、ある行でのカウントがN サンプルであった場合、(コンピュータが他のタスクでビジー状態にあるかなど、他のノイズ源を除いて), その値の不確実性は、 sqrt(N)のオーダーであることが期待できます。このルールの主な例外は、実行頻度は低いが、非常に演算コストの高い傾向があるガベージ コレクションです。(Julia のガベージ コレクタは C で記述されているので、このようなイベントは、以下に説明する 'C=true' 出力モードを使用するか、ProfileView.jl を使用して検出できます。)","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"これは、デフォルト出力である 「ツリー型」ダンプを示しています; 他には、代替案は、入れ子構造に依存せずにカウントを蓄積する「フラット」ダンプです:\\v","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"julia> Profile.print(format=:flat)\n Count File          Line Function\n  6714 ./<missing>     -1 anonymous\n  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)\n  6714 ./REPL.jl       97 macro expansion\n  3821 ./REPL[1]        2 myfunc()\n  2893 ./REPL[1]        3 myfunc()\n  6714 ./REPL[7]        1 macro expansion\n  6714 ./boot.jl      235 eval(::Module, ::Any)\n  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...\n  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\n  6714 ./profile.jl    23 macro expansion\n  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...\n   310 ./random.jl    277 rand\n   310 ./random.jl    278 rand\n   310 ./random.jl    366 rand\n   310 ./random.jl    369 rand\n  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...\n     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"コードで再帰が使われている場合、\"子\" 関数の行が合計バックトレースよりも多くのカウントを蓄積する可能性があります。次の関数定義を考えてみましょう:\\v","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)\ndumbsum3() = dumbsum(3)","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"dumbsum3 をプロファイリングし、dumbsum(1) の実行中にバックトレースが取得された場合、バックトレースは次のようになります:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"dumbsum3\n    dumbsum(3)\n        dumbsum(2)\n            dumbsum(1)","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"その結果、親では1カウントのみなのに対して、この子関数は 3 カウントを取得します。「ツリー」表現はこれをより明確にします。そのため、ツリー表現は (特に) 結果を表示する際に最も便利な方法です。","category":"page"},{"location":"manual/profile.html#蓄積とクリア-1","page":"プロファイリング","title":"蓄積とクリア","text":"","category":"section"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"@profileの結果はバッファに蓄積されます。@profileで複数のコードを実行すると、Profile.print()は、それら複数のコードのプロファイルの結果を結合した結果を出力します。これは非常に便利ですが、プロファイルを新たに開始したい場合があります。その場合は、Profile.clear()で、クリアできます。","category":"page"},{"location":"manual/profile.html#プロファイル結果の表示を制御するオプション-1","page":"プロファイリング","title":"プロファイル結果の表示を制御するオプション","text":"","category":"section"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"Profile.print は、これまで説明した以外にも多くのオプションを持っています。全てここで見てみましょう:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"function print(io::IO = stdout, data = fetch(); kwargs...)","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"まず 2 つの位置引数について説明し、後にキーワード引数を説明します:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"io – ファイルなどのバッファに結果を保存する。デフォルトではstdout (コンソール) へのプリント出力。\ndata – 分析したいデータを指定する; デフォルトでは、事前割り当てされたバッファーからバックトレース情報を取り出す Profile.fetch() から取得されま。たとえば、プロファイラーをプロファイリングする場合は、次のように指定できます:\ndata = copy(Profile.fetch())\nProfile.clear()\n@profile Profile.print(stdout, data) # Prints the previous results\nProfile.print()                      # Prints results from Profile.print()","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"キーワード引数には、次の任意の組み合わせを指定できます:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"format – 上で紹介したように、バックトレースの表示形式を決定します。  関数コールの木構造を示すインデントを用いる :tree(デフォルト) とインデント無しの:flat\nC – true の場合、C コードと Fortran コードからのバックトレースが表示されます (通常は除外されます)。 Profile.print(C = true)の紹介例を示すので実行してみてください。この機能は、ボトルネックになっているのが Juliaコードなのか、Cコードの部分なのか判断するのに大変役立ちます。 C = true を設定すると、より長いプロファイルダンプになってしまいますが、ネストの解釈はしやすくなります。\ncombine – コード行の中には複数の操作が含まれていることがあります。たとえば、s += A[i] には配列の参照(A[i])と加算の両方が含まれています。 これらは、生成されたマシンコードでは、別々の行に対応しています。そのため、この行のバックトレース中で2つ以上の異なるアドレスがキャプチャかもしれません。 combine = true オプションはそれらを一緒にまとめます。これはおそらくあなたが通常望む動作でしょう。 ただし、combine = false オプションを使えば、一意の命令ポインターごとにに出力を生成することもできます。\nmaxdepth – :tree 形式での maxdepth よりさらに大きい値を持つ深さで表示するフレームを制限します。\nsortby – :flat 形式での表示順序を制御します。:filefuncline (デフォルト) はソースファイルによるソート、:count は収集されたサンプルの数の順番でのソートです。\nnoisefloor – サンプル数のノイズフロアをヒューリスティックに指定します。ノイズフロアより下のフレームは表示が制限されます(フォーマット:treeにのみ適用されます)。 これを試す際の推奨値は 2.0 です (デフォルトは 0)。このパラメーターは、n <= ノイズフロア * √N のサンプルを非表示にします。 ここで n は、この行のサンプルの数で、N は呼び出し先のサンプルの数です。\nmincount – ここで指定した値よりも小さいオカレンスのフレームを制限します。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"ファイル/関数名は、(...) を使って切り捨て表示されることがあります。 また、インデントは先頭で +n で切り捨てられます。ここで n は挿入される追加のスペースの数です。深くネストされたコードの完全なプロファイルが必要な場合は、IOContextで広い「表示サイズ」を使用してファイルに保存することをお考えめします:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"open(\"/tmp/prof.txt\", \"w\") do s\n    Profile.print(IOContext(s, :displaysize => (24, 500)))\nend","category":"page"},{"location":"manual/profile.html#構成・設定-1","page":"プロファイリング","title":"構成・設定","text":"","category":"section"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"@profile はバックトレースを蓄積するだけです。実際の分析は、Profile.print()を呼び出したときに行われます。実行時間の長い計算では、バックトレースを格納するために事前に割り当てられたバッファがいっぱいになる可能性があります。その場合、バックトレースは停止しますが、プロファイル対象の計算自体は続行されます。 その結果、いくつかの重要なプロファイリング データを見逃す可能性があります (その場合は警告が表示されます)。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"以下で、関連するパラメータを取得および構成できます:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"Profile.init() # returns the current settings\nProfile.init(n = 10^7, delay = 0.01)","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"n は、格納できる命令ポインターの合計数で、デフォルト値は 10^6 です。 一般的なバックトレースが 20 の命令ポインタである場合は、50000 バックトレースを収集できるため、統計的な不確実性が 1% 未満であることを示唆しています。これは、ほとんどのアプリケーションで十分でしょう。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"delayは、要求された計算を実行するための複数スナップショットの間でJuliaが取得する時間長を秒単位で表記するものですが、前文のような状況であればその結果、このdelayの修正が必要になる可能性が高くなります。非常に長い時間実行されるジョブでは、頻繁なバックトレースは必要ない場合があります。デフォルトの設定は'遅延 = 0.001'です。 もちろん、遅延を減らすだけでなく、遅延を増やすことができます。ただし、遅延がバックトレース (作成者のラップトップで約 30 マイクロ秒) を取るのに必要な時間に近くなると、プロファイリングのオーバーヘッドが大きくなります。","category":"page"},{"location":"manual/profile.html#Memory-allocation-analysis-1","page":"プロファイリング","title":"メモリ割り当て分析","text":"","category":"section"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"パフォーマンスを向上させる最も一般的な手法の 1 つは、メモリ割り当てを減らすことです。メモリ割り当ての合計量は@timeと@allocatedで測定することができ、メモリ割り当てをトリガする特定の行は、多くの場合、これらの行で発生するガベージコレクションによる演算コストを介してプロファイリングから推測することができます。ただし、コード行ごとに割り当てられるメモリの量を直接測定する方が効率的な場合もあります。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"メモリ割り当てを 1 行ずつ測定するには、--track-allocation=<setting>コマンドラインオプションをついけてJulia を起動します。 選択可能なオプションは、none (デフォルト値。メモリ割り当てを測定しない) 、user(Juliaのコアコードを除く、Juliaコードの各行におけるメモリ割り当てを測定する), all(全Juliaコードの各行でメモリ割り当てを測定)です。 Julia終了時、各ソースファイルのファイル名の後に.memが付加されたテキストファイルに書き込まれます。出力先は、ソース ファイルと同じディレクトリです。 各行には、合計バイト数が一覧表示されます。Coverage パッケージ には、基本的な分析ツール、例えば メモリ割り当てのバイト数での行ソートなど、が含まれています。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"結果を解釈する際には、いくつか重要な詳細情報があるので気をつけてください。 --track-allocation=user で実行した場合、REPL から直接呼び出される関数の最初の行には、REPLからの関数コール自体に含まれメモリ割り当ての情報が示されます。 さらに重要なのは、ジュリアのコンパイラの多くはジュリアで書かれているので(そしてコンパイルは通常メモリ割当が必要なので)、JIT コンパイルによってメモリ割り当てカウントが追加されるということです。推奨される手順は、すべての分析したいすべてのコマンドをを実行して強制的にコンパイルしておき、Profile.clear_malloc_data()を呼び出して、すべての割り当てカウンタをリセットすることです。  最後に、目的のコマンドを実行し、ジュリアを終了して '.mem'ファイルの生成をトリガーします。","category":"page"},{"location":"manual/profile.html#外部のプロファイリングツール-1","page":"プロファイリング","title":"外部のプロファイリングツール","text":"","category":"section"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"現在、Juliaは外部プロファイリングツールとしてIntel VTune、OProfile、perfをサポートしています。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"選択したツールに応じて、Make.userファイル内で、USE_INTEL_JITEVENTS、USE_OPROFILE_JITEVENTS、USE_PERF_JITEVENTS などを1に設定してコンパイルしてください。複数のフラグがサポートされています。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"Julia を実行する前に、環境変数 ENABLE_JITPROFILING を 1 に設定します。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"これで、あなたはこれらのツールを使用する多数の方法を手に入れました。たとえば、OProfile を使用すると、簡単な記録をすることができます:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":">ENABLE_JITPROFILING=1 sudo operf -Vdebug ./julia test/fastmath.jl\n>opreport -l `which ./julia`","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"または perfとにたやり方で:","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"$ ENABLE_JITPROFILING=1 perf record -o /tmp/perf.data --call-graph dwarf ./julia /test/fastmath.jl\n$ perf report --call-graph -G","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"あなたのプログラムついて測定を行う方法は他にもたくさんあり、興味深いです。包括的なリストを見たければ,Linux perfの例のページを読んでください。","category":"page"},{"location":"manual/profile.html#","page":"プロファイリング","title":"プロファイリング","text":"実行ごとにperfは、 perf.data ファイルを保存し、小規模なプログラムの場合でも非常に大きなファイルを保存できることを覚えておいてください。また、perf LLVMモジュールは、一時的にデバッグオブジェクトを~/.debug/jitに保存しますから、そのフォルダを頻繁にクリーンアップすることを忘れないでください。","category":"page"},{"location":"manual/stacktraces.html#Stack-Traces-1","page":"Stack Traces","title":"Stack Traces","text":"","category":"section"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"The StackTraces module provides simple stack traces that are both human readable and easy to use programmatically.","category":"page"},{"location":"manual/stacktraces.html#Viewing-a-stack-trace-1","page":"Stack Traces","title":"Viewing a stack trace","text":"","category":"section"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"The primary function used to obtain a stack trace is stacktrace:","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"6-element Array{Base.StackTraces.StackFrame,1}:\n top-level scope\n eval at boot.jl:317 [inlined]\n eval(::Module, ::Expr) at REPL.jl:5\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n macro expansion at REPL.jl:116 [inlined]\n (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"Calling stacktrace() returns a vector of StackTraces.StackFrame s. For ease of use, the alias StackTraces.StackTrace can be used in place of Vector{StackFrame}. (Examples with [...] indicate that output may vary depending on how the code is run.)","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"julia> example() = stacktrace()\nexample (generic function with 1 method)\n\njulia> example()\n7-element Array{Base.StackTraces.StackFrame,1}:\n example() at REPL[1]:1\n top-level scope\n eval at boot.jl:317 [inlined]\n[...]\n\njulia> @noinline child() = stacktrace()\nchild (generic function with 1 method)\n\njulia> @noinline parent() = child()\nparent (generic function with 1 method)\n\njulia> grandparent() = parent()\ngrandparent (generic function with 1 method)\n\njulia> grandparent()\n9-element Array{Base.StackTraces.StackFrame,1}:\n child() at REPL[3]:1\n parent() at REPL[4]:1\n grandparent() at REPL[5]:1\n[...]","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"Note that when calling stacktrace() you'll typically see a frame with eval at boot.jl.  When calling stacktrace() from the REPL you'll also have a few extra frames in the stack from REPL.jl, usually looking something like this:","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"julia> example() = stacktrace()\nexample (generic function with 1 method)\n\njulia> example()\n7-element Array{Base.StackTraces.StackFrame,1}:\n example() at REPL[1]:1\n top-level scope\n eval at boot.jl:317 [inlined]\n eval(::Module, ::Expr) at REPL.jl:5\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n macro expansion at REPL.jl:116 [inlined]\n (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92","category":"page"},{"location":"manual/stacktraces.html#Extracting-useful-information-1","page":"Stack Traces","title":"Extracting useful information","text":"","category":"section"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"Each StackTraces.StackFrame contains the function name, file name, line number, lambda info, a flag indicating whether the frame has been inlined, a flag indicating whether it is a C function (by default C functions do not appear in the stack trace), and an integer representation of the pointer returned by backtrace:","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"julia> frame = stacktrace()[3]\neval(::Module, ::Expr) at REPL.jl:5\n\njulia> frame.func\n:eval\n\njulia> frame.file\nSymbol(\"~/julia/usr/share/julia/stdlib/v0.7/REPL/src/REPL.jl\")\n\njulia> frame.line\n5\n\njulia> top_frame.linfo\nMethodInstance for eval(::Module, ::Expr)\n\njulia> top_frame.inlined\nfalse\n\njulia> top_frame.from_c\nfalse","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"julia> top_frame.pointer\n0x00007f92d6293171","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"This makes stack trace information available programmatically for logging, error handling, and more.","category":"page"},{"location":"manual/stacktraces.html#Error-handling-1","page":"Stack Traces","title":"Error handling","text":"","category":"section"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"While having easy access to information about the current state of the callstack can be helpful in many places, the most obvious application is in error handling and debugging.","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"julia> @noinline bad_function() = undeclared_variable\nbad_function (generic function with 1 method)\n\njulia> @noinline example() = try\n           bad_function()\n       catch\n           stacktrace()\n       end\nexample (generic function with 1 method)\n\njulia> example()\n7-element Array{Base.StackTraces.StackFrame,1}:\n example() at REPL[2]:4\n top-level scope\n eval at boot.jl:317 [inlined]\n[...]","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"You may notice that in the example above the first stack frame points points at line 4, where stacktrace is called, rather than line 2, where bad_function is called, and bad_function's frame is missing entirely. This is understandable, given that stacktrace is called from the context of the catch. While in this example it's fairly easy to find the actual source of the error, in complex cases tracking down the source of the error becomes nontrivial.","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"This can be remedied by passing the result of catch_backtrace to stacktrace.  Instead of returning callstack information for the current context, catch_backtrace  returns stack information for the context of the most recent exception:","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"julia> @noinline bad_function() = undeclared_variable\nbad_function (generic function with 1 method)\n\njulia> @noinline example() = try\n           bad_function()\n       catch\n           stacktrace(catch_backtrace())\n       end\nexample (generic function with 1 method)\n\njulia> example()\n8-element Array{Base.StackTraces.StackFrame,1}:\n bad_function() at REPL[1]:1\n example() at REPL[2]:2\n[...]","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"Notice that the stack trace now indicates the appropriate line number and the missing frame.","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"julia> @noinline child() = error(\"Whoops!\")\nchild (generic function with 1 method)\n\njulia> @noinline parent() = child()\nparent (generic function with 1 method)\n\njulia> @noinline function grandparent()\n           try\n               parent()\n           catch err\n               println(\"ERROR: \", err.msg)\n               stacktrace(catch_backtrace())\n           end\n       end\ngrandparent (generic function with 1 method)\n\njulia> grandparent()\nERROR: Whoops!\n10-element Array{Base.StackTraces.StackFrame,1}:\n error at error.jl:33 [inlined]\n child() at REPL[1]:1\n parent() at REPL[2]:1\n grandparent() at REPL[3]:3\n[...]","category":"page"},{"location":"manual/stacktraces.html#Exception-stacks-and-catch_stack-1","page":"Stack Traces","title":"Exception stacks and catch_stack","text":"","category":"section"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"compat: Julia 1.1\nException stacks requires at least Julia 1.1.","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"While handling an exception further exceptions may be thrown. It can be useful to inspect all these exceptions to identify the root cause of a problem. The julia runtime supports this by pushing each exception onto an internal exception stack as it occurs. When the code exits a catch normally, any exceptions which were pushed onto the stack in the associated try are considered to be successfully handled and are removed from the stack.","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"The stack of current exceptions can be accessed using the experimental Base.catch_stack function. For example,","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"julia> try\n           error(\"(A) The root cause\")\n       catch\n           try\n               error(\"(B) An exception while handling the exception\")\n           catch\n               for (exc, bt) in Base.catch_stack()\n                   showerror(stdout, exc, bt)\n                   println()\n               end\n           end\n       end\n(A) The root cause\nStacktrace:\n [1] error(::String) at error.jl:33\n [2] top-level scope at REPL[7]:2\n [3] eval(::Module, ::Any) at boot.jl:319\n [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n [5] macro expansion at REPL.jl:117 [inlined]\n [6] (::getfield(REPL, Symbol(\"##26#27\")){REPL.REPLBackend})() at task.jl:259\n(B) An exception while handling the exception\nStacktrace:\n [1] error(::String) at error.jl:33\n [2] top-level scope at REPL[7]:5\n [3] eval(::Module, ::Any) at boot.jl:319\n [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n [5] macro expansion at REPL.jl:117 [inlined]\n [6] (::getfield(REPL, Symbol(\"##26#27\")){REPL.REPLBackend})() at task.jl:259","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"In this example the root cause exception (A) is first on the stack, with a further exception (B) following it. After exiting both catch blocks normally (i.e., without throwing a further exception) all exceptions are removed from the stack and are no longer accessible.","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"The exception stack is stored on the Task where the exceptions occurred. When a task fails with uncaught exceptions, catch_stack(task) may be used to inspect the exception stack for that task.","category":"page"},{"location":"manual/stacktraces.html#Comparison-with-[backtrace](@ref)-1","page":"Stack Traces","title":"Comparison with backtrace","text":"","category":"section"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"A call to backtrace returns a vector of Union{Ptr{Nothing}, Base.InterpreterIP}, which may then be passed into stacktrace for translation:","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"julia> trace = backtrace()\n18-element Array{Union{Ptr{Nothing}, Base.InterpreterIP},1}:\n Ptr{Nothing} @0x00007fd8734c6209\n Ptr{Nothing} @0x00007fd87362b342\n Ptr{Nothing} @0x00007fd87362c136\n Ptr{Nothing} @0x00007fd87362c986\n Ptr{Nothing} @0x00007fd87362d089\n Base.InterpreterIP(CodeInfo(:(begin\n      Core.SSAValue(0) = backtrace()\n      trace = Core.SSAValue(0)\n      return Core.SSAValue(0)\n  end)), 0x0000000000000000)\n Ptr{Nothing} @0x00007fd87362e4cf\n[...]\n\njulia> stacktrace(trace)\n6-element Array{Base.StackTraces.StackFrame,1}:\n top-level scope\n eval at boot.jl:317 [inlined]\n eval(::Module, ::Expr) at REPL.jl:5\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n macro expansion at REPL.jl:116 [inlined]\n (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"Notice that the vector returned by backtrace had 18 elements, while the vector returned by stacktrace only has 6. This is because, by default, stacktrace removes any lower-level C functions from the stack. If you want to include stack frames from C calls, you can do it like this:","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"julia> stacktrace(trace, true)\n21-element Array{Base.StackTraces.StackFrame,1}:\n jl_apply_generic at gf.c:2167\n do_call at interpreter.c:324\n eval_value at interpreter.c:416\n eval_body at interpreter.c:559\n jl_interpret_toplevel_thunk_callback at interpreter.c:798\n top-level scope\n jl_interpret_toplevel_thunk at interpreter.c:807\n jl_toplevel_eval_flex at toplevel.c:856\n jl_toplevel_eval_in at builtins.c:624\n eval at boot.jl:317 [inlined]\n eval(::Module, ::Expr) at REPL.jl:5\n jl_apply_generic at gf.c:2167\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n jl_apply_generic at gf.c:2167\n macro expansion at REPL.jl:116 [inlined]\n (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92\n jl_fptr_trampoline at gf.c:1838\n jl_apply_generic at gf.c:2167\n jl_apply at julia.h:1540 [inlined]\n start_task at task.c:268\n ip:0xffffffffffffffff","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"Individual pointers returned by backtrace can be translated into StackTraces.StackFrame  s by passing them into StackTraces.lookup:","category":"page"},{"location":"manual/stacktraces.html#","page":"Stack Traces","title":"Stack Traces","text":"julia> pointer = backtrace()[1];\n\njulia> frame = StackTraces.lookup(pointer)\n1-element Array{Base.StackTraces.StackFrame,1}:\n jl_apply_generic at gf.c:2167\n\njulia> println(\"The top frame is from $(frame[1].func)!\")\nThe top frame is from jl_apply_generic!","category":"page"},{"location":"manual/performance-tips.html#man-performance-tips-1","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"次のセクションでは、Julia コードをできるだけ速く実行するのに役立ついくつかのテクニックを簡単に説明します。","category":"page"},{"location":"manual/performance-tips.html#グローバル変数を避ける-1","page":"パフォーマンス・ティップス","title":"グローバル変数を避ける","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"グローバル変数は(宣言時に) 値と型を持つかもしれませんが、その型はいつでも変わりえます。そのため、コンパイラはグローバル変数を使用したコードを最適化することが難しいのです。変数は、可能な限りローカルであるか、関数に引数として渡される必要があります。","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"パフォーマンスが重要なコードやベンチマークされているコードは、関数内に存在する必要があります。","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"グローバル名は定数であることが多く、そのように宣言するとパフォーマンスが大幅に向上します:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"const DEFAULT_VAL = 0","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"非定数グローバルの使う場合は、使用時に型のアノテーションをすることで最適化できます:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"global x = rand(1000)\n\nfunction loop_over_global()\n    s = 0.0\n    for i in x::Vector{Float64}\n        s += i\n    end\n    return s\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"より優れているのは関数に引数として渡すスタイルです。このスタイルでは、コードがより再利用しやすく、入力と出力が明確になります。","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"!!!メモ     REPL 内のすべてのコードはグローバル スコープで評価されるので、最上位レベルで定義・代入された変数はグローバル変数になります。     モジュール内の最上位スコープで定義された変数もまたグローバルになります。","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"次の REPL セッションで:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> x = 1.0","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"は次と同じです:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> global x = 1.0","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"そのため、前述のパフォーマンス上の問題がすべて当てはまります。","category":"page"},{"location":"manual/performance-tips.html#[@time](@ref)でパフォーマンスを測定し、メモリ割り当てに注意を払う-1","page":"パフォーマンス・ティップス","title":"@timeでパフォーマンスを測定し、メモリ割り当てに注意を払う","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"パフォーマンス測定のための便利なツールは@timeマクロです。上記のグローバル変数の例を繰り返しますが、今回は型アニテーションを削除しました:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> x = rand(1000);\n\njulia> function sum_global()\n           s = 0.0\n           for i in x\n               s += i\n           end\n           return s\n       end;\n\njulia> @time sum_global()\n  0.017705 seconds (15.28 k allocations: 694.484 KiB)\n496.84883432553846\n\njulia> @time sum_global()\n  0.000140 seconds (3.49 k allocations: 70.313 KiB)\n496.84883432553846","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"最初の呼び出し (@time sum_global()) で関数がコンパイルされます。(このセッションで @time をまだ使用していない場合は、時間測定に必要な関数もコンパイルします)。 この実行結果を真剣に受け止めるべきではありません。2 回目の実行では、演算時間のレポートに加えて、大量のメモリが割り当てられていることも示されます。ここでは、64 ビット浮動小数点数のベクトル内のすべての要素に対して合計を計算するだけで、メモリを割り当てる必要はありません (少なくとも@time がレポートするヒープ領域には必要ありません)。","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"予期しないメモリ割り当ては、ほとんどの場合で、あなたの書いたコードに問題があるという兆しです。通常は型の安定性の問題であったり、多数の小さな一時配列の作成の問題です。予期しないメモリ割当は、それそのものが悪いというだけでなく、関数用に生成されたコードが最適とは程遠い可能性が非常に高いのです。このような指示を真剣に受け止め、以下のアドバイスに従ってください。","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"グローバル参照するのでなく、関数の引数としてxを渡せば、メモリ割り当ては起きません(ここでレポートされたメモリ割り当ては、@time マクロがグローバルスコープで実行されたことによるもの)。 そして、二回目の呼び出しからは大幅に高速になります:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> x = rand(1000);\n\njulia> function sum_arg(x)\n           s = 0.0\n           for i in x\n               s += i\n           end\n           return s\n       end;\n\njulia> @time sum_arg(x)\n  0.007701 seconds (821 allocations: 43.059 KiB)\n496.84883432553846\n\njulia> @time sum_arg(x)\n  0.000006 seconds (5 allocations: 176 bytes)\n496.84883432553846","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"ここで見られた5 つのメモリ割り当ては、グローバル スコープで @timeマクロ自体の実行からきたものです。代わりに関数内で時間測定を実行すると、実際に関数内部ではメモリ割り当てが実行されていないことがわかります:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> time_sum(x) = @time sum_arg(x);\n\njulia> time_sum(x)\n  0.000001 seconds\n496.84883432553846","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"状況によっては、必要な操作の一部として関数でメモリを割り当てが必要になるかもしれません。そのときには、上述の上記の単純なイメージが、複雑になる可能性があります。このような場合は、以下の ツール のいずれかを使用して問題を診断するか、メモリ割り当てをアルゴリズム的な側面から分離したバージョンの関数を作ることを検討してください (出力の事前割当参照)。","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"!!!メモ     よりしっかりとベンチマークをとりたい場合は、BenchmarkTools.jlパッケージを検討してください。     とりわけ、測定対象以外の処理の実行に起因するノイズを低減するため、関数を複数回評価してくれます。","category":"page"},{"location":"manual/performance-tips.html#tools-1","page":"パフォーマンス・ティップス","title":"ツール","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Julia とそのパッケージ エコシステムには、問題の診断とコードのパフォーマンスの向上に役立つツールが含まれています:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Profiling を使用すると、実行中のコードのパフォーマンスを測定し、ボトルネックとなる行を特定できます。複雑なプロジェクトの場合、ProfileViewパッケージは、プロファイリング結果を視覚化するに役立ちます。\nTraceurパッケージは、コード内の一般的なパフォーマンス上の問題を見つけるのに役立ちます。\n予想外に大きなメモリ割り当て、これは@time、@allocated、またはプロファイラー (ガベージ コレクション ルーチンの呼び出しを通じて)により報告されるものですが、あなたのコードに問題がある可能性を示唆します。  もしその予想外のメモリ割当に心当たりがない場合は、型の問題を疑ってください。  あるいは、Julia を --track-allocation=userオプションを付けて実行し、その結果を調べることもできます。 *.memファイルは、これらの割り当てが発生する場所に関する情報を表示します。メモリ割り当ての分析を参照してください。\n@code_warntype は、どの式で型の不確実性が生じるかを見つけるのに役立つような、あなたのコードについての情報を生成します。下記の@code_warntypeを参照してください。","category":"page"},{"location":"manual/performance-tips.html#Avoid-containers-with-abstract-type-parameters-1","page":"パフォーマンス・ティップス","title":"Avoid containers with abstract type parameters","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"When working with parameterized types, including arrays, it is best to avoid parameterizing with abstract types where possible.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Consider the following:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> a = Real[]\n0-element Array{Real,1}\n\njulia> push!(a, 1); push!(a, 2.0); push!(a, π)\n3-element Array{Real,1}:\n 1\n 2.0\n π","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Because a is a an array of abstract type Real, it must be able to hold any Real value. Since Real objects can be of arbitrary size and structure, a must be represented as an array of pointers to individually allocated Real objects. However, if we instead only allow numbers of the same type, e.g. Float64, to be stored in a these can be stored more efficiently:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> a = Float64[]\n0-element Array{Float64,1}\n\njulia> push!(a, 1); push!(a, 2.0); push!(a,  π)\n3-element Array{Float64,1}:\n 1.0\n 2.0\n 3.141592653589793","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Assigning numbers into a will now convert them to Float64 and a will be stored as a contiguous block of 64-bit floating-point values that can be manipulated efficiently.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"See also the discussion under Parametric Types.","category":"page"},{"location":"manual/performance-tips.html#Type-declarations-1","page":"パフォーマンス・ティップス","title":"Type declarations","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is not the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.","category":"page"},{"location":"manual/performance-tips.html#Avoid-fields-with-abstract-type-1","page":"パフォーマンス・ティップス","title":"Avoid fields with abstract type","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Types can be declared without specifying the types of their fields:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> struct MyAmbiguousType\n           a\n       end","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This allows a to be of any type. This can often be useful, but it does have a downside: for objects of type MyAmbiguousType, the compiler will not be able to generate high-performance code. The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type MyAmbiguousType:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> b = MyAmbiguousType(\"Hello\")\nMyAmbiguousType(\"Hello\")\n\njulia> c = MyAmbiguousType(17)\nMyAmbiguousType(17)\n\njulia> typeof(b)\nMyAmbiguousType\n\njulia> typeof(c)\nMyAmbiguousType","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The values of b and c have the same type, yet their underlying representation of data in memory is very different. Even if you stored just numeric values in field a, the fact that the memory representation of a UInt8 differs from a Float64 also means that the CPU needs to handle them using two different kinds of instructions. Since the required information is not available in the type, such decisions have to be made at run-time. This slows performance.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"You can do better by declaring the type of a. Here, we are focused on the case where a might be any one of several types, in which case the natural solution is to use parameters. For example:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> mutable struct MyType{T<:AbstractFloat}\n           a::T\n       end","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This is a better choice than","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> mutable struct MyStillAmbiguousType\n           a::AbstractFloat\n       end","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"because the first version specifies the type of a from the type of the wrapper object. For example:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> m = MyType(3.2)\nMyType{Float64}(3.2)\n\njulia> t = MyStillAmbiguousType(3.2)\nMyStillAmbiguousType(3.2)\n\njulia> typeof(m)\nMyType{Float64}\n\njulia> typeof(t)\nMyStillAmbiguousType","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The type of field a can be readily determined from the type of m, but not from the type of t. Indeed, in t it's possible to change the type of the field a:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> typeof(t.a)\nFloat64\n\njulia> t.a = 4.5f0\n4.5f0\n\njulia> typeof(t.a)\nFloat32","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"In contrast, once m is constructed, the type of m.a cannot change:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> m.a = 4.5f0\n4.5f0\n\njulia> typeof(m.a)\nFloat64","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The fact that the type of m.a is known from m's type—coupled with the fact that its type cannot change mid-function—allows the compiler to generate highly-optimized code for objects like m but not for objects like t.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Of course, all of this is true only if we construct m with a concrete type. We can break this by explicitly constructing it with an abstract type:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> m = MyType{AbstractFloat}(3.2)\nMyType{AbstractFloat}(3.2)\n\njulia> typeof(m.a)\nFloat64\n\njulia> m.a = 4.5f0\n4.5f0\n\njulia> typeof(m.a)\nFloat32","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"For all practical purposes, such objects behave identically to those of MyStillAmbiguousType.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"It's quite instructive to compare the sheer amount code generated for a simple function","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"func(m::MyType) = m.a+1","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"using","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"code_llvm(func, Tuple{MyType{Float64}})\ncode_llvm(func, Tuple{MyType{AbstractFloat}})","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn't need to generate any code to resolve the type at run-time. This results in shorter and faster code.","category":"page"},{"location":"manual/performance-tips.html#Avoid-fields-with-abstract-containers-1","page":"パフォーマンス・ティップス","title":"Avoid fields with abstract containers","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The same best practices also work for container types:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> struct MySimpleContainer{A<:AbstractVector}\n           a::A\n       end\n\njulia> struct MyAmbiguousContainer{T}\n           a::AbstractVector{T}\n       end","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"例えば:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> c = MySimpleContainer(1:3);\n\njulia> typeof(c)\nMySimpleContainer{UnitRange{Int64}}\n\njulia> c = MySimpleContainer([1:3;]);\n\njulia> typeof(c)\nMySimpleContainer{Array{Int64,1}}\n\njulia> b = MyAmbiguousContainer(1:3);\n\njulia> typeof(b)\nMyAmbiguousContainer{Int64}\n\njulia> b = MyAmbiguousContainer([1:3;]);\n\njulia> typeof(b)\nMyAmbiguousContainer{Int64}","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"For MySimpleContainer, the object is fully-specified by its type and parameters, so the compiler can generate optimized functions. In most instances, this will probably suffice.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"While the compiler can now do its job perfectly well, there are cases where you might wish that your code could do different things depending on the element type of a. Usually the best way to achieve this is to wrap your specific operation (here, foo) in a separate function:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> function sumfoo(c::MySimpleContainer)\n           s = 0\n           for x in c.a\n               s += foo(x)\n           end\n           s\n       end\nsumfoo (generic function with 1 method)\n\njulia> foo(x::Integer) = x\nfoo (generic function with 1 method)\n\njulia> foo(x::AbstractFloat) = round(x)\nfoo (generic function with 2 methods)","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This keeps things simple, while allowing the compiler to generate optimized code in all cases.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"However, there are cases where you may need to declare different versions of the outer function for different element types or types of the AbstractVector of the field a in MySimpleContainer.  You could do it like this:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:Integer}})\n           return c.a[1]+1\n       end\nmyfunc (generic function with 1 method)\n\njulia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:AbstractFloat}})\n           return c.a[1]+2\n       end\nmyfunc (generic function with 2 methods)\n\njulia> function myfunc(c::MySimpleContainer{Vector{T}}) where T <: Integer\n           return c.a[1]+3\n       end\nmyfunc (generic function with 3 methods)","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> myfunc(MySimpleContainer(1:3))\n2\n\njulia> myfunc(MySimpleContainer(1.0:3))\n3.0\n\njulia> myfunc(MySimpleContainer([1:3;]))\n4","category":"page"},{"location":"manual/performance-tips.html#Annotate-values-taken-from-untyped-locations-1","page":"パフォーマンス・ティップス","title":"Annotate values taken from untyped locations","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"It is often convenient to work with data structures that may contain values of any type (arrays of type Array{Any}). But, if you're using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"function foo(a::Array{Any,1})\n    x = a[1]::Int32\n    b = x+1\n    ...\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Here, we happened to know that the first element of a would be an Int32. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"In the case that the type of a[1] is not known precisely, x can be declared via x = convert(Int32, a[1])::Int32. The use of the convert function allows a[1] to be any object convertible to an Int32 (such as UInt8), thus increasing the genericity of the code by loosening the type requirement. Notice that convert itself needs a type annotation in this context in order to achieve type stability. This is because the compiler cannot deduce the type of the return value of a function, even convert, unless the types of all the function's arguments are known.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Type annotation will not enhance (and can actually hinder) performance if the type is constructed at run-time. This is because the compiler cannot use the annotation to specialize the subsequent code, and the type-check itself takes time. For example, in the code:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"function nr(a, prec)\n    ctype = prec == 32 ? Float32 : Float64\n    b = Complex{ctype}(a)\n    c = (b + 1.0f0)::Complex{ctype}\n    abs(c)\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"the annotation of c harms performance. To write performant code involving types constructed at run-time, use the function-barrier technique discussed below, and ensure that the constructed type appears among the argument types of the kernel function so that the kernel operations are properly specialized by the compiler. For example, in the above snippet, as soon as b is constructed, it can be passed to another function k, the kernel. If, for example, function k declares b as an argument of type Complex{T}, where T is a type parameter, then a type annotation appearing in an assignment statement within k of the form:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"c = (b + 1.0f0)::Complex{T}","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"does not hinder performance (but does not help either) since the compiler can determine the type of c at the time k is compiled.","category":"page"},{"location":"manual/performance-tips.html#Break-functions-into-multiple-definitions-1","page":"パフォーマンス・ティップス","title":"Break functions into multiple definitions","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Writing a function as many small definitions allows the compiler to directly call the most applicable code, or even inline it.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Here is an example of a \"compound function\" that should really be written as multiple definitions:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"using LinearAlgebra\n\nfunction mynorm(A)\n    if isa(A, Vector)\n        return sqrt(real(dot(A,A)))\n    elseif isa(A, Matrix)\n        return maximum(svdvals(A))\n    else\n        error(\"mynorm: invalid argument\")\n    end\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This can be written more concisely and efficiently as:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"norm(x::Vector) = sqrt(real(dot(x, x)))\nnorm(A::Matrix) = maximum(svdvals(A))","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"It should however be noted that the compiler is quite efficient at optimizing away the dead branches in code written as the mynorm example.","category":"page"},{"location":"manual/performance-tips.html#Write-\"type-stable\"-functions-1","page":"パフォーマンス・ティップス","title":"Write \"type-stable\" functions","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"When possible, it helps to ensure that a function always returns a value of the same type. Consider the following definition:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"pos(x) = x < 0 ? 0 : x","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Although this seems innocent enough, the problem is that 0 is an integer (of type Int) and x might be of any type. Thus, depending on the value of x, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"pos(x) = x < 0 ? zero(x) : x","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"There is also a oneunit function, and a more general oftype(x, y) function, which returns y converted to the type of x.","category":"page"},{"location":"manual/performance-tips.html#Avoid-changing-the-type-of-a-variable-1","page":"パフォーマンス・ティップス","title":"Avoid changing the type of a variable","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"An analogous \"type-stability\" problem exists for variables used repeatedly within a function:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"function foo()\n    x = 1\n    for i = 1:10\n        x /= rand()\n    end\n    return x\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Local variable x starts as an integer, and after one loop iteration becomes a floating-point number (the result of / operator). This makes it more difficult for the compiler to optimize the body of the loop. There are several possible fixes:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Initialize x with x = 1.0\nDeclare the type of x: x::Float64 = 1\nUse an explicit conversion: x = oneunit(Float64)\nInitialize with the first loop iteration, to x = 1 / rand(), then loop for i = 2:10","category":"page"},{"location":"manual/performance-tips.html#kernel-functions-1","page":"パフォーマンス・ティップス","title":"Separate kernel functions (aka, function barriers)","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Many functions follow a pattern of performing some set-up work, and then running many iterations to perform a core computation. Where possible, it is a good idea to put these core computations in separate functions. For example, the following contrived function returns an array of a randomly-chosen type:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> function strange_twos(n)\n           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\n           for i = 1:n\n               a[i] = 2\n           end\n           return a\n       end;\n\njulia> strange_twos(3)\n3-element Array{Float64,1}:\n 2.0\n 2.0\n 2.0","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This should be written as:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> function fill_twos!(a)\n           for i = eachindex(a)\n               a[i] = 2\n           end\n       end;\n\njulia> function strange_twos(n)\n           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\n           fill_twos!(a)\n           return a\n       end;\n\njulia> strange_twos(3)\n3-element Array{Float64,1}:\n 2.0\n 2.0\n 2.0","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Julia's compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of a during the loop (since it is chosen randomly).  Therefore the second version is generally faster since the inner loop can be recompiled as part of fill_twos! for different types of a.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The second form is also often better style and can lead to more code reuse.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This pattern is used in several places in Julia Base. For example, see vcat and hcat in abstractarray.jl, or the fill! function, which we could have used instead of writing our own fill_twos!.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Functions like strange_twos occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else.","category":"page"},{"location":"manual/performance-tips.html#Types-with-values-as-parameters-1","page":"パフォーマンス・ティップス","title":"Types with values-as-parameters","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Let's say you want to create an N-dimensional array that has size 3 along each axis. Such arrays can be created like this:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> A = fill(5.0, (3, 3))\n3×3 Array{Float64,2}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This approach works very well: the compiler can figure out that A is an Array{Float64,2} because it knows the type of the fill value (5.0::Float64) and the dimensionality ((3, 3)::NTuple{2,Int}).  This implies that the compiler can generate very efficient code for any future usage of A in the same function.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"But now let's say you want to write a function that creates a 3×3×... array in arbitrary dimensions; you might be tempted to write a function","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> function array3(fillval, N)\n           fill(fillval, ntuple(d->3, N))\n       end\narray3 (generic function with 1 method)\n\njulia> array3(5.0, 2)\n3×3 Array{Float64,2}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This works, but (as you can verify for yourself using @code_warntype array3(5.0, 2)) the problem is that the output type cannot be inferred: the argument N is a value of type Int, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of A; such code will be very slow.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Now, one very good way to solve such problems is by using the function-barrier technique.  However, in some cases you might want to eliminate the type-instability altogether. In such cases, one approach is to pass the dimensionality as a parameter, for example through Val{T}() (see \"Value types\"):","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> function array3(fillval, ::Val{N}) where N\n           fill(fillval, ntuple(d->3, Val(N)))\n       end\narray3 (generic function with 1 method)\n\njulia> array3(5.0, Val(2))\n3×3 Array{Float64,2}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Julia has a specialized version of ntuple that accepts a Val{::Int} instance as the second parameter; by passing N as a type-parameter, you make its \"value\" known to the compiler.  Consequently, this version of array3 allows the compiler to predict the return type.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called array3 from a function like this:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"function call_array3(fillval, n)\n    A = array3(fillval, Val(n))\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Here, you've created the same problem all over again: the compiler can't guess what n is, so it doesn't know the type of Val(n). Attempting to use Val, but doing so incorrectly, can easily make performance worse in many situations. (Only in situations where you're effectively combining Val with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"An example of correct usage of Val would be:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"function filter3(A::AbstractArray{T,N}) where {T,N}\n    kernel = array3(1, Val(N))\n    filter(A, kernel)\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"In this example, N is passed as a parameter, so its \"value\" is known to the compiler. Essentially, Val(T) works only when T is either hard-coded/literal (Val(3)) or already specified in the type-domain.","category":"page"},{"location":"manual/performance-tips.html#The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)-1","page":"パフォーマンス・ティップス","title":"The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Once one learns to appreciate multiple dispatch, there's an understandable tendency to go overboard and try to use it for everything. For example, you might imagine using it to store information, e.g.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"struct Car{Make, Model}\n    year::Int\n    ...more fields...\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"and then dispatch on objects like Car{:Honda,:Accord}(year, args...).","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This might be worthwhile when either of the following are true:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"You require CPU-intensive processing on each Car, and it becomes vastly more efficient if you know the Make and Model at compile time and the total number of different Make or Model that will be used is not too large.\nYou have homogenous lists of the same type of Car to process, so that you can store them all in an Array{Car{:Honda,:Accord},N}.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"When the latter holds, a function processing such a homogenous array can be productively specialized: Julia knows the type of each element in advance (all objects in the container have the same concrete type), so Julia can \"look up\" the correct method calls when the function is being compiled (obviating the need to check at run-time) and thereby emit efficient code for processing the whole list.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"When these do not hold, then it's likely that you'll get no benefit; worse, the resulting \"combinatorial explosion of types\" will be counterproductive. If items[i+1] has a different type than item[i], Julia has to look up the type at run-time, search for the appropriate method in method tables, decide (via type intersection) which one matches, determine whether it has been JIT-compiled yet (and do so if not), and then make the call. In essence, you're asking the full type- system and JIT-compilation machinery to basically execute the equivalent of a switch statement or dictionary lookup in your own code.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Some run-time benchmarks comparing (1) type dispatch, (2) dictionary lookup, and (3) a \"switch\" statement can be found on the mailing list.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Perhaps even worse than the run-time impact is the compile-time impact: Julia will compile specialized functions for each different Car{Make, Model}; if you have hundreds or thousands of such types, then every function that accepts such an object as a parameter (from a custom get_year function you might write yourself, to the generic push! function in Julia Base) will have hundreds or thousands of variants compiled for it. Each of these increases the size of the cache of compiled code, the length of internal lists of methods, etc. Excess enthusiasm for values-as-parameters can easily waste enormous resources.","category":"page"},{"location":"manual/performance-tips.html#Access-arrays-in-memory-order,-along-columns-1","page":"パフォーマンス・ティップス","title":"Access arrays in memory order, along columns","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Multidimensional arrays in Julia are stored in column-major order. This means that arrays are stacked one column at a time. This can be verified using the vec function or the syntax [:] as shown below (notice that the array is ordered [1 3 2 4], not [1 2 3 4]):","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> x = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> x[:]\n4-element Array{Int64,1}:\n 1\n 3\n 2\n 4","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (numpy) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Consider the following contrived example. Imagine we wanted to write a function that accepts a Vector and returns a square Matrix with either the rows or the columns filled with copies of the input vector. Assume that it is not important whether rows or columns are filled with these copies (perhaps the rest of the code can be easily adapted accordingly). We could conceivably do this in at least four ways (in addition to the recommended call to the built-in repeat):","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"function copy_cols(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for i = inds\n        out[:, i] = x\n    end\n    return out\nend\n\nfunction copy_rows(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for i = inds\n        out[i, :] = x\n    end\n    return out\nend\n\nfunction copy_col_row(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for col = inds, row = inds\n        out[row, col] = x[row]\n    end\n    return out\nend\n\nfunction copy_row_col(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for row = inds, col = inds\n        out[row, col] = x[col]\n    end\n    return out\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Now we will time each of these functions using the same random 10000 by 1 input vector:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> x = randn(10000);\n\njulia> fmt(f) = println(rpad(string(f)*\": \", 14, ' '), @elapsed f(x))\n\njulia> map(fmt, [copy_cols, copy_rows, copy_col_row, copy_row_col]);\ncopy_cols:    0.331706323\ncopy_rows:    1.799009911\ncopy_col_row: 0.415630047\ncopy_row_col: 1.721531501","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Notice that copy_cols is much faster than copy_rows. This is expected because copy_cols respects the column-based memory layout of the Matrix and fills it one column at a time. Additionally, copy_col_row is much faster than copy_row_col because it follows our rule of thumb that the first element to appear in a slice expression should be coupled with the inner-most loop.","category":"page"},{"location":"manual/performance-tips.html#Pre-allocating-outputs-1","page":"パフォーマンス・ティップス","title":"出力の事前割当","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"If your function returns an Array or some other complex type, it may have to allocate memory.  Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Sometimes you can circumvent the need to allocate memory on each function call by preallocating the output. As a trivial example, compare","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> function xinc(x)\n           return [x, x+1, x+2]\n       end;\n\njulia> function loopinc()\n           y = 0\n           for i = 1:10^7\n               ret = xinc(i)\n               y += ret[2]\n           end\n           return y\n       end;","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"with","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> function xinc!(ret::AbstractVector{T}, x::T) where T\n           ret[1] = x\n           ret[2] = x+1\n           ret[3] = x+2\n           nothing\n       end;\n\njulia> function loopinc_prealloc()\n           ret = Vector{Int}(undef, 3)\n           y = 0\n           for i = 1:10^7\n               xinc!(ret, i)\n               y += ret[2]\n           end\n           return y\n       end;","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Timing results:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> @time loopinc()\n  0.529894 seconds (40.00 M allocations: 1.490 GiB, 12.14% gc time)\n50000015000000\n\njulia> @time loopinc_prealloc()\n  0.030850 seconds (6 allocations: 288 bytes)\n50000015000000","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Preallocation has other advantages, for example by allowing the caller to control the \"output\" type from an algorithm. In the example above, we could have passed a SubArray rather than an Array, had we so desired.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some judgment may be required. However, for \"vectorized\" (element-wise) functions, the convenient syntax x .= f.(y) can be used for in-place operations with fused loops and no temporary arrays (see the dot syntax for vectorizing functions).","category":"page"},{"location":"manual/performance-tips.html#More-dots:-Fuse-vectorized-operations-1","page":"パフォーマンス・ティップス","title":"More dots: Fuse vectorized operations","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Julia has a special dot syntax that converts any scalar function into a \"vectorized\" function call, and any operator into a \"vectorized\" operator, with the special property that nested \"dot calls\" are fusing: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use .= and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"In a linear-algebra context, this means that even though operations like vector + vector and vector * scalar are defined, it can be advantageous to instead use vector .+ vector and vector .* scalar because the resulting loops can be fused with surrounding computations. For example, consider the two functions:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> f(x) = 3x.^2 + 4x + 7x.^3;\n\njulia> fdot(x) = @. 3x^2 + 4x + 7x^3 # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3;","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Both f and fdot compute the same thing. However, fdot (defined with the help of the @. macro) is significantly faster when applied to an array:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> x = rand(10^6);\n\njulia> @time f(x);\n  0.019049 seconds (16 allocations: 45.777 MiB, 18.59% gc time)\n\njulia> @time fdot(x);\n  0.002790 seconds (6 allocations: 7.630 MiB)\n\njulia> @time f.(x);\n  0.002626 seconds (8 allocations: 7.630 MiB)","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"That is, fdot(x) is ten times faster and allocates 1/6 the memory of f(x), because each * and + operation in f(x) allocates a new temporary array and executes in a separate loop. (Of course, if you just do f.(x) then it is as fast as fdot(x) in this example, but in many contexts it is more convenient to just sprinkle some dots in your expressions rather than defining a separate function for each vectorized operation.)","category":"page"},{"location":"manual/performance-tips.html#Consider-using-views-for-slices-1","page":"パフォーマンス・ティップス","title":"Consider using views for slices","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"In Julia, an array \"slice\" expression like array[1:5, :] creates a copy of that data (except on the left-hand side of an assignment, where array[1:5, :] = ... assigns in-place to that portion of array).  If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array.  On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"An alternative is to create a \"view\" of the array, which is an array object (a SubArray) that actually references the data of the original array in-place, without making a copy. (If you write to a view, it modifies the original array's data as well.)  This can be done for individual slices by calling view, or more simply for a whole expression or block of code by putting @views in front of that expression. For example:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> fcopy(x) = sum(x[2:end-1]);\n\njulia> @views fview(x) = sum(x[2:end-1]);\n\njulia> x = rand(10^6);\n\njulia> @time fcopy(x);\n  0.003051 seconds (7 allocations: 7.630 MB)\n\njulia> @time fview(x);\n  0.001020 seconds (6 allocations: 224 bytes)","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Notice both the 3× speedup and the decreased memory allocation of the fview version of the function.","category":"page"},{"location":"manual/performance-tips.html#Copying-data-is-not-always-bad-1","page":"パフォーマンス・ティップス","title":"Copying data is not always bad","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Arrays are stored contiguously in memory, lending themselves to CPU vectorization and fewer memory accesses due to caching. These are the same reasons that it is recommended to access arrays in column-major order (see above). Irregular access patterns and non-contiguous views can drastically slow down computations on arrays because of non-sequential memory access.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Copying irregularly-accessed data into a contiguous array before operating on it can result in a large speedup, such as in the example below. Here, a matrix and a vector are being accessed at 800,000 of their randomly-shuffled indices before being multiplied. Copying the views into plain arrays speeds up the multiplication even with the cost of the copying operation.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> using Random\n\njulia> x = randn(1_000_000);\n\njulia> inds = shuffle(1:1_000_000)[1:800000];\n\njulia> A = randn(50, 1_000_000);\n\njulia> xtmp = zeros(800_000);\n\njulia> Atmp = zeros(50, 800_000);\n\njulia> @time sum(view(A, :, inds) * view(x, inds))\n  0.412156 seconds (14 allocations: 960 bytes)\n-4256.759568345458\n\njulia> @time begin\n           copyto!(xtmp, view(x, inds))\n           copyto!(Atmp, view(A, :, inds))\n           sum(Atmp * xtmp)\n       end\n  0.285923 seconds (14 allocations: 960 bytes)\n-4256.759568345134","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Provided there is enough memory for the copies, the cost of copying the view to an array is far outweighed by the speed boost from doing the matrix multiplication on a contiguous array.","category":"page"},{"location":"manual/performance-tips.html#Avoid-string-interpolation-for-I/O-1","page":"パフォーマンス・ティップス","title":"Avoid string interpolation for I/O","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"When writing data to a file (or other I/O device), forming extra intermediate strings is a source of overhead. Instead of:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"println(file, \"$a $b\")","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"use:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"println(file, a, \" \", b)","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"println(file, \"$(f(a))$(f(b))\")","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"versus:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"println(file, f(a), f(b))","category":"page"},{"location":"manual/performance-tips.html#Optimize-network-I/O-during-parallel-execution-1","page":"パフォーマンス・ティップス","title":"Optimize network I/O during parallel execution","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"When executing a remote function in parallel:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"using Distributed\n\nresponses = Vector{Any}(undef, nworkers())\n@sync begin\n    for (idx, pid) in enumerate(workers())\n        @async responses[idx] = remotecall_fetch(foo, pid, args...)\n    end\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"is faster than:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"using Distributed\n\nrefs = Vector{Any}(undef, nworkers())\nfor (idx, pid) in enumerate(workers())\n    refs[idx] = @spawnat pid foo(args...)\nend\nresponses = [fetch(r) for r in refs]","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the @spawnat and the second due to the fetch  (or even a wait).  The fetch/wait is also being executed serially resulting in an overall poorer performance.","category":"page"},{"location":"manual/performance-tips.html#Fix-deprecation-warnings-1","page":"パフォーマンス・ティップス","title":"Fix deprecation warnings","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"A deprecated function internally performs a lookup in order to print a relevant warning only once.  This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings.","category":"page"},{"location":"manual/performance-tips.html#Tweaks-1","page":"パフォーマンス・ティップス","title":"Tweaks","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"These are some minor points that might help in tight inner loops.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Avoid unnecessary arrays. For example, instead of sum([x,y,z]) use x+y+z.\nUse abs2(z) instead of abs(z)^2 for complex z. In general, try to rewrite code to use abs2 instead of abs for complex arguments.\nUse div(x,y) for truncating division of integers instead of trunc(x/y), fld(x,y)  instead of floor(x/y), and cld(x,y) instead of ceil(x/y).","category":"page"},{"location":"manual/performance-tips.html#man-performance-annotations-1","page":"パフォーマンス・ティップス","title":"Performance Annotations","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Sometimes you can enable better optimization by promising certain program properties.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Use @inbounds to eliminate array bounds checking within expressions. Be certain before doing this. If the subscripts are ever out of bounds, you may suffer crashes or silent corruption.\nUse @fastmath to allow floating point optimizations that are correct for real numbers, but lead to differences for IEEE numbers. Be careful when doing this, as this may change numerical results.  This corresponds to the -ffast-math option of clang.\nWrite @simd in front of for loops to promise that the iterations are independent and may be reordered.  Note that in many cases, Julia can automatically vectorize code without the @simd macro; it is only beneficial in cases where such a transformation would otherwise be illegal, including cases like allowing floating-point re-associativity and ignoring dependent memory accesses (@simd ivdep).  Again, be very careful when asserting @simd as erroneously annotating a loop with dependent iterations may result in unexpected results. In particular, note that setindex! on some AbstractArray subtypes is inherently dependent upon iteration order. This feature is experimental and could change or disappear in future versions of Julia.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing, and may cause a segmentation fault if bounds checking is turned off. Use LinearIndices(x) or eachindex(x) instead (see also offset-arrays).","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"note: Note\nWhile @simd needs to be placed directly in front of an innermost for loop, both @inbounds and @fastmath can be applied to either single expressions or all the expressions that appear within nested blocks of code, e.g., using @inbounds begin or @inbounds for ....","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Here is an example with both @inbounds and @simd markup (we here use @noinline to prevent the optimizer from trying to be too clever and defeat our benchmark):","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"@noinline function inner(x, y)\n    s = zero(eltype(x))\n    for i=eachindex(x)\n        @inbounds s += x[i]*y[i]\n    end\n    return s\nend\n\n@noinline function innersimd(x, y)\n    s = zero(eltype(x))\n    @simd for i = eachindex(x)\n        @inbounds s += x[i] * y[i]\n    end\n    return s\nend\n\nfunction timeit(n, reps)\n    x = rand(Float32, n)\n    y = rand(Float32, n)\n    s = zero(Float64)\n    time = @elapsed for j in 1:reps\n        s += inner(x, y)\n    end\n    println(\"GFlop/sec        = \", 2n*reps / time*1E-9)\n    time = @elapsed for j in 1:reps\n        s += innersimd(x, y)\n    end\n    println(\"GFlop/sec (SIMD) = \", 2n*reps / time*1E-9)\nend\n\ntimeit(1000, 1000)","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"On a computer with a 2.4GHz Intel Core i5 processor, this produces:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"GFlop/sec        = 1.9467069505224963\nGFlop/sec (SIMD) = 17.578554163920018","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"(GFlop/sec measures the performance, and larger numbers are better.)","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"function init!(u::Vector)\n    n = length(u)\n    dx = 1.0 / (n-1)\n    @fastmath @inbounds @simd for i in 1:n #by asserting that `u` is a `Vector` we can assume it has 1-based indexing\n        u[i] = sin(2pi*dx*i)\n    end\nend\n\nfunction deriv!(u::Vector, du)\n    n = length(u)\n    dx = 1.0 / (n-1)\n    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx\n    @fastmath @inbounds @simd for i in 2:n-1\n        du[i] = (u[i+1] - u[i-1]) / (2*dx)\n    end\n    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx\nend\n\nfunction mynorm(u::Vector)\n    n = length(u)\n    T = eltype(u)\n    s = zero(T)\n    @fastmath @inbounds @simd for i in 1:n\n        s += u[i]^2\n    end\n    @fastmath @inbounds return sqrt(s)\nend\n\nfunction main()\n    n = 2000\n    u = Vector{Float64}(undef, n)\n    init!(u)\n    du = similar(u)\n\n    deriv!(u, du)\n    nu = mynorm(du)\n\n    @time for i in 1:10^6\n        deriv!(u, du)\n        nu = mynorm(du)\n    end\n\n    println(nu)\nend\n\nmain()","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"On a computer with a 2.7 GHz Intel Core i7 processor, this produces:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"$ julia wave.jl;\n  1.207814709 seconds\n4.443986180758249\n\n$ julia --math-mode=ieee wave.jl;\n  4.487083643 seconds\n4.443986180758249","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Here, the option --math-mode=ieee disables the @fastmath macro, so that we can compare results.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"In this case, the speedup due to @fastmath is a factor of about 3.7. This is unusually large – in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result – in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The annotation @fastmath re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression 1 / (2*dx) in the function deriv is hoisted out of the loop (i.e. calculated outside the loop), as if one had written idx = 1 / (2*dx). In the loop, the expression ... / (2*dx) then becomes ... * idx, which is much faster to evaluate. Of course, both the actual optimization that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by using Julia's code_native function.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Note that @fastmath also assumes that NaNs will not occur during the computation, which can lead to surprising behavior:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> f(x) = isnan(x);\n\njulia> f(NaN)\ntrue\n\njulia> f_fast(x) = @fastmath isnan(x);\n\njulia> f_fast(NaN)\nfalse","category":"page"},{"location":"manual/performance-tips.html#Treat-Subnormal-Numbers-as-Zeros-1","page":"パフォーマンス・ティップス","title":"Treat Subnormal Numbers as Zeros","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Subnormal numbers, formerly called denormal numbers, are useful in many contexts, but incur a performance penalty on some hardware. A call set_zero_subnormals(true)  grants permission for floating-point operations to treat subnormal inputs or outputs as zeros, which may improve performance on some hardware. A call set_zero_subnormals(false) enforces strict IEEE behavior for subnormal numbers.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Below is an example where subnormals noticeably impact performance on some hardware:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"function timestep(b::Vector{T}, a::Vector{T}, Δt::T) where T\n    @assert length(a)==length(b)\n    n = length(b)\n    b[1] = 1                            # Boundary condition\n    for i=2:n-1\n        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * Δt\n    end\n    b[n] = 0                            # Boundary condition\nend\n\nfunction heatflow(a::Vector{T}, nstep::Integer) where T\n    b = similar(a)\n    for t=1:div(nstep,2)                # Assume nstep is even\n        timestep(b,a,T(0.1))\n        timestep(a,b,T(0.1))\n    end\nend\n\nheatflow(zeros(Float32,10),2)           # Force compilation\nfor trial=1:6\n    a = zeros(Float32,1000)\n    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic\n    @time heatflow(a,1000)\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This gives an output similar to","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"  0.002202 seconds (1 allocation: 4.063 KiB)\n  0.001502 seconds (1 allocation: 4.063 KiB)\n  0.002139 seconds (1 allocation: 4.063 KiB)\n  0.001454 seconds (1 allocation: 4.063 KiB)\n  0.002115 seconds (1 allocation: 4.063 KiB)\n  0.001455 seconds (1 allocation: 4.063 KiB)","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Note how each even iteration is significantly faster.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This example generates many subnormal numbers because the values in a become an exponentially decreasing curve, which slowly flattens out over time.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as x-y == 0 implies x == y:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> x = 3f-38; y = 2f-38;\n\njulia> set_zero_subnormals(true); (x - y, x == y)\n(0.0f0, false)\n\njulia> set_zero_subnormals(false); (x - y, x == y)\n(1.0000001f-38, false)","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise.  For example, instead of initializing a with zeros, initialize it with:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"a = rand(Float32,1000) * 1.f-9","category":"page"},{"location":"manual/performance-tips.html#man-code-warntype-1","page":"パフォーマンス・ティップス","title":"@code_warntype","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The macro @code_warntype (or its function variant code_warntype) can sometimes be helpful in diagnosing type-related problems. Here's an example:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"julia> @noinline pos(x) = x < 0 ? 0 : x;\n\njulia> function f(x)\n           y = pos(x)\n           return sin(y*x + 1)\n       end;\n\njulia> @code_warntype f(3.2)\nVariables\n  #self#::Core.Compiler.Const(f, false)\n  x::Float64\n  y::Union{Float64, Int64}\n\nBody::Float64\n1 ─      (y = Main.pos(x))\n│   %2 = (y * x)::Float64\n│   %3 = (%2 + 1)::Float64\n│   %4 = Main.sin(%3)::Float64\n└──      return %4","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Interpreting the output of @code_warntype, like that of its cousins @code_lowered, @code_typed, @code_llvm, and @code_native, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the ::T (where T might be Float64, for example). The most important characteristic of @code_warntype  is that non-concrete types are displayed in red; in the above example, such output is shown in uppercase.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"At the top, the inferred return type of the function is shown as Body::Float64.  The next lines represent the body of f in Julia's SSA IR form.  The numbered boxes are labels and represent targets for jumps (via goto) in your code.  Looking at the body, you can see that the first thing that happens is that pos is called and the return value has been inferred as the Union type UNION{FLOAT64, INT64} shown in uppercase since it is a non-concrete type. This means that we cannot know the exact return type of pos based on the input types. However, the result of y*xis a Float64 no matter if y is a Float64 or Int64 The net result is that f(x::Float64) will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"How you use this information is up to you. Obviously, it would be far and away best to fix pos to be type-stable: if you did so, all of the variables in f would be concrete, and its performance would be optimal. However, there are circumstances where this kind of ephemeral type instability might not matter too much: for example, if pos is never used in isolation, the fact that f's output is type-stable (for Float64 inputs) will shield later code from the propagating effects of type instability. This is particularly relevant in cases where fixing the type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the \"damage\" from type instability.  Also, note that even Julia Base has functions that are type unstable.  For example, the function findfirst returns the index into an array where a key is found, or nothing if it is not found, a clear type instability. In order to make it easier to find the type instabilities that are likely to be important, Unions containing either missing or nothing are color highlighted in yellow, instead of red.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The following examples may help you interpret expressions marked as containing non-leaf types:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Function body starting with Body::UNION{T1,T2})\nInterpretation: function with unstable return type\nSuggestion: make the return value type-stable, even if you have to annotate it\ninvoke Main.g(%%x::Int64)::UNION{FLOAT64, INT64}\nInterpretation: call to a type-unstable function g.\nSuggestion: fix the function, or if necessary annotate the return value\ninvoke Base.getindex(%%x::Array{Any,1}, 1::Int64)::ANY\nInterpretation: accessing elements of poorly-typed arrays\nSuggestion: use arrays with better-defined types, or if necessary annotate the type of individual element accesses\nBase.getfield(%%x, :(:data))::ARRAY{FLOAT64,N} WHERE N\nInterpretation: getting a field that is of non-leaf type. In this case, ArrayContainer had a field data::Array{T}. But Array needs the dimension N, too, to be a concrete type.\nSuggestion: use concrete types like Array{T,3} or Array{T,N}, where N is now a parameter of ArrayContainer","category":"page"},{"location":"manual/performance-tips.html#man-performance-captured-1","page":"パフォーマンス・ティップス","title":"Performance of captured variable","text":"","category":"section"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Consider the following example that defines an inner function:","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"function abmult(r::Int)\n    if r < 0\n        r = -r\n    end\n    f = x -> x * r\n    return f\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Function abmult returns a function f that multiplies its argument by the absolute value of r. The inner function assigned to f is called a \"closure\". Inner functions are also used by the language for do-blocks and for generator expressions.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"This style of code presents performance challenges for the language.  The parser, when translating it into lower-level instructions, substantially reorganizes the above code by extracting the inner function to a separate code block.  \"Captured\" variables such as r that are shared by inner functions and their enclosing scope are also extracted into a heap-allocated \"box\" accessible to both inner and outer functions because the language specifies that r in the inner scope must be identical to r in the outer scope even after the outer scope (or another inner function) modifies r.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The discussion in the preceding paragraph referred to the \"parser\", that is, the phase of compilation that takes place when the module containing abmult is first loaded, as opposed to the later phase when it is first invoked. The parser does not \"know\" that Int is a fixed type, or that the statement r = -r transforms an Int to another Int.  The magic of type inference takes place in the later phase of compilation.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"Thus, the parser does not know that r has a fixed type (Int).  nor that r does not change value once the inner function is created (so that the box is unneeded).  Therefore, the parser emits code for box that holds an object with an abstract type such as Any, which requires run-time type dispatch for each occurrence of r.  This can be verified by applying @code_warntype to the above function.  Both the boxing and the run-time type dispatch can cause loss of performance.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"If captured variables are used in a performance-critical section of the code, then the following tips help ensure that their use is performant. First, if it is known that a captured variable does not change its type, then this can be declared explicitly with a type annotation (on the variable, not the right-hand side):","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"function abmult2(r0::Int)\n    r::Int = r0\n    if r < 0\n        r = -r\n    end\n    f = x -> x * r\n    return f\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The type annotation partially recovers lost performance due to capturing because the parser can associate a concrete type to the object in the box. Going further, if the captured variable does not need to be boxed at all (because it will not be reassigned after the closure is created), this can be indicated with let blocks as follows.","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"function abmult3(r::Int)\n    if r < 0\n        r = -r\n    end\n    f = let r = r\n            x -> x * r\n    end\n    return f\nend","category":"page"},{"location":"manual/performance-tips.html#","page":"パフォーマンス・ティップス","title":"パフォーマンス・ティップス","text":"The let block creates a new variable r whose scope is only the inner function. The second technique recovers full language performance in the presence of captured variables. Note that this is a rapidly evolving aspect of the compiler, and it is likely that future releases will not require this degree of programmer annotation to attain performance.  In the mean time, some user-contributed packages like FastClosures automate the insertion of let statements as in abmult3.","category":"page"},{"location":"manual/workflow-tips.html#man-workflow-tips-1","page":"Workflow Tips","title":"Workflow Tips","text":"","category":"section"},{"location":"manual/workflow-tips.html#","page":"Workflow Tips","title":"Workflow Tips","text":"Here are some tips for working with Julia efficiently.","category":"page"},{"location":"manual/workflow-tips.html#REPL-based-workflow-1","page":"Workflow Tips","title":"REPL-based workflow","text":"","category":"section"},{"location":"manual/workflow-tips.html#","page":"Workflow Tips","title":"Workflow Tips","text":"As already elaborated in The Julia REPL, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.","category":"page"},{"location":"manual/workflow-tips.html#A-basic-editor/REPL-workflow-1","page":"Workflow Tips","title":"A basic editor/REPL workflow","text":"","category":"section"},{"location":"manual/workflow-tips.html#","page":"Workflow Tips","title":"Workflow Tips","text":"The most basic Julia workflows involve using a text editor in conjunction with the julia command line. A common pattern includes the following elements:","category":"page"},{"location":"manual/workflow-tips.html#","page":"Workflow Tips","title":"Workflow Tips","text":"Put code under development in a temporary module. Create a file, say Tmp.jl, and include within it\nmodule Tmp\nexport say_hello\n\nsay_hello() = println(\"Hello!\")\n\n# your other definitions here\n\nend\nPut your test code in another file. Create another file, say tst.jl, which looks like\ninclude(\"Tmp.jl\")\nimport .Tmp\n# using .Tmp # we can use `using` to bring the exported symbols in `Tmp` into our namespace\n\nTmp.say_hello()\n# say_hello()\n\n# your other test code here\nand includes tests for the contents of Tmp. Alternatively, you can wrap the contents of your test file in a module, as\nmodule Tst\n    include(\"Tmp.jl\")\n    import .Tmp\n    #using .Tmp\n\n    Tmp.say_hello()\n    # say_hello()\n\n    # your other test code here\nend\nThe advantage is that your testing code is now contained in a module and does not use the global scope in Main for definitions, which is a bit more tidy.\ninclude the tst.jl file in the Julia REPL with include(\"tst.jl\").\nLather. Rinse. Repeat. Explore ideas at the julia command prompt. Save good ideas in tst.jl. To execute tst.jl after it has been changed, just include it again.","category":"page"},{"location":"manual/workflow-tips.html#Browser-based-workflow-1","page":"Workflow Tips","title":"Browser-based workflow","text":"","category":"section"},{"location":"manual/workflow-tips.html#","page":"Workflow Tips","title":"Workflow Tips","text":"It is also possible to interact with a Julia REPL in the browser via IJulia.  See the package home for details.","category":"page"},{"location":"manual/workflow-tips.html#Revise-based-workflows-1","page":"Workflow Tips","title":"Revise-based workflows","text":"","category":"section"},{"location":"manual/workflow-tips.html#","page":"Workflow Tips","title":"Workflow Tips","text":"Whether you're at the REPL or in IJulia, you can typically improve your development experience with Revise. It is common to configure Revise to start whenever julia is started, as per the instructions in the Revise documentation.  Once configured, Revise will track changes to files in any loaded modules, and to any files loaded in to the REPL with includet (but not with plain include); you can then edit the files and the changes take effect without restarting your julia session.  A standard workflow is similar to the REPL-based workflow above, with the following modifications:","category":"page"},{"location":"manual/workflow-tips.html#","page":"Workflow Tips","title":"Workflow Tips","text":"Put your code in a module somewhere on your load path. There are several options for achieving this, of which two recommended choices are:\na. For long-term projects, use    PkgTemplates:\njulia    using PkgTemplates    t = Template()    generate(\"MyPkg\", t)    This will create a blank package, \"MyPkg\", in your .julia/dev directory.    Note that PkgTemplates allows you to control many different options    through its Template constructor.\nIn step 2 below, edit MyPkg/src/MyPkg.jl to change the source code, and    MyPkg/test/runtests.jl for the tests.\nb. For \"throw-away\" projects, you can avoid any need for cleanup    by doing your work in your temporary directory (e.g., /tmp).\nNavigate to your temporary directory and launch Julia, then do the following:\njulia    pkg> generate MyPkg              # type ] to enter pkg mode    julia> push!(LOAD_PATH, pwd())   # hit backspace to exit pkg mode    If you restart your Julia session you'll have to re-issue that command    modifying LOAD_PATH.\nIn step 2 below, edit MyPkg/src/MyPkg.jl to change the source code, and create any    test file of your choosing.\nDevelop your package\nBefore loading any code, make sure you're running Revise: say using Revise or follow its documentation on configuring it to run automatically.\nThen navigate to the directory containing your test file (here assumed to be \"runtests.jl\") and do the following:\njulia> using MyPkg\n\njulia> include(\"runtests.jl\")\nYou can iteratively modify the code in MyPkg in your editor and re-run the tests with include(\"runtests.jl\").  You generally should not need to restart your Julia session to see the changes take effect (subject to a few limitations, see https://timholy.github.io/Revise.jl/stable/limitations/).","category":"page"},{"location":"manual/style-guide.html#スタイルガイド-1","page":"スタイルガイド","title":"スタイルガイド","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"The following sections explain a few aspects of idiomatic Julia coding style. None of these rules are absolute; they are only suggestions to help familiarize you with the language and to help you choose among alternative designs.","category":"page"},{"location":"manual/style-guide.html#Write-functions,-not-just-scripts-1","page":"スタイルガイド","title":"Write functions, not just scripts","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Writing code as a series of steps at the top level is a quick way to get started solving a problem, but you should try to divide a program into functions as soon as possible. Functions are more reusable and testable, and clarify what steps are being done and what their inputs and outputs are. Furthermore, code inside functions tends to run much faster than top level code, due to how Julia's compiler works.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"It is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants like pi).","category":"page"},{"location":"manual/style-guide.html#Avoid-writing-overly-specific-types-1","page":"スタイルガイド","title":"Avoid writing overly-specific types","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Code should be as generic as possible. Instead of writing:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Complex{Float64}(x)","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"it's better to use available generic functions:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"complex(float(x))","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"The second version will convert x to an appropriate type, instead of always the same type.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"This style point is especially relevant to function arguments. For example, don't declare an argument to be of type Int or Int32 if it really could be any integer, expressed with the abstract type Integer. In fact, in many cases you can omit the argument type altogether, unless it is needed to disambiguate from other method definitions, since a MethodError will be thrown anyway if a type is passed that does not support any of the requisite operations. (This is known as duck typing.)","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"For example, consider the following definitions of a function addone that returns one plus its argument:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"addone(x::Int) = x + 1                 # works only for Int\naddone(x::Integer) = x + oneunit(x)    # any integer type\naddone(x::Number) = x + oneunit(x)     # any numeric type\naddone(x) = x + oneunit(x)             # any type supporting + and oneunit","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"The last definition of addone handles any type supporting oneunit (which returns 1 in the same type as x, which avoids unwanted type promotion) and the + function with those arguments. The key thing to realize is that there is no performance penalty to defining only the general addone(x) = x + oneunit(x), because Julia will automatically compile specialized versions as needed. For example, the first time you call addone(12), Julia will automatically compile a specialized addone function for x::Int arguments, with the call to oneunit replaced by its inlined value 1. Therefore, the first three definitions of addone above are completely redundant with the fourth definition.","category":"page"},{"location":"manual/style-guide.html#Handle-excess-argument-diversity-in-the-caller-1","page":"スタイルガイド","title":"Handle excess argument diversity in the caller","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Instead of:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"function foo(x, y)\n    x = Int(x); y = Int(y)\n    ...\nend\nfoo(x, y)","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"use:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"function foo(x::Int, y::Int)\n    ...\nend\nfoo(Int(x), Int(y))","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"This is better style because foo does not really accept numbers of all types; it really needs Int s.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"One issue here is that if a function inherently requires integers, it might be better to force the caller to decide how non-integers should be converted (e.g. floor or ceiling). Another issue is that declaring more specific types leaves more \"space\" for future method definitions.","category":"page"},{"location":"manual/style-guide.html#Append-!-to-names-of-functions-that-modify-their-arguments-1","page":"スタイルガイド","title":"Append ! to names of functions that modify their arguments","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Instead of:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"function double(a::AbstractArray{<:Number})\n    for i = firstindex(a):lastindex(a)\n        a[i] *= 2\n    end\n    return a\nend","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"use:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"function double!(a::AbstractArray{<:Number})\n    for i = firstindex(a):lastindex(a)\n        a[i] *= 2\n    end\n    return a\nend","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Julia Base uses this convention throughout and contains examples of functions with both copying and modifying forms (e.g., sort and sort!), and others which are just modifying (e.g., push!, pop!, splice!).  It is typical for such functions to also return the modified array for convenience.","category":"page"},{"location":"manual/style-guide.html#Avoid-strange-type-Unions-1","page":"スタイルガイド","title":"Avoid strange type Unions","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Types such as Union{Function,AbstractString} are often a sign that some design could be cleaner.","category":"page"},{"location":"manual/style-guide.html#Avoid-elaborate-container-types-1","page":"スタイルガイド","title":"Avoid elaborate container types","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"It is usually not much help to construct arrays like the following:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"a = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"In this case Vector{Any}(undef, n) is better. It is also more helpful to the compiler to annotate specific uses (e.g. a[i]::Int) than to try to pack many alternatives into one type.","category":"page"},{"location":"manual/style-guide.html#Use-naming-conventions-consistent-with-Julia-base/-1","page":"スタイルガイド","title":"Use naming conventions consistent with Julia base/","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"modules and type names use capitalization and camel case: module SparseArrays, struct UnitRange.\nfunctions are lowercase (maximum, convert) and, when readable, with multiple words squashed together (isequal, haskey). When necessary, use underscores as word separators. Underscores are also used to indicate a combination of concepts (remotecall_fetch  as a more efficient implementation of fetch(remotecall(...))) or as modifiers.\nconciseness is valued, but avoid abbreviation (indexin rather than indxin) as it becomes difficult to remember whether and how particular words are abbreviated.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces.","category":"page"},{"location":"manual/style-guide.html#Write-functions-with-argument-ordering-similar-to-Julia-Base-1","page":"スタイルガイド","title":"Write functions with argument ordering similar to Julia Base","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"As a general rule, the Base library uses the following order of arguments to functions, as applicable:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Function argument.  Putting a function argument first permits the use of do blocks for passing multiline anonymous functions.\nI/O stream.  Specifying the IO object first permits passing the function to functions such as sprint, e.g. sprint(show, x).\nInput being mutated.  For example, in fill!(x, v), x is the object being mutated and it appears before the value to be inserted into x.\nType.  Passing a type typically means that the output will have the given type.  In parse(Int, \"1\"), the type comes before the string to parse.  There are many such examples where the type appears first, but it's useful to note that in read(io, String), the IO argument appears before the type, which is in keeping with the order outlined here.\nInput not being mutated.  In fill!(x, v), v is not being mutated and it comes after x.\nKey.  For associative collections, this is the key of the key-value pair(s).  For other indexed collections, this is the index.\nValue.  For associative collections, this is the value of the key-value pair(s).  In cases like fill!(x, v), this is v.\nEverything else.  Any other arguments.\nVarargs.  This refers to arguments that can be listed indefinitely at the end of a function call.  For example, in Matrix{T}(undef, dims), the dimensions can be given as a Tuple, e.g. Matrix{T}(undef, (1,2)), or as Varargs, e.g. Matrix{T}(undef, 1, 2).\nKeyword arguments. In Julia keyword arguments have to come last anyway in function definitions; they're listed here for the sake of completeness.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"The vast majority of functions will not take every kind of argument listed above; the numbers merely denote the precedence that should be used for any applicable arguments to a function.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"There are of course a few exceptions.  For example, in convert, the type should always come first.  In setindex!, the value comes before the indices so that the indices can be provided as varargs.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"When designing APIs, adhering to this general order as much as possible is likely to give users of your functions a more consistent experience.","category":"page"},{"location":"manual/style-guide.html#Don't-overuse-try-catch-1","page":"スタイルガイド","title":"Don't overuse try-catch","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"It is better to avoid errors than to rely on catching them.","category":"page"},{"location":"manual/style-guide.html#Don't-parenthesize-conditions-1","page":"スタイルガイド","title":"Don't parenthesize conditions","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Julia doesn't require parens around conditions in if and while. Write:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"if a == b","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"instead of:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"if (a == b)","category":"page"},{"location":"manual/style-guide.html#Don't-overuse-...-1","page":"スタイルガイド","title":"Don't overuse ...","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Splicing function arguments can be addictive. Instead of [a..., b...], use simply [a; b], which already concatenates arrays. collect(a) is better than [a...], but since a is already iterable it is often even better to leave it alone, and not convert it to an array.","category":"page"},{"location":"manual/style-guide.html#Don't-use-unnecessary-static-parameters-1","page":"スタイルガイド","title":"Don't use unnecessary static parameters","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"A function signature:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"foo(x::T) where {T<:Real} = ...","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"should be written as:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"foo(x::Real) = ...","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"instead, especially if T is not used in the function body. Even if T is used, it can be replaced with typeof(x) if convenient. There is no performance difference. Note that this is not a general caution against static parameters, just against uses where they are not needed.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Note also that container types, specifically may need type parameters in function calls. See the FAQ Avoid fields with abstract containers for more information.","category":"page"},{"location":"manual/style-guide.html#Avoid-confusion-about-whether-something-is-an-instance-or-a-type-1","page":"スタイルガイド","title":"Avoid confusion about whether something is an instance or a type","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Sets of definitions like the following are confusing:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"foo(::Type{MyType}) = ...\nfoo(::MyType) = foo(MyType)","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Decide whether the concept in question will be written as MyType or MyType(), and stick to it.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"The preferred style is to use instances by default, and only add methods involving Type{MyType} later if they become necessary to solve some problem.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive)  type, with the enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over making the enumeration an abstract type, with the \"values\" as subtypes.","category":"page"},{"location":"manual/style-guide.html#Don't-overuse-macros-1","page":"スタイルガイド","title":"Don't overuse macros","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Be aware of when a macro could really be a function instead.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Calling eval inside a macro is a particularly dangerous warning sign; it means the macro will only work when called at the top level. If such a macro is written as a function instead, it will naturally have access to the run-time values it needs.","category":"page"},{"location":"manual/style-guide.html#Don't-expose-unsafe-operations-at-the-interface-level-1","page":"スタイルガイド","title":"Don't expose unsafe operations at the interface level","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"If you have a type that uses a native pointer:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"mutable struct NativeType\n    p::Ptr{UInt8}\n    ...\nend","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"don't write definitions like the following:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"getindex(x::NativeType, i) = unsafe_load(x.p, i)","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"The problem is that users of this type can write x[i] without realizing that the operation is unsafe, and then be susceptible to memory bugs.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Such a function should either check the operation to ensure it is safe, or have unsafe somewhere in its name to alert callers.","category":"page"},{"location":"manual/style-guide.html#Don't-overload-methods-of-base-container-types-1","page":"スタイルガイド","title":"Don't overload methods of base container types","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"It is possible to write definitions like the following:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"show(io::IO, v::Vector{MyType}) = ...","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"This would provide custom showing of vectors with a specific new element type. While tempting, this should be avoided. The trouble is that users will expect a well-known type like Vector() to behave in a certain way, and overly customizing its behavior can make it harder to work with.","category":"page"},{"location":"manual/style-guide.html#Avoid-type-piracy-1","page":"スタイルガイド","title":"Avoid type piracy","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"\"Type piracy\" refers to the practice of extending or redefining methods in Base or other packages on types that you have not defined. In some cases, you can get away with type piracy with little ill effect. In extreme cases, however, you can even crash Julia (e.g. if your method extension or redefinition causes invalid input to be passed to a ccall). Type piracy can complicate reasoning about code, and may introduce incompatibilities that are hard to predict and diagnose.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"As an example, suppose you wanted to define multiplication on symbols in a module:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"module A\nimport Base.*\n*(x::Symbol, y::Symbol) = Symbol(x,y)\nend","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"The problem is that now any other module that uses Base.* will also see this definition.  Since Symbol is defined in Base and is used by other modules, this can change the behavior of unrelated code unexpectedly. There are several alternatives here, including using a different function name, or wrapping the Symbols in another type that you define.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Sometimes, coupled packages may engage in type piracy to separate features from definitions, especially when the packages were designed by collaborating authors, and when the definitions are reusable. For example, one package might provide some types useful for working with colors; another package could define methods for those types that enable conversions between color spaces. Another example might be a package that acts as a thin wrapper for some C code, which another package might then pirate to implement a higher-level, Julia-friendly API.","category":"page"},{"location":"manual/style-guide.html#Be-careful-with-type-equality-1","page":"スタイルガイド","title":"Be careful with type equality","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"You generally want to use isa and <: for testing types, not ==. Checking types for exact equality typically only makes sense when comparing to a known concrete type (e.g. T == Float64), or if you really, really know what you're doing.","category":"page"},{"location":"manual/style-guide.html#Do-not-write-x-f(x)-1","page":"スタイルガイド","title":"Do not write x->f(x)","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Since higher-order functions are often called with anonymous functions, it is easy to conclude that this is desirable or even necessary. But any function can be passed directly, without being \"wrapped\" in an anonymous function. Instead of writing map(x->f(x), a), write map(f, a).","category":"page"},{"location":"manual/style-guide.html#Avoid-using-floats-for-numeric-literals-in-generic-code-when-possible-1","page":"スタイルガイド","title":"Avoid using floats for numeric literals in generic code when possible","text":"","category":"section"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible through promotion.","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"For example,","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"julia> f(x) = 2.0 * x\nf (generic function with 1 method)\n\njulia> f(1//2)\n1.0\n\njulia> f(1/2)\n1.0\n\njulia> f(1)\n2.0","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"while","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"julia> g(x) = 2 * x\ng (generic function with 1 method)\n\njulia> g(1//2)\n1//1\n\njulia> g(1/2)\n1.0\n\njulia> g(1)\n2","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"As you can see, the second version, where we used an Int literal, preserved the type of the input argument, while the first didn't. This is because e.g. promote_type(Int, Float64) == Float64, and promotion happens with the multiplication. Similarly, Rational literals are less type disruptive than Float64 literals, but more disruptive than Ints:","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"julia> h(x) = 2//1 * x\nh (generic function with 1 method)\n\njulia> h(1//2)\n1//1\n\njulia> h(1/2)\n1.0\n\njulia> h(1)\n2//1","category":"page"},{"location":"manual/style-guide.html#","page":"スタイルガイド","title":"スタイルガイド","text":"Thus, use Int literals when possible, with Rational{Int} for literal non-integer numbers, in order to make it easier to use your code.","category":"page"},{"location":"manual/faq.html#Frequently-Asked-Questions-1","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"manual/faq.html#Sessions-and-the-REPL-1","page":"Frequently Asked Questions","title":"Sessions and the REPL","text":"","category":"section"},{"location":"manual/faq.html#How-do-I-delete-an-object-in-memory?-1","page":"Frequently Asked Questions","title":"How do I delete an object in memory?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Julia does not have an analog of MATLAB's clear function; once a name is defined in a Julia session (technically, in module Main), it is always present.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"If memory usage is your concern, you can always replace objects with ones that consume less memory.  For example, if A is a gigabyte-sized array that you no longer need, you can free the memory with A = nothing.  The memory will be released the next time the garbage collector runs; you can force this to happen with gc(). Moreover, an attempt to use A will likely result in an error, because most methods are not defined on type Nothing.","category":"page"},{"location":"manual/faq.html#How-can-I-modify-the-declaration-of-a-type-in-my-session?-1","page":"Frequently Asked Questions","title":"How can I modify the declaration of a type in my session?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Perhaps you've defined a type and then realize you need to add a new field. If you try this at the REPL, you get the error:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"ERROR: invalid redefinition of constant MyType","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Types in module Main cannot be redefined.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"While this can be inconvenient when you are developing new code, there's an excellent workaround.  Modules can be replaced by redefining them, and so if you wrap all your new code inside a module you can redefine types and constants.  You can't import the type names into Main and then expect to be able to redefine them there, but you can use the module name to resolve the scope.  In other words, while developing you might use a workflow something like this:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"include(\"mynewcode.jl\")              # this defines a module MyModule\nobj1 = MyModule.ObjConstructor(a, b)\nobj2 = MyModule.somefunction(obj1)\n# Got an error. Change something in \"mynewcode.jl\"\ninclude(\"mynewcode.jl\")              # reload the module\nobj1 = MyModule.ObjConstructor(a, b) # old objects are no longer valid, must reconstruct\nobj2 = MyModule.somefunction(obj1)   # this time it worked!\nobj3 = MyModule.someotherfunction(obj2, c)\n...","category":"page"},{"location":"manual/faq.html#man-scripting-1","page":"Frequently Asked Questions","title":"スクリプトの作成","text":"","category":"section"},{"location":"manual/faq.html#How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?-1","page":"Frequently Asked Questions","title":"How do I check if the current file is being run as the main script?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"When a file is run as the main script using julia file.jl one might want to activate extra functionality like command line argument handling. A way to determine that a file is run in this fashion is to check if abspath(PROGRAM_FILE) == @__FILE__ is true.","category":"page"},{"location":"manual/faq.html#How-do-I-catch-CTRL-C-in-a-script?-1","page":"Frequently Asked Questions","title":"How do I catch CTRL-C in a script?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Running a Julia script using julia file.jl does not throw InterruptException when you try to terminate it with CTRL-C (SIGINT).  To run a certain code before terminating a Julia script, which may or may not be caused by CTRL-C, use atexit.  Alternatively, you can use julia -e 'include(popfirst!(ARGS))' file.jl to execute a script while being able to catch InterruptException in the try block.","category":"page"},{"location":"manual/faq.html#How-do-I-pass-options-to-julia-using-#!/usr/bin/env?-1","page":"Frequently Asked Questions","title":"How do I pass options to julia using #!/usr/bin/env?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Passing options to julia in so-called shebang by, e.g., #!/usr/bin/env julia --startup-file=no may not work in some platforms such as Linux.  This is because argument parsing in shebang is platform-dependent and not well-specified.  In a Unix-like environment, a reliable way to pass options to julia in an executable script would be to start the script as a bash script and use exec to replace the process to julia:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"#!/bin/bash\n#=\nexec julia --color=yes --startup-file=no -e 'include(popfirst!(ARGS))' \\\n    \"${BASH_SOURCE[0]}\" \"$@\"\n=#\n\n@show ARGS  # put any Julia code here","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In the example above, the code between #= and =# is run as a bash script.  Julia ignores this part since it is a multi-line comment for Julia.  The Julia code after =# is ignored by bash since it stops parsing the file once it reaches to the exec statement.","category":"page"},{"location":"manual/faq.html#Functions-1","page":"Frequently Asked Questions","title":"関数","text":"","category":"section"},{"location":"manual/faq.html#I-passed-an-argument-x-to-a-function,-modified-it-inside-that-function,-but-on-the-outside,-the-variable-x-is-still-unchanged.-Why?-1","page":"Frequently Asked Questions","title":"I passed an argument x to a function, modified it inside that function, but on the outside, the variable x is still unchanged. Why?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Suppose you call a function like this:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> x = 10\n10\n\njulia> function change_value!(y)\n           y = 17\n       end\nchange_value! (generic function with 1 method)\n\njulia> change_value!(x)\n17\n\njulia> x # x is unchanged!\n10","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In Julia, the binding of a variable x cannot be changed by passing x as an argument to a function.  When calling change_value!(x) in the above example, y is a newly created variable, bound initially to the value of x, i.e. 10; then y is rebound to the constant 17, while the variable x of the outer scope is left untouched.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"But here is a thing you should pay attention to: suppose x is bound to an object of type Array (or any other mutable type). From within the function, you cannot \"unbind\" x from this Array, but you can change its content. For example:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> x = [1,2,3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> function change_array!(A)\n           A[1] = 5\n       end\nchange_array! (generic function with 1 method)\n\njulia> change_array!(x)\n5\n\njulia> x\n3-element Array{Int64,1}:\n 5\n 2\n 3","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Here we created a function change_array!, that assigns 5 to the first element of the passed array (bound to x at the call site, and bound to A within the function). Notice that, after the function call, x is still bound to the same array, but the content of that array changed: the variables A and x were distinct bindings referring to the same mutable Array object.","category":"page"},{"location":"manual/faq.html#Can-I-use-using-or-import-inside-a-function?-1","page":"Frequently Asked Questions","title":"Can I use using or import inside a function?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"No, you are not allowed to have a using or import statement inside a function.  If you want to import a module but only use its symbols inside a specific function or set of functions, you have two options:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Use import:\nimport Foo\nfunction bar(...)\n    # ... refer to Foo symbols via Foo.baz ...\nend\nThis loads the module Foo and defines a variable Foo that refers to the module, but does not import any of the other symbols from the module into the current namespace.  You refer to the Foo symbols by their qualified names Foo.bar etc.\nWrap your function in a module:\nmodule Bar\nexport bar\nusing Foo\nfunction bar(...)\n    # ... refer to Foo.baz as simply baz ....\nend\nend\nusing Bar\nThis imports all the symbols from Foo, but only inside the module Bar.","category":"page"},{"location":"manual/faq.html#What-does-the-...-operator-do?-1","page":"Frequently Asked Questions","title":"What does the ... operator do?","text":"","category":"section"},{"location":"manual/faq.html#The-two-uses-of-the-...-operator:-slurping-and-splatting-1","page":"Frequently Asked Questions","title":"The two uses of the ... operator: slurping and splatting","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Many newcomers to Julia find the use of ... operator confusing. Part of what makes the ... operator confusing is that it means two different things depending on context.","category":"page"},{"location":"manual/faq.html#...-combines-many-arguments-into-one-argument-in-function-definitions-1","page":"Frequently Asked Questions","title":"... combines many arguments into one argument in function definitions","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In the context of function definitions, the ... operator is used to combine many different arguments into a single argument. This use of ... for combining many different arguments into a single argument is called slurping:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> function printargs(args...)\n           println(typeof(args))\n           for (i, arg) in enumerate(args)\n               println(\"Arg #$i = $arg\")\n           end\n       end\nprintargs (generic function with 1 method)\n\njulia> printargs(1, 2, 3)\nTuple{Int64,Int64,Int64}\nArg #1 = 1\nArg #2 = 2\nArg #3 = 3","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as <-... instead of ....","category":"page"},{"location":"manual/faq.html#...-splits-one-argument-into-many-different-arguments-in-function-calls-1","page":"Frequently Asked Questions","title":"... splits one argument into many different arguments in function calls","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In contrast to the use of the ... operator to denote slurping many different arguments into one argument when defining a function, the ... operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of ... is called splatting:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> function threeargs(a, b, c)\n           println(\"a = $a::$(typeof(a))\")\n           println(\"b = $b::$(typeof(b))\")\n           println(\"c = $c::$(typeof(c))\")\n       end\nthreeargs (generic function with 1 method)\n\njulia> x = [1, 2, 3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> threeargs(x...)\na = 1::Int64\nb = 2::Int64\nc = 3::Int64","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as ...-> instead of ....","category":"page"},{"location":"manual/faq.html#What-is-the-return-value-of-an-assignment?-1","page":"Frequently Asked Questions","title":"What is the return value of an assignment?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The operator = always returns the right-hand side, therefore:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> function threeint()\n           x::Int = 3.0\n           x # returns variable x\n       end\nthreeint (generic function with 1 method)\n\njulia> function threefloat()\n           x::Int = 3.0 # returns 3.0\n       end\nthreefloat (generic function with 1 method)\n\njulia> threeint()\n3\n\njulia> threefloat()\n3.0","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"and similarly:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> function threetup()\n           x, y = [3, 3]\n           x, y # returns a tuple\n       end\nthreetup (generic function with 1 method)\n\njulia> function threearr()\n           x, y = [3, 3] # returns an array\n       end\nthreearr (generic function with 1 method)\n\njulia> threetup()\n(3, 3)\n\njulia> threearr()\n2-element Array{Int64,1}:\n 3\n 3","category":"page"},{"location":"manual/faq.html#Types,-type-declarations,-and-constructors-1","page":"Frequently Asked Questions","title":"Types, type declarations, and constructors","text":"","category":"section"},{"location":"manual/faq.html#man-type-stability-1","page":"Frequently Asked Questions","title":"What does \"type-stable\" mean?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"It means that the type of the output is predictable from the types of the inputs.  In particular, it means that the type of the output cannot vary depending on the values of the inputs. The following code is not type-stable:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> function unstable(flag::Bool)\n           if flag\n               return 1\n           else\n               return 1.0\n           end\n       end\nunstable (generic function with 1 method)","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"It returns either an Int or a Float64 depending on the value of its argument.  Since Julia can't predict the return type of this function at compile-time, any computation that uses it will have to guard against both types possibly occurring, making generation of fast machine code difficult.","category":"page"},{"location":"manual/faq.html#faq-domain-errors-1","page":"Frequently Asked Questions","title":"Why does Julia give a DomainError for certain seemingly-sensible operations?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Certain operations make mathematical sense but result in errors:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> sqrt(-2.0)\nERROR: DomainError with -2.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This behavior is an inconvenient consequence of the requirement for type-stability.  In the case of sqrt, most users want sqrt(2.0) to give a real number, and would be unhappy if it produced the complex number 1.4142135623730951 + 0.0im.  One could write the sqrt function to switch to a complex-valued output only when passed a negative number (which is what sqrt does in some other languages), but then the result would not be type-stable  and the sqrt function would have poor performance.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In these and other cases, you can get the result you want by choosing an input type that conveys your willingness to accept an output type in which the result can be represented:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> sqrt(-2.0+0im)\n0.0 + 1.4142135623730951im","category":"page"},{"location":"manual/faq.html#Why-does-Julia-use-native-machine-integer-arithmetic?-1","page":"Frequently Asked Questions","title":"Why does Julia use native machine integer arithmetic?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Julia uses machine arithmetic for integer computations. This means that the range of Int values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> typemax(Int)\n9223372036854775807\n\njulia> ans+1\n-9223372036854775808\n\njulia> -ans\n-9223372036854775808\n\njulia> 2*ans\n0","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"One alternative to consider would be to check each integer operation for overflow and promote results to bigger integer types such as Int128 or BigInt in the case of overflow. Unfortunately, this introduces major overhead on every integer operation (think incrementing a loop counter) – it requires emitting code to perform run-time overflow checks after arithmetic instructions and branches to handle potential overflows. Worse still, this would cause every computation involving integers to be type-unstable. As we mentioned above, type-stability is crucial  for effective generation of efficient code. If you can't count on the results of integer operations being integers, it's impossible to generate fast, simple code the way C and Fortran compilers do.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"A variation on this approach, which avoids the appearance of type instability is to merge the Int and BigInt types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach can be made to work and can even be made quite fast in many cases, but has several drawbacks.  One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers.  Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots – large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps – situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab™ does:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":">> int64(9223372036854775807)\n\nans =\n\n  9223372036854775807\n\n>> int64(9223372036854775807) + 1\n\nans =\n\n  9223372036854775807\n\n>> int64(-9223372036854775808)\n\nans =\n\n -9223372036854775808\n\n>> int64(-9223372036854775808) - 1\n\nans =\n\n -9223372036854775808","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic.  The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with typemin(Int) or typemax(Int) as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse – saturating integer arithmetic isn't associative. Consider this Matlab computation:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":">> n = int64(2)^62\n4611686018427387904\n\n>> n + (n - 1)\n9223372036854775807\n\n>> (n + n) - 1\n9223372036854775806","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow is associative. Consider finding the midpoint between integer values lo and hi in Julia using the expression (lo + hi) >>> 1:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> n = 2^62\n4611686018427387904\n\njulia> (n + 2n) >>> 1\n6917529027641081856","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"See? No problem. That's the correct midpoint between 2^62 and 2^63, despite the fact that n + 2n is -4611686018427387904. Now try it in Matlab:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":">> (n + 2*n)/2\n\nans =\n\n  4611686018427387904","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Oops. Adding a >>> operator to Matlab wouldn't help, because saturation that occurs when adding n and 2n has already destroyed the information necessary to compute the correct midpoint.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Not only is lack of associativity unfortunate for programmers who cannot rely it for techniques like this, but it also defeats almost anything compilers might want to do to optimize integer arithmetic. For example, since Julia integers use normal machine integer arithmetic, LLVM is free to aggressively optimize simple little functions like f(k) = 5k-1. The machine code for this function is just this:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> code_native(f, Tuple{Int})\n  .text\nFilename: none\n  pushq %rbp\n  movq  %rsp, %rbp\nSource line: 1\n  leaq  -1(%rdi,%rdi,4), %rax\n  popq  %rbp\n  retq\n  nopl  (%rax,%rax)","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The actual body of the function is a single leaq instruction, which computes the integer multiply and add at once. This is even more beneficial when f gets inlined into another function:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> function g(k, n)\n           for i = 1:n\n               k = f(k)\n           end\n           return k\n       end\ng (generic function with 1 methods)\n\njulia> code_native(g, Tuple{Int,Int})\n  .text\nFilename: none\n  pushq %rbp\n  movq  %rsp, %rbp\nSource line: 2\n  testq %rsi, %rsi\n  jle L26\n  nopl  (%rax)\nSource line: 3\nL16:\n  leaq  -1(%rdi,%rdi,4), %rdi\nSource line: 2\n  decq  %rsi\n  jne L16\nSource line: 5\nL26:\n  movq  %rdi, %rax\n  popq  %rbp\n  retq\n  nop","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Since the call to f gets inlined, the loop body ends up being just a single leaq instruction.  Next, consider what happens if we make the number of loop iterations fixed:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> function g(k)\n           for i = 1:10\n               k = f(k)\n           end\n           return k\n       end\ng (generic function with 2 methods)\n\njulia> code_native(g,(Int,))\n  .text\nFilename: none\n  pushq %rbp\n  movq  %rsp, %rbp\nSource line: 3\n  imulq $9765625, %rdi, %rax    # imm = 0x9502F9\n  addq  $-2441406, %rax         # imm = 0xFFDABF42\nSource line: 5\n  popq  %rbp\n  retq\n  nopw  %cs:(%rax,%rax)","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition – neither of which is true of saturating arithmetic – it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this blog post, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.","category":"page"},{"location":"manual/faq.html#What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?-1","page":"Frequently Asked Questions","title":"What are the possible causes of an UndefVarError during remote execution?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"As the error states, an immediate cause of an UndefVarError on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> module Foo\n           foo() = remotecall_fetch(x->x, 2, \"Hello\")\n       end\n\njulia> Foo.foo()\nERROR: On worker 2:\nUndefVarError: Foo not defined\nStacktrace:\n[...]","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The closure x->x carries a reference to Foo, and since Foo is unavailable on node 2, an UndefVarError is thrown.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Globals under modules other than Main are not serialized by value to the remote node. Only a reference is sent.  Functions which create global bindings (except under Main) may cause an UndefVarError to be thrown later.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> @everywhere module Foo\n           function foo()\n               global gvar = \"Hello\"\n               remotecall_fetch(()->gvar, 2)\n           end\n       end\n\njulia> Foo.foo()\nERROR: On worker 2:\nUndefVarError: gvar not defined\nStacktrace:\n[...]","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In the above example, @everywhere module Foo defined Foo on all nodes. However the call to Foo.foo() created a new global binding gvar on the local node, but this was not found on node 2 resulting in an UndefVarError error.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Note that this does not apply to globals created under module Main. Globals under module Main are serialized and new bindings created under Main on the remote node.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> gvar_self = \"Node1\"\n\"Node1\"\n\njulia> remotecall_fetch(()->gvar_self, 2)\n\"Node1\"\n\njulia> remotecall_fetch(varinfo, 2)\nname          size summary\n––––––––– –––––––– –––––––\nBase               Module\nCore               Module\nMain               Module\ngvar_self 13 bytes String","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This does not apply to function or struct declarations. However, anonymous functions bound to global variables are serialized as can be seen below.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> bar() = 1\nbar (generic function with 1 method)\n\njulia> remotecall_fetch(bar, 2)\nERROR: On worker 2:\nUndefVarError: #bar not defined\n[...]\n\njulia> anon_bar  = ()->1\n(::#21) (generic function with 1 method)\n\njulia> remotecall_fetch(anon_bar, 2)\n1","category":"page"},{"location":"manual/faq.html#Why-does-Julia-use-*-for-string-concatenation?-Why-not-or-something-else?-1","page":"Frequently Asked Questions","title":"Why does Julia use * for string concatenation? Why not + or something else?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The main argument against + is that string concatenation is not commutative, while + is generally used as a commutative operator. While the Julia community recognizes that other languages use different operators and * may be unfamiliar for some users, it communicates certain algebraic properties.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Note that you can also use string(...) to concatenate strings (and other values converted to strings); similarly, repeat can be used instead of ^ to repeat strings. The interpolation syntax is also useful for constructing strings.","category":"page"},{"location":"manual/faq.html#パッケージとモジュール-1","page":"Frequently Asked Questions","title":"パッケージとモジュール","text":"","category":"section"},{"location":"manual/faq.html#usingとimport-の違いは何ですか?-1","page":"Frequently Asked Questions","title":"usingとimport の違いは何ですか?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"違いは1つしかありませんが、表面的に(構文的に)はその違いはごく些細なものに見えるかもしれません。using と import の違いは、using ではモジュール Foo の関数 barを 新しいメソッドで拡張するときには、function Foo.bar(..と書く必要があります。import Foo.barを使ったときにはfunction bar(... と書くだけでモジュール Foo の関数 barが自動的に拡張されます。","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"こうやって別々の構文を与えられるほどに重要な理由は、存在を知らなった関数を誤って拡張してしまうとそれがバグの温床となってしまうので、そういったことを避けたい、ということです。これは、文字列や整数のような共通の型を受け取るメソッドで発生する可能性が最も高いです。import を使用する場合は、他のモジュールの bar(s:AbstractString) の実装を新しい実装に置き換えることになります。その実装は いとも簡単に置き換え前と全く異なる振る舞いをさせることができます(が、そうすることによって、関数 bar の呼び出しに依存しているモジュール Fooで定義された別の関数群を将来的に使う際に大いに問題になるでしょう)","category":"page"},{"location":"manual/faq.html#Nothingness-and-missing-values-1","page":"Frequently Asked Questions","title":"Nothingness and missing values","text":"","category":"section"},{"location":"manual/faq.html#faq-nothing-1","page":"Frequently Asked Questions","title":"How does \"null\", \"nothingness\" or \"missingness\" work in Julia?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Unlike many languages (for example, C and Java), Julia objects cannot be \"null\" by default.  When a reference (variable, object field, or array element) is uninitialized, accessing it will immediately throw an error. This situation can be detected using the isdefined or isassigned functions.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Some functions are used only for their side effects, and do not need to return a value. In these cases, the convention is to return the value nothing, which is just a singleton object of type Nothing. This is an ordinary type with no fields; there is nothing special about it except for this convention, and that the REPL does not print anything for it. Some language constructs that would not otherwise have a value also yield nothing, for example if false; end.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"For situations where a value x of type T exists only sometimes, the Union{T, Nothing} type can be used for function arguments, object fields and array element types as the equivalent of Nullable, Option or Maybe  in other languages. If the value itself can be nothing (notably, when T is Any), the Union{Some{T}, Nothing} type is more appropriate since x == nothing then indicates the absence of a value, and x == Some(nothing) indicates the presence of a value equal to nothing. The something function allows unwrapping Some objects and using a default value instead of nothing arguments. Note that the compiler is able to generate efficient code when working with Union{T, Nothing} arguments or fields.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"To represent missing data in the statistical sense (NA in R or NULL in SQL), use the missing object. See the Missing Values section for more details.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The empty tuple (()) is another form of nothingness. But, it should not really be thought of as nothing but rather a tuple of zero values.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The empty (or \"bottom\") type, written as Union{} (an empty union type), is a type with no values and no subtypes (except itself). You will generally not need to use this type.","category":"page"},{"location":"manual/faq.html#Memory-1","page":"Frequently Asked Questions","title":"Memory","text":"","category":"section"},{"location":"manual/faq.html#Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?-1","page":"Frequently Asked Questions","title":"Why does x += y allocate memory when x and y are arrays?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In Julia, x += y gets replaced during parsing by x = x + y. For arrays, this has the consequence that, rather than storing the result in the same location in memory as x, it allocates a new array to store the result.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"While this behavior might surprise some, the choice is deliberate. The main reason is the presence of immutable objects within Julia, which cannot change their value once created.  Indeed, a number is an immutable object; the statements x = 5; x += 1 do not modify the meaning of 5, they modify the value bound to x. For an immutable, the only way to change the value is to reassign it.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"To amplify a bit further, consider the following function:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"function power_by_squaring(x, n::Int)\n    ispow2(n) || error(\"This implementation only works for powers of 2\")\n    while n >= 2\n        x *= x\n        n >>= 1\n    end\n    x\nend","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"After a call like x = 5; y = power_by_squaring(x, 4), you would get the expected result: x == 5 && y == 625.  However, now suppose that *=, when used with matrices, instead mutated the left hand side.  There would be two problems:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"For general square matrices, A = A*B cannot be implemented without temporary storage: A[1,1] gets computed and stored on the left hand side before you're done using it on the right hand side.\nSuppose you were willing to allocate a temporary for the computation (which would eliminate most of the point of making *= work in-place); if you took advantage of the mutability of x, then this function would behave differently for mutable vs. immutable inputs. In particular, for immutable x, after the call you'd have (in general) y != x, but for mutable x you'd have y == x.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like += and *= work by rebinding new values.","category":"page"},{"location":"manual/faq.html#faq-async-io-1","page":"Frequently Asked Questions","title":"Asynchronous IO and concurrent synchronous writes","text":"","category":"section"},{"location":"manual/faq.html#Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?-1","page":"Frequently Asked Questions","title":"Why do concurrent writes to the same stream result in inter-mixed output?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"While the streaming I/O API is synchronous, the underlying implementation is fully asynchronous.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Consider the printed output from the following:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> @sync for i in 1:3\n           @async write(stdout, string(i), \" Foo \", \" Bar \")\n       end\n123 Foo  Foo  Foo  Bar  Bar  Bar","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This is happening because, while the write call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"print and println \"lock\" the stream during a call. Consequently changing write to println in the above example results in:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> @sync for i in 1:3\n           @async println(stdout, string(i), \" Foo \", \" Bar \")\n       end\n1 Foo  Bar\n2 Foo  Bar\n3 Foo  Bar","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can lock your writes with a ReentrantLock like this:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> l = ReentrantLock();\n\njulia> @sync for i in 1:3\n           @async begin\n               lock(l)\n               try\n                   write(stdout, string(i), \" Foo \", \" Bar \")\n               finally\n                   unlock(l)\n               end\n           end\n       end\n1 Foo  Bar 2 Foo  Bar 3 Foo  Bar","category":"page"},{"location":"manual/faq.html#Arrays-1","page":"Frequently Asked Questions","title":"Arrays","text":"","category":"section"},{"location":"manual/faq.html#What-are-the-differences-between-zero-dimensional-arrays-and-scalars?-1","page":"Frequently Asked Questions","title":"What are the differences between zero-dimensional arrays and scalars?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Zero-dimensional arrays are arrays of the form Array{T,0}. They behave similar to scalars, but there are important differences. They deserve a special mention because they are a special case which makes logical sense given the generic definition of arrays, but might be a bit unintuitive at first. The following line defines a zero-dimensional array:","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> A = zeros()\n0-dimensional Array{Float64,0}:\n0.0","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In this example, A is a mutable container that contains one element, which can be set by A[] = 1.0 and retrieved with A[]. All zero-dimensional arrays have the same size (size(A) == ()), and length (length(A) == 1). In particular, zero-dimensional arrays are not empty. If you find this unintuitive, here are some ideas that might help to understand Julia's definition.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Zero-dimensional arrays are the \"point\" to vector's \"line\" and matrix's \"plane\". Just as a line has no area (but still represents a set of things), a point has no length or any dimensions at all (but still represents a thing).\nWe define prod(()) to be 1, and the total number of elements in an array is the product of the size. The size of a zero-dimensional array is (), and therefore its length is 1.\nZero-dimensional arrays don't natively have any dimensions into which you index – they’re just A[]. We can apply the same \"trailing one\" rule for them as for all other array dimensionalities, so you can indeed index them as A[1], A[1,1], etc.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even though they are iterable and define things like length, getindex, e.g. 1[] == 1). In particular, if x = 0.0 is defined as a scalar, it is an error to attempt to change its value via x[] = 1.0. A scalar x can be converted into a zero-dimensional array containing it via fill(x), and conversely, a zero-dimensional array a can be converted to the contained scalar via a[]. Another difference is that a scalar can participate in linear algebra operations such as 2 * rand(2,2), but the analogous operation with a zero-dimensional array fill(2) * rand(2,2) is an error.","category":"page"},{"location":"manual/faq.html#Why-are-my-Julia-benchmarks-for-linear-algebra-operations-different-from-other-languages?-1","page":"Frequently Asked Questions","title":"Why are my Julia benchmarks for linear algebra operations different from other languages?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You may find that simple benchmarks of linear algebra building blocks like","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using BenchmarkTools\nA = randn(1000, 1000)\nB = randn(1000, 1000)\n@btime $A \\ $B\n@btime $A * $B","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"can be different when compared to other languages like Matlab or R.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Since operations like this are very thin wrappers over the relevant BLAS functions, the reason for the discrepancy is very likely to be","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"the BLAS library each language is using,\nthe number of concurrent threads.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Julia compiles and uses its own copy of OpenBLAS, with threads currently capped at 8 (or the number of your cores).","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Modifying OpenBLAS settings or compiling Julia with a different BLAS library, eg Intel MKL, may provide performance improvements. You can use MKL.jl, a package that makes Julia's linear algebra use Intel MKL BLAS and LAPACK instead of OpenBLAS, or search the discussion forum for suggestions on how to set this up manually. Note that Intel MKL cannot be bundled with Julia, as it is not open source.","category":"page"},{"location":"manual/faq.html#Julia-Releases-1","page":"Frequently Asked Questions","title":"Julia Releases","text":"","category":"section"},{"location":"manual/faq.html#Do-I-want-to-use-a-release,-beta,-or-nightly-version-of-Julia?-1","page":"Frequently Asked Questions","title":"Do I want to use a release, beta, or nightly version of Julia?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You may prefer the release version of Julia if you are looking for a stable code base. Releases generally occur every 6 months, giving you a stable platform for writing code.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You may prefer the beta version of Julia if you don't mind being slightly behind the latest bugfixes and changes, but find the slightly faster rate of changes more appealing. Additionally, these binaries are tested before they are published to ensure they are fully functional.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language, and don't mind if the version available today occasionally doesn't actually work.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning. If this describes you, you may also be interested in reading our guidelines for contributing.","category":"page"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Links to each of these download types can be found on the download page at https://julialang.org/downloads/.  Note that not all versions of Julia are available for all platforms.","category":"page"},{"location":"manual/faq.html#When-are-deprecated-functions-removed?-1","page":"Frequently Asked Questions","title":"When are deprecated functions removed?","text":"","category":"section"},{"location":"manual/faq.html#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Deprecated functions are removed after the subsequent release. For example, functions marked as deprecated in the 0.1 release will not be available starting with the 0.2 release.","category":"page"},{"location":"manual/noteworthy-differences.html#他の言語との注目すべき違い-1","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"","category":"section"},{"location":"manual/noteworthy-differences.html#MATLAB-との注目すべき違い-1","page":"他の言語との注目すべき違い","title":"MATLAB との注目すべき違い","text":"","category":"section"},{"location":"manual/noteworthy-differences.html#","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"MATLAB ユーザーはジュリアの構文を親しみやすいと思うかもしれませんが、Juliaは MATLAB クローンではありません。構文や機能の違いは大きいです。MATLAB に慣れているJuliaユーザーがつまずきやすい注目すべき違いは次のとおりです:","category":"page"},{"location":"manual/noteworthy-differences.html#","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"Julia の配列は角かっこで A[i,j]のようにインデックス付けされる。\nJuliaでは、配列は他の変数に代入してもコピーされません。 A = Bの後、Bの要素を変更すると Aも同様に変更されます。\nJuliaでは、値は関数に渡されてもコピーされません。関数が配列を変更すると、その変更は呼び出し元にも影響を与えます。\nJuliaでは、代入文の中で配列のサイズが自動的に拡張されません。 MATLABでは a(4)= 3.2でa = [0 0 0 3.2]が生成され、その後a(5)= 7とするとa = [0 0 0 3.2 7]と配列のサイズが大きくなります。対して、Juliaで a [5] = 7とすると、aの長さが5より場合、もしくは、この代入式が識別子aを初めて使用する式である場合には、エラーが発生します。Juliaには、push!関数やappend!関数があり、ベクトルのサイズを拡張する手段として、MATLABの a(end + 1)= valよりもはるかに効率的です。\n虚数単位 sqrt(-1)は、MATLABではiやjが用いられますが、Juliaではimと表記します。\nJuliaでは、小数点のない数値リテラル( 42など)は浮動小数点ではなく整数を作成します。任意の大きな整数リテラルがサポートされています。その結果、一部の演算では 例えば julia> a = -1; 2^a のように 浮動小数点を想定している場合、「演算結果が整数ではない」というドメインエラーが発生します(詳細については、ドメインエラーに関するFAQを参照)。\nJuliaでは、複数の値が返され、タプルとして割り当てられます。例えば (a,b) = (1,2) や a, b = 1, 2 という具合です。MATLABの nargoutは、呼び出し側から期待される戻り値の数に基づいて選択的な処理をを行うもので、MATLABではよく使用されますが、Julia では使用できません。代わりに、ユーザーはオプション引数、キーワード引数の機能を使って、似たようなことをできます。\nJuliaは真の1次元配列を持っています。列ベクトルは、サイズがNで、Nx1ではありません。例えば、rand(N)は1次元配列を作成します。\nJuliaでは、 [x、y、z]は常に x、y、 zを含む3要素の配列を構築します。\n最初の( \"垂直方向の\")次元で連結するには、vcat(x, y, z)を使うか、配列の要素をセミコロンで分割します( [x; y; z])。\n2番目の( \"水平方向の\")次元で連結するには、hcat(x, y, z)を使うか、配列の要素をスペースで分割します( [x y z])。\nブロック行列を構築する(最初の2つの次元で連結する)には、hvcatを使うか、スペースとセミコロンを組み合わせます( [a b; c d])。\nJuliaでは、 a：bとa：b：cは AbstractRangeオブジェクトを構成します。 MATLABのように完全なベクトルを作成するには、collect(a:b)を使用してください。しかし、一般的には collectを呼び出す必要はありません。 AbstractRangeオブジェクトはほとんどのケースで通常の配列のように振る舞いますが、その値を遅延計算するためより効率的です。完全な配列ではなく特殊化されたオブジェクトを作成するというこのパターンはよく使用されていて、rangeのような関数や、enumerateや、zip のようなイテレータでも見られます。特殊オブジェクトは、通常の配列のように使用することができます。\nJuliaの関数は、最後の式または returnキーワードから戻り値を返します。MATLABのように、関数定義で戻り値の名前を列挙するのではありません。(詳細はreturnキーワードを参照)。\nJuliaスクリプトには関数をいくつでも含めることができ、ファイルがロードされれば、すべての関数定義は外部から見えます。現在の作業ディレクトリの外にあるファイルからも関数定義はロードすることができます。\nJuliaでは、sum、prod、maxのような簡約処理は、sum(A)のように単一の引数で呼び出された場合、全ての要素に対して行われます。たとえ Aが2次元以上だったとしても、です。\nJuliaでは、rand()のように、ゼロ引数で関数を呼び出すには括弧を使用する必要があります。\nJuliaは、文を終了するのにセミコロンを使用することを推奨していません。（対話式プロンプトでの実行を除き）式の結果が自動出力されませんので（出力を抑制したいのだとしても)コードの行末にセミコロンを使う必要はありません。printlnまたは@printfを使ってプリント出力することができます。\nJuliaでは、 AとBが配列の場合、 A == Bのような論理比較演算は真偽値の配列を返しません。(要素ごとの比較結果が欲しい場合には) 代わりにA.== Bを使用してください。<や>。のような他のブール演算子についても同様です。\nJuliaでは、演算子&、|、および⊻(xor)で、それぞれMATLABにおける and、or、および xorと等価なビット演算が行われます。演算の優先度は、Pythonのビット演算子に似ています(Cとは異なります)。それらはスカラーまたは要素ごとに操作でき、論理配列と組み合わせることもできますが、操作の順序の違いに注意してください: 括弧が必要な場合があります(例えば、1または2に等しい Aの要素を選択するには、(A。== 1)|(A。== 2)を使用します)。\nJuliaでは、接合演算子... を使ってxs = [1,2]; f(xs...)のようにして、コレクションの要素を引数として関数に渡すことができます。","category":"page"},{"location":"manual/noteworthy-differences.html#","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"  * Juliaのsvdは特異値を密な対角行列ではなくベクトルとして返します。   * Juliaでは、 ...はコード行を継続するためには使用されません。代わりに、不完全な式は自動的に、次の行へと解釈が継続します。","category":"page"},{"location":"manual/noteworthy-differences.html#","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"JuliaとMATLABの両方で、対話式セッションでは、変数 ansは最後に発行された式の値に設定されますが、 Juliaでは、MATLABと異なり、Juliaコードが非インタラクティブモードで実行されるときには、 ansは設定されません。\nJuliaの structは、MATLABのclassとは異なり、実行時に動的なフィールドを追加をサポートしません。代わりに、Dictを使ってください。\nJuliaでは各モジュールは独自のグローバルスコープ/名前空間を持ちますが、MATLABでは1つのグローバルスコープしかありません。\nMATLABでは、不要な値を削除するための慣用的な方法は、次のように論理インデックスを使用すること　で、x(x> 3)としたり x(x> 3)= []とxを上書きしたりします。対してJuliaでは、より高次の関数filterとfilter!が利用できます。MATLABのコードをそのままJuliaに書き換えたx [x.> 3]や x = x [x.> 3] の代わりに、filter(z-> z> 3,x)や、filter!(z-> z> 3,x)と書くことができます。 filter!を使うと一時配列の使用を減らすことができます。\nセル配列のすべての要素を抽出する(つまり「間接参照する」)には、MATLABではvertcat(A {:})が使われますが、Julia で同様のことを行うには、接合演算子を使ってvcat(A ...)と書きます。","category":"page"},{"location":"manual/noteworthy-differences.html#R-との注目すべき違い-1","page":"他の言語との注目すべき違い","title":"R との注目すべき違い","text":"","category":"section"},{"location":"manual/noteworthy-differences.html#","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"One of Julia's goals is to provide an effective language for data analysis and statistical programming.  For users coming to Julia from R, these are some noteworthy differences:","category":"page"},{"location":"manual/noteworthy-differences.html#","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"Julia's single quotes enclose characters, not strings.\nJulia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.\nIn Julia, like Python but unlike R, strings can be created with triple quotes \"\"\" ... \"\"\". This syntax is convenient for constructing strings that contain line breaks.\nIn Julia, varargs are specified using the splat operator ..., which always follows the name of a specific variable, unlike R, for which ... can occur in isolation.\nIn Julia, modulus is mod(a, b), not a %% b. % in Julia is the remainder operator.\nIn Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:\nIn R, c(1, 2, 3, 4)[c(TRUE, FALSE)] is equivalent to c(1, 3).\nIn R, c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)] is equivalent to c(1, 3).\nIn Julia, [1, 2, 3, 4][[true, false]] throws a BoundsError.\nIn Julia, [1, 2, 3, 4][[true, false, true, false]] produces [1, 3].\nLike many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range.  For example, c(1, 2, 3, 4) + c(1, 2) is valid R but the equivalent [1, 2, 3, 4] + [1, 2] will throw an error in Julia.\nJulia allows an optional trailing comma when that comma does not change the meaning of code. This can cause confusion among R users when indexing into arrays. For example, x[1,] in R would return the first row of a matrix; in Julia, however, the comma is ignored, so x[1,] == x[1], and will return the first element. To extract a row, be sure to use :, as in x[1,:].\nJulia's map takes the function first, then its arguments, unlike lapply(<structure>, function, ...) in R. Similarly Julia's equivalent of apply(X, MARGIN, FUN, ...) in R is mapslices where the function is the first argument.\nMultivariate apply in R, e.g. mapply(choose, 11:13, 1:3), can be written as broadcast(binomial, 11:13, 1:3) in Julia. Equivalently Julia offers a shorter dot syntax for vectorizing functions binomial.(11:13, 1:3).\nJulia uses end to denote the end of conditional blocks, like if, loop blocks, like while/ for, and functions. In lieu of the one-line if ( cond ) statement, Julia allows statements of the form if cond; statement; end, cond && statement and !cond || statement. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. cond && (x = value).\nIn Julia, <-, <<- and -> are not assignment operators.\nJulia's -> creates an anonymous function.\nJulia constructs vectors using brackets. Julia's [1, 2, 3] is the equivalent of R's c(1, 2, 3).\nJulia's * operator can perform matrix multiplication, unlike in R. If A and B are matrices, then A * B denotes a matrix multiplication in Julia, equivalent to R's A %*% B. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write A .* B in Julia.\nJulia performs matrix transposition using the transpose function and conjugated transposition using the ' operator or the adjoint function. Julia's transpose(A) is therefore equivalent to R's t(A). Additionally a non-recursive transpose in Julia is provided by the permutedims function.\nJulia does not require parentheses when writing if statements or for/while loops: use for i in [1, 2, 3] instead of for (i in c(1, 2, 3)) and if i == 1 instead of if (i == 1).\nJulia does not treat the numbers 0 and 1 as Booleans. You cannot write if (1) in Julia, because if statements accept only booleans. Instead, you can write if true, if Bool(1), or if 1==1.\nJulia does not provide nrow and ncol. Instead, use size(M, 1) for nrow(M) and size(M, 2) for ncol(M).\nJulia is careful to distinguish scalars, vectors and matrices.  In R, 1 and c(1) are the same. In Julia, they cannot be used interchangeably.\nJulia's diag and diagm are not like R's.\nJulia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write diag(M) = fill(1, n).\nJulia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in packages under the JuliaStats organization. For example:\nFunctions pertaining to probability distributions are provided by the Distributions package.\nThe DataFrames package provides data frames.\nGeneralized linear models are provided by the GLM package.\nJulia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple or a named tuple: instead of list(a = 1, b = 2), use (1, 2) or (a=1, b=2).\nJulia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia's multiple dispatch system means that table(x::TypeA) and table(x::TypeB) act like R's table.TypeA(x) and table.TypeB(x).\nIn Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.\nIn Julia, vectors and matrices are concatenated using hcat, vcat and hvcat, not c, rbind and cbind like in R.\nIn Julia, a range like a:b is not shorthand for a vector like in R, but is a specialized AbstractRange object that is used for iteration without high memory overhead. To convert a range into a vector, use collect(a:b).\nJulia's max and min are the equivalent of pmax and pmin respectively in R, but both arguments need to have the same dimensions.  While maximum and minimum replace max and min in R, there are important differences.\nJulia's sum, prod, maximum, and minimum are different from their counterparts in R. They all accept an optional keyword argument dims, which indicates the dimensions, over which the operation is carried out.  For instance, let A = [1 2; 3 4] in Julia and B <- rbind(c(1,2),c(3,4)) be the same matrix in R.  Then sum(A) gives the same result as sum(B), but sum(A, dims=1) is a row vector containing the sum over each column and sum(A, dims=2) is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate colSums(B) and rowSums(B) functions provide these functionalities. If the dims keyword argument is a vector, then it specifies all the dimensions over which the sum is performed, while retaining the dimensions of the summed array, e.g. sum(A, dims=(1,2)) == hcat(10). It should be noted that there is no error checking regarding the second argument.\nJulia has several functions that can mutate their arguments. For example, it has both sort and sort!.\nIn R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.\nJulia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.\nJulia does not support the NULL type. The closest equivalent is nothing, but it behaves like a scalar value rather than like a list. Use x === nothing instead of is.null(x).\nIn Julia, missing values are represented by the missing object rather than by NA. Use ismissing(x) (or ismissing.(x) for element-wise operation on vectors) instead of is.na(x). The skipmissing function is generally used instead of na.rm=TRUE (though in some particular cases functions take a skipmissing argument).\nJulia lacks the equivalent of R's assign or get.\nIn Julia, return does not require parentheses.\nIn R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression x[x>3] or in the statement x = x[x>3] to modify x in-place. In contrast, Julia provides the higher order functions filter and filter!, allowing users to write filter(z->z>3, x) and filter!(z->z>3, x) as alternatives to the corresponding transliterations x[x.>3] and x = x[x.>3]. Using filter! reduces the use of temporary arrays.","category":"page"},{"location":"manual/noteworthy-differences.html#Python-との注目すべき違い-1","page":"他の言語との注目すべき違い","title":"Python との注目すべき違い","text":"","category":"section"},{"location":"manual/noteworthy-differences.html#","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"Julia は、コードブロックの終わりにend が必要です。Pythonとは違って Julia には pass キーワードがありません。\nJulia では、配列、文字列などのインデックスは 0 からではなく 1 から始まります。\nJulia のスライス インデックス作成には、Python とは異なり、最後の要素が含まれています。ジュリアのa[2:3] は Python の a[1:3] です。\nJulia は負のインデックスをサポートしていません。特に、リストまたは配列の最後の要素は、Python では -1 ですが、Julia では end でインデックス付けされます。\nJulia の for、if、whileなどのブロックは end キーワードで終了します。インデントレベルはPythonほど重要ではありません。\nJulia には行継続構文がありません: 行末で、これまでの入力が完全な式である場合は、完了したと見なされますが、それ以外の場合は、入力が続行されます。式を括弧でくくると(そして行内で括弧を閉じなければ) 強制的に次の行に続行することができます。\nJulia 配列は列メジャー (Fortran オーダー) ですが、NumPy 配列はデフォルトで行メジャー (C オーダー) です。配列をループする際に最適なパフォーマンスを得るには、NumPy に対して Julia でループの順序を逆にする必要があります (パフォーマンス・ティップスの関連する節を参照)。\nJulia の更新演算子(例:+=、-=、...)はインプレースではありません(NumPy の更新演算子は インプレースですが) 。どういうことかというと、 A = [1, 1]; B = A; B += [3, 3] は A の値を変更せず、新しい配列である右側の B = B + 3 の結果に B という名前を再バインドします。インプレース操作の場合は、B.+= 3を使用してください。 ( ドット演算子、示的なループ、または InplaceOps.jlを参照)\nJulia は、関数の定義時に既定値が 1 回だけ評価される Python とは異なり、メソッドが呼び出されるたびに関数引数の既定値を評価します。たとえば、関数 f(x=rand()= x は、引数なしで呼び出されるたびに新しい乱数を返します。 一方、関数 g(x=[1,2]) = push!(x,3) は g() と呼ばれるたびに [1,2,3] を返します。\nJulia では、% は reminder 演算子ですが、Python ではモジュラスです。(訳者注: reminder は商に負の数を許した上での剰余)\nThe commonly used Int type corresponds to the machine integer type (Int32 or Int64).  This means it will overflow, such that 2^64 == 0. If you need larger values use another appropriate type, such as Int128, BigInt or a floating point type like Float64.","category":"page"},{"location":"manual/noteworthy-differences.html#C/C-との注目すべき違い-1","page":"他の言語との注目すべき違い","title":"C/C++ との注目すべき違い","text":"","category":"section"},{"location":"manual/noteworthy-differences.html#","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"Julia 配列は角かっこでインデックス付けされ、複数次元の配列を扱えます A[i,j]のように。この構文は、C/C++ のようにポインタまたはアドレスへの参照のための単なる糖衣構文ではありません。配列構築の構文については、Julia のドキュメントを参照してください (バージョン間で構文が変更されています)。\nJulia では、配列、文字列などのインデックスは 0 からではなく 1 から始まります。\nJulia 配列は、別の変数に割り当てられた場合はコピーされません。A = B の後、B の要素を変更すると A も変更されます。+= のような更新演算子は、インプレースでの動作はしませんが、左辺を右辺の式の結果に最バインドする、 A = A + B に相当します。\nJulia 配列は列メジャー (Fortran オーダー) ですが、C/C++ 配列はデフォルトで行メジャーです。配列をループする際に最適なパフォーマンスを得るには、C/C++ に対して Julia でループの順序を逆にする必要があります (パフォーマンス・ティップスの関連セクションを参照)。\nJulia では、値は、関数に割り当てられたり渡されたりしてもコピーされません。関数が配列を変更すると、その変更は呼び出し元にも影響を及ぼします。\nJulia では、空白は C/C++ とは異なり重要です。Julia プログラムから空白を追加/削除する場合は注意が必要です。\nJuliaでは、小数点のないリテラル数( 42など)は、Int型の符号付き整数を作成します。しかし機械語のサイズに収まらないほど大きいリテラルは自動的にInt64(Intが Int32の場合)やInt128、または任意の大きさのより大きなサイズの型のBigInt型に昇格されます。L、LL、U、UL、ULL などの、符号なしおよび/または　符号付き と 符号なしの積などを示す、数値リテラルの接尾辞はありません。10進数リテラルは常に符号付き、16進数リテラル(C / C ++のように 0xで始まる)は符号なしです。また、16進リテラルは、 C / C ++ / Javaの16進数リテラルや、Juliaの10進数リテラルとは違い、リテラルの長さに基づいた型があります。先頭に0が複数が付くものも含みます。例えば、 0x0と0x00は型 UInt8を持ち、0x000と 0x0000は型 UInt16になります。5から8桁の16進数のリテラルは型UInt32に、9から16桁の16進数リテラルは型UInt64に、そして17から32桁の16進数リテラルは型UInt128です。16進数マスクを定義するときには、このことを考慮する必要があります。例えば~0xf == 0xf0 は ~0x000f == 0xfff0と全く異なります。 64ビットの Float64や、32ビットの Float32のビットリテラルはそれぞれ1.0と 1.0f0とひょうきします。浮動小数点リテラルが正確に表現できない場合は、丸められます(BigFloat型には昇格されません)。浮動小数点リテラルの動作はC / C ++に近いです。 8進数(接頭辞 0o)とバイナリ(接頭辞 0b)リテラルも符号なしとして扱われます。","category":"page"},{"location":"manual/noteworthy-differences.html#","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"*文字列リテラルは \"または\"\"\" で囲って表記することができます。 \"\"\" を使った文字列リテラルは、\"\\\"\" のようにクオートすることなく、文字 \" を内に含むことができます。文字列リテラルは他の変数や式の値を 展開して用いることができます。そこでは、$variablename や $(expression) と言った具合に書かれ、変数名や式をその文字列を用いたコンテキストの中で評価されます。","category":"page"},{"location":"manual/noteworthy-differences.html#","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"//は有理数を表し、単一行のコメントではありません (Juliaのコメントは#です)\n#=は複数行コメントの始まりを示し、 =#は終了を示します。\nJuliaの関数は最後の式または returnキーワードから値を返します。複数の値を関数から返すことができ、タプルとして割り当てられます。例えば、 (a, b)= myfunction()や、a, b = myfunction()といった具合です。C / C ++のように(すなわち a=myfunction(&b)というふうに)値へのポインタを渡す必要はありません。\nJuliaでは、文を終了するためにセミコロンを使用する必要はありません。(対話型プロンプト、すなわちREPLを除き)、式の結果は自動的に出力されませんので、コードの行末にセミコロンをつける必要はありません。特段プリント出力が必要なときには、printlnや@printfを使います。REPLでは、 ;を使って出力を抑制することができます。[]内では ;は注目に値する、別の意味を持ちます。同じ行の中で、複数の式を区切るのに使うことができるのです。しかし、この機能は、多くの場合で必ず必要ということではなく、可読性向上のために役立つという意味合いが強いです。\nJuliaでは、演算子⊻(xor)はXORビット演算を実行します。C / C ++でいうところの^にあたります。また、ビット演算子はC / ++とは優先順位が異なるので、括弧が必要な場合があります。\nJuliaの^はべき乗(pow)であり、C / C ++の場合のようなビット演算のXORではありません(Julia では⊻またはxorを使ってください)\nJuliaには2つの右シフト演算子、 >>と >>>があります。 >>>は算術シフトを実行します、 >> は C / C ++とは異なり、常に論理シフトを実行します。ここで、 >>の意味は、シフトされる値の型によって異なります。\nJuliaの ->は無名関数を作成し、ポインタ経由のメンバへのアクセスではありません。\nJuliaは ifステートメントやfor / whileループを書くときに括弧を必要としません: for(int i = 1; i <= 3; i ++)ではなくfor i in [1, 2, 3]です。if(i == 1)ではなく if i == 1です。\nJuliaは数字の0と1をブール値として扱いません。 Juliaでは if(1)と書くことはできません。なぜなら、if文はブール値だけを受け入れるからです。代わりに、 if true、if Bool(1) 、if 1 == 1`と書くことはできます。\nJuliaは、ifなどの条件付きブロックの終わりを示すのに endを使います。同様に、whileやforなどのループブロックのの終わりにもendを使います。ワンラインで書くif ( cond ) statementの代わりに、Juliaでは、if cond; statement; end　や、 cond && statement や、 !cond || statement のように書くことができます。終わり2つの構文で、代入式を書く場合には、括弧で明示的に囲う必要があります。例えば、cond &&(x = value)といった具合で、これは演算子の優先順位のためです。\nJuliaには行継続構文はありません。行末で、これまでの入力が完全な式である場合、完了したとみなされますが、そうでなければ、入力が続行されます。式を括弧でくくることで、強制的に次の行に続行することができます。\nJuliaのマクロは、プログラムのテキストではなく、解析された式を操作します。これにより、Juliaコードの洗練された変換を実行することができます。マクロ名は @文字で始まり、mymacro(arg1, arg2,arg3) という形の関数のような構文であったり、@mymacro arg1 arg2 arg3という形の文のような構文を持ちます。書式は書き換え可能です。関数のような形式は特にマクロが別の式の中にある場合に便利で、多くの場合明確です。文のような形式は、ブロックに注釈を付けるためによく使われます。例えば、分散実行型の for構文のようでは、@distributed for i in 1:n; #= body =#;endのように書きます。マクロの終わりがはっきりしないコードでは、関数のような形式を使用してください。\nJuliaは列挙型を持ち、 @enum(name, value1, value2, ...)マクロを使って表現されます。例えば、@enum(Fruit, banana = 1, apple, pear)のように書きます。","category":"page"},{"location":"manual/noteworthy-differences.html#","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"*慣例により、引数を変更する関数は名前の最後に !を持ちます。例えば、push! などです。","category":"page"},{"location":"manual/noteworthy-differences.html#","page":"他の言語との注目すべき違い","title":"他の言語との注目すべき違い","text":"C ++では、デフォルトでは静的ディスパッチを利用可能です。つまり、動的なディスパッチを行うには、関数を仮想関数であるようにアノテーションする必要があります。一方、Juliaでは、すべてのメソッドは「仮想」です(ただし、より一般的です。メソッドは、最も具体的な宣言規則を使用するような、ディスパッチを、thisだけではなくすべての引数の型に対して行います)。","category":"page"},{"location":"manual/unicode-input.html#Unicode-Input-1","page":"Unicode Input","title":"Unicode Input","text":"","category":"section"},{"location":"manual/unicode-input.html#","page":"Unicode Input","title":"Unicode Input","text":"The following table lists Unicode characters that can be entered via tab completion of LaTeX-like abbreviations in the Julia REPL (and in various other editing environments).  You can also get information on how to type a symbol by entering it in the REPL help, i.e. by typing ? and then entering the symbol in the REPL (e.g., by copy-paste from somewhere you saw the symbol).","category":"page"},{"location":"manual/unicode-input.html#","page":"Unicode Input","title":"Unicode Input","text":"warning: Warning\nThis table may appear to contain missing characters in the second column, or even show characters that are inconsistent with the characters as they are rendered in the Julia REPL. In these cases, users are strongly advised to check their choice of fonts in their browser and REPL environment, as there are known issues with glyphs in many fonts.","category":"page"},{"location":"manual/unicode-input.html#","page":"Unicode Input","title":"Unicode Input","text":"#\n# Generate a table containing all LaTeX and Emoji tab completions available in the REPL.\n#\nimport REPL, Markdown\nconst NBSP = '\\u00A0'\n\nfunction tab_completions(symbols...)\n    completions = Dict{String, Vector{String}}()\n    for each in symbols, (k, v) in each\n        completions[v] = push!(get!(completions, v, String[]), k)\n    end\n    return completions\nend\n\nfunction unicode_data()\n    file = normpath(@__DIR__, \"..\", \"..\", \"..\", \"..\", \"..\", \"doc\", \"UnicodeData.txt\")\n    names = Dict{UInt32, String}()\n    open(file) do unidata\n        for line in readlines(unidata)\n            id, name, desc = split(line, \";\")[[1, 2, 11]]\n            codepoint = parse(UInt32, \"0x$id\")\n            names[codepoint] = titlecase(lowercase(\n                name == \"\" ? desc : desc == \"\" ? name : \"$name / $desc\"))\n        end\n    end\n    return names\nend\n\n# Surround combining characters with no-break spaces (i.e '\\u00A0'). Follows the same format\n# for how unicode is displayed on the unicode.org website:\n# http://unicode.org/cldr/utility/character.jsp?a=0300\nfunction fix_combining_chars(char)\n    cat = Base.Unicode.category_code(char)\n    return cat == 6 || cat == 8 ? \"$NBSP$char$NBSP\" : \"$char\"\nend\n\n\nfunction table_entries(completions, unicode_dict)\n    entries = [[\n        \"Code point(s)\", \"Character(s)\",\n        \"Tab completion sequence(s)\", \"Unicode name(s)\"\n    ]]\n    for (chars, inputs) in sort!(collect(completions), by = first)\n        code_points, unicode_names, characters = String[], String[], String[]\n        for char in chars\n            push!(code_points, \"U+$(uppercase(string(UInt32(char), base = 16, pad = 5)))\")\n            push!(unicode_names, get(unicode_dict, UInt32(char), \"(No Unicode name)\"))\n            push!(characters, isempty(characters) ? fix_combining_chars(char) : \"$char\")\n        end\n        push!(entries, [\n            join(code_points, \" + \"), join(characters),\n            join(inputs, \", \"), join(unicode_names, \" + \")\n        ])\n    end\n    return Markdown.Table(entries, [:l, :l, :l, :l])\nend\n\ntable_entries(\n    tab_completions(\n        REPL.REPLCompletions.latex_symbols,\n        REPL.REPLCompletions.emoji_symbols\n    ),\n    unicode_data()\n)","category":"page"},{"location":"base/base.html#Essentials-1","page":"Essentials","title":"Essentials","text":"","category":"section"},{"location":"base/base.html#Introduction-1","page":"Essentials","title":"Introduction","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Julia Base contains a range of functions and macros appropriate for performing scientific and numerical computing, but is also as broad as those of many general purpose programming languages.  Additional functionality is available from a growing collection of available packages.  Functions are grouped by topic below.","category":"page"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Some general notes:","category":"page"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"To use module functions, use import Module to import the module, and Module.fn(x) to use the functions.\nAlternatively, using Module will import all exported Module functions into the current namespace.\nBy convention, function names ending with an exclamation point (!) modify their arguments.  Some functions have both modifying (e.g., sort!) and non-modifying (sort) versions.","category":"page"},{"location":"base/base.html#Getting-Around-1","page":"Essentials","title":"Getting Around","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.exit\nBase.atexit\nBase.isinteractive\nBase.summarysize\nBase.require\nBase.compilecache\nBase.__precompile__\nBase.include\nBase.MainInclude.include\nBase.include_string\nBase.include_dependency\nBase.which(::Any, ::Any)\nBase.methods\nBase.@show\nans","category":"page"},{"location":"base/base.html#Base.exit","page":"Essentials","title":"Base.exit","text":"exit(code=0)\n\nStop the program with an exit code. The default exit code is zero, indicating that the program completed successfully. In an interactive session, exit() can be called with the keyboard shortcut ^D.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.atexit","page":"Essentials","title":"Base.atexit","text":"atexit(f)\n\nRegister a zero-argument function f() to be called at process exit. atexit() hooks are called in last in first out (LIFO) order and run before object finalizers.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.isinteractive","page":"Essentials","title":"Base.isinteractive","text":"isinteractive() -> Bool\n\nDetermine whether Julia is running an interactive session.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.summarysize","page":"Essentials","title":"Base.summarysize","text":"Base.summarysize(obj; exclude=Union{...}, chargeall=Union{...}) -> Int\n\nCompute the amount of memory, in bytes, used by all unique objects reachable from the argument.\n\nKeyword Arguments\n\nexclude: specifies the types of objects to exclude from the traversal.\nchargeall: specifies the types of objects to always charge the size of all of their fields, even if those fields would normally be excluded.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.require","page":"Essentials","title":"Base.require","text":"require(into::Module, module::Symbol)\n\nThis function is part of the implementation of using / import, if a module is not already defined in Main. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).\n\nLoads a source file, in the context of the Main module, on every active node, searching standard locations for files. require is considered a top-level operation, so it sets the current include path but does not use it to search for files (see help for include). This function is typically used to load library code, and is implicitly called by using to load packages.\n\nWhen searching for files, require first looks for package code in the global array LOAD_PATH. require is case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.\n\nFor more details regarding code loading, see the manual sections on modules and parallel computing.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.compilecache","page":"Essentials","title":"Base.compilecache","text":"Base.compilecache(module::PkgId)\n\nCreates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in DEPOT_PATH[1]/compiled. See Module initialization and precompilation for important notes.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.__precompile__","page":"Essentials","title":"Base.__precompile__","text":"__precompile__(isprecompilable::Bool)\n\nSpecify whether the file calling this function is precompilable, defaulting to true. If a module or file is not safely precompilable, it should call __precompile__(false) in order to throw an error if Julia attempts to precompile it.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.include","page":"Essentials","title":"Base.include","text":"Base.include([m::Module,] path::AbstractString)\n\nEvaluate the contents of the input source file in the global scope of module m. Every module (except those defined with baremodule) has its own 1-argument definition of include, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to include will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.MainInclude.include","page":"Essentials","title":"Base.MainInclude.include","text":"include(path::AbstractString)\n\nEvaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with baremodule) has its own 1-argument definition of include, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to include will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.\n\nUse Base.include to evaluate a file into another module.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.include_string","page":"Essentials","title":"Base.include_string","text":"include_string(m::Module, code::AbstractString, filename::AbstractString=\"string\")\n\nLike include, except reads code from the given string rather than from a file.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.include_dependency","page":"Essentials","title":"Base.include_dependency","text":"include_dependency(path::AbstractString)\n\nIn a module, declare that the file specified by path (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.\n\nThis is only needed if your module depends on a file that is not used via include. It has no effect outside of compilation.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.which-Tuple{Any,Any}","page":"Essentials","title":"Base.which","text":"which(f, types)\n\nReturns the method of f (a Method object) that would be called for arguments of the given types.\n\nIf types is an abstract type, then the method that would be called by invoke is returned.\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.methods","page":"Essentials","title":"Base.methods","text":"methods(f, [types])\n\nReturns the method table for f.\n\nIf types is specified, returns an array of methods whose types match.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.@show","page":"Essentials","title":"Base.@show","text":"@show\n\nShow an expression and result, returning the result. See also show.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#ans","page":"Essentials","title":"ans","text":"ans\n\nA variable referring to the last computed value, automatically set at the interactive prompt.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#Keywords-1","page":"Essentials","title":"Keywords","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"This is the list of reserved keywords in Julia: baremodule, begin, break, catch, const, continue, do, else, elseif, end, export, false, finally, for, function, global, if, import, let, local, macro, module, quote, return, struct, true, try, using, while.  Those keywords are not allowed to be used as variable names.","category":"page"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"The following two-word sequences are reserved: abstract type, mutable struct, primitive type.  However, you can create variables with names: abstract, mutable, primitive and type.","category":"page"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Finally,where is parsed as an infix operator for writing parametric method and type definitions. Also in and isa are parsed as infix operators. Creation of a variable named where, in or isa is allowed though.","category":"page"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"module\nexport\nimport\nusing\nbaremodule\nfunction\nmacro\nreturn\ndo\nbegin\nend\nlet\nif\nfor\nwhile\nbreak\ncontinue\ntry\nfinally\nquote\nlocal\nglobal\nconst\nstruct\nmutable struct\nabstract type\nprimitive type\nwhere\n...\n;\n=","category":"page"},{"location":"base/base.html#module","page":"Essentials","title":"module","text":"module\n\nmodule declares a Module, which is a separate global variable workspace. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting). Modules allow you to create top-level definitions without worrying about name conflicts when your code is used together with somebody else’s. See the manual section about modules for more details.\n\nExamples\n\nmodule Foo\nimport Base.show\nexport MyType, foo\n\nstruct MyType\n    x\nend\n\nbar(x) = 2x\nfoo(a::MyType) = bar(a.x) + 1\nshow(io::IO, a::MyType) = print(io, \"MyType $(a.x)\")\nend\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#export","page":"Essentials","title":"export","text":"export\n\nexport is used within modules to tell Julia which functions should be made available to the user. For example: export foo makes the name foo available when using the module. See the manual section about modules for details.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#import","page":"Essentials","title":"import","text":"import\n\nimport Foo will load the module or package Foo. Names from the imported Foo module can be accessed with dot syntax (e.g. Foo.foo to access the name foo). See the manual section about modules for details.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#using","page":"Essentials","title":"using","text":"using\n\nusing Foo will load the module or package Foo and make its exported names available for direct use. Names can also be used via dot syntax (e.g. Foo.foo to access the name foo), whether they are exported or not. See the manual section about modules for details.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#baremodule","page":"Essentials","title":"baremodule","text":"baremodule\n\nbaremodule declares a module that does not contain using Base or a definition of eval. It does still import Core.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#function","page":"Essentials","title":"function","text":"function\n\nFunctions are defined with the function keyword:\n\nfunction add(a, b)\n    return a + b\nend\n\nOr the short form notation:\n\nadd(a, b) = a + b\n\nThe use of the return keyword is exactly the same as in other languages, but is often optional. A function without an explicit return statement will return the last expression in the function body.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#macro","page":"Essentials","title":"macro","text":"macro\n\nmacro defines a method for inserting generated code into a program. A macro maps a sequence of argument expressions to a returned expression, and the resulting expression is substituted directly into the program at the point where the macro is invoked. Macros are a way to run generated code without calling eval, since the generated code instead simply becomes part of the surrounding program. Macro arguments may include expressions, literal values, and symbols.\n\nExamples\n\njulia> macro sayhello(name)\n           return :( println(\"Hello, \", $name, \"!\") )\n       end\n@sayhello (macro with 1 method)\n\njulia> @sayhello \"Charlie\"\nHello, Charlie!\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#return","page":"Essentials","title":"return","text":"return\n\nreturn x causes the enclosing function to exit early, passing the given value x back to its caller. return by itself with no value is equivalent to return nothing (see nothing).\n\nfunction compare(a, b)\n    a == b && return \"equal to\"\n    a < b ? \"less than\" : \"greater than\"\nend\n\nIn general you can place a return statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with do blocks. For example:\n\nfunction test1(xs)\n    for x in xs\n        iseven(x) && return 2x\n    end\nend\n\nfunction test2(xs)\n    map(xs) do x\n        iseven(x) && return 2x\n        x\n    end\nend\n\nIn the first example, the return breaks out of test1 as soon as it hits an even number, so test1([5,6,7]) returns 12.\n\nYou might expect the second example to behave the same way, but in fact the return there only breaks out of the inner function (inside the do block) and gives a value back to map. test2([5,6,7]) then returns [5,12,7].\n\nWhen used in a top-level expression (i.e. outside any function), return causes the entire current top-level expression to terminate early.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#do","page":"Essentials","title":"do","text":"do\n\nCreate an anonymous function and pass it as the first argument to a function call. For example:\n\nmap(1:10) do x\n    2x\nend\n\nis equivalent to map(x->2x, 1:10).\n\nUse multiple arguments like so:\n\nmap(1:10, 11:20) do x, y\n    x + y\nend\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#begin","page":"Essentials","title":"begin","text":"begin\n\nbegin...end denotes a block of code.\n\nbegin\n    println(\"Hello, \")\n    println(\"World!\")\nend\n\nUsually begin will not be necessary, since keywords such as function and let implicitly begin blocks of code. See also ;.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#end","page":"Essentials","title":"end","text":"end\n\nend marks the conclusion of a block of expressions, for example module, struct, mutable struct, begin, let, for etc. end may also be used when indexing into an array to represent the last index of a dimension.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> A[end, :]\n2-element Array{Int64,1}:\n 3\n 4\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#let","page":"Essentials","title":"let","text":"let\n\nlet statements allocate new variable bindings each time they run. Whereas an assignment modifies an existing value location, let creates new locations. This difference is only detectable in the case of variables that outlive their scope via closures. The let syntax accepts a comma-separated series of assignments and variable names:\n\nlet var1 = value1, var2, var3 = value3\n    code\nend\n\nThe assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like let x = x, since the two x variables are distinct and have separate storage.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#if","page":"Essentials","title":"if","text":"if/elseif/else\n\nif/elseif/else performs conditional evaluation, which allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the if/elseif/else conditional syntax:\n\nif x < y\n    println(\"x is less than y\")\nelseif x > y\n    println(\"x is greater than y\")\nelse\n    println(\"x is equal to y\")\nend\n\nIf the condition expression x < y is true, then the corresponding block is evaluated; otherwise the condition expression x > y is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the else block is evaluated. The elseif and else blocks are optional, and as many elseif blocks as desired can be used.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#for","page":"Essentials","title":"for","text":"for\n\nfor loops repeatedly evaluate a block of statements while iterating over a sequence of values.\n\nExamples\n\njulia> for i in [1, 4, 0]\n           println(i)\n       end\n1\n4\n0\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#while","page":"Essentials","title":"while","text":"while\n\nwhile loops repeatedly evaluate a conditional expression, and continue evaluating the body of the while loop as long as the expression remains true. If the condition expression is false when the while loop is first reached, the body is never evaluated.\n\nExamples\n\njulia> i = 1\n1\n\njulia> while i < 5\n           println(i)\n           global i += 1\n       end\n1\n2\n3\n4\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#break","page":"Essentials","title":"break","text":"break\n\nBreak out of a loop immediately.\n\nExamples\n\njulia> i = 0\n0\n\njulia> while true\n           global i += 1\n           i > 5 && break\n           println(i)\n       end\n1\n2\n3\n4\n5\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#continue","page":"Essentials","title":"continue","text":"continue\n\nSkip the rest of the current loop iteration.\n\nExamples\n\njulia> for i = 1:6\n           iseven(i) && continue\n           println(i)\n       end\n1\n3\n5\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#try","page":"Essentials","title":"try","text":"try/catch\n\nA try/catch statement allows intercepting errors (exceptions) thrown by throw so that program execution can continue. For example, the following code attempts to write a file, but warns the user and proceeds instead of terminating execution if the file cannot be written:\n\ntry\n    open(\"/danger\", \"w\") do f\n        println(f, \"Hello\")\n    end\ncatch\n    @warn \"Could not write file.\"\nend\n\nThe syntax catch e (where e is any variable) assigns the thrown exception object to the given variable within the catch block.\n\nThe power of the try/catch construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#finally","page":"Essentials","title":"finally","text":"finally\n\nRun some code when a given block of code exits, regardless of how it exits. For example, here is how we can guarantee that an opened file is closed:\n\nf = open(\"file\")\ntry\n    operate_on_file(f)\nfinally\n    close(f)\nend\n\nWhen control leaves the try block (for example, due to a return, or just finishing normally), close(f) will be executed. If the try block exits due to an exception, the exception will continue propagating. A catch block may be combined with try and finally as well. In this case the finally block will run after catch has handled the error.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#quote","page":"Essentials","title":"quote","text":"quote\n\nquote creates multiple expression objects in a block without using the explicit Expr constructor. For example:\n\nex = quote\n    x = 1\n    y = 2\n    x + y\nend\n\nUnlike the other means of quoting, :( ... ), this form introduces QuoteNode elements to the expression tree, which must be considered when directly manipulating the tree. For other purposes, :( ... ) and quote .. end blocks are treated identically.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#local","page":"Essentials","title":"local","text":"local\n\nlocal introduces a new local variable. See the manual section on variable scoping for more information.\n\nExamples\n\njulia> function foo(n)\n           x = 0\n           for i = 1:n\n               local x # introduce a loop-local x\n               x = i\n           end\n           x\n       end\nfoo (generic function with 1 method)\n\njulia> foo(10)\n0\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#global","page":"Essentials","title":"global","text":"global\n\nglobal x makes x in the current scope and its inner scopes refer to the global variable of that name. See the manual section on variable scoping for more information.\n\nExamples\n\njulia> z = 3\n3\n\njulia> function foo()\n           global z = 6 # use the z variable defined outside foo\n       end\nfoo (generic function with 1 method)\n\njulia> foo()\n6\n\njulia> z\n6\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#const","page":"Essentials","title":"const","text":"const\n\nconst is used to declare global variables whose values will not change. In almost all code (and particularly performance sensitive code) global variables should be declared constant in this way.\n\nconst x = 5\n\nMultiple variables can be declared within a single const:\n\nconst y, z = 7, 11\n\nNote that const only applies to one = operation, therefore const x = y = 1 declares x to be constant but not y. On the other hand, const x = const y = 1 declares both x and y constant.\n\nNote that \"constant-ness\" does not extend into mutable containers; only the association between a variable and its value is constant. If x is an array or dictionary (for example) you can still modify, add, or remove elements.\n\nIn some cases changing the value of a const variable gives a warning instead of an error. However, this can produce unpredictable behavior or corrupt the state of your program, and so should be avoided. This feature is intended only for convenience during interactive use.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#struct","page":"Essentials","title":"struct","text":"struct\n\nThe most commonly used kind of type in Julia is a struct, specified as a name and a set of fields.\n\nstruct Point\n    x\n    y\nend\n\nFields can have type restrictions, which may be parameterized:\n\n    struct Point{X}\n        x::X\n        y::Float64\n    end\n\nA struct can also declare an abstract super type via <: syntax:\n\nstruct Point <: AbstractPoint\n    x\n    y\nend\n\nstructs are immutable by default; an instance of one of these types cannot be modified after construction. Use mutable struct instead to declare a type whose instances can be modified.\n\nSee the manual section on Composite Types for more details, such as how to define constructors.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#mutable struct","page":"Essentials","title":"mutable struct","text":"mutable struct\n\nmutable struct is similar to struct, but additionally allows the fields of the type to be set after construction. See the manual section on Composite Types for more information.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#abstract type","page":"Essentials","title":"abstract type","text":"abstract type\n\nabstract type declares a type that cannot be instantiated, and serves only as a node in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. Abstract types form the conceptual hierarchy which makes Julia’s type system more than just a collection of object implementations. For example:\n\nabstract type Number end\nabstract type Real <: Number end\n\nNumber has no supertype, whereas Real is an abstract subtype of Number.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#primitive type","page":"Essentials","title":"primitive type","text":"primitive type\n\nprimitive type declares a concrete type whose data consists only of a series of bits. Classic examples of primitive types are integers and floating-point values. Some example built-in primitive type declarations:\n\nprimitive type Char 32 end\nprimitive type Bool <: Integer 8 end\n\nThe number after the name indicates how many bits of storage the type requires. Currently, only sizes that are multiples of 8 bits are supported. The Bool declaration shows how a primitive type can be optionally declared to be a subtype of some supertype.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#where","page":"Essentials","title":"where","text":"where\n\nThe where keyword creates a type that is an iterated union of other types, over all values of some variable. For example Vector{T} where T<:Real includes all Vectors where the element type is some kind of Real number.\n\nThe variable bound defaults to Any if it is omitted:\n\nVector{T} where T    # short for `where T<:Any`\n\nVariables can also have lower bounds:\n\nVector{T} where T>:Int\nVector{T} where Int<:T<:Real\n\nThere is also a concise syntax for nested where expressions. For example, this:\n\nPair{T, S} where S<:Array{T} where T<:Number\n\ncan be shortened to:\n\nPair{T, S} where {T<:Number, S<:Array{T}}\n\nThis form is often found on method signatures.\n\nNote that in this form, the variables are listed outermost-first. This matches the order in which variables are substituted when a type is \"applied\" to parameter values using the syntax T{p1, p2, ...}.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#...","page":"Essentials","title":"...","text":"...\n\nThe \"splat\" operator, ..., represents a sequence of arguments. ... can be used in function definitions, to indicate that the function accepts an arbitrary number of arguments. ... can also be used to apply a function to a sequence of arguments.\n\nExamples\n\njulia> add(xs...) = reduce(+, xs)\nadd (generic function with 1 method)\n\njulia> add(1, 2, 3, 4, 5)\n15\n\njulia> add([1, 2, 3]...)\n6\n\njulia> add(7, 1:100..., 1000:1100...)\n111107\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#;","page":"Essentials","title":";","text":";\n\n; has a similar role in Julia as in many C-like languages, and is used to delimit the end of the previous statement. ; is not necessary after new lines, but can be used to separate statements on a single line or to join statements into a single expression. ; is also used to suppress output printing in the REPL and similar interfaces.\n\nExamples\n\njulia> function foo()\n           x = \"Hello, \"; x *= \"World!\"\n           return x\n       end\nfoo (generic function with 1 method)\n\njulia> bar() = (x = \"Hello, Mars!\"; return x)\nbar (generic function with 1 method)\n\njulia> foo();\n\njulia> bar()\n\"Hello, Mars!\"\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#=","page":"Essentials","title":"=","text":"=\n\n= is the assignment operator.\n\nFor variable a and expression b, a = b makes a refer to the value of b.\nFor functions f(x), f(x) = x defines a new function constant f, or adds a new method to f if f is already defined; this usage is equivalent to function f(x); x; end.\na[i] = v calls setindex!(a,v,i).\na.b = c calls setproperty!(a,:b,c).\nInside a function call, f(a=b) passes b as the value of keyword argument a.\nInside parentheses with commas, (a=1,) constructs a NamedTuple.\n\nExamples\n\nAssigning a to b does not create a copy of b; instead use copy or deepcopy.\n\njulia> b = [1]; a = b; b[1] = 2; a\n1-element Array{Int64,1}:\n 2\n\njulia> b = [1]; a = copy(b); b[1] = 2; a\n1-element Array{Int64,1}:\n 1\n\n\nCollections passed to functions are also not copied. Functions can modify (mutate) the contents of the objects their arguments refer to. (The names of functions which do this are conventionally suffixed with '!'.)\n\njulia> function f!(x); x[:] .+= 1; end\nf! (generic function with 1 method)\n\njulia> a = [1]; f!(a); a\n1-element Array{Int64,1}:\n 2\n\n\nAssignment can operate on multiple variables in parallel, taking values from an iterable:\n\njulia> a, b = 4, 5\n(4, 5)\n\njulia> a, b = 1:3\n1:3\n\njulia> a, b\n(1, 2)\n\n\nAssignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:\n\njulia> a = [1]; b = [2]; c = [3]; a = b = c\n1-element Array{Int64,1}:\n 3\n\njulia> b[1] = 2; a, b, c\n([2], [2], [2])\n\n\nAssignment at out-of-bounds indices does not grow a collection. If the collection is a Vector it can instead be grown with push! or append!.\n\njulia> a = [1, 1]; a[3] = 2\nERROR: BoundsError: attempt to access 2-element Array{Int64,1} at index [3]\n[...]\n\njulia> push!(a, 2, 3)\n4-element Array{Int64,1}:\n 1\n 1\n 2\n 3\n\n\nAssigning [] does not eliminate elements from a collection; instead use filter!.\n\njulia> a = collect(1:3); a[a .<= 1] = []\nERROR: DimensionMismatch(\"tried to assign 0 elements to 1 destinations\")\n[...]\n\njulia> filter!(x -> x > 1, a) # in-place & thus more efficient than a = a[a .> 1]\n2-element Array{Int64,1}:\n 2\n 3\n\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#標準モジュール-1","page":"Essentials","title":"標準モジュール","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Main\nCore\nBase","category":"page"},{"location":"base/base.html#Main","page":"Essentials","title":"Main","text":"Main\n\nMain is the top-level module, and Julia starts with Main set as the current module.  Variables defined at the prompt go in Main, and varinfo lists variables in Main.\n\njulia> @__MODULE__\nMain\n\n\n\n\n\n","category":"module"},{"location":"base/base.html#Core","page":"Essentials","title":"Core","text":"Core\n\nCore is the module that contains all identifiers considered \"built in\" to the language, i.e. part of the core language and not libraries. Every module implicitly specifies using Core, since you can't do anything without those definitions.\n\n\n\n\n\n","category":"module"},{"location":"base/base.html#Base","page":"Essentials","title":"Base","text":"Base\n\nThe base library of Julia. Base is a module that contains basic functionality (the contents of base/). All modules implicitly contain using Base, since this is needed in the vast majority of cases.\n\n\n\n\n\n","category":"module"},{"location":"base/base.html#Base-Submodules-1","page":"Essentials","title":"Base Submodules","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.Broadcast\nBase.Docs\nBase.Iterators\nBase.Libc\nBase.Meta\nBase.StackTraces\nBase.Sys\nBase.Threads\nBase.GC","category":"page"},{"location":"base/base.html#Base.Broadcast","page":"Essentials","title":"Base.Broadcast","text":"Base.Broadcast\n\nModule containing the broadcasting implementation.\n\n\n\n\n\n","category":"module"},{"location":"base/base.html#Base.Docs","page":"Essentials","title":"Base.Docs","text":"Docs\n\nThe Docs module provides the @doc macro which can be used to set and retrieve documentation metadata for Julia objects.\n\nPlease see the manual section on documentation for more information.\n\n\n\n\n\n","category":"module"},{"location":"base/base.html#Base.Iterators","page":"Essentials","title":"Base.Iterators","text":"Methods for working with Iterators.\n\n\n\n\n\n","category":"module"},{"location":"base/base.html#Base.Libc","page":"Essentials","title":"Base.Libc","text":"Interface to libc, the C standard library.\n\n\n\n\n\n","category":"module"},{"location":"base/base.html#Base.Meta","page":"Essentials","title":"Base.Meta","text":"Convenience functions for metaprogramming.\n\n\n\n\n\n","category":"module"},{"location":"base/base.html#Base.StackTraces","page":"Essentials","title":"Base.StackTraces","text":"Tools for collecting and manipulating stack traces. Mainly used for building errors.\n\n\n\n\n\n","category":"module"},{"location":"base/base.html#Base.Sys","page":"Essentials","title":"Base.Sys","text":"Provide methods for retrieving information about hardware and the operating system.\n\n\n\n\n\n","category":"module"},{"location":"base/base.html#Base.Threads","page":"Essentials","title":"Base.Threads","text":"Experimental multithreading support.\n\n\n\n\n\n","category":"module"},{"location":"base/base.html#Base.GC","page":"Essentials","title":"Base.GC","text":"Base.GC\n\nModule with garbage collection utilities.\n\n\n\n\n\n","category":"module"},{"location":"base/base.html#All-Objects-1","page":"Essentials","title":"All Objects","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Core.:(===)\nCore.isa\nBase.isequal\nBase.isless\nBase.ifelse\nCore.typeassert\nCore.typeof\nCore.tuple\nBase.ntuple\nBase.objectid\nBase.hash\nBase.finalizer\nBase.finalize\nBase.copy\nBase.deepcopy\nBase.getproperty\nBase.setproperty!\nBase.propertynames\nBase.hasproperty\nCore.getfield\nCore.setfield!\nCore.isdefined\nBase.@isdefined\nBase.convert\nBase.promote\nBase.oftype\nBase.widen\nBase.identity","category":"page"},{"location":"base/base.html#Core.:===","page":"Essentials","title":"Core.:===","text":"===(x,y) -> Bool\n≡(x,y) -> Bool\n\nDetermine whether x and y are identical, in the sense that no program could distinguish them. First the types of x and y are compared. If those are identical, mutable objects are compared by address in memory and immutable objects (such as numbers) are compared by contents at the bit level. This function is sometimes called \"egal\". It always returns a Bool value.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 2];\n\njulia> a == b\ntrue\n\njulia> a === b\nfalse\n\njulia> a === a\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.isa","page":"Essentials","title":"Core.isa","text":"isa(x, type) -> Bool\n\nDetermine whether x is of the given type. Can also be used as an infix operator, e.g. x isa type.\n\nExamples\n\njulia> isa(1, Int)\ntrue\n\njulia> isa(1, Matrix)\nfalse\n\njulia> isa(1, Char)\nfalse\n\njulia> isa(1, Number)\ntrue\n\njulia> 1 isa Number\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.isequal","page":"Essentials","title":"Base.isequal","text":"isequal(x, y)\n\nSimilar to ==, except for the treatment of floating point numbers and of missing values. isequal treats all floating-point NaN values as equal to each other, treats -0.0 as unequal to 0.0, and missing as equal to missing. Always returns a Bool value.\n\nImplementation\n\nThe default implementation of isequal calls ==, so a type that does not involve floating-point values generally only needs to define ==.\n\nisequal is the comparison function used by hash tables (Dict). isequal(x,y) must imply that hash(x) == hash(y).\n\nThis typically means that types for which a custom == or isequal method exists must implement a corresponding hash method (and vice versa). Collections typically implement isequal by calling isequal recursively on all contents.\n\nScalar types generally do not need to implement isequal separate from ==, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on isnan, signbit, and ==).\n\nExamples\n\njulia> isequal([1., NaN], [1., NaN])\ntrue\n\njulia> [1., NaN] == [1., NaN]\nfalse\n\njulia> 0.0 == -0.0\ntrue\n\njulia> isequal(0.0, -0.0)\nfalse\n\n\n\n\n\nisequal(x)\n\nCreate a function that compares its argument to x using isequal, i.e. a function equivalent to y -> isequal(y, x).\n\nThe returned function is of type Base.Fix2{typeof(isequal)}, which can be used to implement specialized methods.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.isless","page":"Essentials","title":"Base.isless","text":"isless(x, y)\n\nTest whether x is less than y, according to a fixed total order. isless is not defined on all pairs of values (x, y). However, if it is defined, it is expected to satisfy the following:\n\nIf isless(x, y) is defined, then so is isless(y, x) and isequal(x, y), and exactly one of those three yields true.\nThe relation defined by isless is transitive, i.e., isless(x, y) && isless(y, z) implies isless(x, z).\n\nValues that are normally unordered, such as NaN, are ordered in an arbitrary but consistent fashion. missing values are ordered last.\n\nThis is the default comparison used by sort.\n\nImplementation\n\nNon-numeric types with a total order should implement this function. Numeric types only need to implement it if they have special values such as NaN. Types with a partial order should implement <.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.ifelse","page":"Essentials","title":"Core.ifelse","text":"ifelse(condition::Bool, x, y)\n\nReturn x if condition is true, otherwise return y. This differs from ? or if in that it is an ordinary function, so all the arguments are evaluated first. In some cases, using ifelse instead of an if statement can eliminate the branch in generated code and provide higher performance in tight loops.\n\nExamples\n\njulia> ifelse(1 > 2, 1, 2)\n2\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.typeassert","page":"Essentials","title":"Core.typeassert","text":"typeassert(x, type)\n\nThrow a TypeError unless x isa type. The syntax x::type calls this function.\n\nExamples\n\njulia> typeassert(2.5, Int)\nERROR: TypeError: in typeassert, expected Int64, got Float64\nStacktrace:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.typeof","page":"Essentials","title":"Core.typeof","text":"typeof(x)\n\nGet the concrete type of x.\n\nExamples\n\njulia> a = 1//2;\n\njulia> typeof(a)\nRational{Int64}\n\njulia> M = [1 2; 3.5 4];\n\njulia> typeof(M)\nArray{Float64,2}\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.tuple","page":"Essentials","title":"Core.tuple","text":"tuple(xs...)\n\nConstruct a tuple of the given objects.\n\nExamples\n\njulia> tuple(1, 'a', pi)\n(1, 'a', π)\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.ntuple","page":"Essentials","title":"Base.ntuple","text":"ntuple(f::Function, n::Integer)\n\nCreate a tuple of length n, computing each element as f(i), where i is the index of the element.\n\nExamples\n\njulia> ntuple(i -> 2*i, 4)\n(2, 4, 6, 8)\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.objectid","page":"Essentials","title":"Base.objectid","text":"objectid(x)\n\nGet a hash value for x based on object identity. objectid(x)==objectid(y) if x === y.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.hash","page":"Essentials","title":"Base.hash","text":"hash(x[, h::UInt])\n\nCompute an integer hash code such that isequal(x,y) implies hash(x)==hash(y). The optional second argument h is a hash code to be mixed with the result.\n\nNew types should implement the 2-argument form, typically by calling the 2-argument hash method recursively in order to mix hashes of the contents with each other (and with h). Typically, any type that implements hash should also implement its own == (hence isequal) to guarantee the property mentioned above. Types supporting subtraction (operator -) should also implement widen, which is required to hash values inside heterogeneous arrays.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.finalizer","page":"Essentials","title":"Base.finalizer","text":"finalizer(f, x)\n\nRegister a function f(x) to be called when there are no program-accessible references to x, and return x. The type of x must be a mutable struct, otherwise the behavior of this function is unpredictable.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.finalize","page":"Essentials","title":"Base.finalize","text":"finalize(x)\n\nImmediately run finalizers registered for object x.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.copy","page":"Essentials","title":"Base.copy","text":"copy(x)\n\nCreate a shallow copy of x: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.deepcopy","page":"Essentials","title":"Base.deepcopy","text":"deepcopy(x)\n\nCreate a deep copy of x: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling deepcopy on an object should generally have the same effect as serializing and then deserializing it.\n\nAs a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.\n\nWhile it isn't normally necessary, user-defined types can override the default deepcopy behavior by defining a specialized version of the function deepcopy_internal(x::T, dict::IdDict) (which shouldn't otherwise be used), where T is the type to be specialized for, and dict keeps track of objects copied so far within the recursion. Within the definition, deepcopy_internal should be used in place of deepcopy, and the dict variable should be updated as appropriate before returning.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.getproperty","page":"Essentials","title":"Base.getproperty","text":"getproperty(value, name::Symbol)\n\nThe syntax a.b calls getproperty(a, :b).\n\nExamples\n\njulia> struct MyType\n           x\n       end\n\njulia> function Base.getproperty(obj::MyType, sym::Symbol)\n           if sym === :special\n               return obj.x + 1\n           else # fallback to getfield\n               return getfield(obj, sym)\n           end\n       end\n\njulia> obj = MyType(1);\n\njulia> obj.special\n2\n\njulia> obj.x\n1\n\nSee also propertynames and setproperty!.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.setproperty!","page":"Essentials","title":"Base.setproperty!","text":"setproperty!(value, name::Symbol, x)\n\nThe syntax a.b = c calls setproperty!(a, :b, c).\n\nSee also propertynames and getproperty.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.propertynames","page":"Essentials","title":"Base.propertynames","text":"propertynames(x, private=false)\n\nGet a tuple or a vector of the properties (x.property) of an object x. This is typically the same as fieldnames(typeof(x)), but types that overload getproperty should generally overload propertynames as well to get the properties of an instance of the type.\n\npropertynames(x) may return only \"public\" property names that are part of the documented interface of x.   If you want it to also return \"private\" fieldnames intended for internal use, pass true for the optional second argument. REPL tab completion on x. shows only the private=false properties.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.hasproperty","page":"Essentials","title":"Base.hasproperty","text":"hasproperty(x, s::Symbol)\n\nReturn a boolean indicating whether the object x has s as one of its own properties.\n\ncompat: Julia 1.2\nThis function requires at least Julia 1.2.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.getfield","page":"Essentials","title":"Core.getfield","text":"getfield(value, name::Symbol)\n\nExtract a named field from a value of composite type. See also getproperty.\n\nExamples\n\njulia> a = 1//2\n1//2\n\njulia> getfield(a, :num)\n1\n\njulia> a.num\n1\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.setfield!","page":"Essentials","title":"Core.setfield!","text":"setfield!(value, name::Symbol, x)\n\nAssign x to a named field in value of composite type. The value must be mutable and x must be a subtype of fieldtype(typeof(value), name). See also setproperty!.\n\nExamples\n\njulia> mutable struct MyMutableStruct\n           field::Int\n       end\n\njulia> a = MyMutableStruct(1);\n\njulia> setfield!(a, :field, 2);\n\njulia> getfield(a, :field)\n2\n\njulia> a = 1//2\n1//2\n\njulia> setfield!(a, :num, 3);\nERROR: setfield! immutable struct of type Rational cannot be changed\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.isdefined","page":"Essentials","title":"Core.isdefined","text":"isdefined(m::Module, s::Symbol)\nisdefined(object, s::Symbol)\nisdefined(object, index::Int)\n\nTests whether a global variable or object field is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index.\n\nTo test whether an array element is defined, use isassigned instead.\n\nSee also @isdefined.\n\nExamples\n\njulia> isdefined(Base, :sum)\ntrue\n\njulia> isdefined(Base, :NonExistentMethod)\nfalse\n\njulia> a = 1//2;\n\njulia> isdefined(a, 2)\ntrue\n\njulia> isdefined(a, 3)\nfalse\n\njulia> isdefined(a, :num)\ntrue\n\njulia> isdefined(a, :numerator)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.@isdefined","page":"Essentials","title":"Base.@isdefined","text":"@isdefined s -> Bool\n\nTests whether variable s is defined in the current scope.\n\nSee also isdefined.\n\nExamples\n\njulia> function f()\n           println(@isdefined x)\n           x = 3\n           println(@isdefined x)\n       end\nf (generic function with 1 method)\n\njulia> f()\nfalse\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.convert","page":"Essentials","title":"Base.convert","text":"convert(T, x)\n\nConvert x to a value of type T.\n\nIf T is an Integer type, an InexactError will be raised if x is not representable by T, for example if x is not integer-valued, or is outside the range supported by T.\n\nExamples\n\njulia> convert(Int, 3.0)\n3\n\njulia> convert(Int, 3.5)\nERROR: InexactError: Int64(3.5)\nStacktrace:\n[...]\n\nIf T is a AbstractFloat or Rational type, then it will return the closest value to x representable by T.\n\njulia> x = 1/3\n0.3333333333333333\n\njulia> convert(Float32, x)\n0.33333334f0\n\njulia> convert(Rational{Int32}, x)\n1//3\n\njulia> convert(Rational{Int64}, x)\n6004799503160661//18014398509481984\n\nIf T is a collection type and x a collection, the result of convert(T, x) may alias all or part of x.\n\njulia> x = Int[1, 2, 3];\n\njulia> y = convert(Vector{Int}, x);\n\njulia> y === x\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.promote","page":"Essentials","title":"Base.promote","text":"promote(xs...)\n\nConvert all arguments to a common type, and return them all (as a tuple). If no arguments can be converted, an error is raised.\n\nExamples\n\njulia> promote(Int8(1), Float16(4.5), Float32(4.1))\n(1.0f0, 4.5f0, 4.1f0)\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.oftype","page":"Essentials","title":"Base.oftype","text":"oftype(x, y)\n\nConvert y to the type of x (convert(typeof(x), y)).\n\nExamples\n\njulia> x = 4;\n\njulia> y = 3.;\n\njulia> oftype(x, y)\n3\n\njulia> oftype(y, x)\n4.0\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.widen","page":"Essentials","title":"Base.widen","text":"widen(x)\n\nIf x is a type, return a \"larger\" type, defined so that arithmetic operations + and - are guaranteed not to overflow nor lose precision for any combination of values that type x can hold.\n\nFor fixed-size integer types less than 128 bits, widen will return a type with twice the number of bits.\n\nIf x is a value, it is converted to widen(typeof(x)).\n\nExamples\n\njulia> widen(Int32)\nInt64\n\njulia> widen(1.5f0)\n1.5\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.identity","page":"Essentials","title":"Base.identity","text":"identity(x)\n\nThe identity function. Returns its argument.\n\nExamples\n\njulia> identity(\"Well, what did you expect?\")\n\"Well, what did you expect?\"\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Properties-of-Types-1","page":"Essentials","title":"Properties of Types","text":"","category":"section"},{"location":"base/base.html#Type-relations-1","page":"Essentials","title":"Type relations","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.supertype\nCore.:(<:)\nBase.:(>:)\nBase.typejoin\nBase.typeintersect\nBase.promote_type\nBase.promote_rule\nBase.isdispatchtuple","category":"page"},{"location":"base/base.html#Base.supertype","page":"Essentials","title":"Base.supertype","text":"supertype(T::DataType)\n\nReturn the supertype of DataType T.\n\nExamples\n\njulia> supertype(Int32)\nSigned\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.:<:","page":"Essentials","title":"Core.:<:","text":"<:(T1, T2)\n\nSubtype operator: returns true if and only if all values of type T1 are also of type T2.\n\nExamples\n\njulia> Float64 <: AbstractFloat\ntrue\n\njulia> Vector{Int} <: AbstractArray\ntrue\n\njulia> Matrix{Float64} <: Matrix{AbstractFloat}\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.:>:","page":"Essentials","title":"Base.:>:","text":">:(T1, T2)\n\nSupertype operator, equivalent to T2 <: T1.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.typejoin","page":"Essentials","title":"Base.typejoin","text":"typejoin(T, S)\n\nReturn the closest common ancestor of T and S, i.e. the narrowest type from which they both inherit.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.typeintersect","page":"Essentials","title":"Base.typeintersect","text":"typeintersect(T, S)\n\nCompute a type that contains the intersection of T and S. Usually this will be the smallest such type or one close to it.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.promote_type","page":"Essentials","title":"Base.promote_type","text":"promote_type(type1, type2)\n\nPromotion refers to converting values of mixed types to a single common type. promote_type represents the default promotion behavior in Julia when operators (usually mathematical) are given arguments of differing types. promote_type generally tries to return a type which can at least approximate most values of either input type without excessively widening.  Some loss is tolerated; for example, promote_type(Int64, Float64) returns Float64 even though strictly, not all Int64 values can be represented exactly as Float64 values.\n\njulia> promote_type(Int64, Float64)\nFloat64\n\njulia> promote_type(Int32, Int64)\nInt64\n\njulia> promote_type(Float32, BigInt)\nBigFloat\n\njulia> promote_type(Int16, Float16)\nFloat16\n\njulia> promote_type(Int64, Float16)\nFloat16\n\njulia> promote_type(Int8, UInt16)\nUInt16\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.promote_rule","page":"Essentials","title":"Base.promote_rule","text":"promote_rule(type1, type2)\n\nSpecifies what type should be used by promote when given values of types type1 and type2. This function should not be called directly, but should have definitions added to it for new types as appropriate.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.isdispatchtuple","page":"Essentials","title":"Base.isdispatchtuple","text":"isdispatchtuple(T)\n\nDetermine whether type T is a tuple \"leaf type\", meaning it could appear as a type signature in dispatch and has no subtypes (or supertypes) which could appear in a call.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Declared-structure-1","page":"Essentials","title":"Declared structure","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.isimmutable\nBase.isabstracttype\nBase.isprimitivetype\nBase.isstructtype\nBase.nameof(::DataType)\nBase.fieldnames\nBase.fieldname\nBase.hasfield","category":"page"},{"location":"base/base.html#Base.isimmutable","page":"Essentials","title":"Base.isimmutable","text":"isimmutable(v) -> Bool\n\nReturn true iff value v is immutable.  See Mutable Composite Types for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of DataType is mutable.\n\nExamples\n\njulia> isimmutable(1)\ntrue\n\njulia> isimmutable([1,2])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.isabstracttype","page":"Essentials","title":"Base.isabstracttype","text":"Base.isabstracttype(T)\n\nDetermine whether type T was declared as an abstract type (i.e. using the abstract keyword).\n\nExamples\n\njulia> Base.isabstracttype(AbstractArray)\ntrue\n\njulia> Base.isabstracttype(Vector)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.isprimitivetype","page":"Essentials","title":"Base.isprimitivetype","text":"Base.isprimitivetype(T) -> Bool\n\nDetermine whether type T was declared as a primitive type (i.e. using the primitive keyword).\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.isstructtype","page":"Essentials","title":"Base.isstructtype","text":"Base.isstructtype(T) -> Bool\n\nDetermine whether type T was declared as a struct type (i.e. using the struct or mutable struct keyword).\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.nameof-Tuple{DataType}","page":"Essentials","title":"Base.nameof","text":"nameof(t::DataType) -> Symbol\n\nGet the name of a (potentially UnionAll-wrapped) DataType (without its parent module) as a symbol.\n\nExamples\n\njulia> module Foo\n           struct S{T}\n           end\n       end\nFoo\n\njulia> nameof(Foo.S{T} where T)\n:S\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.fieldnames","page":"Essentials","title":"Base.fieldnames","text":"fieldnames(x::DataType)\n\nGet a tuple with the names of the fields of a DataType.\n\nExamples\n\njulia> fieldnames(Rational)\n(:num, :den)\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.fieldname","page":"Essentials","title":"Base.fieldname","text":"fieldname(x::DataType, i::Integer)\n\nGet the name of field i of a DataType.\n\nExamples\n\njulia> fieldname(Rational, 1)\n:num\n\njulia> fieldname(Rational, 2)\n:den\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.hasfield","page":"Essentials","title":"Base.hasfield","text":"hasfield(T::Type, name::Symbol)\n\nReturn a boolean indicating whether T has name as one of its own fields.\n\ncompat: Julia 1.2\nThis function requires at least Julia 1.2.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Memory-layout-1","page":"Essentials","title":"Memory layout","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.sizeof(::Type)\nBase.isconcretetype\nBase.isbits\nBase.isbitstype\nCore.fieldtype\nBase.fieldtypes\nBase.fieldcount\nBase.fieldoffset\nBase.datatype_alignment\nBase.datatype_haspadding\nBase.datatype_pointerfree","category":"page"},{"location":"base/base.html#Base.sizeof-Tuple{Type}","page":"Essentials","title":"Base.sizeof","text":"sizeof(T::DataType)\nsizeof(obj)\n\nSize, in bytes, of the canonical binary representation of the given DataType T, if any. Size, in bytes, of object obj if it is not DataType.\n\nExamples\n\njulia> sizeof(Float32)\n4\n\njulia> sizeof(ComplexF64)\n16\n\njulia> sizeof(1.0)\n8\n\njulia> sizeof([1.0:10.0;])\n80\n\nIf DataType T does not have a specific size, an error is thrown.\n\njulia> sizeof(AbstractArray)\nERROR: Abstract type AbstractArray does not have a definite size.\nStacktrace:\n[...]\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.isconcretetype","page":"Essentials","title":"Base.isconcretetype","text":"isconcretetype(T)\n\nDetermine whether type T is a concrete type, meaning it could have direct instances (values x such that typeof(x) === T).\n\nExamples\n\njulia> isconcretetype(Complex)\nfalse\n\njulia> isconcretetype(Complex{Float32})\ntrue\n\njulia> isconcretetype(Vector{Complex})\ntrue\n\njulia> isconcretetype(Vector{Complex{Float32}})\ntrue\n\njulia> isconcretetype(Union{})\nfalse\n\njulia> isconcretetype(Union{Int,String})\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.isbits","page":"Essentials","title":"Base.isbits","text":"isbits(x)\n\nReturn true if x is an instance of an isbitstype type.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.isbitstype","page":"Essentials","title":"Base.isbitstype","text":"isbitstype(T)\n\nReturn true if type T is a \"plain data\" type, meaning it is immutable and contains no references to other values, only primitive types and other isbitstype types. Typical examples are numeric types such as UInt8, Float64, and Complex{Float64}. This category of types is significant since they are valid as type parameters, may not track isdefined / isassigned status, and have a defined layout that is compatible with C.\n\nExamples\n\njulia> isbitstype(Complex{Float64})\ntrue\n\njulia> isbitstype(Complex)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.fieldtype","page":"Essentials","title":"Core.fieldtype","text":"fieldtype(T, name::Symbol | index::Int)\n\nDetermine the declared type of a field (specified by name or index) in a composite DataType T.\n\nExamples\n\njulia> struct Foo\n           x::Int64\n           y::String\n       end\n\njulia> fieldtype(Foo, :x)\nInt64\n\njulia> fieldtype(Foo, 2)\nString\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.fieldtypes","page":"Essentials","title":"Base.fieldtypes","text":"fieldtypes(T::Type)\n\nThe declared types of all fields in a composite DataType T as a tuple.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nExamples\n\njulia> struct Foo\n           x::Int64\n           y::String\n       end\n\njulia> fieldtypes(Foo)\n(Int64, String)\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.fieldcount","page":"Essentials","title":"Base.fieldcount","text":"fieldcount(t::Type)\n\nGet the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.fieldoffset","page":"Essentials","title":"Base.fieldoffset","text":"fieldoffset(type, i)\n\nThe byte offset of field i of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:\n\njulia> structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:fieldcount(T)];\n\njulia> structinfo(Base.Filesystem.StatStruct)\n12-element Array{Tuple{UInt64,Symbol,DataType},1}:\n (0x0000000000000000, :device, UInt64)\n (0x0000000000000008, :inode, UInt64)\n (0x0000000000000010, :mode, UInt64)\n (0x0000000000000018, :nlink, Int64)\n (0x0000000000000020, :uid, UInt64)\n (0x0000000000000028, :gid, UInt64)\n (0x0000000000000030, :rdev, UInt64)\n (0x0000000000000038, :size, Int64)\n (0x0000000000000040, :blksize, Int64)\n (0x0000000000000048, :blocks, Int64)\n (0x0000000000000050, :mtime, Float64)\n (0x0000000000000058, :ctime, Float64)\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.datatype_alignment","page":"Essentials","title":"Base.datatype_alignment","text":"Base.datatype_alignment(dt::DataType) -> Int\n\nMemory allocation minimum alignment for instances of this type. Can be called on any isconcretetype.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.datatype_haspadding","page":"Essentials","title":"Base.datatype_haspadding","text":"Base.datatype_haspadding(dt::DataType) -> Bool\n\nReturn whether the fields of instances of this type are packed in memory, with no intervening padding bytes. Can be called on any isconcretetype.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.datatype_pointerfree","page":"Essentials","title":"Base.datatype_pointerfree","text":"Base.datatype_pointerfree(dt::DataType) -> Bool\n\nReturn whether instances of this type can contain references to gc-managed memory. Can be called on any isconcretetype.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Special-values-1","page":"Essentials","title":"Special values","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.typemin\nBase.typemax\nBase.floatmin\nBase.floatmax\nBase.maxintfloat\nBase.eps(::Type{<:AbstractFloat})\nBase.eps(::AbstractFloat)\nBase.instances","category":"page"},{"location":"base/base.html#Base.typemin","page":"Essentials","title":"Base.typemin","text":"typemin(T)\n\nThe lowest value representable by the given (real) numeric DataType T.\n\nExamples\n\njulia> typemin(Float16)\n-Inf16\n\njulia> typemin(Float32)\n-Inf32\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.typemax","page":"Essentials","title":"Base.typemax","text":"typemax(T)\n\nThe highest value representable by the given (real) numeric DataType.\n\nExamples\n\njulia> typemax(Int8)\n127\n\njulia> typemax(UInt32)\n0xffffffff\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.floatmin","page":"Essentials","title":"Base.floatmin","text":"floatmin(T)\n\nThe smallest in absolute value non-subnormal value representable by the given floating-point DataType T.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.floatmax","page":"Essentials","title":"Base.floatmax","text":"floatmax(T)\n\nThe highest finite value representable by the given floating-point DataType T.\n\nExamples\n\njulia> floatmax(Float16)\nFloat16(6.55e4)\n\njulia> floatmax(Float32)\n3.4028235f38\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.maxintfloat","page":"Essentials","title":"Base.maxintfloat","text":"maxintfloat(T=Float64)\n\nThe largest consecutive integer-valued floating-point number that is exactly represented in the given floating-point type T (which defaults to Float64).\n\nThat is, maxintfloat returns the smallest positive integer-valued floating-point number n such that n+1 is not exactly representable in the type T.\n\nWhen an Integer-type value is needed, use Integer(maxintfloat(T)).\n\n\n\n\n\nmaxintfloat(T, S)\n\nThe largest consecutive integer representable in the given floating-point type T that also does not exceed the maximum integer representable by the integer type S.  Equivalently, it is the minimum of maxintfloat(T) and typemax(S).\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.eps-Tuple{Type{#s3} where #s3<:AbstractFloat}","page":"Essentials","title":"Base.eps","text":"eps(::Type{T}) where T<:AbstractFloat\neps()\n\nReturn the machine epsilon of the floating point type T (T = Float64 by default). This is defined as the gap between 1 and the next largest value representable by typeof(one(T)), and is equivalent to eps(one(T)).  (Since eps(T) is a bound on the relative error of T, it is a \"dimensionless\" quantity like one.)\n\nExamples\n\njulia> eps()\n2.220446049250313e-16\n\njulia> eps(Float32)\n1.1920929f-7\n\njulia> 1.0 + eps()\n1.0000000000000002\n\njulia> 1.0 + eps()/2\n1.0\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.eps-Tuple{AbstractFloat}","page":"Essentials","title":"Base.eps","text":"eps(x::AbstractFloat)\n\nReturn the unit in last place (ulp) of x. This is the distance between consecutive representable floating point values at x. In most cases, if the distance on either side of x is different, then the larger of the two is taken, that is\n\neps(x) == max(x-prevfloat(x), nextfloat(x)-x)\n\nThe exceptions to this rule are the smallest and largest finite values (e.g. nextfloat(-Inf) and prevfloat(Inf) for Float64), which round to the smaller of the values.\n\nThe rationale for this behavior is that eps bounds the floating point rounding error. Under the default RoundNearest rounding mode, if y is a real number and x is the nearest floating point number to y, then\n\ny-x leq operatornameeps(x)2\n\nExamples\n\njulia> eps(1.0)\n2.220446049250313e-16\n\njulia> eps(prevfloat(2.0))\n2.220446049250313e-16\n\njulia> eps(2.0)\n4.440892098500626e-16\n\njulia> x = prevfloat(Inf)      # largest finite Float64\n1.7976931348623157e308\n\njulia> x + eps(x)/2            # rounds up\nInf\n\njulia> x + prevfloat(eps(x)/2) # rounds down\n1.7976931348623157e308\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.instances","page":"Essentials","title":"Base.instances","text":"instances(T::Type)\n\nReturn a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see @enum).\n\nExample\n\njulia> @enum Color red blue green\n\njulia> instances(Color)\n(red, blue, green)\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Special-Types-1","page":"Essentials","title":"Special Types","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Core.Any\nCore.Union\nUnion{}\nCore.UnionAll\nCore.Tuple\nCore.NamedTuple\nBase.Val\nCore.Vararg\nCore.Nothing\nBase.isnothing\nBase.Some\nBase.something\nBase.Enums.Enum\nBase.Enums.@enum\nCore.Expr\nCore.Symbol\nCore.Symbol(x...)\nCore.Module","category":"page"},{"location":"base/base.html#Core.Any","page":"Essentials","title":"Core.Any","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.Union","page":"Essentials","title":"Core.Union","text":"Union{Types...}\n\nA type union is an abstract type which includes all instances of any of its argument types. The empty union Union{} is the bottom type of Julia.\n\nExamples\n\njulia> IntOrString = Union{Int,AbstractString}\nUnion{Int64, AbstractString}\n\njulia> 1 :: IntOrString\n1\n\njulia> \"Hello!\" :: IntOrString\n\"Hello!\"\n\njulia> 1.0 :: IntOrString\nERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Union{}","page":"Essentials","title":"Union{}","text":"Union{}\n\nUnion{}, the empty Union of types, is the type that has no values. That is, it has the defining property isa(x, Union{}) == false for any x. Base.Bottom is defined as its alias and the type of Union{} is Core.TypeofBottom.\n\nExamples\n\njulia> isa(nothing, Union{})\nfalse\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#Core.UnionAll","page":"Essentials","title":"Core.UnionAll","text":"UnionAll\n\nA union of types over all values of a type parameter. UnionAll is used to describe parametric types where the values of some parameters are not known.\n\nExamples\n\njulia> typeof(Vector)\nUnionAll\n\njulia> typeof(Vector{Int})\nDataType\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.Tuple","page":"Essentials","title":"Core.Tuple","text":"Tuple{Types...}\n\nTuples are an abstraction of the arguments of a function – without the function itself. The salient aspects of a function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. Tuple types may have any number of parameters.\n\nTuple types are covariant in their parameters: Tuple{Int} is a subtype of Tuple{Any}. Therefore Tuple{Any} is considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have field names; fields are only accessed by index.\n\nSee the manual section on Tuple Types.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.NamedTuple","page":"Essentials","title":"Core.NamedTuple","text":"NamedTuple\n\nNamedTuples are, as their name suggests, named Tuples. That is, they're a tuple-like collection of values, where each entry has a unique name, represented as a Symbol. Like Tuples, NamedTuples are immutable; neither the names nor the values can be modified in place after construction.\n\nAccessing the value associated with a name in a named tuple can be done using field access syntax, e.g. x.a, or using getindex, e.g. x[:a]. A tuple of the names can be obtained using keys, and a tuple of the values can be obtained using values.\n\nnote: Note\nIteration over NamedTuples produces the values without the names. (See example below.) To iterate over the name-value pairs, use the pairs function.\n\nExamples\n\njulia> x = (a=1, b=2)\n(a = 1, b = 2)\n\njulia> x.a\n1\n\njulia> x[:a]\n1\n\njulia> keys(x)\n(:a, :b)\n\njulia> values(x)\n(1, 2)\n\njulia> collect(x)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> collect(pairs(x))\n2-element Array{Pair{Symbol,Int64},1}:\n :a => 1\n :b => 2\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.Val","page":"Essentials","title":"Base.Val","text":"Val(c)\n\nReturn Val{c}(), which contains no run-time data. Types like this can be used to pass the information between functions through the value c, which must be an isbits value. The intent of this construct is to be able to dispatch on constants directly (at compile time) without having to test the value of the constant at run time.\n\nExamples\n\njulia> f(::Val{true}) = \"Good\"\nf (generic function with 1 method)\n\njulia> f(::Val{false}) = \"Bad\"\nf (generic function with 2 methods)\n\njulia> f(Val(true))\n\"Good\"\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.Vararg","page":"Essentials","title":"Core.Vararg","text":"Vararg{T,N}\n\nThe last parameter of a tuple type Tuple can be the special type Vararg, which denotes any number of trailing elements. The type Vararg{T,N} corresponds to exactly N elements of type T. Vararg{T} corresponds to zero or more elements of type T. Vararg tuple types are used to represent the arguments accepted by varargs methods (see the section on Varargs Functions in the manual.)\n\nExamples\n\njulia> mytupletype = Tuple{AbstractString,Vararg{Int}}\nTuple{AbstractString,Vararg{Int64,N} where N}\n\njulia> isa((\"1\",), mytupletype)\ntrue\n\njulia> isa((\"1\",1), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2,3.0), mytupletype)\nfalse\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.Nothing","page":"Essentials","title":"Core.Nothing","text":"Nothing\n\nA type with no fields that is the type of nothing.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.isnothing","page":"Essentials","title":"Base.isnothing","text":"isnothing(x)\n\nReturn true if x === nothing, and return false if not.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Some","page":"Essentials","title":"Base.Some","text":"Some{T}\n\nA wrapper type used in Union{Some{T}, Nothing} to distinguish between the absence of a value (nothing) and the presence of a nothing value (i.e. Some(nothing)).\n\nUse something to access the value wrapped by a Some object.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.something","page":"Essentials","title":"Base.something","text":"something(x, y...)\n\nReturn the first value in the arguments which is not equal to nothing, if any. Otherwise throw an error. Arguments of type Some are unwrapped.\n\nExamples\n\njulia> something(nothing, 1)\n1\n\njulia> something(Some(1), nothing)\n1\n\njulia> something(missing, nothing)\nmissing\n\njulia> something(nothing, nothing)\nERROR: ArgumentError: No value arguments present\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Enums.Enum","page":"Essentials","title":"Base.Enums.Enum","text":"Enum{T<:Integer}\n\nThe abstract supertype of all enumerated types defined with @enum.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.Enums.@enum","page":"Essentials","title":"Base.Enums.@enum","text":"@enum EnumName[::BaseType] value1[=x] value2[=y]\n\nCreate an Enum{BaseType} subtype with name EnumName and enum member values of value1 and value2 with optional assigned values of x and y, respectively. EnumName can be used just like other types and enum member values as regular values, such as\n\nExamples\n\njulia> @enum Fruit apple=1 orange=2 kiwi=3\n\njulia> f(x::Fruit) = \"I'm a Fruit with value: $(Int(x))\"\nf (generic function with 1 method)\n\njulia> f(apple)\n\"I'm a Fruit with value: 1\"\n\njulia> Fruit(1)\napple::Fruit = 1\n\nValues can also be specified inside a begin block, e.g.\n\n@enum EnumName begin\n    value1\n    value2\nend\n\nBaseType, which defaults to Int32, must be a primitive subtype of Integer. Member values can be converted between the enum type and BaseType. read and write perform these conversions automatically.\n\nTo list all the instances of an enum use instances, e.g.\n\njulia> instances(Fruit)\n(apple, orange, kiwi)\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Core.Expr","page":"Essentials","title":"Core.Expr","text":"Expr(head::Symbol, args...)\n\nA type representing compound expressions in parsed julia code (ASTs). Each expression consists of a head Symbol identifying which kind of expression it is (e.g. a call, for loop, conditional statement, etc.), and subexpressions (e.g. the arguments of a call). The subexpressions are stored in a Vector{Any} field called args.\n\nSee the manual chapter on Metaprogramming and the developer documentation Julia ASTs.\n\nExamples\n\njulia> Expr(:call, :+, 1, 2)\n:(1 + 2)\n\njulia> dump(:(a ? b : c))\nExpr\n  head: Symbol if\n  args: Array{Any}((3,))\n    1: Symbol a\n    2: Symbol b\n    3: Symbol c\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.Symbol","page":"Essentials","title":"Core.Symbol","text":"Symbol\n\nThe type of object used to represent identifiers in parsed julia code (ASTs). Also often used as a name or label to identify an entity (e.g. as a dictionary key). Symbols can be entered using the : quote operator:\n\njulia> :name\n:name\n\njulia> typeof(:name)\nSymbol\n\njulia> x = 42\n42\n\njulia> eval(:x)\n42\n\nSymbols can also be constructed from strings or other values by calling the constructor Symbol(x...).\n\nSymbols are immutable and should be compared using ===. The implementation re-uses the same object for all Symbols with the same name, so comparison tends to be efficient (it can just compare pointers).\n\nUnlike strings, Symbols are \"atomic\" or \"scalar\" entities that do not support iteration over characters.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.Symbol-Tuple","page":"Essentials","title":"Core.Symbol","text":"Symbol(x...) -> Symbol\n\nCreate a Symbol by concatenating the string representations of the arguments together.\n\nExamples\n\njulia> Symbol(\"my\", \"name\")\n:myname\n\njulia> Symbol(\"day\", 4)\n:day4\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Core.Module","page":"Essentials","title":"Core.Module","text":"Module\n\nA Module is a separate global variable workspace. See module and the manual section about modules for details.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Generic-Functions-1","page":"Essentials","title":"Generic Functions","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Core.Function\nBase.hasmethod\nCore.applicable\nCore.invoke\nBase.invokelatest\nnew\nBase.:(|>)\nBase.:(∘)","category":"page"},{"location":"base/base.html#Core.Function","page":"Essentials","title":"Core.Function","text":"Function\n\nAbstract type of all functions.\n\nExamples\n\njulia> isa(+, Function)\ntrue\n\njulia> typeof(sin)\ntypeof(sin)\n\njulia> ans <: Function\ntrue\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.hasmethod","page":"Essentials","title":"Base.hasmethod","text":"hasmethod(f, t::Type{<:Tuple}[, kwnames]; world=typemax(UInt)) -> Bool\n\nDetermine whether the given generic function has a method matching the given Tuple of argument types with the upper bound of world age given by world.\n\nIf a tuple of keyword argument names kwnames is provided, this also checks whether the method of f matching t has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with kwargs..., any names given in kwnames are considered valid. Otherwise the provided names must be a subset of the method's keyword arguments.\n\nSee also applicable.\n\ncompat: Julia 1.2\nProviding keyword argument names requires Julia 1.2 or later.\n\nExamples\n\njulia> hasmethod(length, Tuple{Array})\ntrue\n\njulia> hasmethod(sum, Tuple{Function, Array}, (:dims,))\ntrue\n\njulia> hasmethod(sum, Tuple{Function, Array}, (:apples, :bananas))\nfalse\n\njulia> g(; xs...) = 4;\n\njulia> hasmethod(g, Tuple{}, (:a, :b, :c, :d))  # g accepts arbitrary kwargs\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.applicable","page":"Essentials","title":"Core.applicable","text":"applicable(f, args...) -> Bool\n\nDetermine whether the given generic function has a method applicable to the given arguments.\n\nSee also hasmethod.\n\nExamples\n\njulia> function f(x, y)\n           x + y\n       end;\n\njulia> applicable(f, 1)\nfalse\n\njulia> applicable(f, 1, 2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.invoke","page":"Essentials","title":"Core.invoke","text":"invoke(f, argtypes::Type, args...; kwargs...)\n\nInvoke a method for the given generic function f matching the specified types argtypes on the specified arguments args and passing the keyword arguments kwargs. The arguments args must conform with the specified types in argtypes, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).\n\nExamples\n\njulia> f(x::Real) = x^2;\n\njulia> f(x::Integer) = 1 + invoke(f, Tuple{Real}, x);\n\njulia> f(2)\n5\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.invokelatest","page":"Essentials","title":"Base.invokelatest","text":"invokelatest(f, args...; kwargs...)\n\nCalls f(args...; kwargs...), but guarantees that the most recent method of f will be executed.   This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function f. (The drawback is that invokelatest is somewhat slower than calling f directly, and the type of the result cannot be inferred by the compiler.)\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#new","page":"Essentials","title":"new","text":"new\n\nSpecial function available to inner constructors which created a new object of the type. See the manual section on Inner Constructor Methods for more information.\n\n\n\n\n\n","category":"keyword"},{"location":"base/base.html#Base.:|>","page":"Essentials","title":"Base.:|>","text":"|>(x, f)\n\nApplies a function to the preceding argument. This allows for easy function chaining.\n\nExamples\n\njulia> [1:5;] |> x->x.^2 |> sum |> inv\n0.01818181818181818\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.:∘","page":"Essentials","title":"Base.:∘","text":"f ∘ g\n\nCompose functions: i.e. (f ∘ g)(args...) means f(g(args...)). The ∘ symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing \\circ<tab>.\n\nExamples\n\njulia> map(uppercase∘first, [\"apple\", \"banana\", \"carrot\"])\n3-element Array{Char,1}:\n 'A'\n 'B'\n 'C'\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Syntax-1","page":"Essentials","title":"Syntax","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Core.eval\nBase.MainInclude.eval\nBase.@eval\nBase.evalfile\nBase.esc\nBase.@inbounds\nBase.@boundscheck\nBase.@propagate_inbounds\nBase.@inline\nBase.@noinline\nBase.@nospecialize\nBase.@specialize\nBase.gensym\nBase.@gensym\nBase.@goto\nBase.@label\nBase.@simd\nBase.@polly\nBase.@generated\nBase.@pure\nBase.@deprecate","category":"page"},{"location":"base/base.html#Core.eval","page":"Essentials","title":"Core.eval","text":"Core.eval(m::Module, expr)\n\nEvaluate an expression in the given module and return the result.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.MainInclude.eval","page":"Essentials","title":"Base.MainInclude.eval","text":"eval(expr)\n\nEvaluate an expression in the global scope of the containing module. Every Module (except those defined with baremodule) has its own 1-argument definition of eval, which evaluates expressions in that module.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.@eval","page":"Essentials","title":"Base.@eval","text":"@eval [mod,] ex\n\nEvaluate an expression with values interpolated into it using eval. If two arguments are provided, the first is the module to evaluate in.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.evalfile","page":"Essentials","title":"Base.evalfile","text":"evalfile(path::AbstractString, args::Vector{String}=String[])\n\nLoad the file using include, evaluate all expressions, and return the value of the last one.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.esc","page":"Essentials","title":"Base.esc","text":"esc(e)\n\nOnly valid in the context of an Expr returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the Macros section of the Metaprogramming chapter of the manual for more details and examples.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.@inbounds","page":"Essentials","title":"Base.@inbounds","text":"@inbounds(blk)\n\nEliminates array bounds checking within expressions.\n\nIn the example below the in-range check for referencing element i of array A is skipped to improve performance.\n\nfunction sum(A::AbstractArray)\n    r = zero(eltype(A))\n    for i = 1:length(A)\n        @inbounds r += A[i]\n    end\n    return r\nend\n\nwarning: Warning\nUsing @inbounds may return incorrect results/crashes/corruption for out-of-bounds indices. The user is responsible for checking it manually. Only use @inbounds when it is certain from the information locally available that all accesses are in bounds.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@boundscheck","page":"Essentials","title":"Base.@boundscheck","text":"@boundscheck(blk)\n\nAnnotates the expression blk as a bounds checking block, allowing it to be elided by @inbounds.\n\nnote: Note\nThe function in which @boundscheck is written must be inlined into its caller in order for @inbounds to have effect.\n\nExamples\n\njulia> @inline function g(A, i)\n           @boundscheck checkbounds(A, i)\n           return \"accessing ($A)[$i]\"\n       end;\n\njulia> f1() = return g(1:2, -1);\n\njulia> f2() = @inbounds return g(1:2, -1);\n\njulia> f1()\nERROR: BoundsError: attempt to access 2-element UnitRange{Int64} at index [-1]\nStacktrace:\n [1] throw_boundserror(::UnitRange{Int64}, ::Tuple{Int64}) at ./abstractarray.jl:455\n [2] checkbounds at ./abstractarray.jl:420 [inlined]\n [3] g at ./none:2 [inlined]\n [4] f1() at ./none:1\n [5] top-level scope\n\njulia> f2()\n\"accessing (1:2)[-1]\"\n\nwarning: Warning\nThe @boundscheck annotation allows you, as a library writer, to opt-in to allowing other code to remove your bounds checks with @inbounds. As noted there, the caller must verify—using information they can access—that their accesses are valid before using @inbounds. For indexing into your AbstractArray subclasses, for example, this involves checking the indices against its size. Therefore, @boundscheck annotations should only be added to a getindex or setindex! implementation after you are certain its behavior is correct.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@propagate_inbounds","page":"Essentials","title":"Base.@propagate_inbounds","text":"@propagate_inbounds\n\nTells the compiler to inline a function while retaining the caller's inbounds context.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@inline","page":"Essentials","title":"Base.@inline","text":"@inline\n\nGive a hint to the compiler that this function is worth inlining.\n\nSmall functions typically do not need the @inline annotation, as the compiler does it automatically. By using @inline on bigger functions, an extra nudge can be given to the compiler to inline it. This is shown in the following example:\n\n@inline function bigfunction(x)\n    #=\n        Function Definition\n    =#\nend\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@noinline","page":"Essentials","title":"Base.@noinline","text":"@noinline\n\nPrevents the compiler from inlining a function.\n\nSmall functions are typically inlined automatically. By using @noinline on small functions, auto-inlining can be prevented. This is shown in the following example:\n\n@noinline function smallfunction(x)\n    #=\n        Function Definition\n    =#\nend\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@nospecialize","page":"Essentials","title":"Base.@nospecialize","text":"@nospecialize\n\nApplied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.\n\nWhen used without arguments, it applies to all arguments of the parent scope. In local scope, this means all arguments of the containing function. In global (top-level) scope, this means all methods subsequently defined in the current module.\n\nSpecialization can reset back to the default by using @specialize.\n\nfunction example_function(@nospecialize x)\n    ...\nend\n\nfunction example_function(@nospecialize(x = 1), y)\n    ...\nend\n\nfunction example_function(x, y, z)\n    @nospecialize x y\n    ...\nend\n\n@nospecialize\nf(y) = [x for x in y]\n@specialize\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@specialize","page":"Essentials","title":"Base.@specialize","text":"@specialize\n\nReset the specialization hint for an argument back to the default. For details, see @nospecialize.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.gensym","page":"Essentials","title":"Base.gensym","text":"gensym([tag])\n\nGenerates a symbol which will not conflict with other variable names.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.@gensym","page":"Essentials","title":"Base.@gensym","text":"@gensym\n\nGenerates a gensym symbol for a variable. For example, @gensym x y is transformed into x = gensym(\"x\"); y = gensym(\"y\").\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@goto","page":"Essentials","title":"Base.@goto","text":"@goto name\n\n@goto name unconditionally jumps to the statement at the location @label name.\n\n@label and @goto cannot create jumps to different top-level statements. Attempts cause an error. To still use @goto, enclose the @label and @goto in a block.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@label","page":"Essentials","title":"Base.@label","text":"@label name\n\nLabels a statement with the symbolic label name. The label marks the end-point of an unconditional jump with @goto name.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.SimdLoop.@simd","page":"Essentials","title":"Base.SimdLoop.@simd","text":"@simd\n\nAnnotate a for loop to allow the compiler to take extra liberties to allow loop re-ordering\n\nwarning: Warning\nThis feature is experimental and could change or disappear in future versions of Julia. Incorrect use of the @simd macro may cause unexpected results.\n\nThe object iterated over in a @simd for loop should be a one-dimensional range. By using @simd, you are asserting several properties of the loop:\n\nIt is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.\nFloating-point operations on reduction variables can be reordered, possibly causing different results than without @simd.\n\nIn many cases, Julia is able to automatically vectorize inner for loops without the use of @simd. Using @simd gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:\n\nThe loop must be an innermost loop\nThe loop body must be straight-line code. Therefore, @inbounds is   currently needed for all array accesses. The compiler can sometimes turn   short &&, ||, and ?: expressions into straight-line code if it is safe   to evaluate all operands unconditionally. Consider using the ifelse   function instead of ?: in the loop if it is safe to do so.\nAccesses must have a stride pattern and cannot be \"gathers\" (random-index   reads) or \"scatters\" (random-index writes).\nThe stride should be unit stride.\n\nnote: Note\nThe @simd does not assert by default that the loop is completely free of loop-carried memory dependencies, which is an assumption that can easily be violated in generic code. If you are writing non-generic code, you can use @simd ivdep for ... end to also assert that:\n\nThere exists no loop-carried memory dependencies\nNo iteration ever waits on a previous iteration to make forward progress.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@polly","page":"Essentials","title":"Base.@polly","text":"@polly\n\nTells the compiler to apply the polyhedral optimizer Polly to a function.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@generated","page":"Essentials","title":"Base.@generated","text":"@generated f\n@generated(f)\n\n@generated is used to annotate a function which will be generated. In the body of the generated function, only types of arguments can be read (not the values). The function returns a quoted expression evaluated when the function is called. The @generated macro should not be used on functions mutating the global scope or depending on mutable elements.\n\nSee Metaprogramming for further details.\n\nExample:\n\njulia> @generated function bar(x)\n           if x <: Integer\n               return :(x ^ 2)\n           else\n               return :(x)\n           end\n       end\nbar (generic function with 1 method)\n\njulia> bar(4)\n16\n\njulia> bar(\"baz\")\n\"baz\"\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@pure","page":"Essentials","title":"Base.@pure","text":"@pure ex\n@pure(ex)\n\n@pure gives the compiler a hint for the definition of a pure function, helping for type inference.\n\nA pure function can only depend on immutable information. This also means a @pure function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect @pure annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@deprecate","page":"Essentials","title":"Base.@deprecate","text":"@deprecate old new [ex=true]\n\nThe first argument old is the signature of the deprecated method, the second one new is the call which replaces it. @deprecate exports old unless the optional third argument is false.\n\nExamples\n\njulia> @deprecate old(x) new(x)\nold (generic function with 1 method)\n\njulia> @deprecate old(x) new(x) false\nold (generic function with 1 method)\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Missing-Values-1","page":"Essentials","title":"Missing Values","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.Missing\nBase.missing\nBase.coalesce\nBase.ismissing\nBase.skipmissing","category":"page"},{"location":"base/base.html#Base.Missing","page":"Essentials","title":"Base.Missing","text":"Missing\n\nA type with no fields whose singleton instance missing is used to represent missing values.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.missing","page":"Essentials","title":"Base.missing","text":"missing\n\nThe singleton instance of type Missing representing a missing value.\n\n\n\n\n\n","category":"constant"},{"location":"base/base.html#Base.coalesce","page":"Essentials","title":"Base.coalesce","text":"coalesce(x, y...)\n\nReturn the first value in the arguments which is not equal to missing, if any. Otherwise return missing.\n\nExamples\n\njulia> coalesce(missing, 1)\n1\n\njulia> coalesce(1, missing)\n1\n\njulia> coalesce(nothing, 1)  # returns `nothing`\n\njulia> coalesce(missing, missing)\nmissing\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.ismissing","page":"Essentials","title":"Base.ismissing","text":"ismissing(x)\n\nIndicate whether x is missing.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.skipmissing","page":"Essentials","title":"Base.skipmissing","text":"skipmissing(itr)\n\nReturn an iterator over the elements in itr skipping missing values. The returned object can be indexed using indices of itr if the latter is indexable. Indices corresponding to missing values are not valid: they are skipped by keys and eachindex, and a MissingException is thrown when trying to use them.\n\nUse collect to obtain an Array containing the non-missing values in itr. Note that even if itr is a multidimensional array, the result will always be a Vector since it is not possible to remove missings while preserving dimensions of the input.\n\nExamples\n\njulia> x = skipmissing([1, missing, 2])\nBase.SkipMissing{Array{Union{Missing, Int64},1}}(Union{Missing, Int64}[1, missing, 2])\n\njulia> sum(x)\n3\n\njulia> x[1]\n1\n\njulia> x[2]\nERROR: MissingException: the value at index (2,) is missing\n[...]\n\njulia> argmax(x)\n3\n\njulia> collect(keys(x))\n2-element Array{Int64,1}:\n 1\n 3\n\njulia> collect(skipmissing([1, missing, 2]))\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> collect(skipmissing([1 missing; 2 missing]))\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#System-1","page":"Essentials","title":"System","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.run\nBase.devnull\nBase.success\nBase.process_running\nBase.process_exited\nBase.kill(::Base.Process, ::Integer)\nBase.Sys.set_process_title\nBase.Sys.get_process_title\nBase.ignorestatus\nBase.detach\nBase.Cmd\nBase.setenv\nBase.withenv\nBase.pipeline(::Any, ::Any, ::Any, ::Any...)\nBase.pipeline(::Base.AbstractCmd)\nBase.Libc.gethostname\nBase.Libc.getpid\nBase.Libc.time()\nBase.time_ns\nBase.@time\nBase.@timev\nBase.@timed\nBase.@elapsed\nBase.@allocated\nBase.EnvDict\nBase.ENV\nBase.Sys.isunix\nBase.Sys.isapple\nBase.Sys.islinux\nBase.Sys.isbsd\nBase.Sys.isfreebsd\nBase.Sys.isopenbsd\nBase.Sys.isnetbsd\nBase.Sys.isdragonfly\nBase.Sys.iswindows\nBase.Sys.windows_version\nBase.Sys.free_memory\nBase.Sys.total_memory\nBase.@static","category":"page"},{"location":"base/base.html#Base.run","page":"Essentials","title":"Base.run","text":"run(command, args...; wait::Bool = true)\n\nRun a command object, constructed with backticks (see the Running External Programs section in the manual). Throws an error if anything goes wrong, including the process exiting with a non-zero status (when wait is true).\n\nIf wait is false, the process runs asynchronously. You can later wait for it and check its exit status by calling success on the returned process object.\n\nWhen wait is false, the process' I/O streams are directed to devnull. When wait is true, I/O streams are shared with the parent process. Use pipeline to control I/O redirection.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.devnull","page":"Essentials","title":"Base.devnull","text":"devnull\n\nUsed in a stream redirect to discard all data written to it. Essentially equivalent to /dev/null on Unix or NUL on Windows. Usage:\n\nrun(pipeline(`cat test.txt`, devnull))\n\n\n\n\n\n","category":"constant"},{"location":"base/base.html#Base.success","page":"Essentials","title":"Base.success","text":"success(command)\n\nRun a command object, constructed with backticks (see the Running External Programs section in the manual), and tell whether it was successful (exited with a code of 0). An exception is raised if the process cannot be started.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.process_running","page":"Essentials","title":"Base.process_running","text":"process_running(p::Process)\n\nDetermine whether a process is currently running.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.process_exited","page":"Essentials","title":"Base.process_exited","text":"process_exited(p::Process)\n\nDetermine whether a process has exited.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.kill-Tuple{Base.Process,Integer}","page":"Essentials","title":"Base.kill","text":"kill(p::Process, signum=SIGTERM)\n\nSend a signal to a process. The default is to terminate the process. Returns successfully if the process has already exited, but throws an error if killing the process failed for other reasons (e.g. insufficient permissions).\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.Sys.set_process_title","page":"Essentials","title":"Base.Sys.set_process_title","text":"Sys.set_process_title(title::AbstractString)\n\nSet the process title. No-op on some operating systems.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Sys.get_process_title","page":"Essentials","title":"Base.Sys.get_process_title","text":"Sys.get_process_title()\n\nGet the process title. On some systems, will always return an empty string.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.ignorestatus","page":"Essentials","title":"Base.ignorestatus","text":"ignorestatus(command)\n\nMark a command object so that running it will not throw an error if the result code is non-zero.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.detach","page":"Essentials","title":"Base.detach","text":"detach(command)\n\nMark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Cmd","page":"Essentials","title":"Base.Cmd","text":"Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)\n\nConstruct a new Cmd object, representing an external program and arguments, from cmd, while changing the settings of the optional keyword arguments:\n\nignorestatus::Bool: If true (defaults to false), then the Cmd will not throw an error if the return code is nonzero.\ndetach::Bool: If true (defaults to false), then the Cmd will be run in a new process group, allowing it to outlive the julia process and not have Ctrl-C passed to it.\nwindows_verbatim::Bool: If true (defaults to false), then on Windows the Cmd will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single \"command-line\" string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes \" in the command line, and \\ or \" are preceded by backslashes. windows_verbatim=true is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.\nwindows_hide::Bool: If true (defaults to false), then on Windows no new console window is displayed when the Cmd is executed. This has no effect if a console is already open or on non-Windows systems.\nenv: Set environment variables to use when running the Cmd. env is either a dictionary mapping strings to strings, an array of strings of the form \"var=val\", an array or tuple of \"var\"=>val pairs, or nothing. In order to modify (rather than replace) the existing environment, create env by copy(ENV) and then set env[\"var\"]=val as desired.\ndir::AbstractString: Specify a working directory for the command (instead of the current directory).\n\nFor any keywords that are not specified, the current settings from cmd are used. Normally, to create a Cmd object in the first place, one uses backticks, e.g.\n\nCmd(`echo \"Hello world\"`, ignorestatus=true, detach=false)\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.setenv","page":"Essentials","title":"Base.setenv","text":"setenv(command::Cmd, env; dir=\"\")\n\nSet environment variables to use when running the given command. env is either a dictionary mapping strings to strings, an array of strings of the form \"var=val\", or zero or more \"var\"=>val pair arguments. In order to modify (rather than replace) the existing environment, create env by copy(ENV) and then setting env[\"var\"]=val as desired, or use withenv.\n\nThe dir keyword argument can be used to specify a working directory for the command.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.withenv","page":"Essentials","title":"Base.withenv","text":"withenv(f::Function, kv::Pair...)\n\nExecute f in an environment that is temporarily modified (not replaced as in setenv) by zero or more \"var\"=>val arguments kv. withenv is generally used via the withenv(kv...) do ... end syntax. A value of nothing can be used to temporarily unset an environment variable (if it is set). When withenv returns, the original environment has been restored.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.pipeline-Tuple{Any,Any,Any,Vararg{Any,N} where N}","page":"Essentials","title":"Base.pipeline","text":"pipeline(from, to, ...)\n\nCreate a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other pipeline calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example, pipeline(a,b,c) is equivalent to pipeline(pipeline(a,b),c). This provides a more concise way to specify multi-stage pipelines.\n\nExamples:\n\nrun(pipeline(`ls`, `grep xyz`))\nrun(pipeline(`ls`, \"out.txt\"))\nrun(pipeline(\"out.txt\", `grep xyz`))\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.pipeline-Tuple{Base.AbstractCmd}","page":"Essentials","title":"Base.pipeline","text":"pipeline(command; stdin, stdout, stderr, append=false)\n\nRedirect I/O to or from the given command. Keyword arguments specify which of the command's streams should be redirected. append controls whether file output appends to the file. This is a more general version of the 2-argument pipeline function. pipeline(from, to) is equivalent to pipeline(from, stdout=to) when from is a command, and to pipeline(to, stdin=from) when from is another kind of data source.\n\nExamples:\n\nrun(pipeline(`dothings`, stdout=\"out.txt\", stderr=\"errs.txt\"))\nrun(pipeline(`update`, stdout=\"log.txt\", append=true))\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.Libc.gethostname","page":"Essentials","title":"Base.Libc.gethostname","text":"gethostname() -> AbstractString\n\nGet the local machine's host name.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Libc.getpid","page":"Essentials","title":"Base.Libc.getpid","text":"getpid(process) -> Int32\n\nGet the child process ID, if it still exists.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\ngetpid() -> Int32\n\nGet Julia's process ID.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Libc.time-Tuple{}","page":"Essentials","title":"Base.Libc.time","text":"time()\n\nGet the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.time_ns","page":"Essentials","title":"Base.time_ns","text":"time_ns()\n\nGet the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.@time","page":"Essentials","title":"Base.@time","text":"@time\n\nA macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.\n\nSee also @timev, @timed, @elapsed, and @allocated.\n\njulia> @time rand(10^6);\n  0.001525 seconds (7 allocations: 7.630 MiB)\n\njulia> @time begin\n           sleep(0.3)\n           1+1\n       end\n  0.301395 seconds (8 allocations: 336 bytes)\n2\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@timev","page":"Essentials","title":"Base.@timev","text":"@timev\n\nThis is a verbose version of the @time macro. It first prints the same information as @time, then any non-zero memory allocation counters, and then returns the value of the expression.\n\nSee also @time, @timed, @elapsed, and @allocated.\n\njulia> @timev rand(10^6);\n  0.001006 seconds (7 allocations: 7.630 MiB)\nelapsed time (ns): 1005567\nbytes allocated:   8000256\npool allocs:       6\nmalloc() calls:    1\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@timed","page":"Essentials","title":"Base.@timed","text":"@timed\n\nA macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.\n\nSee also @time, @timev, @elapsed, and @allocated.\n\njulia> val, t, bytes, gctime, memallocs = @timed rand(10^6);\n\njulia> t\n0.006634834\n\njulia> bytes\n8000256\n\njulia> gctime\n0.0055765\n\njulia> fieldnames(typeof(memallocs))\n(:allocd, :malloc, :realloc, :poolalloc, :bigalloc, :freecall, :total_time, :pause, :full_sweep)\n\njulia> memallocs.total_time\n5576500\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@elapsed","page":"Essentials","title":"Base.@elapsed","text":"@elapsed\n\nA macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.\n\nSee also @time, @timev, @timed, and @allocated.\n\njulia> @elapsed sleep(0.3)\n0.301391426\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@allocated","page":"Essentials","title":"Base.@allocated","text":"@allocated\n\nA macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the @time macros, which do not try to adjust for the effects of compilation.\n\nSee also @time, @timev, @timed, and @elapsed.\n\njulia> @allocated rand(10^6)\n8000080\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.EnvDict","page":"Essentials","title":"Base.EnvDict","text":"EnvDict() -> EnvDict\n\nA singleton of this type provides a hash table interface to environment variables.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.ENV","page":"Essentials","title":"Base.ENV","text":"ENV\n\nReference to the singleton EnvDict, providing a dictionary interface to system environment variables.\n\n(On Windows, system environment variables are case-insensitive, and ENV correspondingly converts all keys to uppercase for display, iteration, and copying. Portable code should not rely on the ability to distinguish variables by case, and should beware that setting an ostensibly lowercase variable may result in an uppercase ENV key.)\n\n\n\n\n\n","category":"constant"},{"location":"base/base.html#Base.Sys.isunix","page":"Essentials","title":"Base.Sys.isunix","text":"Sys.isunix([os])\n\nPredicate for testing if the OS provides a Unix-like interface. See documentation in Handling Operating System Variation.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Sys.isapple","page":"Essentials","title":"Base.Sys.isapple","text":"Sys.isapple([os])\n\nPredicate for testing if the OS is a derivative of Apple Macintosh OS X or Darwin. See documentation in Handling Operating System Variation.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Sys.islinux","page":"Essentials","title":"Base.Sys.islinux","text":"Sys.islinux([os])\n\nPredicate for testing if the OS is a derivative of Linux. See documentation in Handling Operating System Variation.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Sys.isbsd","page":"Essentials","title":"Base.Sys.isbsd","text":"Sys.isbsd([os])\n\nPredicate for testing if the OS is a derivative of BSD. See documentation in Handling Operating System Variation.\n\nnote: Note\nThe Darwin kernel descends from BSD, which means that Sys.isbsd() is true on macOS systems. To exclude macOS from a predicate, use Sys.isbsd() && !Sys.isapple().\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Sys.isfreebsd","page":"Essentials","title":"Base.Sys.isfreebsd","text":"Sys.isfreebsd([os])\n\nPredicate for testing if the OS is a derivative of FreeBSD. See documentation in Handling Operating System Variation.\n\nnote: Note\nNot to be confused with Sys.isbsd(), which is true on FreeBSD but also on other BSD-based systems. Sys.isfreebsd() refers only to FreeBSD.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Sys.isopenbsd","page":"Essentials","title":"Base.Sys.isopenbsd","text":"Sys.isopenbsd([os])\n\nPredicate for testing if the OS is a derivative of OpenBSD. See documentation in Handling Operating System Variation.\n\nnote: Note\nNot to be confused with Sys.isbsd(), which is true on OpenBSD but also on other BSD-based systems. Sys.isopenbsd() refers only to OpenBSD.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Sys.isnetbsd","page":"Essentials","title":"Base.Sys.isnetbsd","text":"Sys.isnetbsd([os])\n\nPredicate for testing if the OS is a derivative of NetBSD. See documentation in Handling Operating System Variation.\n\nnote: Note\nNot to be confused with Sys.isbsd(), which is true on NetBSD but also on other BSD-based systems. Sys.isnetbsd() refers only to NetBSD.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Sys.isdragonfly","page":"Essentials","title":"Base.Sys.isdragonfly","text":"Sys.isdragonfly([os])\n\nPredicate for testing if the OS is a derivative of DragonFly BSD. See documentation in Handling Operating System Variation.\n\nnote: Note\nNot to be confused with Sys.isbsd(), which is true on DragonFly but also on other BSD-based systems. Sys.isdragonfly() refers only to DragonFly.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Sys.iswindows","page":"Essentials","title":"Base.Sys.iswindows","text":"Sys.iswindows([os])\n\nPredicate for testing if the OS is a derivative of Microsoft Windows NT. See documentation in Handling Operating System Variation.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Sys.windows_version","page":"Essentials","title":"Base.Sys.windows_version","text":"Sys.windows_version()\n\nReturn the version number for the Windows NT Kernel as a VersionNumber, i.e. v\"major.minor.build\", or v\"0.0.0\" if this is not running on Windows.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Sys.free_memory","page":"Essentials","title":"Base.Sys.free_memory","text":"Sys.free_memory()\n\nGet the total free memory in RAM in kilobytes.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Sys.total_memory","page":"Essentials","title":"Base.Sys.total_memory","text":"Sys.total_memory()\n\nGet the total memory in RAM (including that which is currently used) in kilobytes.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.@static","page":"Essentials","title":"Base.@static","text":"@static\n\nPartially evaluate an expression at parse time.\n\nFor example, @static Sys.iswindows() ? foo : bar will evaluate Sys.iswindows() and insert either foo or bar into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a ccall to a non-existent function. @static if Sys.isapple() foo end and @static foo <&&,||> bar are also valid syntax.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Versioning-1","page":"Essentials","title":"Versioning","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.VersionNumber\nBase.@v_str","category":"page"},{"location":"base/base.html#Base.VersionNumber","page":"Essentials","title":"Base.VersionNumber","text":"VersionNumber\n\nVersion number type which follow the specifications of semantic versioning, composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric annotations. See also @v_str.\n\nExamples\n\njulia> VersionNumber(\"1.2.3\")\nv\"1.2.3\"\n\njulia> VersionNumber(\"2.0.1-rc1\")\nv\"2.0.1-rc1\"\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.@v_str","page":"Essentials","title":"Base.@v_str","text":"@v_str\n\nString macro used to parse a string to a VersionNumber.\n\nExamples\n\njulia> v\"1.2.3\"\nv\"1.2.3\"\n\njulia> v\"2.0.1-rc1\"\nv\"2.0.1-rc1\"\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#エラー-1","page":"Essentials","title":"エラー","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.error\nCore.throw\nBase.rethrow\nBase.backtrace\nBase.catch_backtrace\nBase.catch_stack\nBase.@assert\nBase.ArgumentError\nBase.AssertionError\nCore.BoundsError\nBase.CompositeException\nBase.DimensionMismatch\nCore.DivideError\nCore.DomainError\nBase.EOFError\nCore.ErrorException\nCore.InexactError\nCore.InterruptException\nBase.KeyError\nBase.LoadError\nBase.MethodError\nBase.MissingException\nCore.OutOfMemoryError\nCore.ReadOnlyMemoryError\nCore.OverflowError\nBase.ProcessFailedException\nCore.StackOverflowError\nBase.SystemError\nCore.TypeError\nCore.UndefKeywordError\nCore.UndefRefError\nCore.UndefVarError\nBase.StringIndexError\nBase.InitError\nBase.retry\nBase.ExponentialBackOff","category":"page"},{"location":"base/base.html#Base.error","page":"Essentials","title":"Base.error","text":"error(message::AbstractString)\n\nRaise an ErrorException with the given message.\n\n\n\n\n\nerror(msg...)\n\nRaise an ErrorException with the given message.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.throw","page":"Essentials","title":"Core.throw","text":"throw(e)\n\nThrow an object as an exception.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.rethrow","page":"Essentials","title":"Base.rethrow","text":"rethrow([e])\n\nThrow an object without changing the current exception backtrace. The default argument is the current exception (if called within a catch block).\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.backtrace","page":"Essentials","title":"Base.backtrace","text":"backtrace()\n\nGet a backtrace object for the current program point.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.catch_backtrace","page":"Essentials","title":"Base.catch_backtrace","text":"catch_backtrace()\n\nGet the backtrace of the current exception, for use within catch blocks.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.catch_stack","page":"Essentials","title":"Base.catch_stack","text":"catch_stack(task=current_task(); [inclue_bt=true])\n\nGet the stack of exceptions currently being handled. For nested catch blocks there may be more than one current exception in which case the most recently thrown exception is last in the stack. The stack is returned as a Vector of (exception,backtrace) pairs, or a Vector of exceptions if include_bt is false.\n\nExplicitly passing task will return the current exception stack on an arbitrary task. This is useful for inspecting tasks which have failed due to uncaught exceptions.\n\ncompat: Julia 1.1\nThis function is experimental in Julia 1.1 and will likely be renamed in a future release (see https://github.com/JuliaLang/julia/pull/29901).\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.@assert","page":"Essentials","title":"Base.@assert","text":"@assert cond [text]\n\nThrow an AssertionError if cond is false. Preferred syntax for writing assertions. Message text is optionally displayed upon assertion failure.\n\nwarning: Warning\nAn assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.\n\nExamples\n\njulia> @assert iseven(3) \"3 is an odd number!\"\nERROR: AssertionError: 3 is an odd number!\n\njulia> @assert isodd(3) \"What even are numbers?\"\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Core.ArgumentError","page":"Essentials","title":"Core.ArgumentError","text":"ArgumentError(msg)\n\nThe parameters to a function call do not match a valid signature. Argument msg is a descriptive error string.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.AssertionError","page":"Essentials","title":"Core.AssertionError","text":"AssertionError([msg])\n\nThe asserted condition did not evaluate to true. Optional argument msg is a descriptive error string.\n\nExamples\n\njulia> @assert false \"this is not true\"\nERROR: AssertionError: this is not true\n\nAssertionError is usually thrown from @assert.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.BoundsError","page":"Essentials","title":"Core.BoundsError","text":"BoundsError([a],[i])\n\nAn indexing operation into an array, a, tried to access an out-of-bounds element at index i.\n\nExamples\n\njulia> A = fill(1.0, 7);\n\njulia> A[8]\nERROR: BoundsError: attempt to access 7-element Array{Float64,1} at index [8]\nStacktrace:\n [1] getindex(::Array{Float64,1}, ::Int64) at ./array.jl:660\n [2] top-level scope\n\njulia> B = fill(1.0, (2,3));\n\njulia> B[2, 4]\nERROR: BoundsError: attempt to access 2×3 Array{Float64,2} at index [2, 4]\nStacktrace:\n [1] getindex(::Array{Float64,2}, ::Int64, ::Int64) at ./array.jl:661\n [2] top-level scope\n\njulia> B[9]\nERROR: BoundsError: attempt to access 2×3 Array{Float64,2} at index [9]\nStacktrace:\n [1] getindex(::Array{Float64,2}, ::Int64) at ./array.jl:660\n [2] top-level scope\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.CompositeException","page":"Essentials","title":"Base.CompositeException","text":"CompositeException\n\nWrap a Vector of exceptions thrown by a Task (e.g. generated from a remote worker over a channel or an asynchronously executing local I/O write or a remote worker under pmap) with information about the series of exceptions. For example, if a group of workers are executing several tasks, and multiple workers fail, the resulting CompositeException will contain a \"bundle\" of information from each worker indicating where and why the exception(s) occurred.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.DimensionMismatch","page":"Essentials","title":"Base.DimensionMismatch","text":"DimensionMismatch([msg])\n\nThe objects called do not have matching dimensionality. Optional argument msg is a descriptive error string.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.DivideError","page":"Essentials","title":"Core.DivideError","text":"DivideError()\n\nInteger division was attempted with a denominator value of 0.\n\nExamples\n\njulia> 2/0\nInf\n\njulia> div(2, 0)\nERROR: DivideError: integer division error\nStacktrace:\n[...]\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.DomainError","page":"Essentials","title":"Core.DomainError","text":"DomainError(val)\nDomainError(val, msg)\n\nThe argument val to a function or constructor is outside the valid domain.\n\nExamples\n\njulia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.EOFError","page":"Essentials","title":"Base.EOFError","text":"EOFError()\n\nNo more data was available to read from a file or stream.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.ErrorException","page":"Essentials","title":"Core.ErrorException","text":"ErrorException(msg)\n\nGeneric error type. The error message, in the .msg field, may provide more specific details.\n\nExamples\n\njulia> ex = ErrorException(\"I've done a bad thing\");\n\njulia> ex.msg\n\"I've done a bad thing\"\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.InexactError","page":"Essentials","title":"Core.InexactError","text":"InexactError(name::Symbol, T, val)\n\nCannot exactly convert val to type T in a method of function name.\n\nExamples\n\njulia> convert(Float64, 1+2im)\nERROR: InexactError: Float64(1 + 2im)\nStacktrace:\n[...]\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.InterruptException","page":"Essentials","title":"Core.InterruptException","text":"InterruptException()\n\nThe process was stopped by a terminal interrupt (CTRL+C).\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.KeyError","page":"Essentials","title":"Base.KeyError","text":"KeyError(key)\n\nAn indexing operation into an AbstractDict (Dict) or Set like object tried to access or delete a non-existent element.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.LoadError","page":"Essentials","title":"Core.LoadError","text":"LoadError(file::AbstractString, line::Int, error)\n\nAn error occurred while includeing, requireing, or using a file. The error specifics should be available in the .error field.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.MethodError","page":"Essentials","title":"Core.MethodError","text":"MethodError(f, args)\n\nA method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.MissingException","page":"Essentials","title":"Base.MissingException","text":"MissingException(msg)\n\nException thrown when a missing value is encountered in a situation where it is not supported. The error message, in the msg field may provide more specific details.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.OutOfMemoryError","page":"Essentials","title":"Core.OutOfMemoryError","text":"OutOfMemoryError()\n\nAn operation allocated too much memory for either the system or the garbage collector to handle properly.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.ReadOnlyMemoryError","page":"Essentials","title":"Core.ReadOnlyMemoryError","text":"ReadOnlyMemoryError()\n\nAn operation tried to write to memory that is read-only.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.OverflowError","page":"Essentials","title":"Core.OverflowError","text":"OverflowError(msg)\n\nThe result of an expression is too large for the specified type and will cause a wraparound.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.ProcessFailedException","page":"Essentials","title":"Base.ProcessFailedException","text":"ProcessFailedException\n\nIndicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.StackOverflowError","page":"Essentials","title":"Core.StackOverflowError","text":"StackOverflowError()\n\nThe function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.SystemError","page":"Essentials","title":"Base.SystemError","text":"SystemError(prefix::AbstractString, [errno::Int32])\n\nA system call failed with an error code (in the errno global variable).\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.TypeError","page":"Essentials","title":"Core.TypeError","text":"TypeError(func::Symbol, context::AbstractString, expected::Type, got)\n\nA type assertion failure, or calling an intrinsic function with an incorrect argument type.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.UndefKeywordError","page":"Essentials","title":"Core.UndefKeywordError","text":"UndefKeywordError(var::Symbol)\n\nThe required keyword argument var was not assigned in a function call.\n\nExamples\n\njulia> function my_func(;my_arg)\n           return my_arg + 1\n       end\nmy_func (generic function with 1 method)\n\njulia> my_func()\nERROR: UndefKeywordError: keyword argument my_arg not assigned\nStacktrace:\n [1] my_func() at ./REPL[1]:2\n [2] top-level scope at REPL[2]:1\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.UndefRefError","page":"Essentials","title":"Core.UndefRefError","text":"UndefRefError()\n\nThe item or field is not defined for the given object.\n\nExamples\n\njulia> struct MyType\n           a::Vector{Int}\n           MyType() = new()\n       end\n\njulia> A = MyType()\nMyType(#undef)\n\njulia> A.a\nERROR: UndefRefError: access to undefined reference\nStacktrace:\n[...]\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.UndefVarError","page":"Essentials","title":"Core.UndefVarError","text":"UndefVarError(var::Symbol)\n\nA symbol in the current scope is not defined.\n\nExamples\n\njulia> a\nERROR: UndefVarError: a not defined\n\njulia> a = 1;\n\njulia> a\n1\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.StringIndexError","page":"Essentials","title":"Base.StringIndexError","text":"StringIndexError(str, i)\n\nAn error occurred when trying to access str at index i that is not valid.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Core.InitError","page":"Essentials","title":"Core.InitError","text":"InitError(mod::Symbol, error)\n\nAn error occurred when running a module's __init__ function. The actual error thrown is available in the .error field.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.retry","page":"Essentials","title":"Base.retry","text":"retry(f;  delays=ExponentialBackOff(), check=nothing) -> Function\n\nReturn an anonymous function that calls function f.  If an exception arises, f is repeatedly called again, each time check returns true, after waiting the number of seconds specified in delays.  check should input delays's current state and the Exception.\n\ncompat: Julia 1.2\nBefore Julia 1.2 this signature was restricted to f::Function.\n\nExamples\n\nretry(f, delays=fill(5.0, 3))\nretry(f, delays=rand(5:10, 2))\nretry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))\nretry(http_get, check=(s,e)->e.status == \"503\")(url)\nretry(read, check=(s,e)->isa(e, IOError))(io, 128; all=false)\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.ExponentialBackOff","page":"Essentials","title":"Base.ExponentialBackOff","text":"ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)\n\nA Float64 iterator of length n whose elements exponentially increase at a rate in the interval factor * (1 ± jitter).  The first element is first_delay and all elements are clamped to max_delay.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Events-1","page":"Essentials","title":"Events","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.Timer(::Function, ::Real)\nBase.Timer\nBase.AsyncCondition\nBase.AsyncCondition(::Function)","category":"page"},{"location":"base/base.html#Base.Timer-Tuple{Function,Real}","page":"Essentials","title":"Base.Timer","text":"Timer(callback::Function, delay; interval = 0)\n\nCreate a timer that wakes up tasks waiting for it (by calling wait on the timer object) and calls the function callback.\n\nWaiting tasks are woken and the function callback is called after an initial delay of delay seconds, and then repeating with the given interval in seconds. If interval is equal to 0, the timer is only triggered once. The function callback is called with a single argument, the timer itself. When the timer is closed (by close waiting tasks are woken with an error. Use isopen to check whether a timer is still active.\n\nExamples\n\nHere the first number is printed after a delay of two seconds, then the following numbers are printed quickly.\n\njulia> begin\n           i = 0\n           cb(timer) = (global i += 1; println(i))\n           t = Timer(cb, 2, interval = 0.2)\n           wait(t)\n           sleep(0.5)\n           close(t)\n       end\n1\n2\n3\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.Timer","page":"Essentials","title":"Base.Timer","text":"Timer(delay; interval = 0)\n\nCreate a timer that wakes up tasks waiting for it (by calling wait on the timer object).\n\nWaiting tasks are woken after an initial delay of delay seconds, and then repeating with the given interval in seconds. If interval is equal to 0, the timer is only triggered once. When the timer is closed (by close waiting tasks are woken with an error. Use isopen to check whether a timer is still active.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.AsyncCondition","page":"Essentials","title":"Base.AsyncCondition","text":"AsyncCondition()\n\nCreate a async condition that wakes up tasks waiting for it (by calling wait on the object) when notified from C by a call to uv_async_send. Waiting tasks are woken with an error when the object is closed (by close. Use isopen to check whether it is still active.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.AsyncCondition-Tuple{Function}","page":"Essentials","title":"Base.AsyncCondition","text":"AsyncCondition(callback::Function)\n\nCreate a async condition that calls the given callback function. The callback is passed one argument, the async condition object itself.\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Reflection-1","page":"Essentials","title":"Reflection","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.nameof(::Module)\nBase.parentmodule\nBase.pathof(::Module)\nBase.moduleroot\nBase.@__MODULE__\nBase.fullname\nBase.names\nCore.nfields\nBase.isconst\nBase.nameof(::Function)\nBase.functionloc(::Any, ::Any)\nBase.functionloc(::Method)","category":"page"},{"location":"base/base.html#Base.nameof-Tuple{Module}","page":"Essentials","title":"Base.nameof","text":"nameof(m::Module) -> Symbol\n\nGet the name of a Module as a Symbol.\n\nExamples\n\njulia> nameof(Base.Broadcast)\n:Broadcast\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.parentmodule","page":"Essentials","title":"Base.parentmodule","text":"parentmodule(m::Module) -> Module\n\nGet a module's enclosing Module. Main is its own parent.\n\nExamples\n\njulia> parentmodule(Main)\nMain\n\njulia> parentmodule(Base.Broadcast)\nBase\n\n\n\n\n\nparentmodule(t::DataType) -> Module\n\nDetermine the module containing the definition of a (potentially UnionAll-wrapped) DataType.\n\nExamples\n\njulia> module Foo\n           struct Int end\n       end\nFoo\n\njulia> parentmodule(Int)\nCore\n\njulia> parentmodule(Foo.Int)\nFoo\n\n\n\n\n\nparentmodule(f::Function) -> Module\n\nDetermine the module containing the (first) definition of a generic function.\n\n\n\n\n\nparentmodule(f::Function, types) -> Module\n\nDetermine the module containing a given definition of a generic function.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.pathof-Tuple{Module}","page":"Essentials","title":"Base.pathof","text":"pathof(m::Module)\n\nReturn the path of m.jl file that was used to import module m, or nothing if m was not imported from a package.\n\nUse dirname to get the directory part and basename to get the file name part of the path.\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.moduleroot","page":"Essentials","title":"Base.moduleroot","text":"moduleroot(m::Module) -> Module\n\nFind the root module of a given module. This is the first module in the chain of parent modules of m which is either a registered root module or which is its own parent module.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.@__MODULE__","page":"Essentials","title":"Base.@__MODULE__","text":"@__MODULE__ -> Module\n\nGet the Module of the toplevel eval, which is the Module code is currently being read from.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.fullname","page":"Essentials","title":"Base.fullname","text":"fullname(m::Module)\n\nGet the fully-qualified name of a module as a tuple of symbols. For example,\n\nExamples\n\njulia> fullname(Base.Iterators)\n(:Base, :Iterators)\n\njulia> fullname(Main)\n(:Main,)\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.names","page":"Essentials","title":"Base.names","text":"names(x::Module; all::Bool = false, imported::Bool = false)\n\nGet an array of the names exported by a Module, excluding deprecated names. If all is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If imported is true, then names explicitly imported from other modules are also included.\n\nAs a special case, all names defined in Main are considered \"exported\", since it is not idiomatic to explicitly export names from Main.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Core.nfields","page":"Essentials","title":"Core.nfields","text":"nfields(x) -> Int\n\nGet the number of fields in the given object.\n\nExamples\n\njulia> a = 1//2;\n\njulia> nfields(a)\n2\n\njulia> b = 1\n1\n\njulia> nfields(b)\n0\n\njulia> ex = ErrorException(\"I've done a bad thing\");\n\njulia> nfields(ex)\n1\n\nIn these examples, a is a Rational, which has two fields. b is an Int, which is a primitive bitstype with no fields at all. ex is an ErrorException, which has one field.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.isconst","page":"Essentials","title":"Base.isconst","text":"isconst(m::Module, s::Symbol) -> Bool\n\nDetermine whether a global is declared const in a given Module.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.nameof-Tuple{Function}","page":"Essentials","title":"Base.nameof","text":"nameof(f::Function) -> Symbol\n\nGet the name of a generic Function as a symbol, or :anonymous.\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.functionloc-Tuple{Any,Any}","page":"Essentials","title":"Base.functionloc","text":"functionloc(f::Function, types)\n\nReturns a tuple (filename,line) giving the location of a generic Function definition.\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.functionloc-Tuple{Method}","page":"Essentials","title":"Base.functionloc","text":"functionloc(m::Method)\n\nReturns a tuple (filename,line) giving the location of a Method definition.\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Internals-1","page":"Essentials","title":"Internals","text":"","category":"section"},{"location":"base/base.html#","page":"Essentials","title":"Essentials","text":"Base.GC.gc\nBase.GC.enable\nBase.GC.@preserve\nMeta.lower\nMeta.@lower\nMeta.parse(::AbstractString, ::Int)\nMeta.parse(::AbstractString)\nMeta.ParseError\nBase.macroexpand\nBase.@macroexpand\nBase.@macroexpand1\nBase.code_lowered\nBase.code_typed\nBase.precompile","category":"page"},{"location":"base/base.html#Base.GC.gc","page":"Essentials","title":"Base.GC.gc","text":"GC.gc()\n\nPerform garbage collection.\n\nwarning: Warning\nExcessive use will likely lead to poor performance.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.GC.enable","page":"Essentials","title":"Base.GC.enable","text":"GC.enable(on::Bool)\n\nControl whether garbage collection is enabled using a boolean argument (true for enabled, false for disabled). Return previous GC state.\n\nwarning: Warning\nDisabling garbage collection should be used only with caution, as it can cause memory use to grow without bound.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.GC.@preserve","page":"Essentials","title":"Base.GC.@preserve","text":"GC.@preserve x1 x2 ... xn expr\n\nTemporarily protect the given objects from being garbage collected, even if they would otherwise be unreferenced.\n\nThe last argument is the expression during which the object(s) will be preserved. The previous arguments are the objects to preserve.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.Meta.lower","page":"Essentials","title":"Base.Meta.lower","text":"lower(m, x)\n\nTakes the expression x and returns an equivalent expression in lowered form for executing in module m. See also code_lowered.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.Meta.@lower","page":"Essentials","title":"Base.Meta.@lower","text":"@lower [m] x\n\nReturn lowered form of the expression x in module m. By default m is the module in which the macro is called. See also lower.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.Meta.parse-Tuple{AbstractString,Int64}","page":"Essentials","title":"Base.Meta.parse","text":"parse(str, start; greedy=true, raise=true, depwarn=true)\n\nParse the expression string and return an expression (which could later be passed to eval for execution). start is the index of the first character to start parsing. If greedy is true (default), parse will try to consume as much input as it can; otherwise, it will stop as soon as it has parsed a valid expression. Incomplete but otherwise syntactically valid expressions will return Expr(:incomplete, \"(error message)\"). If raise is true (default), syntax errors other than incomplete expressions will raise an error. If raise is false, parse will return an expression that will raise an error upon evaluation. If depwarn is false, deprecation warnings will be suppressed.\n\njulia> Meta.parse(\"x = 3, y = 5\", 7)\n(:(y = 5), 13)\n\njulia> Meta.parse(\"x = 3, y = 5\", 5)\n(:((3, y) = 5), 13)\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.Meta.parse-Tuple{AbstractString}","page":"Essentials","title":"Base.Meta.parse","text":"parse(str; raise=true, depwarn=true)\n\nParse the expression string greedily, returning a single expression. An error is thrown if there are additional characters after the first expression. If raise is true (default), syntax errors will raise an error; otherwise, parse will return an expression that will raise an error upon evaluation.  If depwarn is false, deprecation warnings will be suppressed.\n\njulia> Meta.parse(\"x = 3\")\n:(x = 3)\n\njulia> Meta.parse(\"x = \")\n:($(Expr(:incomplete, \"incomplete: premature end of input\")))\n\njulia> Meta.parse(\"1.0.2\")\nERROR: Base.Meta.ParseError(\"invalid numeric constant \\\"1.0.\\\"\")\nStacktrace:\n[...]\n\njulia> Meta.parse(\"1.0.2\"; raise = false)\n:($(Expr(:error, \"invalid numeric constant \\\"1.0.\\\"\")))\n\n\n\n\n\n","category":"method"},{"location":"base/base.html#Base.Meta.ParseError","page":"Essentials","title":"Base.Meta.ParseError","text":"ParseError(msg)\n\nThe expression passed to the parse function could not be interpreted as a valid Julia expression.\n\n\n\n\n\n","category":"type"},{"location":"base/base.html#Base.macroexpand","page":"Essentials","title":"Base.macroexpand","text":"macroexpand(m::Module, x; recursive=true)\n\nTake the expression x and return an equivalent expression with all macros removed (expanded) for executing in module m. The recursive keyword controls whether deeper levels of nested macros are also expanded. This is demonstrated in the example below:\n\njulia> module M\n           macro m1()\n               42\n           end\n           macro m2()\n               :(@m1())\n           end\n       end\nM\n\njulia> macroexpand(M, :(@m2()), recursive=true)\n42\n\njulia> macroexpand(M, :(@m2()), recursive=false)\n:(#= REPL[16]:6 =# M.@m1)\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.@macroexpand","page":"Essentials","title":"Base.@macroexpand","text":"@macroexpand\n\nReturn equivalent expression with all macros removed (expanded).\n\nThere are differences between @macroexpand and macroexpand.\n\nWhile macroexpand takes a keyword argument recursive, @macroexpand\n\nis always recursive. For a non recursive macro version, see @macroexpand1.\n\nWhile macroexpand has an explicit module argument, @macroexpand always\n\nexpands with respect to the module in which it is called. This is best seen in the following example:\n\njulia> module M\n           macro m()\n               1\n           end\n           function f()\n               (@macroexpand(@m),\n                macroexpand(M, :(@m)),\n                macroexpand(Main, :(@m))\n               )\n           end\n       end\nM\n\njulia> macro m()\n           2\n       end\n@m (macro with 1 method)\n\njulia> M.f()\n(1, 1, 2)\n\nWith @macroexpand the expression expands where @macroexpand appears in the code (module M in the example). With macroexpand the expression expands in the module given as the first argument.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.@macroexpand1","page":"Essentials","title":"Base.@macroexpand1","text":"@macroexpand1\n\nNon recursive version of @macroexpand.\n\n\n\n\n\n","category":"macro"},{"location":"base/base.html#Base.code_lowered","page":"Essentials","title":"Base.code_lowered","text":"code_lowered(f, types; generated=true, debuginfo=:default)\n\nReturn an array of the lowered forms (IR) for the methods matching the given generic function and type signature.\n\nIf generated is false, the returned CodeInfo instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If generated is true, these CodeInfo instances will correspond to the method bodies yielded by expanding the generators.\n\nThe keyword debuginfo controls the amount of code metadata present in the output.\n\nNote that an error will be thrown if types are not leaf types when generated is true and any of the corresponding methods are an @generated method.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.code_typed","page":"Essentials","title":"Base.code_typed","text":"code_typed(f, types; optimize=true, debuginfo=:default)\n\nReturns an array of type-inferred lowered form (IR) for the methods matching the given generic function and type signature. The keyword argument optimize controls whether additional optimizations, such as inlining, are also applied. The keyword debuginfo controls the amount of code metadata present in the output, possible options are :source or :none.\n\n\n\n\n\n","category":"function"},{"location":"base/base.html#Base.precompile","page":"Essentials","title":"Base.precompile","text":"precompile(f, args::Tuple{Vararg{Any}})\n\nCompile the given function f for the argument tuple (of types) args, but do not execute it.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Collections-and-Data-Structures-1","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"","category":"section"},{"location":"base/collections.html#lib-collections-iteration-1","page":"Collections and Data Structures","title":"Iteration","text":"","category":"section"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Sequential iteration is implemented by the iterate function.  The general for loop:","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"for i in iter   # or  \"for i = iter\"\n    # body\nend","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"is translated into:","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"next = iterate(iter)\nwhile next !== nothing\n    (i, state) = next\n    # body\n    next = iterate(iter, state)\nend","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"The state object may be anything, and should be chosen appropriately for each iterable type.  See the manual section on the iteration interface for more details about defining a custom iterable type.","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Base.iterate\nBase.IteratorSize\nBase.IteratorEltype","category":"page"},{"location":"base/collections.html#Base.iterate","page":"Collections and Data Structures","title":"Base.iterate","text":"iterate(iter [, state]) -> Union{Nothing, Tuple{Any, Any}}\n\nAdvance the iterator to obtain the next element. If no elements remain, nothing should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.IteratorSize","page":"Collections and Data Structures","title":"Base.IteratorSize","text":"IteratorSize(itertype::Type) -> IteratorSize\n\nGiven the type of an iterator, return one of the following values:\n\nSizeUnknown() if the length (number of elements) cannot be determined in advance.\nHasLength() if there is a fixed, finite length.\nHasShape{N}() if there is a known length plus a notion of multidimensional shape (as for an array).  In this case N should give the number of dimensions, and the axes function is valid  for the iterator.\nIsInfinite() if the iterator yields values forever.\n\nThe default value (for iterators that do not define this function) is HasLength(). This means that most iterators are assumed to implement length.\n\nThis trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.\n\njulia> Base.IteratorSize(1:5)\nBase.HasShape{1}()\n\njulia> Base.IteratorSize((2,3))\nBase.HasLength()\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.IteratorEltype","page":"Collections and Data Structures","title":"Base.IteratorEltype","text":"IteratorEltype(itertype::Type) -> IteratorEltype\n\nGiven the type of an iterator, return one of the following values:\n\nEltypeUnknown() if the type of elements yielded by the iterator is not known in advance.\nHasEltype() if the element type is known, and eltype would return a meaningful value.\n\nHasEltype() is the default, since iterators are assumed to implement eltype.\n\nThis trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.\n\njulia> Base.IteratorEltype(1:5)\nBase.HasEltype()\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Fully implemented by:","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"AbstractRange\nUnitRange\nTuple\nNumber\nAbstractArray\nBitSet\nIdDict\nDict\nWeakKeyDict\nEachLine\nAbstractString\nSet\nPair\nNamedTuple","category":"page"},{"location":"base/collections.html#Constructors-and-Types-1","page":"Collections and Data Structures","title":"Constructors and Types","text":"","category":"section"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Base.AbstractRange\nBase.OrdinalRange\nBase.AbstractUnitRange\nBase.StepRange\nBase.UnitRange\nBase.LinRange","category":"page"},{"location":"base/collections.html#Base.AbstractRange","page":"Collections and Data Structures","title":"Base.AbstractRange","text":"AbstractRange{T}\n\nSupertype for ranges with elements of type T. UnitRange and other types are subtypes of this.\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.OrdinalRange","page":"Collections and Data Structures","title":"Base.OrdinalRange","text":"OrdinalRange{T, S} <: AbstractRange{T}\n\nSupertype for ordinal ranges with elements of type T with spacing(s) of type S. The steps should be always-exact multiples of oneunit, and T should be a \"discrete\" type, which cannot have values smaller than oneunit. For example, Integer or Date types would qualify, whereas Float64 would not (since this type can represent values smaller than oneunit(Float64). UnitRange, StepRange, and other types are subtypes of this.\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.AbstractUnitRange","page":"Collections and Data Structures","title":"Base.AbstractUnitRange","text":"AbstractUnitRange{T} <: OrdinalRange{T, T}\n\nSupertype for ranges with a step size of oneunit(T) with elements of type T. UnitRange and other types are subtypes of this.\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.StepRange","page":"Collections and Data Structures","title":"Base.StepRange","text":"StepRange{T, S} <: OrdinalRange{T, S}\n\nRanges with elements of type T with spacing of type S. The step between each element is constant, and the range is defined in terms of a start and stop of type T and a step of type S. Neither T nor S should be floating point types. The syntax a:b:c with b > 1 and a, b, and c all integers creates a StepRange.\n\nExamples\n\njulia> collect(StepRange(1, Int8(2), 10))\n5-element Array{Int64,1}:\n 1\n 3\n 5\n 7\n 9\n\njulia> typeof(StepRange(1, Int8(2), 10))\nStepRange{Int64,Int8}\n\njulia> typeof(1:3:6)\nStepRange{Int64,Int64}\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.UnitRange","page":"Collections and Data Structures","title":"Base.UnitRange","text":"UnitRange{T<:Real}\n\nA range parameterized by a start and stop of type T, filled with elements spaced by 1 from start until stop is exceeded. The syntax a:b with a and b both Integers creates a UnitRange.\n\nExamples\n\njulia> collect(UnitRange(2.3, 5.2))\n3-element Array{Float64,1}:\n 2.3\n 3.3\n 4.3\n\njulia> typeof(1:10)\nUnitRange{Int64}\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.LinRange","page":"Collections and Data Structures","title":"Base.LinRange","text":"LinRange{T}\n\nA range with len linearly spaced elements between its start and stop. The size of the spacing is controlled by len, which must be an Int.\n\nExamples\n\njulia> LinRange(1.5, 5.5, 9)\n9-element LinRange{Float64}:\n 1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#General-Collections-1","page":"Collections and Data Structures","title":"General Collections","text":"","category":"section"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Base.isempty\nBase.empty!\nBase.length","category":"page"},{"location":"base/collections.html#Base.isempty","page":"Collections and Data Structures","title":"Base.isempty","text":"isempty(collection) -> Bool\n\nDetermine whether a collection is empty (has no elements).\n\nExamples\n\njulia> isempty([])\ntrue\n\njulia> isempty([1 2 3])\nfalse\n\n\n\n\n\nisempty(condition)\n\nReturn true if no tasks are waiting on the condition, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.empty!","page":"Collections and Data Structures","title":"Base.empty!","text":"empty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nDict{String,Int64} with 0 entries\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.length","page":"Collections and Data Structures","title":"Base.length","text":"length(collection) -> Integer\n\nReturn the number of elements in the collection.\n\nUse lastindex to get the last valid index of an indexable collection.\n\nExamples\n\njulia> length(1:5)\n5\n\njulia> length([1, 2, 3, 4])\n4\n\njulia> length([1 2; 3 4])\n4\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Fully implemented by:","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"AbstractRange\nUnitRange\nTuple\nNumber\nAbstractArray\nBitSet\nIdDict\nDict\nWeakKeyDict\nAbstractString\nSet\nNamedTuple","category":"page"},{"location":"base/collections.html#Iterable-Collections-1","page":"Collections and Data Structures","title":"Iterable Collections","text":"","category":"section"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Base.in\nBase.:∉\nBase.eltype\nBase.indexin\nBase.unique\nBase.unique!\nBase.allunique\nBase.reduce(::Any, ::Any)\nBase.foldl(::Any, ::Any)\nBase.foldr(::Any, ::Any)\nBase.maximum\nBase.maximum!\nBase.minimum\nBase.minimum!\nBase.extrema\nBase.argmax\nBase.argmin\nBase.findmax\nBase.findmin\nBase.findmax!\nBase.findmin!\nBase.sum\nBase.sum!\nBase.prod\nBase.prod!\nBase.any(::Any)\nBase.any(::AbstractArray, ::Any)\nBase.any!\nBase.all(::Any)\nBase.all(::AbstractArray, ::Any)\nBase.all!\nBase.count\nBase.any(::Any, ::Any)\nBase.all(::Any, ::Any)\nBase.foreach\nBase.map\nBase.map!\nBase.mapreduce(::Any, ::Any, ::Any)\nBase.mapfoldl(::Any, ::Any, ::Any)\nBase.mapfoldr(::Any, ::Any, ::Any)\nBase.first\nBase.last\nBase.front\nBase.tail\nBase.step\nBase.collect(::Any)\nBase.collect(::Type, ::Any)\nBase.filter\nBase.filter!\nBase.replace(::Any, ::Pair...)\nBase.replace(::Base.Callable, ::Any)\nBase.replace!","category":"page"},{"location":"base/collections.html#Base.in","page":"Collections and Data Structures","title":"Base.in","text":"in(item, collection) -> Bool\n∈(item, collection) -> Bool\n∋(collection, item) -> Bool\n\nDetermine whether an item is in the given collection, in the sense that it is == to one of the values generated by iterating over the collection. Returns a Bool value, except if item is missing or collection contains missing but not item, in which case missing is returned (three-valued logic, matching the behavior of any and ==).\n\nSome collections follow a slightly different definition. For example, Sets check whether the item isequal to one of the elements. Dicts look for key=>value pairs, and the key is compared using isequal. To test for the presence of a key in a dictionary, use haskey or k in keys(dict). For these collections, the result is always a Bool and never missing.\n\nExamples\n\njulia> a = 1:3:20\n1:3:19\n\njulia> 4 in a\ntrue\n\njulia> 5 in a\nfalse\n\njulia> missing in [1, 2]\nmissing\n\njulia> 1 in [2, missing]\nmissing\n\njulia> 1 in [1, missing]\ntrue\n\njulia> missing in Set([1, 2])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.:∉","page":"Collections and Data Structures","title":"Base.:∉","text":"∉(item, collection) -> Bool\n∌(collection, item) -> Bool\n\nNegation of ∈ and ∋, i.e. checks that item is not in collection.\n\nExamples\n\njulia> 1 ∉ 2:4\ntrue\n\njulia> 1 ∉ 1:3\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.eltype","page":"Collections and Data Structures","title":"Base.eltype","text":"eltype(type)\n\nDetermine the type of the elements generated by iterating a collection of the given type. For dictionary types, this will be a Pair{KeyType,ValType}. The definition eltype(x) = eltype(typeof(x)) is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.\n\nExamples\n\njulia> eltype(fill(1f0, (2,2)))\nFloat32\n\njulia> eltype(fill(0x1, (2,2)))\nUInt8\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.indexin","page":"Collections and Data Structures","title":"Base.indexin","text":"indexin(a, b)\n\nReturn an array containing the first index in b for each value in a that is a member of b. The output array contains nothing wherever a is not a member of b.\n\nExamples\n\njulia> a = ['a', 'b', 'c', 'b', 'd', 'a'];\n\njulia> b = ['a', 'b', 'c'];\n\njulia> indexin(a, b)\n6-element Array{Union{Nothing, Int64},1}:\n 1\n 2\n 3\n 2\n  nothing\n 1\n\njulia> indexin(b, a)\n3-element Array{Union{Nothing, Int64},1}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.unique","page":"Collections and Data Structures","title":"Base.unique","text":"unique(itr)\n\nReturn an array containing only the unique elements of collection itr, as determined by isequal, in the order that the first of each set of equivalent elements originally appears. The element type of the input is preserved.\n\nExamples\n\njulia> unique([1, 2, 6, 2])\n3-element Array{Int64,1}:\n 1\n 2\n 6\n\njulia> unique(Real[1, 1.0, 2])\n2-element Array{Real,1}:\n 1\n 2\n\n\n\n\n\nunique(f, itr)\n\nReturns an array containing one value from itr for each unique value produced by f applied to elements of itr.\n\nExamples\n\njulia> unique(x -> x^2, [1, -1, 3, -3, 4])\n3-element Array{Int64,1}:\n 1\n 3\n 4\n\n\n\n\n\nunique(A::AbstractArray; dims::Int)\n\nReturn unique regions of A along dimension dims.\n\nExamples\n\njulia> A = map(isodd, reshape(Vector(1:8), (2,2,2)))\n2×2×2 Array{Bool,3}:\n[:, :, 1] =\n 1  1\n 0  0\n\n[:, :, 2] =\n 1  1\n 0  0\n\njulia> unique(A)\n2-element Array{Bool,1}:\n 1\n 0\n\njulia> unique(A, dims=2)\n2×1×2 Array{Bool,3}:\n[:, :, 1] =\n 1\n 0\n\n[:, :, 2] =\n 1\n 0\n\njulia> unique(A, dims=3)\n2×2×1 Array{Bool,3}:\n[:, :, 1] =\n 1  1\n 0  0\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.unique!","page":"Collections and Data Structures","title":"Base.unique!","text":"unique!(f, A::AbstractVector)\n\nSelects one value from A for each unique value produced by f applied to elements of A , then return the modified A.\n\ncompat: Julia 1.1\nThis method is available as of Julia 1.1.\n\nExamples\n\njulia> unique!(x -> x^2, [1, -1, 3, -3, 4])\n3-element Array{Int64,1}:\n 1\n 3\n 4\n\njulia> unique!(n -> n%3, [5, 1, 8, 9, 3, 4, 10, 7, 2, 6])\n3-element Array{Int64,1}:\n 5\n 1\n 9\n\njulia> unique!(iseven, [2, 3, 5, 7, 9])\n2-element Array{Int64,1}:\n 2\n 3\n\n\n\n\n\nunique!(A::AbstractVector)\n\nRemove duplicate items as determined by isequal, then return the modified A. unique! will return the elements of A in the order that they occur. If you do not care about the order of the returned data, then calling (sort!(A); unique!(A)) will be much more efficient as long as the elements of A can be sorted.\n\nExamples\n\njulia> unique!([1, 1, 1])\n1-element Array{Int64,1}:\n 1\n\njulia> A = [7, 3, 2, 3, 7, 5];\n\njulia> unique!(A)\n4-element Array{Int64,1}:\n 7\n 3\n 2\n 5\n\njulia> B = [7, 6, 42, 6, 7, 42];\n\njulia> sort!(B);  # unique! is able to process sorted data much more efficiently.\n\njulia> unique!(B)\n3-element Array{Int64,1}:\n  6\n  7\n 42\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.allunique","page":"Collections and Data Structures","title":"Base.allunique","text":"allunique(itr) -> Bool\n\nReturn true if all values from itr are distinct when compared with isequal.\n\nExamples\n\njulia> a = [1; 2; 3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> allunique([a, a])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.reduce-Tuple{Any,Any}","page":"Collections and Data Structures","title":"Base.reduce","text":"reduce(op, itr; [init])\n\nReduce the given collection itr with the given binary operator op. If provided, the initial value init must be a neutral element for op that will be returned for empty collections. It is unspecified whether init is used for non-empty collections.\n\nFor empty collections, providing init will be necessary, except for some special cases (e.g. when op is one of +, *, max, min, &, |) when Julia can determine the neutral element of op.\n\nReductions for certain commonly-used operators may have special implementations, and should be used instead: maximum(itr), minimum(itr), sum(itr), prod(itr),  any(itr), all(itr).\n\nThe associativity of the reduction is implementation dependent. This means that you can't use non-associative operations like - because it is undefined whether reduce(-,[1,2,3]) should be evaluated as (1-2)-3 or 1-(2-3). Use foldl or foldr instead for guaranteed left or right associativity.\n\nSome operations accumulate error. Parallelism will be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.\n\nExamples\n\njulia> reduce(*, [2; 3; 4])\n24\n\njulia> reduce(*, [2; 3; 4]; init=-1)\n-24\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.foldl-Tuple{Any,Any}","page":"Collections and Data Structures","title":"Base.foldl","text":"foldl(op, itr; [init])\n\nLike reduce, but with guaranteed left associativity. If provided, the keyword argument init will be used exactly once. In general, it will be necessary to provide init to work with empty collections.\n\nExamples\n\njulia> foldl(=>, 1:4)\n((1 => 2) => 3) => 4\n\njulia> foldl(=>, 1:4; init=0)\n(((0 => 1) => 2) => 3) => 4\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.foldr-Tuple{Any,Any}","page":"Collections and Data Structures","title":"Base.foldr","text":"foldr(op, itr; [init])\n\nLike reduce, but with guaranteed right associativity. If provided, the keyword argument init will be used exactly once. In general, it will be necessary to provide init to work with empty collections.\n\nExamples\n\njulia> foldr(=>, 1:4)\n1 => (2 => (3 => 4))\n\njulia> foldr(=>, 1:4; init=0)\n1 => (2 => (3 => (4 => 0)))\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.maximum","page":"Collections and Data Structures","title":"Base.maximum","text":"maximum(f, itr)\n\nReturns the largest result of calling function f on each element of itr.\n\nExamples\n\njulia> maximum(length, [\"Julion\", \"Julia\", \"Jule\"])\n6\n\n\n\n\n\nmaximum(itr)\n\nReturns the largest element in a collection.\n\nExamples\n\njulia> maximum(-20.5:10)\n9.5\n\njulia> maximum([1,2,3])\n3\n\n\n\n\n\nmaximum(A::AbstractArray; dims)\n\nCompute the maximum value of an array over the given dimensions. See also the max(a,b) function to take the maximum of two or more arguments, which can be applied elementwise to arrays via max.(a,b).\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> maximum(A, dims=1)\n1×2 Array{Int64,2}:\n 3  4\n\njulia> maximum(A, dims=2)\n2×1 Array{Int64,2}:\n 2\n 4\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.maximum!","page":"Collections and Data Structures","title":"Base.maximum!","text":"maximum!(r, A)\n\nCompute the maximum value of A over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> maximum!([1; 1], A)\n2-element Array{Int64,1}:\n 2\n 4\n\njulia> maximum!([1 1], A)\n1×2 Array{Int64,2}:\n 3  4\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.minimum","page":"Collections and Data Structures","title":"Base.minimum","text":"minimum(f, itr)\n\nReturns the smallest result of calling function f on each element of itr.\n\nExamples\n\njulia> minimum(length, [\"Julion\", \"Julia\", \"Jule\"])\n4\n\n\n\n\n\nminimum(itr)\n\nReturns the smallest element in a collection.\n\nExamples\n\njulia> minimum(-20.5:10)\n-20.5\n\njulia> minimum([1,2,3])\n1\n\n\n\n\n\nminimum(A::AbstractArray; dims)\n\nCompute the minimum value of an array over the given dimensions. See also the min(a,b) function to take the minimum of two or more arguments, which can be applied elementwise to arrays via min.(a,b).\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> minimum(A, dims=1)\n1×2 Array{Int64,2}:\n 1  2\n\njulia> minimum(A, dims=2)\n2×1 Array{Int64,2}:\n 1\n 3\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.minimum!","page":"Collections and Data Structures","title":"Base.minimum!","text":"minimum!(r, A)\n\nCompute the minimum value of A over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> minimum!([1; 1], A)\n2-element Array{Int64,1}:\n 1\n 3\n\njulia> minimum!([1 1], A)\n1×2 Array{Int64,2}:\n 1  2\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.extrema","page":"Collections and Data Structures","title":"Base.extrema","text":"extrema(itr) -> Tuple\n\nCompute both the minimum and maximum element in a single pass, and return them as a 2-tuple.\n\nExamples\n\njulia> extrema(2:10)\n(2, 10)\n\njulia> extrema([9,pi,4.5])\n(3.141592653589793, 9.0)\n\n\n\n\n\nextrema(f, itr) -> Tuple\n\nCompute both the minimum and maximum of f applied to each element in itr and return them as a 2-tuple. Only one pass is made over itr.\n\ncompat: Julia 1.2\nThis method requires Julia 1.2 or later.\n\nExamples\n\njulia> extrema(sin, 0:π)\n(0.0, 0.9092974268256817)\n\n\n\n\n\nextrema(A::AbstractArray; dims) -> Array{Tuple}\n\nCompute the minimum and maximum elements of an array over the given dimensions.\n\nExamples\n\njulia> A = reshape(Vector(1:2:16), (2,2,2))\n2×2×2 Array{Int64,3}:\n[:, :, 1] =\n 1  5\n 3  7\n\n[:, :, 2] =\n  9  13\n 11  15\n\njulia> extrema(A, dims = (1,2))\n1×1×2 Array{Tuple{Int64,Int64},3}:\n[:, :, 1] =\n (1, 7)\n\n[:, :, 2] =\n (9, 15)\n\n\n\n\n\nextrema(f, A::AbstractArray; dims) -> Array{Tuple}\n\nCompute the minimum and maximum of f applied to each element in the given dimensions of A.\n\ncompat: Julia 1.2\nThis method requires Julia 1.2 or later.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.argmax","page":"Collections and Data Structures","title":"Base.argmax","text":"argmax(itr) -> Integer\n\nReturn the index of the maximum element in a collection. If there are multiple maximal elements, then the first one will be returned.\n\nThe collection must not be empty.\n\nExamples\n\njulia> argmax([8,0.1,-9,pi])\n1\n\njulia> argmax([1,7,7,6])\n2\n\njulia> argmax([1,7,7,NaN])\n4\n\n\n\n\n\nargmax(A; dims) -> indices\n\nFor an array input, return the indices of the maximum elements over the given dimensions. NaN is treated as greater than all other values.\n\nExamples\n\njulia> A = [1.0 2; 3 4]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> argmax(A, dims=1)\n1×2 Array{CartesianIndex{2},2}:\n CartesianIndex(2, 1)  CartesianIndex(2, 2)\n\njulia> argmax(A, dims=2)\n2×1 Array{CartesianIndex{2},2}:\n CartesianIndex(1, 2)\n CartesianIndex(2, 2)\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.argmin","page":"Collections and Data Structures","title":"Base.argmin","text":"argmin(itr) -> Integer\n\nReturn the index of the minimum element in a collection. If there are multiple minimal elements, then the first one will be returned.\n\nThe collection must not be empty.\n\nExamples\n\njulia> argmin([8,0.1,-9,pi])\n3\n\njulia> argmin([7,1,1,6])\n2\n\njulia> argmin([7,1,1,NaN])\n4\n\n\n\n\n\nargmin(A; dims) -> indices\n\nFor an array input, return the indices of the minimum elements over the given dimensions. NaN is treated as less than all other values.\n\nExamples\n\njulia> A = [1.0 2; 3 4]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> argmin(A, dims=1)\n1×2 Array{CartesianIndex{2},2}:\n CartesianIndex(1, 1)  CartesianIndex(1, 2)\n\njulia> argmin(A, dims=2)\n2×1 Array{CartesianIndex{2},2}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.findmax","page":"Collections and Data Structures","title":"Base.findmax","text":"findmax(itr) -> (x, index)\n\nReturn the maximum element of the collection itr and its index. If there are multiple maximal elements, then the first one will be returned. If any data element is NaN, this element is returned. The result is in line with max.\n\nThe collection must not be empty.\n\nExamples\n\njulia> findmax([8,0.1,-9,pi])\n(8.0, 1)\n\njulia> findmax([1,7,7,6])\n(7, 2)\n\njulia> findmax([1,7,7,NaN])\n(NaN, 4)\n\n\n\n\n\nfindmax(A; dims) -> (maxval, index)\n\nFor an array input, returns the value and index of the maximum over the given dimensions. NaN is treated as greater than all other values.\n\nExamples\n\njulia> A = [1.0 2; 3 4]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> findmax(A, dims=1)\n([3.0 4.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(2, 2)])\n\njulia> findmax(A, dims=2)\n([2.0; 4.0], CartesianIndex{2}[CartesianIndex(1, 2); CartesianIndex(2, 2)])\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.findmin","page":"Collections and Data Structures","title":"Base.findmin","text":"findmin(itr) -> (x, index)\n\nReturn the minimum element of the collection itr and its index. If there are multiple minimal elements, then the first one will be returned. If any data element is NaN, this element is returned. The result is in line with min.\n\nThe collection must not be empty.\n\nExamples\n\njulia> findmin([8,0.1,-9,pi])\n(-9.0, 3)\n\njulia> findmin([7,1,1,6])\n(1, 2)\n\njulia> findmin([7,1,1,NaN])\n(NaN, 4)\n\n\n\n\n\nfindmin(A; dims) -> (minval, index)\n\nFor an array input, returns the value and index of the minimum over the given dimensions. NaN is treated as less than all other values.\n\nExamples\n\njulia> A = [1.0 2; 3 4]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> findmin(A, dims=1)\n([1.0 2.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(1, 2)])\n\njulia> findmin(A, dims=2)\n([1.0; 3.0], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1)])\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.findmax!","page":"Collections and Data Structures","title":"Base.findmax!","text":"findmax!(rval, rind, A) -> (maxval, index)\n\nFind the maximum of A and the corresponding linear index along singleton dimensions of rval and rind, and store the results in rval and rind. NaN is treated as greater than all other values.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.findmin!","page":"Collections and Data Structures","title":"Base.findmin!","text":"findmin!(rval, rind, A) -> (minval, index)\n\nFind the minimum of A and the corresponding linear index along singleton dimensions of rval and rind, and store the results in rval and rind. NaN is treated as less than all other values.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.sum","page":"Collections and Data Structures","title":"Base.sum","text":"sum(f, itr)\n\nSum the results of calling function f on each element of itr.\n\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\n\nExamples\n\njulia> sum(abs2, [2; 3; 4])\n29\n\nNote the important difference between sum(A) and reduce(+, A) for arrays with small integer eltype:\n\njulia> sum(Int8[100, 28])\n128\n\njulia> reduce(+, Int8[100, 28])\n-128\n\nIn the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.\n\n\n\n\n\nsum(itr)\n\nReturns the sum of all elements in a collection.\n\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\n\nExamples\n\njulia> sum(1:20)\n210\n\n\n\n\n\nsum(A::AbstractArray; dims)\n\nSum elements of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> sum(A, dims=1)\n1×2 Array{Int64,2}:\n 4  6\n\njulia> sum(A, dims=2)\n2×1 Array{Int64,2}:\n 3\n 7\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.sum!","page":"Collections and Data Structures","title":"Base.sum!","text":"sum!(r, A)\n\nSum elements of A over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> sum!([1; 1], A)\n2-element Array{Int64,1}:\n 3\n 7\n\njulia> sum!([1 1], A)\n1×2 Array{Int64,2}:\n 4  6\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.prod","page":"Collections and Data Structures","title":"Base.prod","text":"prod(f, itr)\n\nReturns the product of f applied to each element of itr.\n\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\n\nExamples\n\njulia> prod(abs2, [2; 3; 4])\n576\n\n\n\n\n\nprod(itr)\n\nReturns the product of all elements of a collection.\n\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\n\nExamples\n\njulia> prod(1:20)\n2432902008176640000\n\n\n\n\n\nprod(A::AbstractArray; dims)\n\nMultiply elements of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> prod(A, dims=1)\n1×2 Array{Int64,2}:\n 3  8\n\njulia> prod(A, dims=2)\n2×1 Array{Int64,2}:\n  2\n 12\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.prod!","page":"Collections and Data Structures","title":"Base.prod!","text":"prod!(r, A)\n\nMultiply elements of A over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> prod!([1; 1], A)\n2-element Array{Int64,1}:\n  2\n 12\n\njulia> prod!([1 1], A)\n1×2 Array{Int64,2}:\n 3  8\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.any-Tuple{Any}","page":"Collections and Data Structures","title":"Base.any","text":"any(itr) -> Bool\n\nTest whether any elements of a boolean collection are true, returning true as soon as the first true value in itr is encountered (short-circuiting).\n\nIf the input contains missing values, return missing if all non-missing values are false (or equivalently, if the input contains no true value), following three-valued logic.\n\nExamples\n\njulia> a = [true,false,false,true]\n4-element Array{Bool,1}:\n 1\n 0\n 0\n 1\n\njulia> any(a)\ntrue\n\njulia> any((println(i); v) for (i, v) in enumerate(a))\n1\ntrue\n\njulia> any([missing, true])\ntrue\n\njulia> any([false, missing])\nmissing\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.any-Tuple{AbstractArray,Any}","page":"Collections and Data Structures","title":"Base.any","text":"any(p, itr) -> Bool\n\nDetermine whether predicate p returns true for any elements of itr, returning true as soon as the first item in itr for which p returns true is encountered (short-circuiting).\n\nIf the input contains missing values, return missing if all non-missing values are false (or equivalently, if the input contains no true value), following three-valued logic.\n\nExamples\n\njulia> any(i->(4<=i<=6), [3,5,7])\ntrue\n\njulia> any(i -> (println(i); i > 3), 1:10)\n1\n2\n3\n4\ntrue\n\njulia> any(i -> i > 0, [1, missing])\ntrue\n\njulia> any(i -> i > 0, [-1, missing])\nmissing\n\njulia> any(i -> i > 0, [-1, 0])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.any!","page":"Collections and Data Structures","title":"Base.any!","text":"any!(r, A)\n\nTest whether any values in A along the singleton dimensions of r are true, and write results to r.\n\nExamples\n\njulia> A = [true false; true false]\n2×2 Array{Bool,2}:\n 1  0\n 1  0\n\njulia> any!([1; 1], A)\n2-element Array{Int64,1}:\n 1\n 1\n\njulia> any!([1 1], A)\n1×2 Array{Int64,2}:\n 1  0\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.all-Tuple{Any}","page":"Collections and Data Structures","title":"Base.all","text":"all(itr) -> Bool\n\nTest whether all elements of a boolean collection are true, returning false as soon as the first false value in itr is encountered (short-circuiting).\n\nIf the input contains missing values, return missing if all non-missing values are true (or equivalently, if the input contains no false value), following three-valued logic.\n\nExamples\n\njulia> a = [true,false,false,true]\n4-element Array{Bool,1}:\n 1\n 0\n 0\n 1\n\njulia> all(a)\nfalse\n\njulia> all((println(i); v) for (i, v) in enumerate(a))\n1\n2\nfalse\n\njulia> all([missing, false])\nfalse\n\njulia> all([true, missing])\nmissing\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.all-Tuple{AbstractArray,Any}","page":"Collections and Data Structures","title":"Base.all","text":"all(p, itr) -> Bool\n\nDetermine whether predicate p returns true for all elements of itr, returning false as soon as the first item in itr for which p returns false is encountered (short-circuiting).\n\nIf the input contains missing values, return missing if all non-missing values are true (or equivalently, if the input contains no false value), following three-valued logic.\n\nExamples\n\njulia> all(i->(4<=i<=6), [4,5,6])\ntrue\n\njulia> all(i -> (println(i); i < 3), 1:10)\n1\n2\n3\nfalse\n\njulia> all(i -> i > 0, [1, missing])\nmissing\n\njulia> all(i -> i > 0, [-1, missing])\nfalse\n\njulia> all(i -> i > 0, [1, 2])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.all!","page":"Collections and Data Structures","title":"Base.all!","text":"all!(r, A)\n\nTest whether all values in A along the singleton dimensions of r are true, and write results to r.\n\nExamples\n\njulia> A = [true false; true false]\n2×2 Array{Bool,2}:\n 1  0\n 1  0\n\njulia> all!([1; 1], A)\n2-element Array{Int64,1}:\n 0\n 0\n\njulia> all!([1 1], A)\n1×2 Array{Int64,2}:\n 1  0\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.count","page":"Collections and Data Structures","title":"Base.count","text":"count(p, itr) -> Integer\ncount(itr) -> Integer\n\nCount the number of elements in itr for which predicate p returns true. If p is omitted, counts the number of true elements in itr (which should be a collection of boolean values).\n\nExamples\n\njulia> count(i->(4<=i<=6), [2,3,4,5,6])\n3\n\njulia> count([true, false, true, true])\n3\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.any-Tuple{Any,Any}","page":"Collections and Data Structures","title":"Base.any","text":"any(p, itr) -> Bool\n\nDetermine whether predicate p returns true for any elements of itr, returning true as soon as the first item in itr for which p returns true is encountered (short-circuiting).\n\nIf the input contains missing values, return missing if all non-missing values are false (or equivalently, if the input contains no true value), following three-valued logic.\n\nExamples\n\njulia> any(i->(4<=i<=6), [3,5,7])\ntrue\n\njulia> any(i -> (println(i); i > 3), 1:10)\n1\n2\n3\n4\ntrue\n\njulia> any(i -> i > 0, [1, missing])\ntrue\n\njulia> any(i -> i > 0, [-1, missing])\nmissing\n\njulia> any(i -> i > 0, [-1, 0])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.all-Tuple{Any,Any}","page":"Collections and Data Structures","title":"Base.all","text":"all(p, itr) -> Bool\n\nDetermine whether predicate p returns true for all elements of itr, returning false as soon as the first item in itr for which p returns false is encountered (short-circuiting).\n\nIf the input contains missing values, return missing if all non-missing values are true (or equivalently, if the input contains no false value), following three-valued logic.\n\nExamples\n\njulia> all(i->(4<=i<=6), [4,5,6])\ntrue\n\njulia> all(i -> (println(i); i < 3), 1:10)\n1\n2\n3\nfalse\n\njulia> all(i -> i > 0, [1, missing])\nmissing\n\njulia> all(i -> i > 0, [-1, missing])\nfalse\n\njulia> all(i -> i > 0, [1, 2])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.foreach","page":"Collections and Data Structures","title":"Base.foreach","text":"foreach(f, c...) -> Nothing\n\nCall function f on each element of iterable c. For multiple iterable arguments, f is called elementwise. foreach should be used instead of map when the results of f are not needed, for example in foreach(println, array).\n\nExamples\n\njulia> a = 1:3:7;\n\njulia> foreach(x -> println(x^2), a)\n1\n16\n49\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.map","page":"Collections and Data Structures","title":"Base.map","text":"map(f, c...) -> collection\n\nTransform collection c by applying f to each element. For multiple collection arguments, apply f elementwise.\n\nSee also: mapslices\n\nExamples\n\njulia> map(x -> x * 2, [1, 2, 3])\n3-element Array{Int64,1}:\n 2\n 4\n 6\n\njulia> map(+, [1, 2, 3], [10, 20, 30])\n3-element Array{Int64,1}:\n 11\n 22\n 33\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.map!","page":"Collections and Data Structures","title":"Base.map!","text":"map!(function, destination, collection...)\n\nLike map, but stores the result in destination rather than a new collection. destination must be at least as large as the first collection.\n\nExamples\n\njulia> a = zeros(3);\n\njulia> map!(x -> x * 2, a, [1, 2, 3]);\n\njulia> a\n3-element Array{Float64,1}:\n 2.0\n 4.0\n 6.0\n\n\n\n\n\nmap!(f, values(dict::AbstractDict))\n\nModifies dict by transforming each value from val to f(val). Note that the type of dict cannot be changed: if f(val) is not an instance of the key type of dict then it will be converted to the key type if possible and otherwise raise an error.\n\nExamples\n\n```jldoctest julia> d = Dict(:a => 1, :b => 2) Dict{Symbol,Int64} with 2 entries:   :a => 1   :b => 2\n\njulia> map!(v -> v-1, values(d)) Dict{Symbol,Int64} with 2 entries:   :a => 0   :b => 1  ```\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.mapreduce-Tuple{Any,Any,Any}","page":"Collections and Data Structures","title":"Base.mapreduce","text":"mapreduce(f, op, itrs...; [init])\n\nApply function f to each element(s) in itrs, and then reduce the result using the binary function op. If provided, init must be a neutral element for op that will be returned for empty collections. It is unspecified whether init is used for non-empty collections. In general, it will be necessary to provide init to work with empty collections.\n\nmapreduce is functionally equivalent to calling reduce(op, map(f, itr); init=init), but will in general execute faster since no intermediate collection needs to be created. See documentation for reduce and map.\n\ncompat: Julia 1.2\nmapreduce with multiple iterators requires Julia 1.2 or later.\n\nExamples\n\njulia> mapreduce(x->x^2, +, [1:3;]) # == 1 + 4 + 9\n14\n\nThe associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of f for elements that appear multiple times in itr. Use mapfoldl or mapfoldr instead for guaranteed left or right associativity and invocation of f for every value.\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.mapfoldl-Tuple{Any,Any,Any}","page":"Collections and Data Structures","title":"Base.mapfoldl","text":"mapfoldl(f, op, itr; [init])\n\nLike mapreduce, but with guaranteed left associativity, as in foldl. If provided, the keyword argument init will be used exactly once. In general, it will be necessary to provide init to work with empty collections.\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.mapfoldr-Tuple{Any,Any,Any}","page":"Collections and Data Structures","title":"Base.mapfoldr","text":"mapfoldr(f, op, itr; [init])\n\nLike mapreduce, but with guaranteed right associativity, as in foldr. If provided, the keyword argument init will be used exactly once. In general, it will be necessary to provide init to work with empty collections.\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.first","page":"Collections and Data Structures","title":"Base.first","text":"first(coll)\n\nGet the first element of an iterable collection. Return the start point of an AbstractRange even if it is empty.\n\nExamples\n\njulia> first(2:2:10)\n2\n\njulia> first([1; 2; 3; 4])\n1\n\n\n\n\n\nfirst(s::AbstractString, n::Integer)\n\nGet a string consisting of the first n characters of s.\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 1)\n\"∀\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 3)\n\"∀ϵ≠\"\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.last","page":"Collections and Data Structures","title":"Base.last","text":"last(coll)\n\nGet the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling lastindex to get the last index. Return the end point of an AbstractRange even if it is empty.\n\nExamples\n\njulia> last(1:2:10)\n9\n\njulia> last([1; 2; 3; 4])\n4\n\n\n\n\n\nlast(s::AbstractString, n::Integer)\n\nGet a string consisting of the last n characters of s.\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 1)\n\"0\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 3)\n\"²>0\"\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.front","page":"Collections and Data Structures","title":"Base.front","text":"front(x::Tuple)::Tuple\n\nReturn a Tuple consisting of all but the last component of x.\n\nExamples\n\njulia> Base.front((1,2,3))\n(1, 2)\n\njulia> Base.front(())\nERROR: ArgumentError: Cannot call front on an empty tuple.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.tail","page":"Collections and Data Structures","title":"Base.tail","text":"tail(x::Tuple)::Tuple\n\nReturn a Tuple consisting of all but the first component of x.\n\nExamples\n\njulia> Base.tail((1,2,3))\n(2, 3)\n\njulia> Base.tail(())\nERROR: ArgumentError: Cannot call tail on an empty tuple.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.step","page":"Collections and Data Structures","title":"Base.step","text":"step(r)\n\nGet the step size of an AbstractRange object.\n\nExamples\n\njulia> step(1:10)\n1\n\njulia> step(1:2:10)\n2\n\njulia> step(2.5:0.3:10.9)\n0.3\n\njulia> step(range(2.5, stop=10.9, length=85))\n0.1\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.collect-Tuple{Any}","page":"Collections and Data Structures","title":"Base.collect","text":"collect(collection)\n\nReturn an Array of all items in a collection or iterator. For dictionaries, returns Pair{KeyType, ValType}. If the argument is array-like or is an iterator with the HasShape trait, the result will have the same shape and number of dimensions as the argument.\n\nExamples\n\njulia> collect(1:2:13)\n7-element Array{Int64,1}:\n  1\n  3\n  5\n  7\n  9\n 11\n 13\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.collect-Tuple{Type,Any}","page":"Collections and Data Structures","title":"Base.collect","text":"collect(element_type, collection)\n\nReturn an Array with the given element type of all items in a collection or iterable. The result has the same shape and number of dimensions as collection.\n\nExamples\n\njulia> collect(Float64, 1:2:5)\n3-element Array{Float64,1}:\n 1.0\n 3.0\n 5.0\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.filter","page":"Collections and Data Structures","title":"Base.filter","text":"filter(f, a::AbstractArray)\n\nReturn a copy of a, removing elements for which f is false. The function f is passed one argument.\n\nExamples\n\njulia> a = 1:10\n1:10\n\njulia> filter(isodd, a)\n5-element Array{Int64,1}:\n 1\n 3\n 5\n 7\n 9\n\n\n\n\n\nfilter(f, d::AbstractDict)\n\nReturn a copy of d, removing elements for which f is false. The function f is passed key=>value pairs.\n\nExamples\n\njulia> d = Dict(1=>\"a\", 2=>\"b\")\nDict{Int64,String} with 2 entries:\n  2 => \"b\"\n  1 => \"a\"\n\njulia> filter(p->isodd(p.first), d)\nDict{Int64,String} with 1 entry:\n  1 => \"a\"\n\n\n\n\n\nfilter(f, itr::SkipMissing{<:AbstractArray})\n\nReturn a vector similar to the array wrapped by the given SkipMissing iterator but with all missing elements and those for which f returns false removed.\n\ncompat: Julia 1.2\nThis method requires Julia 1.2 or later.\n\nExamples\n\njulia> x = [1 2; missing 4]\n2×2 Array{Union{Missing, Int64},2}:\n 1         2\n  missing  4\n\njulia> filter(isodd, skipmissing(x))\n1-element Array{Int64,1}:\n 1\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.filter!","page":"Collections and Data Structures","title":"Base.filter!","text":"filter!(f, a::AbstractVector)\n\nUpdate a, removing elements for which f is false. The function f is passed one argument.\n\nExamples\n\njulia> filter!(isodd, Vector(1:10))\n5-element Array{Int64,1}:\n 1\n 3\n 5\n 7\n 9\n\n\n\n\n\nfilter!(f, d::AbstractDict)\n\nUpdate d, removing elements for which f is false. The function f is passed key=>value pairs.\n\nExample\n\njulia> d = Dict(1=>\"a\", 2=>\"b\", 3=>\"c\")\nDict{Int64,String} with 3 entries:\n  2 => \"b\"\n  3 => \"c\"\n  1 => \"a\"\n\njulia> filter!(p->isodd(p.first), d)\nDict{Int64,String} with 2 entries:\n  3 => \"c\"\n  1 => \"a\"\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.replace-Tuple{Any,Vararg{Pair,N} where N}","page":"Collections and Data Structures","title":"Base.replace","text":"replace(A, old_new::Pair...; [count::Integer])\n\nReturn a copy of collection A where, for each pair old=>new in old_new, all occurrences of old are replaced by new. Equality is determined using isequal. If count is specified, then replace at most count occurrences in total.\n\nThe element type of the result is chosen using promotion (see promote_type) based on the element type of A and on the types of the new values in pairs. If count is omitted and the element type of A is a Union, the element type of the result will not include singleton types which are replaced with values of a different type: for example, Union{T,Missing} will become T if missing is replaced.\n\nSee also replace!.\n\nExamples\n\njulia> replace([1, 2, 1, 3], 1=>0, 2=>4, count=2)\n4-element Array{Int64,1}:\n 0\n 4\n 1\n 3\n\njulia> replace([1, missing], missing=>0)\n2-element Array{Int64,1}:\n 1\n 0\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.replace-Tuple{Union{Function, Type},Any}","page":"Collections and Data Structures","title":"Base.replace","text":"replace(new::Function, A; [count::Integer])\n\nReturn a copy of A where each value x in A is replaced by new(x) If count is specified, then replace at most count values in total (replacements being defined as new(x) !== x).\n\nExamples\n\njulia> replace(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])\n4-element Array{Int64,1}:\n 2\n 2\n 6\n 4\n\njulia> replace(Dict(1=>2, 3=>4)) do kv\n           first(kv) < 3 ? first(kv)=>3 : kv\n       end\nDict{Int64,Int64} with 2 entries:\n  3 => 4\n  1 => 3\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.replace!","page":"Collections and Data Structures","title":"Base.replace!","text":"replace!(A, old_new::Pair...; [count::Integer])\n\nFor each pair old=>new in old_new, replace all occurrences of old in collection A by new. Equality is determined using isequal. If count is specified, then replace at most count occurrences in total. See also replace.\n\nExamples\n\njulia> replace!([1, 2, 1, 3], 1=>0, 2=>4, count=2)\n4-element Array{Int64,1}:\n 0\n 4\n 1\n 3\n\njulia> replace!(Set([1, 2, 3]), 1=>0)\nSet([0, 2, 3])\n\n\n\n\n\nreplace!(new::Function, A; [count::Integer])\n\nReplace each element x in collection A by new(x). If count is specified, then replace at most count values in total (replacements being defined as new(x) !== x).\n\nExamples\n\njulia> replace!(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])\n4-element Array{Int64,1}:\n 2\n 2\n 6\n 4\n\njulia> replace!(Dict(1=>2, 3=>4)) do kv\n           first(kv) < 3 ? first(kv)=>3 : kv\n       end\nDict{Int64,Int64} with 2 entries:\n  3 => 4\n  1 => 3\n\njulia> replace!(x->2x, Set([3, 6]))\nSet([6, 12])\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Indexable-Collections-1","page":"Collections and Data Structures","title":"Indexable Collections","text":"","category":"section"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Base.getindex\nBase.setindex!\nBase.firstindex\nBase.lastindex","category":"page"},{"location":"base/collections.html#Base.getindex","page":"Collections and Data Structures","title":"Base.getindex","text":"getindex(collection, key...)\n\nRetrieve the value(s) stored at the given key or index within a collection. The syntax a[i,j,...] is converted by the compiler to getindex(a, i, j, ...).\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> getindex(A, \"a\")\n1\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.setindex!","page":"Collections and Data Structures","title":"Base.setindex!","text":"setindex!(collection, value, key...)\n\nStore the given value at the given key or index within a collection. The syntax a[i,j,...] = x is converted by the compiler to (setindex!(a, x, i, j, ...); x).\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.firstindex","page":"Collections and Data Structures","title":"Base.firstindex","text":"firstindex(collection) -> Integer\nfirstindex(collection, d) -> Integer\n\nReturn the first index of collection. If d is given, return the first index of collection along dimension d.\n\nExamples\n\njulia> firstindex([1,2,4])\n1\n\njulia> firstindex(rand(3,4,5), 2)\n1\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.lastindex","page":"Collections and Data Structures","title":"Base.lastindex","text":"lastindex(collection) -> Integer\nlastindex(collection, d) -> Integer\n\nReturn the last index of collection. If d is given, return the last index of collection along dimension d.\n\nThe syntaxes A[end] and A[end, end] lower to A[lastindex(A)] and A[lastindex(A, 1), lastindex(A, 2)], respectively.\n\nExamples\n\njulia> lastindex([1,2,4])\n3\n\njulia> lastindex(rand(3,4,5), 2)\n4\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Fully implemented by:","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Array\nBitArray\nAbstractArray\nSubArray","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Partially implemented by:","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"AbstractRange\nUnitRange\nTuple\nAbstractString\nDict\nIdDict\nWeakKeyDict\nNamedTuple","category":"page"},{"location":"base/collections.html#Dictionaries-1","page":"Collections and Data Structures","title":"Dictionaries","text":"","category":"section"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Dict is the standard dictionary. Its implementation uses hash  as the hashing function for the key, and isequal to determine equality. Define these two functions for custom types to override how they are stored in a hash table.","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"IdDict is a special hash table where the keys are always object identities.","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"WeakKeyDict is a hash table implementation where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table.  Like Dict it uses hash for hashing and isequal for equality, unlike Dict it does not convert keys on insertion.","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Dicts can be created by passing pair objects constructed with => to a Dict constructor: Dict(\"A\"=>1, \"B\"=>2). This call will attempt to infer type information from the keys and values (i.e. this example creates a Dict{String, Int64}). To explicitly specify types use the syntax Dict{KeyType,ValueType}(...). For example, Dict{String,Int32}(\"A\"=>1, \"B\"=>2).","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Dictionaries may also be created with generators. For example, Dict(i => f(i) for i = 1:10).","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Given a dictionary D, the syntax D[x] returns the value of key x (if it exists) or throws an error, and D[x] = y stores the key-value pair x => y in D (replacing any existing value for the key x).  Multiple arguments to D[...] are converted to tuples; for example, the syntax D[x,y]  is equivalent to D[(x,y)], i.e. it refers to the value keyed by the tuple (x,y).","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Base.AbstractDict\nBase.Dict\nBase.IdDict\nBase.WeakKeyDict\nBase.ImmutableDict\nBase.haskey\nBase.get(::Any, ::Any, ::Any)\nBase.get\nBase.get!(::Any, ::Any, ::Any)\nBase.get!(::Function, ::Any, ::Any)\nBase.getkey\nBase.delete!\nBase.pop!(::Any, ::Any, ::Any)\nBase.keys\nBase.values\nBase.pairs\nBase.merge\nBase.merge!(::AbstractDict, ::AbstractDict...)\nBase.merge!(::Function, ::AbstractDict, ::AbstractDict...)\nBase.sizehint!\nBase.keytype\nBase.valtype","category":"page"},{"location":"base/collections.html#Base.AbstractDict","page":"Collections and Data Structures","title":"Base.AbstractDict","text":"AbstractDict{K, V}\n\nSupertype for dictionary-like types with keys of type K and values of type V. Dict, IdDict and other types are subtypes of this.\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.Dict","page":"Collections and Data Structures","title":"Base.Dict","text":"Dict([itr])\n\nDict{K,V}() constructs a hash table with keys of type K and values of type V. Keys are compared with isequal and hashed with hash.\n\nGiven a single iterable argument, constructs a Dict whose key-value pairs are taken from 2-tuples (key,value) generated by the argument.\n\nExamples\n\njulia> Dict([(\"A\", 1), (\"B\", 2)])\nDict{String,Int64} with 2 entries:\n  \"B\" => 2\n  \"A\" => 1\n\nAlternatively, a sequence of pair arguments may be passed.\n\njulia> Dict(\"A\"=>1, \"B\"=>2)\nDict{String,Int64} with 2 entries:\n  \"B\" => 2\n  \"A\" => 1\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.IdDict","page":"Collections and Data Structures","title":"Base.IdDict","text":"IdDict([itr])\n\nIdDict{K,V}() constructs a hash table using object-id as hash and === as equality with keys of type K and values of type V.\n\nSee Dict for further help.\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.WeakKeyDict","page":"Collections and Data Structures","title":"Base.WeakKeyDict","text":"WeakKeyDict([itr])\n\nWeakKeyDict() constructs a hash table where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table.\n\nSee Dict for further help.  Note, unlike Dict, WeakKeyDict does not convert keys on insertion.\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.ImmutableDict","page":"Collections and Data Structures","title":"Base.ImmutableDict","text":"ImmutableDict\n\nImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key\n\nImmutableDict(KV::Pair)\n\nCreate a new entry in the Immutable Dictionary for the key => value pair\n\nuse (key => value) in dict to see if this particular combination is in the properties set\nuse get(dict, key, default) to retrieve the most recent value for a particular key\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.haskey","page":"Collections and Data Structures","title":"Base.haskey","text":"haskey(collection, key) -> Bool\n\nDetermine whether a collection has a mapping for a given key.\n\nExamples\n\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char,Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> haskey(D, 'a')\ntrue\n\njulia> haskey(D, 'c')\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.get-Tuple{Any,Any,Any}","page":"Collections and Data Structures","title":"Base.get","text":"get(collection, key, default)\n\nReturn the value stored for the given key, or the given default value if no mapping for the key is present.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2);\n\njulia> get(d, \"a\", 3)\n1\n\njulia> get(d, \"c\", 3)\n3\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.get","page":"Collections and Data Structures","title":"Base.get","text":"get(collection, key, default)\n\nReturn the value stored for the given key, or the given default value if no mapping for the key is present.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2);\n\njulia> get(d, \"a\", 3)\n1\n\njulia> get(d, \"c\", 3)\n3\n\n\n\n\n\nget(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, return f().  Use get! to also store the default value in the dictionary.\n\nThis is intended to be called using do block syntax\n\nget(dict, key) do\n    # default value calculated here\n    time()\nend\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.get!-Tuple{Any,Any,Any}","page":"Collections and Data Structures","title":"Base.get!","text":"get!(collection, key, default)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store key => default, and return default.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> get!(d, \"a\", 5)\n1\n\njulia> get!(d, \"d\", 4)\n4\n\njulia> d\nDict{String,Int64} with 4 entries:\n  \"c\" => 3\n  \"b\" => 2\n  \"a\" => 1\n  \"d\" => 4\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.get!-Tuple{Function,Any,Any}","page":"Collections and Data Structures","title":"Base.get!","text":"get!(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store key => f(), and return f().\n\nThis is intended to be called using do block syntax:\n\nget!(dict, key) do\n    # default value calculated here\n    time()\nend\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.getkey","page":"Collections and Data Structures","title":"Base.getkey","text":"getkey(collection, key, default)\n\nReturn the key matching argument key if one exists in collection, otherwise return default.\n\nExamples\n\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char,Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> getkey(D, 'a', 1)\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> getkey(D, 'd', 'a')\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.delete!","page":"Collections and Data Structures","title":"Base.delete!","text":"delete!(collection, key)\n\nDelete the mapping for the given key in a collection, and return the collection.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> delete!(d, \"b\")\nDict{String,Int64} with 1 entry:\n  \"a\" => 1\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.pop!-Tuple{Any,Any,Any}","page":"Collections and Data Structures","title":"Base.pop!","text":"pop!(collection, key[, default])\n\nDelete and return the mapping for key if it exists in collection, otherwise return default, or throw an error if default is not specified.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n[...]\n\njulia> pop!(d, \"e\", 4)\n4\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.keys","page":"Collections and Data Structures","title":"Base.keys","text":"keys(iterator)\n\nFor an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over the keys.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.values","page":"Collections and Data Structures","title":"Base.values","text":"values(iterator)\n\nFor an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its \"values\".\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2);\n\njulia> values(d)\nBase.ValueIterator for a Dict{String,Int64} with 2 entries. Values:\n  2\n  1\n\njulia> values([2])\n1-element Array{Int64,1}:\n 2\n\n\n\n\n\nvalues(a::AbstractDict)\n\nReturn an iterator over all values in a collection. collect(values(a)) returns an array of values. Since the values are stored internally in a hash table, the order in which they are returned may vary. But keys(a) and values(a) both iterate a and return the elements in the same order.\n\nExamples\n\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char,Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> collect(values(D))\n2-element Array{Int64,1}:\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.pairs","page":"Collections and Data Structures","title":"Base.pairs","text":"pairs(collection)\n\nReturn an iterator over key => value pairs for any collection that maps a set of keys to a set of values. This includes arrays, where the keys are the array indices.\n\n\n\n\n\npairs(IndexLinear(), A)\npairs(IndexCartesian(), A)\npairs(IndexStyle(A), A)\n\nAn iterator that accesses each element of the array A, returning i => x, where i is the index for the element and x = A[i]. Identical to pairs(A), except that the style of index can be selected. Also similar to enumerate(A), except i will be a valid index for A, while enumerate always counts from 1 regardless of the indices of A.\n\nSpecifying IndexLinear() ensures that i will be an integer; specifying IndexCartesian() ensures that i will be a CartesianIndex; specifying IndexStyle(A) chooses whichever has been defined as the native indexing style for array A.\n\nMutation of the bounds of the underlying array will invalidate this iterator.\n\nExamples\n\njulia> A = [\"a\" \"d\"; \"b\" \"e\"; \"c\" \"f\"];\n\njulia> for (index, value) in pairs(IndexStyle(A), A)\n           println(\"$index $value\")\n       end\n1 a\n2 b\n3 c\n4 d\n5 e\n6 f\n\njulia> S = view(A, 1:2, :);\n\njulia> for (index, value) in pairs(IndexStyle(S), S)\n           println(\"$index $value\")\n       end\nCartesianIndex(1, 1) a\nCartesianIndex(2, 1) b\nCartesianIndex(1, 2) d\nCartesianIndex(2, 2) e\n\nSee also: IndexStyle, axes.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.merge","page":"Collections and Data Structures","title":"Base.merge","text":"merge(d::AbstractDict, others::AbstractDict...)\n\nConstruct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.\n\nExamples\n\njulia> a = Dict(\"foo\" => 0.0, \"bar\" => 42.0)\nDict{String,Float64} with 2 entries:\n  \"bar\" => 42.0\n  \"foo\" => 0.0\n\njulia> b = Dict(\"baz\" => 17, \"bar\" => 4711)\nDict{String,Int64} with 2 entries:\n  \"bar\" => 4711\n  \"baz\" => 17\n\njulia> merge(a, b)\nDict{String,Float64} with 3 entries:\n  \"bar\" => 4711.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\njulia> merge(b, a)\nDict{String,Float64} with 3 entries:\n  \"bar\" => 42.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\n\n\n\n\nmerge(combine, d::AbstractDict, others::AbstractDict...)\n\nConstruct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.\n\nExamples\n\njulia> a = Dict(\"foo\" => 0.0, \"bar\" => 42.0)\nDict{String,Float64} with 2 entries:\n  \"bar\" => 42.0\n  \"foo\" => 0.0\n\njulia> b = Dict(\"baz\" => 17, \"bar\" => 4711)\nDict{String,Int64} with 2 entries:\n  \"bar\" => 4711\n  \"baz\" => 17\n\njulia> merge(+, a, b)\nDict{String,Float64} with 3 entries:\n  \"bar\" => 4753.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\n\n\n\n\nmerge(a::NamedTuple, bs::NamedTuple...)\n\nConstruct a new named tuple by merging two or more existing ones, in a left-associative manner. Merging proceeds left-to-right, between pairs of named tuples, and so the order of fields present in both the leftmost and rightmost named tuples take the same position as they are found in the leftmost named tuple. However, values are taken from matching fields in the rightmost named tuple that contains that field. Fields present in only the rightmost named tuple of a pair are appended at the end. A fallback is implemented for when only a single named tuple is supplied, with signature merge(a::NamedTuple).\n\ncompat: Julia 1.1\nMerging 3 or more NamedTuple requires at least Julia 1.1.\n\nExamples\n\njulia> merge((a=1, b=2, c=3), (b=4, d=5))\n(a = 1, b = 4, c = 3, d = 5)\n\njulia> merge((a=1, b=2), (b=3, c=(d=1,)), (c=(d=2,),))\n(a = 1, b = 3, c = (d = 2,))\n\n\n\n\n\nmerge(a::NamedTuple, iterable)\n\nInterpret an iterable of key-value pairs as a named tuple, and perform a merge.\n\njulia> merge((a=1, b=2, c=3), [:b=>4, :d=>5])\n(a = 1, b = 4, c = 3, d = 5)\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.merge!-Tuple{AbstractDict,Vararg{AbstractDict,N} where N}","page":"Collections and Data Structures","title":"Base.merge!","text":"merge!(d::AbstractDict, others::AbstractDict...)\n\nUpdate collection with pairs from the other collections. See also merge.\n\nExamples\n\njulia> d1 = Dict(1 => 2, 3 => 4);\n\njulia> d2 = Dict(1 => 4, 4 => 5);\n\njulia> merge!(d1, d2);\n\njulia> d1\nDict{Int64,Int64} with 3 entries:\n  4 => 5\n  3 => 4\n  1 => 4\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.merge!-Tuple{Function,AbstractDict,Vararg{AbstractDict,N} where N}","page":"Collections and Data Structures","title":"Base.merge!","text":"merge!(combine, d::AbstractDict, others::AbstractDict...)\n\nUpdate collection with pairs from the other collections. Values with the same key will be combined using the combiner function.\n\nExamples\n\njulia> d1 = Dict(1 => 2, 3 => 4);\n\njulia> d2 = Dict(1 => 4, 4 => 5);\n\njulia> merge!(+, d1, d2);\n\njulia> d1\nDict{Int64,Int64} with 3 entries:\n  4 => 5\n  3 => 4\n  1 => 6\n\njulia> merge!(-, d1, d1);\n\njulia> d1\nDict{Int64,Int64} with 3 entries:\n  4 => 0\n  3 => 0\n  1 => 0\n\n\n\n\n\n","category":"method"},{"location":"base/collections.html#Base.sizehint!","page":"Collections and Data Structures","title":"Base.sizehint!","text":"sizehint!(s, n)\n\nSuggest that collection s reserve capacity for at least n elements. This can improve performance.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.keytype","page":"Collections and Data Structures","title":"Base.keytype","text":"keytype(T::Type{<:AbstractArray})\nkeytype(A::AbstractArray)\n\nReturn the key type of an array. This is equal to the eltype of the result of keys(...), and is provided mainly for compatibility with the dictionary interface.\n\nExamples\n\njulia> keytype([1, 2, 3]) == Int\ntrue\n\njulia> keytype([1 2; 3 4])\nCartesianIndex{2}\n\ncompat: Julia 1.2\nFor arrays, this function requires at least Julia 1.2.\n\n\n\n\n\nkeytype(type)\n\nGet the key type of an dictionary type. Behaves similarly to eltype.\n\nExamples\n\njulia> keytype(Dict(Int32(1) => \"foo\"))\nInt32\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.valtype","page":"Collections and Data Structures","title":"Base.valtype","text":"valtype(T::Type{<:AbstractArray})\nvaltype(A::AbstractArray)\n\nReturn the value type of an array. This is identical to eltype and is provided mainly for compatibility with the dictionary interface.\n\nExamples\n\njulia> valtype([\"one\", \"two\", \"three\"])\nString\n\ncompat: Julia 1.2\nFor arrays, this function requires at least Julia 1.2.\n\n\n\n\n\nvaltype(type)\n\nGet the value type of an dictionary type. Behaves similarly to eltype.\n\nExamples\n\njulia> valtype(Dict(Int32(1) => \"foo\"))\nString\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Fully implemented by:","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"IdDict\nDict\nWeakKeyDict","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Partially implemented by:","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"BitSet\nSet\nEnvDict\nArray\nBitArray\nImmutableDict\nIterators.Pairs","category":"page"},{"location":"base/collections.html#Set-Like-Collections-1","page":"Collections and Data Structures","title":"Set-Like Collections","text":"","category":"section"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Base.AbstractSet\nBase.Set\nBase.BitSet\nBase.union\nBase.union!\nBase.intersect\nBase.setdiff\nBase.setdiff!\nBase.symdiff\nBase.symdiff!\nBase.intersect!\nBase.issubset\nBase.:⊈\nBase.:⊊\nBase.issetequal","category":"page"},{"location":"base/collections.html#Base.AbstractSet","page":"Collections and Data Structures","title":"Base.AbstractSet","text":"AbstractSet{T}\n\nSupertype for set-like types whose elements are of type T. Set, BitSet and other types are subtypes of this.\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.Set","page":"Collections and Data Structures","title":"Base.Set","text":"Set([itr])\n\nConstruct a Set of the values generated by the given iterable object, or an empty set. Should be used instead of BitSet for sparse integer sets, or for sets of arbitrary objects.\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.BitSet","page":"Collections and Data Structures","title":"Base.BitSet","text":"BitSet([itr])\n\nConstruct a sorted set of Ints generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. If the set will be sparse (for example, holding a few very large integers), use Set instead.\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.union","page":"Collections and Data Structures","title":"Base.union","text":"union(s, itrs...)\n∪(s, itrs...)\n\nConstruct the union of sets. Maintain order with arrays.\n\nExamples\n\njulia> union([1, 2], [3, 4])\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> union([1, 2], [2, 4])\n3-element Array{Int64,1}:\n 1\n 2\n 4\n\njulia> union([4, 2], 1:2)\n3-element Array{Int64,1}:\n 4\n 2\n 1\n\njulia> union(Set([1, 2]), 2:3)\nSet([2, 3, 1])\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.union!","page":"Collections and Data Structures","title":"Base.union!","text":"union!(s::Union{AbstractSet,AbstractVector}, itrs...)\n\nConstruct the union of passed in sets and overwrite s with the result. Maintain order with arrays.\n\nExamples\n\njulia> a = Set([1, 3, 4, 5]);\n\njulia> union!(a, 1:2:8);\n\njulia> a\nSet([7, 4, 3, 5, 1])\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.intersect","page":"Collections and Data Structures","title":"Base.intersect","text":"intersect(s, itrs...)\n∩(s, itrs...)\n\nConstruct the intersection of sets. Maintain order with arrays.\n\nExamples\n\njulia> intersect([1, 2, 3], [3, 4, 5])\n1-element Array{Int64,1}:\n 3\n\njulia> intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])\n2-element Array{Int64,1}:\n 4\n 6\n\njulia> intersect(Set([1, 2]), BitSet([2, 3]))\nSet([2])\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.setdiff","page":"Collections and Data Structures","title":"Base.setdiff","text":"setdiff(s, itrs...)\n\nConstruct the set of elements in s but not in any of the iterables in itrs. Maintain order with arrays.\n\nExamples\n\njulia> setdiff([1,2,3], [3,4,5])\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.setdiff!","page":"Collections and Data Structures","title":"Base.setdiff!","text":"setdiff!(s, itrs...)\n\nRemove from set s (in-place) each element of each iterable from itrs. Maintain order with arrays.\n\nExamples\n\njulia> a = Set([1, 3, 4, 5]);\n\njulia> setdiff!(a, 1:2:6);\n\njulia> a\nSet([4])\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.symdiff","page":"Collections and Data Structures","title":"Base.symdiff","text":"symdiff(s, itrs...)\n\nConstruct the symmetric difference of elements in the passed in sets. When s is not an AbstractSet, the order is maintained. Note that in this case the multiplicity of elements matters.\n\nExamples\n\njulia> symdiff([1,2,3], [3,4,5], [4,5,6])\n3-element Array{Int64,1}:\n 1\n 2\n 6\n\njulia> symdiff([1,2,1], [2, 1, 2])\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> symdiff(unique([1,2,1]), unique([2, 1, 2]))\n0-element Array{Int64,1}\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.symdiff!","page":"Collections and Data Structures","title":"Base.symdiff!","text":"symdiff!(s::Union{AbstractSet,AbstractVector}, itrs...)\n\nConstruct the symmetric difference of the passed in sets, and overwrite s with the result. When s is an array, the order is maintained. Note that in this case the multiplicity of elements matters.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.intersect!","page":"Collections and Data Structures","title":"Base.intersect!","text":"intersect!(s::Union{AbstractSet,AbstractVector}, itrs...)\n\nIntersect all passed in sets and overwrite s with the result. Maintain order with arrays.\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.issubset","page":"Collections and Data Structures","title":"Base.issubset","text":"issubset(a, b)\n⊆(a,b)  -> Bool\n⊇(b, a) -> Bool\n\nDetermine whether every element of a is also in b, using in.\n\nExamples\n\njulia> issubset([1, 2], [1, 2, 3])\ntrue\n\njulia> [1, 2, 3] ⊆ [1, 2]\nfalse\n\njulia> [1, 2, 3] ⊇ [1, 2]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.:⊈","page":"Collections and Data Structures","title":"Base.:⊈","text":"⊈(a, b)\n⊉(b, a)\n\nNegation of ⊆ and ⊇, i.e. checks that a is not a subset of b.\n\nExamples\n\njulia> (1, 2) ⊈ (2, 3)\ntrue\n\njulia> (1, 2) ⊈ (1, 2, 3)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.:⊊","page":"Collections and Data Structures","title":"Base.:⊊","text":"⊊(a, b)\n⊋(b, a)\n\nDetermines if a is a subset of, but not equal to, b.\n\nExamples\n\njulia> (1, 2) ⊊ (1, 2, 3)\ntrue\n\njulia> (1, 2) ⊊ (1, 2)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.issetequal","page":"Collections and Data Structures","title":"Base.issetequal","text":"issetequal(a, b)\n\nDetermine whether a and b have the same elements. Equivalent to a ⊆ b && b ⊆ a.\n\nExamples\n\njulia> issetequal([1, 2], [1, 2, 3])\nfalse\n\njulia> issetequal([1, 2], [2, 1])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Fully implemented by:","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"BitSet\nSet","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Partially implemented by:","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Array","category":"page"},{"location":"base/collections.html#Dequeues-1","page":"Collections and Data Structures","title":"Dequeues","text":"","category":"section"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Base.push!\nBase.pop!\nBase.pushfirst!\nBase.popfirst!\nBase.insert!\nBase.deleteat!\nBase.splice!\nBase.resize!\nBase.append!\nBase.prepend!","category":"page"},{"location":"base/collections.html#Base.push!","page":"Collections and Data Structures","title":"Base.push!","text":"push!(collection, items...) -> collection\n\nInsert one or more items at the end of collection.\n\nExamples\n\njulia> push!([1, 2, 3], 4, 5, 6)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nUse append! to add all the elements of another collection to collection. The result of the preceding example is equivalent to append!([1, 2, 3], [4, 5, 6]).\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.pop!","page":"Collections and Data Structures","title":"Base.pop!","text":"pop!(collection) -> item\n\nRemove an item in collection and return it. If collection is an ordered container, the last item is returned.\n\nExamples\n\njulia> A=[1, 2, 3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> pop!(A)\n3\n\njulia> A\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> S = Set([1, 2])\nSet([2, 1])\n\njulia> pop!(S)\n2\n\njulia> S\nSet([1])\n\njulia> pop!(Dict(1=>2))\n1 => 2\n\n\n\n\n\npop!(collection, key[, default])\n\nDelete and return the mapping for key if it exists in collection, otherwise return default, or throw an error if default is not specified.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n[...]\n\njulia> pop!(d, \"e\", 4)\n4\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.pushfirst!","page":"Collections and Data Structures","title":"Base.pushfirst!","text":"pushfirst!(collection, items...) -> collection\n\nInsert one or more items at the beginning of collection.\n\nExamples\n\njulia> pushfirst!([1, 2, 3, 4], 5, 6)\n6-element Array{Int64,1}:\n 5\n 6\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.popfirst!","page":"Collections and Data Structures","title":"Base.popfirst!","text":"popfirst!(collection) -> item\n\nRemove the first item from collection.\n\nExamples\n\njulia> A = [1, 2, 3, 4, 5, 6]\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> popfirst!(A)\n1\n\njulia> A\n5-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.insert!","page":"Collections and Data Structures","title":"Base.insert!","text":"insert!(a::Vector, index::Integer, item)\n\nInsert an item into a at the given index. index is the index of item in the resulting a.\n\nExamples\n\njulia> insert!([6, 5, 4, 2, 1], 4, 3)\n6-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.deleteat!","page":"Collections and Data Structures","title":"Base.deleteat!","text":"deleteat!(a::Vector, i::Integer)\n\nRemove the item at the given i and return the modified a. Subsequent items are shifted to fill the resulting gap.\n\nExamples\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], 2)\n5-element Array{Int64,1}:\n 6\n 4\n 3\n 2\n 1\n\n\n\n\n\ndeleteat!(a::Vector, inds)\n\nRemove the items at the indices given by inds, and return the modified a. Subsequent items are shifted to fill the resulting gap.\n\ninds can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as a with true indicating entries to delete.\n\nExamples\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)\n3-element Array{Int64,1}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])\n3-element Array{Int64,1}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], (2, 2))\nERROR: ArgumentError: indices must be unique and sorted\nStacktrace:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.splice!","page":"Collections and Data Structures","title":"Base.splice!","text":"splice!(a::Vector, index::Integer, [replacement]) -> item\n\nRemove the item at the given index, and return the removed item. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.\n\nExamples\n\njulia> A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)\n2\n\njulia> A\n5-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 1\n\njulia> splice!(A, 5, -1)\n1\n\njulia> A\n5-element Array{Int64,1}:\n  6\n  5\n  4\n  3\n -1\n\njulia> splice!(A, 1, [-1, -2, -3])\n6\n\njulia> A\n7-element Array{Int64,1}:\n -1\n -2\n -3\n  5\n  4\n  3\n -1\n\nTo insert replacement before an index n without removing any items, use splice!(collection, n:n-1, replacement).\n\n\n\n\n\nsplice!(a::Vector, range, [replacement]) -> items\n\nRemove items in the specified index range, and return a collection containing the removed items. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed items.\n\nTo insert replacement before an index n without removing any items, use splice!(collection, n:n-1, replacement).\n\nExamples\n\njulia> splice!(A, 4:3, 2)\n0-element Array{Int64,1}\n\njulia> A\n8-element Array{Int64,1}:\n -1\n -2\n -3\n  2\n  5\n  4\n  3\n -1\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.resize!","page":"Collections and Data Structures","title":"Base.resize!","text":"resize!(a::Vector, n::Integer) -> Vector\n\nResize a to contain n elements. If n is smaller than the current collection length, the first n elements will be retained. If n is larger, the new elements are not guaranteed to be initialized.\n\nExamples\n\njulia> resize!([6, 5, 4, 3, 2, 1], 3)\n3-element Array{Int64,1}:\n 6\n 5\n 4\n\njulia> a = resize!([6, 5, 4, 3, 2, 1], 8);\n\njulia> length(a)\n8\n\njulia> a[1:6]\n6-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.append!","page":"Collections and Data Structures","title":"Base.append!","text":"append!(collection, collection2) -> collection.\n\nAdd the elements of collection2 to the end of collection.\n\nExamples\n\njulia> append!([1],[2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> append!([1, 2, 3], [4, 5, 6])\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nUse push! to add individual items to collection which are not already themselves in another collection. The result of the preceding example is equivalent to push!([1, 2, 3], 4, 5, 6).\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#Base.prepend!","page":"Collections and Data Structures","title":"Base.prepend!","text":"prepend!(a::Vector, items) -> collection\n\nInsert the elements of items to the beginning of a.\n\nExamples\n\njulia> prepend!([3],[1,2])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Fully implemented by:","category":"page"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Vector (a.k.a. 1-dimensional Array)\nBitVector (a.k.a. 1-dimensional BitArray)","category":"page"},{"location":"base/collections.html#Utility-Collections-1","page":"Collections and Data Structures","title":"Utility Collections","text":"","category":"section"},{"location":"base/collections.html#","page":"Collections and Data Structures","title":"Collections and Data Structures","text":"Base.Pair\nIterators.Pairs","category":"page"},{"location":"base/collections.html#Base.Pair","page":"Collections and Data Structures","title":"Base.Pair","text":"Pair(x, y)\nx => y\n\nConstruct a Pair object with type Pair{typeof(x), typeof(y)}. The elements are stored in the fields first and second. They can also be accessed via iteration.\n\nSee also: Dict\n\nExamples\n\njulia> p = \"foo\" => 7\n\"foo\" => 7\n\njulia> typeof(p)\nPair{String,Int64}\n\njulia> p.first\n\"foo\"\n\njulia> for x in p\n           println(x)\n       end\nfoo\n7\n\n\n\n\n\n","category":"type"},{"location":"base/collections.html#Base.Iterators.Pairs","page":"Collections and Data Structures","title":"Base.Iterators.Pairs","text":"Iterators.Pairs(values, keys) <: AbstractDict{eltype(keys), eltype(values)}\n\nTransforms an indexable container into an Dictionary-view of the same data. Modifying the key-space of the underlying data may invalidate this object.\n\n\n\n\n\n","category":"type"},{"location":"base/math.html#Mathematics-1","page":"Mathematics","title":"Mathematics","text":"","category":"section"},{"location":"base/math.html#math-ops-1","page":"Mathematics","title":"Mathematical Operators","text":"","category":"section"},{"location":"base/math.html#","page":"Mathematics","title":"Mathematics","text":"Base.:-(::Any)\nBase.:(+)\nBase.:-(::Any, ::Any)\nBase.:*(::Any, ::Any...)\nBase.:(/)\nBase.:\\(::Any, ::Any)\nBase.:^(::Number, ::Number)\nBase.fma\nBase.muladd\nBase.inv(::Number)\nBase.div\nBase.fld\nBase.cld\nBase.mod\nBase.rem\nBase.rem2pi\nBase.Math.mod2pi\nBase.divrem\nBase.fldmod\nBase.fld1\nBase.mod1\nBase.fldmod1\nBase.:(//)\nBase.rationalize\nBase.numerator\nBase.denominator\nBase.:(<<)\nBase.:(>>)\nBase.:(>>>)\nBase.:(:)\nBase.range\nBase.OneTo\nBase.StepRangeLen\nBase.:(==)\nBase.:(!=)\nBase.:(!==)\nBase.:(<)\nBase.:(<=)\nBase.:(>)\nBase.:(>=)\nBase.cmp\nBase.:(~)\nBase.:(&)\nBase.:(|)\nBase.xor\nBase.:(!)\n&&\n||","category":"page"},{"location":"base/math.html#Base.:--Tuple{Any}","page":"Mathematics","title":"Base.:-","text":"-(x)\n\nUnary minus operator.\n\nExamples\n\njulia> -1\n-1\n\njulia> -(2)\n-2\n\njulia> -[1 2; 3 4]\n2×2 Array{Int64,2}:\n -1  -2\n -3  -4\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.:+","page":"Mathematics","title":"Base.:+","text":"+(x, y...)\n\nAddition operator. x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...).\n\nExamples\n\njulia> 1 + 20 + 4\n25\n\njulia> +(1, 20, 4)\n25\n\n\n\n\n\ndt::Date + t::Time -> DateTime\n\nThe addition of a Date with a Time produces a DateTime. The hour, minute, second, and millisecond parts of the Time are used along with the year, month, and day of the Date to create the new DateTime. Non-zero microseconds or nanoseconds in the Time type will result in an InexactError being thrown.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:--Tuple{Any,Any}","page":"Mathematics","title":"Base.:-","text":"-(x, y)\n\nSubtraction operator.\n\nExamples\n\njulia> 2 - 3\n-1\n\njulia> -(2, 4.5)\n-2.5\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.:*-Tuple{Any,Vararg{Any,N} where N}","page":"Mathematics","title":"Base.:*","text":"*(x, y...)\n\nMultiplication operator. x*y*z*... calls this function with all arguments, i.e. *(x, y, z, ...).\n\nExamples\n\njulia> 2 * 7 * 8\n112\n\njulia> *(2, 7, 8)\n112\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.:/","page":"Mathematics","title":"Base.:/","text":"/(x, y)\n\nRight division operator: multiplication of x by the inverse of y on the right. Gives floating-point results for integer arguments.\n\nExamples\n\njulia> 1/2\n0.5\n\njulia> 4/2\n2.0\n\njulia> 4.5/2\n2.25\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:\\-Tuple{Any,Any}","page":"Mathematics","title":"Base.:\\","text":"\\(x, y)\n\nLeft division operator: multiplication of y by the inverse of x on the left. Gives floating-point results for integer arguments.\n\nExamples\n\njulia> 3 \\ 6\n2.0\n\njulia> inv(3) * 6\n2.0\n\njulia> A = [4 3; 2 1]; x = [5, 6];\n\njulia> A \\ x\n2-element Array{Float64,1}:\n  6.5\n -7.0\n\njulia> inv(A) * x\n2-element Array{Float64,1}:\n  6.5\n -7.0\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.:^-Tuple{Number,Number}","page":"Mathematics","title":"Base.:^","text":"^(x, y)\n\nExponentiation operator. If x is a matrix, computes matrix exponentiation.\n\nIf y is an Int literal (e.g. 2 in x^2 or -3 in x^-3), the Julia code x^y is transformed by the compiler to Base.literal_pow(^, x, Val(y)), to enable compile-time specialization on the value of the exponent. (As a default fallback we have Base.literal_pow(^, x, Val(y)) = ^(x,y), where usually ^ == Base.^ unless ^ has been defined in the calling namespace.)\n\njulia> 3^5\n243\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> A^3\n2×2 Array{Int64,2}:\n 37   54\n 81  118\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.fma","page":"Mathematics","title":"Base.fma","text":"fma(x, y, z)\n\nComputes x*y+z without rounding the intermediate result x*y. On some systems this is significantly more expensive than x*y+z. fma is used to improve accuracy in certain algorithms. See muladd.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.muladd","page":"Mathematics","title":"Base.muladd","text":"muladd(x, y, z)\n\nCombined multiply-add: computes x*y+z, but allowing the add and multiply to be merged with each other or with surrounding operations for performance. For example, this may be implemented as an fma if the hardware supports it efficiently. The result can be different on different machines and can also be different on the same machine due to constant propagation or other optimizations. See fma.\n\nExamples\n\njulia> muladd(3, 2, 1)\n7\n\njulia> 3 * 2 + 1\n7\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.inv-Tuple{Number}","page":"Mathematics","title":"Base.inv","text":"inv(x)\n\nReturn the multiplicative inverse of x, such that x*inv(x) or inv(x)*x yields one(x) (the multiplicative identity) up to roundoff errors.\n\nIf x is a number, this is essentially the same as one(x)/x, but for some types inv(x) may be slightly more efficient.\n\nExamples\n\njulia> inv(2)\n0.5\n\njulia> inv(1 + 2im)\n0.2 - 0.4im\n\njulia> inv(1 + 2im) * (1 + 2im)\n1.0 + 0.0im\n\njulia> inv(2//3)\n3//2\n\ncompat: Julia 1.2\ninv(::Missing) requires at least Julia 1.2.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.div","page":"Mathematics","title":"Base.div","text":"div(x, y)\n÷(x, y)\n\nThe quotient from Euclidean division. Computes x/y, truncated to an integer.\n\nExamples\n\njulia> 9 ÷ 4\n2\n\njulia> -5 ÷ 3\n-1\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.fld","page":"Mathematics","title":"Base.fld","text":"fld(x, y)\n\nLargest integer less than or equal to x/y.\n\nExamples\n\njulia> fld(7.3,5.5)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.cld","page":"Mathematics","title":"Base.cld","text":"cld(x, y)\n\nSmallest integer larger than or equal to x/y.\n\nExamples\n\njulia> cld(5.5,2.2)\n3.0\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.mod","page":"Mathematics","title":"Base.mod","text":"mod(x, y)\nrem(x, y, RoundDown)\n\nThe reduction of x modulo y, or equivalently, the remainder of x after floored division by y, i.e. x - y*fld(x,y) if computed without intermediate rounding.\n\nThe result will have the same sign as y, and magnitude less than abs(y) (with some exceptions, see note below).\n\nnote: Note\nWhen used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to y, then it may be rounded to y.\n\njulia> mod(8, 3)\n2\n\njulia> mod(9, 3)\n0\n\njulia> mod(8.9, 3)\n2.9000000000000004\n\njulia> mod(eps(), 3)\n2.220446049250313e-16\n\njulia> mod(-eps(), 3)\n3.0\n\n\n\n\n\nrem(x::Integer, T::Type{<:Integer}) -> T\nmod(x::Integer, T::Type{<:Integer}) -> T\n%(x::Integer, T::Type{<:Integer}) -> T\n\nFind y::T such that x ≡ y (mod n), where n is the number of integers representable in T, and y is an integer in [typemin(T),typemax(T)]. If T can represent any integer (e.g. T == BigInt), then this operation corresponds to a conversion to T.\n\nExamples\n\njulia> 129 % Int8\n-127\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.rem","page":"Mathematics","title":"Base.rem","text":"rem(x, y)\n%(x, y)\n\nRemainder from Euclidean division, returning a value of the same sign as x, and smaller in magnitude than y. This value is always exact.\n\nExamples\n\njulia> x = 15; y = 4;\n\njulia> x % y\n3\n\njulia> x == div(x, y) * y + rem(x, y)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.rem2pi","page":"Mathematics","title":"Base.Math.rem2pi","text":"rem2pi(x, r::RoundingMode)\n\nCompute the remainder of x after integer division by 2π, with the quotient rounded according to the rounding mode r. In other words, the quantity\n\nx - 2π*round(x/(2π),r)\n\nwithout any intermediate rounding. This internally uses a high precision approximation of 2π, and so will give a more accurate result than rem(x,2π,r)\n\nif r == RoundNearest, then the result is in the interval -π π. This will generally be the most accurate result. See also RoundNearest.\nif r == RoundToZero, then the result is in the interval 0 2π if x is positive,. or -2π 0 otherwise. See also RoundToZero.\nif r == RoundDown, then the result is in the interval 0 2π. See also RoundDown.\nif r == RoundUp, then the result is in the interval -2π 0. See also RoundUp.\n\nExamples\n\njulia> rem2pi(7pi/4, RoundNearest)\n-0.7853981633974485\n\njulia> rem2pi(7pi/4, RoundDown)\n5.497787143782138\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.mod2pi","page":"Mathematics","title":"Base.Math.mod2pi","text":"mod2pi(x)\n\nModulus after division by 2π, returning in the range 02π).\n\nThis function computes a floating point representation of the modulus after division by numerically exact 2π, and is therefore not exactly the same as mod(x,2π), which would compute the modulus of x relative to division by the floating-point number 2π.\n\nExamples\n\njulia> mod2pi(9*pi/4)\n0.7853981633974481\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.divrem","page":"Mathematics","title":"Base.divrem","text":"divrem(x, y)\n\nThe quotient and remainder from Euclidean division. Equivalent to (div(x,y), rem(x,y)) or (x÷y, x%y).\n\nExamples\n\njulia> divrem(3,7)\n(0, 3)\n\njulia> divrem(7,3)\n(2, 1)\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.fldmod","page":"Mathematics","title":"Base.fldmod","text":"fldmod(x, y)\n\nThe floored quotient and modulus after division. Equivalent to (fld(x,y), mod(x,y)).\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.fld1","page":"Mathematics","title":"Base.fld1","text":"fld1(x, y)\n\nFlooring division, returning a value consistent with mod1(x,y)\n\nSee also: mod1, fldmod1.\n\nExamples\n\njulia> x = 15; y = 4;\n\njulia> fld1(x, y)\n4\n\njulia> x == fld(x, y) * y + mod(x, y)\ntrue\n\njulia> x == (fld1(x, y) - 1) * y + mod1(x, y)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.mod1","page":"Mathematics","title":"Base.mod1","text":"mod1(x, y)\n\nModulus after flooring division, returning a value r such that mod(r, y) == mod(x, y) in the range (0 y for positive y and in the range y0) for negative y.\n\nSee also: fld1, fldmod1.\n\nExamples\n\njulia> mod1(4, 2)\n2\n\njulia> mod1(4, 3)\n1\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.fldmod1","page":"Mathematics","title":"Base.fldmod1","text":"fldmod1(x, y)\n\nReturn (fld1(x,y), mod1(x,y)).\n\nSee also: fld1, mod1.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.://","page":"Mathematics","title":"Base.://","text":"//(num, den)\n\nDivide two integers or rational numbers, giving a Rational result.\n\nExamples\n\njulia> 3 // 5\n3//5\n\njulia> (3 // 5) // (2 // 1)\n3//10\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.rationalize","page":"Mathematics","title":"Base.rationalize","text":"rationalize([T<:Integer=Int,] x; tol::Real=eps(x))\n\nApproximate floating point number x as a Rational number with components of the given integer type. The result will differ from x by no more than tol.\n\nExamples\n\njulia> rationalize(5.6)\n28//5\n\njulia> a = rationalize(BigInt, 10.3)\n103//10\n\njulia> typeof(numerator(a))\nBigInt\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.numerator","page":"Mathematics","title":"Base.numerator","text":"numerator(x)\n\nNumerator of the rational representation of x.\n\nExamples\n\njulia> numerator(2//3)\n2\n\njulia> numerator(4)\n4\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.denominator","page":"Mathematics","title":"Base.denominator","text":"denominator(x)\n\nDenominator of the rational representation of x.\n\nExamples\n\njulia> denominator(2//3)\n3\n\njulia> denominator(4)\n1\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:<<","page":"Mathematics","title":"Base.:<<","text":"<<(x, n)\n\nLeft bit shift operator, x << n. For n >= 0, the result is x shifted left by n bits, filling with 0s. This is equivalent to x * 2^n. For n < 0, this is equivalent to x >> -n.\n\nExamples\n\njulia> Int8(3) << 2\n12\n\njulia> bitstring(Int8(3))\n\"00000011\"\n\njulia> bitstring(Int8(12))\n\"00001100\"\n\nSee also >>, >>>.\n\n\n\n\n\n<<(B::BitVector, n) -> BitVector\n\nLeft bit shift operator, B << n. For n >= 0, the result is B with elements shifted n positions backwards, filling with false values. If n < 0, elements are shifted forwards. Equivalent to B >> -n.\n\nExamples\n\njulia> B = BitVector([true, false, true, false, false])\n5-element BitArray{1}:\n 1\n 0\n 1\n 0\n 0\n\njulia> B << 1\n5-element BitArray{1}:\n 0\n 1\n 0\n 0\n 0\n\njulia> B << -1\n5-element BitArray{1}:\n 0\n 1\n 0\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:>>","page":"Mathematics","title":"Base.:>>","text":">>(x, n)\n\nRight bit shift operator, x >> n. For n >= 0, the result is x shifted right by n bits, where n >= 0, filling with 0s if x >= 0, 1s if x < 0, preserving the sign of x. This is equivalent to fld(x, 2^n). For n < 0, this is equivalent to x << -n.\n\nExamples\n\njulia> Int8(13) >> 2\n3\n\njulia> bitstring(Int8(13))\n\"00001101\"\n\njulia> bitstring(Int8(3))\n\"00000011\"\n\njulia> Int8(-14) >> 2\n-4\n\njulia> bitstring(Int8(-14))\n\"11110010\"\n\njulia> bitstring(Int8(-4))\n\"11111100\"\n\nSee also >>>, <<.\n\n\n\n\n\n>>(B::BitVector, n) -> BitVector\n\nRight bit shift operator, B >> n. For n >= 0, the result is B with elements shifted n positions forward, filling with false values. If n < 0, elements are shifted backwards. Equivalent to B << -n.\n\nExamples\n\njulia> B = BitVector([true, false, true, false, false])\n5-element BitArray{1}:\n 1\n 0\n 1\n 0\n 0\n\njulia> B >> 1\n5-element BitArray{1}:\n 0\n 1\n 0\n 1\n 0\n\njulia> B >> -1\n5-element BitArray{1}:\n 0\n 1\n 0\n 0\n 0\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:>>>","page":"Mathematics","title":"Base.:>>>","text":">>>(x, n)\n\nUnsigned right bit shift operator, x >>> n. For n >= 0, the result is x shifted right by n bits, where n >= 0, filling with 0s. For n < 0, this is equivalent to x << -n.\n\nFor Unsigned integer types, this is equivalent to >>. For Signed integer types, this is equivalent to signed(unsigned(x) >> n).\n\nExamples\n\njulia> Int8(-14) >>> 2\n60\n\njulia> bitstring(Int8(-14))\n\"11110010\"\n\njulia> bitstring(Int8(60))\n\"00111100\"\n\nBigInts are treated as if having infinite size, so no filling is required and this is equivalent to >>.\n\nSee also >>, <<.\n\n\n\n\n\n>>>(B::BitVector, n) -> BitVector\n\nUnsigned right bitshift operator, B >>> n. Equivalent to B >> n. See >> for details and examples.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.::","page":"Mathematics","title":"Base.::","text":"(:)(start, [step], stop)\n\nRange operator. a:b constructs a range from a to b with a step size of 1 (a UnitRange) , and a:s:b is similar but uses a step size of s (a StepRange).\n\n: is also used in indexing to select whole dimensions  and for Symbol literals, as in e.g. :hello.\n\n\n\n\n\n(:)(I::CartesianIndex, J::CartesianIndex)\n\nConstruct CartesianIndices from two CartesianIndex.\n\ncompat: Julia 1.1\nThis method requires at least Julia 1.1.\n\nExamples\n\njulia> I = CartesianIndex(2,1);\n\njulia> J = CartesianIndex(3,3);\n\njulia> I:J\n2×3 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:\n CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)\n CartesianIndex(3, 1)  CartesianIndex(3, 2)  CartesianIndex(3, 3)\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.range","page":"Mathematics","title":"Base.range","text":"range(start[, stop]; length, stop, step=1)\n\nGiven a starting value, construct a range either by length or from start to stop, optionally with a given step (defaults to 1, a UnitRange). One of length or stop is required.  If length, stop, and step are all specified, they must agree.\n\nIf length and stop are provided and step is not, the step size will be computed automatically such that there are length linearly spaced elements in the range (a LinRange).\n\nIf step and stop are provided and length is not, the overall range length will be computed automatically such that the elements are step spaced (a StepRange).\n\nstop may be specified as either a positional or keyword argument.\n\ncompat: Julia 1.1\nstop as a positional argument requires at least Julia 1.1.\n\nExamples\n\njulia> range(1, length=100)\n1:100\n\njulia> range(1, stop=100)\n1:100\n\njulia> range(1, step=5, length=100)\n1:5:496\n\njulia> range(1, step=5, stop=100)\n1:5:96\n\njulia> range(1, 10, length=101)\n1.0:0.09:10.0\n\njulia> range(1, 100, step=5)\n1:5:96\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.OneTo","page":"Mathematics","title":"Base.OneTo","text":"Base.OneTo(n)\n\nDefine an AbstractUnitRange that behaves like 1:n, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.\n\n\n\n\n\n","category":"type"},{"location":"base/math.html#Base.StepRangeLen","page":"Mathematics","title":"Base.StepRangeLen","text":"StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1]) where {T,R,S}\nStepRangeLen(       ref::R, step::S, len, [offset=1]) where {  R,S}\n\nA range r where r[i] produces values of type T (in the second form, T is deduced automatically), parameterized by a reference value, a step, and the length. By default ref is the starting value r[1], but alternatively you can supply it as the value of r[offset] for some other index 1 <= offset <= len. In conjunction with TwicePrecision this can be used to implement ranges that are free of roundoff error.\n\n\n\n\n\n","category":"type"},{"location":"base/math.html#Base.:==","page":"Mathematics","title":"Base.:==","text":"==(x, y)\n\nGeneric equality operator. Falls back to ===. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, == is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.\n\nThis operator follows IEEE semantics for floating-point numbers: 0.0 == -0.0 and NaN != NaN.\n\nThe result is of type Bool, except when one of the operands is missing, in which case missing is returned (three-valued logic). For collections, missing is returned if at least one of the operands contains a missing value and all non-missing values are equal. Use isequal or === to always get a Bool result.\n\nImplementation\n\nNew numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.\n\nisequal falls back to ==, so new methods of == will be used by the Dict type to compare keys. If your type will be used as a dictionary key, it should therefore also implement hash.\n\n\n\n\n\n==(x)\n\nCreate a function that compares its argument to x using ==, i.e. a function equivalent to y -> y == x.\n\nThe returned function is of type Base.Fix2{typeof(==)}, which can be used to implement specialized methods.\n\n\n\n\n\n==(a::AbstractString, b::AbstractString) -> Bool\n\nTest whether two strings are equal character by character (technically, Unicode code point by code point).\n\nExamples\n\njulia> \"abc\" == \"abc\"\ntrue\n\njulia> \"abc\" == \"αβγ\"\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:!=","page":"Mathematics","title":"Base.:!=","text":"!=(x, y)\n≠(x,y)\n\nNot-equals comparison operator. Always gives the opposite answer as ==.\n\nImplementation\n\nNew types should generally not implement this, and rely on the fallback definition !=(x,y) = !(x==y) instead.\n\nExamples\n\njulia> 3 != 2\ntrue\n\njulia> \"foo\" ≠ \"foo\"\nfalse\n\n\n\n\n\n!=(x)\n\nCreate a function that compares its argument to x using !=, i.e. a function equivalent to y -> y != x. The returned function is of type Base.Fix2{typeof(!=)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:!==","page":"Mathematics","title":"Base.:!==","text":"!==(x, y)\n≢(x,y)\n\nAlways gives the opposite answer as ===.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 2];\n\njulia> a ≢ b\ntrue\n\njulia> a ≢ a\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:<","page":"Mathematics","title":"Base.:<","text":"<(x, y)\n\nLess-than comparison operator. Falls back to isless. Because of the behavior of floating-point NaN values, this operator implements a partial order.\n\nImplementation\n\nNew numeric types with a canonical partial order should implement this function for two arguments of the new type. Types with a canonical total order should implement isless instead. (x < y) | (x == y)\n\nExamples\n\njulia> 'a' < 'b'\ntrue\n\njulia> \"abc\" < \"abd\"\ntrue\n\njulia> 5 < 3\nfalse\n\n\n\n\n\n<(x)\n\nCreate a function that compares its argument to x using <, i.e. a function equivalent to y -> y < x. The returned function is of type Base.Fix2{typeof(<)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:<=","page":"Mathematics","title":"Base.:<=","text":"<=(x, y)\n≤(x,y)\n\nLess-than-or-equals comparison operator. Falls back to (x < y) | (x == y).\n\nExamples\n\njulia> 'a' <= 'b'\ntrue\n\njulia> 7 ≤ 7 ≤ 9\ntrue\n\njulia> \"abc\" ≤ \"abc\"\ntrue\n\njulia> 5 <= 3\nfalse\n\n\n\n\n\n<=(x)\n\nCreate a function that compares its argument to x using <=, i.e. a function equivalent to y -> y <= x. The returned function is of type Base.Fix2{typeof(<=)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:>","page":"Mathematics","title":"Base.:>","text":">(x, y)\n\nGreater-than comparison operator. Falls back to y < x.\n\nImplementation\n\nGenerally, new types should implement < instead of this function, and rely on the fallback definition >(x, y) = y < x.\n\nExamples\n\njulia> 'a' > 'b'\nfalse\n\njulia> 7 > 3 > 1\ntrue\n\njulia> \"abc\" > \"abd\"\nfalse\n\njulia> 5 > 3\ntrue\n\n\n\n\n\n>(x)\n\nCreate a function that compares its argument to x using >, i.e. a function equivalent to y -> y > x. The returned function is of type Base.Fix2{typeof(>)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:>=","page":"Mathematics","title":"Base.:>=","text":">=(x, y)\n≥(x,y)\n\nGreater-than-or-equals comparison operator. Falls back to y <= x.\n\nExamples\n\njulia> 'a' >= 'b'\nfalse\n\njulia> 7 ≥ 7 ≥ 3\ntrue\n\njulia> \"abc\" ≥ \"abc\"\ntrue\n\njulia> 5 >= 3\ntrue\n\n\n\n\n\n>=(x)\n\nCreate a function that compares its argument to x using >=, i.e. a function equivalent to y -> y >= x. The returned function is of type Base.Fix2{typeof(>=)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.cmp","page":"Mathematics","title":"Base.cmp","text":"cmp(x,y)\n\nReturn -1, 0, or 1 depending on whether x is less than, equal to, or greater than y, respectively. Uses the total order implemented by isless.\n\nExamples\n\njulia> cmp(1, 2)\n-1\n\njulia> cmp(2, 1)\n1\n\njulia> cmp(2+im, 3-im)\nERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})\n[...]\n\n\n\n\n\ncmp(<, x, y)\n\nReturn -1, 0, or 1 depending on whether x is less than, equal to, or greater than y, respectively. The first argument specifies a less-than comparison function to use.\n\n\n\n\n\ncmp(a::AbstractString, b::AbstractString) -> Int\n\nCompare two strings. Return 0 if both strings have the same length and the character at each index is the same in both strings. Return -1 if a is a prefix of b, or if a comes before b in alphabetical order. Return 1 if b is a prefix of a, or if b comes before a in alphabetical order (technically, lexicographical order by Unicode code points).\n\nExamples\n\njulia> cmp(\"abc\", \"abc\")\n0\n\njulia> cmp(\"ab\", \"abc\")\n-1\n\njulia> cmp(\"abc\", \"ab\")\n1\n\njulia> cmp(\"ab\", \"ac\")\n-1\n\njulia> cmp(\"ac\", \"ab\")\n1\n\njulia> cmp(\"α\", \"a\")\n1\n\njulia> cmp(\"b\", \"β\")\n-1\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:~","page":"Mathematics","title":"Base.:~","text":"~(x)\n\nBitwise not.\n\nExamples\n\njulia> ~4\n-5\n\njulia> ~10\n-11\n\njulia> ~true\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:&","page":"Mathematics","title":"Base.:&","text":"&(x, y)\n\nBitwise and. Implements three-valued logic, returning missing if one operand is missing and the other is true.\n\nExamples\n\njulia> 4 & 10\n0\n\njulia> 4 & 12\n4\n\njulia> true & missing\nmissing\n\njulia> false & missing\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:|","page":"Mathematics","title":"Base.:|","text":"|(x, y)\n\nBitwise or. Implements three-valued logic, returning missing if one operand is missing and the other is false.\n\nExamples\n\njulia> 4 | 10\n14\n\njulia> 4 | 1\n5\n\njulia> true | missing\ntrue\n\njulia> false | missing\nmissing\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.xor","page":"Mathematics","title":"Base.xor","text":"xor(x, y)\n⊻(x, y)\n\nBitwise exclusive or of x and y. Implements three-valued logic, returning missing if one of the arguments is missing.\n\nThe infix operation a ⊻ b is a synonym for xor(a,b), and ⊻ can be typed by tab-completing \\xor or \\veebar in the Julia REPL.\n\nExamples\n\njulia> xor(true, false)\ntrue\n\njulia> xor(true, true)\nfalse\n\njulia> xor(true, missing)\nmissing\n\njulia> false ⊻ false\nfalse\n\njulia> [true; true; false] .⊻ [true; false; false]\n3-element BitArray{1}:\n 0\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.:!","page":"Mathematics","title":"Base.:!","text":"!(x)\n\nBoolean not. Implements three-valued logic, returning missing if x is missing.\n\nExamples\n\njulia> !true\nfalse\n\njulia> !false\ntrue\n\njulia> !missing\nmissing\n\njulia> .![true false true]\n1×3 BitArray{2}:\n 0  1  0\n\n\n\n\n\n!f::Function\n\nPredicate function negation: when the argument of ! is a function, it returns a function which computes the boolean negation of f.\n\nExamples\n\njulia> str = \"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε\"\n\"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε\"\n\njulia> filter(isletter, str)\n\"εδxyδfxfyε\"\n\njulia> filter(!isletter, str)\n\"∀  > 0, ∃  > 0: |-| <  ⇒ |()-()| < \"\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#&&","page":"Mathematics","title":"&&","text":"x && y\n\nShort-circuiting boolean AND.\n\n\n\n\n\n","category":"keyword"},{"location":"base/math.html#||","page":"Mathematics","title":"||","text":"x || y\n\nShort-circuiting boolean OR.\n\n\n\n\n\n","category":"keyword"},{"location":"base/math.html#Mathematical-Functions-1","page":"Mathematics","title":"Mathematical Functions","text":"","category":"section"},{"location":"base/math.html#","page":"Mathematics","title":"Mathematics","text":"Base.isapprox\nBase.sin(::Number)\nBase.cos(::Number)\nBase.sincos(::Float64)\nBase.tan(::Number)\nBase.Math.sind\nBase.Math.cosd\nBase.Math.tand\nBase.Math.sinpi\nBase.Math.cospi\nBase.sinh(::Number)\nBase.cosh(::Number)\nBase.tanh(::Number)\nBase.asin(::Number)\nBase.acos(::Number)\nBase.atan(::Number)\nBase.Math.asind\nBase.Math.acosd\nBase.Math.atand\nBase.Math.sec(::Number)\nBase.Math.csc(::Number)\nBase.Math.cot(::Number)\nBase.Math.secd\nBase.Math.cscd\nBase.Math.cotd\nBase.Math.asec(::Number)\nBase.Math.acsc(::Number)\nBase.Math.acot(::Number)\nBase.Math.asecd\nBase.Math.acscd\nBase.Math.acotd\nBase.Math.sech(::Number)\nBase.Math.csch(::Number)\nBase.Math.coth(::Number)\nBase.asinh(::Number)\nBase.acosh(::Number)\nBase.atanh(::Number)\nBase.Math.asech(::Number)\nBase.Math.acsch(::Number)\nBase.Math.acoth(::Number)\nBase.Math.sinc\nBase.Math.cosc\nBase.Math.deg2rad\nBase.Math.rad2deg\nBase.Math.hypot\nBase.log(::Number)\nBase.log(::Number, ::Number)\nBase.log2\nBase.log10\nBase.log1p\nBase.Math.frexp\nBase.exp(::Float64)\nBase.exp2\nBase.exp10\nBase.Math.ldexp\nBase.Math.modf\nBase.expm1\nBase.round(::Type, ::Any)\nBase.Rounding.RoundingMode\nBase.Rounding.RoundNearest\nBase.Rounding.RoundNearestTiesAway\nBase.Rounding.RoundNearestTiesUp\nBase.Rounding.RoundToZero\nBase.Rounding.RoundFromZero\nBase.Rounding.RoundUp\nBase.Rounding.RoundDown\nBase.round(::Complex{<: AbstractFloat}, ::RoundingMode, ::RoundingMode)\nBase.ceil\nBase.floor\nBase.trunc\nBase.unsafe_trunc\nBase.min\nBase.max\nBase.minmax\nBase.Math.clamp\nBase.Math.clamp!\nBase.abs\nBase.Checked.checked_abs\nBase.Checked.checked_neg\nBase.Checked.checked_add\nBase.Checked.checked_sub\nBase.Checked.checked_mul\nBase.Checked.checked_div\nBase.Checked.checked_rem\nBase.Checked.checked_fld\nBase.Checked.checked_mod\nBase.Checked.checked_cld\nBase.Checked.add_with_overflow\nBase.Checked.sub_with_overflow\nBase.Checked.mul_with_overflow\nBase.abs2\nBase.copysign\nBase.sign\nBase.signbit\nBase.flipsign\nBase.sqrt(::Real)\nBase.isqrt\nBase.Math.cbrt\nBase.real(::Complex)\nBase.imag\nBase.reim\nBase.conj\nBase.angle\nBase.cis\nBase.binomial\nBase.factorial\nBase.gcd\nBase.lcm\nBase.gcdx\nBase.ispow2\nBase.nextpow\nBase.prevpow\nBase.nextprod\nBase.invmod\nBase.powermod\nBase.ndigits\nBase.widemul\nBase.Math.@evalpoly\nBase.FastMath.@fastmath","category":"page"},{"location":"base/math.html#Base.isapprox","page":"Mathematics","title":"Base.isapprox","text":"isapprox(x, y; rtol::Real=atol>0 ? 0 : √eps, atol::Real=0, nans::Bool=false, norm::Function)\n\nInexact equality comparison: true if norm(x-y) <= max(atol, rtol*max(norm(x), norm(y))). The default atol is zero and the default rtol depends on the types of x and y. The keyword argument nans determines whether or not NaN values are considered equal (defaults to false).\n\nFor real or complex floating-point values, if an atol > 0 is not specified, rtol defaults to the square root of eps of the type of x or y, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an atol > 0 is supplied, rtol defaults to zero.\n\nx and y may also be arrays of numbers, in which case norm defaults to the usual norm function in LinearAlgebra, but may be changed by passing a norm::Function keyword argument. (For numbers, norm is the same thing as abs.) When x and y are arrays, if norm(x-y) is not finite (i.e. ±Inf or NaN), the comparison falls back to checking whether all elements of x and y are approximately equal component-wise.\n\nThe binary operator ≈ is equivalent to isapprox with the default arguments, and x ≉ y is equivalent to !isapprox(x,y).\n\nNote that x ≈ 0 (i.e., comparing to zero with the default tolerances) is equivalent to x == 0 since the default atol is 0.  In such cases, you should either supply an appropriate atol (or use norm(x) ≤ atol) or rearrange your code (e.g. use x ≈ y rather than x - y ≈ 0).   It is not possible to pick a nonzero atol automatically because it depends on the overall scaling (the \"units\") of your problem: for example, in x - y ≈ 0, atol=1e-9 is an absurdly small tolerance if x is the radius of the Earth in meters, but an absurdly large tolerance if x is the radius of a Hydrogen atom in meters.\n\nExamples\n\njulia> 0.1 ≈ (0.1 - 1e-10)\ntrue\n\njulia> isapprox(10, 11; atol = 2)\ntrue\n\njulia> isapprox([10.0^9, 1.0], [10.0^9, 2.0])\ntrue\n\njulia> 1e-10 ≈ 0\nfalse\n\njulia> isapprox(1e-10, 0, atol=1e-8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.sin-Tuple{Number}","page":"Mathematics","title":"Base.sin","text":"sin(x)\n\nCompute sine of x, where x is in radians.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.cos-Tuple{Number}","page":"Mathematics","title":"Base.cos","text":"cos(x)\n\nCompute cosine of x, where x is in radians.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.sincos-Tuple{Float64}","page":"Mathematics","title":"Base.Math.sincos","text":"sincos(x)\n\nSimultaneously compute the sine and cosine of x, where the x is in radians.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.tan-Tuple{Number}","page":"Mathematics","title":"Base.tan","text":"tan(x)\n\nCompute tangent of x, where x is in radians.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.sind","page":"Mathematics","title":"Base.Math.sind","text":"sind(x)\n\nCompute sine of x, where x is in degrees. \n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.cosd","page":"Mathematics","title":"Base.Math.cosd","text":"cosd(x)\n\nCompute cosine of x, where x is in degrees. \n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.tand","page":"Mathematics","title":"Base.Math.tand","text":"tand(x)\n\nCompute tangent of x, where x is in degrees. \n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.sinpi","page":"Mathematics","title":"Base.Math.sinpi","text":"sinpi(x)\n\nCompute sin(pi x) more accurately than sin(pi*x), especially for large x.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.cospi","page":"Mathematics","title":"Base.Math.cospi","text":"cospi(x)\n\nCompute cos(pi x) more accurately than cos(pi*x), especially for large x.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.sinh-Tuple{Number}","page":"Mathematics","title":"Base.sinh","text":"sinh(x)\n\nCompute hyperbolic sine of x.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.cosh-Tuple{Number}","page":"Mathematics","title":"Base.cosh","text":"cosh(x)\n\nCompute hyperbolic cosine of x.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.tanh-Tuple{Number}","page":"Mathematics","title":"Base.tanh","text":"tanh(x)\n\nCompute hyperbolic tangent of x.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.asin-Tuple{Number}","page":"Mathematics","title":"Base.asin","text":"asin(x)\n\nCompute the inverse sine of x, where the output is in radians.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.acos-Tuple{Number}","page":"Mathematics","title":"Base.acos","text":"acos(x)\n\nCompute the inverse cosine of x, where the output is in radians\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.atan-Tuple{Number}","page":"Mathematics","title":"Base.atan","text":"atan(y)\natan(y, x)\n\nCompute the inverse tangent of y or y/x, respectively.\n\nFor one argument, this is the angle in radians between the positive x-axis and the point (1, y), returning a value in the interval -pi2 pi2.\n\nFor two arguments, this is the angle in radians between the positive x-axis and the point (x, y), returning a value in the interval -pi pi. This corresponds to a standard atan2 function.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.asind","page":"Mathematics","title":"Base.Math.asind","text":"asind(x)\n\nCompute the inverse sine of x, where the output is in degrees. \n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.acosd","page":"Mathematics","title":"Base.Math.acosd","text":"acosd(x)\n\nCompute the inverse cosine of x, where the output is in degrees. \n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.atand","page":"Mathematics","title":"Base.Math.atand","text":"atand(y)\natand(y,x)\n\nCompute the inverse tangent of y or y/x, respectively, where the output is in degrees.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.sec-Tuple{Number}","page":"Mathematics","title":"Base.Math.sec","text":"sec(x)\n\nCompute the secant of x, where x is in radians.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.csc-Tuple{Number}","page":"Mathematics","title":"Base.Math.csc","text":"csc(x)\n\nCompute the cosecant of x, where x is in radians.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.cot-Tuple{Number}","page":"Mathematics","title":"Base.Math.cot","text":"cot(x)\n\nCompute the cotangent of x, where x is in radians.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.secd","page":"Mathematics","title":"Base.Math.secd","text":"secd(x)\n\nCompute the secant of x, where x is in degrees.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.cscd","page":"Mathematics","title":"Base.Math.cscd","text":"cscd(x)\n\nCompute the cosecant of x, where x is in degrees.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.cotd","page":"Mathematics","title":"Base.Math.cotd","text":"cotd(x)\n\nCompute the cotangent of x, where x is in degrees.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.asec-Tuple{Number}","page":"Mathematics","title":"Base.Math.asec","text":"asec(x)\n\nCompute the inverse secant of x, where the output is in radians. \n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.acsc-Tuple{Number}","page":"Mathematics","title":"Base.Math.acsc","text":"acsc(x)\n\nCompute the inverse cosecant of x, where the output is in radians. \n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.acot-Tuple{Number}","page":"Mathematics","title":"Base.Math.acot","text":"acot(x)\n\nCompute the inverse cotangent of x, where the output is in radians. \n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.asecd","page":"Mathematics","title":"Base.Math.asecd","text":"asecd(x)\n\nCompute the inverse secant of x, where the output is in degrees. \n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.acscd","page":"Mathematics","title":"Base.Math.acscd","text":"acscd(x)\n\nCompute the inverse cosecant of x, where the output is in degrees. \n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.acotd","page":"Mathematics","title":"Base.Math.acotd","text":"acotd(x)\n\nCompute the inverse cotangent of x, where the output is in degrees. \n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.sech-Tuple{Number}","page":"Mathematics","title":"Base.Math.sech","text":"sech(x)\n\nCompute the hyperbolic secant of x.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.csch-Tuple{Number}","page":"Mathematics","title":"Base.Math.csch","text":"csch(x)\n\nCompute the hyperbolic cosecant of x.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.coth-Tuple{Number}","page":"Mathematics","title":"Base.Math.coth","text":"coth(x)\n\nCompute the hyperbolic cotangent of x.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.asinh-Tuple{Number}","page":"Mathematics","title":"Base.asinh","text":"asinh(x)\n\nCompute the inverse hyperbolic sine of x.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.acosh-Tuple{Number}","page":"Mathematics","title":"Base.acosh","text":"acosh(x)\n\nCompute the inverse hyperbolic cosine of x.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.atanh-Tuple{Number}","page":"Mathematics","title":"Base.atanh","text":"atanh(x)\n\nCompute the inverse hyperbolic tangent of x.\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.asech-Tuple{Number}","page":"Mathematics","title":"Base.Math.asech","text":"asech(x)\n\nCompute the inverse hyperbolic secant of x. \n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.acsch-Tuple{Number}","page":"Mathematics","title":"Base.Math.acsch","text":"acsch(x)\n\nCompute the inverse hyperbolic cosecant of x. \n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.acoth-Tuple{Number}","page":"Mathematics","title":"Base.Math.acoth","text":"acoth(x)\n\nCompute the inverse hyperbolic cotangent of x. \n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Math.sinc","page":"Mathematics","title":"Base.Math.sinc","text":"sinc(x)\n\nCompute sin(pi x)  (pi x) if x neq 0, and 1 if x = 0.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.cosc","page":"Mathematics","title":"Base.Math.cosc","text":"cosc(x)\n\nCompute cos(pi x)  x - sin(pi x)  (pi x^2) if x neq 0, and 0 if x = 0. This is the derivative of sinc(x).\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.deg2rad","page":"Mathematics","title":"Base.Math.deg2rad","text":"deg2rad(x)\n\nConvert x from degrees to radians.\n\nExamples\n\njulia> deg2rad(90)\n1.5707963267948966\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.rad2deg","page":"Mathematics","title":"Base.Math.rad2deg","text":"rad2deg(x)\n\nConvert x from radians to degrees.\n\nExamples\n\njulia> rad2deg(pi)\n180.0\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.hypot","page":"Mathematics","title":"Base.Math.hypot","text":"hypot(x, y)\n\nCompute the hypotenuse sqrtx^2+y^2 avoiding overflow and underflow.\n\nExamples\n\njulia> a = 10^10;\n\njulia> hypot(a, a)\n1.4142135623730951e10\n\njulia> √(a^2 + a^2) # a^2 overflows\nERROR: DomainError with -2.914184810805068e18:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\n\n\n\n\nhypot(x...)\n\nCompute the hypotenuse sqrtsum x_i^2 avoiding overflow and underflow.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.log-Tuple{Number}","page":"Mathematics","title":"Base.log","text":"log(x)\n\nCompute the natural logarithm of x. Throws DomainError for negative Real arguments. Use complex negative arguments to obtain complex results.\n\nExamples\n\njulia> log(2)\n0.6931471805599453\n\njulia> log(-3)\nERROR: DomainError with -3.0:\nlog will only return a complex result if called with a complex argument. Try log(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31\n[...]\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.log-Tuple{Number,Number}","page":"Mathematics","title":"Base.log","text":"log(b,x)\n\nCompute the base b logarithm of x. Throws DomainError for negative Real arguments.\n\nExamples\n\njulia> log(4,8)\n1.5\n\njulia> log(4,2)\n0.5\n\njulia> log(-2, 3)\nERROR: DomainError with -2.0:\nlog will only return a complex result if called with a complex argument. Try log(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31\n[...]\n\njulia> log(2, -3)\nERROR: DomainError with -3.0:\nlog will only return a complex result if called with a complex argument. Try log(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31\n[...]\n\nnote: Note\nIf b is a power of 2 or 10, log2 or log10 should be used, as these will typically be faster and more accurate. For example,julia> log(100,1000000)\n2.9999999999999996\n\njulia> log10(1000000)/2\n3.0\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.log2","page":"Mathematics","title":"Base.log2","text":"log2(x)\n\nCompute the logarithm of x to base 2. Throws DomainError for negative Real arguments.\n\nExamples\n\njulia> log2(4)\n2.0\n\njulia> log2(10)\n3.321928094887362\n\njulia> log2(-2)\nERROR: DomainError with -2.0:\nNaN result for non-NaN input.\nStacktrace:\n [1] nan_dom_err at ./math.jl:325 [inlined]\n[...]\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.log10","page":"Mathematics","title":"Base.log10","text":"log10(x)\n\nCompute the logarithm of x to base 10. Throws DomainError for negative Real arguments.\n\nExamples\n\njulia> log10(100)\n2.0\n\njulia> log10(2)\n0.3010299956639812\n\njulia> log10(-2)\nERROR: DomainError with -2.0:\nNaN result for non-NaN input.\nStacktrace:\n [1] nan_dom_err at ./math.jl:325 [inlined]\n[...]\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.log1p","page":"Mathematics","title":"Base.log1p","text":"log1p(x)\n\nAccurate natural logarithm of 1+x. Throws DomainError for Real arguments less than -1.\n\nExamples\n\njulia> log1p(-0.5)\n-0.6931471805599453\n\njulia> log1p(0)\n0.0\n\njulia> log1p(-2)\nERROR: DomainError with -2.0:\nlog1p will only return a complex result if called with a complex argument. Try log1p(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31\n[...]\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.frexp","page":"Mathematics","title":"Base.Math.frexp","text":"frexp(val)\n\nReturn (x,exp) such that x has a magnitude in the interval 12 1) or 0, and val is equal to x times 2^exp.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.exp-Tuple{Float64}","page":"Mathematics","title":"Base.exp","text":"exp(x)\n\nCompute the natural base exponential of x, in other words e^x.\n\nExamples\n\njulia> exp(1.0)\n2.718281828459045\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.exp2","page":"Mathematics","title":"Base.exp2","text":"exp2(x)\n\nCompute the base 2 exponential of x, in other words 2^x.\n\nExamples\n\njulia> exp2(5)\n32.0\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.exp10","page":"Mathematics","title":"Base.exp10","text":"exp10(x)\n\nCompute the base 10 exponential of x, in other words 10^x.\n\nExamples\n\njulia> exp10(2)\n100.0\n\n\n\n\n\nexp10(x)\n\nCompute 10^x.\n\nExamples\n\njulia> exp10(2)\n100.0\n\njulia> exp10(0.2)\n1.5848931924611136\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.ldexp","page":"Mathematics","title":"Base.Math.ldexp","text":"ldexp(x, n)\n\nCompute x times 2^n.\n\nExamples\n\njulia> ldexp(5., 2)\n20.0\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.modf","page":"Mathematics","title":"Base.Math.modf","text":"modf(x)\n\nReturn a tuple (fpart, ipart) of the fractional and integral parts of a number. Both parts have the same sign as the argument.\n\nExamples\n\njulia> modf(3.5)\n(0.5, 3.0)\n\njulia> modf(-3.5)\n(-0.5, -3.0)\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.expm1","page":"Mathematics","title":"Base.expm1","text":"expm1(x)\n\nAccurately compute e^x-1.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.round-Tuple{Type,Any}","page":"Mathematics","title":"Base.round","text":"round([T,] x, [r::RoundingMode])\nround(x, [r::RoundingMode]; digits::Integer=0, base = 10)\nround(x, [r::RoundingMode]; sigdigits::Integer, base = 10)\n\nRounds the number x.\n\nWithout keyword arguments, x is rounded to an integer value, returning a value of type T, or of the same type of x if no T is provided. An InexactError will be thrown if the value is not representable by T, similar to convert.\n\nIf the digits keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base base.\n\nIf the sigdigits keyword argument is provided, it rounds to the specified number of significant digits, in base base.\n\nThe RoundingMode r controls the direction of the rounding; the default is RoundNearest, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that round may give incorrect results if the global rounding mode is changed (see rounding).\n\nExamples\n\njulia> round(1.7)\n2.0\n\njulia> round(Int, 1.7)\n2\n\njulia> round(1.5)\n2.0\n\njulia> round(2.5)\n2.0\n\njulia> round(pi; digits=2)\n3.14\n\njulia> round(pi; digits=3, base=2)\n3.125\n\njulia> round(123.456; sigdigits=2)\n120.0\n\njulia> round(357.913; sigdigits=4, base=2)\n352.0\n\nnote: Note\nRounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the Float64 value represented by 1.15 is actually less than 1.15, yet will be rounded to 1.2.Examplesjulia> x = 1.15\n1.15\n\njulia> @sprintf \"%.20f\" x\n\"1.14999999999999991118\"\n\njulia> x < 115//100\ntrue\n\njulia> round(x, digits=1)\n1.2\n\nExtensions\n\nTo extend round to new numeric types, it is typically sufficient to define Base.round(x::NewType, r::RoundingMode).\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.Rounding.RoundingMode","page":"Mathematics","title":"Base.Rounding.RoundingMode","text":"RoundingMode\n\nA type used for controlling the rounding mode of floating point operations (via rounding/setrounding functions), or as optional arguments for rounding to the nearest integer (via the round function).\n\nCurrently supported rounding modes are:\n\nRoundNearest (default)\nRoundNearestTiesAway\nRoundNearestTiesUp\nRoundToZero\nRoundFromZero (BigFloat only)\nRoundUp\nRoundDown\n\n\n\n\n\n","category":"type"},{"location":"base/math.html#Base.Rounding.RoundNearest","page":"Mathematics","title":"Base.Rounding.RoundNearest","text":"RoundNearest\n\nThe default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.\n\n\n\n\n\n","category":"constant"},{"location":"base/math.html#Base.Rounding.RoundNearestTiesAway","page":"Mathematics","title":"Base.Rounding.RoundNearestTiesAway","text":"RoundNearestTiesAway\n\nRounds to nearest integer, with ties rounded away from zero (C/C++ round behaviour).\n\n\n\n\n\n","category":"constant"},{"location":"base/math.html#Base.Rounding.RoundNearestTiesUp","page":"Mathematics","title":"Base.Rounding.RoundNearestTiesUp","text":"RoundNearestTiesUp\n\nRounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript round behaviour).\n\n\n\n\n\n","category":"constant"},{"location":"base/math.html#Base.Rounding.RoundToZero","page":"Mathematics","title":"Base.Rounding.RoundToZero","text":"RoundToZero\n\nround using this rounding mode is an alias for trunc.\n\n\n\n\n\n","category":"constant"},{"location":"base/math.html#Base.Rounding.RoundFromZero","page":"Mathematics","title":"Base.Rounding.RoundFromZero","text":"RoundFromZero\n\nRounds away from zero. This rounding mode may only be used with T == BigFloat inputs to round.\n\nExamples\n\njulia> BigFloat(\"1.0000000000000001\", 5, RoundFromZero)\n1.06\n\n\n\n\n\n","category":"constant"},{"location":"base/math.html#Base.Rounding.RoundUp","page":"Mathematics","title":"Base.Rounding.RoundUp","text":"RoundUp\n\nround using this rounding mode is an alias for ceil.\n\n\n\n\n\n","category":"constant"},{"location":"base/math.html#Base.Rounding.RoundDown","page":"Mathematics","title":"Base.Rounding.RoundDown","text":"RoundDown\n\nround using this rounding mode is an alias for floor.\n\n\n\n\n\n","category":"constant"},{"location":"base/math.html#Base.round-Tuple{Complex{#s5} where #s5<:AbstractFloat,RoundingMode,RoundingMode}","page":"Mathematics","title":"Base.round","text":"round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]])\nround(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; digits=, base=10)\nround(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; sigdigits=, base=10)\n\nReturn the nearest integral value of the same type as the complex-valued z to z, breaking ties using the specified RoundingModes. The first RoundingMode is used for rounding the real components while the second is used for rounding the imaginary components.\n\nExample\n\njulia> round(3.14 + 4.5im)\n3.0 + 4.0im\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.ceil","page":"Mathematics","title":"Base.ceil","text":"ceil([T,] x)\nceil(x; digits::Integer= [, base = 10])\nceil(x; sigdigits::Integer= [, base = 10])\n\nceil(x) returns the nearest integral value of the same type as x that is greater than or equal to x.\n\nceil(T, x) converts the result to type T, throwing an InexactError if the value is not representable.\n\ndigits, sigdigits and base work as for round.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.floor","page":"Mathematics","title":"Base.floor","text":"floor([T,] x)\nfloor(x; digits::Integer= [, base = 10])\nfloor(x; sigdigits::Integer= [, base = 10])\n\nfloor(x) returns the nearest integral value of the same type as x that is less than or equal to x.\n\nfloor(T, x) converts the result to type T, throwing an InexactError if the value is not representable.\n\ndigits, sigdigits and base work as for round.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.trunc","page":"Mathematics","title":"Base.trunc","text":"trunc([T,] x)\ntrunc(x; digits::Integer= [, base = 10])\ntrunc(x; sigdigits::Integer= [, base = 10])\n\ntrunc(x) returns the nearest integral value of the same type as x whose absolute value is less than or equal to x.\n\ntrunc(T, x) converts the result to type T, throwing an InexactError if the value is not representable.\n\ndigits, sigdigits and base work as for round.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.unsafe_trunc","page":"Mathematics","title":"Base.unsafe_trunc","text":"unsafe_trunc(T, x)\n\nReturn the nearest integral value of type T whose absolute value is less than or equal to x. If the value is not representable by T, an arbitrary value will be returned.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.min","page":"Mathematics","title":"Base.min","text":"min(x, y, ...)\n\nReturn the minimum of the arguments. See also the minimum function to take the minimum element from a collection.\n\nExamples\n\njulia> min(2, 5, 1)\n1\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.max","page":"Mathematics","title":"Base.max","text":"max(x, y, ...)\n\nReturn the maximum of the arguments. See also the maximum function to take the maximum element from a collection.\n\nExamples\n\njulia> max(2, 5, 1)\n5\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.minmax","page":"Mathematics","title":"Base.minmax","text":"minmax(x, y)\n\nReturn (min(x,y), max(x,y)). See also: extrema that returns (minimum(x), maximum(x)).\n\nExamples\n\njulia> minmax('c','b')\n('b', 'c')\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.clamp","page":"Mathematics","title":"Base.Math.clamp","text":"clamp(x, lo, hi)\n\nReturn x if lo <= x <= hi. If x > hi, return hi. If x < lo, return lo. Arguments are promoted to a common type.\n\nExamples\n\njulia> clamp.([pi, 1.0, big(10.)], 2., 9.)\n3-element Array{BigFloat,1}:\n 3.141592653589793238462643383279502884197169399375105820974944592307816406286198\n 2.0\n 9.0\n\njulia> clamp.([11,8,5],10,6) # an example where lo > hi\n3-element Array{Int64,1}:\n  6\n  6\n 10\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.clamp!","page":"Mathematics","title":"Base.Math.clamp!","text":"clamp!(array::AbstractArray, lo, hi)\n\nRestrict values in array to the specified range, in-place. See also clamp.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.abs","page":"Mathematics","title":"Base.abs","text":"abs(x)\n\nThe absolute value of x.\n\nWhen abs is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when abs is applied to the minimum representable value of a signed integer. That is, when x == typemin(typeof(x)), abs(x) == x < 0, not -x as might be expected.\n\nExamples\n\njulia> abs(-3)\n3\n\njulia> abs(1 + im)\n1.4142135623730951\n\njulia> abs(typemin(Int64))\n-9223372036854775808\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.checked_abs","page":"Mathematics","title":"Base.Checked.checked_abs","text":"Base.checked_abs(x)\n\nCalculates abs(x), checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. Int) cannot represent abs(typemin(Int)), thus leading to an overflow.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.checked_neg","page":"Mathematics","title":"Base.Checked.checked_neg","text":"Base.checked_neg(x)\n\nCalculates -x, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. Int) cannot represent -typemin(Int), thus leading to an overflow.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.checked_add","page":"Mathematics","title":"Base.Checked.checked_add","text":"Base.checked_add(x, y)\n\nCalculates x+y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.checked_sub","page":"Mathematics","title":"Base.Checked.checked_sub","text":"Base.checked_sub(x, y)\n\nCalculates x-y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.checked_mul","page":"Mathematics","title":"Base.Checked.checked_mul","text":"Base.checked_mul(x, y)\n\nCalculates x*y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.checked_div","page":"Mathematics","title":"Base.Checked.checked_div","text":"Base.checked_div(x, y)\n\nCalculates div(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.checked_rem","page":"Mathematics","title":"Base.Checked.checked_rem","text":"Base.checked_rem(x, y)\n\nCalculates x%y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.checked_fld","page":"Mathematics","title":"Base.Checked.checked_fld","text":"Base.checked_fld(x, y)\n\nCalculates fld(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.checked_mod","page":"Mathematics","title":"Base.Checked.checked_mod","text":"Base.checked_mod(x, y)\n\nCalculates mod(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.checked_cld","page":"Mathematics","title":"Base.Checked.checked_cld","text":"Base.checked_cld(x, y)\n\nCalculates cld(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.add_with_overflow","page":"Mathematics","title":"Base.Checked.add_with_overflow","text":"Base.add_with_overflow(x, y) -> (r, f)\n\nCalculates r = x+y, with the flag f indicating whether overflow has occurred.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.sub_with_overflow","page":"Mathematics","title":"Base.Checked.sub_with_overflow","text":"Base.sub_with_overflow(x, y) -> (r, f)\n\nCalculates r = x-y, with the flag f indicating whether overflow has occurred.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Checked.mul_with_overflow","page":"Mathematics","title":"Base.Checked.mul_with_overflow","text":"Base.mul_with_overflow(x, y) -> (r, f)\n\nCalculates r = x*y, with the flag f indicating whether overflow has occurred.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.abs2","page":"Mathematics","title":"Base.abs2","text":"abs2(x)\n\nSquared absolute value of x.\n\nExamples\n\njulia> abs2(-3)\n9\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.copysign","page":"Mathematics","title":"Base.copysign","text":"copysign(x, y) -> z\n\nReturn z which has the magnitude of x and the same sign as y.\n\nExamples\n\njulia> copysign(1, -2)\n-1\n\njulia> copysign(-1, 2)\n1\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.sign","page":"Mathematics","title":"Base.sign","text":"sign(x)\n\nReturn zero if x==0 and xx otherwise (i.e., ±1 for real x).\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.signbit","page":"Mathematics","title":"Base.signbit","text":"signbit(x)\n\nReturns true if the value of the sign of x is negative, otherwise false.\n\nExamples\n\njulia> signbit(-4)\ntrue\n\njulia> signbit(5)\nfalse\n\njulia> signbit(5.5)\nfalse\n\njulia> signbit(-4.1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.flipsign","page":"Mathematics","title":"Base.flipsign","text":"flipsign(x, y)\n\nReturn x with its sign flipped if y is negative. For example abs(x) = flipsign(x,x).\n\nExamples\n\njulia> flipsign(5, 3)\n5\n\njulia> flipsign(5, -3)\n-5\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.sqrt-Tuple{Real}","page":"Mathematics","title":"Base.sqrt","text":"sqrt(x)\n\nReturn sqrtx. Throws DomainError for negative Real arguments. Use complex negative arguments instead. The prefix operator √ is equivalent to sqrt.\n\nExamples\n\njulia> sqrt(big(81))\n9.0\n\njulia> sqrt(big(-81))\nERROR: DomainError with -81.0:\nNaN result for non-NaN input.\nStacktrace:\n [1] sqrt(::BigFloat) at ./mpfr.jl:501\n[...]\n\njulia> sqrt(big(complex(-81)))\n0.0 + 9.0im\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.isqrt","page":"Mathematics","title":"Base.isqrt","text":"isqrt(n::Integer)\n\nInteger square root: the largest integer m such that m*m <= n.\n\njulia> isqrt(5)\n2\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.cbrt","page":"Mathematics","title":"Base.Math.cbrt","text":"cbrt(x::Real)\n\nReturn the cube root of x, i.e. x^13. Negative values are accepted (returning the negative real root when x  0).\n\nThe prefix operator ∛ is equivalent to cbrt.\n\nExamples\n\njulia> cbrt(big(27))\n3.0\n\njulia> cbrt(big(-27))\n-3.0\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.real-Tuple{Complex}","page":"Mathematics","title":"Base.real","text":"real(z)\n\nReturn the real part of the complex number z.\n\nExamples\n\njulia> real(1 + 3im)\n1\n\n\n\n\n\n","category":"method"},{"location":"base/math.html#Base.imag","page":"Mathematics","title":"Base.imag","text":"imag(z)\n\nReturn the imaginary part of the complex number z.\n\nExamples\n\njulia> imag(1 + 3im)\n3\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.reim","page":"Mathematics","title":"Base.reim","text":"reim(z)\n\nReturn both the real and imaginary parts of the complex number z.\n\nExamples\n\njulia> reim(1 + 3im)\n(1, 3)\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.conj","page":"Mathematics","title":"Base.conj","text":"conj(z)\n\nCompute the complex conjugate of a complex number z.\n\nExamples\n\njulia> conj(1 + 3im)\n1 - 3im\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.angle","page":"Mathematics","title":"Base.angle","text":"angle(z)\n\nCompute the phase angle in radians of a complex number z.\n\nExamples\n\njulia> rad2deg(angle(1 + im))\n45.0\n\njulia> rad2deg(angle(1 - im))\n-45.0\n\njulia> rad2deg(angle(-1 - im))\n-135.0\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.cis","page":"Mathematics","title":"Base.cis","text":"cis(z)\n\nReturn exp(iz).\n\nExamples\n\njulia> cis(π) ≈ -1\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.binomial","page":"Mathematics","title":"Base.binomial","text":"binomial(n::Integer, k::Integer)\n\nThe binomial coefficient binomnk, being the coefficient of the kth term in the polynomial expansion of (1+x)^n.\n\nIf n is non-negative, then it is the number of ways to choose k out of n items:\n\nbinomnk = fracnk (n-k)\n\nwhere n is the factorial function.\n\nIf n is negative, then it is defined in terms of the identity\n\nbinomnk = (-1)^k binomk-n-1k\n\nExamples\n\njulia> binomial(5, 3)\n10\n\njulia> factorial(5) ÷ (factorial(5-3) * factorial(3))\n10\n\njulia> binomial(-5, 3)\n-35\n\nSee also\n\nfactorial\n\nExternal links\n\nBinomial coeffient on Wikipedia.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.factorial","page":"Mathematics","title":"Base.factorial","text":"factorial(n::Integer)\n\nFactorial of n. If n is an Integer, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if n is not small, but you can use factorial(big(n)) to compute the result exactly in arbitrary precision.\n\nExamples\n\njulia> factorial(6)\n720\n\njulia> factorial(21)\nERROR: OverflowError: 21 is too large to look up in the table; consider using `factorial(big(21))` instead\nStacktrace:\n[...]\n\njulia> factorial(big(21))\n51090942171709440000\n\nSee also\n\nbinomial\n\nExternal links\n\nFactorial on Wikipedia.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.gcd","page":"Mathematics","title":"Base.gcd","text":"gcd(x,y)\n\nGreatest common (positive) divisor (or zero if x and y are both zero).\n\nExamples\n\njulia> gcd(6,9)\n3\n\njulia> gcd(6,-9)\n3\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.lcm","page":"Mathematics","title":"Base.lcm","text":"lcm(x,y)\n\nLeast common (non-negative) multiple.\n\nExamples\n\njulia> lcm(2,3)\n6\n\njulia> lcm(-2,3)\n6\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.gcdx","page":"Mathematics","title":"Base.gcdx","text":"gcdx(x,y)\n\nComputes the greatest common (positive) divisor of x and y and their Bézout coefficients, i.e. the integer coefficients u and v that satisfy ux+vy = d = gcd(xy). gcdx(xy) returns (duv).\n\nExamples\n\njulia> gcdx(12, 42)\n(6, -3, 1)\n\njulia> gcdx(240, 46)\n(2, -9, 47)\n\nnote: Note\nBézout coefficients are not uniquely defined. gcdx returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients u and v are minimal in the sense that u  yd and v  xd. Furthermore, the signs of u and v are chosen so that d is positive. For unsigned integers, the coefficients u and v might be near their typemax, and the identity then holds only via the unsigned integers' modulo arithmetic.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.ispow2","page":"Mathematics","title":"Base.ispow2","text":"ispow2(n::Integer) -> Bool\n\nTest whether n is a power of two.\n\nExamples\n\njulia> ispow2(4)\ntrue\n\njulia> ispow2(5)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.nextpow","page":"Mathematics","title":"Base.nextpow","text":"nextpow(a, x)\n\nThe smallest a^n not less than x, where n is a non-negative integer. a must be greater than 1, and x must be greater than 0.\n\nExamples\n\njulia> nextpow(2, 7)\n8\n\njulia> nextpow(2, 9)\n16\n\njulia> nextpow(5, 20)\n25\n\njulia> nextpow(4, 16)\n16\n\nSee also prevpow.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.prevpow","page":"Mathematics","title":"Base.prevpow","text":"prevpow(a, x)\n\nThe largest a^n not greater than x, where n is a non-negative integer. a must be greater than 1, and x must not be less than 1.\n\nExamples\n\njulia> prevpow(2, 7)\n4\n\njulia> prevpow(2, 9)\n8\n\njulia> prevpow(5, 20)\n5\n\njulia> prevpow(4, 16)\n16\n\nSee also nextpow.\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.nextprod","page":"Mathematics","title":"Base.nextprod","text":"nextprod([k_1, k_2,...], n)\n\nNext integer greater than or equal to n that can be written as prod k_i^p_i for integers p_1, p_2, etc.\n\nExamples\n\njulia> nextprod([2, 3], 105)\n108\n\njulia> 2^2 * 3^3\n108\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.invmod","page":"Mathematics","title":"Base.invmod","text":"invmod(x,m)\n\nTake the inverse of x modulo m: y such that x y = 1 pmod m, with div(xy) = 0. This is undefined for m = 0, or if gcd(xm) neq 1.\n\nExamples\n\njulia> invmod(2,5)\n3\n\njulia> invmod(2,3)\n2\n\njulia> invmod(5,6)\n5\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.powermod","page":"Mathematics","title":"Base.powermod","text":"powermod(x::Integer, p::Integer, m)\n\nCompute x^p pmod m.\n\nExamples\n\njulia> powermod(2, 6, 5)\n4\n\njulia> mod(2^6, 5)\n4\n\njulia> powermod(5, 2, 20)\n5\n\njulia> powermod(5, 2, 19)\n6\n\njulia> powermod(5, 3, 19)\n11\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.ndigits","page":"Mathematics","title":"Base.ndigits","text":"ndigits(n::Integer; base::Integer=10, pad::Integer=1)\n\nCompute the number of digits in integer n written in base base (base must not be in [-1, 0, 1]), optionally padded with zeros to a specified size (the result will never be less than pad).\n\nExamples\n\njulia> ndigits(12345)\n5\n\njulia> ndigits(1022, base=16)\n3\n\njulia> string(1022, base=16)\n\"3fe\"\n\njulia> ndigits(123, pad=5)\n5\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.widemul","page":"Mathematics","title":"Base.widemul","text":"widemul(x, y)\n\nMultiply x and y, giving the result as a larger type.\n\nExamples\n\njulia> widemul(Float32(3.), 4.)\n12.0\n\n\n\n\n\n","category":"function"},{"location":"base/math.html#Base.Math.@evalpoly","page":"Mathematics","title":"Base.Math.@evalpoly","text":"@evalpoly(z, c...)\n\nEvaluate the polynomial sum_k ck z^k-1 for the coefficients c[1], c[2], ...; that is, the coefficients are given in ascending order by power of z.  This macro expands to efficient inline code that uses either Horner's method or, for complex z, a more efficient Goertzel-like algorithm.\n\nExamples\n\njulia> @evalpoly(3, 1, 0, 1)\n10\n\njulia> @evalpoly(2, 1, 0, 1)\n5\n\njulia> @evalpoly(2, 1, 1, 1)\n7\n\n\n\n\n\n","category":"macro"},{"location":"base/math.html#Base.FastMath.@fastmath","page":"Mathematics","title":"Base.FastMath.@fastmath","text":"@fastmath expr\n\nExecute a transformed version of the expression, which calls functions that may violate strict IEEE semantics. This allows the fastest possible operation, but results are undefined – be careful when doing this, as it may change numerical results.\n\nThis sets the LLVM Fast-Math flags, and corresponds to the -ffast-math option in clang. See the notes on performance annotations for more details.\n\nExamples\n\njulia> @fastmath 1+2\n3\n\njulia> @fastmath(sin(3))\n0.1411200080598672\n\n\n\n\n\n","category":"macro"},{"location":"base/numbers.html#lib-numbers-1","page":"Numbers","title":"Numbers","text":"","category":"section"},{"location":"base/numbers.html#Standard-Numeric-Types-1","page":"Numbers","title":"Standard Numeric Types","text":"","category":"section"},{"location":"base/numbers.html#Abstract-number-types-1","page":"Numbers","title":"Abstract number types","text":"","category":"section"},{"location":"base/numbers.html#","page":"Numbers","title":"Numbers","text":"Core.Number\nCore.Real\nCore.AbstractFloat\nCore.Integer\nCore.Signed\nCore.Unsigned\nBase.AbstractIrrational","category":"page"},{"location":"base/numbers.html#Core.Number","page":"Numbers","title":"Core.Number","text":"Number\n\nAbstract supertype for all number types.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.Real","page":"Numbers","title":"Core.Real","text":"Real <: Number\n\nAbstract supertype for all real numbers.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.AbstractFloat","page":"Numbers","title":"Core.AbstractFloat","text":"AbstractFloat <: Real\n\nAbstract supertype for all floating point numbers.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.Integer","page":"Numbers","title":"Core.Integer","text":"Integer <: Real\n\nAbstract supertype for all integers.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.Signed","page":"Numbers","title":"Core.Signed","text":"Signed <: Integer\n\nAbstract supertype for all signed integers.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.Unsigned","page":"Numbers","title":"Core.Unsigned","text":"Unsigned <: Integer\n\nAbstract supertype for all unsigned integers.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Base.AbstractIrrational","page":"Numbers","title":"Base.AbstractIrrational","text":"AbstractIrrational <: Real\n\nNumber type representing an exact irrational value.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Concrete-number-types-1","page":"Numbers","title":"Concrete number types","text":"","category":"section"},{"location":"base/numbers.html#","page":"Numbers","title":"Numbers","text":"Core.Float16\nCore.Float32\nCore.Float64\nBase.BigFloat\nCore.Bool\nCore.Int8\nCore.UInt8\nCore.Int16\nCore.UInt16\nCore.Int32\nCore.UInt32\nCore.Int64\nCore.UInt64\nCore.Int128\nCore.UInt128\nBase.BigInt\nBase.Complex\nBase.Rational\nBase.Irrational","category":"page"},{"location":"base/numbers.html#Core.Float16","page":"Numbers","title":"Core.Float16","text":"Float16 <: AbstractFloat\n\n16-bit floating point number type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.Float32","page":"Numbers","title":"Core.Float32","text":"Float32 <: AbstractFloat\n\n32-bit floating point number type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.Float64","page":"Numbers","title":"Core.Float64","text":"Float64 <: AbstractFloat\n\n64-bit floating point number type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Base.MPFR.BigFloat","page":"Numbers","title":"Base.MPFR.BigFloat","text":"BigFloat <: AbstractFloat\n\nArbitrary precision floating point number type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.Bool","page":"Numbers","title":"Core.Bool","text":"Bool <: Integer\n\nBoolean type, containing the values true and false.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.Int8","page":"Numbers","title":"Core.Int8","text":"Int8 <: Signed\n\n8-bit signed integer type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.UInt8","page":"Numbers","title":"Core.UInt8","text":"UInt8 <: Unsigned\n\n8-bit unsigned integer type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.Int16","page":"Numbers","title":"Core.Int16","text":"Int16 <: Signed\n\n16-bit signed integer type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.UInt16","page":"Numbers","title":"Core.UInt16","text":"UInt16 <: Unsigned\n\n16-bit unsigned integer type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.Int32","page":"Numbers","title":"Core.Int32","text":"Int32 <: Signed\n\n32-bit signed integer type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.UInt32","page":"Numbers","title":"Core.UInt32","text":"UInt32 <: Unsigned\n\n32-bit unsigned integer type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.Int64","page":"Numbers","title":"Core.Int64","text":"Int64 <: Signed\n\n64-bit signed integer type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.UInt64","page":"Numbers","title":"Core.UInt64","text":"UInt64 <: Unsigned\n\n64-bit unsigned integer type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.Int128","page":"Numbers","title":"Core.Int128","text":"Int128 <: Signed\n\n128-bit signed integer type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Core.UInt128","page":"Numbers","title":"Core.UInt128","text":"UInt128 <: Unsigned\n\n128-bit unsigned integer type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Base.GMP.BigInt","page":"Numbers","title":"Base.GMP.BigInt","text":"BigInt <: Signed\n\nArbitrary precision integer type.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Base.Complex","page":"Numbers","title":"Base.Complex","text":"Complex{T<:Real} <: Number\n\nComplex number type with real and imaginary part of type T.\n\nComplexF16, ComplexF32 and ComplexF64 are aliases for Complex{Float16}, Complex{Float32} and Complex{Float64} respectively.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Base.Rational","page":"Numbers","title":"Base.Rational","text":"Rational{T<:Integer} <: Real\n\nRational number type, with numerator and denominator of type T.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#Base.Irrational","page":"Numbers","title":"Base.Irrational","text":"Irrational{sym} <: AbstractIrrational\n\nNumber type representing an exact irrational value denoted by the symbol sym.\n\n\n\n\n\n","category":"type"},{"location":"base/numbers.html#データ形式-1","page":"Numbers","title":"データ形式","text":"","category":"section"},{"location":"base/numbers.html#","page":"Numbers","title":"Numbers","text":"Base.digits\nBase.digits!\nBase.bitstring\nBase.parse\nBase.tryparse\nBase.big\nBase.signed\nBase.unsigned\nBase.float(::Any)\nBase.Math.significand\nBase.Math.exponent\nBase.complex(::Complex)\nBase.bswap\nBase.hex2bytes\nBase.hex2bytes!\nBase.bytes2hex","category":"page"},{"location":"base/numbers.html#Base.digits","page":"Numbers","title":"Base.digits","text":"digits([T<:Integer], n::Integer; base::T = 10, pad::Integer = 1)\n\nReturn an array with element type T (default Int) of the digits of n in the given base, optionally padded with zeros to a specified size. More significant digits are at higher indices, such that n == sum([digits[k]*base^(k-1) for k=1:length(digits)]).\n\nExamples\n\njulia> digits(10, base = 10)\n2-element Array{Int64,1}:\n 0\n 1\n\njulia> digits(10, base = 2)\n4-element Array{Int64,1}:\n 0\n 1\n 0\n 1\n\njulia> digits(10, base = 2, pad = 6)\n6-element Array{Int64,1}:\n 0\n 1\n 0\n 1\n 0\n 0\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.digits!","page":"Numbers","title":"Base.digits!","text":"digits!(array, n::Integer; base::Integer = 10)\n\nFills an array of the digits of n in the given base. More significant digits are at higher indices. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.\n\nExamples\n\njulia> digits!([2,2,2,2], 10, base = 2)\n4-element Array{Int64,1}:\n 0\n 1\n 0\n 1\n\njulia> digits!([2,2,2,2,2,2], 10, base = 2)\n6-element Array{Int64,1}:\n 0\n 1\n 0\n 1\n 0\n 0\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.bitstring","page":"Numbers","title":"Base.bitstring","text":"bitstring(n)\n\nA string giving the literal bit representation of a number.\n\nExamples\n\njulia> bitstring(4)\n\"0000000000000000000000000000000000000000000000000000000000000100\"\n\njulia> bitstring(2.2)\n\"0100000000000001100110011001100110011001100110011001100110011010\"\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.parse","page":"Numbers","title":"Base.parse","text":"parse(type, str; base)\n\nParse a string as a number. For Integer types, a base can be specified (the default is 10). For floating-point types, the string is parsed as a decimal floating-point number.  Complex types are parsed from decimal strings of the form \"R±Iim\" as a Complex(R,I) of the requested type; \"i\" or \"j\" can also be used instead of \"im\", and \"R\" or \"Iim\" are also permitted. If the string does not contain a valid number, an error is raised.\n\ncompat: Julia 1.1\nparse(Bool, str) requires at least Julia 1.1.\n\nExamples\n\njulia> parse(Int, \"1234\")\n1234\n\njulia> parse(Int, \"1234\", base = 5)\n194\n\njulia> parse(Int, \"afc\", base = 16)\n2812\n\njulia> parse(Float64, \"1.2e-3\")\n0.0012\n\njulia> parse(Complex{Float64}, \"3.2e-1 + 4.5im\")\n0.32 + 4.5im\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.tryparse","page":"Numbers","title":"Base.tryparse","text":"tryparse(type, str; base)\n\nLike parse, but returns either a value of the requested type, or nothing if the string does not contain a valid number.\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.big","page":"Numbers","title":"Base.big","text":"big(x)\n\nConvert a number to a maximum precision representation (typically BigInt or BigFloat). See BigFloat for information about some pitfalls with floating-point numbers.\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.signed","page":"Numbers","title":"Base.signed","text":"signed(x)\n\nConvert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.unsigned","page":"Numbers","title":"Base.unsigned","text":"unsigned(x) -> Unsigned\n\nConvert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.\n\nExamples\n\njulia> unsigned(-2)\n0xfffffffffffffffe\n\njulia> unsigned(2)\n0x0000000000000002\n\njulia> signed(unsigned(-2))\n-2\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.float-Tuple{Any}","page":"Numbers","title":"Base.float","text":"float(x)\n\nConvert a number or array to a floating point data type.\n\n\n\n\n\n","category":"method"},{"location":"base/numbers.html#Base.Math.significand","page":"Numbers","title":"Base.Math.significand","text":"significand(x)\n\nExtract the significand(s) (a.k.a. mantissa), in binary representation, of a floating-point number. If x is a non-zero finite number, then the result will be a number of the same type on the interval 12). Otherwise x is returned.\n\nExamples\n\njulia> significand(15.2)/15.2\n0.125\n\njulia> significand(15.2)*8\n15.2\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.Math.exponent","page":"Numbers","title":"Base.Math.exponent","text":"exponent(x) -> Int\n\nGet the exponent of a normalized floating-point number.\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.complex-Tuple{Complex}","page":"Numbers","title":"Base.complex","text":"complex(r, [i])\n\nConvert real numbers or arrays to complex. i defaults to zero.\n\nExamples\n\njulia> complex(7)\n7 + 0im\n\njulia> complex([1, 2, 3])\n3-element Array{Complex{Int64},1}:\n 1 + 0im\n 2 + 0im\n 3 + 0im\n\n\n\n\n\n","category":"method"},{"location":"base/numbers.html#Base.bswap","page":"Numbers","title":"Base.bswap","text":"bswap(n)\n\nReverse the byte order of n.\n\nExamples\n\njulia> a = bswap(0x10203040)\n0x40302010\n\njulia> bswap(a)\n0x10203040\n\njulia> string(1, base = 2)\n\"1\"\n\njulia> string(bswap(1), base = 2)\n\"100000000000000000000000000000000000000000000000000000000\"\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.hex2bytes","page":"Numbers","title":"Base.hex2bytes","text":"hex2bytes(s::Union{AbstractString,AbstractVector{UInt8}})\n\nGiven a string or array s of ASCII codes for a sequence of hexadecimal digits, returns a Vector{UInt8} of bytes  corresponding to the binary representation: each successive pair of hexadecimal digits in s gives the value of one byte in the return vector.\n\nThe length of s must be even, and the returned array has half of the length of s. See also hex2bytes! for an in-place version, and bytes2hex for the inverse.\n\nExamples\n\njulia> s = string(12345, base = 16)\n\"3039\"\n\njulia> hex2bytes(s)\n2-element Array{UInt8,1}:\n 0x30\n 0x39\n\njulia> a = b\"01abEF\"\n6-element Base.CodeUnits{UInt8,String}:\n 0x30\n 0x31\n 0x61\n 0x62\n 0x45\n 0x46\n\njulia> hex2bytes(a)\n3-element Array{UInt8,1}:\n 0x01\n 0xab\n 0xef\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.hex2bytes!","page":"Numbers","title":"Base.hex2bytes!","text":"hex2bytes!(d::AbstractVector{UInt8}, s::Union{String,AbstractVector{UInt8}})\n\nConvert an array s of bytes representing a hexadecimal string to its binary representation, similar to hex2bytes except that the output is written in-place in d.   The length of s must be exactly twice the length of d.\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.bytes2hex","page":"Numbers","title":"Base.bytes2hex","text":"bytes2hex(a::AbstractArray{UInt8}) -> String\nbytes2hex(io::IO, a::AbstractArray{UInt8})\n\nConvert an array a of bytes to its hexadecimal string representation, either returning a String via bytes2hex(a) or writing the string to an io stream via bytes2hex(io, a).  The hexadecimal characters are all lowercase.\n\nExamples\n\njulia> a = string(12345, base = 16)\n\"3039\"\n\njulia> b = hex2bytes(a)\n2-element Array{UInt8,1}:\n 0x30\n 0x39\n\njulia> bytes2hex(b)\n\"3039\"\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#General-Number-Functions-and-Constants-1","page":"Numbers","title":"General Number Functions and Constants","text":"","category":"section"},{"location":"base/numbers.html#","page":"Numbers","title":"Numbers","text":"Base.one\nBase.oneunit\nBase.zero\nBase.im\nBase.MathConstants.pi\nBase.MathConstants.ℯ\nBase.MathConstants.catalan\nBase.MathConstants.eulergamma\nBase.MathConstants.golden\nBase.Inf\nBase.Inf32\nBase.Inf16\nBase.NaN\nBase.NaN32\nBase.NaN16\nBase.issubnormal\nBase.isfinite\nBase.isinf\nBase.isnan\nBase.iszero\nBase.isone\nBase.nextfloat\nBase.prevfloat\nBase.isinteger\nBase.isreal\nCore.Float32(::Any)\nCore.Float64(::Any)\nBase.Rounding.rounding\nBase.Rounding.setrounding(::Type, ::Any)\nBase.Rounding.setrounding(::Function, ::Type, ::RoundingMode)\nBase.Rounding.get_zero_subnormals\nBase.Rounding.set_zero_subnormals","category":"page"},{"location":"base/numbers.html#Base.one","page":"Numbers","title":"Base.one","text":"one(x)\none(T::type)\n\nReturn a multiplicative identity for x: a value such that one(x)*x == x*one(x) == x.  Alternatively one(T) can take a type T, in which case one returns a multiplicative identity for any x of type T.\n\nIf possible, one(x) returns a value of the same type as x, and one(T) returns a value of type T.  However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless.  In that case, one(x) should return an identity value of the same precision (and shape, for matrices) as x.\n\nIf you want a quantity that is of the same type as x, or of type T, even if x is dimensionful, use oneunit instead.\n\nExamples\n\njulia> one(3.7)\n1.0\n\njulia> one(Int)\n1\n\njulia> import Dates; one(Dates.Day(1))\n1\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.oneunit","page":"Numbers","title":"Base.oneunit","text":"oneunit(x::T)\noneunit(T::Type)\n\nReturns T(one(x)), where T is either the type of the argument or (if a type is passed) the argument.  This differs from one for dimensionful quantities: one is dimensionless (a multiplicative identity) while oneunit is dimensionful (of the same type as x, or of type T).\n\nExamples\n\njulia> oneunit(3.7)\n1.0\n\njulia> import Dates; oneunit(Dates.Day)\n1 day\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.zero","page":"Numbers","title":"Base.zero","text":"zero(x)\n\nGet the additive identity element for the type of x (x can also specify the type itself).\n\nExamples\n\njulia> zero(1)\n0\n\njulia> zero(big\"2.0\")\n0.0\n\njulia> zero(rand(2,2))\n2×2 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.im","page":"Numbers","title":"Base.im","text":"im\n\nThe imaginary unit.\n\nExamples\n\njulia> im * im\n-1 + 0im\n\n\n\n\n\n","category":"constant"},{"location":"base/numbers.html#Base.MathConstants.pi","page":"Numbers","title":"Base.MathConstants.pi","text":"π\npi\n\nThe constant pi.\n\nExamples\n\njulia> pi\nπ = 3.1415926535897...\n\n\n\n\n\n","category":"constant"},{"location":"base/numbers.html#Base.MathConstants.ℯ","page":"Numbers","title":"Base.MathConstants.ℯ","text":"ℯ\ne\n\nThe constant ℯ.\n\nExamples\n\njulia> ℯ\nℯ = 2.7182818284590...\n\n\n\n\n\n","category":"constant"},{"location":"base/numbers.html#Base.MathConstants.catalan","page":"Numbers","title":"Base.MathConstants.catalan","text":"catalan\n\nCatalan's constant.\n\nExamples\n\njulia> Base.MathConstants.catalan\ncatalan = 0.9159655941772...\n\n\n\n\n\n","category":"constant"},{"location":"base/numbers.html#Base.MathConstants.eulergamma","page":"Numbers","title":"Base.MathConstants.eulergamma","text":"γ\neulergamma\n\nEuler's constant.\n\nExamples\n\njulia> Base.MathConstants.eulergamma\nγ = 0.5772156649015...\n\n\n\n\n\n","category":"constant"},{"location":"base/numbers.html#Base.MathConstants.golden","page":"Numbers","title":"Base.MathConstants.golden","text":"φ\ngolden\n\nThe golden ratio.\n\nExamples\n\njulia> Base.MathConstants.golden\nφ = 1.6180339887498...\n\n\n\n\n\n","category":"constant"},{"location":"base/numbers.html#Base.Inf","page":"Numbers","title":"Base.Inf","text":"Inf, Inf64\n\nPositive infinity of type Float64.\n\n\n\n\n\n","category":"constant"},{"location":"base/numbers.html#Base.Inf32","page":"Numbers","title":"Base.Inf32","text":"Inf32\n\nPositive infinity of type Float32.\n\n\n\n\n\n","category":"constant"},{"location":"base/numbers.html#Base.Inf16","page":"Numbers","title":"Base.Inf16","text":"Inf16\n\nPositive infinity of type Float16.\n\n\n\n\n\n","category":"constant"},{"location":"base/numbers.html#Base.NaN","page":"Numbers","title":"Base.NaN","text":"NaN, NaN64\n\nA not-a-number value of type Float64.\n\n\n\n\n\n","category":"constant"},{"location":"base/numbers.html#Base.NaN32","page":"Numbers","title":"Base.NaN32","text":"NaN32\n\nA not-a-number value of type Float32.\n\n\n\n\n\n","category":"constant"},{"location":"base/numbers.html#Base.NaN16","page":"Numbers","title":"Base.NaN16","text":"NaN16\n\nA not-a-number value of type Float16.\n\n\n\n\n\n","category":"constant"},{"location":"base/numbers.html#Base.issubnormal","page":"Numbers","title":"Base.issubnormal","text":"issubnormal(f) -> Bool\n\nTest whether a floating point number is subnormal.\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.isfinite","page":"Numbers","title":"Base.isfinite","text":"isfinite(f) -> Bool\n\nTest whether a number is finite.\n\nExamples\n\njulia> isfinite(5)\ntrue\n\njulia> isfinite(NaN32)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.isinf","page":"Numbers","title":"Base.isinf","text":"isinf(f) -> Bool\n\nTest whether a number is infinite.\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.isnan","page":"Numbers","title":"Base.isnan","text":"isnan(f) -> Bool\n\nTest whether a floating point number is not a number (NaN).\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.iszero","page":"Numbers","title":"Base.iszero","text":"iszero(x)\n\nReturn true if x == zero(x); if x is an array, this checks whether all of the elements of x are zero.\n\nExamples\n\njulia> iszero(0.0)\ntrue\n\njulia> iszero([1, 9, 0])\nfalse\n\njulia> iszero([false, 0, 0])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.isone","page":"Numbers","title":"Base.isone","text":"isone(x)\n\nReturn true if x == one(x); if x is an array, this checks whether x is an identity matrix.\n\nExamples\n\njulia> isone(1.0)\ntrue\n\njulia> isone([1 0; 0 2])\nfalse\n\njulia> isone([1 0; 0 true])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.nextfloat","page":"Numbers","title":"Base.nextfloat","text":"nextfloat(x::AbstractFloat, n::Integer)\n\nThe result of n iterative applications of nextfloat to x if n >= 0, or -n applications of prevfloat if n < 0.\n\n\n\n\n\nnextfloat(x::AbstractFloat)\n\nReturn the smallest floating point number y of the same type as x such x < y. If no such y exists (e.g. if x is Inf or NaN), then return x.\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.prevfloat","page":"Numbers","title":"Base.prevfloat","text":"prevfloat(x::AbstractFloat, n::Integer)\n\nThe result of n iterative applications of prevfloat to x if n >= 0, or -n applications of nextfloat if n < 0.\n\n\n\n\n\nprevfloat(x::AbstractFloat)\n\nReturn the largest floating point number y of the same type as x such y < x. If no such y exists (e.g. if x is -Inf or NaN), then return x.\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.isinteger","page":"Numbers","title":"Base.isinteger","text":"isinteger(x) -> Bool\n\nTest whether x is numerically equal to some integer.\n\nExamples\n\njulia> isinteger(4.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.isreal","page":"Numbers","title":"Base.isreal","text":"isreal(x) -> Bool\n\nTest whether x or all its elements are numerically equal to some real number including infinities and NaNs. isreal(x) is true if isequal(x, real(x)) is true.\n\nExamples\n\njulia> isreal(5.)\ntrue\n\njulia> isreal(Inf + 0im)\ntrue\n\njulia> isreal([4.; complex(0,1)])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Core.Float32-Tuple{Any}","page":"Numbers","title":"Core.Float32","text":"Float32(x [, mode::RoundingMode])\n\nCreate a Float32 from x. If x is not exactly representable then mode determines how x is rounded.\n\nExamples\n\njulia> Float32(1/3, RoundDown)\n0.3333333f0\n\njulia> Float32(1/3, RoundUp)\n0.33333334f0\n\nSee RoundingMode for available rounding modes.\n\n\n\n\n\n","category":"method"},{"location":"base/numbers.html#Core.Float64-Tuple{Any}","page":"Numbers","title":"Core.Float64","text":"Float64(x [, mode::RoundingMode])\n\nCreate a Float64 from x. If x is not exactly representable then mode determines how x is rounded.\n\nExamples\n\njulia> Float64(pi, RoundDown)\n3.141592653589793\n\njulia> Float64(pi, RoundUp)\n3.1415926535897936\n\nSee RoundingMode for available rounding modes.\n\n\n\n\n\n","category":"method"},{"location":"base/numbers.html#Base.Rounding.rounding","page":"Numbers","title":"Base.Rounding.rounding","text":"rounding(T)\n\nGet the current floating point rounding mode for type T, controlling the rounding of basic arithmetic functions (+, -, *, / and sqrt) and type conversion.\n\nSee RoundingMode for available modes.\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.Rounding.setrounding-Tuple{Type,Any}","page":"Numbers","title":"Base.Rounding.setrounding","text":"setrounding(T, mode)\n\nSet the rounding mode of floating point type T, controlling the rounding of basic arithmetic functions (+, -, *, / and sqrt) and type conversion. Other numerical functions may give incorrect or invalid values when using rounding modes other than the default RoundNearest.\n\nNote that this is currently only supported for T == BigFloat.\n\n\n\n\n\n","category":"method"},{"location":"base/numbers.html#Base.Rounding.setrounding-Tuple{Function,Type,RoundingMode}","page":"Numbers","title":"Base.Rounding.setrounding","text":"setrounding(f::Function, T, mode)\n\nChange the rounding mode of floating point type T for the duration of f. It is logically equivalent to:\n\nold = rounding(T)\nsetrounding(T, mode)\nf()\nsetrounding(T, old)\n\nSee RoundingMode for available rounding modes.\n\n\n\n\n\n","category":"method"},{"location":"base/numbers.html#Base.Rounding.get_zero_subnormals","page":"Numbers","title":"Base.Rounding.get_zero_subnormals","text":"get_zero_subnormals() -> Bool\n\nReturn false if operations on subnormal floating-point values (\"denormals\") obey rules for IEEE arithmetic, and true if they might be converted to zeros.\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.Rounding.set_zero_subnormals","page":"Numbers","title":"Base.Rounding.set_zero_subnormals","text":"set_zero_subnormals(yes::Bool) -> Bool\n\nIf yes is false, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (\"denormals\"). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns true unless yes==true but the hardware does not support zeroing of subnormal numbers.\n\nset_zero_subnormals(true) can speed up some computations on some hardware. However, it can break identities such as (x-y==0) == (x==y).\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#整数-1","page":"Numbers","title":"整数","text":"","category":"section"},{"location":"base/numbers.html#","page":"Numbers","title":"Numbers","text":"Base.count_ones\nBase.count_zeros\nBase.leading_zeros\nBase.leading_ones\nBase.trailing_zeros\nBase.trailing_ones\nBase.isodd\nBase.iseven\nBase.@int128_str\nBase.@uint128_str","category":"page"},{"location":"base/numbers.html#Base.count_ones","page":"Numbers","title":"Base.count_ones","text":"count_ones(x::Integer) -> Integer\n\nNumber of ones in the binary representation of x.\n\nExamples\n\njulia> count_ones(7)\n3\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.count_zeros","page":"Numbers","title":"Base.count_zeros","text":"count_zeros(x::Integer) -> Integer\n\nNumber of zeros in the binary representation of x.\n\nExamples\n\njulia> count_zeros(Int32(2 ^ 16 - 1))\n16\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.leading_zeros","page":"Numbers","title":"Base.leading_zeros","text":"leading_zeros(x::Integer) -> Integer\n\nNumber of zeros leading the binary representation of x.\n\nExamples\n\njulia> leading_zeros(Int32(1))\n31\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.leading_ones","page":"Numbers","title":"Base.leading_ones","text":"leading_ones(x::Integer) -> Integer\n\nNumber of ones leading the binary representation of x.\n\nExamples\n\njulia> leading_ones(UInt32(2 ^ 32 - 2))\n31\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.trailing_zeros","page":"Numbers","title":"Base.trailing_zeros","text":"trailing_zeros(x::Integer) -> Integer\n\nNumber of zeros trailing the binary representation of x.\n\nExamples\n\njulia> trailing_zeros(2)\n1\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.trailing_ones","page":"Numbers","title":"Base.trailing_ones","text":"trailing_ones(x::Integer) -> Integer\n\nNumber of ones trailing the binary representation of x.\n\nExamples\n\njulia> trailing_ones(3)\n2\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.isodd","page":"Numbers","title":"Base.isodd","text":"isodd(x::Integer) -> Bool\n\nReturn true if x is odd (that is, not divisible by 2), and false otherwise.\n\nExamples\n\njulia> isodd(9)\ntrue\n\njulia> isodd(10)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.iseven","page":"Numbers","title":"Base.iseven","text":"iseven(x::Integer) -> Bool\n\nReturn true is x is even (that is, divisible by 2), and false otherwise.\n\nExamples\n\njulia> iseven(9)\nfalse\n\njulia> iseven(10)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Core.@int128_str","page":"Numbers","title":"Core.@int128_str","text":"@int128_str str\n@int128_str(str)\n\n@int128_str parses a string into a Int128 Throws an ArgumentError if the string is not a valid integer\n\n\n\n\n\n","category":"macro"},{"location":"base/numbers.html#Core.@uint128_str","page":"Numbers","title":"Core.@uint128_str","text":"@uint128_str str\n@uint128_str(str)\n\n@uint128_str parses a string into a UInt128 Throws an ArgumentError if the string is not a valid integer\n\n\n\n\n\n","category":"macro"},{"location":"base/numbers.html#BigFloats-and-BigInts-1","page":"Numbers","title":"BigFloats and BigInts","text":"","category":"section"},{"location":"base/numbers.html#","page":"Numbers","title":"Numbers","text":"The BigFloat and BigInt types implements arbitrary-precision floating point and integer arithmetic, respectively. For BigFloat the GNU MPFR library is used, and for BigInt the GNU Multiple Precision Arithmetic Library (GMP) is used.","category":"page"},{"location":"base/numbers.html#","page":"Numbers","title":"Numbers","text":"Base.MPFR.BigFloat(::Any, rounding::RoundingMode)\nBase.precision\nBase.MPFR.precision(::Type{BigFloat})\nBase.MPFR.setprecision\nBase.GMP.BigInt(::Any)\nBase.@big_str","category":"page"},{"location":"base/numbers.html#Base.MPFR.BigFloat-Tuple{Any,RoundingMode}","page":"Numbers","title":"Base.MPFR.BigFloat","text":"BigFloat(x::Union{Real, AbstractString} [, rounding::RoundingMode=rounding(BigFloat)]; [precision::Integer=precision(BigFloat)])\n\nCreate an arbitrary precision floating point number from x, with precision precision. The rounding argument specifies the direction in which the result should be rounded if the conversion cannot be done exactly. If not provided, these are set by the current global values.\n\nBigFloat(x::Real) is the same as convert(BigFloat,x), except if x itself is already BigFloat, in which case it will return a value with the precision set to the current global precision; convert will always return x.\n\nBigFloat(x::AbstractString) is identical to parse. This is provided for convenience since decimal literals are converted to Float64 when parsed, so BigFloat(2.1) may not yield what you expect.\n\ncompat: Julia 1.1\nprecision as a keyword argument requires at least Julia 1.1. In Julia 1.0 precision is the second positional argument (BigFloat(x, precision)).\n\nExamples\n\njulia> BigFloat(2.1) # 2.1 here is a Float64\n2.100000000000000088817841970012523233890533447265625\n\njulia> BigFloat(\"2.1\") # the closest BigFloat to 2.1\n2.099999999999999999999999999999999999999999999999999999999999999999999999999986\n\njulia> BigFloat(\"2.1\", RoundUp)\n2.100000000000000000000000000000000000000000000000000000000000000000000000000021\n\njulia> BigFloat(\"2.1\", RoundUp, precision=128)\n2.100000000000000000000000000000000000007\n\nSee also\n\n@big_str\nrounding and setrounding\nprecision and setprecision\n\n\n\n\n\n","category":"method"},{"location":"base/numbers.html#Base.precision","page":"Numbers","title":"Base.precision","text":"precision(num::AbstractFloat)\n\nGet the precision of a floating point number, as defined by the effective number of bits in the mantissa.\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.precision-Tuple{Type{BigFloat}}","page":"Numbers","title":"Base.precision","text":"precision(BigFloat)\n\nGet the precision (in bits) currently used for BigFloat arithmetic.\n\n\n\n\n\n","category":"method"},{"location":"base/numbers.html#Base.MPFR.setprecision","page":"Numbers","title":"Base.MPFR.setprecision","text":"setprecision([T=BigFloat,] precision::Int)\n\nSet the precision (in bits) to be used for T arithmetic.\n\n\n\n\n\nsetprecision(f::Function, [T=BigFloat,] precision::Integer)\n\nChange the T arithmetic precision (in bits) for the duration of f. It is logically equivalent to:\n\nold = precision(BigFloat)\nsetprecision(BigFloat, precision)\nf()\nsetprecision(BigFloat, old)\n\nOften used as setprecision(T, precision) do ... end\n\nNote: nextfloat(), prevfloat() do not use the precision mentioned by setprecision\n\n\n\n\n\n","category":"function"},{"location":"base/numbers.html#Base.GMP.BigInt-Tuple{Any}","page":"Numbers","title":"Base.GMP.BigInt","text":"BigInt(x)\n\nCreate an arbitrary precision integer. x may be an Int (or anything that can be converted to an Int). The usual mathematical operators are defined for this type, and results are promoted to a BigInt.\n\nInstances can be constructed from strings via parse, or using the big string literal.\n\nExamples\n\njulia> parse(BigInt, \"42\")\n42\n\njulia> big\"313\"\n313\n\n\n\n\n\n","category":"method"},{"location":"base/numbers.html#Core.@big_str","page":"Numbers","title":"Core.@big_str","text":"@big_str str\n@big_str(str)\n\nParse a string into a BigInt or BigFloat, and throw an ArgumentError if the string is not a valid number. For integers _ is allowed in the string as a separator.\n\nExamples\n\njulia> big\"123_456\"\n123456\n\njulia> big\"7891.5\"\n7891.5\n\n\n\n\n\n","category":"macro"},{"location":"base/strings.html#lib-strings-1","page":"Strings","title":"Strings","text":"","category":"section"},{"location":"base/strings.html#","page":"Strings","title":"Strings","text":"Core.AbstractChar\nCore.Char\nBase.codepoint\nBase.length(::AbstractString)\nBase.sizeof(::AbstractString)\nBase.:*(::Union{AbstractChar, AbstractString}, ::Union{AbstractChar, AbstractString}...)\nBase.:^(::AbstractString, ::Integer)\nBase.string\nBase.repeat(::AbstractString, ::Integer)\nBase.repeat(::AbstractChar, ::Integer)\nBase.repr(::Any)\nCore.String(::AbstractString)\nBase.SubString\nBase.transcode\nBase.unsafe_string\nBase.ncodeunits(::AbstractString)\nBase.codeunit\nBase.codeunits\nBase.ascii\nBase.@r_str\nBase.SubstitutionString\nBase.@s_str\nBase.@raw_str\nBase.@b_str\nBase.Docs.@html_str\nBase.Docs.@text_str\nBase.isvalid(::Any)\nBase.isvalid(::Any, ::Any)\nBase.isvalid(::AbstractString, ::Integer)\nBase.match\nBase.eachmatch\nBase.isless(::AbstractString, ::AbstractString)\nBase.:(==)(::AbstractString, ::AbstractString)\nBase.cmp(::AbstractString, ::AbstractString)\nBase.lpad\nBase.rpad\nBase.findfirst(::AbstractString, ::AbstractString)\nBase.findnext(::AbstractString, ::AbstractString, ::Integer)\nBase.findlast(::AbstractString, ::AbstractString)\nBase.findprev(::AbstractString, ::AbstractString, ::Integer)\nBase.occursin\nBase.reverse(::Union{String,SubString{String}})\nBase.replace(s::AbstractString, ::Pair)\nBase.split\nBase.rsplit\nBase.strip\nBase.lstrip\nBase.rstrip\nBase.startswith\nBase.endswith\nBase.first(::AbstractString, ::Integer)\nBase.last(::AbstractString, ::Integer)\nBase.uppercase\nBase.lowercase\nBase.titlecase\nBase.uppercasefirst\nBase.lowercasefirst\nBase.join\nBase.chop\nBase.chomp\nBase.thisind\nBase.nextind\nBase.prevind\nBase.textwidth\nBase.isascii\nBase.iscntrl\nBase.isdigit\nBase.isletter\nBase.islowercase\nBase.isnumeric\nBase.isprint\nBase.ispunct\nBase.isspace\nBase.isuppercase\nBase.isxdigit\nBase.escape_string\nBase.unescape_string","category":"page"},{"location":"base/strings.html#Core.AbstractChar","page":"Strings","title":"Core.AbstractChar","text":"The AbstractChar type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted to an integer via the codepoint function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with < and ==, for example.  New T <: AbstractChar types should define a codepoint(::T) method and a T(::UInt32) constructor, at minimum.\n\nA given AbstractChar subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported UInt32 value may throw an error. Conversely, the built-in Char type represents a superset of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value to UInt32 throws an error. The isvalid function can be used to check which codepoints are representable in a given AbstractChar type.\n\nInternally, an AbstractChar type may use a variety of encodings.  Conversion via codepoint(char) will not reveal this encoding because it always returns the Unicode value of the character. print(io, c) of any c::AbstractChar produces an encoding determined by io (UTF-8 for all built-in IO types), via conversion to Char if necessary.\n\nwrite(io, c), in contrast, may emit an encoding depending on typeof(c), and read(io, typeof(c)) should read the same encoding as write. New AbstractChar types must provide their own implementations of write and read.\n\n\n\n\n\n","category":"type"},{"location":"base/strings.html#Core.Char","page":"Strings","title":"Core.Char","text":"Char(c::Union{Number,AbstractChar})\n\nChar is a 32-bit AbstractChar type that is the default representation of characters in Julia. Char is the type used for character literals like 'x' and it is also the element type of String.\n\nIn order to losslessly represent arbitrary byte streams stored in a String, a Char value may store information that cannot be converted to a Unicode codepoint — converting such a Char to UInt32 will throw an error. The isvalid(c::Char) function can be used to query whether c represents a valid Unicode character.\n\n\n\n\n\n","category":"type"},{"location":"base/strings.html#Base.codepoint","page":"Strings","title":"Base.codepoint","text":"codepoint(c::AbstractChar) -> Integer\n\nReturn the Unicode codepoint (an unsigned integer) corresponding to the character c (or throw an exception if c does not represent a valid character). For Char, this is a UInt32 value, but AbstractChar types that represent only a subset of Unicode may return a different-sized integer (e.g. UInt8).\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.length-Tuple{AbstractString}","page":"Strings","title":"Base.length","text":"length(s::AbstractString) -> Int\nlength(s::AbstractString, i::Integer, j::Integer) -> Int\n\nThe number of characters in string s from indices i through j. This is computed as the number of code unit indices from i to j which are valid character indices. With only a single string argument, this computes the number of characters in the entire string. With i and j arguments it computes the number of indices between i and j inclusive that are valid indices in the string s. In addition to in-bounds values, i may take the out-of-bounds value ncodeunits(s) + 1 and j may take the out-of-bounds value 0.\n\nSee also: isvalid, ncodeunits, lastindex, thisind, nextind, prevind\n\nExamples\n\njulia> length(\"jμΛIα\")\n5\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.sizeof-Tuple{AbstractString}","page":"Strings","title":"Base.sizeof","text":"sizeof(str::AbstractString)\n\nSize, in bytes, of the string str. Equal to the number of code units in str multiplied by the size, in bytes, of one code unit in str.\n\nExamples\n\njulia> sizeof(\"\")\n0\n\njulia> sizeof(\"∀\")\n3\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.:*-Tuple{Union{AbstractChar, AbstractString},Vararg{Union{AbstractChar, AbstractString},N} where N}","page":"Strings","title":"Base.:*","text":"*(s::Union{AbstractString, AbstractChar}, t::Union{AbstractString, AbstractChar}...) -> AbstractString\n\nConcatenate strings and/or characters, producing a String. This is equivalent to calling the string function on the arguments. Concatenation of built-in string types always produces a value of type String but other string types may choose to return a string of a different type as appropriate.\n\nExamples\n\njulia> \"Hello \" * \"world\"\n\"Hello world\"\n\njulia> 'j' * \"ulia\"\n\"julia\"\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.:^-Tuple{AbstractString,Integer}","page":"Strings","title":"Base.:^","text":"^(s::Union{AbstractString,AbstractChar}, n::Integer)\n\nRepeat a string or character n times. This can also be written as repeat(s, n).\n\nSee also: repeat\n\nExamples\n\njulia> \"Test \"^3\n\"Test Test Test \"\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.string","page":"Strings","title":"Base.string","text":"string(n::Integer; base::Integer = 10, pad::Integer = 1)\n\nConvert an integer n to a string in the given base, optionally specifying a number of digits to pad to.\n\njulia> string(5, base = 13, pad = 4)\n\"0005\"\n\njulia> string(13, base = 5, pad = 4)\n\"0023\"\n\n\n\n\n\nstring(xs...)\n\nCreate a string from any values, except nothing, using the print function.\n\nstring should usually not be defined directly. Instead, define a method print(io::IO, x::MyType). If string(x) for a certain type needs to be highly efficient, then it may make sense to add a method to string and define print(io::IO, x::MyType) = print(io, string(x)) to ensure the functions are consistent.\n\nExamples\n\njulia> string(\"a\", 1, true)\n\"a1true\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.repeat-Tuple{AbstractString,Integer}","page":"Strings","title":"Base.repeat","text":"repeat(s::AbstractString, r::Integer)\n\nRepeat a string r times. This can be written as s^r.\n\nSee also: ^\n\nExamples\n\njulia> repeat(\"ha\", 3)\n\"hahaha\"\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.repeat-Tuple{AbstractChar,Integer}","page":"Strings","title":"Base.repeat","text":"repeat(c::AbstractChar, r::Integer) -> String\n\nRepeat a character r times. This can equivalently be accomplished by calling c^r.\n\nExamples\n\njulia> repeat('A', 3)\n\"AAA\"\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.repr-Tuple{Any}","page":"Strings","title":"Base.repr","text":"repr(x; context=nothing)\n\nCreate a string from any value using the show function. You should not add methods to repr; define a show method instead.\n\nThe optional keyword argument context can be set to an IO or IOContext object whose attributes are used for the I/O stream passed to show.\n\nNote that repr(x) is usually similar to how the value of x would be entered in Julia.  See also repr(MIME(\"text/plain\"), x) to instead return a \"pretty-printed\" version of x designed more for human consumption, equivalent to the REPL display of x.\n\nExamples\n\njulia> repr(1)\n\"1\"\n\njulia> repr(zeros(3))\n\"[0.0, 0.0, 0.0]\"\n\njulia> repr(big(1/3))\n\"0.333333333333333314829616256247390992939472198486328125\"\n\njulia> repr(big(1/3), context=:compact => true)\n\"0.333333\"\n\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Core.String-Tuple{AbstractString}","page":"Strings","title":"Core.String","text":"String(s::AbstractString)\n\nConvert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.SubString","page":"Strings","title":"Base.SubString","text":"SubString(s::AbstractString, i::Integer, j::Integer=lastindex(s))\nSubString(s::AbstractString, r::UnitRange{<:Integer})\n\nLike getindex, but returns a view into the parent string s within range i:j or r respectively instead of making a copy.\n\nExamples\n\njulia> SubString(\"abc\", 1, 2)\n\"ab\"\n\njulia> SubString(\"abc\", 1:2)\n\"ab\"\n\njulia> SubString(\"abc\", 2)\n\"bc\"\n\n\n\n\n\n","category":"type"},{"location":"base/strings.html#Base.transcode","page":"Strings","title":"Base.transcode","text":"transcode(T, src)\n\nConvert string data between Unicode encodings. src is either a String or a Vector{UIntXX} of UTF-XX code units, where XX is 8, 16, or 32. T indicates the encoding of the return value: String to return a (UTF-8 encoded) String or UIntXX to return a Vector{UIntXX} of UTF-XX data. (The alias Cwchar_t can also be used as the integer type, for converting wchar_t* strings used by external C libraries.)\n\nThe transcode function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.\n\nOnly conversion to/from UTF-8 is currently supported.\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.unsafe_string","page":"Strings","title":"Base.unsafe_string","text":"unsafe_string(p::Ptr{UInt8}, [length::Integer])\n\nCopy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If length is specified (the length of the data in bytes), the string does not have to be NUL-terminated.\n\nThis function is labeled \"unsafe\" because it will crash if p is not a valid memory address to data of the requested length.\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.ncodeunits-Tuple{AbstractString}","page":"Strings","title":"Base.ncodeunits","text":"ncodeunits(s::AbstractString) -> Int\n\nReturn the number of code units in a string. Indices that are in bounds to access this string must satisfy 1 ≤ i ≤ ncodeunits(s). Not all such indices are valid – they may not be the start of a character, but they will return a code unit value when calling codeunit(s,i).\n\nSee also: codeunit, checkbounds, sizeof, length, lastindex\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.codeunit","page":"Strings","title":"Base.codeunit","text":"codeunit(s::AbstractString) -> Type{<:Union{UInt8, UInt16, UInt32}}\n\nReturn the code unit type of the given string object. For ASCII, Latin-1, or UTF-8 encoded strings, this would be UInt8; for UCS-2 and UTF-16 it would be UInt16; for UTF-32 it would be UInt32. The unit code type need not be limited to these three types, but it's hard to think of widely used string encodings that don't use one of these units. codeunit(s) is the same as typeof(codeunit(s,1)) when s is a non-empty string.\n\nSee also: ncodeunits\n\n\n\n\n\ncodeunit(s::AbstractString, i::Integer) -> Union{UInt8, UInt16, UInt32}\n\nReturn the code unit value in the string s at index i. Note that\n\ncodeunit(s, i) :: codeunit(s)\n\nI.e. the value returned by codeunit(s, i) is of the type returned by codeunit(s).\n\nSee also: ncodeunits, checkbounds\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.codeunits","page":"Strings","title":"Base.codeunits","text":"codeunits(s::AbstractString)\n\nObtain a vector-like object containing the code units of a string. Returns a CodeUnits wrapper by default, but codeunits may optionally be defined for new string types if necessary.\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.ascii","page":"Strings","title":"Base.ascii","text":"ascii(s::AbstractString)\n\nConvert a string to String type and check that it contains only ASCII data, otherwise throwing an ArgumentError indicating the position of the first non-ASCII byte.\n\nExamples\n\njulia> ascii(\"abcdeγfgh\")\nERROR: ArgumentError: invalid ASCII at index 6 in \"abcdeγfgh\"\nStacktrace:\n[...]\n\njulia> ascii(\"abcdefgh\")\n\"abcdefgh\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.@r_str","page":"Strings","title":"Base.@r_str","text":"@r_str -> Regex\n\nConstruct a regex, such as r\"^[a-z]*$\", without interpolation and unescaping (except for quotation mark \" which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:\n\ni enables case-insensitive matching\nm treats the ^ and $ tokens as matching the start and end of individual lines, as opposed to the whole string.\ns allows the . modifier to match newlines.\nx enables \"comment mode\": whitespace is enabled except when escaped with \\, and # is treated as starting a comment.\na disables UCP mode (enables ASCII mode). By default \\B, \\b, \\D, \\d, \\S, \\s, \\W, \\w, etc. match based on Unicode character properties. With this option, these sequences only match ASCII characters.\n\nSee Regex if interpolation is needed.\n\nExamples\n\njulia> match(r\"a+.*b+.*?d$\"ism, \"Goodbye,\\nOh, angry,\\nBad world\\n\")\nRegexMatch(\"angry,\\nBad world\")\n\nThis regex has the first three flags enabled.\n\n\n\n\n\n","category":"macro"},{"location":"base/strings.html#Base.SubstitutionString","page":"Strings","title":"Base.SubstitutionString","text":"SubstitutionString(substr)\n\nStores the given string substr as a SubstitutionString, for use in regular expression substitutions. Most commonly constructed using the @s_str macro.\n\njulia> SubstitutionString(\"Hello \\\\g<name>, it's \\\\1\")\ns\"Hello \\\\g<name>, it's \\\\1\"\n\njulia> subst = s\"Hello \\g<name>, it's \\1\"\ns\"Hello \\\\g<name>, it's \\\\1\"\n\njulia> typeof(subst)\nSubstitutionString{String}\n\n\n\n\n\n\n","category":"type"},{"location":"base/strings.html#Base.@s_str","page":"Strings","title":"Base.@s_str","text":"@s_str -> SubstitutionString\n\nConstruct a substitution string, used for regular expression substitutions.  Within the string, sequences of the form \\N refer to the Nth capture group in the regex, and \\g<groupname> refers to a named capture group with name groupname.\n\njulia> msg = \"#Hello# from Julia\";\n\njulia> replace(msg, r\"#(.+)# from (?<from>\\w+)\" => s\"FROM: \\g<from>; MESSAGE: \\1\")\n\"FROM: Julia; MESSAGE: Hello\"\n\n\n\n\n\n","category":"macro"},{"location":"base/strings.html#Base.@raw_str","page":"Strings","title":"Base.@raw_str","text":"@raw_str -> String\n\nCreate a raw string without interpolation and unescaping. The exception is that quotation marks still must be escaped. Backslashes escape both quotation marks and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character.\n\nExamples\n\njulia> println(raw\"\\ $x\")\n\\ $x\n\njulia> println(raw\"\\\"\")\n\"\n\njulia> println(raw\"\\\\\\\"\")\n\\\"\n\njulia> println(raw\"\\\\x \\\\\\\"\")\n\\\\x \\\"\n\n\n\n\n\n","category":"macro"},{"location":"base/strings.html#Base.@b_str","page":"Strings","title":"Base.@b_str","text":"@b_str\n\nCreate an immutable byte (UInt8) vector using string syntax.\n\nExamples\n\njulia> v = b\"12\\x01\\x02\"\n4-element Base.CodeUnits{UInt8,String}:\n 0x31\n 0x32\n 0x01\n 0x02\n\njulia> v[2]\n0x32\n\n\n\n\n\n","category":"macro"},{"location":"base/strings.html#Base.Docs.@html_str","page":"Strings","title":"Base.Docs.@html_str","text":"@html_str -> Docs.HTML\n\nCreate an HTML object from a literal string.\n\n\n\n\n\n","category":"macro"},{"location":"base/strings.html#Base.Docs.@text_str","page":"Strings","title":"Base.Docs.@text_str","text":"@text_str -> Docs.Text\n\nCreate a Text object from a literal string.\n\n\n\n\n\n","category":"macro"},{"location":"base/strings.html#Base.isvalid-Tuple{Any}","page":"Strings","title":"Base.isvalid","text":"isvalid(value) -> Bool\n\nReturns true if the given value is valid for its type, which currently can be either AbstractChar or String or SubString{String}.\n\nExamples\n\njulia> isvalid(Char(0xd800))\nfalse\n\njulia> isvalid(SubString(String(UInt8[0xfe,0x80,0x80,0x80,0x80,0x80]),1,2))\nfalse\n\njulia> isvalid(Char(0xd799))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.isvalid-Tuple{Any,Any}","page":"Strings","title":"Base.isvalid","text":"isvalid(T, value) -> Bool\n\nReturns true if the given value is valid for that type. Types currently can be either AbstractChar or String. Values for AbstractChar can be of type AbstractChar or UInt32. Values for String can be of that type, or Vector{UInt8} or SubString{String}.\n\nExamples\n\njulia> isvalid(Char, 0xd800)\nfalse\n\njulia> isvalid(String, SubString(\"thisisvalid\",1,5))\ntrue\n\njulia> isvalid(Char, 0xd799)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.isvalid-Tuple{AbstractString,Integer}","page":"Strings","title":"Base.isvalid","text":"isvalid(s::AbstractString, i::Integer) -> Bool\n\nPredicate indicating whether the given index is the start of the encoding of a character in s or not. If isvalid(s, i) is true then s[i] will return the character whose encoding starts at that index, if it's false, then s[i] will raise an invalid index error or a bounds error depending on if i is in bounds. In order for isvalid(s, i) to be an O(1) function, the encoding of s must be self-synchronizing this is a basic assumption of Julia's generic string support.\n\nSee also: getindex, iterate, thisind, nextind, prevind, length\n\nExamples\n\njulia> str = \"αβγdef\";\n\njulia> isvalid(str, 1)\ntrue\n\njulia> str[1]\n'α': Unicode U+03b1 (category Ll: Letter, lowercase)\n\njulia> isvalid(str, 2)\nfalse\n\njulia> str[2]\nERROR: StringIndexError(\"αβγdef\", 2)\nStacktrace:\n[...]\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.match","page":"Strings","title":"Base.match","text":"match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])\n\nSearch for the first match of the regular expression r in s and return a RegexMatch object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing m.match and the captured sequences can be retrieved by accessing m.captures The optional idx argument specifies an index at which to start the search.\n\nExamples\n\njulia> rx = r\"a(.)a\"\nr\"a(.)a\"\n\njulia> m = match(rx, \"cabac\")\nRegexMatch(\"aba\", 1=\"b\")\n\njulia> m.captures\n1-element Array{Union{Nothing, SubString{String}},1}:\n \"b\"\n\njulia> m.match\n\"aba\"\n\njulia> match(rx, \"cabac\", 3) === nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.eachmatch","page":"Strings","title":"Base.eachmatch","text":"eachmatch(r::Regex, s::AbstractString; overlap::Bool=false)\n\nSearch for all matches of a the regular expression r in s and return a iterator over the matches. If overlap is true, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.\n\nExamples\n\njulia> rx = r\"a.a\"\nr\"a.a\"\n\njulia> m = eachmatch(rx, \"a1a2a3a\")\nBase.RegexMatchIterator(r\"a.a\", \"a1a2a3a\", false)\n\njulia> collect(m)\n2-element Array{RegexMatch,1}:\n RegexMatch(\"a1a\")\n RegexMatch(\"a3a\")\n\njulia> collect(eachmatch(rx, \"a1a2a3a\", overlap = true))\n3-element Array{RegexMatch,1}:\n RegexMatch(\"a1a\")\n RegexMatch(\"a2a\")\n RegexMatch(\"a3a\")\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.isless-Tuple{AbstractString,AbstractString}","page":"Strings","title":"Base.isless","text":"isless(a::AbstractString, b::AbstractString) -> Bool\n\nTest whether string a comes before string b in alphabetical order (technically, in lexicographical order by Unicode code points).\n\nExamples\n\njulia> isless(\"a\", \"b\")\ntrue\n\njulia> isless(\"β\", \"α\")\nfalse\n\njulia> isless(\"a\", \"a\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.:==-Tuple{AbstractString,AbstractString}","page":"Strings","title":"Base.:==","text":"==(a::AbstractString, b::AbstractString) -> Bool\n\nTest whether two strings are equal character by character (technically, Unicode code point by code point).\n\nExamples\n\njulia> \"abc\" == \"abc\"\ntrue\n\njulia> \"abc\" == \"αβγ\"\nfalse\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.cmp-Tuple{AbstractString,AbstractString}","page":"Strings","title":"Base.cmp","text":"cmp(a::AbstractString, b::AbstractString) -> Int\n\nCompare two strings. Return 0 if both strings have the same length and the character at each index is the same in both strings. Return -1 if a is a prefix of b, or if a comes before b in alphabetical order. Return 1 if b is a prefix of a, or if b comes before a in alphabetical order (technically, lexicographical order by Unicode code points).\n\nExamples\n\njulia> cmp(\"abc\", \"abc\")\n0\n\njulia> cmp(\"ab\", \"abc\")\n-1\n\njulia> cmp(\"abc\", \"ab\")\n1\n\njulia> cmp(\"ab\", \"ac\")\n-1\n\njulia> cmp(\"ac\", \"ab\")\n1\n\njulia> cmp(\"α\", \"a\")\n1\n\njulia> cmp(\"b\", \"β\")\n-1\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.lpad","page":"Strings","title":"Base.lpad","text":"lpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -> String\n\nStringify s and pad the resulting string on the left with p to make it n characters (code points) long. If s is already n characters long, an equal string is returned. Pad with spaces by default.\n\nExamples\n\njulia> lpad(\"March\", 10)\n\"     March\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.rpad","page":"Strings","title":"Base.rpad","text":"rpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -> String\n\nStringify s and pad the resulting string on the right with p to make it n characters (code points) long. If s is already n characters long, an equal string is returned. Pad with spaces by default.\n\nExamples\n\njulia> rpad(\"March\", 20)\n\"March               \"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.findfirst-Tuple{AbstractString,AbstractString}","page":"Strings","title":"Base.findfirst","text":"findfirst(pattern::AbstractString, string::AbstractString)\nfindfirst(pattern::Regex, string::String)\n\nFind the first occurrence of pattern in string. Equivalent to findnext(pattern, string, firstindex(s)).\n\nExamples\n\njulia> findfirst(\"z\", \"Hello to the world\") # returns nothing, but not printed in the REPL\n\njulia> findfirst(\"Julia\", \"JuliaLang\")\n1:5\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.findnext-Tuple{AbstractString,AbstractString,Integer}","page":"Strings","title":"Base.findnext","text":"findnext(pattern::AbstractString, string::AbstractString, start::Integer)\nfindnext(pattern::Regex, string::String, start::Integer)\n\nFind the next occurrence of pattern in string starting at position start. pattern can be either a string, or a regular expression, in which case string must be of type String.\n\nThe return value is a range of indices where the matching sequence is found, such that s[findnext(x, s, i)] == x:\n\nfindnext(\"substring\", string, i) == start:stop such that string[start:stop] == \"substring\" and i <= start, or nothing if unmatched.\n\nExamples\n\njulia> findnext(\"z\", \"Hello to the world\", 1) === nothing\ntrue\n\njulia> findnext(\"o\", \"Hello to the world\", 6)\n8:8\n\njulia> findnext(\"Lang\", \"JuliaLang\", 2)\n6:9\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.findlast-Tuple{AbstractString,AbstractString}","page":"Strings","title":"Base.findlast","text":"findlast(pattern::AbstractString, string::AbstractString)\n\nFind the last occurrence of pattern in string. Equivalent to findprev(pattern, string, lastindex(string)).\n\nExamples\n\njulia> findlast(\"o\", \"Hello to the world\")\n15:15\n\njulia> findfirst(\"Julia\", \"JuliaLang\")\n1:5\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.findprev-Tuple{AbstractString,AbstractString,Integer}","page":"Strings","title":"Base.findprev","text":"findprev(pattern::AbstractString, string::AbstractString, start::Integer)\n\nFind the previous occurrence of pattern in string starting at position start.\n\nThe return value is a range of indices where the matching sequence is found, such that s[findprev(x, s, i)] == x:\n\nfindprev(\"substring\", string, i) == start:stop such that string[start:stop] == \"substring\" and stop <= i, or nothing if unmatched.\n\nExamples\n\njulia> findprev(\"z\", \"Hello to the world\", 18) === nothing\ntrue\n\njulia> findprev(\"o\", \"Hello to the world\", 18)\n15:15\n\njulia> findprev(\"Julia\", \"JuliaLang\", 6)\n1:5\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.occursin","page":"Strings","title":"Base.occursin","text":"occursin(needle::Union{AbstractString,Regex,AbstractChar}, haystack::AbstractString)\n\nDetermine whether the first argument is a substring of the second. If needle is a regular expression, checks whether haystack contains a match.\n\nExamples\n\njulia> occursin(\"Julia\", \"JuliaLang is pretty cool!\")\ntrue\n\njulia> occursin('a', \"JuliaLang is pretty cool!\")\ntrue\n\njulia> occursin(r\"a.a\", \"aba\")\ntrue\n\njulia> occursin(r\"a.a\", \"abba\")\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.reverse-Tuple{Union{SubString{String}, String}}","page":"Strings","title":"Base.reverse","text":"reverse(s::AbstractString) -> AbstractString\n\nReverses a string. Technically, this function reverses the codepoints in a string and its main utility is for reversed-order string processing, especially for reversed regular-expression searches. See also reverseind to convert indices in s to indices in reverse(s) and vice-versa, and graphemes from module Unicode to operate on user-visible \"characters\" (graphemes) rather than codepoints. See also Iterators.reverse for reverse-order iteration without making a copy. Custom string types must implement the reverse function themselves and should typically return a string with the same type and encoding. If they return a string with a different encoding, they must also override reverseind for that string type to satisfy s[reverseind(s,i)] == reverse(s)[i].\n\nExamples\n\njulia> reverse(\"JuliaLang\")\n\"gnaLailuJ\"\n\njulia> reverse(\"ax̂e\") # combining characters can lead to surprising results\n\"êxa\"\n\njulia> using Unicode\n\njulia> join(reverse(collect(graphemes(\"ax̂e\")))) # reverses graphemes\n\"ex̂a\"\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.replace-Tuple{AbstractString,Pair}","page":"Strings","title":"Base.replace","text":"replace(s::AbstractString, pat=>r; [count::Integer])\n\nSearch for the given pattern pat in s, and replace each occurrence with r. If count is provided, replace at most count occurrences. pat may be a single character, a vector or a set of characters, a string, or a regular expression. If r is a function, each occurrence is replaced with r(s) where s is the matched substring (when patis a Regex or AbstractString) or character (when pat is an AbstractChar or a collection of AbstractChar). If pat is a regular expression and r is a SubstitutionString, then capture group references in r are replaced with the corresponding matched text. To remove instances of pat from string, set r to the empty String (\"\").\n\nExamples\n\njulia> replace(\"Python is a programming language.\", \"Python\" => \"Julia\")\n\"Julia is a programming language.\"\n\njulia> replace(\"The quick foxes run quickly.\", \"quick\" => \"slow\", count=1)\n\"The slow foxes run quickly.\"\n\njulia> replace(\"The quick foxes run quickly.\", \"quick\" => \"\", count=1)\n\"The  foxes run quickly.\"\n\njulia> replace(\"The quick foxes run quickly.\", r\"fox(es)?\" => s\"bus\\1\")\n\"The quick buses run quickly.\"\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.split","page":"Strings","title":"Base.split","text":"split(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)\nsplit(str::AbstractString; limit::Integer=0, keepempty::Bool=false)\n\nSplit str into an array of substrings on occurrences of the delimiter(s) dlm.  dlm can be any of the formats allowed by findnext's first argument (i.e. as a string, regular expression or a function), or as a single character or collection of characters.\n\nIf dlm is omitted, it defaults to isspace.\n\nThe optional keyword arguments are:\n\nlimit: the maximum size of the result. limit=0 implies no maximum (default)\nkeepempty: whether empty fields should be kept in the result. Default is false without a dlm argument, true with a dlm argument.\n\nSee also rsplit.\n\nExamples\n\njulia> a = \"Ma.rch\"\n\"Ma.rch\"\n\njulia> split(a,\".\")\n2-element Array{SubString{String},1}:\n \"Ma\"\n \"rch\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.rsplit","page":"Strings","title":"Base.rsplit","text":"rsplit(s::AbstractString; limit::Integer=0, keepempty::Bool=false)\nrsplit(s::AbstractString, chars; limit::Integer=0, keepempty::Bool=true)\n\nSimilar to split, but starting from the end of the string.\n\nExamples\n\njulia> a = \"M.a.r.c.h\"\n\"M.a.r.c.h\"\n\njulia> rsplit(a,\".\")\n5-element Array{SubString{String},1}:\n \"M\"\n \"a\"\n \"r\"\n \"c\"\n \"h\"\n\njulia> rsplit(a,\".\";limit=1)\n1-element Array{SubString{String},1}:\n \"M.a.r.c.h\"\n\njulia> rsplit(a,\".\";limit=2)\n2-element Array{SubString{String},1}:\n \"M.a.r.c\"\n \"h\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.strip","page":"Strings","title":"Base.strip","text":"strip([pred=isspace,] str::AbstractString)\nstrip(str::AbstractString, chars)\n\nRemove leading and trailing characters from str, either those specified by chars or those for which the function pred returns true.\n\nThe default behaviour is to remove leading whitespace and delimiters: see isspace for precise details.\n\nThe optional chars argument specifies which characters to remove: it can be a single character, vector or set of characters.\n\ncompat: Julia 1.2\nThe method which accepts a predicate function requires Julia 1.2 or later.\n\nExamples\n\njulia> strip(\"{3, 5}\\n\", ['{', '}', '\\n'])\n\"3, 5\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.lstrip","page":"Strings","title":"Base.lstrip","text":"lstrip([pred=isspace,] str::AbstractString)\nlstrip(str::AbstractString, chars)\n\nRemove leading characters from str, either those specified by chars or those for which the function pred returns true.\n\nThe default behaviour is to remove leading whitespace and delimiters: see isspace for precise details.\n\nThe optional chars argument specifies which characters to remove: it can be a single character, or a vector or set of characters.\n\nExamples\n\njulia> a = lpad(\"March\", 20)\n\"               March\"\n\njulia> lstrip(a)\n\"March\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.rstrip","page":"Strings","title":"Base.rstrip","text":"rstrip([pred=isspace,] str::AbstractString)\nrstrip(str::AbstractString, chars)\n\nRemove trailing characters from str, either those specified by chars or those for which the function pred returns true.\n\nThe default behaviour is to remove trailing whitespace and delimiters: see isspace for precise details.\n\nThe optional chars argument specifies which characters to remove: it can be a single character, or a vector or set of characters.\n\nExamples\n\njulia> a = rpad(\"March\", 20)\n\"March               \"\n\njulia> rstrip(a)\n\"March\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.startswith","page":"Strings","title":"Base.startswith","text":"startswith(s::AbstractString, prefix::AbstractString)\n\nReturn true if s starts with prefix. If prefix is a vector or set of characters, test whether the first character of s belongs to that set.\n\nSee also endswith.\n\nExamples\n\njulia> startswith(\"JuliaLang\", \"Julia\")\ntrue\n\n\n\n\n\nstartswith(s::AbstractString, prefix::Regex)\n\nReturn true if s starts with the regex pattern, prefix.\n\nnote: Note\nstartswith does not compile the anchoring into the regular expression, but instead passes the anchoring as match_option to PCRE. If compile time is amortized, occursin(r\"^...\", s) is faster than startswith(s, r\"...\").\n\nSee also occursin and endswith.\n\ncompat: Julia 1.2\nThis method requires at least Julia 1.2.\n\nExamples\n\njulia> startswith(\"JuliaLang\", r\"Julia|Romeo\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.endswith","page":"Strings","title":"Base.endswith","text":"endswith(s::AbstractString, suffix::AbstractString)\n\nReturn true if s ends with suffix. If suffix is a vector or set of characters, test whether the last character of s belongs to that set.\n\nSee also startswith.\n\nExamples\n\njulia> endswith(\"Sunday\", \"day\")\ntrue\n\n\n\n\n\nendswith(s::AbstractString, suffix::Regex)\n\nReturn true if s ends with the regex pattern, suffix.\n\nnote: Note\nendswith does not compile the anchoring into the regular expression, but instead passes the anchoring as match_option to PCRE. If compile time is amortized, occursin(r\"...$\", s) is faster than endswith(s, r\"...\").\n\nSee also occursin and startswith.\n\ncompat: Julia 1.2\nThis method requires at least Julia 1.2.\n\nExamples\n\njulia> endswith(\"JuliaLang\", r\"Lang|Roberts\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.first-Tuple{AbstractString,Integer}","page":"Strings","title":"Base.first","text":"first(s::AbstractString, n::Integer)\n\nGet a string consisting of the first n characters of s.\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 1)\n\"∀\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 3)\n\"∀ϵ≠\"\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.last-Tuple{AbstractString,Integer}","page":"Strings","title":"Base.last","text":"last(s::AbstractString, n::Integer)\n\nGet a string consisting of the last n characters of s.\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 1)\n\"0\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 3)\n\"²>0\"\n\n\n\n\n\n","category":"method"},{"location":"base/strings.html#Base.Unicode.uppercase","page":"Strings","title":"Base.Unicode.uppercase","text":"uppercase(s::AbstractString)\n\nReturn s with all characters converted to uppercase.\n\nExamples\n\njulia> uppercase(\"Julia\")\n\"JULIA\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.lowercase","page":"Strings","title":"Base.Unicode.lowercase","text":"lowercase(s::AbstractString)\n\nReturn s with all characters converted to lowercase.\n\nExamples\n\njulia> lowercase(\"STRINGS AND THINGS\")\n\"strings and things\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.titlecase","page":"Strings","title":"Base.Unicode.titlecase","text":"titlecase(s::AbstractString; [wordsep::Function], strict::Bool=true) -> String\n\nCapitalize the first character of each word in s; if strict is true, every other character is converted to lowercase, otherwise they are left unchanged. By default, all non-letters are considered as word separators; a predicate can be passed as the wordsep keyword to determine which characters should be considered as word separators. See also uppercasefirst to capitalize only the first character in s.\n\nExamples\n\njulia> titlecase(\"the JULIA programming language\")\n\"The Julia Programming Language\"\n\njulia> titlecase(\"ISS - international space station\", strict=false)\n\"ISS - International Space Station\"\n\njulia> titlecase(\"a-a b-b\", wordsep = c->c==' ')\n\"A-a B-b\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.uppercasefirst","page":"Strings","title":"Base.Unicode.uppercasefirst","text":"uppercasefirst(s::AbstractString) -> String\n\nReturn s with the first character converted to uppercase (technically \"title case\" for Unicode). See also titlecase to capitalize the first character of every word in s.\n\nSee also: lowercasefirst, uppercase, lowercase, titlecase\n\nExamples\n\njulia> uppercasefirst(\"python\")\n\"Python\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.lowercasefirst","page":"Strings","title":"Base.Unicode.lowercasefirst","text":"lowercasefirst(s::AbstractString)\n\nReturn s with the first character converted to lowercase.\n\nSee also: uppercasefirst, uppercase, lowercase, titlecase\n\nExamples\n\njulia> lowercasefirst(\"Julia\")\n\"julia\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.join","page":"Strings","title":"Base.join","text":"join([io::IO,] strings, delim, [last])\n\nJoin an array of strings into a single string, inserting the given delimiter between adjacent strings. If last is given, it will be used instead of delim between the last two strings. If io is given, the result is written to io rather than returned as as a String.\n\nExamples\n\njulia> join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\n\"apples, bananas and pineapples\"\n\nstrings can be any iterable over elements x which are convertible to strings via print(io::IOBuffer, x). strings will be printed to io.\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.chop","page":"Strings","title":"Base.chop","text":"chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)\n\nRemove the first head and the last tail characters from s. The call chop(s) removes the last character from s. If it is requested to remove more characters than length(s) then an empty string is returned.\n\nExamples\n\njulia> a = \"March\"\n\"March\"\n\njulia> chop(a)\n\"Marc\"\n\njulia> chop(a, head = 1, tail = 2)\n\"ar\"\n\njulia> chop(a, head = 5, tail = 5)\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.chomp","page":"Strings","title":"Base.chomp","text":"chomp(s::AbstractString)\n\nRemove a single trailing newline from a string.\n\nExamples\n\njulia> chomp(\"Hello\\n\")\n\"Hello\"\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.thisind","page":"Strings","title":"Base.thisind","text":"thisind(s::AbstractString, i::Integer) -> Int\n\nIf i is in bounds in s return the index of the start of the character whose encoding code unit i is part of. In other words, if i is the start of a character, return i; if i is not the start of a character, rewind until the start of a character and return that index. If i is equal to 0 or ncodeunits(s)+1 return i. In all other cases throw BoundsError.\n\nExamples\n\njulia> thisind(\"α\", 0)\n0\n\njulia> thisind(\"α\", 1)\n1\n\njulia> thisind(\"α\", 2)\n1\n\njulia> thisind(\"α\", 3)\n3\n\njulia> thisind(\"α\", 4)\nERROR: BoundsError: attempt to access \"α\"\n  at index [4]\n[...]\n\njulia> thisind(\"α\", -1)\nERROR: BoundsError: attempt to access \"α\"\n  at index [-1]\n[...]\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.nextind","page":"Strings","title":"Base.nextind","text":"nextind(str::AbstractString, i::Integer, n::Integer=1) -> Int\n\nCase n == 1\nIf i is in bounds in s return the index of the start of the character whose encoding starts after index i. In other words, if i is the start of a character, return the start of the next character; if i is not the start of a character, move forward until the start of a character and return that index. If i is equal to 0 return 1. If i is in bounds but greater or equal to lastindex(str) return ncodeunits(str)+1. Otherwise throw BoundsError.\nCase n > 1\nBehaves like applying n times nextind for n==1. The only difference is that if n is so large that applying nextind would reach ncodeunits(str)+1 then each remaining iteration increases the returned value by 1. This means that in this case nextind can return a value greater than ncodeunits(str)+1.\nCase n == 0\nReturn i only if i is a valid index in s or is equal to 0. Otherwise StringIndexError or BoundsError is thrown.\n\nExamples\n\njulia> nextind(\"α\", 0)\n1\n\njulia> nextind(\"α\", 1)\n3\n\njulia> nextind(\"α\", 3)\nERROR: BoundsError: attempt to access \"α\"\n  at index [3]\n[...]\n\njulia> nextind(\"α\", 0, 2)\n3\n\njulia> nextind(\"α\", 1, 2)\n4\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.prevind","page":"Strings","title":"Base.prevind","text":"prevind(str::AbstractString, i::Integer, n::Integer=1) -> Int\n\nCase n == 1\nIf i is in bounds in s return the index of the start of the character whose encoding starts before index i. In other words, if i is the start of a character, return the start of the previous character; if i is not the start of a character, rewind until the start of a character and return that index. If i is equal to 1 return 0. If i is equal to ncodeunits(str)+1 return lastindex(str). Otherwise throw BoundsError.\nCase n > 1\nBehaves like applying n times prevind for n==1. The only difference is that if n is so large that applying prevind would reach 0 then each remaining iteration decreases the returned value by 1. This means that in this case prevind can return a negative value.\nCase n == 0\nReturn i only if i is a valid index in str or is equal to ncodeunits(str)+1. Otherwise StringIndexError or BoundsError is thrown.\n\nExamples\n\njulia> prevind(\"α\", 3)\n1\n\njulia> prevind(\"α\", 1)\n0\n\njulia> prevind(\"α\", 0)\nERROR: BoundsError: attempt to access \"α\"\n  at index [0]\n[...]\n\njulia> prevind(\"α\", 2, 2)\n0\n\njulia> prevind(\"α\", 2, 3)\n-1\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.textwidth","page":"Strings","title":"Base.Unicode.textwidth","text":"textwidth(c)\n\nGive the number of columns needed to print a character.\n\nExamples\n\njulia> textwidth('α')\n1\n\njulia> textwidth('⛵')\n2\n\n\n\n\n\ntextwidth(s::AbstractString)\n\nGive the number of columns needed to print a string.\n\nExamples\n\njulia> textwidth(\"March\")\n5\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.isascii","page":"Strings","title":"Base.isascii","text":"isascii(c::Union{AbstractChar,AbstractString}) -> Bool\n\nTest whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.\n\nExamples\n\njulia> isascii('a')\ntrue\n\njulia> isascii('α')\nfalse\n\njulia> isascii(\"abc\")\ntrue\n\njulia> isascii(\"αβγ\")\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.iscntrl","page":"Strings","title":"Base.Unicode.iscntrl","text":"iscntrl(c::AbstractChar) -> Bool\n\nTests whether a character is a control character. Control characters are the non-printing characters of the Latin-1 subset of Unicode.\n\nExamples\n\njulia> iscntrl('\\x01')\ntrue\n\njulia> iscntrl('a')\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.isdigit","page":"Strings","title":"Base.Unicode.isdigit","text":"isdigit(c::AbstractChar) -> Bool\n\nTests whether a character is a decimal digit (0-9).\n\nExamples\n\njulia> isdigit('❤')\nfalse\n\njulia> isdigit('9')\ntrue\n\njulia> isdigit('α')\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.isletter","page":"Strings","title":"Base.Unicode.isletter","text":"isletter(c::AbstractChar) -> Bool\n\nTest whether a character is a letter. A character is classified as a letter if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with 'L'.\n\nExamples\n\njulia> isletter('❤')\nfalse\n\njulia> isletter('α')\ntrue\n\njulia> isletter('9')\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.islowercase","page":"Strings","title":"Base.Unicode.islowercase","text":"islowercase(c::AbstractChar) -> Bool\n\nTests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.\n\nExamples\n\njulia> islowercase('α')\ntrue\n\njulia> islowercase('Γ')\nfalse\n\njulia> islowercase('❤')\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.isnumeric","page":"Strings","title":"Base.Unicode.isnumeric","text":"isnumeric(c::AbstractChar) -> Bool\n\nTests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with 'N'.\n\nNote that this broad category includes characters such as ¾ and ௰. Use isdigit to check whether a character a decimal digit between 0 and 9.\n\nExamples\n\njulia> isnumeric('௰')\ntrue\n\njulia> isnumeric('9')\ntrue\n\njulia> isnumeric('α')\nfalse\n\njulia> isnumeric('❤')\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.isprint","page":"Strings","title":"Base.Unicode.isprint","text":"isprint(c::AbstractChar) -> Bool\n\nTests whether a character is printable, including spaces, but not a control character.\n\nExamples\n\njulia> isprint('\\x01')\nfalse\n\njulia> isprint('A')\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.ispunct","page":"Strings","title":"Base.Unicode.ispunct","text":"ispunct(c::AbstractChar) -> Bool\n\nTests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with 'P'.\n\nExamples\n\njulia> ispunct('α')\nfalse\n\njulia> ispunct('/')\ntrue\n\njulia> ispunct(';')\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.isspace","page":"Strings","title":"Base.Unicode.isspace","text":"isspace(c::AbstractChar) -> Bool\n\nTests whether a character is any whitespace character. Includes ASCII characters '\\t', '\\n', '\\v', '\\f', '\\r', and ' ', Latin-1 character U+0085, and characters in Unicode category Zs.\n\nExamples\n\njulia> isspace('\\n')\ntrue\n\njulia> isspace('\\r')\ntrue\n\njulia> isspace(' ')\ntrue\n\njulia> isspace('\\x20')\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.isuppercase","page":"Strings","title":"Base.Unicode.isuppercase","text":"isuppercase(c::AbstractChar) -> Bool\n\nTests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.\n\nExamples\n\njulia> isuppercase('γ')\nfalse\n\njulia> isuppercase('Γ')\ntrue\n\njulia> isuppercase('❤')\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.Unicode.isxdigit","page":"Strings","title":"Base.Unicode.isxdigit","text":"isxdigit(c::AbstractChar) -> Bool\n\nTest whether a character is a valid hexadecimal digit. Note that this does not include x (as in the standard 0x prefix).\n\nExamples\n\njulia> isxdigit('a')\ntrue\n\njulia> isxdigit('x')\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.escape_string","page":"Strings","title":"Base.escape_string","text":"escape_string(str::AbstractString[, esc])::AbstractString\nescape_string(io, str::AbstractString[, esc::])::Nothing\n\nGeneral escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to io.\n\nBackslashes (\\) are escaped with a double-backslash (\"\\\\\"). Non-printable characters are escaped either with their standard C escape codes, \"\\0\" for NUL (if unambiguous), unicode code point (\"\\u\" prefix) or hex (\"\\x\" prefix).\n\nThe optional esc argument specifies any additional characters that should also be escaped by a prepending backslash (\" is also escaped by default in the first form).\n\nExamples\n\njulia> escape_string(\"aaa\\nbbb\")\n\"aaa\\\\nbbb\"\n\njulia> escape_string(\"\\xfe\\xff\") # invalid utf-8\n\"\\\\xfe\\\\xff\"\n\njulia> escape_string(string('\\u2135','\\0')) # unambiguous\n\"ℵ\\\\0\"\n\njulia> escape_string(string('\\u2135','\\0','0')) # \\0 would be ambiguous\n\"ℵ\\\\x000\"\n\nSee also\n\nunescape_string for the reverse operation.\n\n\n\n\n\n","category":"function"},{"location":"base/strings.html#Base.unescape_string","page":"Strings","title":"Base.unescape_string","text":"unescape_string(str::AbstractString)::AbstractString\nunescape_string(io, str::AbstractString)::Nothing\n\nGeneral unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to io.\n\nThe following escape sequences are recognised:\n\nEscaped backslash (\\\\)\nEscaped double-quote (\\\")\nStandard C escape sequences (\\a, \\b, \\t, \\n, \\v, \\f, \\r, \\e)\nUnicode code points (\\u or \\U prefixes with 1-4 trailing hex digits)\nHex bytes (\\x with 1-2 trailing hex digits)\nOctal bytes (\\ with 1-3 trailing octal digits)\n\nExamples\n\njulia> unescape_string(\"aaa\\\\nbbb\") # C escape sequence\n\"aaa\\nbbb\"\n\njulia> unescape_string(\"\\\\u03c0\") # unicode\n\"π\"\n\njulia> unescape_string(\"\\\\101\") # octal\n\"A\"\n\nSee also\n\nescape_string.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#lib-arrays-1","page":"Arrays","title":"Arrays","text":"","category":"section"},{"location":"base/arrays.html#Constructors-and-Types-1","page":"Arrays","title":"Constructors and Types","text":"","category":"section"},{"location":"base/arrays.html#","page":"Arrays","title":"Arrays","text":"Core.AbstractArray\nBase.AbstractVector\nBase.AbstractMatrix\nBase.AbstractVecOrMat\nCore.Array\nCore.Array(::UndefInitializer, ::Any)\nCore.Array(::Nothing, ::Any)\nCore.Array(::Missing, ::Any)\nCore.UndefInitializer\nCore.undef\nBase.Vector\nBase.Vector(::UndefInitializer, ::Any)\nBase.Vector(::Nothing, ::Any)\nBase.Vector(::Missing, ::Any)\nBase.Matrix\nBase.Matrix(::UndefInitializer, ::Any, ::Any)\nBase.Matrix(::Nothing, ::Any, ::Any)\nBase.Matrix(::Missing, ::Any, ::Any)\nBase.VecOrMat\nCore.DenseArray\nBase.DenseVector\nBase.DenseMatrix\nBase.DenseVecOrMat\nBase.StridedArray\nBase.StridedVector\nBase.StridedMatrix\nBase.StridedVecOrMat\nBase.getindex(::Type, ::Any...)\nBase.zeros\nBase.ones\nBase.BitArray\nBase.BitArray(::UndefInitializer, ::Integer...)\nBase.BitArray(::Any)\nBase.trues\nBase.falses\nBase.fill\nBase.fill!\nBase.similar","category":"page"},{"location":"base/arrays.html#Core.AbstractArray","page":"Arrays","title":"Core.AbstractArray","text":"AbstractArray{T,N}\n\nSupertype for N-dimensional arrays (or array-like types) with elements of type T. Array and other types are subtypes of this. See the manual section on the AbstractArray interface.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.AbstractVector","page":"Arrays","title":"Base.AbstractVector","text":"AbstractVector{T}\n\nSupertype for one-dimensional arrays (or array-like types) with elements of type T. Alias for AbstractArray{T,1}.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.AbstractMatrix","page":"Arrays","title":"Base.AbstractMatrix","text":"AbstractMatrix{T}\n\nSupertype for two-dimensional arrays (or array-like types) with elements of type T. Alias for AbstractArray{T,2}.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.AbstractVecOrMat","page":"Arrays","title":"Base.AbstractVecOrMat","text":"AbstractVecOrMat{T}\n\nUnion type of AbstractVector{T} and AbstractMatrix{T}.\n\n\n\n\n\n","category":"constant"},{"location":"base/arrays.html#Core.Array","page":"Arrays","title":"Core.Array","text":"Array{T,N} <: AbstractArray{T,N}\n\nN-dimensional dense array with elements of type T.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Core.Array-Tuple{UndefInitializer,Any}","page":"Arrays","title":"Core.Array","text":"Array{T}(undef, dims)\nArray{T,N}(undef, dims)\n\nConstruct an uninitialized N-dimensional Array containing elements of type T. N can either be supplied explicitly, as in Array{T,N}(undef, dims), or be determined by the length or number of dims. dims may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank N is supplied explicitly, then it must match the length or number of dims. See undef.\n\nExamples\n\njulia> A = Array{Float64,2}(undef, 2, 3) # N given explicitly\n2×3 Array{Float64,2}:\n 6.90198e-310  6.90198e-310  6.90198e-310\n 6.90198e-310  6.90198e-310  0.0\n\njulia> B = Array{Float64}(undef, 2) # N determined by the input\n2-element Array{Float64,1}:\n 1.87103e-320\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Core.Array-Tuple{Nothing,Any}","page":"Arrays","title":"Core.Array","text":"Array{T}(nothing, dims)\nArray{T,N}(nothing, dims)\n\nConstruct an N-dimensional Array containing elements of type T, initialized with nothing entries. Element type T must be able to hold these values, i.e. Nothing <: T.\n\nExamples\n\njulia> Array{Union{Nothing, String}}(nothing, 2)\n2-element Array{Union{Nothing, String},1}:\n nothing\n nothing\n\njulia> Array{Union{Nothing, Int}}(nothing, 2, 3)\n2×3 Array{Union{Nothing, Int64},2}:\n nothing  nothing  nothing\n nothing  nothing  nothing\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Core.Array-Tuple{Missing,Any}","page":"Arrays","title":"Core.Array","text":"Array{T}(missing, dims)\nArray{T,N}(missing, dims)\n\nConstruct an N-dimensional Array containing elements of type T, initialized with missing entries. Element type T must be able to hold these values, i.e. Missing <: T.\n\nExamples\n\njulia> Array{Union{Missing, String}}(missing, 2)\n2-element Array{Union{Missing, String},1}:\n missing\n missing\n\njulia> Array{Union{Missing, Int}}(missing, 2, 3)\n2×3 Array{Union{Missing, Int64},2}:\n missing  missing  missing\n missing  missing  missing\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Core.UndefInitializer","page":"Arrays","title":"Core.UndefInitializer","text":"UndefInitializer\n\nSingleton type used in array initialization, indicating the array-constructor-caller would like an uninitialized array. See also undef, an alias for UndefInitializer().\n\nExamples\n\njulia> Array{Float64,1}(UndefInitializer(), 3)\n3-element Array{Float64,1}:\n 2.2752528595e-314\n 2.202942107e-314\n 2.275252907e-314\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Core.undef","page":"Arrays","title":"Core.undef","text":"undef\n\nAlias for UndefInitializer(), which constructs an instance of the singleton type UndefInitializer, used in array initialization to indicate the array-constructor-caller would like an uninitialized array.\n\nExamples\n\njulia> Array{Float64,1}(undef, 3)\n3-element Array{Float64,1}:\n 2.2752528595e-314\n 2.202942107e-314\n 2.275252907e-314\n\n\n\n\n\n","category":"constant"},{"location":"base/arrays.html#Base.Vector","page":"Arrays","title":"Base.Vector","text":"Vector{T} <: AbstractVector{T}\n\nOne-dimensional dense array with elements of type T, often used to represent a mathematical vector. Alias for Array{T,1}.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.Vector-Tuple{UndefInitializer,Any}","page":"Arrays","title":"Base.Vector","text":"Vector{T}(undef, n)\n\nConstruct an uninitialized Vector{T} of length n. See undef.\n\nExamples\n\njulia> Vector{Float64}(undef, 3)\n3-element Array{Float64,1}:\n 6.90966e-310\n 6.90966e-310\n 6.90966e-310\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.Vector-Tuple{Nothing,Any}","page":"Arrays","title":"Base.Vector","text":"Vector{T}(nothing, m)\n\nConstruct a Vector{T} of length m, initialized with nothing entries. Element type T must be able to hold these values, i.e. Nothing <: T.\n\nExamples\n\njulia> Vector{Union{Nothing, String}}(nothing, 2)\n2-element Array{Union{Nothing, String},1}:\n nothing\n nothing\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.Vector-Tuple{Missing,Any}","page":"Arrays","title":"Base.Vector","text":"Vector{T}(missing, m)\n\nConstruct a Vector{T} of length m, initialized with missing entries. Element type T must be able to hold these values, i.e. Missing <: T.\n\nExamples\n\njulia> Vector{Union{Missing, String}}(missing, 2)\n2-element Array{Union{Missing, String},1}:\n missing\n missing\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.Matrix","page":"Arrays","title":"Base.Matrix","text":"Matrix{T} <: AbstractMatrix{T}\n\nTwo-dimensional dense array with elements of type T, often used to represent a mathematical matrix. Alias for Array{T,2}.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.Matrix-Tuple{UndefInitializer,Any,Any}","page":"Arrays","title":"Base.Matrix","text":"Matrix{T}(undef, m, n)\n\nConstruct an uninitialized Matrix{T} of size m×n. See undef.\n\nExamples\n\njulia> Matrix{Float64}(undef, 2, 3)\n2×3 Array{Float64,2}:\n 6.93517e-310  6.93517e-310  6.93517e-310\n 6.93517e-310  6.93517e-310  1.29396e-320\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.Matrix-Tuple{Nothing,Any,Any}","page":"Arrays","title":"Base.Matrix","text":"Matrix{T}(nothing, m, n)\n\nConstruct a Matrix{T} of size m×n, initialized with nothing entries. Element type T must be able to hold these values, i.e. Nothing <: T.\n\nExamples\n\njulia> Matrix{Union{Nothing, String}}(nothing, 2, 3)\n2×3 Array{Union{Nothing, String},2}:\n nothing  nothing  nothing\n nothing  nothing  nothing\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.Matrix-Tuple{Missing,Any,Any}","page":"Arrays","title":"Base.Matrix","text":"Matrix{T}(missing, m, n)\n\nConstruct a Matrix{T} of size m×n, initialized with missing entries. Element type T must be able to hold these values, i.e. Missing <: T.\n\nExamples\n\njulia> Matrix{Union{Missing, String}}(missing, 2, 3)\n2×3 Array{Union{Missing, String},2}:\n missing  missing  missing\n missing  missing  missing\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.VecOrMat","page":"Arrays","title":"Base.VecOrMat","text":"VecOrMat{T}\n\nUnion type of Vector{T} and Matrix{T}.\n\n\n\n\n\n","category":"constant"},{"location":"base/arrays.html#Core.DenseArray","page":"Arrays","title":"Core.DenseArray","text":"DenseArray{T, N} <: AbstractArray{T,N}\n\nN-dimensional dense array with elements of type T. The elements of a dense array are stored contiguously in memory.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.DenseVector","page":"Arrays","title":"Base.DenseVector","text":"DenseVector{T}\n\nOne-dimensional DenseArray with elements of type T. Alias for DenseArray{T,1}.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.DenseMatrix","page":"Arrays","title":"Base.DenseMatrix","text":"DenseMatrix{T}\n\nTwo-dimensional DenseArray with elements of type T. Alias for DenseArray{T,2}.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.DenseVecOrMat","page":"Arrays","title":"Base.DenseVecOrMat","text":"DenseVecOrMat{T}\n\nUnion type of DenseVector{T} and DenseMatrix{T}.\n\n\n\n\n\n","category":"constant"},{"location":"base/arrays.html#Base.StridedArray","page":"Arrays","title":"Base.StridedArray","text":"StridedArray{T, N}\n\nAn N dimensional strided array with elements of type T. These arrays follow the strided array interface. If A is a StridedArray, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, A could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing A along dimension d jumps in memory by [strides(A, d)] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.\n\n\n\n\n\n","category":"constant"},{"location":"base/arrays.html#Base.StridedVector","page":"Arrays","title":"Base.StridedVector","text":"StridedVector{T}\n\nOne dimensional StridedArray with elements of type T.\n\n\n\n\n\n","category":"constant"},{"location":"base/arrays.html#Base.StridedMatrix","page":"Arrays","title":"Base.StridedMatrix","text":"StridedMatrix{T}\n\nTwo dimensional StridedArray with elements of type T.\n\n\n\n\n\n","category":"constant"},{"location":"base/arrays.html#Base.StridedVecOrMat","page":"Arrays","title":"Base.StridedVecOrMat","text":"StridedVecOrMat{T}\n\nUnion type of StridedVector and StridedMatrix with elements of type T.\n\n\n\n\n\n","category":"constant"},{"location":"base/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}","page":"Arrays","title":"Base.getindex","text":"getindex(type[, elements...])\n\nConstruct a 1-d array of the specified type. This is usually called with the syntax Type[]. Element values can be specified using Type[a,b,c,...].\n\nExamples\n\njulia> Int8[1, 2, 3]\n3-element Array{Int8,1}:\n 1\n 2\n 3\n\njulia> getindex(Int8, 1, 2, 3)\n3-element Array{Int8,1}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.zeros","page":"Arrays","title":"Base.zeros","text":"zeros([T=Float64,] dims...)\n\nCreate an Array, with element type T, of all zeros with size specified by dims. See also fill, ones.\n\nExamples\n\njulia> zeros(1)\n1-element Array{Float64,1}:\n 0.0\n\njulia> zeros(Int8, 2, 3)\n2×3 Array{Int8,2}:\n 0  0  0\n 0  0  0\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.ones","page":"Arrays","title":"Base.ones","text":"ones([T=Float64,] dims...)\n\nCreate an Array, with element type T, of all ones with size specified by dims. See also: fill, zeros.\n\nExamples\n\njulia> ones(1,2)\n1×2 Array{Float64,2}:\n 1.0  1.0\n\njulia> ones(ComplexF64, 2, 3)\n2×3 Array{Complex{Float64},2}:\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.BitArray","page":"Arrays","title":"Base.BitArray","text":"BitArray{N} <: AbstractArray{Bool, N}\n\nSpace-efficient N-dimensional boolean array, using just one bit for each boolean value.\n\nBitArrays pack up to 64 values into every 8 bytes, resulting in an 8x space efficiency over Array{Bool, N} and allowing some operations to work on 64 values at once.\n\nBy default, Julia returns BitArrays from broadcasting operations that generate boolean elements (including dotted-comparisons like .==) as well as from the functions trues and falses.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.BitArray-Tuple{UndefInitializer,Vararg{Integer,N} where N}","page":"Arrays","title":"Base.BitArray","text":"BitArray(undef, dims::Integer...)\nBitArray{N}(undef, dims::NTuple{N,Int})\n\nConstruct an undef BitArray with the given dimensions. Behaves identically to the Array constructor. See undef.\n\nExamples\n\njulia> BitArray(undef, 2, 2)\n2×2 BitArray{2}:\n false  false\n false  true\n\njulia> BitArray(undef, (3, 1))\n3×1 BitArray{2}:\n false\n true\n false\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.BitArray-Tuple{Any}","page":"Arrays","title":"Base.BitArray","text":"BitArray(itr)\n\nConstruct a BitArray generated by the given iterable object. The shape is inferred from the itr object.\n\nExamples\n\njulia> BitArray([1 0; 0 1])\n2×2 BitArray{2}:\n 1  0\n 0  1\n\njulia> BitArray(x+y == 3 for x = 1:2, y = 1:3)\n2×3 BitArray{2}:\n 0  1  0\n 1  0  0\n\njulia> BitArray(x+y == 3 for x = 1:2 for y = 1:3)\n6-element BitArray{1}:\n 0\n 1\n 0\n 1\n 0\n 0\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.trues","page":"Arrays","title":"Base.trues","text":"trues(dims)\n\nCreate a BitArray with all values set to true.\n\nExamples\n\njulia> trues(2,3)\n2×3 BitArray{2}:\n 1  1  1\n 1  1  1\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.falses","page":"Arrays","title":"Base.falses","text":"falses(dims)\n\nCreate a BitArray with all values set to false.\n\nExamples\n\njulia> falses(2,3)\n2×3 BitArray{2}:\n 0  0  0\n 0  0  0\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.fill","page":"Arrays","title":"Base.fill","text":"fill(x, dims)\n\nCreate an array filled with the value x. For example, fill(1.0, (5,5)) returns a 5×5 array of floats, with each element initialized to 1.0.\n\nExamples\n\njulia> fill(1.0, (5,5))\n5×5 Array{Float64,2}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n\nIf x is an object reference, all elements will refer to the same object. fill(Foo(), dims) will return an array filled with the result of evaluating Foo() once.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.fill!","page":"Arrays","title":"Base.fill!","text":"fill!(A, x)\n\nFill array A with the value x. If x is an object reference, all elements will refer to the same object. fill!(A, Foo()) will return A filled with the result of evaluating Foo() once.\n\nExamples\n\njulia> A = zeros(2,3)\n2×3 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> fill!(A, 2.)\n2×3 Array{Float64,2}:\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n\njulia> a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(undef, 3), a); a[1] = 2; A\n3-element Array{Array{Int64,1},1}:\n [2, 1, 1]\n [2, 1, 1]\n [2, 1, 1]\n\njulia> x = 0; f() = (global x += 1; x); fill!(Vector{Int}(undef, 3), f())\n3-element Array{Int64,1}:\n 1\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.similar","page":"Arrays","title":"Base.similar","text":"similar(array, [element_type=eltype(array)], [dims=size(array)])\n\nCreate an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array's eltype and size. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.\n\nCustom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an Array{element_type}(undef, dims...).\n\nFor example, similar(1:10, 1, 4) returns an uninitialized Array{Int,2} since ranges are neither mutable nor support 2 dimensions:\n\njulia> similar(1:10, 1, 4)\n1×4 Array{Int64,2}:\n 4419743872  4374413872  4419743888  0\n\nConversely, similar(trues(10,10), 2) returns an uninitialized BitVector with two elements since BitArrays are both mutable and can support 1-dimensional arrays:\n\njulia> similar(trues(10,10), 2)\n2-element BitArray{1}:\n 0\n 0\n\nSince BitArrays can only store elements of type Bool, however, if you request a different element type it will create a regular Array instead:\n\njulia> similar(falses(10), Float64, 2, 4)\n2×4 Array{Float64,2}:\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n\n\n\n\n\nsimilar(storagetype, axes)\n\nCreate an uninitialized mutable array analogous to that specified by storagetype, but with axes specified by the last argument. storagetype might be a type or a function.\n\nExamples:\n\nsimilar(Array{Int}, axes(A))\n\ncreates an array that \"acts like\" an Array{Int} (and might indeed be backed by one), but which is indexed identically to A. If A has conventional indexing, this will be identical to Array{Int}(undef, size(A)), but if A has unconventional indexing then the indices of the result will match A.\n\nsimilar(BitArray, (axes(A, 2),))\n\nwould create a 1-dimensional logical array whose indices match those of the columns of A.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Basic-functions-1","page":"Arrays","title":"Basic functions","text":"","category":"section"},{"location":"base/arrays.html#","page":"Arrays","title":"Arrays","text":"Base.ndims\nBase.size\nBase.axes(::Any)\nBase.axes(::AbstractArray, ::Any)\nBase.length(::AbstractArray)\nBase.eachindex\nBase.IndexStyle\nBase.IndexLinear\nBase.IndexCartesian\nBase.conj!\nBase.stride\nBase.strides","category":"page"},{"location":"base/arrays.html#Base.ndims","page":"Arrays","title":"Base.ndims","text":"ndims(A::AbstractArray) -> Integer\n\nReturn the number of dimensions of A.\n\nExamples\n\njulia> A = fill(1, (3,4,5));\n\njulia> ndims(A)\n3\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.size","page":"Arrays","title":"Base.size","text":"size(A::AbstractArray, [dim])\n\nReturn a tuple containing the dimensions of A. Optionally you can specify a dimension to just get the length of that dimension.\n\nNote that size may not be defined for arrays with non-standard indices, in which case axes may be useful. See the manual chapter on arrays with custom indices.\n\nExamples\n\njulia> A = fill(1, (2,3,4));\n\njulia> size(A)\n(2, 3, 4)\n\njulia> size(A, 2)\n3\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.axes-Tuple{Any}","page":"Arrays","title":"Base.axes","text":"axes(A)\n\nReturn the tuple of valid indices for array A.\n\nExamples\n\njulia> A = fill(1, (5,6,7));\n\njulia> axes(A)\n(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.axes-Tuple{AbstractArray,Any}","page":"Arrays","title":"Base.axes","text":"axes(A, d)\n\nReturn the valid range of indices for array A along dimension d.\n\nSee also size, and the manual chapter on arrays with custom indices.\n\nExamples\n\njulia> A = fill(1, (5,6,7));\n\njulia> axes(A, 2)\nBase.OneTo(6)\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.length-Tuple{AbstractArray}","page":"Arrays","title":"Base.length","text":"length(A::AbstractArray)\n\nReturn the number of elements in the array, defaults to prod(size(A)).\n\nExamples\n\njulia> length([1, 2, 3, 4])\n4\n\njulia> length([1 2; 3 4])\n4\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.eachindex","page":"Arrays","title":"Base.eachindex","text":"eachindex(A...)\n\nCreate an iterable object for visiting each index of an AbstractArray A in an efficient manner. For array types that have opted into fast linear indexing (like Array), this is simply the range 1:length(A). For other array types, return a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, return an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).\n\nIf you supply more than one AbstractArray argument, eachindex will create an iterable object that is fast for all arguments (a UnitRange if all inputs have fast linear indexing, a CartesianIndices otherwise). If the arrays have different sizes and/or dimensionalities, eachindex will return an iterable that spans the largest range along each dimension.\n\nExamples\n\njulia> A = [1 2; 3 4];\n\njulia> for i in eachindex(A) # linear indexing\n           println(i)\n       end\n1\n2\n3\n4\n\njulia> for i in eachindex(view(A, 1:2, 1:1)) # Cartesian indexing\n           println(i)\n       end\nCartesianIndex(1, 1)\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.IndexStyle","page":"Arrays","title":"Base.IndexStyle","text":"IndexStyle(A)\nIndexStyle(typeof(A))\n\nIndexStyle specifies the \"native indexing style\" for array A. When you define a new AbstractArray type, you can choose to implement either linear indexing (with IndexLinear) or cartesian indexing. If you decide to implement linear indexing, then you must set this trait for your array type:\n\nBase.IndexStyle(::Type{<:MyArray}) = IndexLinear()\n\nThe default is IndexCartesian().\n\nJulia's internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.\n\nIf you define both styles of indexing for your AbstractArray, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, eachindex creates an iterator whose type depends on the setting of this trait.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.IndexLinear","page":"Arrays","title":"Base.IndexLinear","text":"IndexLinear()\n\nSubtype of IndexStyle used to describe arrays which are optimally indexed by one linear index.\n\nA linear indexing style uses one integer to describe the position in the array (even if it's a multidimensional array) and column-major ordering is used to access the elements. For example, if A were a (2, 3) custom matrix type with linear indexing, and we referenced A[5] (using linear style), this would be equivalent to referencing A[1, 3] (since 2*1 + 3 = 5). See also IndexCartesian.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.IndexCartesian","page":"Arrays","title":"Base.IndexCartesian","text":"IndexCartesian()\n\nSubtype of IndexStyle used to describe arrays which are optimally indexed by a Cartesian index.\n\nA cartesian indexing style uses multiple integers/indices to describe the position in the array. For example, if A were a (2, 3, 4) custom matrix type with cartesian indexing, we could reference A[2, 1, 3] and Julia would automatically convert this into the correct location in the underlying memory. See also IndexLinear.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.conj!","page":"Arrays","title":"Base.conj!","text":"conj!(A)\n\nTransform an array to its complex conjugate in-place.\n\nSee also conj.\n\nExamples\n\njulia> A = [1+im 2-im; 2+2im 3+im]\n2×2 Array{Complex{Int64},2}:\n 1+1im  2-1im\n 2+2im  3+1im\n\njulia> conj!(A);\n\njulia> A\n2×2 Array{Complex{Int64},2}:\n 1-1im  2+1im\n 2-2im  3-1im\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.stride","page":"Arrays","title":"Base.stride","text":"stride(A, k::Integer)\n\nReturn the distance in memory (in number of elements) between adjacent elements in dimension k.\n\nExamples\n\njulia> A = fill(1, (3,4,5));\n\njulia> stride(A,2)\n3\n\njulia> stride(A,3)\n12\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.strides","page":"Arrays","title":"Base.strides","text":"strides(A)\n\nReturn a tuple of the memory strides in each dimension.\n\nExamples\n\njulia> A = fill(1, (3,4,5));\n\njulia> strides(A)\n(1, 3, 12)\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Broadcast-and-vectorization-1","page":"Arrays","title":"Broadcast and vectorization","text":"","category":"section"},{"location":"base/arrays.html#","page":"Arrays","title":"Arrays","text":"See also the dot syntax for vectorizing functions; for example, f.(args...) implicitly calls broadcast(f, args...).  Rather than relying on \"vectorized\" methods of functions like sin to operate on arrays, you should use sin.(a) to vectorize via broadcast.","category":"page"},{"location":"base/arrays.html#","page":"Arrays","title":"Arrays","text":"Base.broadcast\nBase.Broadcast.broadcast!\nBase.@__dot__","category":"page"},{"location":"base/arrays.html#Base.Broadcast.broadcast","page":"Arrays","title":"Base.Broadcast.broadcast","text":"broadcast(f, As...)\n\nBroadcast the function f over the arrays, tuples, collections, Refs and/or scalars As.\n\nBroadcasting applies the function f over the elements of the container arguments and the scalars themselves in As. Singleton and missing dimensions are expanded to match the extents of the other arguments by virtually repeating the value. By default, only a limited number of types are considered scalars, including Numbers, Strings, Symbols, Types, Functions and some common singletons like missing and nothing. All other arguments are iterated over or indexed into elementwise.\n\nThe resulting container type is established by the following rules:\n\nIf all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.\nIf at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.\nAll other combinations of arguments default to returning an Array, but custom container types can define their own implementation and promotion-like rules to customize the result when they appear as arguments.\n\nA special syntax exists for broadcasting: f.(args...) is equivalent to broadcast(f, args...), and nested f.(g.(args...)) calls are fused into a single broadcast loop.\n\nExamples\n\njulia> A = [1, 2, 3, 4, 5]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> B = [1 2; 3 4; 5 6; 7 8; 9 10]\n5×2 Array{Int64,2}:\n 1   2\n 3   4\n 5   6\n 7   8\n 9  10\n\njulia> broadcast(+, A, B)\n5×2 Array{Int64,2}:\n  2   3\n  5   6\n  8   9\n 11  12\n 14  15\n\njulia> parse.(Int, [\"1\", \"2\"])\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> abs.((1, -2))\n(1, 2)\n\njulia> broadcast(+, 1.0, (0, -2.0))\n(1.0, -1.0)\n\njulia> (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))\n2-element Array{Array{Int64,1},1}:\n [1, 1]\n [2, 2]\n\njulia> string.((\"one\",\"two\",\"three\",\"four\"), \": \", 1:4)\n4-element Array{String,1}:\n \"one: 1\"\n \"two: 2\"\n \"three: 3\"\n \"four: 4\"\n\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.Broadcast.broadcast!","page":"Arrays","title":"Base.Broadcast.broadcast!","text":"broadcast!(f, dest, As...)\n\nLike broadcast, but store the result of broadcast(f, As...) in the dest array. Note that dest is only used to store the result, and does not supply arguments to f unless it is also listed in the As, as in broadcast!(f, A, A, B) to perform A[:] = broadcast(f, A, B).\n\nExamples\n\njulia> A = [1.0; 0.0]; B = [0.0; 0.0];\n\njulia> broadcast!(+, B, A, (0, -2.0));\n\njulia> B\n2-element Array{Float64,1}:\n  1.0\n -2.0\n\njulia> A\n2-element Array{Float64,1}:\n 1.0\n 0.0\n\njulia> broadcast!(+, A, A, (0, -2.0));\n\njulia> A\n2-element Array{Float64,1}:\n  1.0\n -2.0\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.Broadcast.@__dot__","page":"Arrays","title":"Base.Broadcast.@__dot__","text":"@. expr\n\nConvert every function call or operator in expr into a \"dot call\" (e.g. convert f(x) to f.(x)), and convert every assignment in expr to a \"dot assignment\" (e.g. convert += to .+=).\n\nIf you want to avoid adding dots for selected function calls in expr, splice those function calls in with $.  For example, @. sqrt(abs($sort(x))) is equivalent to sqrt.(abs.(sort(x))) (no dot for sort).\n\n(@. is equivalent to a call to @__dot__.)\n\nExamples\n\njulia> x = 1.0:3.0; y = similar(x);\n\njulia> @. y = x + 3 * sin(x)\n3-element Array{Float64,1}:\n 3.5244129544236893\n 4.727892280477045\n 3.4233600241796016\n\n\n\n\n\n","category":"macro"},{"location":"base/arrays.html#","page":"Arrays","title":"Arrays","text":"For specializing broadcast on custom types, see","category":"page"},{"location":"base/arrays.html#","page":"Arrays","title":"Arrays","text":"Base.BroadcastStyle\nBase.Broadcast.AbstractArrayStyle\nBase.Broadcast.ArrayStyle\nBase.Broadcast.DefaultArrayStyle\nBase.Broadcast.broadcastable\nBase.Broadcast.combine_axes\nBase.Broadcast.combine_styles\nBase.Broadcast.result_style","category":"page"},{"location":"base/arrays.html#Base.Broadcast.BroadcastStyle","page":"Arrays","title":"Base.Broadcast.BroadcastStyle","text":"BroadcastStyle is an abstract type and trait-function used to determine behavior of objects under broadcasting. BroadcastStyle(typeof(x)) returns the style associated with x. To customize the broadcasting behavior of a type, one can declare a style by defining a type/method pair\n\nstruct MyContainerStyle <: BroadcastStyle end\nBase.BroadcastStyle(::Type{<:MyContainer}) = MyContainerStyle()\n\nOne then writes method(s) (at least similar) operating on Broadcasted{MyContainerStyle}. There are also several pre-defined subtypes of BroadcastStyle that you may be able to leverage; see the Interfaces chapter for more information.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.Broadcast.AbstractArrayStyle","page":"Arrays","title":"Base.Broadcast.AbstractArrayStyle","text":"Broadcast.AbstractArrayStyle{N} <: BroadcastStyle is the abstract supertype for any style associated with an AbstractArray type. The N parameter is the dimensionality, which can be handy for AbstractArray types that only support specific dimensionalities:\n\nstruct SparseMatrixStyle <: Broadcast.AbstractArrayStyle{2} end\nBase.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatrixStyle()\n\nFor AbstractArray types that support arbitrary dimensionality, N can be set to Any:\n\nstruct MyArrayStyle <: Broadcast.AbstractArrayStyle{Any} end\nBase.BroadcastStyle(::Type{<:MyArray}) = MyArrayStyle()\n\nIn cases where you want to be able to mix multiple AbstractArrayStyles and keep track of dimensionality, your style needs to support a Val constructor:\n\nstruct MyArrayStyleDim{N} <: Broadcast.AbstractArrayStyle{N} end\n(::Type{<:MyArrayStyleDim})(::Val{N}) where N = MyArrayStyleDim{N}()\n\nNote that if two or more AbstractArrayStyle subtypes conflict, broadcasting machinery will fall back to producing Arrays. If this is undesirable, you may need to define binary BroadcastStyle rules to control the output type.\n\nSee also Broadcast.DefaultArrayStyle.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.Broadcast.ArrayStyle","page":"Arrays","title":"Base.Broadcast.ArrayStyle","text":"Broadcast.ArrayStyle{MyArrayType}() is a BroadcastStyle indicating that an object behaves as an array for broadcasting. It presents a simple way to construct Broadcast.AbstractArrayStyles for specific AbstractArray container types. Broadcast styles created this way lose track of dimensionality; if keeping track is important for your type, you should create your own custom Broadcast.AbstractArrayStyle.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.Broadcast.DefaultArrayStyle","page":"Arrays","title":"Base.Broadcast.DefaultArrayStyle","text":"Broadcast.DefaultArrayStyle{N}() is a BroadcastStyle indicating that an object behaves as an N-dimensional array for broadcasting. Specifically, DefaultArrayStyle is used for any AbstractArray type that hasn't defined a specialized style, and in the absence of overrides from other broadcast arguments the resulting output type is Array. When there are multiple inputs to broadcast, DefaultArrayStyle \"loses\" to any other Broadcast.ArrayStyle.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.Broadcast.broadcastable","page":"Arrays","title":"Base.Broadcast.broadcastable","text":"Broadcast.broadcastable(x)\n\nReturn either x or an object like x such that it supports axes, indexing, and its type supports ndims.\n\nIf x supports iteration, the returned value should have the same axes and indexing behaviors as collect(x).\n\nIf x is not an AbstractArray but it supports axes, indexing, and its type supports ndims, then broadcastable(::typeof(x)) may be implemented to just return itself. Further, if x defines its own BroadcastStyle, then it must define its broadcastable method to return itself for the custom style to have any effect.\n\nExamples\n\njulia> Broadcast.broadcastable([1,2,3]) # like `identity` since arrays already support axes and indexing\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> Broadcast.broadcastable(Int) # Types don't support axes, indexing, or iteration but are commonly used as scalars\nBase.RefValue{Type{Int64}}(Int64)\n\njulia> Broadcast.broadcastable(\"hello\") # Strings break convention of matching iteration and act like a scalar instead\nBase.RefValue{String}(\"hello\")\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.Broadcast.combine_axes","page":"Arrays","title":"Base.Broadcast.combine_axes","text":"combine_axes(As...) -> Tuple\n\nDetermine the result axes for broadcasting across all values in As.\n\njulia> Broadcast.combine_axes([1], [1 2; 3 4; 5 6])\n(Base.OneTo(3), Base.OneTo(2))\n\njulia> Broadcast.combine_axes(1, 1, 1)\n()\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.Broadcast.combine_styles","page":"Arrays","title":"Base.Broadcast.combine_styles","text":"combine_styles(cs...) -> BroadcastStyle\n\nDecides which BroadcastStyle to use for any number of value arguments. Uses BroadcastStyle to get the style for each argument, and uses result_style to combine styles.\n\nExamples\n\njulia> Broadcast.combine_styles([1], [1 2; 3 4])\nBase.Broadcast.DefaultArrayStyle{2}()\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.Broadcast.result_style","page":"Arrays","title":"Base.Broadcast.result_style","text":"result_style(s1::BroadcastStyle[, s2::BroadcastStyle]) -> BroadcastStyle\n\nTakes one or two BroadcastStyles and combines them using BroadcastStyle to determine a common BroadcastStyle.\n\nExamples\n\njulia> Broadcast.result_style(Broadcast.DefaultArrayStyle{0}(), Broadcast.DefaultArrayStyle{3}())\nBase.Broadcast.DefaultArrayStyle{3}()\n\njulia> Broadcast.result_style(Broadcast.Unknown(), Broadcast.DefaultArrayStyle{1}())\nBase.Broadcast.DefaultArrayStyle{1}()\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Indexing-and-assignment-1","page":"Arrays","title":"Indexing and assignment","text":"","category":"section"},{"location":"base/arrays.html#","page":"Arrays","title":"Arrays","text":"Base.getindex(::AbstractArray, ::Any...)\nBase.setindex!(::AbstractArray, ::Any, ::Any...)\nBase.copyto!(::AbstractArray, ::CartesianIndices, ::AbstractArray, ::CartesianIndices)\nBase.isassigned\nBase.Colon\nBase.CartesianIndex\nBase.CartesianIndices\nBase.Dims\nBase.LinearIndices\nBase.to_indices\nBase.checkbounds\nBase.checkindex","category":"page"},{"location":"base/arrays.html#Base.getindex-Tuple{AbstractArray,Vararg{Any,N} where N}","page":"Arrays","title":"Base.getindex","text":"getindex(A, inds...)\n\nReturn a subset of array A as specified by inds, where each ind may be an Int, an AbstractRange, or a Vector. See the manual section on array indexing for details.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> getindex(A, 1)\n1\n\njulia> getindex(A, [2, 1])\n2-element Array{Int64,1}:\n 3\n 1\n\njulia> getindex(A, 2:4)\n3-element Array{Int64,1}:\n 3\n 2\n 4\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}","page":"Arrays","title":"Base.setindex!","text":"setindex!(A, X, inds...)\nA[inds...] = X\n\nStore values from array X within some subset of A as specified by inds. The syntax A[inds...] = X is equivalent to setindex!(A, X, inds...).\n\nExamples\n\njulia> A = zeros(2,2);\n\njulia> setindex!(A, [10, 20], [1, 2]);\n\njulia> A[[3, 4]] = [30, 40];\n\njulia> A\n2×2 Array{Float64,2}:\n 10.0  30.0\n 20.0  40.0\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.copyto!-Tuple{AbstractArray,CartesianIndices,AbstractArray,CartesianIndices}","page":"Arrays","title":"Base.copyto!","text":"copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -> dest\n\nCopy the block of src in the range of Rsrc to the block of dest in the range of Rdest. The sizes of the two regions must match.\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.isassigned","page":"Arrays","title":"Base.isassigned","text":"isassigned(array, i) -> Bool\n\nTest whether the given array has a value associated with index i. Return false if the index is out of bounds, or has an undefined reference.\n\nExamples\n\njulia> isassigned(rand(3, 3), 5)\ntrue\n\njulia> isassigned(rand(3, 3), 3 * 3 + 1)\nfalse\n\njulia> mutable struct Foo end\n\njulia> v = similar(rand(3), Foo)\n3-element Array{Foo,1}:\n #undef\n #undef\n #undef\n\njulia> isassigned(v, 1)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.Colon","page":"Arrays","title":"Base.Colon","text":"Colon()\n\nColons (:) are used to signify indexing entire objects or dimensions at once.\n\nVery few operations are defined on Colons directly; instead they are converted by to_indices to an internal vector type (Base.Slice) to represent the collection of indices they span before being used.\n\nThe singleton instance of Colon is also a function used to construct ranges; see :.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.IteratorsMD.CartesianIndex","page":"Arrays","title":"Base.IteratorsMD.CartesianIndex","text":"CartesianIndex(i, j, k...)   -> I\nCartesianIndex((i, j, k...)) -> I\n\nCreate a multidimensional index I, which can be used for indexing a multidimensional array A.  In particular, A[I] is equivalent to A[i,j,k...].  One can freely mix integer and CartesianIndex indices; for example, A[Ipre, i, Ipost] (where Ipre and Ipost are CartesianIndex indices and i is an Int) can be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary dimensionality.\n\nA CartesianIndex is sometimes produced by eachindex, and always when iterating with an explicit CartesianIndices.\n\nExamples\n\njulia> A = reshape(Vector(1:16), (2, 2, 2, 2))\n2×2×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\n[:, :, 2, 1] =\n 5  7\n 6  8\n\n[:, :, 1, 2] =\n  9  11\n 10  12\n\n[:, :, 2, 2] =\n 13  15\n 14  16\n\njulia> A[CartesianIndex((1, 1, 1, 1))]\n1\n\njulia> A[CartesianIndex((1, 1, 1, 2))]\n9\n\njulia> A[CartesianIndex((1, 1, 2, 1))]\n5\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.IteratorsMD.CartesianIndices","page":"Arrays","title":"Base.IteratorsMD.CartesianIndices","text":"CartesianIndices(sz::Dims) -> R\nCartesianIndices((istart:istop, jstart:jstop, ...)) -> R\n\nDefine a region R spanning a multidimensional rectangular range of integer indices. These are most commonly encountered in the context of iteration, where for I in R ... end will return CartesianIndex indices I equivalent to the nested loops\n\nfor j = jstart:jstop\n    for i = istart:istop\n        ...\n    end\nend\n\nConsequently these can be useful for writing algorithms that work in arbitrary dimensions.\n\nCartesianIndices(A::AbstractArray) -> R\n\nAs a convenience, constructing a CartesianIndices from an array makes a range of its indices.\n\nExamples\n\njulia> foreach(println, CartesianIndices((2, 2, 2)))\nCartesianIndex(1, 1, 1)\nCartesianIndex(2, 1, 1)\nCartesianIndex(1, 2, 1)\nCartesianIndex(2, 2, 1)\nCartesianIndex(1, 1, 2)\nCartesianIndex(2, 1, 2)\nCartesianIndex(1, 2, 2)\nCartesianIndex(2, 2, 2)\n\njulia> CartesianIndices(fill(1, (2,3)))\n2×3 CartesianIndices{2,Tuple{Base.OneTo{Int64},Base.OneTo{Int64}}}:\n CartesianIndex(1, 1)  CartesianIndex(1, 2)  CartesianIndex(1, 3)\n CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)\n\nConversion between linear and cartesian indices\n\nLinear index to cartesian index conversion exploits the fact that a CartesianIndices is an AbstractArray and can be indexed linearly:\n\njulia> cartesian = CartesianIndices((1:3, 1:2))\n3×2 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:\n CartesianIndex(1, 1)  CartesianIndex(1, 2)\n CartesianIndex(2, 1)  CartesianIndex(2, 2)\n CartesianIndex(3, 1)  CartesianIndex(3, 2)\n\njulia> cartesian[4]\nCartesianIndex(1, 2)\n\nBroadcasting\n\nCartesianIndices support broadcasting arithmetic (+ and -) with a CartesianIndex.\n\ncompat: Julia 1.1\nBroadcasting of CartesianIndices requires at least Julia 1.1.\n\njulia> CIs = CartesianIndices((2:3, 5:6))\n2×2 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:\n CartesianIndex(2, 5)  CartesianIndex(2, 6)\n CartesianIndex(3, 5)  CartesianIndex(3, 6)\n\njulia> CI = CartesianIndex(3, 4)\nCartesianIndex(3, 4)\n\njulia> CIs .+ CI\n2×2 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:\n CartesianIndex(5, 9)  CartesianIndex(5, 10)\n CartesianIndex(6, 9)  CartesianIndex(6, 10)\n\nFor cartesian to linear index conversion, see LinearIndices.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.Dims","page":"Arrays","title":"Base.Dims","text":"Dims{N}\n\nAn NTuple of N Ints used to represent the dimensions of an AbstractArray.\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.LinearIndices","page":"Arrays","title":"Base.LinearIndices","text":"LinearIndices(A::AbstractArray)\n\nReturn a LinearIndices array with the same shape and axes as A, holding the linear index of each entry in A. Indexing this array with cartesian indices allows mapping them to linear indices.\n\nFor arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to length(A). However, for AbstractVectors linear indices are axes(A, 1), and therefore do not start at 1 for vectors with unconventional indexing.\n\nCalling this function is the \"safe\" way to write algorithms that exploit linear indexing.\n\nExamples\n\njulia> A = fill(1, (5,6,7));\n\njulia> b = LinearIndices(A);\n\njulia> extrema(b)\n(1, 210)\n\nLinearIndices(inds::CartesianIndices) -> R\nLinearIndices(sz::Dims) -> R\nLinearIndices((istart:istop, jstart:jstop, ...)) -> R\n\nReturn a LinearIndices array with the specified shape or axes.\n\nExample\n\nThe main purpose of this constructor is intuitive conversion from cartesian to linear indexing:\n\njulia> linear = LinearIndices((1:3, 1:2))\n3×2 LinearIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:\n 1  4\n 2  5\n 3  6\n\njulia> linear[1,2]\n4\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.to_indices","page":"Arrays","title":"Base.to_indices","text":"to_indices(A, I::Tuple)\n\nConvert the tuple I to a tuple of indices for use in indexing into array A.\n\nThe returned tuple must only contain either Ints or AbstractArrays of scalar indices that are supported by array A. It will error upon encountering a novel index type that it does not know how to process.\n\nFor simple index types, it defers to the unexported Base.to_index(A, i) to process each index i. While this internal function is not intended to be called directly, Base.to_index may be extended by custom array or index types to provide custom indexing behaviors.\n\nMore complicated index types may require more context about the dimension into which they index. To support those cases, to_indices(A, I) calls to_indices(A, axes(A), I), which then recursively walks through both the given tuple of indices and the dimensional indices of A in tandem. As such, not all index types are guaranteed to propagate to Base.to_index.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.checkbounds","page":"Arrays","title":"Base.checkbounds","text":"checkbounds(Bool, A, I...)\n\nReturn true if the specified indices I are in bounds for the given array A. Subtypes of AbstractArray should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on A's indices and checkindex.\n\nSee also checkindex.\n\nExamples\n\njulia> A = rand(3, 3);\n\njulia> checkbounds(Bool, A, 2)\ntrue\n\njulia> checkbounds(Bool, A, 3, 4)\nfalse\n\njulia> checkbounds(Bool, A, 1:3)\ntrue\n\njulia> checkbounds(Bool, A, 1:3, 2:4)\nfalse\n\n\n\n\n\ncheckbounds(A, I...)\n\nThrow an error if the specified indices I are not in bounds for the given array A.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.checkindex","page":"Arrays","title":"Base.checkindex","text":"checkindex(Bool, inds::AbstractUnitRange, index)\n\nReturn true if the given index is within the bounds of inds. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.\n\nExamples\n\njulia> checkindex(Bool, 1:20, 8)\ntrue\n\njulia> checkindex(Bool, 1:20, 21)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Views-(SubArrays-and-other-view-types)-1","page":"Arrays","title":"Views (SubArrays and other view types)","text":"","category":"section"},{"location":"base/arrays.html#","page":"Arrays","title":"Arrays","text":"Base.view\nBase.@view\nBase.@views\nBase.parent\nBase.parentindices\nBase.selectdim\nBase.reinterpret\nBase.reshape\nBase.dropdims\nBase.vec","category":"page"},{"location":"base/arrays.html#Base.view","page":"Arrays","title":"Base.view","text":"view(A, inds...)\n\nLike getindex, but returns a view into the parent array A with the given indices instead of making a copy.  Calling getindex or setindex! on the returned SubArray computes the indices to the parent array on the fly without checking bounds.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> b = view(A, :, 1)\n2-element view(::Array{Int64,2}, :, 1) with eltype Int64:\n 1\n 3\n\njulia> fill!(b, 0)\n2-element view(::Array{Int64,2}, :, 1) with eltype Int64:\n 0\n 0\n\njulia> A # Note A has changed even though we modified b\n2×2 Array{Int64,2}:\n 0  2\n 0  4\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.@view","page":"Arrays","title":"Base.@view","text":"@view A[inds...]\n\nCreates a SubArray from an indexing expression. This can only be applied directly to a reference expression (e.g. @view A[1,2:end]), and should not be used as the target of an assignment (e.g. @view(A[1,2:end]) = ...).  See also @views to switch an entire block of code to use views for slicing.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> b = @view A[:, 1]\n2-element view(::Array{Int64,2}, :, 1) with eltype Int64:\n 1\n 3\n\njulia> fill!(b, 0)\n2-element view(::Array{Int64,2}, :, 1) with eltype Int64:\n 0\n 0\n\njulia> A\n2×2 Array{Int64,2}:\n 0  2\n 0  4\n\n\n\n\n\n","category":"macro"},{"location":"base/arrays.html#Base.@views","page":"Arrays","title":"Base.@views","text":"@views expression\n\nConvert every array-slicing operation in the given expression (which may be a begin/end block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit getindex calls (as opposed to array[...]) are unaffected.\n\nnote: Note\nThe @views macro only affects array[...] expressions that appear explicitly in the given expression, not array slicing that occurs in functions called by that code.\n\nExamples\n\njulia> A = zeros(3, 3);\n\njulia> @views for row in 1:3\n           b = A[row, :]\n           b[:] .= row\n       end\n\njulia> A\n3×3 Array{Float64,2}:\n 1.0  1.0  1.0\n 2.0  2.0  2.0\n 3.0  3.0  3.0\n\n\n\n\n\n","category":"macro"},{"location":"base/arrays.html#Base.parent","page":"Arrays","title":"Base.parent","text":"parent(A)\n\nReturns the \"parent array\" of an array view type (e.g., SubArray), or the array itself if it is not a view.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> V = view(A, 1:2, :)\n2×2 view(::Array{Int64,2}, 1:2, :) with eltype Int64:\n 1  2\n 3  4\n\njulia> parent(V)\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.parentindices","page":"Arrays","title":"Base.parentindices","text":"parentindices(A)\n\nReturn the indices in the parent which correspond to the array view A.\n\nExamples\n\njulia> A = [1 2; 3 4];\n\njulia> V = view(A, 1, :)\n2-element view(::Array{Int64,2}, 1, :) with eltype Int64:\n 1\n 2\n\njulia> parentindices(V)\n(1, Base.Slice(Base.OneTo(2)))\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.selectdim","page":"Arrays","title":"Base.selectdim","text":"selectdim(A, d::Integer, i)\n\nReturn a view of all the data of A where the index for dimension d equals i.\n\nEquivalent to view(A,:,:,...,i,:,:,...) where i is in position d.\n\nExamples\n\njulia> A = [1 2 3 4; 5 6 7 8]\n2×4 Array{Int64,2}:\n 1  2  3  4\n 5  6  7  8\n\njulia> selectdim(A, 2, 3)\n2-element view(::Array{Int64,2}, :, 3) with eltype Int64:\n 3\n 7\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.reinterpret","page":"Arrays","title":"Base.reinterpret","text":"reinterpret(type, A)\n\nChange the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, reinterpret(Float32, UInt32(7)) interprets the 4 bytes corresponding to UInt32(7) as a Float32.\n\nExamples\n\njulia> reinterpret(Float32, UInt32(7))\n1.0f-44\n\njulia> reinterpret(Float32, UInt32[1 2 3 4 5])\n1×5 reinterpret(Float32, ::Array{UInt32,2}):\n 1.4013e-45  2.8026e-45  4.2039e-45  5.60519e-45  7.00649e-45\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.reshape","page":"Arrays","title":"Base.reshape","text":"reshape(A, dims...) -> AbstractArray\nreshape(A, dims) -> AbstractArray\n\nReturn an array with the same data as A, but with different dimension sizes or number of dimensions. The two arrays share the same underlying data, so that the result is mutable if and only if A is mutable, and setting elements of one alters the values of the other.\n\nThe new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a :, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array A. The total number of elements must not change.\n\nExamples\n\njulia> A = Vector(1:16)\n16-element Array{Int64,1}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n\njulia> reshape(A, (4, 4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> reshape(A, 2, :)\n2×8 Array{Int64,2}:\n 1  3  5  7   9  11  13  15\n 2  4  6  8  10  12  14  16\n\njulia> reshape(1:6, 2, 3)\n2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:\n 1  3  5\n 2  4  6\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.dropdims","page":"Arrays","title":"Base.dropdims","text":"dropdims(A; dims)\n\nRemove the dimensions specified by dims from array A. Elements of dims must be unique and within the range 1:ndims(A). size(A,i) must equal 1 for all i in dims.\n\nExamples\n\njulia> a = reshape(Vector(1:4),(2,2,1,1))\n2×2×1×1 Array{Int64,4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\njulia> dropdims(a; dims=3)\n2×2×1 Array{Int64,3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.vec","page":"Arrays","title":"Base.vec","text":"vec(a::AbstractArray) -> AbstractVector\n\nReshape the array a as a one-dimensional column vector. Return a if it is already an AbstractVector. The resulting array shares the same underlying data as a, so it will only be mutable if a is mutable, in which case modifying one will also modify the other.\n\nExamples\n\njulia> a = [1 2 3; 4 5 6]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> vec(a)\n6-element Array{Int64,1}:\n 1\n 4\n 2\n 5\n 3\n 6\n\njulia> vec(1:3)\n1:3\n\nSee also reshape.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Concatenation-and-permutation-1","page":"Arrays","title":"Concatenation and permutation","text":"","category":"section"},{"location":"base/arrays.html#","page":"Arrays","title":"Arrays","text":"Base.cat\nBase.vcat\nBase.hcat\nBase.hvcat\nBase.vect\nBase.circshift\nBase.circshift!\nBase.circcopy!\nBase.findall(::Any)\nBase.findall(::Function, ::Any)\nBase.findfirst(::Any)\nBase.findfirst(::Function, ::Any)\nBase.findlast(::Any)\nBase.findlast(::Function, ::Any)\nBase.findnext(::Any, ::Integer)\nBase.findnext(::Function, ::Any, ::Integer)\nBase.findprev(::Any, ::Integer)\nBase.findprev(::Function, ::Any, ::Integer)\nBase.permutedims\nBase.permutedims!\nBase.PermutedDimsArray\nBase.promote_shape","category":"page"},{"location":"base/arrays.html#Base.cat","page":"Arrays","title":"Base.cat","text":"cat(A...; dims=dims)\n\nConcatenate the input arrays along the specified dimensions in the iterable dims. For dimensions not in dims, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in dims, the size of the output array is the sum of the sizes of the input arrays along that dimension. If dims is a single number, the different arrays are tightly stacked along that dimension. If dims is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, cat(matrices...; dims=(1,2)) builds a block diagonal matrix, i.e. a block matrix with matrices[1], matrices[2], ... as diagonal blocks and matching zero blocks away from the diagonal.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.vcat","page":"Arrays","title":"Base.vcat","text":"vcat(A...)\n\nConcatenate along dimension 1.\n\nExamples\n\njulia> a = [1 2 3 4 5]\n1×5 Array{Int64,2}:\n 1  2  3  4  5\n\njulia> b = [6 7 8 9 10; 11 12 13 14 15]\n2×5 Array{Int64,2}:\n  6   7   8   9  10\n 11  12  13  14  15\n\njulia> vcat(a,b)\n3×5 Array{Int64,2}:\n  1   2   3   4   5\n  6   7   8   9  10\n 11  12  13  14  15\n\njulia> c = ([1 2 3], [4 5 6])\n([1 2 3], [4 5 6])\n\njulia> vcat(c...)\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.hcat","page":"Arrays","title":"Base.hcat","text":"hcat(A...)\n\nConcatenate along dimension 2.\n\nExamples\n\njulia> a = [1; 2; 3; 4; 5]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> b = [6 7; 8 9; 10 11; 12 13; 14 15]\n5×2 Array{Int64,2}:\n  6   7\n  8   9\n 10  11\n 12  13\n 14  15\n\njulia> hcat(a,b)\n5×3 Array{Int64,2}:\n 1   6   7\n 2   8   9\n 3  10  11\n 4  12  13\n 5  14  15\n\njulia> c = ([1; 2; 3], [4; 5; 6])\n([1, 2, 3], [4, 5, 6])\n\njulia> hcat(c...)\n3×2 Array{Int64,2}:\n 1  4\n 2  5\n 3  6\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.hvcat","page":"Arrays","title":"Base.hvcat","text":"hvcat(rows::Tuple{Vararg{Int}}, values...)\n\nHorizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.\n\nExamples\n\njulia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6\n(1, 2, 3, 4, 5, 6)\n\njulia> [a b c; d e f]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> hvcat((3,3), a,b,c,d,e,f)\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> [a b;c d; e f]\n3×2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n\njulia> hvcat((2,2,2), a,b,c,d,e,f)\n3×2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n\nIf the first argument is a single integer n, then all block rows are assumed to have n block columns.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.vect","page":"Arrays","title":"Base.vect","text":"vect(X...)\n\nCreate a Vector with element type computed from the promote_typeof of the argument, containing the argument list.\n\nExamples\n\njulia> a = Base.vect(UInt8(1), 2.5, 1//2)\n3-element Array{Float64,1}:\n 1.0\n 2.5\n 0.5\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.circshift","page":"Arrays","title":"Base.circshift","text":"circshift(A, shifts)\n\nCircularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.\n\nExamples\n\njulia> b = reshape(Vector(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> circshift(b, (0,2))\n4×4 Array{Int64,2}:\n  9  13  1  5\n 10  14  2  6\n 11  15  3  7\n 12  16  4  8\n\njulia> circshift(b, (-1,0))\n4×4 Array{Int64,2}:\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n 1  5   9  13\n\njulia> a = BitArray([true, true, false, false, true])\n5-element BitArray{1}:\n 1\n 1\n 0\n 0\n 1\n\njulia> circshift(a, 1)\n5-element BitArray{1}:\n 1\n 1\n 1\n 0\n 0\n\njulia> circshift(a, -1)\n5-element BitArray{1}:\n 1\n 0\n 0\n 1\n 1\n\nSee also circshift!.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.circshift!","page":"Arrays","title":"Base.circshift!","text":"circshift!(dest, src, shifts)\n\nCircularly shift, i.e. rotate, the data in src, storing the result in dest. shifts specifies the amount to shift in each dimension.\n\nThe dest array must be distinct from the src array (they cannot alias each other).\n\nSee also circshift.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.circcopy!","page":"Arrays","title":"Base.circcopy!","text":"circcopy!(dest, src)\n\nCopy src to dest, indexing each dimension modulo its length. src and dest must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap dest agrees with src.\n\nExamples\n\njulia> src = reshape(Vector(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> dest = OffsetArray{Int}(undef, (0:3,2:5))\n\njulia> circcopy!(dest, src)\nOffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:\n 8  12  16  4\n 5   9  13  1\n 6  10  14  2\n 7  11  15  3\n\njulia> dest[1:3,2:4] == src[1:3,2:4]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.findall-Tuple{Any}","page":"Arrays","title":"Base.findall","text":"findall(A)\n\nReturn a vector I of the true indices or keys of A. If there are no such elements of A, return an empty array. To search for other kinds of values, pass a predicate as the first argument.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [true, false, false, true]\n4-element Array{Bool,1}:\n 1\n 0\n 0\n 1\n\njulia> findall(A)\n2-element Array{Int64,1}:\n 1\n 4\n\njulia> A = [true false; false true]\n2×2 Array{Bool,2}:\n 1  0\n 0  1\n\njulia> findall(A)\n2-element Array{CartesianIndex{2},1}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 2)\n\njulia> findall(falses(3))\n0-element Array{Int64,1}\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.findall-Tuple{Function,Any}","page":"Arrays","title":"Base.findall","text":"findall(f::Function, A)\n\nReturn a vector I of the indices or keys of A where f(A[I]) returns true. If there are no such elements of A, return an empty array.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> x = [1, 3, 4]\n3-element Array{Int64,1}:\n 1\n 3\n 4\n\njulia> findall(isodd, x)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> A = [1 2 0; 3 4 0]\n2×3 Array{Int64,2}:\n 1  2  0\n 3  4  0\njulia> findall(isodd, A)\n2-element Array{CartesianIndex{2},1}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n\njulia> findall(!iszero, A)\n4-element Array{CartesianIndex{2},1}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n CartesianIndex(1, 2)\n CartesianIndex(2, 2)\n\njulia> d = Dict(:A => 10, :B => -1, :C => 0)\nDict{Symbol,Int64} with 3 entries:\n  :A => 10\n  :B => -1\n  :C => 0\n\njulia> findall(x -> x >= 0, d)\n2-element Array{Symbol,1}:\n :A\n :C\n\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.findfirst-Tuple{Any}","page":"Arrays","title":"Base.findfirst","text":"findfirst(A)\n\nReturn the index or key of the first true value in A. Return nothing if no such value is found. To search for other kinds of values, pass a predicate as the first argument.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [false, false, true, false]\n4-element Array{Bool,1}:\n 0\n 0\n 1\n 0\n\njulia> findfirst(A)\n3\n\njulia> findfirst(falses(3)) # returns nothing, but not printed in the REPL\n\njulia> A = [false false; true false]\n2×2 Array{Bool,2}:\n 0  0\n 1  0\n\njulia> findfirst(A)\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.findfirst-Tuple{Function,Any}","page":"Arrays","title":"Base.findfirst","text":"findfirst(predicate::Function, A)\n\nReturn the index or key of the first element of A for which predicate returns true. Return nothing if there is no such element.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [1, 4, 2, 2]\n4-element Array{Int64,1}:\n 1\n 4\n 2\n 2\n\njulia> findfirst(iseven, A)\n2\n\njulia> findfirst(x -> x>10, A) # returns nothing, but not printed in the REPL\n\njulia> findfirst(isequal(4), A)\n2\n\njulia> A = [1 4; 2 2]\n2×2 Array{Int64,2}:\n 1  4\n 2  2\n\njulia> findfirst(iseven, A)\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.findlast-Tuple{Any}","page":"Arrays","title":"Base.findlast","text":"findlast(A)\n\nReturn the index or key of the last true value in A. Return nothing if there is no true value in A.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [true, false, true, false]\n4-element Array{Bool,1}:\n 1\n 0\n 1\n 0\n\njulia> findlast(A)\n3\n\njulia> A = falses(2,2);\n\njulia> findlast(A) # returns nothing, but not printed in the REPL\n\njulia> A = [true false; true false]\n2×2 Array{Bool,2}:\n 1  0\n 1  0\n\njulia> findlast(A)\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.findlast-Tuple{Function,Any}","page":"Arrays","title":"Base.findlast","text":"findlast(predicate::Function, A)\n\nReturn the index or key of the last element of A for which predicate returns true. Return nothing if there is no such element.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [1, 2, 3, 4]\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> findlast(isodd, A)\n3\n\njulia> findlast(x -> x > 5, A) # returns nothing, but not printed in the REPL\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> findlast(isodd, A)\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.findnext-Tuple{Any,Integer}","page":"Arrays","title":"Base.findnext","text":"findnext(A, i)\n\nFind the next index after or including i of a true element of A, or nothing if not found.\n\nIndices are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [false, false, true, false]\n4-element Array{Bool,1}:\n 0\n 0\n 1\n 0\n\njulia> findnext(A, 1)\n3\n\njulia> findnext(A, 4) # returns nothing, but not printed in the REPL\n\njulia> A = [false false; true false]\n2×2 Array{Bool,2}:\n 0  0\n 1  0\n\njulia> findnext(A, CartesianIndex(1, 1))\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.findnext-Tuple{Function,Any,Integer}","page":"Arrays","title":"Base.findnext","text":"findnext(predicate::Function, A, i)\n\nFind the next index after or including i of an element of A for which predicate returns true, or nothing if not found.\n\nIndices are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [1, 4, 2, 2];\n\njulia> findnext(isodd, A, 1)\n1\n\njulia> findnext(isodd, A, 2) # returns nothing, but not printed in the REPL\n\njulia> A = [1 4; 2 2];\n\njulia> findnext(isodd, A, CartesianIndex(1, 1))\nCartesianIndex(1, 1)\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.findprev-Tuple{Any,Integer}","page":"Arrays","title":"Base.findprev","text":"findprev(A, i)\n\nFind the previous index before or including i of a true element of A, or nothing if not found.\n\nIndices are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [false, false, true, true]\n4-element Array{Bool,1}:\n 0\n 0\n 1\n 1\n\njulia> findprev(A, 3)\n3\n\njulia> findprev(A, 1) # returns nothing, but not printed in the REPL\n\njulia> A = [false false; true true]\n2×2 Array{Bool,2}:\n 0  0\n 1  1\n\njulia> findprev(A, CartesianIndex(2, 1))\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.findprev-Tuple{Function,Any,Integer}","page":"Arrays","title":"Base.findprev","text":"findprev(predicate::Function, A, i)\n\nFind the previous index before or including i of an element of A for which predicate returns true, or nothing if not found.\n\nIndices are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [4, 6, 1, 2]\n4-element Array{Int64,1}:\n 4\n 6\n 1\n 2\n\njulia> findprev(isodd, A, 1) # returns nothing, but not printed in the REPL\n\njulia> findprev(isodd, A, 3)\n3\n\njulia> A = [4 6; 1 2]\n2×2 Array{Int64,2}:\n 4  6\n 1  2\n\njulia> findprev(isodd, A, CartesianIndex(1, 2))\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.permutedims","page":"Arrays","title":"Base.permutedims","text":"permutedims(A::AbstractArray, perm)\n\nPermute the dimensions of array A. perm is a vector specifying a permutation of length ndims(A).\n\nSee also: PermutedDimsArray.\n\nExamples\n\njulia> A = reshape(Vector(1:8), (2,2,2))\n2×2×2 Array{Int64,3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8\n\njulia> permutedims(A, [3, 2, 1])\n2×2×2 Array{Int64,3}:\n[:, :, 1] =\n 1  3\n 5  7\n\n[:, :, 2] =\n 2  4\n 6  8\n\n\n\n\n\npermutedims(m::AbstractMatrix)\n\nPermute the dimensions of the matrix m, by flipping the elements across the diagonal of the matrix. Differs from LinearAlgebra's transpose in that the operation is not recursive.\n\nExamples\n\njulia> a = [1 2; 3 4];\n\njulia> b = [5 6; 7 8];\n\njulia> c = [9 10; 11 12];\n\njulia> d = [13 14; 15 16];\n\njulia> X = [[a] [b]; [c] [d]]\n2×2 Array{Array{Int64,2},2}:\n [1 2; 3 4]     [5 6; 7 8]\n [9 10; 11 12]  [13 14; 15 16]\n\njulia> permutedims(X)\n2×2 Array{Array{Int64,2},2}:\n [1 2; 3 4]  [9 10; 11 12]\n [5 6; 7 8]  [13 14; 15 16]\n\njulia> transpose(X)\n2×2 Transpose{Transpose{Int64,Array{Int64,2}},Array{Array{Int64,2},2}}:\n [1 3; 2 4]  [9 11; 10 12]\n [5 7; 6 8]  [13 15; 14 16]\n\n\n\n\n\npermutedims(v::AbstractVector)\n\nReshape vector v into a 1 × length(v) row matrix. Differs from LinearAlgebra's transpose in that the operation is not recursive.\n\nExamples\n\njulia> permutedims([1, 2, 3, 4])\n1×4 Array{Int64,2}:\n 1  2  3  4\n\njulia> V = [[[1 2; 3 4]]; [[5 6; 7 8]]]\n2-element Array{Array{Int64,2},1}:\n [1 2; 3 4]\n [5 6; 7 8]\n\njulia> permutedims(V)\n1×2 Array{Array{Int64,2},2}:\n [1 2; 3 4]  [5 6; 7 8]\n\njulia> transpose(V)\n1×2 Transpose{Transpose{Int64,Array{Int64,2}},Array{Array{Int64,2},1}}:\n [1 3; 2 4]  [5 7; 6 8]\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.permutedims!","page":"Arrays","title":"Base.permutedims!","text":"permutedims!(dest, src, perm)\n\nPermute the dimensions of array src and store the result in the array dest. perm is a vector specifying a permutation of length ndims(src). The preallocated array dest should have size(dest) == size(src)[perm] and is completely overwritten. No in-place permutation is supported and unexpected results will happen if src and dest have overlapping memory regions.\n\nSee also permutedims.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.PermutedDimsArrays.PermutedDimsArray","page":"Arrays","title":"Base.PermutedDimsArrays.PermutedDimsArray","text":"PermutedDimsArray(A, perm) -> B\n\nGiven an AbstractArray A, create a view B such that the dimensions appear to be permuted. Similar to permutedims, except that no copying occurs (B shares storage with A).\n\nSee also: permutedims.\n\nExamples\n\njulia> A = rand(3,5,4);\n\njulia> B = PermutedDimsArray(A, (3,1,2));\n\njulia> size(B)\n(4, 3, 5)\n\njulia> B[3,1,2] == A[1,2,3]\ntrue\n\n\n\n\n\n","category":"type"},{"location":"base/arrays.html#Base.promote_shape","page":"Arrays","title":"Base.promote_shape","text":"promote_shape(s1, s2)\n\nCheck two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.\n\nExamples\n\njulia> a = fill(1, (3,4,1,1,1));\n\njulia> b = fill(1, (3,4));\n\njulia> promote_shape(a,b)\n(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))\n\njulia> promote_shape((2,3,1,4), (2, 3, 1, 4, 1))\n(2, 3, 1, 4, 1)\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Array-functions-1","page":"Arrays","title":"Array functions","text":"","category":"section"},{"location":"base/arrays.html#","page":"Arrays","title":"Arrays","text":"Base.accumulate\nBase.accumulate!\nBase.cumprod\nBase.cumprod!\nBase.cumsum\nBase.cumsum!\nBase.diff\nBase.repeat\nBase.rot180\nBase.rotl90\nBase.rotr90\nBase.mapslices","category":"page"},{"location":"base/arrays.html#Base.accumulate","page":"Arrays","title":"Base.accumulate","text":"accumulate(op, A; dims::Integer, [init])\n\nCumulative operation op along the dimension dims of A (providing dims is optional for vectors). An initial value init may optionally be provided by a keyword argument. See also accumulate! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of accumulate, see: cumsum, cumprod\n\nExamples\n\njulia> accumulate(+, [1,2,3])\n3-element Array{Int64,1}:\n 1\n 3\n 6\n\njulia> accumulate(*, [1,2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 6\n\njulia> accumulate(+, [1,2,3]; init=100)\n3-element Array{Int64,1}:\n 101\n 103\n 106\n\njulia> accumulate(min, [1,2,-1]; init=0)\n3-element Array{Int64,1}:\n  0\n  0\n -1\n\njulia> accumulate(+, fill(1, 3, 3), dims=1)\n3×3 Array{Int64,2}:\n 1  1  1\n 2  2  2\n 3  3  3\n\njulia> accumulate(+, fill(1, 3, 3), dims=2)\n3×3 Array{Int64,2}:\n 1  2  3\n 1  2  3\n 1  2  3\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.accumulate!","page":"Arrays","title":"Base.accumulate!","text":"accumulate!(op, B, A; [dims], [init])\n\nCumulative operation op on A along the dimension dims, storing the result in B. Providing dims is optional for vectors.  If the keyword argument init is given, its value is used to instantiate the accumulation. See also accumulate.\n\nExamples\n\njulia> x = [1, 0, 2, 0, 3];\n\njulia> y = [0, 0, 0, 0, 0];\n\njulia> accumulate!(+, y, x);\n\njulia> y\n5-element Array{Int64,1}:\n 1\n 1\n 3\n 3\n 6\n\njulia> A = [1 2; 3 4];\n\njulia> B = [0 0; 0 0];\n\njulia> accumulate!(-, B, A, dims=1);\n\njulia> B\n2×2 Array{Int64,2}:\n  1   2\n -2  -2\n\njulia> accumulate!(-, B, A, dims=2);\n\njulia> B\n2×2 Array{Int64,2}:\n 1  -1\n 3  -1\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.cumprod","page":"Arrays","title":"Base.cumprod","text":"cumprod(A; dims::Integer)\n\nCumulative product along the dimension dim. See also cumprod! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\nExamples\n\njulia> a = [1 2 3; 4 5 6]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> cumprod(a, dims=1)\n2×3 Array{Int64,2}:\n 1   2   3\n 4  10  18\n\njulia> cumprod(a, dims=2)\n2×3 Array{Int64,2}:\n 1   2    6\n 4  20  120\n\n\n\n\n\ncumprod(x::AbstractVector)\n\nCumulative product of a vector. See also cumprod! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\nExamples\n\njulia> cumprod(fill(1//2, 3))\n3-element Array{Rational{Int64},1}:\n 1//2\n 1//4\n 1//8\n\njulia> cumprod([fill(1//3, 2, 2) for i in 1:3])\n3-element Array{Array{Rational{Int64},2},1}:\n [1//3 1//3; 1//3 1//3]\n [2//9 2//9; 2//9 2//9]\n [4//27 4//27; 4//27 4//27]\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.cumprod!","page":"Arrays","title":"Base.cumprod!","text":"cumprod!(B, A; dims::Integer)\n\nCumulative product of A along the dimension dims, storing the result in B. See also cumprod.\n\n\n\n\n\ncumprod!(y::AbstractVector, x::AbstractVector)\n\nCumulative product of a vector x, storing the result in y. See also cumprod.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.cumsum","page":"Arrays","title":"Base.cumsum","text":"cumsum(A; dims::Integer)\n\nCumulative sum along the dimension dims. See also cumsum! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\nExamples\n\njulia> a = [1 2 3; 4 5 6]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> cumsum(a, dims=1)\n2×3 Array{Int64,2}:\n 1  2  3\n 5  7  9\n\njulia> cumsum(a, dims=2)\n2×3 Array{Int64,2}:\n 1  3   6\n 4  9  15\n\n\n\n\n\ncumsum(x::AbstractVector)\n\nCumulative sum a vector. See also cumsum! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\nExamples\n\njulia> cumsum([1, 1, 1])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> cumsum([fill(1, 2) for i in 1:3])\n3-element Array{Array{Int64,1},1}:\n [1, 1]\n [2, 2]\n [3, 3]\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.cumsum!","page":"Arrays","title":"Base.cumsum!","text":"cumsum!(B, A; dims::Integer)\n\nCumulative sum of A along the dimension dims, storing the result in B. See also cumsum.\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.diff","page":"Arrays","title":"Base.diff","text":"diff(A::AbstractVector)\ndiff(A::AbstractArray; dims::Integer)\n\nFinite difference operator on a vector or a multidimensional array A. In the latter case the dimension to operate on needs to be specified with the dims keyword argument.\n\ncompat: Julia 1.1\ndiff for arrays with dimension higher than 2 requires at least Julia 1.1.\n\nExamples\n\njulia> a = [2 4; 6 16]\n2×2 Array{Int64,2}:\n 2   4\n 6  16\n\njulia> diff(a, dims=2)\n2×1 Array{Int64,2}:\n  2\n 10\n\njulia> diff(vec(a))\n3-element Array{Int64,1}:\n  4\n -2\n 12\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.repeat","page":"Arrays","title":"Base.repeat","text":"repeat(A::AbstractArray, counts::Integer...)\n\nConstruct an array by repeating array A a given number of times in each dimension, specified by counts.\n\nExamples\n\njulia> repeat([1, 2, 3], 2)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 1\n 2\n 3\n\njulia> repeat([1, 2, 3], 2, 3)\n6×3 Array{Int64,2}:\n 1  1  1\n 2  2  2\n 3  3  3\n 1  1  1\n 2  2  2\n 3  3  3\n\n\n\n\n\nrepeat(A::AbstractArray; inner=ntuple(x->1, ndims(A)), outer=ntuple(x->1, ndims(A)))\n\nConstruct an array by repeating the entries of A. The i-th element of inner specifies the number of times that the individual entries of the i-th dimension of A should be repeated. The i-th element of outer specifies the number of times that a slice along the i-th dimension of A should be repeated. If inner or outer are omitted, no repetition is performed.\n\nExamples\n\njulia> repeat(1:2, inner=2)\n4-element Array{Int64,1}:\n 1\n 1\n 2\n 2\n\njulia> repeat(1:2, outer=2)\n4-element Array{Int64,1}:\n 1\n 2\n 1\n 2\n\njulia> repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))\n4×6 Array{Int64,2}:\n 1  2  1  2  1  2\n 1  2  1  2  1  2\n 3  4  3  4  3  4\n 3  4  3  4  3  4\n\n\n\n\n\nrepeat(s::AbstractString, r::Integer)\n\nRepeat a string r times. This can be written as s^r.\n\nSee also: ^\n\nExamples\n\njulia> repeat(\"ha\", 3)\n\"hahaha\"\n\n\n\n\n\nrepeat(c::AbstractChar, r::Integer) -> String\n\nRepeat a character r times. This can equivalently be accomplished by calling c^r.\n\nExamples\n\njulia> repeat('A', 3)\n\"AAA\"\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.rot180","page":"Arrays","title":"Base.rot180","text":"rot180(A)\n\nRotate matrix A 180 degrees.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rot180(a)\n2×2 Array{Int64,2}:\n 4  3\n 2  1\n\n\n\n\n\nrot180(A, k)\n\nRotate matrix A 180 degrees an integer k number of times. If k is even, this is equivalent to a copy.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rot180(a,1)\n2×2 Array{Int64,2}:\n 4  3\n 2  1\n\njulia> rot180(a,2)\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.rotl90","page":"Arrays","title":"Base.rotl90","text":"rotl90(A)\n\nRotate matrix A left 90 degrees.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rotl90(a)\n2×2 Array{Int64,2}:\n 2  4\n 1  3\n\n\n\n\n\nrotl90(A, k)\n\nLeft-rotate matrix A 90 degrees counterclockwise an integer k number of times. If k is a multiple of four (including zero), this is equivalent to a copy.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rotl90(a,1)\n2×2 Array{Int64,2}:\n 2  4\n 1  3\n\njulia> rotl90(a,2)\n2×2 Array{Int64,2}:\n 4  3\n 2  1\n\njulia> rotl90(a,3)\n2×2 Array{Int64,2}:\n 3  1\n 4  2\n\njulia> rotl90(a,4)\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.rotr90","page":"Arrays","title":"Base.rotr90","text":"rotr90(A)\n\nRotate matrix A right 90 degrees.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rotr90(a)\n2×2 Array{Int64,2}:\n 3  1\n 4  2\n\n\n\n\n\nrotr90(A, k)\n\nRight-rotate matrix A 90 degrees clockwise an integer k number of times. If k is a multiple of four (including zero), this is equivalent to a copy.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rotr90(a,1)\n2×2 Array{Int64,2}:\n 3  1\n 4  2\n\njulia> rotr90(a,2)\n2×2 Array{Int64,2}:\n 4  3\n 2  1\n\njulia> rotr90(a,3)\n2×2 Array{Int64,2}:\n 2  4\n 1  3\n\njulia> rotr90(a,4)\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.mapslices","page":"Arrays","title":"Base.mapslices","text":"mapslices(f, A; dims)\n\nTransform the given dimensions of array A using function f. f is called on each slice of A of the form A[...,:,...,:,...]. dims is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if dims is [1,2] and A is 4-dimensional, f is called on A[:,:,i,j] for all i and j.\n\nExamples\n\njulia> a = reshape(Vector(1:16),(2,2,2,2))\n2×2×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\n[:, :, 2, 1] =\n 5  7\n 6  8\n\n[:, :, 1, 2] =\n  9  11\n 10  12\n\n[:, :, 2, 2] =\n 13  15\n 14  16\n\njulia> mapslices(sum, a, dims = [1,2])\n1×1×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 10\n\n[:, :, 2, 1] =\n 26\n\n[:, :, 1, 2] =\n 42\n\n[:, :, 2, 2] =\n 58\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Combinatorics-1","page":"Arrays","title":"Combinatorics","text":"","category":"section"},{"location":"base/arrays.html#","page":"Arrays","title":"Arrays","text":"Base.invperm\nBase.isperm\nBase.permute!(::Any, ::AbstractVector)\nBase.invpermute!\nBase.reverse(::AbstractVector; kwargs...)\nBase.reverseind\nBase.reverse!","category":"page"},{"location":"base/arrays.html#Base.invperm","page":"Arrays","title":"Base.invperm","text":"invperm(v)\n\nReturn the inverse permutation of v. If B = A[v], then A == B[invperm(v)].\n\nExamples\n\njulia> v = [2; 4; 3; 1];\n\njulia> invperm(v)\n4-element Array{Int64,1}:\n 4\n 1\n 3\n 2\n\njulia> A = ['a','b','c','d'];\n\njulia> B = A[v]\n4-element Array{Char,1}:\n 'b'\n 'd'\n 'c'\n 'a'\n\njulia> B[invperm(v)]\n4-element Array{Char,1}:\n 'a'\n 'b'\n 'c'\n 'd'\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.isperm","page":"Arrays","title":"Base.isperm","text":"isperm(v) -> Bool\n\nReturn true if v is a valid permutation.\n\nExamples\n\njulia> isperm([1; 2])\ntrue\n\njulia> isperm([1; 3])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.permute!-Tuple{Any,AbstractArray{T,1} where T}","page":"Arrays","title":"Base.permute!","text":"permute!(v, p)\n\nPermute vector v in-place, according to permutation p. No checking is done to verify that p is a permutation.\n\nTo return a new permutation, use v[p]. Note that this is generally faster than permute!(v,p) for large vectors.\n\nSee also invpermute!.\n\nExamples\n\njulia> A = [1, 1, 3, 4];\n\njulia> perm = [2, 4, 3, 1];\n\njulia> permute!(A, perm);\n\njulia> A\n4-element Array{Int64,1}:\n 1\n 4\n 3\n 1\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.invpermute!","page":"Arrays","title":"Base.invpermute!","text":"invpermute!(v, p)\n\nLike permute!, but the inverse of the given permutation is applied.\n\nExamples\n\njulia> A = [1, 1, 3, 4];\n\njulia> perm = [2, 4, 3, 1];\n\njulia> invpermute!(A, perm);\n\njulia> A\n4-element Array{Int64,1}:\n 4\n 1\n 3\n 1\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.reverse-Tuple{AbstractArray{T,1} where T}","page":"Arrays","title":"Base.reverse","text":"reverse(v [, start=1 [, stop=length(v) ]] )\n\nReturn a copy of v reversed from start to stop.  See also Iterators.reverse for reverse-order iteration without making a copy.\n\nExamples\n\njulia> A = Vector(1:5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> reverse(A)\n5-element Array{Int64,1}:\n 5\n 4\n 3\n 2\n 1\n\njulia> reverse(A, 1, 4)\n5-element Array{Int64,1}:\n 4\n 3\n 2\n 1\n 5\n\njulia> reverse(A, 3, 5)\n5-element Array{Int64,1}:\n 1\n 2\n 5\n 4\n 3\n\n\n\n\n\nreverse(A; dims::Integer)\n\nReverse A in dimension dims.\n\nExamples\n\njulia> b = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> reverse(b, dims=2)\n2×2 Array{Int64,2}:\n 2  1\n 4  3\n\n\n\n\n\n","category":"method"},{"location":"base/arrays.html#Base.reverseind","page":"Arrays","title":"Base.reverseind","text":"reverseind(v, i)\n\nGiven an index i in reverse(v), return the corresponding index in v so that v[reverseind(v,i)] == reverse(v)[i]. (This can be nontrivial in cases where v contains non-ASCII characters.)\n\nExamples\n\njulia> r = reverse(\"Julia\")\n\"ailuJ\"\n\njulia> for i in 1:length(r)\n           print(r[reverseind(\"Julia\", i)])\n       end\nJulia\n\n\n\n\n\n","category":"function"},{"location":"base/arrays.html#Base.reverse!","page":"Arrays","title":"Base.reverse!","text":"reverse!(v [, start=1 [, stop=length(v) ]]) -> v\n\nIn-place version of reverse.\n\nExamples\n\njulia> A = Vector(1:5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> reverse!(A);\n\njulia> A\n5-element Array{Int64,1}:\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Tasks-1","page":"Tasks","title":"Tasks","text":"","category":"section"},{"location":"base/parallel.html#","page":"Tasks","title":"Tasks","text":"Core.Task\nBase.@task\nBase.@async\nBase.@sync\nBase.asyncmap\nBase.asyncmap!\nBase.fetch(t::Task)\nBase.current_task\nBase.istaskdone\nBase.istaskstarted\nBase.task_local_storage(::Any)\nBase.task_local_storage(::Any, ::Any)\nBase.task_local_storage(::Function, ::Any, ::Any)","category":"page"},{"location":"base/parallel.html#Core.Task","page":"Tasks","title":"Core.Task","text":"Task(func)\n\nCreate a Task (i.e. coroutine) to execute the given function func (which must be callable with no arguments). The task exits when this function returns.\n\nExamples\n\njulia> a() = sum(i for i in 1:1000);\n\njulia> b = Task(a);\n\nIn this example, b is a runnable Task that hasn't started yet.\n\n\n\n\n\n","category":"type"},{"location":"base/parallel.html#Base.@task","page":"Tasks","title":"Base.@task","text":"@task\n\nWrap an expression in a Task without executing it, and return the Task. This only creates a task, and does not run it.\n\nExamples\n\njulia> a1() = sum(i for i in 1:1000);\n\njulia> b = @task a1();\n\njulia> istaskstarted(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskdone(b)\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"base/parallel.html#Base.@async","page":"Tasks","title":"Base.@async","text":"@async\n\nWrap an expression in a Task and add it to the local machine's scheduler queue.\n\n\n\n\n\n","category":"macro"},{"location":"base/parallel.html#Base.@sync","page":"Tasks","title":"Base.@sync","text":"@sync\n\nWait until all lexically-enclosed uses of @async, @spawn, @spawnat and @distributed are complete. All exceptions thrown by enclosed async operations are collected and thrown as a CompositeException.\n\n\n\n\n\n","category":"macro"},{"location":"base/parallel.html#Base.asyncmap","page":"Tasks","title":"Base.asyncmap","text":"asyncmap(f, c...; ntasks=0, batch_size=nothing)\n\nUses multiple concurrent tasks to map f over a collection (or multiple equal length collections). For multiple collection arguments, f is applied elementwise.\n\nntasks specifies the number of tasks to run concurrently. Depending on the length of the collections, if ntasks is unspecified, up to 100 tasks will be used for concurrent mapping.\n\nntasks can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of ntasks_func is less than the current number of tasks.\n\nIf batch_size is specified, the collection is processed in batch mode. f must then be a function that must accept a Vector of argument tuples and must return a vector of results. The input vector will have a length of batch_size or less.\n\nThe following examples highlight execution in different tasks by returning the objectid of the tasks in which the mapping function is executed.\n\nFirst, with ntasks undefined, each element is processed in a different task.\n\njulia> tskoid() = objectid(current_task());\n\njulia> asyncmap(x->tskoid(), 1:5)\n5-element Array{UInt64,1}:\n 0x6e15e66c75c75853\n 0x440f8819a1baa682\n 0x9fb3eeadd0c83985\n 0xebd3e35fe90d4050\n 0x29efc93edce2b961\n\njulia> length(unique(asyncmap(x->tskoid(), 1:5)))\n5\n\nWith ntasks=2 all elements are processed in 2 tasks.\n\njulia> asyncmap(x->tskoid(), 1:5; ntasks=2)\n5-element Array{UInt64,1}:\n 0x027ab1680df7ae94\n 0xa23d2f80cd7cf157\n 0x027ab1680df7ae94\n 0xa23d2f80cd7cf157\n 0x027ab1680df7ae94\n\njulia> length(unique(asyncmap(x->tskoid(), 1:5; ntasks=2)))\n2\n\nWith batch_size defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. map is used in the modified mapping function to achieve this.\n\njulia> batch_func(input) = map(x->string(\"args_tuple: \", x, \", element_val: \", x[1], \", task: \", tskoid()), input)\nbatch_func (generic function with 1 method)\n\njulia> asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)\n5-element Array{String,1}:\n \"args_tuple: (1,), element_val: 1, task: 9118321258196414413\"\n \"args_tuple: (2,), element_val: 2, task: 4904288162898683522\"\n \"args_tuple: (3,), element_val: 3, task: 9118321258196414413\"\n \"args_tuple: (4,), element_val: 4, task: 4904288162898683522\"\n \"args_tuple: (5,), element_val: 5, task: 9118321258196414413\"\n\nnote: Note\nCurrently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, asyncmap is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.asyncmap!","page":"Tasks","title":"Base.asyncmap!","text":"asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)\n\nLike asyncmap, but stores output in results rather than returning a collection.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.fetch-Tuple{Task}","page":"Tasks","title":"Base.fetch","text":"fetch(t::Task)\n\nWait for a Task to finish, then return its result value. If the task fails with an exception, the exception is propagated (re-thrown in the task that called fetch).\n\n\n\n\n\n","category":"method"},{"location":"base/parallel.html#Base.current_task","page":"Tasks","title":"Base.current_task","text":"current_task()\n\nGet the currently running Task.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.istaskdone","page":"Tasks","title":"Base.istaskdone","text":"istaskdone(t::Task) -> Bool\n\nDetermine whether a task has exited.\n\nExamples\n\njulia> a2() = sum(i for i in 1:1000);\n\njulia> b = Task(a2);\n\njulia> istaskdone(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskdone(b)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.istaskstarted","page":"Tasks","title":"Base.istaskstarted","text":"istaskstarted(t::Task) -> Bool\n\nDetermine whether a task has started executing.\n\nExamples\n\njulia> a3() = sum(i for i in 1:1000);\n\njulia> b = Task(a3);\n\njulia> istaskstarted(b)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.task_local_storage-Tuple{Any}","page":"Tasks","title":"Base.task_local_storage","text":"task_local_storage(key)\n\nLook up the value of a key in the current task's task-local storage.\n\n\n\n\n\n","category":"method"},{"location":"base/parallel.html#Base.task_local_storage-Tuple{Any,Any}","page":"Tasks","title":"Base.task_local_storage","text":"task_local_storage(key, value)\n\nAssign a value to a key in the current task's task-local storage.\n\n\n\n\n\n","category":"method"},{"location":"base/parallel.html#Base.task_local_storage-Tuple{Function,Any,Any}","page":"Tasks","title":"Base.task_local_storage","text":"task_local_storage(body, key, value)\n\nCall the function body with a modified task-local storage, in which value is assigned to key; the previous value of key, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.\n\n\n\n\n\n","category":"method"},{"location":"base/parallel.html#Scheduling-1","page":"Tasks","title":"Scheduling","text":"","category":"section"},{"location":"base/parallel.html#","page":"Tasks","title":"Tasks","text":"Base.yield\nBase.yieldto\nBase.sleep\nBase.wait\nBase.timedwait\n\nBase.Condition\nBase.Threads.Condition\nBase.notify\nBase.schedule\n\nBase.Threads.Event\n\nBase.Semaphore\nBase.acquire\nBase.release\n\nBase.AbstractLock\nBase.lock\nBase.unlock\nBase.trylock\nBase.islocked\nBase.ReentrantLock\n\nBase.Channel\nBase.put!(::Channel, ::Any)\nBase.take!(::Channel)\nBase.isready(::Channel)\nBase.fetch(::Channel)\nBase.close(::Channel)\nBase.bind(c::Channel, task::Task)","category":"page"},{"location":"base/parallel.html#Base.yield","page":"Tasks","title":"Base.yield","text":"yield()\n\nSwitch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.\n\n\n\n\n\nyield(t::Task, arg = nothing)\n\nA fast, unfair-scheduling version of schedule(t, arg); yield() which immediately yields to t before calling the scheduler.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.yieldto","page":"Tasks","title":"Base.yieldto","text":"yieldto(t::Task, arg = nothing)\n\nSwitch to the given task. The first time a task is switched to, the task's function is called with no arguments. On subsequent switches, arg is returned from the task's last call to yieldto. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.sleep","page":"Tasks","title":"Base.sleep","text":"sleep(seconds)\n\nBlock the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of 0.001.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.wait","page":"Tasks","title":"Base.wait","text":"Special note for Threads.Condition:\n\nThe caller must be holding the lock that owns c before calling this method. The calling task will be blocked until some other task wakes it, usually by calling notify` on the same Condition object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.\n\n\n\n\n\nwait([x])\n\nBlock the current task until some event occurs, depending on the type of the argument:\n\nChannel: Wait for a value to be appended to the channel.\nCondition: Wait for notify on a condition.\nProcess: Wait for a process or process chain to exit. The exitcode field of a process can be used to determine success or failure.\nTask: Wait for a Task to finish. If the task fails with an exception, the exception is propagated (re-thrown in the task that called wait).\nRawFD: Wait for changes on a file descriptor (see the FileWatching package).\n\nIf no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to schedule or yieldto.\n\nOften wait is called within a while loop to ensure a waited-for condition is met before proceeding.\n\n\n\n\n\nwait(r::Future)\n\nWait for a value to become available for the specified Future.\n\n\n\n\n\nwait(r::RemoteChannel, args...)\n\nWait for a value to become available on the specified RemoteChannel.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.timedwait","page":"Tasks","title":"Base.timedwait","text":"timedwait(testcb::Function, secs::Float64; pollint::Float64=0.1)\n\nWaits until testcb returns true or for secs seconds, whichever is earlier. testcb is polled every pollint seconds.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.Condition","page":"Tasks","title":"Base.Condition","text":"Condition()\n\nCreate an edge-triggered event source that tasks can wait for. Tasks that call wait on a Condition are suspended and queued. Tasks are woken up when notify is later called on the Condition. Edge triggering means that only tasks waiting at the time notify is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The Channel and Threads.Event types do this, and can be used for level-triggered events.\n\nThis object is NOT thread-safe. See Threads.Condition for a thread-safe version.\n\n\n\n\n\n","category":"type"},{"location":"base/parallel.html#Base.Threads.Condition","page":"Tasks","title":"Base.Threads.Condition","text":"Threads.Condition([lock])\n\nA thread-safe version of Base.Condition.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"type"},{"location":"base/parallel.html#Base.notify","page":"Tasks","title":"Base.notify","text":"notify(condition, val=nothing; all=true, error=false)\n\nWake up tasks waiting for a condition, passing them val. If all is true (the default), all waiting tasks are woken, otherwise only one is. If error is true, the passed value is raised as an exception in the woken tasks.\n\nReturn the count of tasks woken up. Return 0 if no tasks are waiting on condition.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.schedule","page":"Tasks","title":"Base.schedule","text":"schedule(t::Task, [val]; error=false)\n\nAdd a Task to the scheduler's queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as wait.\n\nIf a second argument val is provided, it will be passed to the task (via the return value of yieldto) when it runs again. If error is true, the value is raised as an exception in the woken task.\n\nExamples\n\njulia> a5() = sum(i for i in 1:1000);\n\njulia> b = Task(a5);\n\njulia> istaskstarted(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskstarted(b)\ntrue\n\njulia> istaskdone(b)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.Event","page":"Tasks","title":"Base.Event","text":"Event()\n\nCreate a level-triggered event source. Tasks that call wait on an Event are suspended and queued until notify is called on the Event. After notify is called, the Event remains in a signaled state and tasks will no longer block when waiting for it.\n\ncompat: Julia 1.1\nThis functionality requires at least Julia 1.1.\n\n\n\n\n\n","category":"type"},{"location":"base/parallel.html#Base.Semaphore","page":"Tasks","title":"Base.Semaphore","text":"Semaphore(sem_size)\n\nCreate a counting semaphore that allows at most sem_size acquires to be in use at any time. Each acquire must be matched with a release.\n\n\n\n\n\n","category":"type"},{"location":"base/parallel.html#Base.acquire","page":"Tasks","title":"Base.acquire","text":"acquire(s::Semaphore)\n\nWait for one of the sem_size permits to be available, blocking until one can be acquired.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.release","page":"Tasks","title":"Base.release","text":"release(s::Semaphore)\n\nReturn one permit to the pool, possibly allowing another task to acquire it and resume execution.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.AbstractLock","page":"Tasks","title":"Base.AbstractLock","text":"AbstractLock\n\nAbstract supertype describing types that implement the synchronization primitives: lock, trylock, unlock, and islocked.\n\n\n\n\n\n","category":"type"},{"location":"base/parallel.html#Base.lock","page":"Tasks","title":"Base.lock","text":"lock(lock)\n\nAcquire the lock when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.\n\nEach lock must be matched by an unlock.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.unlock","page":"Tasks","title":"Base.unlock","text":"unlock(lock)\n\nReleases ownership of the lock.\n\nIf this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.trylock","page":"Tasks","title":"Base.trylock","text":"trylock(lock) -> Success (Boolean)\n\nAcquire the lock if it is available, and return true if successful. If the lock is already locked by a different task/thread, return false.\n\nEach successful trylock must be matched by an unlock.\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.islocked","page":"Tasks","title":"Base.islocked","text":"islocked(lock) -> Status (Boolean)\n\nCheck whether the lock is held by any task/thread. This should not be used for synchronization (see instead trylock).\n\n\n\n\n\n","category":"function"},{"location":"base/parallel.html#Base.ReentrantLock","page":"Tasks","title":"Base.ReentrantLock","text":"ReentrantLock()\n\nCreates a re-entrant lock for synchronizing Tasks. The same task can acquire the lock as many times as required. Each lock must be matched with an unlock.\n\n\n\n\n\n","category":"type"},{"location":"base/parallel.html#Base.Channel","page":"Tasks","title":"Base.Channel","text":"Channel{T}(sz::Int)\n\nConstructs a Channel with an internal buffer that can hold a maximum of sz objects of type T. put! calls on a full channel block until an object is removed with take!.\n\nChannel(0) constructs an unbuffered channel. put! blocks until a matching take! is called. And vice-versa.\n\nOther constructors:\n\nChannel(Inf): equivalent to Channel{Any}(typemax(Int))\nChannel(sz): equivalent to Channel{Any}(sz)\n\n\n\n\n\n","category":"type"},{"location":"base/parallel.html#Base.put!-Tuple{Channel,Any}","page":"Tasks","title":"Base.put!","text":"put!(c::Channel, v)\n\nAppend an item v to the channel c. Blocks if the channel is full.\n\nFor unbuffered channels, blocks until a take! is performed by a different task.\n\ncompat: Julia 1.1\nv now gets converted to the channel's type with convert as put! is called.\n\n\n\n\n\n","category":"method"},{"location":"base/parallel.html#Base.take!-Tuple{Channel}","page":"Tasks","title":"Base.take!","text":"take!(c::Channel)\n\nRemove and return a value from a Channel. Blocks until data is available.\n\nFor unbuffered channels, blocks until a put! is performed by a different task.\n\n\n\n\n\n","category":"method"},{"location":"base/parallel.html#Base.isready-Tuple{Channel}","page":"Tasks","title":"Base.isready","text":"isready(c::Channel)\n\nDetermine whether a Channel has a value stored to it. Returns immediately, does not block.\n\nFor unbuffered channels returns true if there are tasks waiting on a put!.\n\n\n\n\n\n","category":"method"},{"location":"base/parallel.html#Base.fetch-Tuple{Channel}","page":"Tasks","title":"Base.fetch","text":"fetch(c::Channel)\n\nWait for and get the first available item from the channel. Does not remove the item. fetch is unsupported on an unbuffered (0-size) channel.\n\n\n\n\n\n","category":"method"},{"location":"base/parallel.html#Base.close-Tuple{Channel}","page":"Tasks","title":"Base.close","text":"close(c::Channel[, excp::Exception])\n\nClose a channel. An exception (optionally given by excp), is thrown by:\n\nput! on a closed channel.\ntake! and fetch on an empty, closed channel.\n\n\n\n\n\n","category":"method"},{"location":"base/parallel.html#Base.bind-Tuple{Channel,Task}","page":"Tasks","title":"Base.bind","text":"bind(chnl::Channel, task::Task)\n\nAssociate the lifetime of chnl with a task. Channel chnl is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on chnl.\n\nThe chnl object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed Channel objects.\n\nWhen a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.\n\nExamples\n\njulia> c = Channel(0);\n\njulia> task = @async foreach(i->put!(c, i), 1:4);\n\njulia> bind(c,task);\n\njulia> for i in c\n           @show i\n       end;\ni = 1\ni = 2\ni = 3\ni = 4\n\njulia> isopen(c)\nfalse\n\njulia> c = Channel(0);\n\njulia> task = @async (put!(c,1);error(\"foo\"));\n\njulia> bind(c,task);\n\njulia> take!(c)\n1\n\njulia> put!(c,1);\nERROR: foo\nStacktrace:\n[...]\n\n\n\n\n\n","category":"method"},{"location":"base/multi-threading.html#lib-multithreading-1","page":"Multi-Threading","title":"Multi-Threading","text":"","category":"section"},{"location":"base/multi-threading.html#","page":"Multi-Threading","title":"Multi-Threading","text":"This experimental interface supports Julia's multi-threading capabilities. Types and functions described here might (and likely will) change in the future.","category":"page"},{"location":"base/multi-threading.html#","page":"Multi-Threading","title":"Multi-Threading","text":"Base.Threads.threadid\nBase.Threads.nthreads\nBase.Threads.@threads","category":"page"},{"location":"base/multi-threading.html#Base.Threads.threadid","page":"Multi-Threading","title":"Base.Threads.threadid","text":"Threads.threadid()\n\nGet the ID number of the current thread of execution. The master thread has ID 1.\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#Base.Threads.nthreads","page":"Multi-Threading","title":"Base.Threads.nthreads","text":"Threads.nthreads()\n\nGet the number of threads available to the Julia process. This is the inclusive upper bound on threadid().\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#Base.Threads.@threads","page":"Multi-Threading","title":"Base.Threads.@threads","text":"Threads.@threads\n\nA macro to parallelize a for-loop to run with multiple threads. This spawns nthreads() number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.\n\n\n\n\n\n","category":"macro"},{"location":"base/multi-threading.html#","page":"Multi-Threading","title":"Multi-Threading","text":"Base.Threads.Atomic\nBase.Threads.atomic_cas!\nBase.Threads.atomic_xchg!\nBase.Threads.atomic_add!\nBase.Threads.atomic_sub!\nBase.Threads.atomic_and!\nBase.Threads.atomic_nand!\nBase.Threads.atomic_or!\nBase.Threads.atomic_xor!\nBase.Threads.atomic_max!\nBase.Threads.atomic_min!\nBase.Threads.atomic_fence","category":"page"},{"location":"base/multi-threading.html#Base.Threads.Atomic","page":"Multi-Threading","title":"Base.Threads.Atomic","text":"Threads.Atomic{T}\n\nHolds a reference to an object of type T, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.\n\nOnly certain \"simple\" types can be used atomically, namely the primitive boolean, integer, and float-point types. These are Bool, Int8...Int128, UInt8...UInt128, and Float16...Float64.\n\nNew atomic objects can be created from a non-atomic values; if none is specified, the atomic object is initialized with zero.\n\nAtomic objects can be accessed using the [] notation:\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> x[] = 1\n1\n\njulia> x[]\n1\n\nAtomic operations use an atomic_ prefix, such as atomic_add!, atomic_xchg!, etc.\n\n\n\n\n\n","category":"type"},{"location":"base/multi-threading.html#Base.Threads.atomic_cas!","page":"Multi-Threading","title":"Base.Threads.atomic_cas!","text":"Threads.atomic_cas!(x::Atomic{T}, cmp::T, newval::T) where T\n\nAtomically compare-and-set x\n\nAtomically compares the value in x with cmp. If equal, write newval to x. Otherwise, leaves x unmodified. Returns the old value in x. By comparing the returned value to cmp (via ===) one knows whether x was modified and now holds the new value newval.\n\nFor further details, see LLVM's cmpxchg instruction.\n\nThis function can be used to implement transactional semantics. Before the transaction, one records the value in x. After the transaction, the new value is stored only if x has not been modified in the mean time.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_cas!(x, 4, 2);\n\njulia> x\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_cas!(x, 3, 2);\n\njulia> x\nBase.Threads.Atomic{Int64}(2)\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#Base.Threads.atomic_xchg!","page":"Multi-Threading","title":"Base.Threads.atomic_xchg!","text":"Threads.atomic_xchg!(x::Atomic{T}, newval::T) where T\n\nAtomically exchange the value in x\n\nAtomically exchanges the value in x with newval. Returns the old value.\n\nFor further details, see LLVM's atomicrmw xchg instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_xchg!(x, 2)\n3\n\njulia> x[]\n2\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#Base.Threads.atomic_add!","page":"Multi-Threading","title":"Base.Threads.atomic_add!","text":"Threads.atomic_add!(x::Atomic{T}, val::T) where T <: ArithmeticTypes\n\nAtomically add val to x\n\nPerforms x[] += val atomically. Returns the old value. Not defined for Atomic{Bool}.\n\nFor further details, see LLVM's atomicrmw add instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_add!(x, 2)\n3\n\njulia> x[]\n5\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#Base.Threads.atomic_sub!","page":"Multi-Threading","title":"Base.Threads.atomic_sub!","text":"Threads.atomic_sub!(x::Atomic{T}, val::T) where T <: ArithmeticTypes\n\nAtomically subtract val from x\n\nPerforms x[] -= val atomically. Returns the old value. Not defined for Atomic{Bool}.\n\nFor further details, see LLVM's atomicrmw sub instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_sub!(x, 2)\n3\n\njulia> x[]\n1\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#Base.Threads.atomic_and!","page":"Multi-Threading","title":"Base.Threads.atomic_and!","text":"Threads.atomic_and!(x::Atomic{T}, val::T) where T\n\nAtomically bitwise-and x with val\n\nPerforms x[] &= val atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw and instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_and!(x, 2)\n3\n\njulia> x[]\n2\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#Base.Threads.atomic_nand!","page":"Multi-Threading","title":"Base.Threads.atomic_nand!","text":"Threads.atomic_nand!(x::Atomic{T}, val::T) where T\n\nAtomically bitwise-nand (not-and) x with val\n\nPerforms x[] = ~(x[] & val) atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw nand instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_nand!(x, 2)\n3\n\njulia> x[]\n-3\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#Base.Threads.atomic_or!","page":"Multi-Threading","title":"Base.Threads.atomic_or!","text":"Threads.atomic_or!(x::Atomic{T}, val::T) where T\n\nAtomically bitwise-or x with val\n\nPerforms x[] |= val atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw or instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(5)\nBase.Threads.Atomic{Int64}(5)\n\njulia> Threads.atomic_or!(x, 7)\n5\n\njulia> x[]\n7\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#Base.Threads.atomic_xor!","page":"Multi-Threading","title":"Base.Threads.atomic_xor!","text":"Threads.atomic_xor!(x::Atomic{T}, val::T) where T\n\nAtomically bitwise-xor (exclusive-or) x with val\n\nPerforms x[] $= val atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw xor instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(5)\nBase.Threads.Atomic{Int64}(5)\n\njulia> Threads.atomic_xor!(x, 7)\n5\n\njulia> x[]\n2\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#Base.Threads.atomic_max!","page":"Multi-Threading","title":"Base.Threads.atomic_max!","text":"Threads.atomic_max!(x::Atomic{T}, val::T) where T\n\nAtomically store the maximum of x and val in x\n\nPerforms x[] = max(x[], val) atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw max instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(5)\nBase.Threads.Atomic{Int64}(5)\n\njulia> Threads.atomic_max!(x, 7)\n5\n\njulia> x[]\n7\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#Base.Threads.atomic_min!","page":"Multi-Threading","title":"Base.Threads.atomic_min!","text":"Threads.atomic_min!(x::Atomic{T}, val::T) where T\n\nAtomically store the minimum of x and val in x\n\nPerforms x[] = min(x[], val) atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw min instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(7)\nBase.Threads.Atomic{Int64}(7)\n\njulia> Threads.atomic_min!(x, 5)\n7\n\njulia> x[]\n5\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#Base.Threads.atomic_fence","page":"Multi-Threading","title":"Base.Threads.atomic_fence","text":"Threads.atomic_fence()\n\nInsert a sequential-consistency memory fence\n\nInserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.\n\nThis is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.\n\nFor further details, see LLVM's fence instruction.\n\n\n\n\n\n","category":"function"},{"location":"base/multi-threading.html#ccall-using-a-threadpool-(Experimental)-1","page":"Multi-Threading","title":"ccall using a threadpool (Experimental)","text":"","category":"section"},{"location":"base/multi-threading.html#","page":"Multi-Threading","title":"Multi-Threading","text":"Base.@threadcall","category":"page"},{"location":"base/multi-threading.html#Base.@threadcall","page":"Multi-Threading","title":"Base.@threadcall","text":"@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)\n\nThe @threadcall macro is called in the same way as ccall but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main julia thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the UV_THREADPOOL_SIZE environment variable and restarting the julia process.\n\nNote that the called function should never call back into Julia.\n\n\n\n\n\n","category":"macro"},{"location":"base/multi-threading.html#Low-level-synchronization-primitives-1","page":"Multi-Threading","title":"Low-level synchronization primitives","text":"","category":"section"},{"location":"base/multi-threading.html#","page":"Multi-Threading","title":"Multi-Threading","text":"These building blocks are used to create the regular synchronization objects.","category":"page"},{"location":"base/multi-threading.html#","page":"Multi-Threading","title":"Multi-Threading","text":"Base.Threads.Mutex\nBase.Threads.SpinLock","category":"page"},{"location":"base/multi-threading.html#Base.Threads.Mutex","page":"Multi-Threading","title":"Base.Threads.Mutex","text":"Mutex()\n\nThese are standard system mutexes for locking critical sections of logic.\n\nOn Windows, this is a critical section object, on pthreads, this is a pthread_mutex_t.\n\nSee also SpinLock for a lighter-weight lock.\n\n\n\n\n\n","category":"type"},{"location":"base/multi-threading.html#Base.Threads.SpinLock","page":"Multi-Threading","title":"Base.Threads.SpinLock","text":"SpinLock()\n\nCreate a non-reentrant lock. Recursive use will result in a deadlock. Each lock must be matched with an unlock.\n\nTest-and-test-and-set spin locks are quickest up to about 30ish contending threads. If you have more contention than that, perhaps a lock is the wrong way to synchronize.\n\nSee also Mutex for a more efficient version on one core or if the lock may be held for a considerable length of time.\n\n\n\n\n\n","category":"type"},{"location":"base/constants.html#lib-constants-1","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"base/constants.html#","page":"Constants","title":"Constants","text":"Core.nothing\nBase.PROGRAM_FILE\nBase.ARGS\nBase.C_NULL\nBase.VERSION\nBase.DEPOT_PATH\nBase.LOAD_PATH\nBase.Sys.BINDIR\nBase.Sys.CPU_THREADS\nBase.Sys.WORD_SIZE\nBase.Sys.KERNEL\nBase.Sys.ARCH\nBase.Sys.MACHINE","category":"page"},{"location":"base/constants.html#Core.nothing","page":"Constants","title":"Core.nothing","text":"nothing\n\nThe singleton instance of type Nothing, used by convention when there is no value to return (as in a C void function) or when a variable or field holds no value.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Base.PROGRAM_FILE","page":"Constants","title":"Base.PROGRAM_FILE","text":"PROGRAM_FILE\n\nA string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see @__FILE__.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Base.ARGS","page":"Constants","title":"Base.ARGS","text":"ARGS\n\nAn array of the command line arguments passed to Julia, as strings.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Base.C_NULL","page":"Constants","title":"Base.C_NULL","text":"C_NULL\n\nThe C null pointer constant, sometimes used when calling external code.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Base.VERSION","page":"Constants","title":"Base.VERSION","text":"VERSION\n\nA VersionNumber object describing which version of Julia is in use. For details see Version Number Literals.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Base.DEPOT_PATH","page":"Constants","title":"Base.DEPOT_PATH","text":"DEPOT_PATH\n\nA stack of \"depot\" locations where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. By default it includes:\n\n~/.julia where ~ is the user home as appropriate on the system;\nan architecture-specific shared system directory, e.g. /usr/local/share/julia;\nan architecture-independent shared system directory, e.g. /usr/share/julia.\n\nSo DEPOT_PATH might be:\n\n[joinpath(homedir(), \".julia\"), \"/usr/local/share/julia\", \"/usr/share/julia\"]\n\nThe first entry is the \"user depot\" and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.\n\nDEPOT_PATH is populated based on the JULIA_DEPOT_PATH environment variable if set.\n\nSee also: JULIA_DEPOT_PATH, and Code Loading.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Base.LOAD_PATH","page":"Constants","title":"Base.LOAD_PATH","text":"LOAD_PATH\n\nAn array of paths for using and import statements to consider as project environments or package directories when loading code. It is populated based on the JULIA_LOAD_PATH environment variable if set; otherwise it defaults to [\"@\", \"@v#.#\", \"@stdlib\"]. Entries starting with @ have special meanings:\n\n@ refers to the \"current active environment\", the initial value of which is initially determined by the JULIA_PROJECT environment variable or the --project command-line option.\n@stdlib expands to the absolute path of the current Julia installation's standard library directory.\n@name refers to a named environment, which are stored in depots (see JULIA_DEPOT_PATH) under the environments subdirectory. The user's named environments are stored in ~/.julia/environments so @name would refer to the environment in ~/.julia/environments/name if it exists and contains a Project.toml file. If name contains # characters, then they are replaced with the major, minor and patch components of the Julia version number. For example, if you are running Julia 1.2 then @v#.# expands to @v1.2 and will look for an environment by that name, typically at ~/.julia/environments/v1.2.\n\nThe fully expanded value of LOAD_PATH that is searched for projects and packages can be seen by calling the Base.load_path() function.\n\nSee also: JULIA_LOAD_PATH, JULIA_PROJECT, JULIA_DEPOT_PATH, and Code Loading.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Base.Sys.BINDIR","page":"Constants","title":"Base.Sys.BINDIR","text":"Sys.BINDIR\n\nA string containing the full path to the directory containing the julia executable.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Base.Sys.CPU_THREADS","page":"Constants","title":"Base.Sys.CPU_THREADS","text":"Sys.CPU_THREADS\n\nThe number of logical CPU cores available in the system, i.e. the number of threads that the CPU can run concurrently. Note that this is not necessarily the number of CPU cores, for example, in the presence of hyper-threading.\n\nSee Hwloc.jl or CpuId.jl for extended information, including number of physical cores.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Base.Sys.WORD_SIZE","page":"Constants","title":"Base.Sys.WORD_SIZE","text":"Sys.WORD_SIZE\n\nStandard word size on the current machine, in bits.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Base.Sys.KERNEL","page":"Constants","title":"Base.Sys.KERNEL","text":"Sys.KERNEL\n\nA symbol representing the name of the operating system, as returned by uname of the build configuration.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Base.Sys.ARCH","page":"Constants","title":"Base.Sys.ARCH","text":"Sys.ARCH\n\nA symbol representing the architecture of the build configuration.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Base.Sys.MACHINE","page":"Constants","title":"Base.Sys.MACHINE","text":"Sys.MACHINE\n\nA string containing the build triple.\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#","page":"Constants","title":"Constants","text":"See also:","category":"page"},{"location":"base/constants.html#","page":"Constants","title":"Constants","text":"stdin\nstdout\nstderr\nENV\nENDIAN_BOM\nLibc.MS_ASYNC\nLibc.MS_INVALIDATE\nLibc.MS_SYNC","category":"page"},{"location":"base/file.html#Filesystem-1","page":"Filesystem","title":"Filesystem","text":"","category":"section"},{"location":"base/file.html#","page":"Filesystem","title":"Filesystem","text":"Base.Filesystem.pwd\nBase.Filesystem.cd(::AbstractString)\nBase.Filesystem.cd(::Function)\nBase.Filesystem.readdir\nBase.Filesystem.walkdir\nBase.Filesystem.mkdir\nBase.Filesystem.mkpath\nBase.Filesystem.symlink\nBase.Filesystem.readlink\nBase.Filesystem.chmod\nBase.Filesystem.chown\nBase.RawFD\nBase.stat\nBase.Filesystem.lstat\nBase.Filesystem.ctime\nBase.Filesystem.mtime\nBase.Filesystem.filemode\nBase.Filesystem.filesize\nBase.Filesystem.uperm\nBase.Filesystem.gperm\nBase.Filesystem.operm\nBase.Filesystem.cp\nBase.download\nBase.Filesystem.mv\nBase.Filesystem.rm\nBase.Filesystem.touch\nBase.Filesystem.tempname\nBase.Filesystem.tempdir\nBase.Filesystem.mktemp(::Any)\nBase.Filesystem.mktemp(::Function, ::Any)\nBase.Filesystem.mktempdir(::Any)\nBase.Filesystem.mktempdir(::Function, ::Any)\nBase.Filesystem.isblockdev\nBase.Filesystem.ischardev\nBase.Filesystem.isdir\nBase.Filesystem.isfifo\nBase.Filesystem.isfile\nBase.Filesystem.islink\nBase.Filesystem.ismount\nBase.Filesystem.ispath\nBase.Filesystem.issetgid\nBase.Filesystem.issetuid\nBase.Filesystem.issocket\nBase.Filesystem.issticky\nBase.Filesystem.homedir\nBase.Filesystem.dirname\nBase.Filesystem.basename\nBase.@__FILE__\nBase.@__DIR__\nBase.@__LINE__\nBase.Filesystem.isabspath\nBase.Filesystem.isdirpath\nBase.Filesystem.joinpath\nBase.Filesystem.abspath\nBase.Filesystem.normpath\nBase.Filesystem.realpath\nBase.Filesystem.relpath\nBase.Filesystem.expanduser\nBase.Filesystem.splitdir\nBase.Filesystem.splitdrive\nBase.Filesystem.splitext\nBase.Filesystem.splitpath","category":"page"},{"location":"base/file.html#Base.Filesystem.pwd","page":"Filesystem","title":"Base.Filesystem.pwd","text":"pwd() -> AbstractString\n\nGet the current working directory.\n\nExamples\n\njulia> pwd()\n\"/home/JuliaUser\"\n\njulia> cd(\"/home/JuliaUser/Projects/julia\")\n\njulia> pwd()\n\"/home/JuliaUser/Projects/julia\"\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.cd-Tuple{AbstractString}","page":"Filesystem","title":"Base.Filesystem.cd","text":"cd(dir::AbstractString=homedir())\n\nSet the current working directory.\n\nExamples\n\njulia> cd(\"/home/JuliaUser/Projects/julia\")\n\njulia> pwd()\n\"/home/JuliaUser/Projects/julia\"\n\njulia> cd()\n\njulia> pwd()\n\"/home/JuliaUser\"\n\n\n\n\n\n","category":"method"},{"location":"base/file.html#Base.Filesystem.cd-Tuple{Function}","page":"Filesystem","title":"Base.Filesystem.cd","text":"cd(f::Function, dir::AbstractString=homedir())\n\nTemporarily change the current working directory to dir, apply function f and finally return to the original directory.\n\nExamples\n\njulia> pwd()\n\"/home/JuliaUser\"\n\njulia> cd(readdir, \"/home/JuliaUser/Projects/julia\")\n34-element Array{String,1}:\n \".circleci\"\n \".freebsdci.sh\"\n \".git\"\n \".gitattributes\"\n \".github\"\n ⋮\n \"test\"\n \"ui\"\n \"usr\"\n \"usr-staging\"\n\njulia> pwd()\n\"/home/JuliaUser\"\n\n\n\n\n\n","category":"method"},{"location":"base/file.html#Base.Filesystem.readdir","page":"Filesystem","title":"Base.Filesystem.readdir","text":"readdir(dir::AbstractString=\".\") -> Vector{String}\n\nReturn the files and directories in the directory dir (or the current working directory if not given).\n\nExamples\n\njulia> readdir(\"/home/JuliaUser/Projects/julia\")\n34-element Array{String,1}:\n \".circleci\"\n \".freebsdci.sh\"\n \".git\"\n \".gitattributes\"\n \".github\"\n ⋮\n \"test\"\n \"ui\"\n \"usr\"\n \"usr-staging\"\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.walkdir","page":"Filesystem","title":"Base.Filesystem.walkdir","text":"walkdir(dir; topdown=true, follow_symlinks=false, onerror=throw)\n\nReturn an iterator that walks the directory tree of a directory. The iterator returns a tuple containing (rootpath, dirs, files). The directory tree can be traversed top-down or bottom-up. If walkdir encounters a SystemError it will rethrow the error by default. A custom error handling function can be provided through onerror keyword argument. onerror is called with a SystemError as argument.\n\nExamples\n\nfor (root, dirs, files) in walkdir(\".\")\n    println(\"Directories in $root\")\n    for dir in dirs\n        println(joinpath(root, dir)) # path to directories\n    end\n    println(\"Files in $root\")\n    for file in files\n        println(joinpath(root, file)) # path to files\n    end\nend\n\njulia> mkpath(\"my/test/dir\");\n\njulia> itr = walkdir(\"my\");\n\njulia> (root, dirs, files) = first(itr)\n(\"my\", [\"test\"], String[])\n\njulia> (root, dirs, files) = first(itr)\n(\"my/test\", [\"dir\"], String[])\n\njulia> (root, dirs, files) = first(itr)\n(\"my/test/dir\", String[], String[])\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.mkdir","page":"Filesystem","title":"Base.Filesystem.mkdir","text":"mkdir(path::AbstractString; mode::Unsigned = 0o777)\n\nMake a new directory with name path and permissions mode. mode defaults to 0o777, modified by the current file creation mask. This function never creates more than one directory. If the directory already exists, or some intermediate directories do not exist, this function throws an error. See mkpath for a function which creates all required intermediate directories. Return path.\n\nExamples\n\njulia> mkdir(\"testingdir\")\n\"testingdir\"\n\njulia> cd(\"testingdir\")\n\njulia> pwd()\n\"/home/JuliaUser/testingdir\"\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.mkpath","page":"Filesystem","title":"Base.Filesystem.mkpath","text":"mkpath(path::AbstractString; mode::Unsigned = 0o777)\n\nCreate all directories in the given path, with permissions mode. mode defaults to 0o777, modified by the current file creation mask. Return path.\n\nExamples\n\njulia> mkdir(\"testingdir\")\n\"testingdir\"\n\njulia> cd(\"testingdir\")\n\njulia> pwd()\n\"/home/JuliaUser/testingdir\"\n\njulia> mkpath(\"my/test/dir\")\n\"my/test/dir\"\n\njulia> readdir()\n1-element Array{String,1}:\n \"my\"\n\njulia> cd(\"my\")\n\njulia> readdir()\n1-element Array{String,1}:\n \"test\"\n\njulia> readdir(\"test\")\n1-element Array{String,1}:\n \"dir\"\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.symlink","page":"Filesystem","title":"Base.Filesystem.symlink","text":"symlink(target::AbstractString, link::AbstractString)\n\nCreates a symbolic link to target with the name link.\n\nnote: Note\nThis function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.readlink","page":"Filesystem","title":"Base.Filesystem.readlink","text":"readlink(path::AbstractString) -> AbstractString\n\nReturn the target location a symbolic link path points to.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.chmod","page":"Filesystem","title":"Base.Filesystem.chmod","text":"chmod(path::AbstractString, mode::Integer; recursive::Bool=false)\n\nChange the permissions mode of path to mode. Only integer modes (e.g. 0o777) are currently supported. If recursive=true and the path is a directory all permissions in that directory will be recursively changed. Return path.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.chown","page":"Filesystem","title":"Base.Filesystem.chown","text":"chown(path::AbstractString, owner::Integer, group::Integer=-1)\n\nChange the owner and/or group of path to owner and/or group. If the value entered for owner or group is -1 the corresponding ID will not change. Only integer owners and groups are currently supported. Return path.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Libc.RawFD","page":"Filesystem","title":"Base.Libc.RawFD","text":"RawFD\n\nPrimitive type which wraps the native OS file descriptor. RawFDs can be passed to methods like stat to discover information about the underlying file, and can also be used to open streams, with the RawFD describing the OS file backing the stream.\n\n\n\n\n\n","category":"type"},{"location":"base/file.html#Base.stat","page":"Filesystem","title":"Base.stat","text":"stat(file)\n\nReturns a structure whose fields contain information about the file. The fields of the structure are:\n\nName Description\nsize The size (in bytes) of the file\ndevice ID of the device that contains the file\ninode The inode number of the file\nmode The protection mode of the file\nnlink The number of hard links to the file\nuid The user id of the owner of the file\ngid The group id of the file owner\nrdev If this file refers to a device, the ID of the device it refers to\nblksize The file-system preferred block size for the file\nblocks The number of such blocks allocated\nmtime Unix timestamp of when the file was last modified\nctime Unix timestamp of when the file was created\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.lstat","page":"Filesystem","title":"Base.Filesystem.lstat","text":"lstat(file)\n\nLike stat, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.ctime","page":"Filesystem","title":"Base.Filesystem.ctime","text":"ctime(file)\n\nEquivalent to stat(file).ctime.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.mtime","page":"Filesystem","title":"Base.Filesystem.mtime","text":"mtime(file)\n\nEquivalent to stat(file).mtime.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.filemode","page":"Filesystem","title":"Base.Filesystem.filemode","text":"filemode(file)\n\nEquivalent to stat(file).mode.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.filesize","page":"Filesystem","title":"Base.Filesystem.filesize","text":"filesize(path...)\n\nEquivalent to stat(file).size.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.uperm","page":"Filesystem","title":"Base.Filesystem.uperm","text":"uperm(file)\n\nGet the permissions of the owner of the file as a bitfield of\n\nValue Description\n01 Execute Permission\n02 Write Permission\n04 Read Permission\n\nFor allowed arguments, see stat.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.gperm","page":"Filesystem","title":"Base.Filesystem.gperm","text":"gperm(file)\n\nLike uperm but gets the permissions of the group owning the file.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.operm","page":"Filesystem","title":"Base.Filesystem.operm","text":"operm(file)\n\nLike uperm but gets the permissions for people who neither own the file nor are a member of the group owning the file\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.cp","page":"Filesystem","title":"Base.Filesystem.cp","text":"cp(src::AbstractString, dst::AbstractString; force::Bool=false, follow_symlinks::Bool=false)\n\nCopy the file, link, or directory from src to dst. force=true will first remove an existing dst.\n\nIf follow_symlinks=false, and src is a symbolic link, dst will be created as a symbolic link. If follow_symlinks=true and src is a symbolic link, dst will be a copy of the file or directory src refers to. Return dst.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.download","page":"Filesystem","title":"Base.download","text":"download(url::AbstractString, [localfile::AbstractString])\n\nDownload a file from the given url, optionally renaming it to the given local file name. If no filename is given this will download into a randomly-named file in your temp directory. Note that this function relies on the availability of external tools such as curl, wget or fetch to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.\n\nReturns the filename of the downloaded file.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.mv","page":"Filesystem","title":"Base.Filesystem.mv","text":"mv(src::AbstractString, dst::AbstractString; force::Bool=false)\n\nMove the file, link, or directory from src to dst. force=true will first remove an existing dst. Return dst.\n\nExamples\n\njulia> write(\"hello.txt\", \"world\");\n\njulia> mv(\"hello.txt\", \"goodbye.txt\")\n\"goodbye.txt\"\n\njulia> \"hello.txt\" in readdir()\nfalse\n\njulia> readline(\"goodbye.txt\")\n\"world\"\n\njulia> write(\"hello.txt\", \"world2\");\n\njulia> mv(\"hello.txt\", \"goodbye.txt\")\nERROR: ArgumentError: 'goodbye.txt' exists. `force=true` is required to remove 'goodbye.txt' before moving.\nStacktrace:\n [1] #checkfor_mv_cp_cptree#10(::Bool, ::Function, ::String, ::String, ::String) at ./file.jl:293\n[...]\n\njulia> mv(\"hello.txt\", \"goodbye.txt\", force=true)\n\"goodbye.txt\"\n\njulia> rm(\"goodbye.txt\");\n\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.rm","page":"Filesystem","title":"Base.Filesystem.rm","text":"rm(path::AbstractString; force::Bool=false, recursive::Bool=false)\n\nDelete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.\n\nExamples\n\njulia> mkpath(\"my/test/dir\");\n\njulia> rm(\"my\", recursive=true)\n\njulia> rm(\"this_file_does_not_exist\", force=true)\n\njulia> rm(\"this_file_does_not_exist\")\nERROR: IOError: unlink: no such file or directory (ENOENT)\nStacktrace:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.touch","page":"Filesystem","title":"Base.Filesystem.touch","text":"touch(path::AbstractString)\n\nUpdate the last-modified timestamp on a file to the current time. Return path.\n\nExamples\n\njulia> write(\"my_little_file\", 2);\n\njulia> mtime(\"my_little_file\")\n1.5273815391135583e9\n\njulia> touch(\"my_little_file\");\n\njulia> mtime(\"my_little_file\")\n1.527381559163435e9\n\nWe can see the mtime has been modified by touch.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.tempname","page":"Filesystem","title":"Base.Filesystem.tempname","text":"tempname()\n\nGenerate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed.\n\nwarning: Warning\nThis can lead to race conditions if another process obtains the same file name and creates the file before you are able to. Using mktemp() is recommended instead.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.tempdir","page":"Filesystem","title":"Base.Filesystem.tempdir","text":"tempdir()\n\nObtain the path of a temporary directory (possibly shared with other processes).\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.mktemp-Tuple{Any}","page":"Filesystem","title":"Base.Filesystem.mktemp","text":"mktemp(parent=tempdir())\n\nReturn (path, io), where path is the path of a new temporary file in parent and io is an open file object for this path.\n\n\n\n\n\n","category":"method"},{"location":"base/file.html#Base.Filesystem.mktemp-Tuple{Function,Any}","page":"Filesystem","title":"Base.Filesystem.mktemp","text":"mktemp(f::Function, parent=tempdir())\n\nApply the function f to the result of mktemp(parent) and remove the temporary file upon completion.\n\n\n\n\n\n","category":"method"},{"location":"base/file.html#Base.Filesystem.mktempdir-Tuple{Any}","page":"Filesystem","title":"Base.Filesystem.mktempdir","text":"mktempdir(parent=tempdir(); prefix=\"jl_\")\n\nCreate a temporary directory in the parent directory with a name constructed from the given prefix and a random suffix, and return its path. Additionally, any trailing X characters may be replaced with random characters. If parent does not exist, throw an error.\n\n\n\n\n\n","category":"method"},{"location":"base/file.html#Base.Filesystem.mktempdir-Tuple{Function,Any}","page":"Filesystem","title":"Base.Filesystem.mktempdir","text":"mktempdir(f::Function, parent=tempdir(); prefix=\"jl_\")\n\nApply the function f to the result of mktempdir(parent; prefix) and remove the temporary directory all of its contents upon completion.\n\n\n\n\n\n","category":"method"},{"location":"base/file.html#Base.Filesystem.isblockdev","page":"Filesystem","title":"Base.Filesystem.isblockdev","text":"isblockdev(path) -> Bool\n\nReturn true if path is a block device, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.ischardev","page":"Filesystem","title":"Base.Filesystem.ischardev","text":"ischardev(path) -> Bool\n\nReturn true if path is a character device, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.isdir","page":"Filesystem","title":"Base.Filesystem.isdir","text":"isdir(path) -> Bool\n\nReturn true if path is a directory, false otherwise.\n\nExamples\n\njulia> isdir(homedir())\ntrue\n\njulia> isdir(\"not/a/directory\")\nfalse\n\nSee also: isfile and ispath.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.isfifo","page":"Filesystem","title":"Base.Filesystem.isfifo","text":"isfifo(path) -> Bool\n\nReturn true if path is a FIFO, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.isfile","page":"Filesystem","title":"Base.Filesystem.isfile","text":"isfile(path) -> Bool\n\nReturn true if path is a regular file, false otherwise.\n\nExamples\n\njulia> isfile(homedir())\nfalse\n\njulia> f = open(\"test_file.txt\", \"w\");\n\njulia> isfile(f)\ntrue\n\njulia> close(f); rm(\"test_file.txt\")\n\nSee also: isdir and ispath.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.islink","page":"Filesystem","title":"Base.Filesystem.islink","text":"islink(path) -> Bool\n\nReturn true if path is a symbolic link, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.ismount","page":"Filesystem","title":"Base.Filesystem.ismount","text":"ismount(path) -> Bool\n\nReturn true if path is a mount point, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.ispath","page":"Filesystem","title":"Base.Filesystem.ispath","text":"ispath(path) -> Bool\n\nReturn true if a valid filesystem entity exists at path, otherwise returns false. This is the generalization of isfile, isdir etc.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.issetgid","page":"Filesystem","title":"Base.Filesystem.issetgid","text":"issetgid(path) -> Bool\n\nReturn true if path has the setgid flag set, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.issetuid","page":"Filesystem","title":"Base.Filesystem.issetuid","text":"issetuid(path) -> Bool\n\nReturn true if path has the setuid flag set, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.issocket","page":"Filesystem","title":"Base.Filesystem.issocket","text":"issocket(path) -> Bool\n\nReturn true if path is a socket, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.issticky","page":"Filesystem","title":"Base.Filesystem.issticky","text":"issticky(path) -> Bool\n\nReturn true if path has the sticky bit set, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.homedir","page":"Filesystem","title":"Base.Filesystem.homedir","text":"homedir() -> AbstractString\n\nReturn the current user's home directory.\n\nnote: Note\nhomedir determines the home directory via libuv's uv_os_homedir. For details (for example on how to specify the home directory via environment variables), see the uv_os_homedir documentation.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.dirname","page":"Filesystem","title":"Base.Filesystem.dirname","text":"dirname(path::AbstractString) -> AbstractString\n\nGet the directory part of a path. Trailing characters ('/' or '\\') in the path are counted as part of the path.\n\nExamples\n\njulia> dirname(\"/home/myuser\")\n\"/home\"\n\njulia> dirname(\"/home/myuser/\")\n\"/home/myuser\"\n\nSee also: basename\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.basename","page":"Filesystem","title":"Base.Filesystem.basename","text":"basename(path::AbstractString) -> AbstractString\n\nGet the file name part of a path.\n\nExamples\n\njulia> basename(\"/home/myuser/example.jl\")\n\"example.jl\"\n\nSee also: dirname\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.@__FILE__","page":"Filesystem","title":"Base.@__FILE__","text":"@__FILE__ -> AbstractString\n\nExpand to a string with the path to the file containing the macrocall, or an empty string if evaluated by julia -e <expr>. Return nothing if the macro was missing parser source information. Alternatively see PROGRAM_FILE.\n\n\n\n\n\n","category":"macro"},{"location":"base/file.html#Base.@__DIR__","page":"Filesystem","title":"Base.@__DIR__","text":"@__DIR__ -> AbstractString\n\nExpand to a string with the absolute path to the directory of the file containing the macrocall. Return the current working directory if run from a REPL or if evaluated by julia -e <expr>.\n\n\n\n\n\n","category":"macro"},{"location":"base/file.html#Base.@__LINE__","page":"Filesystem","title":"Base.@__LINE__","text":"@__LINE__ -> Int\n\nExpand to the line number of the location of the macrocall. Return 0 if the line number could not be determined.\n\n\n\n\n\n","category":"macro"},{"location":"base/file.html#Base.Filesystem.isabspath","page":"Filesystem","title":"Base.Filesystem.isabspath","text":"isabspath(path::AbstractString) -> Bool\n\nDetermine whether a path is absolute (begins at the root directory).\n\nExamples\n\njulia> isabspath(\"/home\")\ntrue\n\njulia> isabspath(\"home\")\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.isdirpath","page":"Filesystem","title":"Base.Filesystem.isdirpath","text":"isdirpath(path::AbstractString) -> Bool\n\nDetermine whether a path refers to a directory (for example, ends with a path separator).\n\nExamples\n\njulia> isdirpath(\"/home\")\nfalse\n\njulia> isdirpath(\"/home/\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.joinpath","page":"Filesystem","title":"Base.Filesystem.joinpath","text":"joinpath(parts...) -> AbstractString\n\nJoin path components into a full path. If some argument is an absolute path or (on Windows) has a drive specification that doesn't match the drive computed for the join of the preceding paths, then prior components are dropped.\n\nExamples\n\njulia> joinpath(\"/home/myuser\", \"example.jl\")\n\"/home/myuser/example.jl\"\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.abspath","page":"Filesystem","title":"Base.Filesystem.abspath","text":"abspath(path::AbstractString) -> AbstractString\n\nConvert a path to an absolute path by adding the current directory if necessary. Also normalizes the path as in normpath.\n\n\n\n\n\nabspath(path::AbstractString, paths::AbstractString...) -> AbstractString\n\nConvert a set of paths to an absolute path by joining them together and adding the current directory if necessary. Equivalent to abspath(joinpath(path, paths...)).\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.normpath","page":"Filesystem","title":"Base.Filesystem.normpath","text":"normpath(path::AbstractString) -> AbstractString\n\nNormalize a path, removing \".\" and \"..\" entries.\n\nExamples\n\njulia> normpath(\"/home/myuser/../example.jl\")\n\"/home/example.jl\"\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.realpath","page":"Filesystem","title":"Base.Filesystem.realpath","text":"realpath(path::AbstractString) -> AbstractString\n\nCanonicalize a path by expanding symbolic links and removing \".\" and \"..\" entries. On case-insensitive case-preserving filesystems (typically Mac and Windows), the filesystem's stored case for the path is returned.\n\n(This function throws an exception if path does not exist in the filesystem.)\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.relpath","page":"Filesystem","title":"Base.Filesystem.relpath","text":"relpath(path::AbstractString, startpath::AbstractString = \".\") -> AbstractString\n\nReturn a relative filepath to path either from the current directory or from an optional start directory. This is a path computation: the filesystem is not accessed to confirm the existence or nature of path or startpath.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.expanduser","page":"Filesystem","title":"Base.Filesystem.expanduser","text":"expanduser(path::AbstractString) -> AbstractString\n\nOn Unix systems, replace a tilde character at the start of a path with the current user's home directory.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.splitdir","page":"Filesystem","title":"Base.Filesystem.splitdir","text":"splitdir(path::AbstractString) -> (AbstractString, AbstractString)\n\nSplit a path into a tuple of the directory name and file name.\n\nExamples\n\njulia> splitdir(\"/home/myuser\")\n(\"/home\", \"myuser\")\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.splitdrive","page":"Filesystem","title":"Base.Filesystem.splitdrive","text":"splitdrive(path::AbstractString) -> (AbstractString, AbstractString)\n\nOn Windows, split a path into the drive letter part and the path part. On Unix systems, the first component is always the empty string.\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.splitext","page":"Filesystem","title":"Base.Filesystem.splitext","text":"splitext(path::AbstractString) -> (AbstractString, AbstractString)\n\nIf the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.\n\nExamples\n\njulia> splitext(\"/home/myuser/example.jl\")\n(\"/home/myuser/example\", \".jl\")\n\njulia> splitext(\"/home/myuser/example\")\n(\"/home/myuser/example\", \"\")\n\n\n\n\n\n","category":"function"},{"location":"base/file.html#Base.Filesystem.splitpath","page":"Filesystem","title":"Base.Filesystem.splitpath","text":"splitpath(path::AbstractString) -> Vector{String}\n\nSplit a file path into all its path components. This is the opposite of joinpath. Returns an array of substrings, one for each directory or file in the path, including the root directory if present.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nExamples\n\njulia> splitpath(\"/home/myuser/example.jl\")\n4-element Array{String,1}:\n \"/\"\n \"home\"\n \"myuser\"\n \"example.jl\"\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#I/O-and-Network-1","page":"I/O and Network","title":"I/O and Network","text":"","category":"section"},{"location":"base/io-network.html#General-I/O-1","page":"I/O and Network","title":"General I/O","text":"","category":"section"},{"location":"base/io-network.html#","page":"I/O and Network","title":"I/O and Network","text":"Base.stdout\nBase.stderr\nBase.stdin\nBase.open\nBase.IOStream\nBase.IOBuffer\nBase.take!(::Base.GenericIOBuffer)\nBase.fdio\nBase.flush\nBase.close\nBase.write\nBase.read\nBase.read!\nBase.readbytes!\nBase.unsafe_read\nBase.unsafe_write\nBase.position\nBase.seek\nBase.seekstart\nBase.seekend\nBase.skip\nBase.mark\nBase.unmark\nBase.reset\nBase.ismarked\nBase.eof\nBase.isreadonly\nBase.iswritable\nBase.isreadable\nBase.isopen\nBase.Grisu.print_shortest\nBase.fd\nBase.redirect_stdout\nBase.redirect_stdout(::Function, ::Any)\nBase.redirect_stderr\nBase.redirect_stderr(::Function, ::Any)\nBase.redirect_stdin\nBase.redirect_stdin(::Function, ::Any)\nBase.readchomp\nBase.truncate\nBase.skipchars\nBase.countlines\nBase.PipeBuffer\nBase.readavailable\nBase.IOContext\nBase.IOContext(::IO, ::Pair)\nBase.IOContext(::IO, ::IOContext)","category":"page"},{"location":"base/io-network.html#Base.stdout","page":"I/O and Network","title":"Base.stdout","text":"stdout\n\nGlobal variable referring to the standard out stream.\n\n\n\n\n\n","category":"constant"},{"location":"base/io-network.html#Base.stderr","page":"I/O and Network","title":"Base.stderr","text":"stderr\n\nGlobal variable referring to the standard error stream.\n\n\n\n\n\n","category":"constant"},{"location":"base/io-network.html#Base.stdin","page":"I/O and Network","title":"Base.stdin","text":"stdin\n\nGlobal variable referring to the standard input stream.\n\n\n\n\n\n","category":"constant"},{"location":"base/io-network.html#Base.open","page":"I/O and Network","title":"Base.open","text":"open(filename::AbstractString; keywords...) -> IOStream\n\nOpen a file in a mode specified by five boolean keyword arguments:\n\nKeyword Description Default\nread open for reading !write\nwrite open for writing truncate | append\ncreate create if non-existent !read & write | truncate | append\ntruncate truncate to zero size !read & write\nappend seek to end false\n\nThe default when no keywords are passed is to open files for reading only. Returns a stream for accessing the opened file.\n\n\n\n\n\nopen(filename::AbstractString, [mode::AbstractString]) -> IOStream\n\nAlternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of mode correspond to those from fopen(3) or Perl open, and are equivalent to setting the following boolean groups:\n\nMode Description Keywords\nr read none\nw write, create, truncate write = true\na write, create, append append = true\nr+ read, write read = true, write = true\nw+ read, write, create, truncate truncate = true, read = true\na+ read, write, create, append append = true, read = true\n\nExamples\n\njulia> io = open(\"myfile.txt\", \"w\");\n\njulia> write(io, \"Hello world!\");\n\njulia> close(io);\n\njulia> io = open(\"myfile.txt\", \"r\");\n\njulia> read(io, String)\n\"Hello world!\"\n\njulia> write(io, \"This file is read only\")\nERROR: ArgumentError: write failed, IOStream is not writeable\n[...]\n\njulia> close(io)\n\njulia> io = open(\"myfile.txt\", \"a\");\n\njulia> write(io, \"This stream is not read only\")\n28\n\njulia> close(io)\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\nopen(f::Function, args...; kwargs....)\n\nApply the function f to the result of open(args...; kwargs...) and close the resulting file descriptor upon completion.\n\nExamples\n\njulia> open(\"myfile.txt\", \"w\") do io\n           write(io, \"Hello world!\")\n       end;\n\njulia> open(f->read(f, String), \"myfile.txt\")\n\"Hello world!\"\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\nopen(fd::OS_HANDLE) -> IO\n\nTake a raw file descriptor wrap it in a Julia-aware IO type, and take ownership of the fd handle. Call open(Libc.dup(fd)) to avoid the ownership capture of the original handle.\n\nwarn: Warn\nDo not call this on a handle that's already owned by some other part of the system.\n\n\n\n\n\nopen(command, other=devnull; write::Bool = false, read::Bool = !write)\n\nStart running command asynchronously, and return a process::IO object.  If read is true, then reads from the process come from the process's standard output and other optionally specifies the process's standard input stream.  If write is true, then writes go to the process's standard input and other optionally specifies the process's standard output stream. The process's standard error stream is connected to the current global stderr.\n\n\n\n\n\nopen(f::Function, command, mode::AbstractString=\"r\", stdio=devnull)\n\nSimilar to open(command, mode, stdio), but calls f(stream) on the resulting process stream, then closes the input stream and waits for the process to complete. Returns the value returned by f.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.IOStream","page":"I/O and Network","title":"Base.IOStream","text":"IOStream\n\nA buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned by open.\n\n\n\n\n\n","category":"type"},{"location":"base/io-network.html#Base.IOBuffer","page":"I/O and Network","title":"Base.IOBuffer","text":"IOBuffer([data::AbstractVector{UInt8}]; keywords...) -> IOBuffer\n\nCreate an in-memory I/O stream, which may optionally operate on a pre-existing array.\n\nIt may take optional keyword arguments:\n\nread, write, append: restricts operations to the buffer; see open for details.\ntruncate: truncates the buffer size to zero length.\nmaxsize: specifies a size beyond which the buffer may not be grown.\nsizehint: suggests a capacity of the buffer (data must implement sizehint!(data, size)).\n\nWhen data is not given, the buffer will be both readable and writable by default.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization. It has many members.\"\n\njulia> io = IOBuffer(b\"JuliaLang is a GitHub organization.\")\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=35, maxsize=Inf, ptr=1, mark=-1)\n\njulia> read(io, String)\n\"JuliaLang is a GitHub organization.\"\n\njulia> write(io, \"This isn't writable.\")\nERROR: ArgumentError: ensureroom failed, IOBuffer is not writeable\n\njulia> io = IOBuffer(UInt8[], read=true, write=true, maxsize=34)\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=34, ptr=1, mark=-1)\n\njulia> write(io, \"JuliaLang is a GitHub organization.\")\n34\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization\"\n\njulia> length(read(IOBuffer(b\"data\", read=true, truncate=false)))\n4\n\njulia> length(read(IOBuffer(b\"data\", read=true, truncate=true)))\n0\n\n\n\n\n\nIOBuffer(string::String)\n\nCreate a read-only IOBuffer on the data underlying the given string.\n\nExamples\n\njulia> io = IOBuffer(\"Haho\");\n\njulia> String(take!(io))\n\"Haho\"\n\njulia> String(take!(io))\n\"Haho\"\n\n\n\n\n\n","category":"type"},{"location":"base/io-network.html#Base.take!-Tuple{Base.GenericIOBuffer}","page":"I/O and Network","title":"Base.take!","text":"take!(b::IOBuffer)\n\nObtain the contents of an IOBuffer as an array, without copying. Afterwards, the IOBuffer is reset to its initial state.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization. It has many members.\"\n\n\n\n\n\n","category":"method"},{"location":"base/io-network.html#Base.fdio","page":"I/O and Network","title":"Base.fdio","text":"fdio([name::AbstractString, ]fd::Integer[, own::Bool=false]) -> IOStream\n\nCreate an IOStream object from an integer file descriptor. If own is true, closing this object will close the underlying descriptor. By default, an IOStream is closed when it is garbage collected. name allows you to associate the descriptor with a named file.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.flush","page":"I/O and Network","title":"Base.flush","text":"flush(stream)\n\nCommit all currently buffered writes to the given stream.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.close","page":"I/O and Network","title":"Base.close","text":"close(stream)\n\nClose an I/O stream. Performs a flush first.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.write","page":"I/O and Network","title":"Base.write","text":"write(io::IO, x)\nwrite(filename::AbstractString, x)\n\nWrite the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream.   See also print to write a text representation (with an encoding that may depend upon io).\n\nYou can write multiple values with the same write call. i.e. the following are equivalent:\n\nwrite(io, x, y...)\nwrite(io, x) + write(io, y...)\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization. It has many members.\"\n\njulia> write(io, \"Sometimes those members\") + write(io, \" write documentation.\")\n44\n\njulia> String(take!(io))\n\"Sometimes those members write documentation.\"\n\nUser-defined plain-data types without write methods can be written when wrapped in a Ref:\n\njulia> struct MyStruct; x::Float64; end\n\njulia> io = IOBuffer()\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=Inf, ptr=1, mark=-1)\n\njulia> write(io, Ref(MyStruct(42.0)))\n8\n\njulia> seekstart(io); read!(io, Ref(MyStruct(NaN)))\nBase.RefValue{MyStruct}(MyStruct(42.0))\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.read","page":"I/O and Network","title":"Base.read","text":"read(io::IO, T)\n\nRead a single value of type T from io, in canonical binary representation.\n\nread(io::IO, String)\n\nRead the entirety of io, as a String.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, Char)\n'J': ASCII/Unicode U+004a (category Lu: Letter, uppercase)\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, String)\n\"JuliaLang is a GitHub organization\"\n\n\n\n\n\nread(filename::AbstractString, args...)\n\nOpen a file and read its contents. args is passed to read: this is equivalent to open(io->read(io, args...), filename).\n\nread(filename::AbstractString, String)\n\nRead the entire contents of a file as a string.\n\n\n\n\n\nread(s::IO, nb=typemax(Int))\n\nRead at most nb bytes from s, returning a Vector{UInt8} of the bytes read.\n\n\n\n\n\nread(s::IOStream, nb::Integer; all=true)\n\nRead at most nb bytes from s, returning a Vector{UInt8} of the bytes read.\n\nIf all is true (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If all is false, at most one read call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the all option.\n\n\n\n\n\nread(command::Cmd)\n\nRun command and return the resulting output as an array of bytes.\n\n\n\n\n\nread(command::Cmd, String)\n\nRun command and return the resulting output as a String.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.read!","page":"I/O and Network","title":"Base.read!","text":"read!(stream::IO, array::Union{Array, BitArray})\nread!(filename::AbstractString, array::Union{Array, BitArray})\n\nRead binary data from an I/O stream or file, filling in array.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.readbytes!","page":"I/O and Network","title":"Base.readbytes!","text":"readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))\n\nRead at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.\n\n\n\n\n\nreadbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)\n\nRead at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.\n\nIf all is true (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If all is false, at most one read call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the all option.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.unsafe_read","page":"I/O and Network","title":"Base.unsafe_read","text":"unsafe_read(io::IO, ref, nbytes::UInt)\n\nCopy nbytes from the IO stream object into ref (converted to a pointer).\n\nIt is recommended that subtypes T<:IO override the following method signature to provide more efficient implementations: unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.unsafe_write","page":"I/O and Network","title":"Base.unsafe_write","text":"unsafe_write(io::IO, ref, nbytes::UInt)\n\nCopy nbytes from ref (converted to a pointer) into the IO object.\n\nIt is recommended that subtypes T<:IO override the following method signature to provide more efficient implementations: unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.position","page":"I/O and Network","title":"Base.position","text":"position(s)\n\nGet the current position of a stream.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> position(io)\n5\n\njulia> skip(io, 10);\n\njulia> position(io)\n15\n\njulia> seekend(io);\n\njulia> position(io)\n35\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.seek","page":"I/O and Network","title":"Base.seek","text":"seek(s, pos)\n\nSeek a stream to the given position.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> read(io, Char)\n'L': ASCII/Unicode U+004c (category Lu: Letter, uppercase)\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.seekstart","page":"I/O and Network","title":"Base.seekstart","text":"seekstart(s)\n\nSeek a stream to its beginning.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> read(io, Char)\n'L': ASCII/Unicode U+004c (category Lu: Letter, uppercase)\n\njulia> seekstart(io);\n\njulia> read(io, Char)\n'J': ASCII/Unicode U+004a (category Lu: Letter, uppercase)\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.seekend","page":"I/O and Network","title":"Base.seekend","text":"seekend(s)\n\nSeek a stream to its end.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.skip","page":"I/O and Network","title":"Base.skip","text":"skip(s, offset)\n\nSeek a stream relative to the current position.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> skip(io, 10);\n\njulia> read(io, Char)\n'G': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.mark","page":"I/O and Network","title":"Base.mark","text":"mark(s)\n\nAdd a mark at the current position of stream s. Return the marked position.\n\nSee also unmark, reset, ismarked.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.unmark","page":"I/O and Network","title":"Base.unmark","text":"unmark(s)\n\nRemove a mark from stream s. Return true if the stream was marked, false otherwise.\n\nSee also mark, reset, ismarked.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.reset","page":"I/O and Network","title":"Base.reset","text":"reset(s)\n\nReset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked.\n\nSee also mark, unmark, ismarked.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.ismarked","page":"I/O and Network","title":"Base.ismarked","text":"ismarked(s)\n\nReturn true if stream s is marked.\n\nSee also mark, unmark, reset.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.eof","page":"I/O and Network","title":"Base.eof","text":"eof(stream) -> Bool\n\nTest whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.isreadonly","page":"I/O and Network","title":"Base.isreadonly","text":"isreadonly(io) -> Bool\n\nDetermine whether a stream is read-only.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> isreadonly(io)\ntrue\n\njulia> io = IOBuffer();\n\njulia> isreadonly(io)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.iswritable","page":"I/O and Network","title":"Base.iswritable","text":"iswritable(io) -> Bool\n\nReturn true if the specified IO object is writable (if that can be determined).\n\nExamples\n\njulia> open(\"myfile.txt\", \"w\") do io\n           print(io, \"Hello world!\");\n           iswritable(io)\n       end\ntrue\n\njulia> open(\"myfile.txt\", \"r\") do io\n           iswritable(io)\n       end\nfalse\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.isreadable","page":"I/O and Network","title":"Base.isreadable","text":"isreadable(io) -> Bool\n\nReturn true if the specified IO object is readable (if that can be determined).\n\nExamples\n\njulia> open(\"myfile.txt\", \"w\") do io\n           print(io, \"Hello world!\");\n           isreadable(io)\n       end\nfalse\n\njulia> open(\"myfile.txt\", \"r\") do io\n           isreadable(io)\n       end\ntrue\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.isopen","page":"I/O and Network","title":"Base.isopen","text":"isopen(object) -> Bool\n\nDetermine whether an object - such as a stream or timer – is not yet closed. Once an object is closed, it will never produce a new event. However, since a closed stream may still have data to read in its buffer, use eof to check for the ability to read data. Use the FileWatching package to be notified when a stream might be writable or readable.\n\nExamples\n\njulia> io = open(\"my_file.txt\", \"w+\");\n\njulia> isopen(io)\ntrue\n\njulia> close(io)\n\njulia> isopen(io)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.Grisu.print_shortest","page":"I/O and Network","title":"Base.Grisu.print_shortest","text":"print_shortest(io::IO, x)\n\nPrint the shortest possible representation, with the minimum number of consecutive non-zero digits, of number x, ensuring that it would parse to the exact same number.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.fd","page":"I/O and Network","title":"Base.fd","text":"fd(stream)\n\nReturn the file descriptor backing the stream or file. Note that this function only applies to synchronous File's and IOStream's not to any of the asynchronous streams.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.redirect_stdout","page":"I/O and Network","title":"Base.redirect_stdout","text":"redirect_stdout([stream]) -> (rd, wr)\n\nCreate a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.\n\nIf called with the optional stream argument, then returns stream itself.\n\nnote: Note\nstream must be a TTY, a Pipe, or a socket.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.redirect_stdout-Tuple{Function,Any}","page":"I/O and Network","title":"Base.redirect_stdout","text":"redirect_stdout(f::Function, stream)\n\nRun the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.\n\nnote: Note\nstream must be a TTY, a Pipe, or a socket.\n\n\n\n\n\n","category":"method"},{"location":"base/io-network.html#Base.redirect_stderr","page":"I/O and Network","title":"Base.redirect_stderr","text":"redirect_stderr([stream]) -> (rd, wr)\n\nLike redirect_stdout, but for stderr.\n\nnote: Note\nstream must be a TTY, a Pipe, or a socket.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.redirect_stderr-Tuple{Function,Any}","page":"I/O and Network","title":"Base.redirect_stderr","text":"redirect_stderr(f::Function, stream)\n\nRun the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.\n\nnote: Note\nstream must be a TTY, a Pipe, or a socket.\n\n\n\n\n\n","category":"method"},{"location":"base/io-network.html#Base.redirect_stdin","page":"I/O and Network","title":"Base.redirect_stdin","text":"redirect_stdin([stream]) -> (rd, wr)\n\nLike redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.\n\nnote: Note\nstream must be a TTY, a Pipe, or a socket.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.redirect_stdin-Tuple{Function,Any}","page":"I/O and Network","title":"Base.redirect_stdin","text":"redirect_stdin(f::Function, stream)\n\nRun the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.\n\nnote: Note\nstream must be a TTY, a Pipe, or a socket.\n\n\n\n\n\n","category":"method"},{"location":"base/io-network.html#Base.readchomp","page":"I/O and Network","title":"Base.readchomp","text":"readchomp(x)\n\nRead the entirety of x as a string and remove a single trailing newline if there is one. Equivalent to chomp(read(x, String)).\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end;\n\njulia> readchomp(\"my_file.txt\")\n\"JuliaLang is a GitHub organization.\\nIt has many members.\"\n\njulia> rm(\"my_file.txt\");\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.truncate","page":"I/O and Network","title":"Base.truncate","text":"truncate(file, n)\n\nResize the file or buffer given by the first argument to exactly n bytes, filling previously unallocated space with '\\0' if the file or buffer is grown.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\")\n35\n\njulia> truncate(io, 15)\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=15, maxsize=Inf, ptr=16, mark=-1)\n\njulia> String(take!(io))\n\"JuliaLang is a \"\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\");\n\njulia> truncate(io, 40);\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization.\\0\\0\\0\\0\\0\"\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.skipchars","page":"I/O and Network","title":"Base.skipchars","text":"skipchars(predicate, io::IO; linecomment=nothing)\n\nAdvance the stream io such that the next-read character will be the first remaining for which predicate returns false. If the keyword argument linecomment is specified, all characters from that character until the start of the next line are ignored.\n\nExamples\n\njulia> buf = IOBuffer(\"    text\")\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=1, mark=-1)\n\njulia> skipchars(isspace, buf)\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=5, mark=-1)\n\njulia> String(readavailable(buf))\n\"text\"\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.countlines","page":"I/O and Network","title":"Base.countlines","text":"countlines(io::IO; eol::AbstractChar = '\\n')\n\nRead io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\\n' are supported by passing them as the second argument.  The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\\n\");\n\njulia> countlines(io)\n1\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> countlines(io)\n1\n\njulia> countlines(io, eol = '.')\n0\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.PipeBuffer","page":"I/O and Network","title":"Base.PipeBuffer","text":"PipeBuffer(data::Vector{UInt8}=UInt8[]; maxsize::Integer = typemax(Int))\n\nAn IOBuffer that allows reading and performs writes by appending. Seeking and truncating are not supported. See IOBuffer for the available constructors. If data is given, creates a PipeBuffer to operate on a data vector, optionally specifying a size beyond which the underlying Array may not be grown.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.readavailable","page":"I/O and Network","title":"Base.readavailable","text":"readavailable(stream)\n\nRead all available data on the stream, blocking the task only if no data is available. The result is a Vector{UInt8,1}.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.IOContext","page":"I/O and Network","title":"Base.IOContext","text":"IOContext\n\nIOContext provides a mechanism for passing output configuration settings among show methods.\n\nIn short, it is an immutable dictionary that is a subclass of IO. It supports standard dictionary operations such as getindex, and can also be used as an I/O stream.\n\n\n\n\n\n","category":"type"},{"location":"base/io-network.html#Base.IOContext-Tuple{IO,Pair}","page":"I/O and Network","title":"Base.IOContext","text":"IOContext(io::IO, KV::Pair...)\n\nCreate an IOContext that wraps a given stream, adding the specified key=>value pairs to the properties of that stream (note that io can itself be an IOContext).\n\nuse (key => value) in io to see if this particular combination is in the properties set\nuse get(io, key, default) to retrieve the most recent value for a particular key\n\nThe following properties are in common use:\n\n:compact: Boolean specifying that small values should be printed more compactly, e.g. that numbers should be printed with fewer digits. This is set when printing array elements.\n:limit: Boolean specifying that containers should be truncated, e.g. showing … in place of most elements.\n:displaysize: A Tuple{Int,Int} giving the size in rows and columns to use for text output. This can be used to override the display size for called functions, but to get the size of the screen use the displaysize function.\n:typeinfo: a Type characterizing the information already printed concerning the type of the object about to be displayed. This is mainly useful when displaying a collection of objects of the same type, so that redundant type information can be avoided (e.g. [Float16(0)] can be shown as \"Float16[0.0]\" instead of \"Float16[Float16(0.0)]\" : while displaying the elements of the array, the :typeinfo property will be set to Float16).\n:color: Boolean specifying whether ANSI color/escape codes are supported/expected. By default, this is determined by whether io is a compatible terminal and by any --color command-line flag when julia was launched.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> printstyled(IOContext(io, :color => true), \"string\", color=:red)\n\njulia> String(take!(io))\n\"\\e[31mstring\\e[39m\"\n\njulia> printstyled(io, \"string\", color=:red)\n\njulia> String(take!(io))\n\"string\"\n\njulia> print(IOContext(stdout, :compact => false), 1.12341234)\n1.12341234\njulia> print(IOContext(stdout, :compact => true), 1.12341234)\n1.12341\n\njulia> function f(io::IO)\n           if get(io, :short, false)\n               print(io, \"short\")\n           else\n               print(io, \"loooooong\")\n           end\n       end\nf (generic function with 1 method)\n\njulia> f(stdout)\nloooooong\njulia> f(IOContext(stdout, :short => true))\nshort\n\n\n\n\n\n","category":"method"},{"location":"base/io-network.html#Base.IOContext-Tuple{IO,IOContext}","page":"I/O and Network","title":"Base.IOContext","text":"IOContext(io::IO, context::IOContext)\n\nCreate an IOContext that wraps an alternate IO but inherits the properties of context.\n\n\n\n\n\n","category":"method"},{"location":"base/io-network.html#Text-I/O-1","page":"I/O and Network","title":"Text I/O","text":"","category":"section"},{"location":"base/io-network.html#","page":"I/O and Network","title":"I/O and Network","text":"Base.show(::Any)\nBase.summary\nBase.print\nBase.println\nBase.printstyled\nBase.sprint\nBase.showerror\nBase.dump\nMeta.@dump\nBase.readline\nBase.readuntil\nBase.readlines\nBase.eachline\nBase.displaysize","category":"page"},{"location":"base/io-network.html#Base.show-Tuple{Any}","page":"I/O and Network","title":"Base.show","text":"show(x)\n\nWrite an informative text representation of a value to the current output stream. New types should overload show(io::IO, x) where the first argument is a stream. The representation used by show generally includes Julia-specific formatting and type information.\n\nrepr returns the output of show as a string.\n\nSee also print, which writes un-decorated representations.\n\nExamples\n\njulia> show(\"Hello World!\")\n\"Hello World!\"\njulia> print(\"Hello World!\")\nHello World!\n\n\n\n\n\n","category":"method"},{"location":"base/io-network.html#Base.summary","page":"I/O and Network","title":"Base.summary","text":"summary(io::IO, x)\nstr = summary(x)\n\nPrint to a stream io, or return a string str, giving a brief description of a value. By default returns string(typeof(x)), e.g. Int64.\n\nFor arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}.\n\nExamples\n\njulia> summary(1)\n\"Int64\"\n\njulia> summary(zeros(2))\n\"2-element Array{Float64,1}\"\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.print","page":"I/O and Network","title":"Base.print","text":"print([io::IO], xs...)\n\nWrite to io (or to the default output stream stdout if io is not given) a canonical (un-decorated) text representation. The representation used by print includes minimal formatting and tries to avoid Julia-specific details.\n\nPrinting nothing is not allowed and throws an error.\n\nprint falls back to calling show, so most types should just define show. Define print if your type has a separate \"plain\" representation. For example, show displays strings with quotes, and print displays strings without quotes.\n\nstring returns the output of print as a string.\n\nExamples\n\njulia> print(\"Hello World!\")\nHello World!\njulia> io = IOBuffer();\n\njulia> print(io, \"Hello\", ' ', :World!)\n\njulia> String(take!(io))\n\"Hello World!\"\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.println","page":"I/O and Network","title":"Base.println","text":"println([io::IO], xs...)\n\nPrint (using print) xs followed by a newline. If io is not supplied, prints to stdout.\n\nExamples\n\njulia> println(\"Hello, world\")\nHello, world\n\njulia> io = IOBuffer();\n\njulia> println(io, \"Hello, world\")\n\njulia> String(take!(io))\n\"Hello, world\\n\"\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.printstyled","page":"I/O and Network","title":"Base.printstyled","text":"printstyled([io], xs...; bold::Bool=false, color::Union{Symbol,Int}=:normal)\n\nPrint xs in a color specified as a symbol or integer, optionally in bold.\n\ncolor may take any of the values :normal, :default, :bold, :black, :blink, :blue, :cyan, :green, :hidden, :light_black, :light_blue, :light_cyan, :light_green, :light_magenta, :light_red, :light_yellow, :magenta, :nothing, :red, :reverse, :underline, :white, or  :yellow or an integer between 0 and 255 inclusive. Note that not all terminals support 256 colors. If the keyword bold is given as true, the result will be printed in bold.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.sprint","page":"I/O and Network","title":"Base.sprint","text":"sprint(f::Function, args...; context=nothing, sizehint=0)\n\nCall the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string. context can be either an IOContext whose properties will be used, or a Pair specifying a property and its value. sizehint suggests the capacity of the buffer (in bytes).\n\nThe optional keyword argument context can be set to :key=>value pair or an IO or IOContext object whose attributes are used for the I/O stream passed to f.  The optional sizehint is a suggested size (in bytes) to allocate for the buffer used to write the string.\n\nExamples\n\njulia> sprint(show, 66.66666; context=:compact => true)\n\"66.6667\"\n\njulia> sprint(showerror, BoundsError([1], 100))\n\"BoundsError: attempt to access 1-element Array{Int64,1} at index [100]\"\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.showerror","page":"I/O and Network","title":"Base.showerror","text":"showerror(io, e)\n\nShow a descriptive representation of an exception object e. This method is used to display the exception after a call to throw.\n\nExamples\n\njulia> struct MyException <: Exception\n           msg::AbstractString\n       end\n\njulia> function Base.showerror(io::IO, err::MyException)\n           print(io, \"MyException: \")\n           print(io, err.msg)\n       end\n\njulia> err = MyException(\"test exception\")\nMyException(\"test exception\")\n\njulia> sprint(showerror, err)\n\"MyException: test exception\"\n\njulia> throw(MyException(\"test exception\"))\nERROR: MyException: test exception\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.dump","page":"I/O and Network","title":"Base.dump","text":"dump(x; maxdepth=8)\n\nShow every part of the representation of a value. The depth of the output is truncated at maxdepth.\n\nExamples\n\njulia> struct MyStruct\n           x\n           y\n       end\n\njulia> x = MyStruct(1, (2,3));\n\njulia> dump(x)\nMyStruct\n  x: Int64 1\n  y: Tuple{Int64,Int64}\n    1: Int64 2\n    2: Int64 3\n\njulia> dump(x; maxdepth = 1)\nMyStruct\n  x: Int64 1\n  y: Tuple{Int64,Int64}\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.Meta.@dump","page":"I/O and Network","title":"Base.Meta.@dump","text":"@dump expr\n\nShow every part of the representation of the given expression. Equivalent to dump(:(expr)).\n\n\n\n\n\n","category":"macro"},{"location":"base/io-network.html#Base.readline","page":"I/O and Network","title":"Base.readline","text":"readline(io::IO=stdin; keep::Bool=false)\nreadline(filename::AbstractString; keep::Bool=false)\n\nRead a single line of text from the given I/O stream or file (defaults to stdin). When reading from a file, the text is assumed to be encoded in UTF-8. Lines in the input end with '\\n' or \"\\r\\n\" or the end of an input stream. When keep is false (as it is by default), these trailing newline characters are removed from the line before it is returned. When keep is true, they are returned as part of the line.\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end\n57\n\njulia> readline(\"my_file.txt\")\n\"JuliaLang is a GitHub organization.\"\n\njulia> readline(\"my_file.txt\", keep=true)\n\"JuliaLang is a GitHub organization.\\n\"\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.readuntil","page":"I/O and Network","title":"Base.readuntil","text":"readuntil(stream::IO, delim; keep::Bool = false)\nreaduntil(filename::AbstractString, delim; keep::Bool = false)\n\nRead a string from an I/O stream or a file, up to the given delimiter. The delimiter can be a UInt8, AbstractChar, string, or vector. Keyword argument keep controls whether the delimiter is included in the result. The text is assumed to be encoded in UTF-8.\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end\n57\n\njulia> readuntil(\"my_file.txt\", 'L')\n\"Julia\"\n\njulia> readuntil(\"my_file.txt\", '.', keep = true)\n\"JuliaLang is a GitHub organization.\"\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.readlines","page":"I/O and Network","title":"Base.readlines","text":"readlines(io::IO=stdin; keep::Bool=false)\nreadlines(filename::AbstractString; keep::Bool=false)\n\nRead all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading readline repeatedly with the same arguments and saving the resulting lines as a vector of strings.\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end\n57\n\njulia> readlines(\"my_file.txt\")\n2-element Array{String,1}:\n \"JuliaLang is a GitHub organization.\"\n \"It has many members.\"\n\njulia> readlines(\"my_file.txt\", keep=true)\n2-element Array{String,1}:\n \"JuliaLang is a GitHub organization.\\n\"\n \"It has many members.\\n\"\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.eachline","page":"I/O and Network","title":"Base.eachline","text":"eachline(io::IO=stdin; keep::Bool=false)\neachline(filename::AbstractString; keep::Bool=false)\n\nCreate an iterable EachLine object that will yield each line from an I/O stream or a file. Iteration calls readline on the stream argument repeatedly with keep passed through, determining whether trailing end-of-line characters are retained. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the EachLine object is garbage collected.\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\n It has many members.\\n\");\n       end;\n\njulia> for line in eachline(\"my_file.txt\")\n           print(line)\n       end\nJuliaLang is a GitHub organization. It has many members.\n\njulia> rm(\"my_file.txt\");\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.displaysize","page":"I/O and Network","title":"Base.displaysize","text":"displaysize([io::IO]) -> (lines, columns)\n\nReturn the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.\n\nExamples\n\njulia> withenv(\"LINES\" => 30, \"COLUMNS\" => 100) do\n           displaysize()\n       end\n(30, 100)\n\nTo get your TTY size,\n\njulia> displaysize(stdout)\n(34, 147)\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Multimedia-I/O-1","page":"I/O and Network","title":"Multimedia I/O","text":"","category":"section"},{"location":"base/io-network.html#","page":"I/O and Network","title":"I/O and Network","text":"Just as text output is performed by print and user-defined types can indicate their textual representation by overloading show, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:","category":"page"},{"location":"base/io-network.html#","page":"I/O and Network","title":"I/O and Network","text":"A function display(x) to request the richest available multimedia display of a Julia object x (with a plain-text fallback).\nOverloading show allows one to indicate arbitrary multimedia representations (keyed by standard MIME types) of user-defined types.\nMultimedia-capable display backends may be registered by subclassing a generic AbstractDisplay type and pushing them onto a stack of display backends via pushdisplay.","category":"page"},{"location":"base/io-network.html#","page":"I/O and Network","title":"I/O and Network","text":"The base Julia runtime provides only plain-text display, but richer displays may be enabled by loading external modules or by using graphical Julia environments (such as the IPython-based IJulia notebook).","category":"page"},{"location":"base/io-network.html#","page":"I/O and Network","title":"I/O and Network","text":"Base.AbstractDisplay\nBase.Multimedia.display\nBase.Multimedia.redisplay\nBase.Multimedia.displayable\nBase.show(::Any, ::Any, ::Any)\nBase.Multimedia.showable\nBase.repr(::MIME, ::Any)\nBase.MIME\nBase.@MIME_str","category":"page"},{"location":"base/io-network.html#Base.Multimedia.AbstractDisplay","page":"I/O and Network","title":"Base.Multimedia.AbstractDisplay","text":"AbstractDisplay\n\nAbstract supertype for rich display output devices. TextDisplay is a subtype of this.\n\n\n\n\n\n","category":"type"},{"location":"base/io-network.html#Base.Multimedia.display","page":"I/O and Network","title":"Base.Multimedia.display","text":"display(x)\ndisplay(d::AbstractDisplay, x)\ndisplay(mime, x)\ndisplay(d::AbstractDisplay, mime, x)\n\nAbstractDisplay x using the topmost applicable display in the display stack, typically using the richest supported multimedia output for x, with plain-text stdout output as a fallback. The display(d, x) variant attempts to display x on the given display d only, throwing a MethodError if d cannot display objects of this type.\n\nIn general, you cannot assume that display output goes to stdout (unlike print(x) or show(x)).  For example, display(x) may open up a separate window with an image. display(x) means \"show x in the best way you can for the current output device(s).\" If you want REPL-like text output that is guaranteed to go to stdout, use show(stdout, \"text/plain\", x) instead.\n\nThere are also two variants with a mime argument (a MIME type string, such as \"image/png\"), which attempt to display x using the requested MIME type only, throwing a MethodError if this type is not supported by either the display(s) or by x. With these variants, one can also supply the \"raw\" data in the requested MIME type by passing x::AbstractString (for MIME types with text-based storage, such as text/html or application/postscript) or x::Vector{UInt8} (for binary MIME types).\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.Multimedia.redisplay","page":"I/O and Network","title":"Base.Multimedia.redisplay","text":"redisplay(x)\nredisplay(d::AbstractDisplay, x)\nredisplay(mime, x)\nredisplay(d::AbstractDisplay, mime, x)\n\nBy default, the redisplay functions simply call display. However, some display backends may override redisplay to modify an existing display of x (if any). Using redisplay is also a hint to the backend that x may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.Multimedia.displayable","page":"I/O and Network","title":"Base.Multimedia.displayable","text":"displayable(mime) -> Bool\ndisplayable(d::AbstractDisplay, mime) -> Bool\n\nReturns a boolean value indicating whether the given mime type (string) is displayable by any of the displays in the current display stack, or specifically by the display d in the second variant.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.show-Tuple{Any,Any,Any}","page":"I/O and Network","title":"Base.show","text":"show(io, mime, x)\n\nThe display functions ultimately call show in order to write an object x as a given mime type to a given I/O stream io (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type T, it is only necessary to define a new show method for T, via: show(io, ::MIME\"mime\", x::T) = ..., where mime is a MIME-type string and the function body calls write (or similar) to write that representation of x to io. (Note that the MIME\"\" notation only supports literal strings; to construct MIME types in a more flexible manner use MIME{Symbol(\"\")}.)\n\nFor example, if you define a MyImage type and know how to write it to a PNG file, you could define a function show(io, ::MIME\"image/png\", x::MyImage) = ... to allow your images to be displayed on any PNG-capable AbstractDisplay (such as IJulia). As usual, be sure to import Base.show in order to add new methods to the built-in Julia function show.\n\nThe default MIME type is MIME\"text/plain\". There is a fallback definition for text/plain output that calls show with 2 arguments. Therefore, this case should be handled by defining a 2-argument show(io::IO, x::MyType) method.\n\nTechnically, the MIME\"mime\" macro defines a singleton type for the given mime string, which allows us to exploit Julia's dispatch mechanisms in determining how to display objects of any given type.\n\nThe first argument to show can be an IOContext specifying output format properties. See IOContext for details.\n\n\n\n\n\n","category":"method"},{"location":"base/io-network.html#Base.Multimedia.showable","page":"I/O and Network","title":"Base.Multimedia.showable","text":"showable(mime, x)\n\nReturns a boolean value indicating whether or not the object x can be written as the given mime type.\n\n(By default, this is determined automatically by the existence of the corresponding show method for typeof(x).  Some types provide custom showable methods; for example, if the available MIME formats depend on the value of x.)\n\nExamples\n\njulia> showable(MIME(\"text/plain\"), rand(5))\ntrue\n\njulia> showable(\"img/png\", rand(5))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.repr-Tuple{MIME,Any}","page":"I/O and Network","title":"Base.repr","text":"repr(mime, x; context=nothing)\n\nReturns an AbstractString or Vector{UInt8} containing the representation of x in the requested mime type, as written by show(io, mime, x) (throwing a MethodError if no appropriate show is available). An AbstractString is returned for MIME types with textual representations (such as \"text/html\" or \"application/postscript\"), whereas binary data is returned as Vector{UInt8}. (The function istextmime(mime) returns whether or not Julia treats a given mime type as text.)\n\nThe optional keyword argument context can be set to :key=>value pair or an IO or IOContext object whose attributes are used for the I/O stream passed to show.\n\nAs a special case, if x is an AbstractString (for textual MIME types) or a Vector{UInt8} (for binary MIME types), the repr function assumes that x is already in the requested mime format and simply returns x. This special case does not apply to the \"text/plain\" MIME type. This is useful so that raw data can be passed to display(m::MIME, x).\n\nIn particular, repr(\"text/plain\", x) is typically a \"pretty-printed\" version of x designed for human consumption.  See also repr(x) to instead return a string corresponding to show(x) that may be closer to how the value of x would be entered in Julia.\n\nExamples\n\njulia> A = [1 2; 3 4];\n\njulia> repr(\"text/plain\", A)\n\"2×2 Array{Int64,2}:\\n 1  2\\n 3  4\"\n\n\n\n\n\n","category":"method"},{"location":"base/io-network.html#Base.Multimedia.MIME","page":"I/O and Network","title":"Base.Multimedia.MIME","text":"MIME\n\nA type representing a standard internet data format. \"MIME\" stands for \"Multipurpose Internet Mail Extensions\", since the standard was originally used to describe multimedia attachments to email messages.\n\nA MIME object can be passed as the second argument to show to request output in that format.\n\nExamples\n\njulia> show(stdout, MIME(\"text/plain\"), \"hi\")\n\"hi\"\n\n\n\n\n\n","category":"type"},{"location":"base/io-network.html#Base.Multimedia.@MIME_str","page":"I/O and Network","title":"Base.Multimedia.@MIME_str","text":"@MIME_str\n\nA convenience macro for writing MIME types, typically used when adding methods to show. For example the syntax show(io::IO, ::MIME\"text/html\", x::MyType) = ... could be used to define how to write an HTML representation of MyType.\n\n\n\n\n\n","category":"macro"},{"location":"base/io-network.html#","page":"I/O and Network","title":"I/O and Network","text":"As mentioned above, one can also define new display backends. For example, a module that can display PNG images in a window can register this capability with Julia, so that calling display(x) on types with PNG representations will automatically display the image using the module's window.","category":"page"},{"location":"base/io-network.html#","page":"I/O and Network","title":"I/O and Network","text":"In order to define a new display backend, one should first create a subtype D of the abstract class AbstractDisplay.  Then, for each MIME type (mime string) that can be displayed on D, one should define a function display(d::D, ::MIME\"mime\", x) = ... that displays x as that MIME type, usually by calling show(io, mime, x) or repr(io, mime, x).  A MethodError should be thrown if x cannot be displayed as that MIME type; this is automatic if one calls show or repr. Finally, one should define a function display(d::D, x) that queries showable(mime, x) for the mime types supported by D and displays the \"best\" one; a MethodError should be thrown if no supported MIME types are found for x.  Similarly, some subtypes may wish to override redisplay(d::D, ...). (Again, one should import Base.display to add new methods to display.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display \"handle\" of some type).  The display functions for D can then be called directly, but they can also be invoked automatically from display(x) simply by pushing a new display onto the display-backend stack with:","category":"page"},{"location":"base/io-network.html#","page":"I/O and Network","title":"I/O and Network","text":"Base.Multimedia.pushdisplay\nBase.Multimedia.popdisplay\nBase.Multimedia.TextDisplay\nBase.Multimedia.istextmime","category":"page"},{"location":"base/io-network.html#Base.Multimedia.pushdisplay","page":"I/O and Network","title":"Base.Multimedia.pushdisplay","text":"pushdisplay(d::AbstractDisplay)\n\nPushes a new display d on top of the global display-backend stack. Calling display(x) or display(mime, x) will display x on the topmost compatible backend in the stack (i.e., the topmost backend that does not throw a MethodError).\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.Multimedia.popdisplay","page":"I/O and Network","title":"Base.Multimedia.popdisplay","text":"popdisplay()\npopdisplay(d::AbstractDisplay)\n\nPop the topmost backend off of the display-backend stack, or the topmost copy of d in the second variant.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.Multimedia.TextDisplay","page":"I/O and Network","title":"Base.Multimedia.TextDisplay","text":"TextDisplay(io::IO)\n\nReturns a TextDisplay <: AbstractDisplay, which displays any object as the text/plain MIME type (by default), writing the text representation to the given I/O stream. (This is how objects are printed in the Julia REPL.)\n\n\n\n\n\n","category":"type"},{"location":"base/io-network.html#Base.Multimedia.istextmime","page":"I/O and Network","title":"Base.Multimedia.istextmime","text":"istextmime(m::MIME)\n\nDetermine whether a MIME type is text data. MIME types are assumed to be binary data except for a set of types known to be text data (possibly Unicode).\n\nExamples\n\njulia> istextmime(MIME(\"text/plain\"))\ntrue\n\njulia> istextmime(MIME(\"img/png\"))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Network-I/O-1","page":"I/O and Network","title":"Network I/O","text":"","category":"section"},{"location":"base/io-network.html#","page":"I/O and Network","title":"I/O and Network","text":"Base.bytesavailable\nBase.ntoh\nBase.hton\nBase.ltoh\nBase.htol\nBase.ENDIAN_BOM","category":"page"},{"location":"base/io-network.html#Base.bytesavailable","page":"I/O and Network","title":"Base.bytesavailable","text":"bytesavailable(io)\n\nReturn the number of bytes available for reading before a read from this stream or buffer will block.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> bytesavailable(io)\n34\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.ntoh","page":"I/O and Network","title":"Base.ntoh","text":"ntoh(x)\n\nConvert the endianness of a value from Network byte order (big-endian) to that used by the Host.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.hton","page":"I/O and Network","title":"Base.hton","text":"hton(x)\n\nConvert the endianness of a value from that used by the Host to Network byte order (big-endian).\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.ltoh","page":"I/O and Network","title":"Base.ltoh","text":"ltoh(x)\n\nConvert the endianness of a value from Little-endian to that used by the Host.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.htol","page":"I/O and Network","title":"Base.htol","text":"htol(x)\n\nConvert the endianness of a value from that used by the Host to Little-endian.\n\n\n\n\n\n","category":"function"},{"location":"base/io-network.html#Base.ENDIAN_BOM","page":"I/O and Network","title":"Base.ENDIAN_BOM","text":"ENDIAN_BOM\n\nThe 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value 0x04030201. Big-endian machines will contain the value 0x01020304.\n\n\n\n\n\n","category":"constant"},{"location":"base/punctuation.html#Punctuation-1","page":"Punctuation","title":"Punctuation","text":"","category":"section"},{"location":"base/punctuation.html#","page":"Punctuation","title":"Punctuation","text":"Extended documentation for mathematical symbols & functions is here.","category":"page"},{"location":"base/punctuation.html#","page":"Punctuation","title":"Punctuation","text":"symbol meaning\n@m invoke macro m; followed by space-separated expressions\n! prefix \"not\" (logical negation) operator\na!( ) at the end of a function name, ! is used as a convention to indicate that a function modifies its argument(s)\n# begin single line comment\n#= begin multi-line comment (these are nestable)\n=# end multi-line comment\n$ string and expression interpolation\n% remainder operator\n^ exponent operator\n& bitwise and\n&& short-circuiting boolean and\n| bitwise or\n|| short-circuiting boolean or\n⊻ bitwise xor operator\n* multiply, or matrix multiply\n() the empty tuple\n~ bitwise not operator\n\\ backslash operator\n' complex transpose operator Aᴴ\na[] array indexing (calling getindex or setindex!)\n[,] vector literal constructor (calling vect)\n[;] vertical concatenation (calling vcat or hvcat)\n[    ] with space-separated expressions, horizontal concatenation (calling hcat or hvcat)\nT{ } parametric type instantiation\n; statement separator\n, separate function arguments or tuple components\n? 3-argument conditional operator (used like: conditional ? if_true : if_false)\n\"\" delimit string literals\n'' delimit character literals\n` ` delimit external process (command) specifications\n... splice arguments into a function call or declare a varargs function\n. access named fields in objects/modules (calling getproperty or setproperty!), also prefixes elementwise function calls (calling broadcast)\na:b range a, a+1, a+2, ..., b\na:s:b range a, a+s, a+2s, ..., b\n: index an entire dimension (firstindex:lastindex), see Colon)\n:: type annotation or typeassert, depending on context\n:( ) quoted expression\n:a symbol a\n<: subtype operator\n>: supertype operator (reverse of subtype operator)\n=== egal comparison operator","category":"page"},{"location":"base/sort.html#Sorting-and-Related-Functions-1","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"","category":"section"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of values. By default, Julia picks reasonable algorithms and sorts in standard ascending order:","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"julia> sort([2,3,1])\n3-element Array{Int64,1}:\n 1\n 2\n 3","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"You can easily sort in reverse order as well:","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"julia> sort([2,3,1], rev=true)\n3-element Array{Int64,1}:\n 3\n 2\n 1","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"To sort an array in-place, use the \"bang\" version of the sort function:","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"julia> a = [2,3,1];\n\njulia> sort!(a);\n\njulia> a\n3-element Array{Int64,1}:\n 1\n 2\n 3","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"Instead of directly sorting an array, you can compute a permutation of the array's indices that puts the array into sorted order:","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"julia> v = randn(5)\n5-element Array{Float64,1}:\n  0.297288\n  0.382396\n -0.597634\n -0.0104452\n -0.839027\n\njulia> p = sortperm(v)\n5-element Array{Int64,1}:\n 5\n 3\n 4\n 1\n 2\n\njulia> v[p]\n5-element Array{Float64,1}:\n -0.839027\n -0.597634\n -0.0104452\n  0.297288\n  0.382396","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"Arrays can easily be sorted according to an arbitrary transformation of their values:","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"julia> sort(v, by=abs)\n5-element Array{Float64,1}:\n -0.0104452\n  0.297288\n  0.382396\n -0.597634\n -0.839027","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"Or in reverse order by a transformation:","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"julia> sort(v, by=abs, rev=true)\n5-element Array{Float64,1}:\n -0.839027\n -0.597634\n  0.382396\n  0.297288\n -0.0104452","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"If needed, the sorting algorithm can be chosen:","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"julia> sort(v, alg=InsertionSort)\n5-element Array{Float64,1}:\n -0.839027\n -0.597634\n -0.0104452\n  0.297288\n  0.382396","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"All the sorting and order related functions rely on a \"less than\" relation defining a total order on the values to be manipulated. The isless function is invoked by default, but the relation can be specified via the lt keyword.","category":"page"},{"location":"base/sort.html#Sorting-Functions-1","page":"Sorting and Related Functions","title":"Sorting Functions","text":"","category":"section"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"Base.sort!\nBase.sort\nBase.sortperm\nBase.InsertionSort\nBase.MergeSort\nBase.QuickSort\nBase.PartialQuickSort\nBase.Sort.sortperm!\nBase.Sort.sortslices","category":"page"},{"location":"base/sort.html#Base.sort!","page":"Sorting and Related Functions","title":"Base.sort!","text":"sort!(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nSort the vector v in place. QuickSort is used by default for numeric arrays while MergeSort is used for other arrays. You can specify an algorithm to use via the alg keyword (see Sorting Algorithms for available algorithms). The by keyword lets you provide a function that will be applied to each element before comparison; the lt keyword allows providing a custom \"less than\" function; use rev=true to reverse the sorting order. These options are independent and can be used together in all possible combinations: if both by and lt are specified, the lt function is applied to the result of the by function; rev=true reverses whatever ordering specified via the by and lt keywords.\n\nExamples\n\njulia> v = [3, 1, 2]; sort!(v); v\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> v = [3, 1, 2]; sort!(v, rev = true); v\n3-element Array{Int64,1}:\n 3\n 2\n 1\n\njulia> v = [(1, \"c\"), (3, \"a\"), (2, \"b\")]; sort!(v, by = x -> x[1]); v\n3-element Array{Tuple{Int64,String},1}:\n (1, \"c\")\n (2, \"b\")\n (3, \"a\")\n\njulia> v = [(1, \"c\"), (3, \"a\"), (2, \"b\")]; sort!(v, by = x -> x[2]); v\n3-element Array{Tuple{Int64,String},1}:\n (3, \"a\")\n (2, \"b\")\n (1, \"c\")\n\n\n\n\n\nsort!(A; dims::Integer, alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nSort the multidimensional array A along dimension dims. See sort! for a description of possible keyword arguments.\n\nTo sort slices of an array, refer to sortslices.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nExamples\n\njulia> A = [4 3; 1 2]\n2×2 Array{Int64,2}:\n 4  3\n 1  2\n\njulia> sort!(A, dims = 1); A\n2×2 Array{Int64,2}:\n 1  2\n 4  3\n\njulia> sort!(A, dims = 2); A\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Base.sort","page":"Sorting and Related Functions","title":"Base.sort","text":"sort(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nVariant of sort! that returns a sorted copy of v leaving v itself unmodified.\n\nExamples\n\njulia> v = [3, 1, 2];\n\njulia> sort(v)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> v\n3-element Array{Int64,1}:\n 3\n 1\n 2\n\n\n\n\n\nsort(A; dims::Integer, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nSort a multidimensional array A along the given dimension. See sort! for a description of possible keyword arguments.\n\nTo sort slices of an array, refer to sortslices.\n\nExamples\n\njulia> A = [4 3; 1 2]\n2×2 Array{Int64,2}:\n 4  3\n 1  2\n\njulia> sort(A, dims = 1)\n2×2 Array{Int64,2}:\n 1  2\n 4  3\n\njulia> sort(A, dims = 2)\n2×2 Array{Int64,2}:\n 3  4\n 1  2\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Base.sortperm","page":"Sorting and Related Functions","title":"Base.sortperm","text":"sortperm(v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nReturn a permutation vector I that puts v[I] in sorted order. The order is specified using the same keywords as sort!. The permutation is guaranteed to be stable even if the sorting algorithm is unstable, meaning that indices of equal elements appear in ascending order.\n\nSee also sortperm!.\n\nExamples\n\njulia> v = [3, 1, 2];\n\njulia> p = sortperm(v)\n3-element Array{Int64,1}:\n 2\n 3\n 1\n\njulia> v[p]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Base.Sort.InsertionSort","page":"Sorting and Related Functions","title":"Base.Sort.InsertionSort","text":"InsertionSort\n\nIndicate that a sorting function should use the insertion sort algorithm. Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output list.\n\nCharacteristics:\n\nstable: preserves the ordering of elements which compare equal (e.g. \"a\" and \"A\" in a sort of letters which ignores case).\nin-place in memory.\nquadratic performance in the number of elements to be sorted: it is well-suited to small collections but should not be used for large ones.\n\n\n\n\n\n","category":"constant"},{"location":"base/sort.html#Base.Sort.MergeSort","page":"Sorting and Related Functions","title":"Base.Sort.MergeSort","text":"MergeSort\n\nIndicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.\n\nCharacteristics:\n\nstable: preserves the ordering of elements which compare equal (e.g. \"a\" and \"A\" in a sort of letters which ignores case).\nnot in-place in memory.\ndivide-and-conquer sort strategy.\n\n\n\n\n\n","category":"constant"},{"location":"base/sort.html#Base.Sort.QuickSort","page":"Sorting and Related Functions","title":"Base.Sort.QuickSort","text":"QuickSort\n\nIndicate that a sorting function should use the quick sort algorithm, which is not stable.\n\nCharacteristics:\n\nnot stable: does not preserve the ordering of elements which compare equal (e.g. \"a\" and \"A\" in a sort of letters which ignores case).\nin-place in memory.\ndivide-and-conquer: sort strategy similar to MergeSort.\ngood performance for large collections.\n\n\n\n\n\n","category":"constant"},{"location":"base/sort.html#Base.Sort.PartialQuickSort","page":"Sorting and Related Functions","title":"Base.Sort.PartialQuickSort","text":"PartialQuickSort{T <: Union{Int,OrdinalRange}}\n\nIndicate that a sorting function should use the partial quick sort algorithm. Partial quick sort returns the smallest k elements sorted from smallest to largest, finding them and sorting them using QuickSort.\n\nCharacteristics:\n\nnot stable: does not preserve the ordering of elements which compare equal (e.g. \"a\" and \"A\" in a sort of letters which ignores case).\nin-place in memory.\ndivide-and-conquer: sort strategy similar to MergeSort.\n\n\n\n\n\n","category":"type"},{"location":"base/sort.html#Base.Sort.sortperm!","page":"Sorting and Related Functions","title":"Base.Sort.sortperm!","text":"sortperm!(ix, v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)\n\nLike sortperm, but accepts a preallocated index vector ix.  If initialized is false (the default), ix is initialized to contain the values 1:length(v).\n\nExamples\n\njulia> v = [3, 1, 2]; p = zeros(Int, 3);\n\njulia> sortperm!(p, v); p\n3-element Array{Int64,1}:\n 2\n 3\n 1\n\njulia> v[p]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Base.sortslices","page":"Sorting and Related Functions","title":"Base.sortslices","text":"sortslices(A; dims, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nSort slices of an array A. The required keyword argument dims must be either an integer or a tuple of integers. It specifies the dimension(s) over which the slices are sorted.\n\nE.g., if A is a matrix, dims=1 will sort rows, dims=2 will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.\n\nFor the remaining keyword arguments, see the documentation of sort!.\n\nExamples\n\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1) # Sort rows\n3×3 Array{Int64,2}:\n -1   6  4\n  7   3  5\n  9  -2  8\n\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, lt=(x,y)->isless(x[2],y[2]))\n3×3 Array{Int64,2}:\n  9  -2  8\n  7   3  5\n -1   6  4\n\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, rev=true)\n3×3 Array{Int64,2}:\n  9  -2  8\n  7   3  5\n -1   6  4\n\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2) # Sort columns\n3×3 Array{Int64,2}:\n  3   5  7\n -1  -4  6\n -2   8  9\n\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, alg=InsertionSort, lt=(x,y)->isless(x[2],y[2]))\n3×3 Array{Int64,2}:\n  5   3  7\n -4  -1  6\n  8  -2  9\n\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, rev=true)\n3×3 Array{Int64,2}:\n 7   5   3\n 6  -4  -1\n 9   8  -2\n\nHigher dimensions\n\nsortslices extends naturally to higher dimensions. E.g., if A is a a 2x2x2 array, sortslices(A, dims=3) will sort slices within the 3rd dimension, passing the 2x2 slices A[:, :, 1] and A[:, :, 2] to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the by or lt keyword argument to specify such an order.\n\nIf dims is a tuple, the order of the dimensions in dims is relevant and specifies the linear order of the slices. E.g., if A is three dimensional and dims is (1, 2), the orderings of the first two dimensions are re-arranged such such that the slices (of the remaining third dimension) are sorted. If dims is (2, 1) instead, the same slices will be taken, but the result order will be row-major instead.\n\nHigher dimensional examples\n\njulia> A = permutedims(reshape([4 3; 2 1; 'A' 'B'; 'C' 'D'], (2, 2, 2)), (1, 3, 2))\n2×2×2 Array{Any,3}:\n[:, :, 1] =\n 4  3\n 2  1\n\n[:, :, 2] =\n 'A'  'B'\n 'C'  'D'\n\njulia> sortslices(A, dims=(1,2))\n2×2×2 Array{Any,3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 'D'  'B'\n 'C'  'A'\n\njulia> sortslices(A, dims=(2,1))\n2×2×2 Array{Any,3}:\n[:, :, 1] =\n 1  2\n 3  4\n\n[:, :, 2] =\n 'D'  'C'\n 'B'  'A'\n\njulia> sortslices(reshape([5; 4; 3; 2; 1], (1,1,5)), dims=3, by=x->x[1,1])\n1×1×5 Array{Int64,3}:\n[:, :, 1] =\n 1\n\n[:, :, 2] =\n 2\n\n[:, :, 3] =\n 3\n\n[:, :, 4] =\n 4\n\n[:, :, 5] =\n 5\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Order-Related-Functions-1","page":"Sorting and Related Functions","title":"Order-Related Functions","text":"","category":"section"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"Base.issorted\nBase.Sort.searchsorted\nBase.Sort.searchsortedfirst\nBase.Sort.searchsortedlast\nBase.Sort.partialsort!\nBase.Sort.partialsort\nBase.Sort.partialsortperm\nBase.Sort.partialsortperm!","category":"page"},{"location":"base/sort.html#Base.issorted","page":"Sorting and Related Functions","title":"Base.issorted","text":"issorted(v, lt=isless, by=identity, rev:Bool=false, order::Ordering=Forward)\n\nTest whether a vector is in sorted order. The lt, by and rev keywords modify what order is considered to be sorted just as they do for sort.\n\nExamples\n\njulia> issorted([1, 2, 3])\ntrue\n\njulia> issorted([(1, \"b\"), (2, \"a\")], by = x -> x[1])\ntrue\n\njulia> issorted([(1, \"b\"), (2, \"a\")], by = x -> x[2])\nfalse\n\njulia> issorted([(1, \"b\"), (2, \"a\")], by = x -> x[2], rev=true)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Base.Sort.searchsorted","page":"Sorting and Related Functions","title":"Base.Sort.searchsorted","text":"searchsorted(a, x; by=<transform>, lt=<comparison>, rev=false)\n\nReturn the range of indices of a which compare as equal to x (using binary search) according to the order specified by the by, lt and rev keywords, assuming that a is already sorted in that order. Return an empty range located at the insertion point if a does not contain values equal to x.\n\nExamples\n\njulia> searchsorted([1, 2, 4, 5, 5, 7], 4) # single match\n3:3\n\njulia> searchsorted([1, 2, 4, 5, 5, 7], 5) # multiple matches\n4:5\n\njulia> searchsorted([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle\n3:2\n\njulia> searchsorted([1, 2, 4, 5, 5, 7], 9) # no match, insert at end\n7:6\n\njulia> searchsorted([1, 2, 4, 5, 5, 7], 0) # no match, insert at start\n1:0\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Base.Sort.searchsortedfirst","page":"Sorting and Related Functions","title":"Base.Sort.searchsortedfirst","text":"searchsortedfirst(a, x; by=<transform>, lt=<comparison>, rev=false)\n\nReturn the index of the first value in a greater than or equal to x, according to the specified order. Return length(a) + 1 if x is greater than all values in a. a is assumed to be sorted.\n\nExamples\n\njulia> searchsortedfirst([1, 2, 4, 5, 5, 7], 4) # single match\n3\n\njulia> searchsortedfirst([1, 2, 4, 5, 5, 7], 5) # multiple matches\n4\n\njulia> searchsortedfirst([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle\n3\n\njulia> searchsortedfirst([1, 2, 4, 5, 5, 7], 9) # no match, insert at end\n7\n\njulia> searchsortedfirst([1, 2, 4, 5, 5, 7], 0) # no match, insert at start\n1\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Base.Sort.searchsortedlast","page":"Sorting and Related Functions","title":"Base.Sort.searchsortedlast","text":"searchsortedlast(a, x; by=<transform>, lt=<comparison>, rev=false)\n\nReturn the index of the last value in a less than or equal to x, according to the specified order. Return 0 if x is less than all values in a. a is assumed to be sorted.\n\nExamples\n\njulia> searchsortedlast([1, 2, 4, 5, 5, 7], 4) # single match\n3\n\njulia> searchsortedlast([1, 2, 4, 5, 5, 7], 5) # multiple matches\n5\n\njulia> searchsortedlast([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle\n2\n\njulia> searchsortedlast([1, 2, 4, 5, 5, 7], 9) # no match, insert at end\n6\n\njulia> searchsortedlast([1, 2, 4, 5, 5, 7], 0) # no match, insert at start\n0\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Base.Sort.partialsort!","page":"Sorting and Related Functions","title":"Base.Sort.partialsort!","text":"partialsort!(v, k; by=<transform>, lt=<comparison>, rev=false)\n\nPartially sort the vector v in place, according to the order specified by by, lt and rev so that the value at index k (or range of adjacent values if k is a range) occurs at the position where it would appear if the array were fully sorted via a non-stable algorithm. If k is a single index, that value is returned; if k is a range, an array of values at those indices is returned. Note that partialsort! does not fully sort the input array.\n\nExamples\n\njulia> a = [1, 2, 4, 3, 4]\n5-element Array{Int64,1}:\n 1\n 2\n 4\n 3\n 4\n\njulia> partialsort!(a, 4)\n4\n\njulia> a\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 4\n\njulia> a = [1, 2, 4, 3, 4]\n5-element Array{Int64,1}:\n 1\n 2\n 4\n 3\n 4\n\njulia> partialsort!(a, 4, rev=true)\n2\n\njulia> a\n5-element Array{Int64,1}:\n 4\n 4\n 3\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Base.Sort.partialsort","page":"Sorting and Related Functions","title":"Base.Sort.partialsort","text":"partialsort(v, k, by=<transform>, lt=<comparison>, rev=false)\n\nVariant of partialsort! which copies v before partially sorting it, thereby returning the same thing as partialsort! but leaving v unmodified.\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Base.Sort.partialsortperm","page":"Sorting and Related Functions","title":"Base.Sort.partialsortperm","text":"partialsortperm(v, k; by=<transform>, lt=<comparison>, rev=false)\n\nReturn a partial permutation I of the vector v, so that v[I] returns values of a fully sorted version of v at index k. If k is a range, a vector of indices is returned; if k is an integer, a single index is returned. The order is specified using the same keywords as sort!. The permutation is stable, meaning that indices of equal elements appear in ascending order.\n\nNote that this function is equivalent to, but more efficient than, calling sortperm(...)[k].\n\nExamples\n\njulia> v = [3, 1, 2, 1];\n\njulia> v[partialsortperm(v, 1)]\n1\n\njulia> p = partialsortperm(v, 1:3)\n3-element view(::Array{Int64,1}, 1:3) with eltype Int64:\n 2\n 4\n 3\n\njulia> v[p]\n3-element Array{Int64,1}:\n 1\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Base.Sort.partialsortperm!","page":"Sorting and Related Functions","title":"Base.Sort.partialsortperm!","text":"partialsortperm!(ix, v, k; by=<transform>, lt=<comparison>, rev=false, initialized=false)\n\nLike partialsortperm, but accepts a preallocated index vector ix. If initialized is false (the default), ix is initialized to contain the values 1:length(ix).\n\n\n\n\n\n","category":"function"},{"location":"base/sort.html#Sorting-Algorithms-1","page":"Sorting and Related Functions","title":"Sorting Algorithms","text":"","category":"section"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"There are currently four sorting algorithms available in base Julia:","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"InsertionSort\nQuickSort\nPartialQuickSort(k)\nMergeSort","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"InsertionSort is an O(n^2) stable sorting algorithm. It is efficient for very small n, and is used internally by QuickSort.","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"QuickSort is an O(n log n) sorting algorithm which is in-place, very fast, but not stable – i.e. elements which are considered equal will not remain in the same order in which they originally appeared in the array to be sorted. QuickSort is the default algorithm for numeric values, including integers and floats.","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"PartialQuickSort(k) is similar to QuickSort, but the output array is only sorted up to index k if k is an integer, or in the range of k if k is an OrdinalRange. For example:","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"x = rand(1:500, 100)\nk = 50\nk2 = 50:100\ns = sort(x; alg=QuickSort)\nps = sort(x; alg=PartialQuickSort(k))\nqs = sort(x; alg=PartialQuickSort(k2))\nmap(issorted, (s, ps, qs))             # => (true, false, false)\nmap(x->issorted(x[1:k]), (s, ps, qs))  # => (true, true, false)\nmap(x->issorted(x[k2]), (s, ps, qs))   # => (true, false, true)\ns[1:k] == ps[1:k]                      # => true\ns[k2] == qs[k2]                        # => true","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"MergeSort is an O(n log n) stable sorting algorithm but is not in-place – it requires a temporary array of half the size of the input array – and is typically not quite as fast as QuickSort.  It is the default algorithm for non-numeric data.","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"The default sorting algorithms are chosen on the basis that they are fast and stable, or appear to be so. For numeric types indeed, QuickSort is selected as it is faster and indistinguishable in this case from a stable sort (unless the array records its mutations in some way). The stability property comes at a non-negligible cost, so if you don't need it, you may want to explicitly specify your preferred algorithm, e.g. sort!(v, alg=QuickSort).","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"The mechanism by which Julia picks default sorting algorithms is implemented via the Base.Sort.defalg function. It allows a particular algorithm to be registered as the default in all sorting functions for specific arrays. For example, here are the two default methods from sort.jl:","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"defalg(v::AbstractArray) = MergeSort\ndefalg(v::AbstractArray{<:Number}) = QuickSort","category":"page"},{"location":"base/sort.html#","page":"Sorting and Related Functions","title":"Sorting and Related Functions","text":"As for numeric arrays, choosing a non-stable default algorithm for array types for which the notion of a stable sort is meaningless (i.e. when two values comparing equal can not be distinguished)  may make sense.","category":"page"},{"location":"base/iterators.html#Iteration-utilities-1","page":"Iteration utilities","title":"Iteration utilities","text":"","category":"section"},{"location":"base/iterators.html#","page":"Iteration utilities","title":"Iteration utilities","text":"Base.Iterators.Stateful\nBase.Iterators.zip\nBase.Iterators.enumerate\nBase.Iterators.rest\nBase.Iterators.countfrom\nBase.Iterators.take\nBase.Iterators.drop\nBase.Iterators.cycle\nBase.Iterators.repeated\nBase.Iterators.product\nBase.Iterators.flatten\nBase.Iterators.partition\nBase.Iterators.filter\nBase.Iterators.reverse","category":"page"},{"location":"base/iterators.html#Base.Iterators.Stateful","page":"Iteration utilities","title":"Base.Iterators.Stateful","text":"Stateful(itr)\n\nThere are several different ways to think about this iterator wrapper:\n\nIt provides a mutable wrapper around an iterator and its iteration state.\nIt turns an iterator-like abstraction into a Channel-like abstraction.\nIt's an iterator that mutates to become its own rest iterator whenever an item is produced.\n\nStateful provides the regular iterator interface. Like other mutable iterators (e.g. Channel), if iteration is stopped early (e.g. by a break in a for loop), iteration can be resumed from the same spot by continuing to iterate over the same iterator object (in contrast, an immutable iterator would restart from the beginning).\n\nExamples\n\njulia> a = Iterators.Stateful(\"abcdef\");\n\njulia> isempty(a)\nfalse\n\njulia> popfirst!(a)\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> collect(Iterators.take(a, 3))\n3-element Array{Char,1}:\n 'b'\n 'c'\n 'd'\n\njulia> collect(a)\n2-element Array{Char,1}:\n 'e'\n 'f'\n\njulia> a = Iterators.Stateful([1,1,1,2,3,4]);\n\njulia> for x in a; x == 1 || break; end\n\njulia> Base.peek(a)\n3\n\njulia> sum(a) # Sum the remaining elements\n7\n\n\n\n\n\n","category":"type"},{"location":"base/iterators.html#Base.Iterators.zip","page":"Iteration utilities","title":"Base.Iterators.zip","text":"zip(iters...)\n\nRun multiple iterators at the same time, until any of them is exhausted. The value type of the zip iterator is a tuple of values of its subiterators.\n\nNote: zip orders the calls to its subiterators in such a way that stateful iterators will not advance when another iterator finishes in the current iteration.\n\nExamples\n\njulia> a = 1:5\n1:5\n\njulia> b = [\"e\",\"d\",\"b\",\"c\",\"a\"]\n5-element Array{String,1}:\n \"e\"\n \"d\"\n \"b\"\n \"c\"\n \"a\"\n\njulia> c = zip(a,b)\nBase.Iterators.Zip{Tuple{UnitRange{Int64},Array{String,1}}}((1:5, [\"e\", \"d\", \"b\", \"c\", \"a\"]))\n\njulia> length(c)\n5\n\njulia> first(c)\n(1, \"e\")\n\n\n\n\n\n","category":"function"},{"location":"base/iterators.html#Base.Iterators.enumerate","page":"Iteration utilities","title":"Base.Iterators.enumerate","text":"enumerate(iter)\n\nAn iterator that yields (i, x) where i is a counter starting at 1, and x is the ith value from the given iterator. It's useful when you need not only the values x over which you are iterating, but also the number of iterations so far. Note that i may not be valid for indexing iter; it's also possible that x != iter[i], if iter has indices that do not start at 1. See the pairs(IndexLinear(), iter) method if you want to ensure that i is an index.\n\nExamples\n\njulia> a = [\"a\", \"b\", \"c\"];\n\njulia> for (index, value) in enumerate(a)\n           println(\"$index $value\")\n       end\n1 a\n2 b\n3 c\n\n\n\n\n\n","category":"function"},{"location":"base/iterators.html#Base.Iterators.rest","page":"Iteration utilities","title":"Base.Iterators.rest","text":"rest(iter, state)\n\nAn iterator that yields the same elements as iter, but starting at the given state.\n\nExamples\n\njulia> collect(Iterators.rest([1,2,3,4], 2))\n3-element Array{Int64,1}:\n 2\n 3\n 4\n\n\n\n\n\n","category":"function"},{"location":"base/iterators.html#Base.Iterators.countfrom","page":"Iteration utilities","title":"Base.Iterators.countfrom","text":"countfrom(start=1, step=1)\n\nAn iterator that counts forever, starting at start and incrementing by step.\n\nExamples\n\njulia> for v in Iterators.countfrom(5, 2)\n           v > 10 && break\n           println(v)\n       end\n5\n7\n9\n\n\n\n\n\n","category":"function"},{"location":"base/iterators.html#Base.Iterators.take","page":"Iteration utilities","title":"Base.Iterators.take","text":"take(iter, n)\n\nAn iterator that generates at most the first n elements of iter.\n\nExamples\n\njulia> a = 1:2:11\n1:2:11\n\njulia> collect(a)\n6-element Array{Int64,1}:\n  1\n  3\n  5\n  7\n  9\n 11\n\njulia> collect(Iterators.take(a,3))\n3-element Array{Int64,1}:\n 1\n 3\n 5\n\n\n\n\n\n","category":"function"},{"location":"base/iterators.html#Base.Iterators.drop","page":"Iteration utilities","title":"Base.Iterators.drop","text":"drop(iter, n)\n\nAn iterator that generates all but the first n elements of iter.\n\nExamples\n\njulia> a = 1:2:11\n1:2:11\n\njulia> collect(a)\n6-element Array{Int64,1}:\n  1\n  3\n  5\n  7\n  9\n 11\n\njulia> collect(Iterators.drop(a,4))\n2-element Array{Int64,1}:\n  9\n 11\n\n\n\n\n\n","category":"function"},{"location":"base/iterators.html#Base.Iterators.cycle","page":"Iteration utilities","title":"Base.Iterators.cycle","text":"cycle(iter)\n\nAn iterator that cycles through iter forever. If iter is empty, so is cycle(iter).\n\nExamples\n\njulia> for (i, v) in enumerate(Iterators.cycle(\"hello\"))\n           print(v)\n           i > 10 && break\n       end\nhellohelloh\n\n\n\n\n\n","category":"function"},{"location":"base/iterators.html#Base.Iterators.repeated","page":"Iteration utilities","title":"Base.Iterators.repeated","text":"repeated(x[, n::Int])\n\nAn iterator that generates the value x forever. If n is specified, generates x that many times (equivalent to take(repeated(x), n)).\n\nExamples\n\njulia> a = Iterators.repeated([1 2], 4);\n\njulia> collect(a)\n4-element Array{Array{Int64,2},1}:\n [1 2]\n [1 2]\n [1 2]\n [1 2]\n\n\n\n\n\n","category":"function"},{"location":"base/iterators.html#Base.Iterators.product","page":"Iteration utilities","title":"Base.Iterators.product","text":"product(iters...)\n\nReturn an iterator over the product of several iterators. Each generated element is a tuple whose ith element comes from the ith argument iterator. The first iterator changes the fastest.\n\nExamples\n\njulia> collect(Iterators.product(1:2, 3:5))\n2×3 Array{Tuple{Int64,Int64},2}:\n (1, 3)  (1, 4)  (1, 5)\n (2, 3)  (2, 4)  (2, 5)\n\n\n\n\n\n","category":"function"},{"location":"base/iterators.html#Base.Iterators.flatten","page":"Iteration utilities","title":"Base.Iterators.flatten","text":"flatten(iter)\n\nGiven an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.\n\nExamples\n\njulia> collect(Iterators.flatten((1:2, 8:9)))\n4-element Array{Int64,1}:\n 1\n 2\n 8\n 9\n\n\n\n\n\n","category":"function"},{"location":"base/iterators.html#Base.Iterators.partition","page":"Iteration utilities","title":"Base.Iterators.partition","text":"partition(collection, n)\n\nIterate over a collection n elements at a time.\n\nExamples\n\njulia> collect(Iterators.partition([1,2,3,4,5], 2))\n3-element Array{Array{Int64,1},1}:\n [1, 2]\n [3, 4]\n [5]\n\n\n\n\n\n","category":"function"},{"location":"base/iterators.html#Base.Iterators.filter","page":"Iteration utilities","title":"Base.Iterators.filter","text":"Iterators.filter(flt, itr)\n\nGiven a predicate function flt and an iterable object itr, return an iterable object which upon iteration yields the elements x of itr that satisfy flt(x). The order of the original iterator is preserved.\n\nThis function is lazy; that is, it is guaranteed to return in Θ(1) time and use Θ(1) additional space, and flt will not be called by an invocation of filter. Calls to flt will be made when iterating over the returned iterable object. These calls are not cached and repeated calls will be made when reiterating.\n\nSee Base.filter for an eager implementation of filtering for arrays.\n\nExamples\n\njulia> f = Iterators.filter(isodd, [1, 2, 3, 4, 5])\nBase.Iterators.Filter{typeof(isodd),Array{Int64,1}}(isodd, [1, 2, 3, 4, 5])\n\njulia> foreach(println, f)\n1\n3\n5\n\n\n\n\n\n","category":"function"},{"location":"base/iterators.html#Base.Iterators.reverse","page":"Iteration utilities","title":"Base.Iterators.reverse","text":"Iterators.reverse(itr)\n\nGiven an iterator itr, then reverse(itr) is an iterator over the same collection but in the reverse order.\n\nThis iterator is \"lazy\" in that it does not make a copy of the collection in order to reverse it; see Base.reverse for an eager implementation.\n\nNot all iterator types T support reverse-order iteration.  If T doesn't, then iterating over Iterators.reverse(itr::T) will throw a MethodError because of the missing iterate methods for Iterators.Reverse{T}. (To implement these methods, the original iterator itr::T can be obtained from r = Iterators.reverse(itr) by r.itr.)\n\nExamples\n\njulia> foreach(println, Iterators.reverse(1:5))\n5\n4\n3\n2\n1\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#C-Interface-1","page":"C Interface","title":"C Interface","text":"","category":"section"},{"location":"base/c.html#","page":"C Interface","title":"C Interface","text":"ccall\nCore.Intrinsics.cglobal\nBase.@cfunction\nBase.CFunction\nBase.unsafe_convert\nBase.cconvert\nBase.unsafe_load\nBase.unsafe_store!\nBase.unsafe_copyto!{T}(::Ptr{T}, ::Ptr{T}, ::Any)\nBase.unsafe_copyto!{T}(::Array{T}, ::Any, ::Array{T}, ::Any, ::Any)\nBase.copyto!\nBase.pointer\nBase.unsafe_wrap{T,N}(::Union{Type{Array},Type{Array{T}},Type{Array{T,N}}}, ::Ptr{T}, ::NTuple{N,Int})\nBase.pointer_from_objref\nBase.unsafe_pointer_to_objref\nBase.disable_sigint\nBase.reenable_sigint\nBase.systemerror\nCore.Ptr\nCore.Ref\nBase.Cchar\nBase.Cuchar\nBase.Cshort\nBase.Cstring\nBase.Cushort\nBase.Cint\nBase.Cuint\nBase.Clong\nBase.Culong\nBase.Clonglong\nBase.Culonglong\nBase.Cintmax_t\nBase.Cuintmax_t\nBase.Csize_t\nBase.Cssize_t\nBase.Cptrdiff_t\nBase.Cwchar_t\nBase.Cwstring\nBase.Cfloat\nBase.Cdouble","category":"page"},{"location":"base/c.html#ccall","page":"C Interface","title":"ccall","text":"ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)\nccall(function_name, returntype, (argtype1, ...), argvalue1, ...)\nccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)\n\nCall a function in a C-exported shared library, specified by the tuple (function_name, library), where each component is either a string or symbol. Instead of specifying a library, one can also use a function_name symbol or string, which is resolved in the current process. Alternatively, ccall may also be used to call a function pointer function_pointer, such as one returned by dlsym.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.\n\nEach argvalue to the ccall will be converted to the corresponding argtype, by automatic insertion of calls to unsafe_convert(argtype, cconvert(argtype, argvalue)). (See also the documentation for unsafe_convert and cconvert for further details.) In most cases, this simply results in a call to convert(argtype, argvalue).\n\n\n\n\n\n","category":"keyword"},{"location":"base/c.html#Core.Intrinsics.cglobal","page":"C Interface","title":"Core.Intrinsics.cglobal","text":"cglobal((symbol, library) [, type=Cvoid])\n\nObtain a pointer to a global variable in a C-exported shared library, specified exactly as in ccall. Returns a Ptr{Type}, defaulting to Ptr{Cvoid} if no Type argument is supplied. The values can be read or written by unsafe_load or unsafe_store!, respectively.\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#Base.@cfunction","page":"C Interface","title":"Base.@cfunction","text":"@cfunction(callable, ReturnType, (ArgumentTypes...,)) -> Ptr{Cvoid}\n@cfunction($callable, ReturnType, (ArgumentTypes...,)) -> CFunction\n\nGenerate a C-callable function pointer from the Julia function callable for the given type signature. To pass the return value to a ccall, use the argument type Ptr{Cvoid} in the signature.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression (although it can include a splat expression). And that these arguments will be evaluated in global scope during compile-time (not deferred until runtime). Adding a '$' in front of the function argument changes this to instead create a runtime closure over the local variable callable.\n\nSee manual section on ccall and cfunction usage.\n\nExamples\n\njulia> function foo(x::Int, y::Int)\n           return x + y\n       end\n\njulia> @cfunction(foo, Int, (Int, Int))\nPtr{Cvoid} @0x000000001b82fcd0\n\n\n\n\n\n","category":"macro"},{"location":"base/c.html#Base.CFunction","page":"C Interface","title":"Base.CFunction","text":"CFunction struct\n\nGarbage-collection handle for the return value from @cfunction when the first argument is annotated with '$'. Like all cfunction handles, it should be passed to ccall as a Ptr{Cvoid}, and will be converted automatically at the call site to the appropriate type.\n\nSee @cfunction.\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.unsafe_convert","page":"C Interface","title":"Base.unsafe_convert","text":"unsafe_convert(T, x)\n\nConvert x to a C argument of type T where the input x must be the return value of cconvert(T, ...).\n\nIn cases where convert would need to take a Julia object and turn it into a Ptr, this function should be used to define and perform that conversion.\n\nBe careful to ensure that a Julia reference to x exists as long as the result of this function will be used. Accordingly, the argument x to this function should never be an expression, only a variable name or field reference. For example, x=a.b.c is acceptable, but x=[a,b,c] is not.\n\nThe unsafe prefix on this function indicates that using the result of this function after the x argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.\n\nSee also cconvert\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#Base.cconvert","page":"C Interface","title":"Base.cconvert","text":"cconvert(T,x)\n\nConvert x to a value to be passed to C code as type T, typically by calling convert(T, x).\n\nIn cases where x cannot be safely converted to T, unlike convert, cconvert may return an object of a type different from T, which however is suitable for unsafe_convert to handle. The result of this function should be kept valid (for the GC) until the result of unsafe_convert is not needed anymore. This can be used to allocate memory that will be accessed by the ccall. If multiple objects need to be allocated, a tuple of the objects can be used as return value.\n\nNeither convert nor cconvert should take a Julia object and turn it into a Ptr.\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#Base.unsafe_load","page":"C Interface","title":"Base.unsafe_load","text":"unsafe_load(p::Ptr{T}, i::Integer=1)\n\nLoad a value of type T from the address of the ith element (1-indexed) starting at p. This is equivalent to the C expression p[i-1].\n\nThe unsafe prefix on this function indicates that no validation is performed on the pointer p to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#Base.unsafe_store!","page":"C Interface","title":"Base.unsafe_store!","text":"unsafe_store!(p::Ptr{T}, x, i::Integer=1)\n\nStore a value of type T to the address of the ith element (1-indexed) starting at p. This is equivalent to the C expression p[i-1] = x.\n\nThe unsafe prefix on this function indicates that no validation is performed on the pointer p to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Ptr{T},Ptr{T},Any}} where T","page":"C Interface","title":"Base.unsafe_copyto!","text":"unsafe_copyto!(dest::Ptr{T}, src::Ptr{T}, N)\n\nCopy N elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.\n\nThe unsafe prefix on this function indicates that no validation is performed on the pointers dest and src to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n\n\n\n\n","category":"method"},{"location":"base/c.html#Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Array{T,N} where N,Any,Array{T,N} where N,Any,Any}} where T","page":"C Interface","title":"Base.unsafe_copyto!","text":"unsafe_copyto!(dest::Array, do, src::Array, so, N)\n\nCopy N elements from a source array to a destination, starting at offset so in the source and do in the destination (1-indexed).\n\nThe unsafe prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n\n\n\n\n","category":"method"},{"location":"base/c.html#Base.copyto!","page":"C Interface","title":"Base.copyto!","text":"copyto!(dest, do, src, so, N)\n\nCopy N elements from collection src starting at offset so, to array dest starting at offset do. Return dest.\n\n\n\n\n\ncopyto!(dest::AbstractArray, src) -> dest\n\nCopy all elements from collection src to array dest, whose length must be greater than or equal to the length n of src. The first n elements of dest are overwritten, the other elements are left untouched.\n\nExamples\n\njulia> x = [1., 0., 3., 0., 5.];\n\njulia> y = zeros(7);\n\njulia> copyto!(y, x);\n\njulia> y\n7-element Array{Float64,1}:\n 1.0\n 0.0\n 3.0\n 0.0\n 5.0\n 0.0\n 0.0\n\n\n\n\n\ncopyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -> dest\n\nCopy the block of src in the range of Rsrc to the block of dest in the range of Rdest. The sizes of the two regions must match.\n\n\n\n\n\ncopyto!(dest::AbstractMatrix, src::UniformScaling)\n\nCopies a UniformScaling onto a matrix.\n\ncompat: Julia 1.1\nIn Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#Base.pointer","page":"C Interface","title":"Base.pointer","text":"pointer(array [, index])\n\nGet the native address of an array or string, optionally at a given location index.\n\nThis function is \"unsafe\". Be careful to ensure that a Julia reference to array exists as long as this pointer will be used. The GC.@preserve macro should be used to protect the array argument from garbage collection within a given block of code.\n\nCalling Ref(array[, index]) is generally preferable to this function as it guarantees validity.\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T,N} where N}, Type{Array{T,N}}},Ptr{T},Tuple{Vararg{Int64,N}}}} where N where T","page":"C Interface","title":"Base.unsafe_wrap","text":"unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)\n\nWrap a Julia Array object around the data at the address given by pointer, without making a copy.  The pointer element type T determines the array element type. dims is either an integer (for a 1d array) or a tuple of the array dimensions. own optionally specifies whether Julia should take ownership of the memory, calling free on the pointer when the array is no longer referenced.\n\nThis function is labeled \"unsafe\" because it will crash if pointer is not a valid memory address to data of the requested length.\n\n\n\n\n\n","category":"method"},{"location":"base/c.html#Base.pointer_from_objref","page":"C Interface","title":"Base.pointer_from_objref","text":"pointer_from_objref(x)\n\nGet the memory address of a Julia object as a Ptr. The existence of the resulting Ptr will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the Ptr will be used.\n\nThis function may not be called on immutable objects, since they do not have stable memory addresses.\n\nSee also: unsafe_pointer_to_objref.\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#Base.unsafe_pointer_to_objref","page":"C Interface","title":"Base.unsafe_pointer_to_objref","text":"unsafe_pointer_to_objref(p::Ptr)\n\nConvert a Ptr to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered \"unsafe\" and should be used with care.\n\nSee also: pointer_from_objref.\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#Base.disable_sigint","page":"C Interface","title":"Base.disable_sigint","text":"disable_sigint(f::Function)\n\nDisable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using do block syntax as follows:\n\ndisable_sigint() do\n    # interrupt-unsafe code\n    ...\nend\n\nThis is not needed on worker threads (Threads.threadid() != 1) since the InterruptException will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#Base.reenable_sigint","page":"C Interface","title":"Base.reenable_sigint","text":"reenable_sigint(f::Function)\n\nRe-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of disable_sigint.\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#Base.systemerror","page":"C Interface","title":"Base.systemerror","text":"systemerror(sysfunc, iftrue)\n\nRaises a SystemError for errno with the descriptive string sysfunc if iftrue is true\n\n\n\n\n\n","category":"function"},{"location":"base/c.html#Core.Ptr","page":"C Interface","title":"Core.Ptr","text":"Ptr{T}\n\nA memory address referring to data of type T.  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Core.Ref","page":"C Interface","title":"Core.Ref","text":"Ref{T}\n\nAn object that safely references data of type T. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the Ref itself is referenced.\n\nIn Julia, Ref objects are dereferenced (loaded or stored) with [].\n\nCreation of a Ref to a value x of type T is usually written Ref(x). Additionally, for creating interior pointers to containers (such as Array or Ptr), it can be written Ref(a, i) for creating a reference to the i-th element of a.\n\nWhen passed as a ccall argument (either as a Ptr or Ref type), a Ref object will be converted to a native pointer to the data it references.\n\nThere is no invalid (NULL) Ref in Julia, but a C_NULL instance of Ptr can be passed to a ccall Ref argument.\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cchar","page":"C Interface","title":"Base.Cchar","text":"Cchar\n\nEquivalent to the native char c-type.\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cuchar","page":"C Interface","title":"Base.Cuchar","text":"Cuchar\n\nEquivalent to the native unsigned char c-type (UInt8).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cshort","page":"C Interface","title":"Base.Cshort","text":"Cshort\n\nEquivalent to the native signed short c-type (Int16).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cstring","page":"C Interface","title":"Base.Cstring","text":"Cstring\n\nA C-style string composed of the native character type Cchars. Cstrings are NUL-terminated. For C-style strings composed of the native wide character type, see Cwstring. For more information about string interopability with C, see the manual.\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cushort","page":"C Interface","title":"Base.Cushort","text":"Cushort\n\nEquivalent to the native unsigned short c-type (UInt16).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cint","page":"C Interface","title":"Base.Cint","text":"Cint\n\nEquivalent to the native signed int c-type (Int32).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cuint","page":"C Interface","title":"Base.Cuint","text":"Cuint\n\nEquivalent to the native unsigned int c-type (UInt32).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Clong","page":"C Interface","title":"Base.Clong","text":"Clong\n\nEquivalent to the native signed long c-type.\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Culong","page":"C Interface","title":"Base.Culong","text":"Culong\n\nEquivalent to the native unsigned long c-type.\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Clonglong","page":"C Interface","title":"Base.Clonglong","text":"Clonglong\n\nEquivalent to the native signed long long c-type (Int64).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Culonglong","page":"C Interface","title":"Base.Culonglong","text":"Culonglong\n\nEquivalent to the native unsigned long long c-type (UInt64).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cintmax_t","page":"C Interface","title":"Base.Cintmax_t","text":"Cintmax_t\n\nEquivalent to the native intmax_t c-type (Int64).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cuintmax_t","page":"C Interface","title":"Base.Cuintmax_t","text":"Cuintmax_t\n\nEquivalent to the native uintmax_t c-type (UInt64).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Csize_t","page":"C Interface","title":"Base.Csize_t","text":"Csize_t\n\nEquivalent to the native size_t c-type (UInt).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cssize_t","page":"C Interface","title":"Base.Cssize_t","text":"Cssize_t\n\nEquivalent to the native ssize_t c-type.\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cptrdiff_t","page":"C Interface","title":"Base.Cptrdiff_t","text":"Cptrdiff_t\n\nEquivalent to the native ptrdiff_t c-type (Int).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cwchar_t","page":"C Interface","title":"Base.Cwchar_t","text":"Cwchar_t\n\nEquivalent to the native wchar_t c-type (Int32).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cwstring","page":"C Interface","title":"Base.Cwstring","text":"Cwstring\n\nA C-style string composed of the native wide character type Cwchar_ts. Cwstrings are NUL-terminated. For C-style strings composed of the native character type, see Cstring. For more information about string interopability with C, see the manual.\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cfloat","page":"C Interface","title":"Base.Cfloat","text":"Cfloat\n\nEquivalent to the native float c-type (Float32).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#Base.Cdouble","page":"C Interface","title":"Base.Cdouble","text":"Cdouble\n\nEquivalent to the native double c-type (Float64).\n\n\n\n\n\n","category":"type"},{"location":"base/c.html#LLVM-Interface-1","page":"C Interface","title":"LLVM Interface","text":"","category":"section"},{"location":"base/c.html#","page":"C Interface","title":"C Interface","text":"Core.Intrinsics.llvmcall","category":"page"},{"location":"base/c.html#Core.Intrinsics.llvmcall","page":"C Interface","title":"Core.Intrinsics.llvmcall","text":"llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\nllvmcall((declarations::String, IR::String), ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\nCall LLVM IR string in the first argument. Similar to an LLVM function define block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).\n\nThe optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.\n\nEach ArgumentValue to llvmcall will be converted to the corresponding ArgumentType, by automatic insertion of calls to unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue)). (See also the documentation for unsafe_convert and cconvert for further details.) In most cases, this simply results in a call to convert(ArgumentType, ArgumentValue).\n\nSee test/llvmcall.jl for usage examples.\n\n\n\n\n\n","category":"function"},{"location":"base/libc.html#C-Standard-Library-1","page":"C Standard Library","title":"C Standard Library","text":"","category":"section"},{"location":"base/libc.html#","page":"C Standard Library","title":"C Standard Library","text":"Base.Libc.malloc\nBase.Libc.calloc\nBase.Libc.realloc\nBase.Libc.free\nBase.Libc.errno\nBase.Libc.strerror\nBase.Libc.GetLastError\nBase.Libc.FormatMessage\nBase.Libc.time(::Base.Libc.TmStruct)\nBase.Libc.strftime\nBase.Libc.strptime\nBase.Libc.TmStruct\nBase.Libc.flush_cstdio\nBase.Libc.systemsleep","category":"page"},{"location":"base/libc.html#Base.Libc.malloc","page":"C Standard Library","title":"Base.Libc.malloc","text":"malloc(size::Integer) -> Ptr{Cvoid}\n\nCall malloc from the C standard library.\n\n\n\n\n\n","category":"function"},{"location":"base/libc.html#Base.Libc.calloc","page":"C Standard Library","title":"Base.Libc.calloc","text":"calloc(num::Integer, size::Integer) -> Ptr{Cvoid}\n\nCall calloc from the C standard library.\n\n\n\n\n\n","category":"function"},{"location":"base/libc.html#Base.Libc.realloc","page":"C Standard Library","title":"Base.Libc.realloc","text":"realloc(addr::Ptr, size::Integer) -> Ptr{Cvoid}\n\nCall realloc from the C standard library.\n\nSee warning in the documentation for free regarding only using this on memory originally obtained from malloc.\n\n\n\n\n\n","category":"function"},{"location":"base/libc.html#Base.Libc.free","page":"C Standard Library","title":"Base.Libc.free","text":"free(addr::Ptr)\n\nCall free from the C standard library. Only use this on memory obtained from malloc, not on pointers retrieved from other C libraries. Ptr objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple libc libraries exist on the system.\n\n\n\n\n\n","category":"function"},{"location":"base/libc.html#Base.Libc.errno","page":"C Standard Library","title":"Base.Libc.errno","text":"errno([code])\n\nGet the value of the C library's errno. If an argument is specified, it is used to set the value of errno.\n\nThe value of errno is only valid immediately after a ccall to a C library routine that sets it. Specifically, you cannot call errno at the next prompt in a REPL, because lots of code is executed between prompts.\n\n\n\n\n\n","category":"function"},{"location":"base/libc.html#Base.Libc.strerror","page":"C Standard Library","title":"Base.Libc.strerror","text":"strerror(n=errno())\n\nConvert a system call error code to a descriptive string\n\n\n\n\n\n","category":"function"},{"location":"base/libc.html#Base.Libc.GetLastError","page":"C Standard Library","title":"Base.Libc.GetLastError","text":"GetLastError()\n\nCall the Win32 GetLastError function [only available on Windows].\n\n\n\n\n\n","category":"function"},{"location":"base/libc.html#Base.Libc.FormatMessage","page":"C Standard Library","title":"Base.Libc.FormatMessage","text":"FormatMessage(n=GetLastError())\n\nConvert a Win32 system call error code to a descriptive string [only available on Windows].\n\n\n\n\n\n","category":"function"},{"location":"base/libc.html#Base.Libc.time-Tuple{Base.Libc.TmStruct}","page":"C Standard Library","title":"Base.Libc.time","text":"time(t::TmStruct)\n\nConverts a TmStruct struct to a number of seconds since the epoch.\n\n\n\n\n\n","category":"method"},{"location":"base/libc.html#Base.Libc.strftime","page":"C Standard Library","title":"Base.Libc.strftime","text":"strftime([format], time)\n\nConvert time, given as a number of seconds since the epoch or a TmStruct, to a formatted string using the given format. Supported formats are the same as those in the standard C library.\n\n\n\n\n\n","category":"function"},{"location":"base/libc.html#Base.Libc.strptime","page":"C Standard Library","title":"Base.Libc.strptime","text":"strptime([format], timestr)\n\nParse a formatted time string into a TmStruct giving the seconds, minute, hour, date, etc. Supported formats are the same as those in the standard C library. On some platforms, timezones will not be parsed correctly. If the result of this function will be passed to time to convert it to seconds since the epoch, the isdst field should be filled in manually. Setting it to -1 will tell the C library to use the current system settings to determine the timezone.\n\n\n\n\n\n","category":"function"},{"location":"base/libc.html#Base.Libc.TmStruct","page":"C Standard Library","title":"Base.Libc.TmStruct","text":"TmStruct([seconds])\n\nConvert a number of seconds since the epoch to broken-down format, with fields sec, min, hour, mday, month, year, wday, yday, and isdst.\n\n\n\n\n\n","category":"type"},{"location":"base/libc.html#Base.Libc.flush_cstdio","page":"C Standard Library","title":"Base.Libc.flush_cstdio","text":"flush_cstdio()\n\nFlushes the C stdout and stderr streams (which may have been written to by external C code).\n\n\n\n\n\n","category":"function"},{"location":"base/libc.html#Base.Libc.systemsleep","page":"C Standard Library","title":"Base.Libc.systemsleep","text":"systemsleep(s::Real)\n\nSuspends execution for s seconds. This function does not yield to Julia's scheduler and therefore blocks the Julia thread that it is running on for the duration of the sleep time.\n\nSee also: sleep\n\n\n\n\n\n","category":"function"},{"location":"base/stacktraces.html#StackTraces-1","page":"StackTraces","title":"StackTraces","text":"","category":"section"},{"location":"base/stacktraces.html#","page":"StackTraces","title":"StackTraces","text":"Base.StackTraces.StackFrame\nBase.StackTraces.StackTrace\nBase.StackTraces.stacktrace","category":"page"},{"location":"base/stacktraces.html#Base.StackTraces.StackFrame","page":"StackTraces","title":"Base.StackTraces.StackFrame","text":"StackFrame\n\nStack information representing execution context, with the following fields:\n\nfunc::Symbol\nThe name of the function containing the execution context.\nlinfo::Union{Core.MethodInstance, CodeInfo, Nothing}\nThe MethodInstance containing the execution context (if it could be found).\nfile::Symbol\nThe path to the file containing the execution context.\nline::Int\nThe line number in the file containing the execution context.\nfrom_c::Bool\nTrue if the code is from C.\ninlined::Bool\nTrue if the code is from an inlined frame.\npointer::UInt64\nRepresentation of the pointer to the execution context as returned by backtrace.\n\n\n\n\n\n","category":"type"},{"location":"base/stacktraces.html#Base.StackTraces.StackTrace","page":"StackTraces","title":"Base.StackTraces.StackTrace","text":"StackTrace\n\nAn alias for Vector{StackFrame} provided for convenience; returned by calls to stacktrace.\n\n\n\n\n\n","category":"type"},{"location":"base/stacktraces.html#Base.StackTraces.stacktrace","page":"StackTraces","title":"Base.StackTraces.stacktrace","text":"stacktrace([trace::Vector{Ptr{Cvoid}},] [c_funcs::Bool=false]) -> StackTrace\n\nReturns a stack trace in the form of a vector of StackFrames. (By default stacktrace doesn't return C functions, but this can be enabled.) When called without specifying a trace, stacktrace first calls backtrace.\n\n\n\n\n\n","category":"function"},{"location":"base/stacktraces.html#","page":"StackTraces","title":"StackTraces","text":"The following methods and types in Base.StackTraces are not exported and need to be called e.g.  as StackTraces.lookup(ptr).","category":"page"},{"location":"base/stacktraces.html#","page":"StackTraces","title":"StackTraces","text":"Base.StackTraces.lookup\nBase.StackTraces.remove_frames!","category":"page"},{"location":"base/stacktraces.html#Base.StackTraces.lookup","page":"StackTraces","title":"Base.StackTraces.lookup","text":"lookup(pointer::Union{Ptr{Cvoid}, UInt}) -> Vector{StackFrame}\n\nGiven a pointer to an execution context (usually generated by a call to backtrace), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.\n\n\n\n\n\n","category":"function"},{"location":"base/stacktraces.html#Base.StackTraces.remove_frames!","page":"StackTraces","title":"Base.StackTraces.remove_frames!","text":"remove_frames!(stack::StackTrace, name::Symbol)\n\nTakes a StackTrace (a vector of StackFrames) and a function name (a Symbol) and removes the StackFrame specified by the function name from the StackTrace (also removing all frames above the specified function). Primarily used to remove StackTraces functions from the StackTrace prior to returning it.\n\n\n\n\n\nremove_frames!(stack::StackTrace, m::Module)\n\nReturns the StackTrace with all StackFrames from the provided Module removed.\n\n\n\n\n\n","category":"function"},{"location":"base/simd-types.html#SIMD-Support-1","page":"SIMD Support","title":"SIMD Support","text":"","category":"section"},{"location":"base/simd-types.html#","page":"SIMD Support","title":"SIMD Support","text":"Type VecElement{T} is intended for building libraries of SIMD operations. Practical use of it requires using llvmcall. The type is defined as:","category":"page"},{"location":"base/simd-types.html#","page":"SIMD Support","title":"SIMD Support","text":"struct VecElement{T}\n    value::T\nend","category":"page"},{"location":"base/simd-types.html#","page":"SIMD Support","title":"SIMD Support","text":"It has a special compilation rule: a homogeneous tuple of VecElement{T} maps to an LLVM vector type when T is a primitive bits type and the tuple length is in the set {2-6,8-10,16}.","category":"page"},{"location":"base/simd-types.html#","page":"SIMD Support","title":"SIMD Support","text":"At -O3, the compiler might automatically vectorize operations on such tuples. For example, the following program, when compiled with julia -O3 generates two SIMD addition instructions (addps) on x86 systems:","category":"page"},{"location":"base/simd-types.html#","page":"SIMD Support","title":"SIMD Support","text":"const m128 = NTuple{4,VecElement{Float32}}\n\nfunction add(a::m128, b::m128)\n    (VecElement(a[1].value+b[1].value),\n     VecElement(a[2].value+b[2].value),\n     VecElement(a[3].value+b[3].value),\n     VecElement(a[4].value+b[4].value))\nend\n\ntriple(c::m128) = add(add(c,c),c)\n\ncode_native(triple,(m128,))","category":"page"},{"location":"base/simd-types.html#","page":"SIMD Support","title":"SIMD Support","text":"However, since the automatic vectorization cannot be relied upon, future use will mostly be via libraries that use llvmcall.","category":"page"},{"location":"stdlib/Base64.html#Base64-1","page":"Base64","title":"Base64","text":"","category":"section"},{"location":"stdlib/Base64.html#","page":"Base64","title":"Base64","text":"DocTestSetup = :(using Base64)","category":"page"},{"location":"stdlib/Base64.html#","page":"Base64","title":"Base64","text":"Base64.Base64\nBase64.Base64EncodePipe\nBase64.base64encode\nBase64.Base64DecodePipe\nBase64.base64decode\nBase64.stringmime","category":"page"},{"location":"stdlib/Base64.html#Base64.Base64","page":"Base64","title":"Base64.Base64","text":"Base64\n\nFunctionality for base-64 encoded strings and IO.\n\n\n\n\n\n","category":"module"},{"location":"stdlib/Base64.html#Base64.Base64EncodePipe","page":"Base64","title":"Base64.Base64EncodePipe","text":"Base64EncodePipe(ostream)\n\nReturn a new write-only I/O stream, which converts any bytes written to it into base64-encoded ASCII bytes written to ostream.  Calling close on the Base64EncodePipe stream is necessary to complete the encoding (but does not close ostream).\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> iob64_encode = Base64EncodePipe(io);\n\njulia> write(iob64_encode, \"Hello!\")\n6\n\njulia> close(iob64_encode);\n\njulia> str = String(take!(io))\n\"SGVsbG8h\"\n\njulia> String(base64decode(str))\n\"Hello!\"\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Base64.html#Base64.base64encode","page":"Base64","title":"Base64.base64encode","text":"base64encode(writefunc, args...; context=nothing)\nbase64encode(args...; context=nothing)\n\nGiven a write-like function writefunc, which takes an I/O stream as its first argument, base64encode(writefunc, args...) calls writefunc to write args... to a base64-encoded string, and returns the string. base64encode(args...) is equivalent to base64encode(write, args...): it converts its arguments into bytes using the standard write functions and returns the base64-encoded string.\n\nThe optional keyword argument context can be set to :key=>value pair or an IO or IOContext object whose attributes are used for the I/O stream passed to writefunc or write.\n\nSee also base64decode.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Base64.html#Base64.Base64DecodePipe","page":"Base64","title":"Base64.Base64DecodePipe","text":"Base64DecodePipe(istream)\n\nReturn a new read-only I/O stream, which decodes base64-encoded data read from istream.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> iob64_decode = Base64DecodePipe(io);\n\njulia> write(io, \"SGVsbG8h\")\n8\n\njulia> seekstart(io);\n\njulia> String(read(iob64_decode))\n\"Hello!\"\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Base64.html#Base64.base64decode","page":"Base64","title":"Base64.base64decode","text":"base64decode(string)\n\nDecode the base64-encoded string and returns a Vector{UInt8} of the decoded bytes.\n\nSee also base64encode.\n\nExamples\n\njulia> b = base64decode(\"SGVsbG8h\")\n6-element Array{UInt8,1}:\n 0x48\n 0x65\n 0x6c\n 0x6c\n 0x6f\n 0x21\n\njulia> String(b)\n\"Hello!\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Base64.html#Base64.stringmime","page":"Base64","title":"Base64.stringmime","text":"stringmime(mime, x; context=nothing)\n\nReturns an AbstractString containing the representation of x in the requested mime type. This is similar to repr(mime, x) except that binary data is base64-encoded as an ASCII string.\n\nThe optional keyword argument context can be set to :key=>value pair or an IO or IOContext object whose attributes are used for the I/O stream passed to show.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Base64.html#","page":"Base64","title":"Base64","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/CRC32c.html#CRC32c-1","page":"CRC32c","title":"CRC32c","text":"","category":"section"},{"location":"stdlib/CRC32c.html#","page":"CRC32c","title":"CRC32c","text":"CRC32c.crc32c\nCRC32c.crc32c(::IO, ::Integer, ::UInt32)","category":"page"},{"location":"stdlib/CRC32c.html#CRC32c.crc32c","page":"CRC32c","title":"CRC32c.crc32c","text":"crc32c(data, crc::UInt32=0x00000000)\n\nCompute the CRC-32c checksum of the given data, which can be an Array{UInt8}, a contiguous subarray thereof, or a String.  Optionally, you can pass a starting crc integer to be mixed in with the checksum.  The crc parameter can be used to compute a checksum on data divided into chunks: performing crc32c(data2, crc32c(data1)) is equivalent to the checksum of [data1; data2]. (Technically, a little-endian checksum is computed.)\n\nThere is also a method crc32c(io, nb, crc) to checksum nb bytes from a stream io, or crc32c(io, crc) to checksum all the remaining bytes. Hence you can do open(crc32c, filename) to checksum an entire file, or crc32c(seekstart(buf)) to checksum an IOBuffer without calling take!.\n\nFor a String, note that the result is specific to the UTF-8 encoding (a different checksum would be obtained from a different Unicode encoding). To checksum an a::Array of some other bitstype, you can do crc32c(reinterpret(UInt8,a)), but note that the result may be endian-dependent.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/CRC32c.html#CRC32c.crc32c-Tuple{IO,Integer,UInt32}","page":"CRC32c","title":"CRC32c.crc32c","text":"crc32c(io::IO, [nb::Integer,] crc::UInt32=0x00000000)\n\nRead up to nb bytes from io and return the CRC-32c checksum, optionally mixed with a starting crc integer.  If nb is not supplied, then io will be read until the end of the stream.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates-1","page":"Dates","title":"Dates","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"DocTestSetup = :(using Dates)","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"The Dates module provides two types for working with dates: Date and DateTime, representing day and millisecond precision, respectively; both are subtypes of the abstract TimeType.  The motivation for distinct types is simple: some operations are much simpler, both in terms of code and mental reasoning, when the complexities of greater precision don't have to be dealt with.  For example, since the Date type only resolves to the precision of a single date (i.e. no hours, minutes, or seconds), normal considerations for time zones, daylight savings/summer time, and leap seconds are unnecessary and avoided.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Both Date and DateTime are basically immutable Int64 wrappers.  The single instant field of either type is actually a UTInstant{P} type, which represents a continuously increasing machine timeline based on the UT second [1]. The DateTime type is not aware of time zones (naive, in Python parlance), analogous to a LocalDateTime in Java 8. Additional time zone functionality can be added through the TimeZones.jl package, which compiles the IANA time zone database. Both Date and DateTime are based on the ISO 8601 standard, which follows the proleptic Gregorian calendar.  One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists.  The ISO standard, however, states that 1 BC/BCE is year zero, so 0000-12-31 is the day before 0001-01-01, and year -0001 (yes, negative one for the year) is 2 BC/BCE, year -0002 is 3 BC/BCE, etc.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"[1]: The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a \"UT second\", as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that Date and DateTime are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called UT or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates.","category":"page"},{"location":"stdlib/Dates.html#Constructors-1","page":"Dates","title":"Constructors","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Date and DateTime types can be constructed by integer or Period  types, by parsing, or through adjusters (more on those later):","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> DateTime(2013)\n2013-01-01T00:00:00\n\njulia> DateTime(2013,7)\n2013-07-01T00:00:00\n\njulia> DateTime(2013,7,1)\n2013-07-01T00:00:00\n\njulia> DateTime(2013,7,1,12)\n2013-07-01T12:00:00\n\njulia> DateTime(2013,7,1,12,30)\n2013-07-01T12:30:00\n\njulia> DateTime(2013,7,1,12,30,59)\n2013-07-01T12:30:59\n\njulia> DateTime(2013,7,1,12,30,59,1)\n2013-07-01T12:30:59.001\n\njulia> Date(2013)\n2013-01-01\n\njulia> Date(2013,7)\n2013-07-01\n\njulia> Date(2013,7,1)\n2013-07-01\n\njulia> Date(Dates.Year(2013),Dates.Month(7),Dates.Day(1))\n2013-07-01\n\njulia> Date(Dates.Month(7),Dates.Year(2013))\n2013-07-01","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Date or DateTime parsing is accomplished by the use of format strings. Format strings work by the notion of defining delimited or fixed-width \"slots\" that contain a period to parse and passing the text to parse and format string to a Date or DateTime constructor, of the form Date(\"2015-01-01\",\"y-m-d\") or DateTime(\"20150101\",\"yyyymmdd\").","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Delimited slots are marked by specifying the delimiter the parser should expect between two subsequent periods; so \"y-m-d\" lets the parser know that between the first and second slots in a date string like \"2014-07-16\", it should find the - character. The y, m, and d characters let the parser know which periods to parse in each slot.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between characters. So \"yyyymmdd\" would correspond to a date string like \"20140716\". The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition \"yyyymm\" from one period character to the next.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Support for text-form month parsing is also supported through the u and U characters, for abbreviated and full-length month names, respectively. By default, only English month names are supported, so u corresponds to \"Jan\", \"Feb\", \"Mar\", etc. And U corresponds to \"January\", \"February\", \"March\", etc. Similar to other name=>value mapping functions dayname and monthname, custom locales can be loaded by passing in the locale=>Dict{String,Int} mapping to the MONTHTOVALUEABBR and MONTHTOVALUE dicts for abbreviated and full-name month names, respectively.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"One note on parsing performance: using the Date(date_string,format_string) function is fine if only called a few times. If there are many similarly formatted date strings to parse however, it is much more efficient to first create a Dates.DateFormat, and pass it instead of a raw format string.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> df = DateFormat(\"y-m-d\");\n\njulia> dt = Date(\"2015-01-01\",df)\n2015-01-01\n\njulia> dt2 = Date(\"2015-01-02\",df)\n2015-01-02","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"You can also use the dateformat\"\" string macro. This macro creates the DateFormat object once when the macro is expanded and uses the same DateFormat object even if a code snippet is run multiple times.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> for i = 1:10^5\n           Date(\"2015-01-01\", dateformat\"y-m-d\")\n       end","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"A full suite of parsing and formatting tests and examples is available in stdlib/Dates/test/io.jl.","category":"page"},{"location":"stdlib/Dates.html#Durations/Comparisons-1","page":"Dates","title":"Durations/Comparisons","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Finding the length of time between two Date or DateTime is straightforward given their underlying representation as UTInstant{Day} and UTInstant{Millisecond}, respectively.  The difference between Date is returned in the number of Day, and DateTime  in the number of Millisecond. Similarly, comparing TimeType is a simple matter of comparing the underlying machine instants (which in turn compares the internal Int64 values).","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> dt = Date(2012,2,29)\n2012-02-29\n\njulia> dt2 = Date(2000,2,1)\n2000-02-01\n\njulia> dump(dt)\nDate\n  instant: Dates.UTInstant{Day}\n    periods: Day\n      value: Int64 734562\n\njulia> dump(dt2)\nDate\n  instant: Dates.UTInstant{Day}\n    periods: Day\n      value: Int64 730151\n\njulia> dt > dt2\ntrue\n\njulia> dt != dt2\ntrue\n\njulia> dt + dt2\nERROR: MethodError: no method matching +(::Date, ::Date)\n[...]\n\njulia> dt * dt2\nERROR: MethodError: no method matching *(::Date, ::Date)\n[...]\n\njulia> dt / dt2\nERROR: MethodError: no method matching /(::Date, ::Date)\n\njulia> dt - dt2\n4411 days\n\njulia> dt2 - dt\n-4411 days\n\njulia> dt = DateTime(2012,2,29)\n2012-02-29T00:00:00\n\njulia> dt2 = DateTime(2000,2,1)\n2000-02-01T00:00:00\n\njulia> dt - dt2\n381110400000 milliseconds","category":"page"},{"location":"stdlib/Dates.html#Accessor-Functions-1","page":"Dates","title":"Accessor Functions","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Because the Date and DateTime types are stored as single Int64 values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> t = Date(2014, 1, 31)\n2014-01-31\n\njulia> Dates.year(t)\n2014\n\njulia> Dates.month(t)\n1\n\njulia> Dates.week(t)\n5\n\njulia> Dates.day(t)\n31","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"While propercase return the same value in the corresponding Period type:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> Dates.Year(t)\n2014 years\n\njulia> Dates.Day(t)\n31 days","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Compound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> Dates.yearmonth(t)\n(2014, 1)\n\njulia> Dates.monthday(t)\n(1, 31)\n\njulia> Dates.yearmonthday(t)\n(2014, 1, 31)","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"One may also access the underlying UTInstant or integer value:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> dump(t)\nDate\n  instant: Dates.UTInstant{Day}\n    periods: Day\n      value: Int64 735264\n\njulia> t.instant\nDates.UTInstant{Day}(735264 days)\n\njulia> Dates.value(t)\n735264","category":"page"},{"location":"stdlib/Dates.html#Query-Functions-1","page":"Dates","title":"Query Functions","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Query functions provide calendrical information about a TimeType. They include information about the day of the week:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> t = Date(2014, 1, 31)\n2014-01-31\n\njulia> Dates.dayofweek(t)\n5\n\njulia> Dates.dayname(t)\n\"Friday\"\n\njulia> Dates.dayofweekofmonth(t) # 5th Friday of January\n5","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Month of the year:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> Dates.monthname(t)\n\"January\"\n\njulia> Dates.daysinmonth(t)\n31","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"As well as information about the TimeType's year and quarter:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> Dates.isleapyear(t)\nfalse\n\njulia> Dates.dayofyear(t)\n31\n\njulia> Dates.quarterofyear(t)\n1\n\njulia> Dates.dayofquarter(t)\n31","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"The dayname and monthname methods can also take an optional locale keyword that can be used to return the name of the day or month of the year for other languages/locales.  There are also versions of these functions returning the abbreviated names, namely dayabbr and monthabbr.  First the mapping is loaded into the LOCALES variable:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> french_months = [\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\",\n                        \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\"];\n\njulia> french_monts_abbrev = [\"janv\",\"févr\",\"mars\",\"avril\",\"mai\",\"juin\",\n                              \"juil\",\"août\",\"sept\",\"oct\",\"nov\",\"déc\"];\n\njulia> french_days = [\"lundi\",\"mardi\",\"mercredi\",\"jeudi\",\"vendredi\",\"samedi\",\"dimanche\"];\n\njulia> Dates.LOCALES[\"french\"] = Dates.DateLocale(french_months, french_monts_abbrev, french_days, [\"\"]);","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"The above mentioned functions can then be used to perform the queries:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> Dates.dayname(t;locale=\"french\")\n\"vendredi\"\n\njulia> Dates.monthname(t;locale=\"french\")\n\"janvier\"\n\njulia> Dates.monthabbr(t;locale=\"french\")\n\"janv\"","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Since the abbreviated versions of the days are not loaded, trying to use the function dayabbr will error.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> Dates.dayabbr(t;locale=\"french\")\nERROR: BoundsError: attempt to access 1-element Array{String,1} at index [5]\nStacktrace:\n[...]","category":"page"},{"location":"stdlib/Dates.html#TimeType-Period-Arithmetic-1","page":"Dates","title":"TimeType-Period Arithmetic","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"It's good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some tricky issues to deal with (though much less so for day-precision types).","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"The Dates module approach tries to follow the simple principle of trying to change as little as possible when doing Period arithmetic. This approach is also often known as calendrical arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let's take a classic example: add 1 month to January 31st, 2014. What's the answer? Javascript will say March 3 (assumes 31 days). PHP says March 2 (assumes 30 days). The fact is, there is no right answer. In the Dates module, it gives the result of February 28th. How does it figure that out? I like to think of the classic 7-7-7 gambling game in casinos.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31.  When you ask to add 1 month to this date, the month slot is incremented, so now we have 2014-02-31.  Then the day number is checked if it is greater than the last valid day of the new month; if it is (as in the case above), the day number is adjusted down to the last valid day (28). What are the ramifications with this approach? Go ahead and add another month to our date, 2014-02-28 + Month(1) == 2014-03-28.  What? Were you expecting the last day of March? Nope, sorry, remember the 7-7-7 slots. As few slots as possible are going to change, so we first increment the month slot by 1, 2014-03-28, and boom, we're done because that's a valid date. On the other hand, if we were to add 2 months to our original date, 2014-01-31, then we end up with 2014-03-31, as expected. The other ramification of this approach is a loss in associativity when a specific ordering is forced (i.e. adding things in different orders results in different outcomes). For example:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> (Date(2014,1,29)+Dates.Day(1)) + Dates.Month(1)\n2014-02-28\n\njulia> (Date(2014,1,29)+Dates.Month(1)) + Dates.Day(1)\n2014-03-01","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"What's going on there? In the first line, we're adding 1 day to January 29th, which results in 2014-01-30; then we add 1 month, so we get 2014-02-30, which then adjusts down to 2014-02-28.  In the second example, we add 1 month first, where we get 2014-02-29, which adjusts down to 2014-02-28, and then add 1 day, which results in 2014-03-01. One design principle that helps in this case is that, in the presence of multiple Periods, the operations will be ordered by the Periods' types, not their value or positional order; this means Year will always be added first, then Month, then Week, etc. Hence the following does result in associativity and Just Works:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> Date(2014,1,29) + Dates.Day(1) + Dates.Month(1)\n2014-03-01\n\njulia> Date(2014,1,29) + Dates.Month(1) + Dates.Day(1)\n2014-03-01","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Tricky? Perhaps. What is an innocent Dates user to do? The bottom line is to be aware that explicitly forcing a certain associativity, when dealing with months, may lead to some unexpected results, but otherwise, everything should work as expected. Thankfully, that's pretty much the extent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the \"joys\" of dealing with daylight savings, leap seconds, etc.).","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"As a bonus, all period arithmetic objects work directly with ranges:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> dr = Date(2014,1,29):Day(1):Date(2014,2,3)\n2014-01-29:1 day:2014-02-03\n\njulia> collect(dr)\n6-element Array{Date,1}:\n 2014-01-29\n 2014-01-30\n 2014-01-31\n 2014-02-01\n 2014-02-02\n 2014-02-03\n\njulia> dr = Date(2014,1,29):Dates.Month(1):Date(2014,07,29)\n2014-01-29:1 month:2014-07-29\n\njulia> collect(dr)\n7-element Array{Date,1}:\n 2014-01-29\n 2014-02-28\n 2014-03-29\n 2014-04-29\n 2014-05-29\n 2014-06-29\n 2014-07-29","category":"page"},{"location":"stdlib/Dates.html#Adjuster-Functions-1","page":"Dates","title":"Adjuster Functions","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a calendrical or temporal nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as \"Memorial Day = Last Monday of May\", or \"Thanksgiving = 4th Thursday of November\". These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"The Dates module provides the adjuster API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single TimeType  as input and return or adjust to the first or last of the desired period relative to the input.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> Dates.firstdayofweek(Date(2014,7,16)) # Adjusts the input to the Monday of the input's week\n2014-07-14\n\njulia> Dates.lastdayofmonth(Date(2014,7,16)) # Adjusts to the last day of the input's month\n2014-07-31\n\njulia> Dates.lastdayofquarter(Date(2014,7,16)) # Adjusts to the last day of the input's quarter\n2014-09-30","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"The next two higher-order methods, tonext, and toprev, generalize working with temporal expressions by taking a DateFunction as first argument, along with a starting TimeType. A DateFunction is just a function, usually anonymous, that takes a single TimeType as input and returns a Bool, true indicating a satisfied adjustment criterion.  For example:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> istuesday = x->Dates.dayofweek(x) == Dates.Tuesday; # Returns true if the day of the week of x is Tuesday\n\njulia> Dates.tonext(istuesday, Date(2014,7,13)) # 2014-07-13 is a Sunday\n2014-07-15\n\njulia> Dates.tonext(Date(2014,7,13), Dates.Tuesday) # Convenience method provided for day of the week adjustments\n2014-07-15","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"This is useful with the do-block syntax for more complex temporal expressions:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> Dates.tonext(Date(2014,7,13)) do x\n           # Return true on the 4th Thursday of November (Thanksgiving)\n           Dates.dayofweek(x) == Dates.Thursday &&\n           Dates.dayofweekofmonth(x) == 4 &&\n           Dates.month(x) == Dates.November\n       end\n2014-11-27","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"The Base.filter method can be used to obtain all valid dates/moments in a specified range:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"# Pittsburgh street cleaning; Every 2nd Tuesday from April to November\n# Date range from January 1st, 2014 to January 1st, 2015\njulia> dr = Dates.Date(2014):Day(1):Dates.Date(2015);\n\njulia> filter(dr) do x\n           Dates.dayofweek(x) == Dates.Tue &&\n           Dates.April <= Dates.month(x) <= Dates.Nov &&\n           Dates.dayofweekofmonth(x) == 2\n       end\n8-element Array{Date,1}:\n 2014-04-08\n 2014-05-13\n 2014-06-10\n 2014-07-08\n 2014-08-12\n 2014-09-09\n 2014-10-14\n 2014-11-11","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Additional examples and tests are available in stdlib/Dates/test/adjusters.jl.","category":"page"},{"location":"stdlib/Dates.html#Period-Types-1","page":"Dates","title":"Period Types","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Periods are a human view of discrete, sometimes irregular durations of time. Consider 1 month; it could represent, in days, a value of 28, 29, 30, or 31 depending on the year and month context.  Or a year could represent 365 or 366 days in the case of a leap year. Period types are simple Int64 wrappers and are constructed by wrapping any Int64 convertible type, i.e. Year(1) or Month(3.0). Arithmetic between Period of the same type behave like integers, and limited Period-Real arithmetic is available.  You can extract the underlying integer with Dates.value.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> y1 = Dates.Year(1)\n1 year\n\njulia> y2 = Dates.Year(2)\n2 years\n\njulia> y3 = Dates.Year(10)\n10 years\n\njulia> y1 + y2\n3 years\n\njulia> div(y3,y2)\n5\n\njulia> y3 - y2\n8 years\n\njulia> y3 % y2\n0 years\n\njulia> div(y3,3) # mirrors integer division\n3 years\n\njulia> Dates.value(Dates.Millisecond(10))\n10","category":"page"},{"location":"stdlib/Dates.html#Rounding-1","page":"Dates","title":"Rounding","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Date and DateTime values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with floor, ceil, or round:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> floor(Date(1985, 8, 16), Dates.Month)\n1985-08-01\n\njulia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\n2013-02-13T00:45:00\n\njulia> round(DateTime(2016, 8, 6, 20, 15), Dates.Day)\n2016-08-07T00:00:00","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Unlike the numeric round method, which breaks ties toward the even number by default, the TimeTyperound method uses the RoundNearestTiesUp rounding mode. (It's difficult to guess what breaking ties to nearest \"even\" TimeType would entail.) Further details on the available RoundingMode s can be found in the API reference.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Rounding should generally behave as expected, but there are a few cases in which the expected behaviour is not obvious.","category":"page"},{"location":"stdlib/Dates.html#Rounding-Epoch-1","page":"Dates","title":"Rounding Epoch","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"In many cases, the resolution specified for rounding (e.g., Dates.Second(30)) divides evenly into the next largest period (in this case, Dates.Minute(1)). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a DateTime  to the nearest 10 hours?","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> round(DateTime(2016, 7, 17, 11, 55), Dates.Hour(10))\n2016-07-17T12:00:00","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"That may seem confusing, given that the hour (12) is not divisible by","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"The reason that 2016-07-17T12:00:00 was chosen is that it is","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"17,676,660 hours after 0000-01-01T00:00:00, and 17,676,660 is divisible by","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"As Julia Date and DateTime values are represented according to the ISO 8601 standard, 0000-01-01T00:00:00 was chosen as base (or \"rounding epoch\") from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia's internal representation of Date s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, 0000-01-01T00:00:00 was chosen as the rounding epoch instead of the 0000-12-31T00:00:00 used internally to minimize confusion.)","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"The only exception to the use of 0000-01-01T00:00:00 as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use 0000-01-03T00:00:00 (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest P(2), where P is a Period type? In some cases (specifically, when P <: Dates.TimePeriod) the answer is clear:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Hour(2))\n2016-07-17T08:00:00\n\njulia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Minute(2))\n2016-07-17T08:56:00","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Month(2))\n2016-07-01T00:00:00","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Why round to the first day in July, even though it is month 7 (an odd number)? The key is that months are 1-indexed (the first month is assigned 1), unlike hours, minutes, seconds, and milliseconds (the first of which are assigned 0).","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"This means that rounding a DateTime to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a DateTime  with an even value in that field, while rounding a DateTime to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"See the API reference for additional information on methods exported from the Dates module.","category":"page"},{"location":"stdlib/Dates.html#stdlib-dates-api-1","page":"Dates","title":"API reference","text":"","category":"section"},{"location":"stdlib/Dates.html#Dates-and-Time-Types-1","page":"Dates","title":"Dates and Time Types","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Dates.Period\nDates.CompoundPeriod\nDates.Instant\nDates.UTInstant\nDates.TimeType\nDates.DateTime\nDates.Date\nDates.Time","category":"page"},{"location":"stdlib/Dates.html#Dates.Period","page":"Dates","title":"Dates.Period","text":"Period\nYear\nMonth\nWeek\nDay\nHour\nMinute\nSecond\nMillisecond\nMicrosecond\nNanosecond\n\nPeriod types represent discrete, human representations of time.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Dates.html#Dates.CompoundPeriod","page":"Dates","title":"Dates.CompoundPeriod","text":"CompoundPeriod\n\nA CompoundPeriod is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, \"a year and a  day\" is not a fixed number of days, but can be expressed using a CompoundPeriod. In fact, a CompoundPeriod is automatically generated by addition of different period types, e.g. Year(1) + Day(1) produces a CompoundPeriod result.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Dates.html#Dates.Instant","page":"Dates","title":"Dates.Instant","text":"Instant\n\nInstant types represent integer-based, machine representations of time as continuous timelines starting from an epoch.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Dates.html#Dates.UTInstant","page":"Dates","title":"Dates.UTInstant","text":"UTInstant{T}\n\nThe UTInstant represents a machine timeline based on UT time (1 day = one revolution of the earth). The T is a Period parameter that indicates the resolution or precision of the instant.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Dates.html#Dates.TimeType","page":"Dates","title":"Dates.TimeType","text":"TimeType\n\nTimeType types wrap Instant machine instances to provide human representations of the machine instant. Time, DateTime and Date are subtypes of TimeType.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Dates.html#Dates.DateTime","page":"Dates","title":"Dates.DateTime","text":"DateTime\n\nDateTime wraps a UTInstant{Millisecond} and interprets it according to the proleptic Gregorian calendar.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Dates.html#Dates.Date","page":"Dates","title":"Dates.Date","text":"Date\n\nDate wraps a UTInstant{Day} and interprets it according to the proleptic Gregorian calendar.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Dates.html#Dates.Time","page":"Dates","title":"Dates.Time","text":"Time\n\nTime wraps a Nanosecond and represents a specific moment in a 24-hour day.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Dates.html#Dates-Functions-1","page":"Dates","title":"Dates Functions","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Dates.DateTime(::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\nDates.DateTime(::Dates.Period)\nDates.DateTime(::Function, ::Any...)\nDates.DateTime(::Dates.TimeType)\nDates.DateTime(::AbstractString, ::AbstractString)\nDates.format\nDates.DateFormat\nDates.@dateformat_str\nDates.DateTime(::AbstractString, ::Dates.DateFormat)\nDates.Date(::Int64, ::Int64, ::Int64)\nDates.Date(::Dates.Period)\nDates.Date(::Function, ::Any, ::Any, ::Any)\nDates.Date(::Dates.TimeType)\nDates.Date(::AbstractString, ::AbstractString)\nDates.Date(::AbstractString, ::Dates.DateFormat)\nDates.Time(::Int64::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\nDates.Time(::Dates.TimePeriod)\nDates.Time(::Function, ::Any...)\nDates.Time(::Dates.DateTime)\nDates.now()\nDates.now(::Type{Dates.UTC})\nBase.eps","category":"page"},{"location":"stdlib/Dates.html#Dates.DateTime-NTuple{7,Int64}","page":"Dates","title":"Dates.DateTime","text":"DateTime(y, [m, d, h, mi, s, ms]) -> DateTime\n\nConstruct a DateTime type by parts. Arguments must be convertible to Int64.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.DateTime-Tuple{Period}","page":"Dates","title":"Dates.DateTime","text":"DateTime(periods::Period...) -> DateTime\n\nConstruct a DateTime type by Period type parts. Arguments may be in any order. DateTime parts not provided will default to the value of Dates.default(period).\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.DateTime-Tuple{Function,Vararg{Any,N} where N}","page":"Dates","title":"Dates.DateTime","text":"DateTime(f::Function, y[, m, d, h, mi, s]; step=Day(1), limit=10000) -> DateTime\n\nCreate a DateTime through the adjuster API. The starting point will be constructed from the provided y, m, d... arguments, and will be adjusted until f::Function returns true. The step size in adjusting can be provided manually through the step keyword. limit provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that f::Function is never satisfied).\n\nExamples\n\njulia> DateTime(dt -> Dates.second(dt) == 40, 2010, 10, 20, 10; step = Dates.Second(1))\n2010-10-20T10:00:40\n\njulia> DateTime(dt -> Dates.hour(dt) == 20, 2010, 10, 20, 10; step = Dates.Hour(1), limit = 5)\nERROR: ArgumentError: Adjustment limit reached: 5 iterations\nStacktrace:\n[...]\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.DateTime-Tuple{TimeType}","page":"Dates","title":"Dates.DateTime","text":"DateTime(dt::Date) -> DateTime\n\nConvert a Date to a DateTime. The hour, minute, second, and millisecond parts of the new DateTime are assumed to be zero.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.DateTime-Tuple{AbstractString,AbstractString}","page":"Dates","title":"Dates.DateTime","text":"DateTime(dt::AbstractString, format::AbstractString; locale=\"english\") -> DateTime\n\nConstruct a DateTime by parsing the dt date time string following the pattern given in the format string.\n\nThis method creates a DateFormat object each time it is called. If you are parsing many date time strings of the same format, consider creating a DateFormat object once and using that as the second argument instead.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.format","page":"Dates","title":"Dates.format","text":"format(io::IO, tok::AbstractDateToken, dt::TimeType, locale)\n\nFormat the tok token from dt and write it to io. The formatting can be based on locale.\n\nAll subtypes of AbstractDateToken must define this method in order to be able to print a Date / DateTime object according to a DateFormat containing that token.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.DateFormat","page":"Dates","title":"Dates.DateFormat","text":"DateFormat(format::AbstractString, locale=\"english\") -> DateFormat\n\nConstruct a date formatting object that can be used for parsing date strings or formatting a date object as a string. The following character codes can be used to construct the format string:\n\nCode Matches Comment\ny 1996, 96 Returns year of 1996, 0096\nY 1996, 96 Returns year of 1996, 0096. Equivalent to y\nm 1, 01 Matches 1 or 2-digit months\nu Jan Matches abbreviated months according to the locale keyword\nU January Matches full month names according to the locale keyword\nd 1, 01 Matches 1 or 2-digit days\nH 00 Matches hours\nM 00 Matches minutes\nS 00 Matches seconds\ns .500 Matches milliseconds\ne Mon, Tues Matches abbreviated days of the week\nE Monday Matches full name days of the week\nyyyymmdd 19960101 Matches fixed-width year, month, and day\n\nCharacters not listed above are normally treated as delimiters between date and time slots. For example a dt string of \"1996-01-15T00:00:00.0\" would have a format string like \"y-m-dTH:M:S.s\". If you need to use a code character as a delimiter you can escape it using backslash. The date \"1995y01m\" would have the format \"y\\ym\\m\".\n\nCreating a DateFormat object is expensive. Whenever possible, create it once and use it many times or try the dateformat\"\" string macro. Using this macro creates the DateFormat object once at macro expansion time and reuses it later. see @dateformat_str.\n\nSee DateTime and format for how to use a DateFormat object to parse and write Date strings respectively.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Dates.html#Dates.@dateformat_str","page":"Dates","title":"Dates.@dateformat_str","text":"dateformat\"Y-m-d H:M:S\"\n\nCreate a DateFormat object. Similar to DateFormat(\"Y-m-d H:M:S\") but creates the DateFormat object once during macro expansion.\n\nSee DateFormat for details about format specifiers.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Dates.html#Dates.DateTime-Tuple{AbstractString,DateFormat}","page":"Dates","title":"Dates.DateTime","text":"DateTime(dt::AbstractString, df::DateFormat) -> DateTime\n\nConstruct a DateTime by parsing the dt date time string following the pattern given in the DateFormat object. Similar to DateTime(::AbstractString, ::AbstractString) but more efficient when repeatedly parsing similarly formatted date time strings with a pre-created DateFormat object.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Date-Tuple{Int64,Int64,Int64}","page":"Dates","title":"Dates.Date","text":"Date(y, [m, d]) -> Date\n\nConstruct a Date type by parts. Arguments must be convertible to Int64.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Date-Tuple{Period}","page":"Dates","title":"Dates.Date","text":"Date(period::Period...) -> Date\n\nConstruct a Date type by Period type parts. Arguments may be in any order. Date parts not provided will default to the value of Dates.default(period).\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Date-Tuple{Function,Any,Any,Any}","page":"Dates","title":"Dates.Date","text":"Date(f::Function, y[, m, d]; step=Day(1), limit=10000) -> Date\n\nCreate a Date through the adjuster API. The starting point will be constructed from the provided y, m, d arguments, and will be adjusted until f::Function returns true. The step size in adjusting can be provided manually through the step keyword. limit provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that f::Function is never satisfied).\n\nExamples\n\njulia> Date(date -> Dates.week(date) == 20, 2010, 01, 01)\n2010-05-17\n\njulia> Date(date -> Dates.year(date) == 2010, 2000, 01, 01)\n2010-01-01\n\njulia> Date(date -> Dates.month(date) == 10, 2000, 01, 01; limit = 5)\nERROR: ArgumentError: Adjustment limit reached: 5 iterations\nStacktrace:\n[...]\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Date-Tuple{TimeType}","page":"Dates","title":"Dates.Date","text":"Date(dt::DateTime) -> Date\n\nConvert a DateTime to a Date. The hour, minute, second, and millisecond parts of the DateTime are truncated, so only the year, month and day parts are used in construction.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Date-Tuple{AbstractString,AbstractString}","page":"Dates","title":"Dates.Date","text":"Date(d::AbstractString, format::AbstractString; locale=\"english\") -> Date\n\nConstruct a Date by parsing the d date string following the pattern given in the format string.\n\nThis method creates a DateFormat object each time it is called. If you are parsing many date strings of the same format, consider creating a DateFormat object once and using that as the second argument instead.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Date-Tuple{AbstractString,DateFormat}","page":"Dates","title":"Dates.Date","text":"Date(d::AbstractString, df::DateFormat) -> Date\n\nParse a date from a date string d using a DateFormat object df.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Time-NTuple{5,Int64}","page":"Dates","title":"Dates.Time","text":"Time(h, [mi, s, ms, us, ns]) -> Time\n\nConstruct a Time type by parts. Arguments must be convertible to Int64.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Time-Tuple{TimePeriod}","page":"Dates","title":"Dates.Time","text":"Time(period::TimePeriod...) -> Time\n\nConstruct a Time type by Period type parts. Arguments may be in any order. Time parts not provided will default to the value of Dates.default(period).\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Time-Tuple{Function,Vararg{Any,N} where N}","page":"Dates","title":"Dates.Time","text":"Time(f::Function, h, mi=0; step::Period=Second(1), limit::Int=10000)\nTime(f::Function, h, mi, s; step::Period=Millisecond(1), limit::Int=10000)\nTime(f::Function, h, mi, s, ms; step::Period=Microsecond(1), limit::Int=10000)\nTime(f::Function, h, mi, s, ms, us; step::Period=Nanosecond(1), limit::Int=10000)\n\nCreate a Time through the adjuster API. The starting point will be constructed from the provided h, mi, s, ms, us arguments, and will be adjusted until f::Function returns true. The step size in adjusting can be provided manually through the step keyword. limit provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that f::Function is never satisfied). Note that the default step will adjust to allow for greater precision for the given arguments; i.e. if hour, minute, and second arguments are provided, the default step will be Millisecond(1) instead of Second(1).\n\nExamples\n\njulia> Dates.Time(t -> Dates.minute(t) == 30, 20)\n20:30:00\n\njulia> Dates.Time(t -> Dates.minute(t) == 0, 20)\n20:00:00\n\njulia> Dates.Time(t -> Dates.hour(t) == 10, 3; limit = 5)\nERROR: ArgumentError: Adjustment limit reached: 5 iterations\nStacktrace:\n[...]\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Time-Tuple{DateTime}","page":"Dates","title":"Dates.Time","text":"Time(dt::DateTime) -> Time\n\nConvert a DateTime to a Time. The hour, minute, second, and millisecond parts of the DateTime are used to create the new Time. Microsecond and nanoseconds are zero by default.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.now-Tuple{}","page":"Dates","title":"Dates.now","text":"now() -> DateTime\n\nReturn a DateTime corresponding to the user's system time including the system timezone locale.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.now-Tuple{Type{UTC}}","page":"Dates","title":"Dates.now","text":"now(::Type{UTC}) -> DateTime\n\nReturn a DateTime corresponding to the user's system time as UTC/GMT.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Base.eps","page":"Dates","title":"Base.eps","text":"eps(::DateTime) -> Millisecond\neps(::Date) -> Day\neps(::Time) -> Nanosecond\n\nReturns Millisecond(1) for DateTime values, Day(1) for Date values, and Nanosecond(1) for Time values.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Accessor-Functions-2","page":"Dates","title":"Accessor Functions","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Dates.year\nDates.month\nDates.week\nDates.day\nDates.hour\nDates.minute\nDates.second\nDates.millisecond\nDates.microsecond\nDates.nanosecond\nDates.Year(::Dates.TimeType)\nDates.Month(::Dates.TimeType)\nDates.Week(::Dates.TimeType)\nDates.Day(::Dates.TimeType)\nDates.Hour(::DateTime)\nDates.Minute(::DateTime)\nDates.Second(::DateTime)\nDates.Millisecond(::DateTime)\nDates.Microsecond(::Dates.Time)\nDates.Nanosecond(::Dates.Time)\nDates.yearmonth\nDates.monthday\nDates.yearmonthday","category":"page"},{"location":"stdlib/Dates.html#Dates.year","page":"Dates","title":"Dates.year","text":"year(dt::TimeType) -> Int64\n\nThe year of a Date or DateTime as an Int64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.month","page":"Dates","title":"Dates.month","text":"month(dt::TimeType) -> Int64\n\nThe month of a Date or DateTime as an Int64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.week","page":"Dates","title":"Dates.week","text":"week(dt::TimeType) -> Int64\n\nReturn the ISO week date of a Date or DateTime as an Int64. Note that the first week of a year is the week that contains the first Thursday of the year, which can result in dates prior to January 4th being in the last week of the previous year. For example, week(Date(2005, 1, 1)) is the 53rd week of 2004.\n\nExamples\n\njulia> Dates.week(Date(1989, 6, 22))\n25\n\njulia> Dates.week(Date(2005, 1, 1))\n53\n\njulia> Dates.week(Date(2004, 12, 31))\n53\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.day","page":"Dates","title":"Dates.day","text":"day(dt::TimeType) -> Int64\n\nThe day of month of a Date or DateTime as an Int64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.hour","page":"Dates","title":"Dates.hour","text":"hour(dt::DateTime) -> Int64\n\nThe hour of day of a DateTime as an Int64.\n\n\n\n\n\nhour(t::Time) -> Int64\n\nThe hour of a Time as an Int64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.minute","page":"Dates","title":"Dates.minute","text":"minute(dt::DateTime) -> Int64\n\nThe minute of a DateTime as an Int64.\n\n\n\n\n\nminute(t::Time) -> Int64\n\nThe minute of a Time as an Int64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.second","page":"Dates","title":"Dates.second","text":"second(dt::DateTime) -> Int64\n\nThe second of a DateTime as an Int64.\n\n\n\n\n\nsecond(t::Time) -> Int64\n\nThe second of a Time as an Int64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.millisecond","page":"Dates","title":"Dates.millisecond","text":"millisecond(dt::DateTime) -> Int64\n\nThe millisecond of a DateTime as an Int64.\n\n\n\n\n\nmillisecond(t::Time) -> Int64\n\nThe millisecond of a Time as an Int64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.microsecond","page":"Dates","title":"Dates.microsecond","text":"microsecond(t::Time) -> Int64\n\nThe microsecond of a Time as an Int64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.nanosecond","page":"Dates","title":"Dates.nanosecond","text":"nanosecond(t::Time) -> Int64\n\nThe nanosecond of a Time as an Int64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.Year-Tuple{TimeType}","page":"Dates","title":"Dates.Year","text":"Year(v)\n\nConstruct a Year object with the given v value. Input must be losslessly convertible to an Int64.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Month-Tuple{TimeType}","page":"Dates","title":"Dates.Month","text":"Month(v)\n\nConstruct a Month object with the given v value. Input must be losslessly convertible to an Int64.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Week-Tuple{TimeType}","page":"Dates","title":"Dates.Week","text":"Week(v)\n\nConstruct a Week object with the given v value. Input must be losslessly convertible to an Int64.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Day-Tuple{TimeType}","page":"Dates","title":"Dates.Day","text":"Day(v)\n\nConstruct a Day object with the given v value. Input must be losslessly convertible to an Int64.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Hour-Tuple{DateTime}","page":"Dates","title":"Dates.Hour","text":"Hour(dt::DateTime) -> Hour\n\nThe hour part of a DateTime as a Hour.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Minute-Tuple{DateTime}","page":"Dates","title":"Dates.Minute","text":"Minute(dt::DateTime) -> Minute\n\nThe minute part of a DateTime as a Minute.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Second-Tuple{DateTime}","page":"Dates","title":"Dates.Second","text":"Second(dt::DateTime) -> Second\n\nThe second part of a DateTime as a Second.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Millisecond-Tuple{DateTime}","page":"Dates","title":"Dates.Millisecond","text":"Millisecond(dt::DateTime) -> Millisecond\n\nThe millisecond part of a DateTime as a Millisecond.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Microsecond-Tuple{Time}","page":"Dates","title":"Dates.Microsecond","text":"Microsecond(dt::Time) -> Microsecond\n\nThe microsecond part of a Time as a Microsecond.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.Nanosecond-Tuple{Time}","page":"Dates","title":"Dates.Nanosecond","text":"Nanosecond(dt::Time) -> Nanosecond\n\nThe nanosecond part of a Time as a Nanosecond.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.yearmonth","page":"Dates","title":"Dates.yearmonth","text":"yearmonth(dt::TimeType) -> (Int64, Int64)\n\nSimultaneously return the year and month parts of a Date or DateTime.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.monthday","page":"Dates","title":"Dates.monthday","text":"monthday(dt::TimeType) -> (Int64, Int64)\n\nSimultaneously return the month and day parts of a Date or DateTime.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.yearmonthday","page":"Dates","title":"Dates.yearmonthday","text":"yearmonthday(dt::TimeType) -> (Int64, Int64, Int64)\n\nSimultaneously return the year, month and day parts of a Date or DateTime.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Query-Functions-2","page":"Dates","title":"Query Functions","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Dates.dayname\nDates.dayabbr\nDates.dayofweek\nDates.dayofmonth\nDates.dayofweekofmonth\nDates.daysofweekinmonth\nDates.monthname\nDates.monthabbr\nDates.daysinmonth\nDates.isleapyear\nDates.dayofyear\nDates.daysinyear\nDates.quarterofyear\nDates.dayofquarter","category":"page"},{"location":"stdlib/Dates.html#Dates.dayname","page":"Dates","title":"Dates.dayname","text":"dayname(dt::TimeType; locale=\"english\") -> String\n\nReturn the full day name corresponding to the day of the week of the Date or DateTime in the given locale.\n\nExamples\n\njulia> Dates.dayname(Date(\"2000-01-01\"))\n\"Saturday\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.dayabbr","page":"Dates","title":"Dates.dayabbr","text":"dayabbr(dt::TimeType; locale=\"english\") -> String\n\nReturn the abbreviated name corresponding to the day of the week of the Date or DateTime in the given locale.\n\nExamples\n\njulia> Dates.dayabbr(Date(\"2000-01-01\"))\n\"Sat\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.dayofweek","page":"Dates","title":"Dates.dayofweek","text":"dayofweek(dt::TimeType) -> Int64\n\nReturn the day of the week as an Int64 with 1 = Monday, 2 = Tuesday, etc..\n\nExamples\n\njulia> Dates.dayofweek(Date(\"2000-01-01\"))\n6\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.dayofmonth","page":"Dates","title":"Dates.dayofmonth","text":"dayofmonth(dt::TimeType) -> Int64\n\nThe day of month of a Date or DateTime as an Int64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.dayofweekofmonth","page":"Dates","title":"Dates.dayofweekofmonth","text":"dayofweekofmonth(dt::TimeType) -> Int\n\nFor the day of week of dt, return which number it is in dt's month. So if the day of the week of dt is Monday, then 1 = First Monday of the month, 2 = Second Monday of the month, etc. In the range 1:5.\n\nExamples\n\njulia> Dates.dayofweekofmonth(Date(\"2000-02-01\"))\n1\n\njulia> Dates.dayofweekofmonth(Date(\"2000-02-08\"))\n2\n\njulia> Dates.dayofweekofmonth(Date(\"2000-02-15\"))\n3\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.daysofweekinmonth","page":"Dates","title":"Dates.daysofweekinmonth","text":"daysofweekinmonth(dt::TimeType) -> Int\n\nFor the day of week of dt, return the total number of that day of the week in dt's month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including dayofweekofmonth(dt) == daysofweekinmonth(dt) in the adjuster function.\n\nExamples\n\njulia> Dates.daysofweekinmonth(Date(\"2005-01-01\"))\n5\n\njulia> Dates.daysofweekinmonth(Date(\"2005-01-04\"))\n4\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.monthname","page":"Dates","title":"Dates.monthname","text":"monthname(dt::TimeType; locale=\"english\") -> String\n\nReturn the full name of the month of the Date or DateTime in the given locale.\n\nExamples\n\njulia> Dates.monthname(Date(\"2005-01-04\"))\n\"January\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.monthabbr","page":"Dates","title":"Dates.monthabbr","text":"monthabbr(dt::TimeType; locale=\"english\") -> String\n\nReturn the abbreviated month name of the Date or DateTime in the given locale.\n\nExamples\n\njulia> Dates.monthabbr(Date(\"2005-01-04\"))\n\"Jan\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.daysinmonth","page":"Dates","title":"Dates.daysinmonth","text":"daysinmonth(dt::TimeType) -> Int\n\nReturn the number of days in the month of dt. Value will be 28, 29, 30, or 31.\n\nExamples\n\njulia> Dates.daysinmonth(Date(\"2000-01\"))\n31\n\njulia> Dates.daysinmonth(Date(\"2001-02\"))\n28\n\njulia> Dates.daysinmonth(Date(\"2000-02\"))\n29\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.isleapyear","page":"Dates","title":"Dates.isleapyear","text":"isleapyear(dt::TimeType) -> Bool\n\nReturn true if the year of dt is a leap year.\n\nExamples\n\njulia> Dates.isleapyear(Date(\"2004\"))\ntrue\n\njulia> Dates.isleapyear(Date(\"2005\"))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.dayofyear","page":"Dates","title":"Dates.dayofyear","text":"dayofyear(dt::TimeType) -> Int\n\nReturn the day of the year for dt with January 1st being day 1.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.daysinyear","page":"Dates","title":"Dates.daysinyear","text":"daysinyear(dt::TimeType) -> Int\n\nReturn 366 if the year of dt is a leap year, otherwise return 365.\n\nExamples\n\njulia> Dates.daysinyear(1999)\n365\n\njulia> Dates.daysinyear(2000)\n366\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.quarterofyear","page":"Dates","title":"Dates.quarterofyear","text":"quarterofyear(dt::TimeType) -> Int\n\nReturn the quarter that dt resides in. Range of value is 1:4.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.dayofquarter","page":"Dates","title":"Dates.dayofquarter","text":"dayofquarter(dt::TimeType) -> Int\n\nReturn the day of the current quarter of dt. Range of value is 1:92.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Adjuster-Functions-2","page":"Dates","title":"Adjuster Functions","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Base.trunc(::Dates.TimeType, ::Type{Dates.Period})\nDates.firstdayofweek\nDates.lastdayofweek\nDates.firstdayofmonth\nDates.lastdayofmonth\nDates.firstdayofyear\nDates.lastdayofyear\nDates.firstdayofquarter\nDates.lastdayofquarter\nDates.tonext(::Dates.TimeType, ::Int)\nDates.toprev(::Dates.TimeType, ::Int)\nDates.tofirst\nDates.tolast\nDates.tonext(::Function, ::Dates.TimeType)\nDates.toprev(::Function, ::Dates.TimeType)","category":"page"},{"location":"stdlib/Dates.html#Base.trunc-Tuple{TimeType,Type{Period}}","page":"Dates","title":"Base.trunc","text":"trunc(dt::TimeType, ::Type{Period}) -> TimeType\n\nTruncates the value of dt according to the provided Period type.\n\nExamples\n\njulia> trunc(Dates.DateTime(\"1996-01-01T12:30:00\"), Dates.Day)\n1996-01-01T00:00:00\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.firstdayofweek","page":"Dates","title":"Dates.firstdayofweek","text":"firstdayofweek(dt::TimeType) -> TimeType\n\nAdjusts dt to the Monday of its week.\n\nExamples\n\njulia> Dates.firstdayofweek(DateTime(\"1996-01-05T12:30:00\"))\n1996-01-01T00:00:00\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.lastdayofweek","page":"Dates","title":"Dates.lastdayofweek","text":"lastdayofweek(dt::TimeType) -> TimeType\n\nAdjusts dt to the Sunday of its week.\n\nExamples\n\njulia> Dates.lastdayofweek(DateTime(\"1996-01-05T12:30:00\"))\n1996-01-07T00:00:00\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.firstdayofmonth","page":"Dates","title":"Dates.firstdayofmonth","text":"firstdayofmonth(dt::TimeType) -> TimeType\n\nAdjusts dt to the first day of its month.\n\nExamples\n\njulia> Dates.firstdayofmonth(DateTime(\"1996-05-20\"))\n1996-05-01T00:00:00\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.lastdayofmonth","page":"Dates","title":"Dates.lastdayofmonth","text":"lastdayofmonth(dt::TimeType) -> TimeType\n\nAdjusts dt to the last day of its month.\n\nExamples\n\njulia> Dates.lastdayofmonth(DateTime(\"1996-05-20\"))\n1996-05-31T00:00:00\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.firstdayofyear","page":"Dates","title":"Dates.firstdayofyear","text":"firstdayofyear(dt::TimeType) -> TimeType\n\nAdjusts dt to the first day of its year.\n\nExamples\n\njulia> Dates.firstdayofyear(DateTime(\"1996-05-20\"))\n1996-01-01T00:00:00\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.lastdayofyear","page":"Dates","title":"Dates.lastdayofyear","text":"lastdayofyear(dt::TimeType) -> TimeType\n\nAdjusts dt to the last day of its year.\n\nExamples\n\njulia> Dates.lastdayofyear(DateTime(\"1996-05-20\"))\n1996-12-31T00:00:00\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.firstdayofquarter","page":"Dates","title":"Dates.firstdayofquarter","text":"firstdayofquarter(dt::TimeType) -> TimeType\n\nAdjusts dt to the first day of its quarter.\n\nExamples\n\njulia> Dates.firstdayofquarter(DateTime(\"1996-05-20\"))\n1996-04-01T00:00:00\n\njulia> Dates.firstdayofquarter(DateTime(\"1996-08-20\"))\n1996-07-01T00:00:00\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.lastdayofquarter","page":"Dates","title":"Dates.lastdayofquarter","text":"lastdayofquarter(dt::TimeType) -> TimeType\n\nAdjusts dt to the last day of its quarter.\n\nExamples\n\njulia> Dates.lastdayofquarter(DateTime(\"1996-05-20\"))\n1996-06-30T00:00:00\n\njulia> Dates.lastdayofquarter(DateTime(\"1996-08-20\"))\n1996-09-30T00:00:00\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.tonext-Tuple{TimeType,Int64}","page":"Dates","title":"Dates.tonext","text":"tonext(dt::TimeType, dow::Int; same::Bool=false) -> TimeType\n\nAdjusts dt to the next day of week corresponding to dow with 1 = Monday, 2 = Tuesday, etc. Setting same=true allows the current dt to be considered as the next dow, allowing for no adjustment to occur.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.toprev-Tuple{TimeType,Int64}","page":"Dates","title":"Dates.toprev","text":"toprev(dt::TimeType, dow::Int; same::Bool=false) -> TimeType\n\nAdjusts dt to the previous day of week corresponding to dow with 1 = Monday, 2 = Tuesday, etc. Setting same=true allows the current dt to be considered as the previous dow, allowing for no adjustment to occur.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.tofirst","page":"Dates","title":"Dates.tofirst","text":"tofirst(dt::TimeType, dow::Int; of=Month) -> TimeType\n\nAdjusts dt to the first dow of its month. Alternatively, of=Year will adjust to the first dow of the year.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.tolast","page":"Dates","title":"Dates.tolast","text":"tolast(dt::TimeType, dow::Int; of=Month) -> TimeType\n\nAdjusts dt to the last dow of its month. Alternatively, of=Year will adjust to the last dow of the year.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.tonext-Tuple{Function,TimeType}","page":"Dates","title":"Dates.tonext","text":"tonext(func::Function, dt::TimeType; step=Day(1), limit=10000, same=false) -> TimeType\n\nAdjusts dt by iterating at most limit iterations by step increments until func returns true. func must take a single TimeType argument and return a Bool. same allows dt to be considered in satisfying func.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.toprev-Tuple{Function,TimeType}","page":"Dates","title":"Dates.toprev","text":"toprev(func::Function, dt::TimeType; step=Day(-1), limit=10000, same=false) -> TimeType\n\nAdjusts dt by iterating at most limit iterations by step increments until func returns true. func must take a single TimeType argument and return a Bool. same allows dt to be considered in satisfying func.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Periods-1","page":"Dates","title":"Periods","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Dates.Period(::Any)\nDates.CompoundPeriod(::Vector{<:Dates.Period})\nDates.value\nDates.default","category":"page"},{"location":"stdlib/Dates.html#Dates.Period-Tuple{Any}","page":"Dates","title":"Dates.Period","text":"Year(v)\nMonth(v)\nWeek(v)\nDay(v)\nHour(v)\nMinute(v)\nSecond(v)\nMillisecond(v)\nMicrosecond(v)\nNanosecond(v)\n\nConstruct a Period type with the given v value. Input must be losslessly convertible to an Int64.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.CompoundPeriod-Tuple{Array{#s3,1} where #s3<:Period}","page":"Dates","title":"Dates.CompoundPeriod","text":"CompoundPeriod(periods) -> CompoundPeriod\n\nConstruct a CompoundPeriod from a Vector of Periods. All Periods of the same type will be added together.\n\nExamples\n\njulia> Dates.CompoundPeriod(Dates.Hour(12), Dates.Hour(13))\n25 hours\n\njulia> Dates.CompoundPeriod(Dates.Hour(-1), Dates.Minute(1))\n-1 hour, 1 minute\n\njulia> Dates.CompoundPeriod(Dates.Month(1), Dates.Week(-2))\n1 month, -2 weeks\n\njulia> Dates.CompoundPeriod(Dates.Minute(50000))\n50000 minutes\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Dates.value","page":"Dates","title":"Dates.value","text":"Dates.value(x::Period) -> Int64\n\nFor a given period, return the value associated with that period.  For example, value(Millisecond(10)) returns 10 as an integer.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.default","page":"Dates","title":"Dates.default","text":"default(p::Period) -> Period\n\nReturns a sensible \"default\" value for the input Period by returning T(1) for Year, Month, and Day, and T(0) for Hour, Minute, Second, and Millisecond.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Rounding-Functions-1","page":"Dates","title":"Rounding Functions","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Date and DateTime values can be rounded to a specified resolution (e.g., 1 month or 15 minutes)  with floor, ceil, or round.","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Base.floor(::Dates.TimeType, ::Dates.Period)\nBase.ceil(::Dates.TimeType, ::Dates.Period)\nBase.round(::Dates.TimeType, ::Dates.Period, ::RoundingMode{:NearestTiesUp})","category":"page"},{"location":"stdlib/Dates.html#Base.floor-Tuple{TimeType,Period}","page":"Dates","title":"Base.floor","text":"floor(dt::TimeType, p::Period) -> TimeType\n\nReturn the nearest Date or DateTime less than or equal to dt at resolution p.\n\nFor convenience, p may be a type instead of a value: floor(dt, Dates.Hour) is a shortcut for floor(dt, Dates.Hour(1)).\n\njulia> floor(Date(1985, 8, 16), Dates.Month)\n1985-08-01\n\njulia> floor(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\n2013-02-13T00:30:00\n\njulia> floor(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)\n2016-08-06T00:00:00\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Base.ceil-Tuple{TimeType,Period}","page":"Dates","title":"Base.ceil","text":"ceil(dt::TimeType, p::Period) -> TimeType\n\nReturn the nearest Date or DateTime greater than or equal to dt at resolution p.\n\nFor convenience, p may be a type instead of a value: ceil(dt, Dates.Hour) is a shortcut for ceil(dt, Dates.Hour(1)).\n\njulia> ceil(Date(1985, 8, 16), Dates.Month)\n1985-09-01\n\njulia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\n2013-02-13T00:45:00\n\njulia> ceil(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)\n2016-08-07T00:00:00\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Base.round-Tuple{TimeType,Period,RoundingMode{:NearestTiesUp}}","page":"Dates","title":"Base.round","text":"round(dt::TimeType, p::Period, [r::RoundingMode]) -> TimeType\n\nReturn the Date or DateTime nearest to dt at resolution p. By default (RoundNearestTiesUp), ties (e.g., rounding 9:30 to the nearest hour) will be rounded up.\n\nFor convenience, p may be a type instead of a value: round(dt, Dates.Hour) is a shortcut for round(dt, Dates.Hour(1)).\n\njulia> round(Date(1985, 8, 16), Dates.Month)\n1985-08-01\n\njulia> round(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\n2013-02-13T00:30:00\n\njulia> round(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)\n2016-08-07T00:00:00\n\nValid rounding modes for round(::TimeType, ::Period, ::RoundingMode) are RoundNearestTiesUp (default), RoundDown (floor), and RoundUp (ceil).\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Most Period values can also be rounded to a specified resolution:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Base.floor(::Dates.ConvertiblePeriod, ::T) where T <: Dates.ConvertiblePeriod\nBase.ceil(::Dates.ConvertiblePeriod, ::Dates.ConvertiblePeriod)\nBase.round(::Dates.ConvertiblePeriod, ::Dates.ConvertiblePeriod, ::RoundingMode{:NearestTiesUp})","category":"page"},{"location":"stdlib/Dates.html#Base.floor-Union{Tuple{T}, Tuple{Union{Day, Week, TimePeriod},T}} where T<:Union{Day, Week, TimePeriod}","page":"Dates","title":"Base.floor","text":"floor(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> T\n\nRound x down to the nearest multiple of precision. If x and precision are different subtypes of Period, the return value will have the same type as precision.\n\nFor convenience, precision may be a type instead of a value: floor(x, Dates.Hour) is a shortcut for floor(x, Dates.Hour(1)).\n\njulia> floor(Dates.Day(16), Dates.Week)\n2 weeks\n\njulia> floor(Dates.Minute(44), Dates.Minute(15))\n30 minutes\n\njulia> floor(Dates.Hour(36), Dates.Day)\n1 day\n\nRounding to a precision of Months or Years is not supported, as these Periods are of inconsistent length.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Base.ceil-Tuple{Union{Day, Week, TimePeriod},Union{Day, Week, TimePeriod}}","page":"Dates","title":"Base.ceil","text":"ceil(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> T\n\nRound x up to the nearest multiple of precision. If x and precision are different subtypes of Period, the return value will have the same type as precision.\n\nFor convenience, precision may be a type instead of a value: ceil(x, Dates.Hour) is a shortcut for ceil(x, Dates.Hour(1)).\n\njulia> ceil(Dates.Day(16), Dates.Week)\n3 weeks\n\njulia> ceil(Dates.Minute(44), Dates.Minute(15))\n45 minutes\n\njulia> ceil(Dates.Hour(36), Dates.Day)\n2 days\n\nRounding to a precision of Months or Years is not supported, as these Periods are of inconsistent length.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#Base.round-Tuple{Union{Day, Week, TimePeriod},Union{Day, Week, TimePeriod},RoundingMode{:NearestTiesUp}}","page":"Dates","title":"Base.round","text":"round(x::Period, precision::T, [r::RoundingMode]) where T <: Union{TimePeriod, Week, Day} -> T\n\nRound x to the nearest multiple of precision. If x and precision are different subtypes of Period, the return value will have the same type as precision. By default (RoundNearestTiesUp), ties (e.g., rounding 90 minutes to the nearest hour) will be rounded up.\n\nFor convenience, precision may be a type instead of a value: round(x, Dates.Hour) is a shortcut for round(x, Dates.Hour(1)).\n\njulia> round(Dates.Day(16), Dates.Week)\n2 weeks\n\njulia> round(Dates.Minute(44), Dates.Minute(15))\n45 minutes\n\njulia> round(Dates.Hour(36), Dates.Day)\n2 days\n\nValid rounding modes for round(::Period, ::T, ::RoundingMode) are RoundNearestTiesUp (default), RoundDown (floor), and RoundUp (ceil).\n\nRounding to a precision of Months or Years is not supported, as these Periods are of inconsistent length.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"The following functions are not exported:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Dates.floorceil\nDates.epochdays2date\nDates.epochms2datetime\nDates.date2epochdays\nDates.datetime2epochms","category":"page"},{"location":"stdlib/Dates.html#Dates.floorceil","page":"Dates","title":"Dates.floorceil","text":"floorceil(dt::TimeType, p::Period) -> (TimeType, TimeType)\n\nSimultaneously return the floor and ceil of a Date or DateTime at resolution p. More efficient than calling both floor and ceil individually.\n\n\n\n\n\nfloorceil(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> (T, T)\n\nSimultaneously return the floor and ceil of Period at resolution p.  More efficient than calling both floor and ceil individually.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.epochdays2date","page":"Dates","title":"Dates.epochdays2date","text":"epochdays2date(days) -> Date\n\nTake the number of days since the rounding epoch (0000-01-01T00:00:00) and return the corresponding Date.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.epochms2datetime","page":"Dates","title":"Dates.epochms2datetime","text":"epochms2datetime(milliseconds) -> DateTime\n\nTake the number of milliseconds since the rounding epoch (0000-01-01T00:00:00) and return the corresponding DateTime.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.date2epochdays","page":"Dates","title":"Dates.date2epochdays","text":"date2epochdays(dt::Date) -> Int64\n\nTake the given Date and return the number of days since the rounding epoch (0000-01-01T00:00:00) as an Int64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.datetime2epochms","page":"Dates","title":"Dates.datetime2epochms","text":"datetime2epochms(dt::DateTime) -> Int64\n\nTake the given DateTime and return the number of milliseconds since the rounding epoch (0000-01-01T00:00:00) as an Int64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Conversion-Functions-1","page":"Dates","title":"Conversion Functions","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Dates.today\nDates.unix2datetime\nDates.datetime2unix\nDates.julian2datetime\nDates.datetime2julian\nDates.rata2datetime\nDates.datetime2rata","category":"page"},{"location":"stdlib/Dates.html#Dates.today","page":"Dates","title":"Dates.today","text":"today() -> Date\n\nReturn the date portion of now().\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.unix2datetime","page":"Dates","title":"Dates.unix2datetime","text":"unix2datetime(x) -> DateTime\n\nTake the number of seconds since unix epoch 1970-01-01T00:00:00 and convert to the corresponding DateTime.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.datetime2unix","page":"Dates","title":"Dates.datetime2unix","text":"datetime2unix(dt::DateTime) -> Float64\n\nTake the given DateTime and return the number of seconds since the unix epoch 1970-01-01T00:00:00 as a Float64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.julian2datetime","page":"Dates","title":"Dates.julian2datetime","text":"julian2datetime(julian_days) -> DateTime\n\nTake the number of Julian calendar days since epoch -4713-11-24T12:00:00 and return the corresponding DateTime.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.datetime2julian","page":"Dates","title":"Dates.datetime2julian","text":"datetime2julian(dt::DateTime) -> Float64\n\nTake the given DateTime and return the number of Julian calendar days since the julian epoch -4713-11-24T12:00:00 as a Float64.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.rata2datetime","page":"Dates","title":"Dates.rata2datetime","text":"rata2datetime(days) -> DateTime\n\nTake the number of Rata Die days since epoch 0000-12-31T00:00:00 and return the corresponding DateTime.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Dates.datetime2rata","page":"Dates","title":"Dates.datetime2rata","text":"datetime2rata(dt::TimeType) -> Int64\n\nReturn the number of Rata Die days since epoch from the given Date or DateTime.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Dates.html#Constants-1","page":"Dates","title":"Constants","text":"","category":"section"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Days of the Week:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Variable Abbr. Value (Int)\nMonday Mon 1\nTuesday Tue 2\nWednesday Wed 3\nThursday Thu 4\nFriday Fri 5\nSaturday Sat 6\nSunday Sun 7","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Months of the Year:","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"Variable Abbr. Value (Int)\nJanuary Jan 1\nFebruary Feb 2\nMarch Mar 3\nApril Apr 4\nMay May 5\nJune Jun 6\nJuly Jul 7\nAugust Aug 8\nSeptember Sep 9\nOctober Oct 10\nNovember Nov 11\nDecember Dec 12","category":"page"},{"location":"stdlib/Dates.html#","page":"Dates","title":"Dates","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/DelimitedFiles.html#Delimited-Files-1","page":"Delimited Files","title":"Delimited Files","text":"","category":"section"},{"location":"stdlib/DelimitedFiles.html#","page":"Delimited Files","title":"Delimited Files","text":"DocTestSetup = :(using DelimitedFiles)","category":"page"},{"location":"stdlib/DelimitedFiles.html#","page":"Delimited Files","title":"Delimited Files","text":"DelimitedFiles.readdlm(::Any, ::AbstractChar, ::Type, ::AbstractChar)\nDelimitedFiles.readdlm(::Any, ::AbstractChar, ::AbstractChar)\nDelimitedFiles.readdlm(::Any, ::AbstractChar, ::Type)\nDelimitedFiles.readdlm(::Any, ::AbstractChar)\nDelimitedFiles.readdlm(::Any, ::Type)\nDelimitedFiles.readdlm(::Any)\nDelimitedFiles.writedlm","category":"page"},{"location":"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any,AbstractChar,Type,AbstractChar}","page":"Delimited Files","title":"DelimitedFiles.readdlm","text":"readdlm(source, delim::AbstractChar, T::Type, eol::AbstractChar; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=false, comment_char='#')\n\nRead a matrix from the source where each line (separated by eol) gives one row, with elements separated by the given delimiter. The source can be a text file, stream or byte array. Memory mapped files can be used by passing the byte array representation of the mapped segment as source.\n\nIf T is a numeric type, the result is an array of that type, with any non-numeric elements as NaN for floating-point types, or zero. Other useful values of T include String, AbstractString, and Any.\n\nIf header is true, the first row of data will be read as header and the tuple (data_cells, header_cells) is returned instead of only data_cells.\n\nSpecifying skipstart will ignore the corresponding number of initial lines from the input.\n\nIf skipblanks is true, blank lines in the input will be ignored.\n\nIf use_mmap is true, the file specified by source is memory mapped for potential speedups. Default is true except on Windows. On Windows, you may want to specify true if the file is large, and is only read once and not written to.\n\nIf quotes is true, columns enclosed within double-quote (\") characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote.  Specifying dims as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files.  If comments is true, lines beginning with comment_char and text following comment_char in any line are ignored.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [5; 6; 7; 8];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y])\n       end\n\njulia> readdlm(\"delim_file.txt\", '\\t', Int, '\\n')\n4×2 Array{Int64,2}:\n 1  5\n 2  6\n 3  7\n 4  8\n\n\n\n\n\n","category":"method"},{"location":"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any,AbstractChar,AbstractChar}","page":"Delimited Files","title":"DelimitedFiles.readdlm","text":"readdlm(source, delim::AbstractChar, eol::AbstractChar; options...)\n\nIf all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any,AbstractChar,Type}","page":"Delimited Files","title":"DelimitedFiles.readdlm","text":"readdlm(source, delim::AbstractChar, T::Type; options...)\n\nThe end of line delimiter is taken as \\n.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [1.1; 2.2; 3.3; 4.4];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y], ',')\n       end;\n\njulia> readdlm(\"delim_file.txt\", ',', Float64)\n4×2 Array{Float64,2}:\n 1.0  1.1\n 2.0  2.2\n 3.0  3.3\n 4.0  4.4\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n","category":"method"},{"location":"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any,AbstractChar}","page":"Delimited Files","title":"DelimitedFiles.readdlm","text":"readdlm(source, delim::AbstractChar; options...)\n\nThe end of line delimiter is taken as \\n. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [1.1; 2.2; 3.3; 4.4];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y], ',')\n       end;\n\njulia> readdlm(\"delim_file.txt\", ',')\n4×2 Array{Float64,2}:\n 1.0  1.1\n 2.0  2.2\n 3.0  3.3\n 4.0  4.4\n\njulia> rm(\"delim_file.txt\")\n\njulia> z = [\"a\"; \"b\"; \"c\"; \"d\"];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x z], ',')\n       end;\n\njulia> readdlm(\"delim_file.txt\", ',')\n4×2 Array{Any,2}:\n 1  \"a\"\n 2  \"b\"\n 3  \"c\"\n 4  \"d\"\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n","category":"method"},{"location":"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any,Type}","page":"Delimited Files","title":"DelimitedFiles.readdlm","text":"readdlm(source, T::Type; options...)\n\nThe columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \\n.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [5; 6; 7; 8];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y])\n       end;\n\njulia> readdlm(\"delim_file.txt\", Int64)\n4×2 Array{Int64,2}:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> readdlm(\"delim_file.txt\", Float64)\n4×2 Array{Float64,2}:\n 1.0  5.0\n 2.0  6.0\n 3.0  7.0\n 4.0  8.0\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n","category":"method"},{"location":"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any}","page":"Delimited Files","title":"DelimitedFiles.readdlm","text":"readdlm(source; options...)\n\nThe columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \\n. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [\"a\"; \"b\"; \"c\"; \"d\"];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y])\n       end;\n\njulia> readdlm(\"delim_file.txt\")\n4×2 Array{Any,2}:\n 1  \"a\"\n 2  \"b\"\n 3  \"c\"\n 4  \"d\"\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n","category":"method"},{"location":"stdlib/DelimitedFiles.html#DelimitedFiles.writedlm","page":"Delimited Files","title":"DelimitedFiles.writedlm","text":"writedlm(f, A, delim='\\t'; opts)\n\nWrite A (a vector, matrix, or an iterable collection of iterable rows) as text to f (either a filename string or an IO stream) using the given delimiter delim (which defaults to tab, but can be any printable Julia object, typically a Char or AbstractString).\n\nFor example, two vectors x and y of the same length can be written as two columns of tab-delimited text to f by either writedlm(f, [x y]) or by writedlm(f, zip(x, y)).\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [5; 6; 7; 8];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y])\n       end\n\njulia> readdlm(\"delim_file.txt\", '\\t', Int, '\\n')\n4×2 Array{Int64,2}:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n","category":"function"},{"location":"stdlib/DelimitedFiles.html#","page":"Delimited Files","title":"Delimited Files","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/Distributed.html#Distributed-Computing-1","page":"Distributed Computing","title":"Distributed Computing","text":"","category":"section"},{"location":"stdlib/Distributed.html#","page":"Distributed Computing","title":"Distributed Computing","text":"DocTestSetup = :(using Distributed)","category":"page"},{"location":"stdlib/Distributed.html#","page":"Distributed Computing","title":"Distributed Computing","text":"Distributed.addprocs\nDistributed.nprocs\nDistributed.nworkers\nDistributed.procs()\nDistributed.procs(::Integer)\nDistributed.workers\nDistributed.rmprocs\nDistributed.interrupt\nDistributed.myid\nDistributed.pmap\nDistributed.RemoteException\nDistributed.Future\nDistributed.RemoteChannel\nDistributed.fetch(::Future)\nDistributed.fetch(::RemoteChannel)\nDistributed.remotecall(::Any, ::Integer, ::Any...)\nDistributed.remotecall_wait(::Any, ::Integer, ::Any...)\nDistributed.remotecall_fetch(::Any, ::Integer, ::Any...)\nDistributed.remote_do(::Any, ::Integer, ::Any...)\nDistributed.put!(::RemoteChannel, ::Any...)\nDistributed.put!(::Future, ::Any)\nDistributed.take!(::RemoteChannel, ::Any...)\nDistributed.isready(::RemoteChannel, ::Any...)\nDistributed.isready(::Future)\nDistributed.AbstractWorkerPool\nDistributed.WorkerPool\nDistributed.CachingPool\nDistributed.default_worker_pool\nDistributed.clear!(::CachingPool)\nDistributed.remote\nDistributed.remotecall(::Any, ::AbstractWorkerPool, ::Any...)\nDistributed.remotecall_wait(::Any, ::AbstractWorkerPool, ::Any...)\nDistributed.remotecall_fetch(::Any, ::AbstractWorkerPool, ::Any...)\nDistributed.remote_do(::Any, ::AbstractWorkerPool, ::Any...)\nDistributed.@spawn\nDistributed.@spawnat\nDistributed.@fetch\nDistributed.@fetchfrom\nDistributed.@distributed\nDistributed.@everywhere\nDistributed.clear!(::Any, ::Any; ::Any)\nDistributed.remoteref_id\nDistributed.channel_from_id\nDistributed.worker_id_from_socket\nDistributed.cluster_cookie()\nDistributed.cluster_cookie(::Any)","category":"page"},{"location":"stdlib/Distributed.html#Distributed.addprocs","page":"Distributed Computing","title":"Distributed.addprocs","text":"addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers\n\nLaunches worker processes via the specified cluster manager.\n\nFor example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl.\n\nThe number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport.\n\nTo launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task.\n\nExamples\n\n# On busy clusters, call `addprocs` asynchronously\nt = @async addprocs(...)\n\n# Utilize workers as and when they come online\nif nprocs() > 1   # Ensure at least one new worker is available\n   ....   # perform distributed execution\nend\n\n# Retrieve newly launched worker IDs, or any error messages\nif istaskdone(t)   # Check if `addprocs` has completed to ensure `fetch` doesn't block\n    if nworkers() == N\n        new_pids = fetch(t)\n    else\n        fetch(t)\n    end\n  end\n\n\n\n\n\naddprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers\n\nAdd processes on remote machines via SSH. Requires julia to be installed in the same location on each node, or to be available via a shared file system.\n\nmachines is a vector of machine specifications. Workers are started for each specification.\n\nA machine specification is either a string machine_spec or a tuple - (machine_spec, count).\n\nmachine_spec is a string of the form [user@]host[:port] [bind_addr[:port]]. user defaults to current user, port to the standard ssh port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified bind_addr and port.\n\ncount is the number of workers to be launched on the specified host. If specified as :auto it will launch as many workers as the number of CPU threads on the specific host.\n\nKeyword arguments:\n\ntunnel: if true then SSH tunneling will be used to connect to the worker from the master process. Default is false.\nsshflags: specifies additional ssh options, e.g. sshflags=`-i /home/foo/bar.pem`\nmax_parallel: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10.\ndir: specifies the working directory on the workers. Defaults to the host's current directory (as found by pwd())\nenable_threaded_blas: if true then  BLAS will run on multiple threads in added processes. Default is false.\nexename: name of the julia executable. Defaults to \"$(Sys.BINDIR)/julia\" or \"$(Sys.BINDIR)/julia-debug\" as the case may be.\nexeflags: additional flags passed to the worker processes.\ntopology: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.\ntopology=:all_to_all: All processes are connected to each other. The default.\ntopology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each other.\ntopology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in connect_idents.\nlazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first instance of a remote call between workers. Default is true.\n\nEnvironment variables :\n\nIf the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the master process specifies the number of seconds a newly launched worker waits for connection establishment.\n\n\n\n\n\naddprocs(; kwargs...) -> List of process identifiers\n\nEquivalent to addprocs(Sys.CPU_THREADS; kwargs...)\n\nNote that workers do not run a .julia/config/startup.jl startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.\n\n\n\n\n\naddprocs(np::Integer; restrict=true, kwargs...) -> List of process identifiers\n\nLaunches workers using the in-built LocalManager which only launches workers on the local host. This can be used to take advantage of multiple cores. addprocs(4) will add 4 processes on the local machine. If restrict is true, binding is restricted to 127.0.0.1. Keyword args dir, exename, exeflags, topology, lazy and enable_threaded_blas have the same effect as documented for addprocs(machines).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.nprocs","page":"Distributed Computing","title":"Distributed.nprocs","text":"nprocs()\n\nGet the number of available processes.\n\nExamples\n\njulia> nprocs()\n3\n\njulia> workers()\n5-element Array{Int64,1}:\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.nworkers","page":"Distributed Computing","title":"Distributed.nworkers","text":"nworkers()\n\nGet the number of available worker processes. This is one less than nprocs(). Equal to nprocs() if nprocs() == 1.\n\nExamples\n\n$ julia -p 5\n\njulia> nprocs()\n6\n\njulia> nworkers()\n5\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.procs-Tuple{}","page":"Distributed Computing","title":"Distributed.procs","text":"procs()\n\nReturn a list of all process identifiers, including pid 1 (which is not included by workers()).\n\nExamples\n\n$ julia -p 5\n\njulia> procs()\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.procs-Tuple{Integer}","page":"Distributed Computing","title":"Distributed.procs","text":"procs(pid::Integer)\n\nReturn a list of all process identifiers on the same physical node. Specifically all workers bound to the same ip-address as pid are returned.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.workers","page":"Distributed Computing","title":"Distributed.workers","text":"workers()\n\nReturn a list of all worker process identifiers.\n\nExamples\n\n$ julia -p 5\n\njulia> workers()\n2-element Array{Int64,1}:\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.rmprocs","page":"Distributed Computing","title":"Distributed.rmprocs","text":"rmprocs(pids...; waitfor=typemax(Int))\n\nRemove the specified workers. Note that only process 1 can add or remove workers.\n\nArgument waitfor specifies how long to wait for the workers to shut down:\n\nIf unspecified, rmprocs will wait until all requested pids are removed.\nAn ErrorException is raised if all workers cannot be terminated before the requested waitfor seconds.\nWith a waitfor value of 0, the call returns immediately with the workers scheduled for removal in a different task. The scheduled Task object is returned. The user should call wait on the task before invoking any other parallel calls.\n\nExamples\n\n$ julia -p 5\n\njulia> t = rmprocs(2, 3, waitfor=0)\nTask (runnable) @0x0000000107c718d0\n\njulia> wait(t)\n\njulia> workers()\n3-element Array{Int64,1}:\n 4\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.interrupt","page":"Distributed Computing","title":"Distributed.interrupt","text":"interrupt(pids::Integer...)\n\nInterrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.\n\n\n\n\n\ninterrupt(pids::AbstractVector=workers())\n\nInterrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.myid","page":"Distributed Computing","title":"Distributed.myid","text":"myid()\n\nGet the id of the current process.\n\nExamples\n\njulia> myid()\n1\n\njulia> remotecall_fetch(() -> myid(), 4)\n4\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.pmap","page":"Distributed Computing","title":"Distributed.pmap","text":"pmap(f, [::AbstractWorkerPool], c...; distributed=true, batch_size=1, on_error=nothing, retry_delays=[], retry_check=nothing) -> collection\n\nTransform collection c by applying f to each element using available workers and tasks.\n\nFor multiple collection arguments, apply f elementwise.\n\nNote that f must be made available to all worker processes; see Code Availability and Loading Packages for details.\n\nIf a worker pool is not specified, all available workers, i.e., the default worker pool is used.\n\nBy default, pmap distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify distributed=false. This is equivalent to using asyncmap. For example, pmap(f, c; distributed=false) is equivalent to asyncmap(f,c; ntasks=()->nworkers())\n\npmap can also use a mix of processes and tasks via the batch_size argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length batch_size or less. A batch is sent as a single request to a free worker, where a local asyncmap processes elements from the batch using multiple concurrent tasks.\n\nAny error stops pmap from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument on_error which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.\n\nConsider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:\n\njulia> pmap(x->iseven(x) ? error(\"foo\") : x, 1:4; on_error=identity)\n4-element Array{Any,1}:\n 1\n  ErrorException(\"foo\")\n 3\n  ErrorException(\"foo\")\n\njulia> pmap(x->iseven(x) ? error(\"foo\") : x, 1:4; on_error=ex->0)\n4-element Array{Int64,1}:\n 1\n 0\n 3\n 0\n\nErrors can also be handled by retrying failed computations. Keyword arguments retry_delays and retry_check are passed through to retry as keyword arguments delays and check respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.\n\nNote that if both on_error and retry_delays are specified, the on_error hook is called before retrying. If on_error does not throw (or rethrow) an exception, the element will not be retried.\n\nExample: On errors, retry f on an element a maximum of 3 times without any delay between retries.\n\npmap(f, c; retry_delays = zeros(3))\n\nExample: Retry f only if the exception is not of type InexactError, with exponentially increasing delays up to 3 times. Return a NaN in place for all InexactError occurrences.\n\npmap(f, c; on_error = e->(isa(e, InexactError) ? NaN : rethrow()), retry_delays = ExponentialBackOff(n = 3))\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.RemoteException","page":"Distributed Computing","title":"Distributed.RemoteException","text":"RemoteException(captured)\n\nExceptions on remote computations are captured and rethrown locally.  A RemoteException wraps the pid of the worker and a captured exception. A CapturedException captures the remote exception and a serializable form of the call stack when the exception was raised.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Distributed.html#Distributed.Future","page":"Distributed Computing","title":"Distributed.Future","text":"Future(pid::Integer=myid())\n\nCreate a Future on process pid. The default pid is the current process.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Distributed.html#Distributed.RemoteChannel","page":"Distributed Computing","title":"Distributed.RemoteChannel","text":"RemoteChannel(pid::Integer=myid())\n\nMake a reference to a Channel{Any}(1) on process pid. The default pid is the current process.\n\nRemoteChannel(f::Function, pid::Integer=myid())\n\nCreate references to remote channels of a specific size and type. f is a function that when executed on pid must return an implementation of an AbstractChannel.\n\nFor example, RemoteChannel(()->Channel{Int}(10), pid), will return a reference to a channel of type Int and size 10 on pid.\n\nThe default pid is the current process.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Distributed.html#Base.fetch-Tuple{Future}","page":"Distributed Computing","title":"Base.fetch","text":"fetch(x::Future)\n\nWait for and get the value of a Future. The fetched value is cached locally. Further calls to fetch on the same reference return the cached value. If the remote value is an exception, throws a RemoteException which captures the remote exception and backtrace.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Base.fetch-Tuple{RemoteChannel}","page":"Distributed Computing","title":"Base.fetch","text":"fetch(c::RemoteChannel)\n\nWait for and get a value from a RemoteChannel. Exceptions raised are the same as for a Future. Does not remove the item fetched.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.remotecall-Tuple{Any,Integer,Vararg{Any,N} where N}","page":"Distributed Computing","title":"Distributed.remotecall","text":"remotecall(f, id::Integer, args...; kwargs...) -> Future\n\nCall a function f asynchronously on the given arguments on the specified process. Return a Future. Keyword arguments, if any, are passed through to f.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.remotecall_wait-Tuple{Any,Integer,Vararg{Any,N} where N}","page":"Distributed Computing","title":"Distributed.remotecall_wait","text":"remotecall_wait(f, id::Integer, args...; kwargs...)\n\nPerform a faster wait(remotecall(...)) in one message on the Worker specified by worker id id. Keyword arguments, if any, are passed through to f.\n\nSee also wait and remotecall.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.remotecall_fetch-Tuple{Any,Integer,Vararg{Any,N} where N}","page":"Distributed Computing","title":"Distributed.remotecall_fetch","text":"remotecall_fetch(f, id::Integer, args...; kwargs...)\n\nPerform fetch(remotecall(...)) in one message. Keyword arguments, if any, are passed through to f. Any remote exceptions are captured in a RemoteException and thrown.\n\nSee also fetch and remotecall.\n\nExamples\n\n$ julia -p 2\n\njulia> remotecall_fetch(sqrt, 2, 4)\n2.0\n\njulia> remotecall_fetch(sqrt, 2, -4)\nERROR: On worker 2:\nDomainError with -4.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n...\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.remote_do-Tuple{Any,Integer,Vararg{Any,N} where N}","page":"Distributed Computing","title":"Distributed.remote_do","text":"remote_do(f, id::Integer, args...; kwargs...) -> nothing\n\nExecutes f on worker id asynchronously. Unlike remotecall, it does not store the result of computation, nor is there a way to wait for its completion.\n\nA successful invocation indicates that the request has been accepted for execution on the remote node.\n\nWhile consecutive remotecalls to the same worker are serialized in the order they are invoked, the order of executions on the remote worker is undetermined. For example, remote_do(f1, 2); remotecall(f2, 2); remote_do(f3, 2) will serialize the call to f1, followed by f2 and f3 in that order. However, it is not guaranteed that f1 is executed before f3 on worker 2.\n\nAny exceptions thrown by f are printed to stderr on the remote worker.\n\nKeyword arguments, if any, are passed through to f.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Base.put!-Tuple{RemoteChannel,Vararg{Any,N} where N}","page":"Distributed Computing","title":"Base.put!","text":"put!(rr::RemoteChannel, args...)\n\nStore a set of values to the RemoteChannel. If the channel is full, blocks until space is available. Return the first argument.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Base.put!-Tuple{Future,Any}","page":"Distributed Computing","title":"Base.put!","text":"put!(rr::Future, v)\n\nStore a value to a Future rr. Futures are write-once remote references. A put! on an already set Future throws an Exception. All asynchronous remote calls return Futures and set the value to the return value of the call upon completion.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Base.take!-Tuple{RemoteChannel,Vararg{Any,N} where N}","page":"Distributed Computing","title":"Base.take!","text":"take!(rr::RemoteChannel, args...)\n\nFetch value(s) from a RemoteChannel rr, removing the value(s) in the process.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Base.isready-Tuple{RemoteChannel,Vararg{Any,N} where N}","page":"Distributed Computing","title":"Base.isready","text":"isready(rr::RemoteChannel, args...)\n\nDetermine whether a RemoteChannel has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. However, it can be safely used on a Future since they are assigned only once.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Base.isready-Tuple{Future}","page":"Distributed Computing","title":"Base.isready","text":"isready(rr::Future)\n\nDetermine whether a Future has a value stored to it.\n\nIf the argument Future is owned by a different node, this call will block to wait for the answer. It is recommended to wait for rr in a separate task instead or to use a local Channel as a proxy:\n\nc = Channel(1)\n@async put!(c, remotecall_fetch(long_computation, p))\nisready(c)  # will not block\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.AbstractWorkerPool","page":"Distributed Computing","title":"Distributed.AbstractWorkerPool","text":"AbstractWorkerPool\n\nSupertype for worker pools such as WorkerPool and CachingPool. An AbstractWorkerPool should implement:\n\npush! - add a new worker to the overall pool (available + busy)\nput! - put back a worker to the available pool\ntake! - take a worker from the available pool (to be used for remote function execution)\nlength - number of workers available in the overall pool\nisready - return false if a take! on the pool would block, else true\n\nThe default implementations of the above (on a AbstractWorkerPool) require fields     channel::Channel{Int}     workers::Set{Int} where channel contains free worker pids and workers is the set of all workers associated with this pool.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Distributed.html#Distributed.WorkerPool","page":"Distributed Computing","title":"Distributed.WorkerPool","text":"WorkerPool(workers::Vector{Int})\n\nCreate a WorkerPool from a vector of worker ids.\n\nExamples\n\n$ julia -p 3\n\njulia> WorkerPool([2, 3])\nWorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:2), Set([2, 3]), RemoteChannel{Channel{Any}}(1, 1, 6))\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Distributed.html#Distributed.CachingPool","page":"Distributed Computing","title":"Distributed.CachingPool","text":"CachingPool(workers::Vector{Int})\n\nAn implementation of an AbstractWorkerPool. remote, remotecall_fetch, pmap (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).\n\nThe remote cache is maintained for the lifetime of the returned CachingPool object. To clear the cache earlier, use clear!(pool).\n\nFor global variables, only the bindings are captured in a closure, not the data. let blocks can be used to capture global data.\n\nExamples\n\nconst foo = rand(10^8);\nwp = CachingPool(workers())\nlet foo = foo\n    pmap(wp, i -> sum(foo) + i, 1:100);\nend\n\nThe above would transfer foo only once to each worker.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Distributed.html#Distributed.default_worker_pool","page":"Distributed Computing","title":"Distributed.default_worker_pool","text":"default_worker_pool()\n\nWorkerPool containing idle workers - used by remote(f) and pmap (by default).\n\nExamples\n\n$ julia -p 3\n\njulia> default_worker_pool()\nWorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:3), Set([4, 2, 3]), RemoteChannel{Channel{Any}}(1, 1, 4))\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.clear!-Tuple{CachingPool}","page":"Distributed Computing","title":"Distributed.clear!","text":"clear!(pool::CachingPool) -> pool\n\nRemoves all cached functions from all participating workers.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.remote","page":"Distributed Computing","title":"Distributed.remote","text":"remote([p::AbstractWorkerPool], f) -> Function\n\nReturn an anonymous function that executes function f on an available worker (drawn from WorkerPool p if provided) using remotecall_fetch.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.remotecall-Tuple{Any,AbstractWorkerPool,Vararg{Any,N} where N}","page":"Distributed Computing","title":"Distributed.remotecall","text":"remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future\n\nWorkerPool variant of remotecall(f, pid, ....). Wait for and take a free worker from pool and perform a remotecall on it.\n\nExamples\n\n$ julia -p 3\n\njulia> wp = WorkerPool([2, 3]);\n\njulia> A = rand(3000);\n\njulia> f = remotecall(maximum, wp, A)\nFuture(2, 1, 6, nothing)\n\nIn this example, the task ran on pid 2, called from pid 1.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.remotecall_wait-Tuple{Any,AbstractWorkerPool,Vararg{Any,N} where N}","page":"Distributed Computing","title":"Distributed.remotecall_wait","text":"remotecall_wait(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future\n\nWorkerPool variant of remotecall_wait(f, pid, ....). Wait for and take a free worker from pool and perform a remotecall_wait on it.\n\nExamples\n\n$ julia -p 3\n\njulia> wp = WorkerPool([2, 3]);\n\njulia> A = rand(3000);\n\njulia> f = remotecall_wait(maximum, wp, A)\nFuture(3, 1, 9, nothing)\n\njulia> fetch(f)\n0.9995177101692958\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.remotecall_fetch-Tuple{Any,AbstractWorkerPool,Vararg{Any,N} where N}","page":"Distributed Computing","title":"Distributed.remotecall_fetch","text":"remotecall_fetch(f, pool::AbstractWorkerPool, args...; kwargs...) -> result\n\nWorkerPool variant of remotecall_fetch(f, pid, ....). Waits for and takes a free worker from pool and performs a remotecall_fetch on it.\n\nExamples\n\n$ julia -p 3\n\njulia> wp = WorkerPool([2, 3]);\n\njulia> A = rand(3000);\n\njulia> remotecall_fetch(maximum, wp, A)\n0.9995177101692958\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.remote_do-Tuple{Any,AbstractWorkerPool,Vararg{Any,N} where N}","page":"Distributed Computing","title":"Distributed.remote_do","text":"remote_do(f, pool::AbstractWorkerPool, args...; kwargs...) -> nothing\n\nWorkerPool variant of remote_do(f, pid, ....). Wait for and take a free worker from pool and perform a remote_do on it.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.@spawn","page":"Distributed Computing","title":"Distributed.@spawn","text":"@spawn\n\nCreate a closure around an expression and run it on an automatically-chosen process, returning a Future to the result.\n\nExamples\n\njulia> addprocs(3);\n\njulia> f = @spawn myid()\nFuture(2, 1, 5, nothing)\n\njulia> fetch(f)\n2\n\njulia> f = @spawn myid()\nFuture(3, 1, 7, nothing)\n\njulia> fetch(f)\n3\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Distributed.html#Distributed.@spawnat","page":"Distributed Computing","title":"Distributed.@spawnat","text":"@spawnat\n\nCreate a closure around an expression and run the closure asynchronously on process p. Return a Future to the result. Accepts two arguments, p and an expression.\n\nExamples\n\njulia> addprocs(1);\n\njulia> f = @spawnat 2 myid()\nFuture(2, 1, 3, nothing)\n\njulia> fetch(f)\n2\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Distributed.html#Distributed.@fetch","page":"Distributed Computing","title":"Distributed.@fetch","text":"@fetch\n\nEquivalent to fetch(@spawn expr). See fetch and @spawn.\n\nExamples\n\njulia> addprocs(3);\n\njulia> @fetch myid()\n2\n\njulia> @fetch myid()\n3\n\njulia> @fetch myid()\n4\n\njulia> @fetch myid()\n2\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Distributed.html#Distributed.@fetchfrom","page":"Distributed Computing","title":"Distributed.@fetchfrom","text":"@fetchfrom\n\nEquivalent to fetch(@spawnat p expr). See fetch and @spawnat.\n\nExamples\n\njulia> addprocs(3);\n\njulia> @fetchfrom 2 myid()\n2\n\njulia> @fetchfrom 4 myid()\n4\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Distributed.html#Distributed.@distributed","page":"Distributed Computing","title":"Distributed.@distributed","text":"@distributed\n\nA distributed memory, parallel for loop of the form :\n\n@distributed [reducer] for var = range\n    body\nend\n\nThe specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, @distributed performs local reductions on each worker with a final reduction on the calling process.\n\nNote that without a reducer function, @distributed executes asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion. To wait for completion, prefix the call with @sync, like :\n\n@sync @distributed for var = range\n    body\nend\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Distributed.html#Distributed.@everywhere","page":"Distributed Computing","title":"Distributed.@everywhere","text":"@everywhere [procs()] expr\n\nExecute an expression under Main on all procs. Errors on any of the processes are collected into a CompositeException and thrown. For example:\n\n@everywhere bar = 1\n\nwill define Main.bar on all processes.\n\nUnlike @spawn and @spawnat, @everywhere does not capture any local variables. Instead, local variables can be broadcast using interpolation:\n\nfoo = 1\n@everywhere bar = $foo\n\nThe optional argument procs allows specifying a subset of all processes to have execute the expression.\n\nEquivalent to calling remotecall_eval(Main, procs, expr).\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Distributed.html#Distributed.clear!-Tuple{Any,Any}","page":"Distributed Computing","title":"Distributed.clear!","text":"clear!(syms, pids=workers(); mod=Main)\n\nClears global bindings in modules by initializing them to nothing. syms should be of type Symbol or a collection of Symbols . pids and mod identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under mod are cleared.\n\nAn exception is raised if a global constant is requested to be cleared.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.remoteref_id","page":"Distributed Computing","title":"Distributed.remoteref_id","text":"remoteref_id(r::AbstractRemoteRef) -> RRID\n\nFutures and RemoteChannels are identified by fields:\n\nwhere - refers to the node where the underlying object/storage referred to by the reference actually exists.\nwhence - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling RemoteChannel(2) from the master process would result in a where value of 2 and a whence value of 1.\nid is unique across all references created from the worker specified by whence.\n\nTaken together,  whence and id uniquely identify a reference across all workers.\n\nremoteref_id is a low-level API which returns a RRID object that wraps whence and id values of a remote reference.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.channel_from_id","page":"Distributed Computing","title":"Distributed.channel_from_id","text":"channel_from_id(id) -> c\n\nA low-level API which returns the backing AbstractChannel for an id returned by remoteref_id. The call is valid only on the node where the backing channel exists.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.worker_id_from_socket","page":"Distributed Computing","title":"Distributed.worker_id_from_socket","text":"worker_id_from_socket(s) -> pid\n\nA low-level API which, given a IO connection or a Worker, returns the pid of the worker it is connected to. This is useful when writing custom serialize methods for a type, which optimizes the data written out depending on the receiving process id.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.cluster_cookie-Tuple{}","page":"Distributed Computing","title":"Distributed.cluster_cookie","text":"cluster_cookie() -> cookie\n\nReturn the cluster cookie.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.cluster_cookie-Tuple{Any}","page":"Distributed Computing","title":"Distributed.cluster_cookie","text":"cluster_cookie(cookie) -> cookie\n\nSet the passed cookie as the cluster cookie, then returns it.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Cluster-Manager-Interface-1","page":"Distributed Computing","title":"Cluster Manager Interface","text":"","category":"section"},{"location":"stdlib/Distributed.html#","page":"Distributed Computing","title":"Distributed Computing","text":"This interface provides a mechanism to launch and manage Julia workers on different cluster environments.  There are two types of managers present in Base: LocalManager, for launching additional workers on the same host, and SSHManager, for launching on remote hosts via ssh. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.","category":"page"},{"location":"stdlib/Distributed.html#","page":"Distributed Computing","title":"Distributed Computing","text":"Distributed.ClusterManager\nDistributed.WorkerConfig\nDistributed.launch\nDistributed.manage\nDistributed.kill(::ClusterManager, ::Int, ::WorkerConfig)\nDistributed.connect(::ClusterManager, ::Int, ::WorkerConfig)\nDistributed.init_worker\nDistributed.start_worker\nDistributed.process_messages","category":"page"},{"location":"stdlib/Distributed.html#Distributed.ClusterManager","page":"Distributed Computing","title":"Distributed.ClusterManager","text":"ClusterManager\n\nSupertype for cluster managers, which control workers processes as a cluster. Cluster managers implement how workers can be added, removed and communicated with. SSHManager and LocalManager are subtypes of this.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Distributed.html#Distributed.WorkerConfig","page":"Distributed Computing","title":"Distributed.WorkerConfig","text":"WorkerConfig\n\nType used by ClusterManagers to control workers added to their clusters. Some fields are used by all cluster managers to access a host:\n\nio – the connection used to access the worker (a subtype of IO or Nothing)\nhost – the host address (either an AbstractString or Nothing)\nport – the port on the host used to connect to the worker (either an Int or Nothing)\n\nSome are used by the cluster manager to add workers to an already-initialized host:\n\ncount – the number of workers to be launched on the host\nexename – the path to the Julia executable on the host, defaults to \"$(Sys.BINDIR)/julia\" or \"$(Sys.BINDIR)/julia-debug\"\nexeflags – flags to use when lauching Julia remotely\n\nThe userdata field is used to store information for each worker by external managers.\n\nSome fields are used by SSHManager and similar managers:\n\ntunnel – true (use tunneling), false (do not use tunneling), or nothing (use default for the manager)\nbind_addr – the address on the remote host to bind to\nsshflags – flags to use in establishing the SSH connection\nmax_parallel – the maximum number of workers to connect to in parallel on the host\n\nSome fields are used by both LocalManagers and SSHManagers:\n\nconnect_at – determines whether this is a worker-to-worker or driver-to-worker setup call\nprocess – the process which will be connected (usually the manager will assign this during addprocs)\nospid – the process ID according to the host OS, used to interrupt worker processes\nenviron – private dictionary used to store temporary information by Local/SSH managers\nident – worker as identified by the ClusterManager\nconnect_idents – list of worker ids the worker must connect to if using a custom topology\nenable_threaded_blas – true, false, or nothing, whether to use threaded BLAS or not on the workers\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Distributed.html#Distributed.launch","page":"Distributed Computing","title":"Distributed.launch","text":"launch(manager::ClusterManager, params::Dict, launched::Array, launch_ntfy::Condition)\n\nImplemented by cluster managers. For every Julia worker launched by this function, it should append a WorkerConfig entry to launched and notify launch_ntfy. The function MUST exit once all workers, requested by manager have been launched. params is a dictionary of all keyword arguments addprocs was called with.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.manage","page":"Distributed Computing","title":"Distributed.manage","text":"manage(manager::ClusterManager, id::Integer, config::WorkerConfig. op::Symbol)\n\nImplemented by cluster managers. It is called on the master process, during a worker's lifetime, with appropriate op values:\n\nwith :register/:deregister when a worker is added / removed from the Julia worker pool.\nwith :interrupt when interrupt(workers) is called. The ClusterManager should signal the appropriate worker with an interrupt signal.\nwith :finalize for cleanup purposes.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Base.kill-Tuple{ClusterManager,Int64,WorkerConfig}","page":"Distributed Computing","title":"Base.kill","text":"kill(manager::ClusterManager, pid::Int, config::WorkerConfig)\n\nImplemented by cluster managers. It is called on the master process, by rmprocs. It should cause the remote worker specified by pid to exit. kill(manager::ClusterManager.....) executes a remote exit() on pid.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Sockets.connect-Tuple{ClusterManager,Int64,WorkerConfig}","page":"Distributed Computing","title":"Sockets.connect","text":"connect(manager::ClusterManager, pid::Int, config::WorkerConfig) -> (instrm::IO, outstrm::IO)\n\nImplemented by cluster managers using custom transports. It should establish a logical connection to worker with id pid, specified by config and return a pair of IO objects. Messages from pid to current process will be read off instrm, while messages to be sent to pid will be written to outstrm. The custom transport implementation must ensure that messages are delivered and received completely and in order. connect(manager::ClusterManager.....) sets up TCP/IP socket connections in-between workers.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Distributed.html#Distributed.init_worker","page":"Distributed Computing","title":"Distributed.init_worker","text":"init_worker(cookie::AbstractString, manager::ClusterManager=DefaultClusterManager())\n\nCalled by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument --worker[=<cookie>] has the effect of initializing a process as a worker using TCP/IP sockets for transport. cookie is a cluster_cookie.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.start_worker","page":"Distributed Computing","title":"Distributed.start_worker","text":"start_worker([out::IO=stdout], cookie::AbstractString=readline(stdin); close_stdin::Bool=true, stderr_to_stdout::Bool=true)\n\nstart_worker is an internal function which is the default entry point for worker processes connecting via TCP/IP. It sets up the process as a Julia cluster worker.\n\nhost:port information is written to stream out (defaults to stdout).\n\nThe function reads the cookie from stdin if required, and  listens on a free port (or if specified, the port in the --bind-to command line option) and schedules tasks to process incoming TCP connections and requests. It also (optionally) closes stdin and redirects stderr to stdout.\n\nIt does not return.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#Distributed.process_messages","page":"Distributed Computing","title":"Distributed.process_messages","text":"process_messages(r_stream::IO, w_stream::IO, incoming::Bool=true)\n\nCalled by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two IO objects, one for incoming messages and the other for messages addressed to the remote worker. If incoming is true, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.\n\nSee also cluster_cookie.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Distributed.html#","page":"Distributed Computing","title":"Distributed Computing","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/FileWatching.html#lib-filewatching-1","page":"File Events","title":"File Events","text":"","category":"section"},{"location":"stdlib/FileWatching.html#","page":"File Events","title":"File Events","text":"FileWatching.poll_fd\nFileWatching.poll_file\nFileWatching.watch_file\nFileWatching.watch_folder\nFileWatching.unwatch_folder","category":"page"},{"location":"stdlib/FileWatching.html#FileWatching.poll_fd","page":"File Events","title":"FileWatching.poll_fd","text":"poll_fd(fd, timeout_s::Real=-1; readable=false, writable=false)\n\nMonitor a file descriptor fd for changes in the read or write availability, and with a timeout given by timeout_s seconds.\n\nThe keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to true.\n\nThe returned value is an object with boolean fields readable, writable, and timedout, giving the result of the polling.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/FileWatching.html#FileWatching.poll_file","page":"File Events","title":"FileWatching.poll_file","text":"poll_file(path::AbstractString, interval_s::Real=5.007, timeout_s::Real=-1) -> (previous::StatStruct, current)\n\nMonitor a file for changes by polling every interval_s seconds until a change occurs or timeout_s seconds have elapsed. The interval_s should be a long period; the default is 5.007 seconds.\n\nReturns a pair of status objects (previous, current) when a change is detected. The previous status is always a StatStruct, but it may have all of the fields zeroed (indicating the file didn't previously exist, or wasn't previously accessible).\n\nThe current status object may be a StatStruct, an EOFError (indicating the timeout elapsed), or some other Exception subtype (if the stat operation failed - for example, if the path does not exist).\n\nTo determine when a file was modified, compare current isa StatStruct && mtime(prev) != mtime(current) to detect notification of changes. However, using watch_file for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/FileWatching.html#FileWatching.watch_file","page":"File Events","title":"FileWatching.watch_file","text":"watch_file(path::AbstractString, timeout_s::Real=-1)\n\nWatch file or directory path for changes until a change occurs or timeout_s seconds have elapsed.\n\nThe returned value is an object with boolean fields changed, renamed, and timedout, giving the result of watching the file.\n\nThis behavior of this function varies slightly across platforms. See https://nodejs.org/api/fs.html#fs_caveats for more detailed information.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/FileWatching.html#FileWatching.watch_folder","page":"File Events","title":"FileWatching.watch_folder","text":"watch_folder(path::AbstractString, timeout_s::Real=-1)\n\nWatches a file or directory path for changes until a change has occurred or timeout_s seconds have elapsed.\n\nThis will continuing tracking changes for path in the background until unwatch_folder is called on the same path.\n\nThe returned value is an pair where the first field is the name of the changed file (if available) and the second field is an object with boolean fields changed, renamed, and timedout, giving the event.\n\nThis behavior of this function varies slightly across platforms. See https://nodejs.org/api/fs.html#fs_caveats for more detailed information.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/FileWatching.html#FileWatching.unwatch_folder","page":"File Events","title":"FileWatching.unwatch_folder","text":"unwatch_folder(path::AbstractString)\n\nStop background tracking of changes for path. It is not recommended to do this while another task is waiting for watch_folder to return on the same path, as the result may be unpredictable.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/InteractiveUtils.html#Interactive-Utilities-1","page":"Interactive Utilities","title":"Interactive Utilities","text":"","category":"section"},{"location":"stdlib/InteractiveUtils.html#","page":"Interactive Utilities","title":"Interactive Utilities","text":"DocTestSetup = :(using InteractiveUtils)","category":"page"},{"location":"stdlib/InteractiveUtils.html#","page":"Interactive Utilities","title":"Interactive Utilities","text":"InteractiveUtils.apropos\nInteractiveUtils.varinfo\nInteractiveUtils.versioninfo\nInteractiveUtils.methodswith\nInteractiveUtils.subtypes\nInteractiveUtils.edit(::AbstractString, ::Integer)\nInteractiveUtils.edit(::Any)\nInteractiveUtils.@edit\nInteractiveUtils.less(::AbstractString)\nInteractiveUtils.less(::Any)\nInteractiveUtils.@less\nInteractiveUtils.@which\nInteractiveUtils.@functionloc\nInteractiveUtils.@code_lowered\nInteractiveUtils.@code_typed\nInteractiveUtils.code_warntype\nInteractiveUtils.@code_warntype\nInteractiveUtils.code_llvm\nInteractiveUtils.@code_llvm\nInteractiveUtils.code_native\nInteractiveUtils.@code_native\nInteractiveUtils.clipboard","category":"page"},{"location":"stdlib/InteractiveUtils.html#Base.Docs.apropos","page":"Interactive Utilities","title":"Base.Docs.apropos","text":"apropos(string)\n\nSearch through all documentation for a string, ignoring case.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.varinfo","page":"Interactive Utilities","title":"InteractiveUtils.varinfo","text":"varinfo(m::Module=Main, pattern::Regex=r\"\")\n\nReturn a markdown table giving information about exported global variables in a module, optionally restricted to those matching pattern.\n\nThe memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.versioninfo","page":"Interactive Utilities","title":"InteractiveUtils.versioninfo","text":"versioninfo(io::IO=stdout; verbose::Bool=false)\n\nPrint information about the version of Julia in use. The output is controlled with boolean keyword arguments:\n\nverbose: print all additional information\n\n\n\n\n\n","category":"function"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.methodswith","page":"Interactive Utilities","title":"InteractiveUtils.methodswith","text":"methodswith(typ[, module or function]; supertypes::Bool=false])\n\nReturn an array of methods with an argument of type typ.\n\nThe optional second argument restricts the search to a particular module or function (the default is all top-level modules).\n\nIf keyword supertypes is true, also return arguments with a parent type of typ, excluding type Any.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.subtypes","page":"Interactive Utilities","title":"InteractiveUtils.subtypes","text":"subtypes(T::DataType)\n\nReturn a list of immediate subtypes of DataType T. Note that all currently loaded subtypes are included, including those not visible in the current module.\n\nExamples\n\njulia> subtypes(Integer)\n3-element Array{Any,1}:\n Bool\n Signed\n Unsigned\n\n\n\n\n\n","category":"function"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.edit-Tuple{AbstractString,Integer}","page":"Interactive Utilities","title":"InteractiveUtils.edit","text":"edit(path::AbstractString, line::Integer=0)\n\nEdit a file or directory optionally providing a line number to edit the file at. Return to the julia prompt when you quit the editor. The editor can be changed by setting JULIA_EDITOR, VISUAL or EDITOR as an environment variable.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.edit-Tuple{Any}","page":"Interactive Utilities","title":"InteractiveUtils.edit","text":"edit(function, [types])\nedit(module)\n\nEdit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. For modules, open the main source file. The module needs to be loaded with using or import first.\n\ncompat: Julia 1.1\nedit on modules requires at least Julia 1.1.\n\nThe editor can be changed by setting JULIA_EDITOR, VISUAL or EDITOR as an environment variable.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.@edit","page":"Interactive Utilities","title":"InteractiveUtils.@edit","text":"@edit\n\nEvaluates the arguments to the function or macro call, determines their types, and calls the edit function on the resulting expression.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.less-Tuple{AbstractString}","page":"Interactive Utilities","title":"InteractiveUtils.less","text":"less(file::AbstractString, [line::Integer])\n\nShow a file using the default pager, optionally providing a starting line number. Returns to the julia prompt when you quit the pager.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.less-Tuple{Any}","page":"Interactive Utilities","title":"InteractiveUtils.less","text":"less(function, [types])\n\nShow the definition of a function using the default pager, optionally specifying a tuple of types to indicate which method to see.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.@less","page":"Interactive Utilities","title":"InteractiveUtils.@less","text":"@less\n\nEvaluates the arguments to the function or macro call, determines their types, and calls the less function on the resulting expression.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.@which","page":"Interactive Utilities","title":"InteractiveUtils.@which","text":"@which\n\nApplied to a function or macro call, it evaluates the arguments to the specified call, and returns the Method object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the which function.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.@functionloc","page":"Interactive Utilities","title":"InteractiveUtils.@functionloc","text":"@functionloc\n\nApplied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple (filename,line) giving the location for the method that would be called for those arguments. It calls out to the functionloc function.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.@code_lowered","page":"Interactive Utilities","title":"InteractiveUtils.@code_lowered","text":"@code_lowered\n\nEvaluates the arguments to the function or macro call, determines their types, and calls code_lowered on the resulting expression.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.@code_typed","page":"Interactive Utilities","title":"InteractiveUtils.@code_typed","text":"@code_typed\n\nEvaluates the arguments to the function or macro call, determines their types, and calls code_typed on the resulting expression. Use the optional argument optimize with\n\n@code_typed optimize=true foo(x)\n\nto control whether additional optimizations, such as inlining, are also applied.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.code_warntype","page":"Interactive Utilities","title":"InteractiveUtils.code_warntype","text":"code_warntype([io::IO], f, types; debuginfo=:default)\n\nPrints lowered and type-inferred ASTs for the methods matching the given generic function and type signature to io which defaults to stdout. The ASTs are annotated in such a way as to cause \"non-leaf\" types to be emphasized (if color is available, displayed in red). This serves as a warning of potential type instability. Not all non-leaf types are particularly problematic for performance, so the results need to be used judiciously. In particular, unions containing either missing or nothing are displayed in yellow, since these are often intentional.\n\nKeyword argument debuginfo may be one of :source or :none (default), to specify the verbosity of code comments.\n\nSee @code_warntype for more information.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.@code_warntype","page":"Interactive Utilities","title":"InteractiveUtils.@code_warntype","text":"@code_warntype\n\nEvaluates the arguments to the function or macro call, determines their types, and calls code_warntype on the resulting expression.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.code_llvm","page":"Interactive Utilities","title":"InteractiveUtils.code_llvm","text":"code_llvm([io=stdout,], f, types; raw=false, dump_module=false, optimize=true, debuginfo=:default)\n\nPrints the LLVM bitcodes generated for running the method matching the given generic function and type signature to io.\n\nIf the optimize keyword is unset, the code will be shown before LLVM optimizations. All metadata and dbg.* calls are removed from the printed bitcode. For the full IR, set the raw keyword to true. To dump the entire module that encapsulates the function (with declarations), set the dump_module keyword to true. Keyword argument debuginfo may be one of source (default) or none, to specify the verbosity of code comments.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.@code_llvm","page":"Interactive Utilities","title":"InteractiveUtils.@code_llvm","text":"@code_llvm\n\nEvaluates the arguments to the function or macro call, determines their types, and calls code_llvm on the resulting expression. Set the optional keyword arguments raw, dump_module, debuginfo, optimize by putting them and their value before the function call, like this:\n\n@code_llvm raw=true dump_module=true debuginfo=:default f(x)\n@code_llvm optimize=false f(x)\n\noptimize controls whether additional optimizations, such as inlining, are also applied. raw makes all metadata and dbg.* calls visible. debuginfo may be one of :source (default) or :none,  to specify the verbosity of code comments. dump_module prints the entire module that encapsulates the function.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.code_native","page":"Interactive Utilities","title":"InteractiveUtils.code_native","text":"code_native([io=stdout,], f, types; syntax=:att, debuginfo=:default)\n\nPrints the native assembly instructions generated for running the method matching the given generic function and type signature to io. Switch assembly syntax using syntax symbol parameter set to :att for AT&T syntax or :intel for Intel syntax. Keyword argument debuginfo may be one of source (default) or none, to specify the verbosity of code comments.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.@code_native","page":"Interactive Utilities","title":"InteractiveUtils.@code_native","text":"@code_native\n\nEvaluates the arguments to the function or macro call, determines their types, and calls code_native on the resulting expression.\n\nSet the optional keyword argument debuginfo by putting it before the function call, like this:\n\n@code_native debuginfo=:default f(x)\n\ndebuginfo may be one of :source (default) or :none, to specify the verbosity of code comments.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/InteractiveUtils.html#InteractiveUtils.clipboard","page":"Interactive Utilities","title":"InteractiveUtils.clipboard","text":"clipboard(x)\n\nSend a printed form of x to the operating system clipboard (\"copy\").\n\n\n\n\n\nclipboard() -> AbstractString\n\nReturn a string with the contents of the operating system clipboard (\"paste\").\n\n\n\n\n\n","category":"function"},{"location":"stdlib/InteractiveUtils.html#","page":"Interactive Utilities","title":"Interactive Utilities","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/LibGit2.html#LibGit2-1","page":"LibGit2","title":"LibGit2","text":"","category":"section"},{"location":"stdlib/LibGit2.html#","page":"LibGit2","title":"LibGit2","text":"DocTestSetup = :(using LibGit2)","category":"page"},{"location":"stdlib/LibGit2.html#","page":"LibGit2","title":"LibGit2","text":"The LibGit2 module provides bindings to libgit2, a portable C library that implements core functionality for the Git version control system.  These bindings are currently used to power Julia's package manager.  It is expected that this module will eventually be moved into a separate package.","category":"page"},{"location":"stdlib/LibGit2.html#Functionality-1","page":"LibGit2","title":"Functionality","text":"","category":"section"},{"location":"stdlib/LibGit2.html#","page":"LibGit2","title":"LibGit2","text":"Some of this documentation assumes some prior knowledge of the libgit2 API. For more information on some of the objects and methods referenced here, consult the upstream libgit2 API reference.","category":"page"},{"location":"stdlib/LibGit2.html#","page":"LibGit2","title":"LibGit2","text":"LibGit2.Buffer\nLibGit2.CheckoutOptions\nLibGit2.CloneOptions\nLibGit2.DescribeOptions\nLibGit2.DescribeFormatOptions\nLibGit2.DiffDelta\nLibGit2.DiffFile\nLibGit2.DiffOptionsStruct\nLibGit2.FetchHead\nLibGit2.FetchOptions\nLibGit2.GitAnnotated\nLibGit2.GitBlame\nLibGit2.GitBlob\nLibGit2.GitCommit\nLibGit2.GitHash\nLibGit2.GitObject\nLibGit2.GitRemote\nLibGit2.GitRemoteAnon\nLibGit2.GitRepo\nLibGit2.GitRepoExt\nLibGit2.GitRevWalker\nLibGit2.GitShortHash\nLibGit2.GitSignature\nLibGit2.GitStatus\nLibGit2.GitTag\nLibGit2.GitTree\nLibGit2.IndexEntry\nLibGit2.IndexTime\nLibGit2.BlameOptions\nLibGit2.MergeOptions\nLibGit2.ProxyOptions\nLibGit2.PushOptions\nLibGit2.RebaseOperation\nLibGit2.RebaseOptions\nLibGit2.RemoteCallbacks\nLibGit2.SignatureStruct\nLibGit2.StatusEntry\nLibGit2.StatusOptions\nLibGit2.StrArrayStruct\nLibGit2.TimeStruct\nLibGit2.add!\nLibGit2.add_fetch!\nLibGit2.add_push!\nLibGit2.addblob!\nLibGit2.author\nLibGit2.authors\nLibGit2.branch\nLibGit2.branch!\nLibGit2.checkout!\nLibGit2.clone\nLibGit2.commit\nLibGit2.committer\nLibGit2.count\nLibGit2.counthunks\nLibGit2.create_branch\nLibGit2.credentials_callback\nLibGit2.credentials_cb\nLibGit2.default_signature\nLibGit2.delete_branch\nLibGit2.diff_files\nLibGit2.entryid\nLibGit2.entrytype\nLibGit2.fetch\nLibGit2.fetchheads\nLibGit2.fetch_refspecs\nLibGit2.fetchhead_foreach_cb\nLibGit2.merge_base\nLibGit2.merge!(::LibGit2.GitRepo; ::Any...)\nLibGit2.merge!(::LibGit2.GitRepo, ::Vector{LibGit2.GitAnnotated}; ::LibGit2.MergeOptions, ::LibGit2.CheckoutOptions)\nLibGit2.merge!(::LibGit2.GitRepo, ::Vector{LibGit2.GitAnnotated}, ::Bool; ::LibGit2.MergeOptions, ::LibGit2.CheckoutOptions)\nLibGit2.ffmerge!\nLibGit2.fullname\nLibGit2.features\nLibGit2.filename\nLibGit2.filemode\nLibGit2.gitdir\nLibGit2.git_url\nLibGit2.@githash_str\nLibGit2.head\nLibGit2.head!\nLibGit2.head_oid\nLibGit2.headname\nLibGit2.init\nLibGit2.is_ancestor_of\nLibGit2.isbinary\nLibGit2.iscommit\nLibGit2.isdiff\nLibGit2.isdirty\nLibGit2.isorphan\nLibGit2.isset\nLibGit2.iszero\nLibGit2.lookup_branch\nLibGit2.map\nLibGit2.mirror_callback\nLibGit2.mirror_cb\nLibGit2.message\nLibGit2.merge_analysis\nLibGit2.name\nLibGit2.need_update\nLibGit2.objtype\nLibGit2.path\nLibGit2.peel\nLibGit2.posixpath\nLibGit2.push\nLibGit2.push!(::LibGit2.GitRevWalker, ::LibGit2.GitHash)\nLibGit2.push_head!\nLibGit2.push_refspecs\nLibGit2.raw\nLibGit2.read_tree!\nLibGit2.rebase!\nLibGit2.ref_list\nLibGit2.reftype\nLibGit2.remotes\nLibGit2.remove!\nLibGit2.reset\nLibGit2.reset!\nLibGit2.restore\nLibGit2.revcount\nLibGit2.set_remote_url\nLibGit2.shortname\nLibGit2.snapshot\nLibGit2.split_cfg_entry\nLibGit2.status\nLibGit2.stage\nLibGit2.tag_create\nLibGit2.tag_delete\nLibGit2.tag_list\nLibGit2.target\nLibGit2.toggle\nLibGit2.transact\nLibGit2.treewalk\nLibGit2.upstream\nLibGit2.update!\nLibGit2.url\nLibGit2.version\nLibGit2.with\nLibGit2.with_warn\nLibGit2.workdir\nLibGit2.GitObject(::LibGit2.GitTreeEntry)\nLibGit2.UserPasswordCredential\nLibGit2.SSHCredential\nLibGit2.isfilled\nLibGit2.CachedCredentials\nLibGit2.CredentialPayload\nLibGit2.approve\nLibGit2.reject","category":"page"},{"location":"stdlib/LibGit2.html#LibGit2.Buffer","page":"LibGit2","title":"LibGit2.Buffer","text":"LibGit2.Buffer\n\nA data buffer for exporting data from libgit2. Matches the git_buf struct.\n\nWhen fetching data from LibGit2, a typical usage would look like:\n\nbuf_ref = Ref(Buffer())\n@check ccall(..., (Ptr{Buffer},), buf_ref)\n# operation on buf_ref\nfree(buf_ref)\n\nIn particular, note that LibGit2.free should be called afterward on the Ref object.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.CheckoutOptions","page":"LibGit2","title":"LibGit2.CheckoutOptions","text":"LibGit2.CheckoutOptions\n\nMatches the git_checkout_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\ncheckout_strategy: determine how to handle conflicts and whether to force the  checkout/recreate missing files.\ndisable_filters: if nonzero, do not apply filters like CLRF (to convert file newlines between UNIX and DOS).\ndir_mode: read/write/access mode for any directories involved in the checkout. Default is 0755.\nfile_mode: read/write/access mode for any files involved in the checkout.  Default is 0755 or 0644, depending on the blob.\nfile_open_flags: bitflags used to open any files during the checkout.\nnotify_flags: Flags for what sort of conflicts the user should be notified about.\nnotify_cb: An optional callback function to notify the user if a checkout conflict occurs.  If this function returns a non-zero value, the checkout will be cancelled.\nnotify_payload: Payload for the notify callback function.\nprogress_cb: An optional callback function to display checkout progress.\nprogress_payload: Payload for the progress callback.\npaths: If not empty, describes which paths to search during the checkout.  If empty, the checkout will occur over all files in the repository.\nbaseline: Expected content of the workdir, captured in a (pointer to a)  GitTree. Defaults to the state of the tree at HEAD.\nbaseline_index: Expected content of the workdir, captured in a (pointer to a)  GitIndex. Defaults to the state of the index at HEAD.\ntarget_directory: If not empty, checkout to this directory instead of the workdir.\nancestor_label: In case of conflicts, the name of the common ancestor side.\nour_label: In case of conflicts, the name of \"our\" side.\ntheir_label: In case of conflicts, the name of \"their\" side.\nperfdata_cb: An optional callback function to display performance data.\nperfdata_payload: Payload for the performance callback.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.CloneOptions","page":"LibGit2","title":"LibGit2.CloneOptions","text":"LibGit2.CloneOptions\n\nMatches the git_clone_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\ncheckout_opts: The options for performing the checkout of the remote as part of the clone.\nfetch_opts: The options for performing the pre-checkout fetch of the remote as part of the clone.\nbare: If 0, clone the full remote repository. If non-zero, perform a bare clone, in which  there is no local copy of the source files in the repository and the gitdir and workdir  are the same.\nlocalclone: Flag whether to clone a local object database or do a fetch. The default is to let git decide.  It will not use the git-aware transport for a local clone, but will use it for URLs which begin with file://.\ncheckout_branch: The name of the branch to checkout. If an empty string, the default branch of the  remote will be checked out.\nrepository_cb: An optional callback which will be used to create the new repository into which  the clone is made.\nrepository_cb_payload: The payload for the repository callback.\nremote_cb: An optional callback used to create the GitRemote before making the clone from it.\nremote_cb_payload: The payload for the remote callback.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.DescribeOptions","page":"LibGit2","title":"LibGit2.DescribeOptions","text":"LibGit2.DescribeOptions\n\nMatches the git_describe_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nmax_candidates_tags: consider this many most recent tags in refs/tags to describe a commit.  Defaults to 10 (so that the 10 most recent tags would be examined to see if they describe a commit).\ndescribe_strategy: whether to consider all entries in refs/tags (equivalent to git-describe --tags)  or all entries in refs/ (equivalent to git-describe --all). The default is to only show annotated tags.  If Consts.DESCRIBE_TAGS is passed, all tags, annotated or not, will be considered.  If Consts.DESCRIBE_ALL is passed, any ref in refs/ will be considered.\npattern: only consider tags which match pattern. Supports glob expansion.\nonly_follow_first_parent: when finding the distance from a matching reference to the described  object, only consider the distance from the first parent.\nshow_commit_oid_as_fallback: if no matching reference can be found which describes a commit, show the  commit's GitHash instead of throwing an error (the default behavior).\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.DescribeFormatOptions","page":"LibGit2","title":"LibGit2.DescribeFormatOptions","text":"LibGit2.DescribeFormatOptions\n\nMatches the git_describe_format_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nabbreviated_size: lower bound on the size of the abbreviated GitHash to use, defaulting to 7.\nalways_use_long_format: set to 1 to use the long format for strings even if a short format can be used.\ndirty_suffix: if set, this will be appended to the end of the description string if the workdir is dirty.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.DiffDelta","page":"LibGit2","title":"LibGit2.DiffDelta","text":"LibGit2.DiffDelta\n\nDescription of changes to one entry. Matches the git_diff_delta struct.\n\nThe fields represent:\n\nstatus: One of Consts.DELTA_STATUS, indicating whether the file has been added/modified/deleted.\nflags: Flags for the delta and the objects on each side. Determines whether to treat the file(s)  as binary/text, whether they exist on each side of the diff, and whether the object ids are known  to be correct.\nsimilarity: Used to indicate if a file has been renamed or copied.\nnfiles: The number of files in the delta (for instance, if the delta  was run on a submodule commit id, it may contain more than one file).\nold_file: A DiffFile containing information about the file(s) before the changes.\nnew_file: A DiffFile containing information about the file(s) after the changes.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.DiffFile","page":"LibGit2","title":"LibGit2.DiffFile","text":"LibGit2.DiffFile\n\nDescription of one side of a delta. Matches the git_diff_file struct.\n\nThe fields represent:\n\nid: the GitHash of the item in the diff. If the item is empty on this  side of the diff (for instance, if the diff is of the removal of a file), this will  be GitHash(0).\npath: a NULL terminated path to the item relative to the working directory of the repository.\nsize: the size of the item in bytes.\nflags: a combination of the git_diff_flag_t  flags. The ith bit of this integer sets the ith flag.\nmode: the stat mode for the item.\nid_abbrev: only present in LibGit2 versions newer than or equal to 0.25.0.  The length of the id field when converted using string. Usually equal to OID_HEXSZ (40).\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.DiffOptionsStruct","page":"LibGit2","title":"LibGit2.DiffOptionsStruct","text":"LibGit2.DiffOptionsStruct\n\nMatches the git_diff_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nflags: flags controlling which files will appear in the diff. Defaults to DIFF_NORMAL.\nignore_submodules: whether to look at files in submodules or not. Defaults to SUBMODULE_IGNORE_UNSPECIFIED, which means the submodule's configuration will control  whether it appears in the diff or not.\npathspec: path to files to include in the diff. Default is to use all files in the repository.\nnotify_cb: optional callback which will notify the user of changes to the diff as file deltas are  added to it.\nprogress_cb: optional callback which will display diff progress. Only relevant on libgit2 versions  at least as new as 0.24.0.\npayload: the payload to pass to notify_cb and progress_cb.\ncontext_lines: the number of unchanged lines used to define the edges of a hunk.  This is also the number of lines which will be shown before/after a hunk to provide  context. Default is 3.\ninterhunk_lines: the maximum number of unchanged lines between two separate  hunks allowed before the hunks will be combined. Default is 0.\nid_abbrev: sets the length of the abbreviated GitHash to print.  Default is 7.\nmax_size: the maximum file size of a blob. Above this size, it will be treated  as a binary blob. The default is 512 MB.\nold_prefix: the virtual file directory in which to place old files on one side  of the diff. Default is \"a\".\nnew_prefix: the virtual file directory in which to place new files on one side  of the diff. Default is \"b\".\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.FetchHead","page":"LibGit2","title":"LibGit2.FetchHead","text":"LibGit2.FetchHead\n\nContains the information about HEAD during a fetch, including the name and URL of the branch fetched from, the oid of the HEAD, and whether the fetched HEAD has been merged locally.\n\nThe fields represent:\n\nname: The name in the local reference database of the fetch head, for example,  \"refs/heads/master\".\nurl: The URL of the fetch head.\noid: The GitHash of the tip of the fetch head.\nismerge: Boolean flag indicating whether the changes at the  remote have been merged into the local copy yet or not. If true, the local  copy is up to date with the remote fetch head.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.FetchOptions","page":"LibGit2","title":"LibGit2.FetchOptions","text":"LibGit2.FetchOptions\n\nMatches the git_fetch_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\ncallbacks: remote callbacks to use during the fetch.\nprune: whether to perform a prune after the fetch or not. The default is to  use the setting from the GitConfig.\nupdate_fetchhead: whether to update the FetchHead after the fetch.  The default is to perform the update, which is the normal git behavior.\ndownload_tags: whether to download tags present at the remote or not. The default  is to request the tags for objects which are being downloaded anyway from the server.\nproxy_opts: options for connecting to the remote through a proxy. See ProxyOptions.  Only present on libgit2 versions newer than or equal to 0.25.0.\ncustom_headers: any extra headers needed for the fetch. Only present on libgit2 versions  newer than or equal to 0.24.0.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitAnnotated","page":"LibGit2","title":"LibGit2.GitAnnotated","text":"GitAnnotated(repo::GitRepo, commit_id::GitHash)\nGitAnnotated(repo::GitRepo, ref::GitReference)\nGitAnnotated(repo::GitRepo, fh::FetchHead)\nGitAnnotated(repo::GitRepo, comittish::AbstractString)\n\nAn annotated git commit carries with it information about how it was looked up and why, so that rebase or merge operations have more information about the context of the commit. Conflict files contain information about the source/target branches in the merge which are conflicting, for instance. An annotated commit can refer to the tip of a remote branch, for instance when a FetchHead is passed, or to a branch head described using GitReference.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitBlame","page":"LibGit2","title":"LibGit2.GitBlame","text":"GitBlame(repo::GitRepo, path::AbstractString; options::BlameOptions=BlameOptions())\n\nConstruct a GitBlame object for the file at path, using change information gleaned from the history of repo. The GitBlame object records who changed which chunks of the file when, and how. options controls how to separate the contents of the file and which commits to probe - see BlameOptions for more information.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitBlob","page":"LibGit2","title":"LibGit2.GitBlob","text":"GitBlob(repo::GitRepo, hash::AbstractGitHash)\nGitBlob(repo::GitRepo, spec::AbstractString)\n\nReturn a GitBlob object from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitCommit","page":"LibGit2","title":"LibGit2.GitCommit","text":"GitCommit(repo::GitRepo, hash::AbstractGitHash)\nGitCommit(repo::GitRepo, spec::AbstractString)\n\nReturn a GitCommit object from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitHash","page":"LibGit2","title":"LibGit2.GitHash","text":"GitHash\n\nA git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a GitObject in a repository.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitObject","page":"LibGit2","title":"LibGit2.GitObject","text":"GitObject(repo::GitRepo, hash::AbstractGitHash)\nGitObject(repo::GitRepo, spec::AbstractString)\n\nReturn the specified object (GitCommit, GitBlob, GitTree or GitTag) from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitRemote","page":"LibGit2","title":"LibGit2.GitRemote","text":"GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString) -> GitRemote\n\nLook up a remote git repository using its name and URL. Uses the default fetch refspec.\n\nExamples\n\nrepo = LibGit2.init(repo_path)\nremote = LibGit2.GitRemote(repo, \"upstream\", repo_url)\n\n\n\n\n\nGitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString, fetch_spec::AbstractString) -> GitRemote\n\nLook up a remote git repository using the repository's name and URL, as well as specifications for how to fetch from the remote (e.g. which remote branch to fetch from).\n\nExamples\n\nrepo = LibGit2.init(repo_path)\nrefspec = \"+refs/heads/mybranch:refs/remotes/origin/mybranch\"\nremote = LibGit2.GitRemote(repo, \"upstream\", repo_url, refspec)\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitRemoteAnon","page":"LibGit2","title":"LibGit2.GitRemoteAnon","text":"GitRemoteAnon(repo::GitRepo, url::AbstractString) -> GitRemote\n\nLook up a remote git repository using only its URL, not its name.\n\nExamples\n\nrepo = LibGit2.init(repo_path)\nremote = LibGit2.GitRemoteAnon(repo, repo_url)\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.GitRepo","page":"LibGit2","title":"LibGit2.GitRepo","text":"LibGit2.GitRepo(path::AbstractString)\n\nOpen a git repository at path.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitRepoExt","page":"LibGit2","title":"LibGit2.GitRepoExt","text":"LibGit2.GitRepoExt(path::AbstractString, flags::Cuint = Cuint(Consts.REPOSITORY_OPEN_DEFAULT))\n\nOpen a git repository at path with extended controls (for instance, if the current user must be a member of a special access group to read path).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.GitRevWalker","page":"LibGit2","title":"LibGit2.GitRevWalker","text":"GitRevWalker(repo::GitRepo)\n\nA GitRevWalker walks through the revisions (i.e. commits) of a git repository repo. It is a collection of the commits in the repository, and supports iteration and calls to map and count (for instance, count could be used to determine what percentage of commits in a repository were made by a certain author).\n\ncnt = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker\n    count((oid,repo)->(oid == commit_oid1), walker, oid=commit_oid1, by=LibGit2.Consts.SORT_TIME)\nend\n\nHere, count finds the number of commits along the walk with a certain GitHash. Since the GitHash is unique to a commit, cnt will be 1.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitShortHash","page":"LibGit2","title":"LibGit2.GitShortHash","text":"GitShortHash(hash::GitHash, len::Integer)\n\nA shortened git object identifier, which can be used to identify a git object when it is unique, consisting of the initial len hexadecimal digits of hash (the remaining digits are ignored).\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitSignature","page":"LibGit2","title":"LibGit2.GitSignature","text":"LibGit2.GitSignature\n\nThis is a Julia wrapper around a pointer to a git_signature object.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitStatus","page":"LibGit2","title":"LibGit2.GitStatus","text":"LibGit2.GitStatus(repo::GitRepo; status_opts=StatusOptions())\n\nCollect information about the status of each file in the git repository repo (e.g. is the file modified, staged, etc.). status_opts can be used to set various options, for instance whether or not to look at untracked files or whether to include submodules or not. See StatusOptions for more information.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitTag","page":"LibGit2","title":"LibGit2.GitTag","text":"GitTag(repo::GitRepo, hash::AbstractGitHash)\nGitTag(repo::GitRepo, spec::AbstractString)\n\nReturn a GitTag object from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.GitTree","page":"LibGit2","title":"LibGit2.GitTree","text":"GitTree(repo::GitRepo, hash::AbstractGitHash)\nGitTree(repo::GitRepo, spec::AbstractString)\n\nReturn a GitTree object from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.IndexEntry","page":"LibGit2","title":"LibGit2.IndexEntry","text":"LibGit2.IndexEntry\n\nIn-memory representation of a file entry in the index. Matches the git_index_entry struct.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.IndexTime","page":"LibGit2","title":"LibGit2.IndexTime","text":"LibGit2.IndexTime\n\nMatches the git_index_time struct.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.BlameOptions","page":"LibGit2","title":"LibGit2.BlameOptions","text":"LibGit2.BlameOptions\n\nMatches the git_blame_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nflags: one of Consts.BLAME_NORMAL or Consts.BLAME_FIRST_PARENT (the other blame flags  are not yet implemented by libgit2).\nmin_match_characters: the minimum number of alphanumeric characters which much change in a commit in order for the change to be associated with that commit. The default is 20. Only takes effect if one of the Consts.BLAME_*_COPIES flags are used, which libgit2 does not implement yet.\nnewest_commit: the GitHash of the newest commit from which to look at changes.\noldest_commit: the GitHash of the oldest commit from which to look at changes.\nmin_line: the first line of the file from which to starting blaming. The default is 1.\nmax_line: the last line of the file to which to blame. The default is 0, meaning the last line of the file.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.MergeOptions","page":"LibGit2","title":"LibGit2.MergeOptions","text":"LibGit2.MergeOptions\n\nMatches the git_merge_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nflags: an enum for flags describing merge behavior.  Defined in git_merge_flag_t.  The corresponding Julia enum is GIT_MERGE and has values:\nMERGE_FIND_RENAMES: detect if a file has been renamed between the common ancestor and the \"ours\" or \"theirs\" side of the merge. Allows merges where a file has been renamed.\nMERGE_FAIL_ON_CONFLICT: exit immediately if a conflict is found rather than trying to resolve it.\nMERGE_SKIP_REUC: do not write the REUC extension on the index resulting from the merge.\nMERGE_NO_RECURSIVE: if the commits being merged have multiple merge bases, use the first one, rather than trying to recursively merge the bases.\nrename_threshold: how similar two files must to consider one a rename of the other. This is an integer that sets the percentage similarity. The default is 50.\ntarget_limit: the maximum number of files to compare with to look for renames. The default is 200.\nmetric: optional custom function to use to determine the similarity between two files for rename detection.\nrecursion_limit: the upper limit on the number of merges of common ancestors to perform to try to build a new virtual merge base for the merge. The default is no limit. This field is only present on libgit2 versions newer than 0.24.0.\ndefault_driver: the merge driver to use if both sides have changed. This field is only present on libgit2 versions newer than 0.25.0.\nfile_favor: how to handle conflicting file contents for the text driver.\nMERGE_FILE_FAVOR_NORMAL: if both sides of the merge have changes to a section,  make a note of the conflict in the index which git checkout will use to create  a merge file, which the user can then reference to resolve the conflicts. This is  the default.\nMERGE_FILE_FAVOR_OURS: if both sides of the merge have changes to a section,  use the version in the \"ours\" side of the merge in the index.\nMERGE_FILE_FAVOR_THEIRS: if both sides of the merge have changes to a section,  use the version in the \"theirs\" side of the merge in the index.\nMERGE_FILE_FAVOR_UNION: if both sides of the merge have changes to a section,  include each unique line from both sides in the file which is put into the index.\nfile_flags: guidelines for merging files.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.ProxyOptions","page":"LibGit2","title":"LibGit2.ProxyOptions","text":"LibGit2.ProxyOptions\n\nOptions for connecting through a proxy.\n\nMatches the git_proxy_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nproxytype: an enum for the type of proxy to use.  Defined in git_proxy_t.  The corresponding Julia enum is GIT_PROXY and has values:\nPROXY_NONE: do not attempt the connection through a proxy.\nPROXY_AUTO: attempt to figure out the proxy configuration from the git configuration.\nPROXY_SPECIFIED: connect using the URL given in the url field of this struct.\nDefault is to auto-detect the proxy type.\nurl: the URL of the proxy.\ncredential_cb: a pointer to a callback function which will be called if the remote requires authentication to connect.\ncertificate_cb: a pointer to a callback function which will be called if certificate verification fails. This lets the user decide whether or not to keep connecting. If the function returns 1, connecting will be allowed. If it returns 0, the connection will not be allowed. A negative value can be used to return errors.\npayload: the payload to be provided to the two callback functions.\n\nExamples\n\njulia> fo = LibGit2.FetchOptions(\n           proxy_opts = LibGit2.ProxyOptions(url = Cstring(\"https://my_proxy_url.com\")))\n\njulia> fetch(remote, \"master\", options=fo)\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.PushOptions","page":"LibGit2","title":"LibGit2.PushOptions","text":"LibGit2.PushOptions\n\nMatches the git_push_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nparallelism: if a pack file must be created, this variable sets the number of worker  threads which will be spawned by the packbuilder. If 0, the packbuilder will auto-set  the number of threads to use. The default is 1.\ncallbacks: the callbacks (e.g. for authentication with the remote) to use for the push.\nproxy_opts: only relevant if the LibGit2 version is greater than or equal to 0.25.0.  Sets options for using a proxy to communicate with a remote. See ProxyOptions  for more information.\ncustom_headers: only relevant if the LibGit2 version is greater than or equal to 0.24.0.  Extra headers needed for the push operation.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.RebaseOperation","page":"LibGit2","title":"LibGit2.RebaseOperation","text":"LibGit2.RebaseOperation\n\nDescribes a single instruction/operation to be performed during the rebase. Matches the git_rebase_operation struct.\n\nThe fields represent:\n\noptype: the type of rebase operation currently being performed. The options are:\nREBASE_OPERATION_PICK: cherry-pick the commit in question.\nREBASE_OPERATION_REWORD: cherry-pick the commit in question, but rewrite its message using the prompt.\nREBASE_OPERATION_EDIT: cherry-pick the commit in question, but allow the user to edit the commit's contents and its message.\nREBASE_OPERATION_SQUASH: squash the commit in question into the previous commit. The commit messages of the two commits will be merged.\nREBASE_OPERATION_FIXUP: squash the commit in question into the previous commit. Only the commit message of the previous commit will be used.\nREBASE_OPERATION_EXEC: do not cherry-pick a commit. Run a command and continue if the command exits successfully.\nid: the GitHash of the commit being worked on during this rebase step.\nexec: in case REBASE_OPERATION_EXEC is used, the command to run during this step (for instance, running the test suite after each commit).\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.RebaseOptions","page":"LibGit2","title":"LibGit2.RebaseOptions","text":"LibGit2.RebaseOptions\n\nMatches the git_rebase_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nquiet: inform other git clients helping with/working on the rebase that the rebase should be done \"quietly\". Used for interoperability. The default is 1.\ninmemory: start an in-memory rebase. Callers working on the rebase can go through its steps and commit any changes, but cannot rewind HEAD or update the repository. The workdir will not be modified. Only present on libgit2 versions newer than or equal to 0.24.0.\nrewrite_notes_ref: name of the reference to notes to use to rewrite the commit notes as the rebase is finished.\nmerge_opts: merge options controlling how the trees will be merged at each rebase step.  Only present on libgit2 versions newer than or equal to 0.24.0.\ncheckout_opts: checkout options for writing files when initializing the rebase, stepping through it, and aborting it. See CheckoutOptions for more information.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.RemoteCallbacks","page":"LibGit2","title":"LibGit2.RemoteCallbacks","text":"LibGit2.RemoteCallbacks\n\nCallback settings. Matches the git_remote_callbacks struct.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.SignatureStruct","page":"LibGit2","title":"LibGit2.SignatureStruct","text":"LibGit2.SignatureStruct\n\nAn action signature (e.g. for committers, taggers, etc). Matches the git_signature struct.\n\nThe fields represent:\n\nname: The full name of the committer or author of the commit.\nemail: The email at which the committer/author can be contacted.\nwhen: a TimeStruct indicating when the commit was  authored/committed into the repository.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.StatusEntry","page":"LibGit2","title":"LibGit2.StatusEntry","text":"LibGit2.StatusEntry\n\nProviding the differences between the file as it exists in HEAD and the index, and providing the differences between the index and the working directory. Matches the git_status_entry struct.\n\nThe fields represent:\n\nstatus: contains the status flags for the file, indicating if it is current, or has been changed in some way in the index or work tree.\nhead_to_index: a pointer to a DiffDelta which encapsulates the difference(s) between the file as it exists in HEAD and in the index.\nindex_to_workdir: a pointer to a DiffDelta which encapsulates the difference(s) between the file as it exists in the index and in the workdir.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.StatusOptions","page":"LibGit2","title":"LibGit2.StatusOptions","text":"LibGit2.StatusOptions\n\nOptions to control how git_status_foreach_ext() will issue callbacks. Matches the git_status_opt_t struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nshow: a flag for which files to examine and in which order. The default is Consts.STATUS_SHOW_INDEX_AND_WORKDIR.\nflags: flags for controlling any callbacks used in a status call.\npathspec: an array of paths to use for path-matching. The behavior of the path-matching will vary depending on the values of show and flags.\nThe baseline is the tree to be used for comparison to the working directory and index; defaults to HEAD.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.StrArrayStruct","page":"LibGit2","title":"LibGit2.StrArrayStruct","text":"LibGit2.StrArrayStruct\n\nA LibGit2 representation of an array of strings. Matches the git_strarray struct.\n\nWhen fetching data from LibGit2, a typical usage would look like:\n\nsa_ref = Ref(StrArrayStruct())\n@check ccall(..., (Ptr{StrArrayStruct},), sa_ref)\nres = convert(Vector{String}, sa_ref[])\nfree(sa_ref)\n\nIn particular, note that LibGit2.free should be called afterward on the Ref object.\n\nConversely, when passing a vector of strings to LibGit2, it is generally simplest to rely on implicit conversion:\n\nstrs = String[...]\n@check ccall(..., (Ptr{StrArrayStruct},), strs)\n\nNote that no call to free is required as the data is allocated by Julia.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.TimeStruct","page":"LibGit2","title":"LibGit2.TimeStruct","text":"LibGit2.TimeStruct\n\nTime in a signature. Matches the git_time struct.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.add!","page":"LibGit2","title":"LibGit2.add!","text":"add!(repo::GitRepo, files::AbstractString...; flags::Cuint = Consts.INDEX_ADD_DEFAULT)\nadd!(idx::GitIndex, files::AbstractString...; flags::Cuint = Consts.INDEX_ADD_DEFAULT)\n\nAdd all the files with paths specified by files to the index idx (or the index of the repo). If the file already exists, the index entry will be updated. If the file does not exist already, it will be newly added into the index. files may contain glob patterns which will be expanded and any matching files will be added (unless INDEX_ADD_DISABLE_PATHSPEC_MATCH is set, see below). If a file has been ignored (in .gitignore or in the config), it will not be added, unless it is already being tracked in the index, in which case it will be updated. The keyword argument flags is a set of bit-flags which control the behavior with respect to ignored files:\n\nConsts.INDEX_ADD_DEFAULT - default, described above.\nConsts.INDEX_ADD_FORCE - disregard the existing ignore rules and force addition of the file to the index even if it is already ignored.\nConsts.INDEX_ADD_CHECK_PATHSPEC - cannot be used at the same time as INDEX_ADD_FORCE. Check that each file in files which exists on disk is not in the ignore list. If one of the files is ignored, the function will return EINVALIDSPEC.\nConsts.INDEX_ADD_DISABLE_PATHSPEC_MATCH - turn off glob matching, and only add files to the index which exactly match the paths specified in files.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.add_fetch!","page":"LibGit2","title":"LibGit2.add_fetch!","text":"add_fetch!(repo::GitRepo, rmt::GitRemote, fetch_spec::String)\n\nAdd a fetch refspec for the specified rmt. This refspec will contain information about which branch(es) to fetch from.\n\nExamples\n\njulia> LibGit2.add_fetch!(repo, remote, \"upstream\");\n\njulia> LibGit2.fetch_refspecs(remote)\nString[\"+refs/heads/*:refs/remotes/upstream/*\"]\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.add_push!","page":"LibGit2","title":"LibGit2.add_push!","text":"add_push!(repo::GitRepo, rmt::GitRemote, push_spec::String)\n\nAdd a push refspec for the specified rmt. This refspec will contain information about which branch(es) to push to.\n\nExamples\n\njulia> LibGit2.add_push!(repo, remote, \"refs/heads/master\");\n\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, branch);\n\njulia> LibGit2.push_refspecs(remote)\nString[\"refs/heads/master\"]\n\nnote: Note\nYou may need to close and reopen the GitRemote in question after updating its push refspecs in order for the change to take effect and for calls to push to work.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.addblob!","page":"LibGit2","title":"LibGit2.addblob!","text":"LibGit2.addblob!(repo::GitRepo, path::AbstractString)\n\nRead the file at path and adds it to the object database of repo as a loose blob. Return the GitHash of the resulting blob.\n\nExamples\n\nhash_str = string(commit_oid)\nblob_file = joinpath(repo_path, \".git\", \"objects\", hash_str[1:2], hash_str[3:end])\nid = LibGit2.addblob!(repo, blob_file)\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.author","page":"LibGit2","title":"LibGit2.author","text":"author(c::GitCommit)\n\nReturn the Signature of the author of the commit c. The author is the person who made changes to the relevant file(s). See also committer.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.authors","page":"LibGit2","title":"LibGit2.authors","text":"authors(repo::GitRepo) -> Vector{Signature}\n\nReturn all authors of commits to the repo repository.\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nrepo_file = open(joinpath(repo_path, test_file), \"a\")\n\nprintln(repo_file, commit_msg)\nflush(repo_file)\nLibGit2.add!(repo, test_file)\nsig = LibGit2.Signature(\"TEST\", \"TEST@TEST.COM\", round(time(), 0), 0)\ncommit_oid1 = LibGit2.commit(repo, \"commit1\"; author=sig, committer=sig)\nprintln(repo_file, randstring(10))\nflush(repo_file)\nLibGit2.add!(repo, test_file)\ncommit_oid2 = LibGit2.commit(repo, \"commit2\"; author=sig, committer=sig)\n\n# will be a Vector of [sig, sig]\nauths = LibGit2.authors(repo)\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.branch","page":"LibGit2","title":"LibGit2.branch","text":"branch(repo::GitRepo)\n\nEquivalent to git branch. Create a new branch from the current HEAD.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.branch!","page":"LibGit2","title":"LibGit2.branch!","text":"branch!(repo::GitRepo, branch_name::AbstractString, commit::AbstractString=\"\"; kwargs...)\n\nCheckout a new git branch in the repo repository. commit is the GitHash, in string form, which will be the start of the new branch. If commit is an empty string, the current HEAD will be used.\n\nThe keyword arguments are:\n\ntrack::AbstractString=\"\": the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.\nforce::Bool=false: if true, branch creation will be forced.\nset_head::Bool=true: if true, after the branch creation finishes the branch head will be set as the HEAD of repo.\n\nEquivalent to git checkout [-b|-B] <branch_name> [<commit>] [--track <track>].\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nLibGit2.branch!(repo, \"new_branch\", set_head=false)\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.checkout!","page":"LibGit2","title":"LibGit2.checkout!","text":"checkout!(repo::GitRepo, commit::AbstractString=\"\"; force::Bool=true)\n\nEquivalent to git checkout [-f] --detach <commit>. Checkout the git commit commit (a GitHash in string form) in repo. If force is true, force the checkout and discard any current changes. Note that this detaches the current HEAD.\n\nExamples\n\nrepo = LibGit2.init(repo_path)\nopen(joinpath(LibGit2.path(repo), \"file1\"), \"w\") do f\n    write(f, \"111\n\")\nend\nLibGit2.add!(repo, \"file1\")\ncommit_oid = LibGit2.commit(repo, \"add file1\")\nopen(joinpath(LibGit2.path(repo), \"file1\"), \"w\") do f\n    write(f, \"112\n\")\nend\n# would fail without the force=true\n# since there are modifications to the file\nLibGit2.checkout!(repo, string(commit_oid), force=true)\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.clone","page":"LibGit2","title":"LibGit2.clone","text":"clone(repo_url::AbstractString, repo_path::AbstractString, clone_opts::CloneOptions)\n\nClone the remote repository at repo_url (which can be a remote URL or a path on the local filesystem) to repo_path (which must be a path on the local filesystem). Options for the clone, such as whether to perform a bare clone or not, are set by CloneOptions.\n\nExamples\n\nrepo_url = \"https://github.com/JuliaLang/Example.jl\"\nrepo = LibGit2.clone(repo_url, \"/home/me/projects/Example\")\n\n\n\n\n\nclone(repo_url::AbstractString, repo_path::AbstractString; kwargs...)\n\nClone a remote repository located at repo_url to the local filesystem location repo_path.\n\nThe keyword arguments are:\n\nbranch::AbstractString=\"\": which branch of the remote to clone, if not the default repository branch (usually master).\nisbare::Bool=false: if true, clone the remote as a bare repository, which will make repo_path itself the git directory instead of repo_path/.git. This means that a working tree cannot be checked out. Plays the role of the git CLI argument --bare.\nremote_cb::Ptr{Cvoid}=C_NULL: a callback which will be used to create the remote before it is cloned. If C_NULL (the default), no attempt will be made to create the remote - it will be assumed to already exist.\ncredentials::Creds=nothing: provides credentials and/or settings when authenticating against a private repository.\ncallbacks::Callbacks=Callbacks(): user provided callbacks and payloads.\n\nEquivalent to git clone [-b <branch>] [--bare] <repo_url> <repo_path>.\n\nExamples\n\nrepo_url = \"https://github.com/JuliaLang/Example.jl\"\nrepo1 = LibGit2.clone(repo_url, \"test_path\")\nrepo2 = LibGit2.clone(repo_url, \"test_path\", isbare=true)\njulia_url = \"https://github.com/JuliaLang/julia\"\njulia_repo = LibGit2.clone(julia_url, \"julia_path\", branch=\"release-0.6\")\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.commit","page":"LibGit2","title":"LibGit2.commit","text":"commit(repo::GitRepo, msg::AbstractString; kwargs...) -> GitHash\n\nWrapper around git_commit_create. Create a commit in the repository repo. msg is the commit message. Return the OID of the new commit.\n\nThe keyword arguments are:\n\nrefname::AbstractString=Consts.HEAD_FILE: if not NULL, the name of the reference to update to point to the new commit. For example, \"HEAD\" will update the HEAD of the current branch. If the reference does not yet exist, it will be created.\nauthor::Signature = Signature(repo) is a Signature containing information about the person who authored the commit.\ncommitter::Signature = Signature(repo) is a Signature containing information about the person who committed the commit to the repository. Not necessarily the same as author, for instance if author emailed a patch to committer who committed it.\ntree_id::GitHash = GitHash() is a git tree to use to create the commit, showing its ancestry and relationship with any other history. tree must belong to repo.\nparent_ids::Vector{GitHash}=GitHash[] is a list of commits by GitHash to use as parent commits for the new one, and may be empty. A commit might have multiple parents if it is a merge commit, for example.\n\n\n\n\n\nLibGit2.commit(rb::GitRebase, sig::GitSignature)\n\nCommit the current patch to the rebase rb, using sig as the committer. Is silent if the commit has already been applied.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.committer","page":"LibGit2","title":"LibGit2.committer","text":"committer(c::GitCommit)\n\nReturn the Signature of the committer of the commit c. The committer is the person who committed the changes originally authored by the author, but need not be the same as the author, for example, if the author emailed a patch to a committer who committed it.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.count","page":"LibGit2","title":"LibGit2.count","text":"LibGit2.count(f::Function, walker::GitRevWalker; oid::GitHash=GitHash(), by::Cint=Consts.SORT_NONE, rev::Bool=false)\n\nUsing the GitRevWalker walker to \"walk\" over every commit in the repository's history, find the number of commits which return true when f is applied to them. The keyword arguments are:     * oid: The GitHash of the commit to begin the walk from. The default is to use       push_head! and therefore the HEAD commit and all its ancestors.     * by: The sorting method. The default is not to sort. Other options are to sort by       topology (LibGit2.Consts.SORT_TOPOLOGICAL), to sort forwards in time       (LibGit2.Consts.SORT_TIME, most ancient first) or to sort backwards in time       (LibGit2.Consts.SORT_REVERSE, most recent first).     * rev: Whether to reverse the sorted order (for instance, if topological sorting is used).\n\nExamples\n\ncnt = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker\n    count((oid, repo)->(oid == commit_oid1), walker, oid=commit_oid1, by=LibGit2.Consts.SORT_TIME)\nend\n\ncount finds the number of commits along the walk with a certain GitHash commit_oid1, starting the walk from that commit and moving forwards in time from it. Since the GitHash is unique to a commit, cnt will be 1.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.counthunks","page":"LibGit2","title":"LibGit2.counthunks","text":"counthunks(blame::GitBlame)\n\nReturn the number of distinct \"hunks\" with a file. A hunk may contain multiple lines. A hunk is usually a piece of a file that was added/changed/removed together, for example, a function added to a source file or an inner loop that was optimized out of that function later.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.create_branch","page":"LibGit2","title":"LibGit2.create_branch","text":"LibGit2.create_branch(repo::GitRepo, bname::AbstractString, commit_obj::GitCommit; force::Bool=false)\n\nCreate a new branch in the repository repo with name bname, which points to commit commit_obj (which has to be part of repo). If force is true, overwrite an existing branch named bname if it exists. If force is false and a branch already exists named bname, this function will throw an error.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.credentials_callback","page":"LibGit2","title":"LibGit2.credentials_callback","text":"credential_callback(...) -> Cint\n\nA LibGit2 credential callback function which provides different credential acquisition functionality w.r.t. a connection protocol. The payload_ptr is required to contain a LibGit2.CredentialPayload object which will keep track of state and settings.\n\nThe allowed_types contains a bitmask of LibGit2.Consts.GIT_CREDTYPE values specifying which authentication methods should be attempted.\n\nCredential authentication is done in the following order (if supported):\n\nSSH agent\nSSH private/public key pair\nUsername/password plain text\n\nIf a user is presented with a credential prompt they can abort the prompt by typing ^D (pressing the control key together with the d key).\n\nNote: Due to the specifics of the libgit2 authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, we will keep track of state using the payload.\n\nFor addition details see the LibGit2 guide on authenticating against a server.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.credentials_cb","page":"LibGit2","title":"LibGit2.credentials_cb","text":"C function pointer for credentials_callback\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.default_signature","page":"LibGit2","title":"LibGit2.default_signature","text":"Return signature object. Free it after use.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.delete_branch","page":"LibGit2","title":"LibGit2.delete_branch","text":"LibGit2.delete_branch(branch::GitReference)\n\nDelete the branch pointed to by branch.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.diff_files","page":"LibGit2","title":"LibGit2.diff_files","text":"diff_files(repo::GitRepo, branch1::AbstractString, branch2::AbstractString; kwarg...) -> Vector{AbstractString}\n\nShow which files have changed in the git repository repo between branches branch1 and branch2.\n\nThe keyword argument is:\n\nfilter::Set{Consts.DELTA_STATUS}=Set([Consts.DELTA_ADDED, Consts.DELTA_MODIFIED, Consts.DELTA_DELETED])), and it sets options for the diff. The default is to show files added, modified, or deleted.\n\nReturn only the names of the files which have changed, not their contents.\n\nExamples\n\nLibGit2.branch!(repo, \"branch/a\")\nLibGit2.branch!(repo, \"branch/b\")\n# add a file to repo\nopen(joinpath(LibGit2.path(repo),\"file\"),\"w\") do f\n    write(f, \"hello repo\n\")\nend\nLibGit2.add!(repo, \"file\")\nLibGit2.commit(repo, \"add file\")\n# returns [\"file\"]\nfilt = Set([LibGit2.Consts.DELTA_ADDED])\nfiles = LibGit2.diff_files(repo, \"branch/a\", \"branch/b\", filter=filt)\n# returns [] because existing files weren't modified\nfilt = Set([LibGit2.Consts.DELTA_MODIFIED])\nfiles = LibGit2.diff_files(repo, \"branch/a\", \"branch/b\", filter=filt)\n\nEquivalent to git diff --name-only --diff-filter=<filter> <branch1> <branch2>.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.entryid","page":"LibGit2","title":"LibGit2.entryid","text":"entryid(te::GitTreeEntry)\n\nReturn the GitHash of the object to which te refers.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.entrytype","page":"LibGit2","title":"LibGit2.entrytype","text":"entrytype(te::GitTreeEntry)\n\nReturn the type of the object to which te refers. The result will be one of the types which objtype returns, e.g. a GitTree or GitBlob.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.fetch","page":"LibGit2","title":"LibGit2.fetch","text":"fetch(rmt::GitRemote, refspecs; options::FetchOptions=FetchOptions(), msg=\"\")\n\nFetch from the specified rmt remote git repository, using refspecs to determine which remote branch(es) to fetch. The keyword arguments are:\n\noptions: determines the options for the fetch, e.g. whether to prune afterwards. See FetchOptions for more information.\nmsg: a message to insert into the reflogs.\n\n\n\n\n\nfetch(repo::GitRepo; kwargs...)\n\nFetches updates from an upstream of the repository repo.\n\nThe keyword arguments are:\n\nremote::AbstractString=\"origin\": which remote, specified by name, of repo to fetch from. If this is empty, the URL will be used to construct an anonymous remote.\nremoteurl::AbstractString=\"\": the URL of remote. If not specified, will be assumed based on the given name of remote.\nrefspecs=AbstractString[]: determines properties of the fetch.\ncredentials=nothing: provides credentials and/or settings when authenticating against a private remote.\ncallbacks=Callbacks(): user provided callbacks and payloads.\n\nEquivalent to git fetch [<remoteurl>|<repo>] [<refspecs>].\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.fetchheads","page":"LibGit2","title":"LibGit2.fetchheads","text":"fetchheads(repo::GitRepo) -> Vector{FetchHead}\n\nReturn the list of all the fetch heads for repo, each represented as a FetchHead, including their names, URLs, and merge statuses.\n\nExamples\n\njulia> fetch_heads = LibGit2.fetchheads(repo);\n\njulia> fetch_heads[1].name\n\"refs/heads/master\"\n\njulia> fetch_heads[1].ismerge\ntrue\n\njulia> fetch_heads[2].name\n\"refs/heads/test_branch\"\n\njulia> fetch_heads[2].ismerge\nfalse\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.fetch_refspecs","page":"LibGit2","title":"LibGit2.fetch_refspecs","text":"fetch_refspecs(rmt::GitRemote) -> Vector{String}\n\nGet the fetch refspecs for the specified rmt. These refspecs contain information about which branch(es) to fetch from.\n\nExamples\n\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, \"upstream\");\n\njulia> LibGit2.add_fetch!(repo, remote, \"upstream\");\n\njulia> LibGit2.fetch_refspecs(remote)\nString[\"+refs/heads/*:refs/remotes/upstream/*\"]\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.fetchhead_foreach_cb","page":"LibGit2","title":"LibGit2.fetchhead_foreach_cb","text":"C function pointer for fetchhead_foreach_callback\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.merge_base","page":"LibGit2","title":"LibGit2.merge_base","text":"merge_base(repo::GitRepo, one::AbstractString, two::AbstractString) -> GitHash\n\nFind a merge base (a common ancestor) between the commits one and two. one and two may both be in string form. Return the GitHash of the merge base.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.merge!-Tuple{GitRepo}","page":"LibGit2","title":"LibGit2.merge!","text":"merge!(repo::GitRepo; kwargs...) -> Bool\n\nPerform a git merge on the repository repo, merging commits with diverging history into the current branch. Return true if the merge succeeded, false if not.\n\nThe keyword arguments are:\n\ncommittish::AbstractString=\"\": Merge the named commit(s) in committish.\nbranch::AbstractString=\"\": Merge the branch branch and all its commits since it diverged from the current branch.\nfastforward::Bool=false: If fastforward is true, only merge if the merge is a fast-forward (the current branch head is an ancestor of the commits to be merged), otherwise refuse to merge and return false. This is equivalent to the git CLI option --ff-only.\nmerge_opts::MergeOptions=MergeOptions(): merge_opts specifies options for the merge, such as merge strategy in case of conflicts.\ncheckout_opts::CheckoutOptions=CheckoutOptions(): checkout_opts specifies options for the checkout step.\n\nEquivalent to git merge [--ff-only] [<committish> | <branch>].\n\nnote: Note\nIf you specify a branch, this must be done in reference format, since the string will be turned into a GitReference. For example, if you wanted to merge branch branch_a, you would call merge!(repo, branch=\"refs/heads/branch_a\").\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LibGit2.html#LibGit2.merge!-Tuple{GitRepo,Array{LibGit2.GitAnnotated,1}}","page":"LibGit2","title":"LibGit2.merge!","text":"merge!(repo::GitRepo, anns::Vector{GitAnnotated}; kwargs...) -> Bool\n\nMerge changes from the annotated commits (captured as GitAnnotated objects) anns into the HEAD of the repository repo. The keyword arguments are:\n\nmerge_opts::MergeOptions = MergeOptions(): options for how to perform the merge, including whether fastforwarding is allowed. See MergeOptions for more information.\ncheckout_opts::CheckoutOptions = CheckoutOptions(): options for how to perform the checkout. See CheckoutOptions for more information.\n\nanns may refer to remote or local branch heads. Return true if the merge is successful, otherwise return false (for instance, if no merge is possible because the branches have no common ancestor).\n\nExamples\n\nupst_ann = LibGit2.GitAnnotated(repo, \"branch/a\")\n\n# merge the branch in\nLibGit2.merge!(repo, [upst_ann])\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LibGit2.html#LibGit2.merge!-Tuple{GitRepo,Array{LibGit2.GitAnnotated,1},Bool}","page":"LibGit2","title":"LibGit2.merge!","text":"merge!(repo::GitRepo, anns::Vector{GitAnnotated}, fastforward::Bool; kwargs...) -> Bool\n\nMerge changes from the annotated commits (captured as GitAnnotated objects) anns into the HEAD of the repository repo. If fastforward is true, only a fastforward merge is allowed. In this case, if conflicts occur, the merge will fail. Otherwise, if fastforward is false, the merge may produce a conflict file which the user will need to resolve.\n\nThe keyword arguments are:\n\nmerge_opts::MergeOptions = MergeOptions(): options for how to perform the merge, including whether fastforwarding is allowed. See MergeOptions for more information.\ncheckout_opts::CheckoutOptions = CheckoutOptions(): options for how to perform the checkout. See CheckoutOptions for more information.\n\nanns may refer to remote or local branch heads. Return true if the merge is successful, otherwise return false (for instance, if no merge is possible because the branches have no common ancestor).\n\nExamples\n\nupst_ann_1 = LibGit2.GitAnnotated(repo, \"branch/a\")\n\n# merge the branch in, fastforward\nLibGit2.merge!(repo, [upst_ann_1], true)\n\n# merge conflicts!\nupst_ann_2 = LibGit2.GitAnnotated(repo, \"branch/b\")\n# merge the branch in, try to fastforward\nLibGit2.merge!(repo, [upst_ann_2], true) # will return false\nLibGit2.merge!(repo, [upst_ann_2], false) # will return true\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LibGit2.html#LibGit2.ffmerge!","page":"LibGit2","title":"LibGit2.ffmerge!","text":"ffmerge!(repo::GitRepo, ann::GitAnnotated)\n\nFastforward merge changes into current HEAD. This is only possible if the commit referred to by ann is descended from the current HEAD (e.g. if pulling changes from a remote branch which is simply ahead of the local branch tip).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.fullname","page":"LibGit2","title":"LibGit2.fullname","text":"LibGit2.fullname(ref::GitReference)\n\nReturn the name of the reference pointed to by the symbolic reference ref. If ref is not a symbolic reference, return an empty string.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.features","page":"LibGit2","title":"LibGit2.features","text":"features()\n\nReturn a list of git features the current version of libgit2 supports, such as threading or using HTTPS or SSH.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.filename","page":"LibGit2","title":"LibGit2.filename","text":"filename(te::GitTreeEntry)\n\nReturn the filename of the object on disk to which te refers.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.filemode","page":"LibGit2","title":"LibGit2.filemode","text":"filemode(te::GitTreeEntry) -> Cint\n\nReturn the UNIX filemode of the object on disk to which te refers as an integer.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.gitdir","page":"LibGit2","title":"LibGit2.gitdir","text":"LibGit2.gitdir(repo::GitRepo)\n\nReturn the location of the \"git\" files of repo:\n\nfor normal repositories, this is the location of the .git folder.\nfor bare repositories, this is the location of the repository itself.\n\nSee also workdir, path.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.git_url","page":"LibGit2","title":"LibGit2.git_url","text":"LibGit2.git_url(; kwargs...) -> String\n\nCreate a string based upon the URL components provided. When the scheme keyword is not provided the URL produced will use the alternative scp-like syntax.\n\nKeywords\n\nscheme::AbstractString=\"\": the URL scheme which identifies the protocol to be used. For HTTP use \"http\", SSH use \"ssh\", etc. When scheme is not provided the output format will be \"ssh\" but using the scp-like syntax.\nusername::AbstractString=\"\": the username to use in the output if provided.\npassword::AbstractString=\"\": the password to use in the output if provided.\nhost::AbstractString=\"\": the hostname to use in the output. A hostname is required to be specified.\nport::Union{AbstractString,Integer}=\"\": the port number to use in the output if provided. Cannot be specified when using the scp-like syntax.\npath::AbstractString=\"\": the path to use in the output if provided.\n\nwarning: Warning\nAvoid using passwords in URLs. Unlike the credential objects, Julia is not able to securely zero or destroy the sensitive data after use and the password may remain in memory; possibly to be exposed by an uninitialized memory.\n\nExamples\n\njulia> LibGit2.git_url(username=\"git\", host=\"github.com\", path=\"JuliaLang/julia.git\")\n\"git@github.com:JuliaLang/julia.git\"\n\njulia> LibGit2.git_url(scheme=\"https\", host=\"github.com\", path=\"/JuliaLang/julia.git\")\n\"https://github.com/JuliaLang/julia.git\"\n\njulia> LibGit2.git_url(scheme=\"ssh\", username=\"git\", host=\"github.com\", port=2222, path=\"JuliaLang/julia.git\")\n\"ssh://git@github.com:2222/JuliaLang/julia.git\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.@githash_str","page":"LibGit2","title":"LibGit2.@githash_str","text":"@githash_str -> AbstractGitHash\n\nConstruct a git hash object from the given string, returning a GitShortHash if the string is shorter than 40 hexadecimal digits, otherwise a GitHash.\n\nExamples\n\njulia> LibGit2.githash\"d114feb74ce633\"\nGitShortHash(\"d114feb74ce633\")\n\njulia> LibGit2.githash\"d114feb74ce63307afe878a5228ad014e0289a85\"\nGitHash(\"d114feb74ce63307afe878a5228ad014e0289a85\")\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/LibGit2.html#LibGit2.head","page":"LibGit2","title":"LibGit2.head","text":"LibGit2.head(repo::GitRepo) -> GitReference\n\nReturn a GitReference to the current HEAD of repo.\n\n\n\n\n\nhead(pkg::AbstractString) -> String\n\nReturn current HEAD GitHash of the pkg repo as a string.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.head!","page":"LibGit2","title":"LibGit2.head!","text":"LibGit2.head!(repo::GitRepo, ref::GitReference) -> GitReference\n\nSet the HEAD of repo to the object pointed to by ref.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.head_oid","page":"LibGit2","title":"LibGit2.head_oid","text":"LibGit2.head_oid(repo::GitRepo) -> GitHash\n\nLookup the object id of the current HEAD of git repository repo.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.headname","page":"LibGit2","title":"LibGit2.headname","text":"LibGit2.headname(repo::GitRepo)\n\nLookup the name of the current HEAD of git repository repo. If repo is currently detached, return the name of the HEAD it's detached from.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.init","page":"LibGit2","title":"LibGit2.init","text":"LibGit2.init(path::AbstractString, bare::Bool=false) -> GitRepo\n\nOpen a new git repository at path. If bare is false, the working tree will be created in path/.git. If bare is true, no working directory will be created.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.is_ancestor_of","page":"LibGit2","title":"LibGit2.is_ancestor_of","text":"is_ancestor_of(a::AbstractString, b::AbstractString, repo::GitRepo) -> Bool\n\nReturn true if a, a GitHash in string form, is an ancestor of b, a GitHash in string form.\n\nExamples\n\njulia> repo = LibGit2.GitRepo(repo_path);\n\njulia> LibGit2.add!(repo, test_file1);\n\njulia> commit_oid1 = LibGit2.commit(repo, \"commit1\");\n\njulia> LibGit2.add!(repo, test_file2);\n\njulia> commit_oid2 = LibGit2.commit(repo, \"commit2\");\n\njulia> LibGit2.is_ancestor_of(string(commit_oid1), string(commit_oid2), repo)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.isbinary","page":"LibGit2","title":"LibGit2.isbinary","text":"isbinary(blob::GitBlob) -> Bool\n\nUse a heuristic to guess if a file is binary: searching for NULL bytes and looking for a reasonable ratio of printable to non-printable characters among the first 8000 bytes.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.iscommit","page":"LibGit2","title":"LibGit2.iscommit","text":"iscommit(id::AbstractString, repo::GitRepo) -> Bool\n\nCheck if commit id (which is a GitHash in string form) is in the repository.\n\nExamples\n\njulia> repo = LibGit2.GitRepo(repo_path);\n\njulia> LibGit2.add!(repo, test_file);\n\njulia> commit_oid = LibGit2.commit(repo, \"add test_file\");\n\njulia> LibGit2.iscommit(string(commit_oid), repo)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.isdiff","page":"LibGit2","title":"LibGit2.isdiff","text":"LibGit2.isdiff(repo::GitRepo, treeish::AbstractString, pathspecs::AbstractString=\"\"; cached::Bool=false)\n\nChecks if there are any differences between the tree specified by treeish and the tracked files in the working tree (if cached=false) or the index (if cached=true). pathspecs are the specifications for options for the diff.\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nLibGit2.isdiff(repo, \"HEAD\") # should be false\nopen(joinpath(repo_path, new_file), \"a\") do f\n    println(f, \"here's my cool new file\")\nend\nLibGit2.isdiff(repo, \"HEAD\") # now true\n\nEquivalent to git diff-index <treeish> [-- <pathspecs>].\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.isdirty","page":"LibGit2","title":"LibGit2.isdirty","text":"LibGit2.isdirty(repo::GitRepo, pathspecs::AbstractString=\"\"; cached::Bool=false) -> Bool\n\nCheck if there have been any changes to tracked files in the working tree (if cached=false) or the index (if cached=true). pathspecs are the specifications for options for the diff.\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nLibGit2.isdirty(repo) # should be false\nopen(joinpath(repo_path, new_file), \"a\") do f\n    println(f, \"here's my cool new file\")\nend\nLibGit2.isdirty(repo) # now true\nLibGit2.isdirty(repo, new_file) # now true\n\nEquivalent to git diff-index HEAD [-- <pathspecs>].\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.isorphan","page":"LibGit2","title":"LibGit2.isorphan","text":"LibGit2.isorphan(repo::GitRepo)\n\nCheck if the current branch is an \"orphan\" branch, i.e. has no commits. The first commit to this branch will have no parents.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.isset","page":"LibGit2","title":"LibGit2.isset","text":"isset(val::Integer, flag::Integer)\n\nTest whether the bits of val indexed by flag are set (1) or unset (0).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.iszero","page":"LibGit2","title":"LibGit2.iszero","text":"iszero(id::GitHash) -> Bool\n\nDetermine whether all hexadecimal digits of the given GitHash are zero.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.lookup_branch","page":"LibGit2","title":"LibGit2.lookup_branch","text":"lookup_branch(repo::GitRepo, branch_name::AbstractString, remote::Bool=false) -> Union{GitReference, Nothing}\n\nDetermine if the branch specified by branch_name exists in the repository repo. If remote is true, repo is assumed to be a remote git repository. Otherwise, it is part of the local filesystem.\n\nReturn either a GitReference to the requested branch if it exists, or nothing if not.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.map","page":"LibGit2","title":"LibGit2.map","text":"LibGit2.map(f::Function, walker::GitRevWalker; oid::GitHash=GitHash(), range::AbstractString=\"\", by::Cint=Consts.SORT_NONE, rev::Bool=false)\n\nUsing the GitRevWalker walker to \"walk\" over every commit in the repository's history, apply f to each commit in the walk. The keyword arguments are:     * oid: The GitHash of the commit to begin the walk from. The default is to use       push_head! and therefore the HEAD commit and all its ancestors.     * range: A range of GitHashs in the format oid1..oid2. f will be       applied to all commits between the two.     * by: The sorting method. The default is not to sort. Other options are to sort by       topology (LibGit2.Consts.SORT_TOPOLOGICAL), to sort forwards in time       (LibGit2.Consts.SORT_TIME, most ancient first) or to sort backwards in time       (LibGit2.Consts.SORT_REVERSE, most recent first).     * rev: Whether to reverse the sorted order (for instance, if topological sorting is used).\n\nExamples\n\noids = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker\n    LibGit2.map((oid, repo)->string(oid), walker, by=LibGit2.Consts.SORT_TIME)\nend\n\nHere, map visits each commit using the GitRevWalker and finds its GitHash.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.mirror_callback","page":"LibGit2","title":"LibGit2.mirror_callback","text":"Mirror callback function\n\nFunction sets +refs/*:refs/* refspecs and mirror flag for remote reference.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.mirror_cb","page":"LibGit2","title":"LibGit2.mirror_cb","text":"C function pointer for mirror_callback\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.message","page":"LibGit2","title":"LibGit2.message","text":"message(c::GitCommit, raw::Bool=false)\n\nReturn the commit message describing the changes made in commit c. If raw is false, return a slightly \"cleaned up\" message (which has any leading newlines removed). If raw is true, the message is not stripped of any such newlines.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.merge_analysis","page":"LibGit2","title":"LibGit2.merge_analysis","text":"merge_analysis(repo::GitRepo, anns::Vector{GitAnnotated}) -> analysis, preference\n\nRun analysis on the branches pointed to by the annotated branch tips anns and determine under what circumstances they can be merged. For instance, if anns[1] is simply an ancestor of ann[2], then merge_analysis will report that a fast-forward merge is possible.\n\nReturn two outputs, analysis and preference. analysis has several possible values:     * MERGE_ANALYSIS_NONE: it is not possible to merge the elements of anns.     * MERGE_ANALYSIS_NORMAL: a regular merge, when HEAD and the commits that the       user wishes to merge have all diverged from a common ancestor. In this case the       changes have to be resolved and conflicts may occur.     * MERGE_ANALYSIS_UP_TO_DATE: all the input commits the user wishes to merge can       be reached from HEAD, so no merge needs to be performed.     * MERGE_ANALYSIS_FASTFORWARD: the input commit is a descendant of HEAD and so no       merge needs to be performed - instead, the user can simply checkout the       input commit(s).     * MERGE_ANALYSIS_UNBORN: the HEAD of the repository refers to a commit which does not       exist. It is not possible to merge, but it may be possible to checkout the input       commits. preference also has several possible values:     * MERGE_PREFERENCE_NONE: the user has no preference.     * MERGE_PREFERENCE_NO_FASTFORWARD: do not allow any fast-forward merges.     * MERGE_PREFERENCE_FASTFORWARD_ONLY: allow only fast-forward merges and no       other type (which may introduce conflicts). preference can be controlled through the repository or global git configuration.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.name","page":"LibGit2","title":"LibGit2.name","text":"LibGit2.name(ref::GitReference)\n\nReturn the full name of ref.\n\n\n\n\n\nname(rmt::GitRemote)\n\nGet the name of a remote repository, for instance \"origin\". If the remote is anonymous (see GitRemoteAnon) the name will be an empty string \"\".\n\nExamples\n\njulia> repo_url = \"https://github.com/JuliaLang/Example.jl\";\n\njulia> repo = LibGit2.clone(cache_repo, \"test_directory\");\n\njulia> remote = LibGit2.GitRemote(repo, \"origin\", repo_url);\n\njulia> name(remote)\n\"origin\"\n\n\n\n\n\nLibGit2.name(tag::GitTag)\n\nThe name of tag (e.g. \"v0.5\").\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.need_update","page":"LibGit2","title":"LibGit2.need_update","text":"need_update(repo::GitRepo)\n\nEquivalent to git update-index. Return true if repo needs updating.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.objtype","page":"LibGit2","title":"LibGit2.objtype","text":"objtype(obj_type::Consts.OBJECT)\n\nReturn the type corresponding to the enum value.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.path","page":"LibGit2","title":"LibGit2.path","text":"LibGit2.path(repo::GitRepo)\n\nReturn the base file path of the repository repo.\n\nfor normal repositories, this will typically be the parent directory of the \".git\" directory (note: this may be different than the working directory, see workdir for more details).\nfor bare repositories, this is the location of the \"git\" files.\n\nSee also gitdir, workdir.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.peel","page":"LibGit2","title":"LibGit2.peel","text":"peel([T,] ref::GitReference)\n\nRecursively peel ref until an object of type T is obtained. If no T is provided, then ref will be peeled until an object other than a GitTag is obtained.\n\nA GitTag will be peeled to the object it references.\nA GitCommit will be peeled to a GitTree.\n\nnote: Note\nOnly annotated tags can be peeled to GitTag objects. Lightweight tags (the default) are references under refs/tags/ which point directly to GitCommit objects.\n\n\n\n\n\npeel([T,] obj::GitObject)\n\nRecursively peel obj until an object of type T is obtained. If no T is provided, then obj will be peeled until the type changes.\n\nA GitTag will be peeled to the object it references.\nA GitCommit will be peeled to a GitTree.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.posixpath","page":"LibGit2","title":"LibGit2.posixpath","text":"LibGit2.posixpath(path)\n\nStandardise the path string path to use POSIX separators.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.push","page":"LibGit2","title":"LibGit2.push","text":"push(rmt::GitRemote, refspecs; force::Bool=false, options::PushOptions=PushOptions())\n\nPush to the specified rmt remote git repository, using refspecs to determine which remote branch(es) to push to. The keyword arguments are:\n\nforce: if true, a force-push will occur, disregarding conflicts.\noptions: determines the options for the push, e.g. which proxy headers to use. See PushOptions for more information.\n\nnote: Note\nYou can add information about the push refspecs in two other ways: by setting an option in the repository's GitConfig (with push.default as the key) or by calling add_push!. Otherwise you will need to explicitly specify a push refspec in the call to push for it to have any effect, like so: LibGit2.push(repo, refspecs=[\"refs/heads/master\"]).\n\n\n\n\n\npush(repo::GitRepo; kwargs...)\n\nPushes updates to an upstream of repo.\n\nThe keyword arguments are:\n\nremote::AbstractString=\"origin\": the name of the upstream remote to push to.\nremoteurl::AbstractString=\"\": the URL of remote.\nrefspecs=AbstractString[]: determines properties of the push.\nforce::Bool=false: determines if the push will be a force push,  overwriting the remote branch.\ncredentials=nothing: provides credentials and/or settings when authenticating against  a private remote.\ncallbacks=Callbacks(): user provided callbacks and payloads.\n\nEquivalent to git push [<remoteurl>|<repo>] [<refspecs>].\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.push!-Tuple{LibGit2.GitRevWalker,LibGit2.GitHash}","page":"LibGit2","title":"LibGit2.push!","text":"LibGit2.push!(w::GitRevWalker, cid::GitHash)\n\nStart the GitRevWalker walker at commit cid. This function can be used to apply a function to all commits since a certain year, by passing the first commit of that year as cid and then passing the resulting w to map.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LibGit2.html#LibGit2.push_head!","page":"LibGit2","title":"LibGit2.push_head!","text":"LibGit2.push_head!(w::GitRevWalker)\n\nPush the HEAD commit and its ancestors onto the GitRevWalker w. This ensures that HEAD and all its ancestor commits will be encountered during the walk.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.push_refspecs","page":"LibGit2","title":"LibGit2.push_refspecs","text":"push_refspecs(rmt::GitRemote) -> Vector{String}\n\nGet the push refspecs for the specified rmt. These refspecs contain information about which branch(es) to push to.\n\nExamples\n\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, \"upstream\");\n\njulia> LibGit2.add_push!(repo, remote, \"refs/heads/master\");\n\njulia> close(remote);\n\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, \"upstream\");\n\njulia> LibGit2.push_refspecs(remote)\nString[\"refs/heads/master\"]\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.raw","page":"LibGit2","title":"LibGit2.raw","text":"raw(id::GitHash) -> Vector{UInt8}\n\nObtain the raw bytes of the GitHash as a vector of length 20.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.read_tree!","page":"LibGit2","title":"LibGit2.read_tree!","text":"LibGit2.read_tree!(idx::GitIndex, tree::GitTree)\nLibGit2.read_tree!(idx::GitIndex, treehash::AbstractGitHash)\n\nRead the tree tree (or the tree pointed to by treehash in the repository owned by idx) into the index idx. The current index contents will be replaced.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.rebase!","page":"LibGit2","title":"LibGit2.rebase!","text":"LibGit2.rebase!(repo::GitRepo, upstream::AbstractString=\"\", newbase::AbstractString=\"\")\n\nAttempt an automatic merge rebase of the current branch, from upstream if provided, or otherwise from the upstream tracking branch. newbase is the branch to rebase onto. By default this is upstream.\n\nIf any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a GitError. This is roughly equivalent to the following command line statement:\n\ngit rebase --merge [<upstream>]\nif [ -d \".git/rebase-merge\" ]; then\n    git rebase --abort\nfi\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.ref_list","page":"LibGit2","title":"LibGit2.ref_list","text":"LibGit2.ref_list(repo::GitRepo) -> Vector{String}\n\nGet a list of all reference names in the repo repository.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.reftype","page":"LibGit2","title":"LibGit2.reftype","text":"LibGit2.reftype(ref::GitReference) -> Cint\n\nReturn a Cint corresponding to the type of ref:\n\n0 if the reference is invalid\n1 if the reference is an object id\n2 if the reference is symbolic\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.remotes","page":"LibGit2","title":"LibGit2.remotes","text":"LibGit2.remotes(repo::GitRepo)\n\nReturn a vector of the names of the remotes of repo.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.remove!","page":"LibGit2","title":"LibGit2.remove!","text":"remove!(repo::GitRepo, files::AbstractString...)\nremove!(idx::GitIndex, files::AbstractString...)\n\nRemove all the files with paths specified by files in the index idx (or the index of the repo).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.reset","page":"LibGit2","title":"LibGit2.reset","text":"reset(val::Integer, flag::Integer)\n\nUnset the bits of val indexed by flag, returning them to 0.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.reset!","page":"LibGit2","title":"LibGit2.reset!","text":"reset!(payload, [config]) -> CredentialPayload\n\nReset the payload state back to the initial values so that it can be used again within the credential callback. If a config is provided the configuration will also be updated.\n\n\n\n\n\nUpdates some entries, determined by the pathspecs, in the index from the target commit tree.\n\n\n\n\n\nSets the current head to the specified commit oid and optionally resets the index and working tree to match.\n\n\n\n\n\ngit reset [<committish>] [–] <pathspecs>... \n\n\n\n\n\nreset!(repo::GitRepo, id::GitHash, mode::Cint=Consts.RESET_MIXED)\n\nReset the repository repo to its state at id, using one of three modes set by mode:\n\nConsts.RESET_SOFT - move HEAD to id.\nConsts.RESET_MIXED - default, move HEAD to id and reset the index to id.\nConsts.RESET_HARD - move HEAD to id, reset the index to id, and discard all working changes.\n\nExamples\n\n# fetch changes\nLibGit2.fetch(repo)\nisfile(joinpath(repo_path, our_file)) # will be false\n\n# fastforward merge the changes\nLibGit2.merge!(repo, fastforward=true)\n\n# because there was not any file locally, but there is\n# a file remotely, we need to reset the branch\nhead_oid = LibGit2.head_oid(repo)\nnew_head = LibGit2.reset!(repo, head_oid, LibGit2.Consts.RESET_HARD)\n\nIn this example, the remote which is being fetched from does have a file called our_file in its index, which is why we must reset.\n\nEquivalent to git reset [--soft | --mixed | --hard] <id>.\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nhead_oid = LibGit2.head_oid(repo)\nopen(joinpath(repo_path, \"file1\"), \"w\") do f\n    write(f, \"111\n\")\nend\nLibGit2.add!(repo, \"file1\")\nmode = LibGit2.Consts.RESET_HARD\n# will discard the changes to file1\n# and unstage it\nnew_head = LibGit2.reset!(repo, head_oid, mode)\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.restore","page":"LibGit2","title":"LibGit2.restore","text":"restore(s::State, repo::GitRepo)\n\nReturn a repository repo to a previous State s, for example the HEAD of a branch before a merge attempt. s can be generated using the snapshot function.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.revcount","page":"LibGit2","title":"LibGit2.revcount","text":"LibGit2.revcount(repo::GitRepo, commit1::AbstractString, commit2::AbstractString)\n\nList the number of revisions between commit1 and commit2 (committish OIDs in string form). Since commit1 and commit2 may be on different branches, revcount performs a \"left-right\" revision list (and count), returning a tuple of Ints - the number of left and right commits, respectively. A left (or right) commit refers to which side of a symmetric difference in a tree the commit is reachable from.\n\nEquivalent to git rev-list --left-right --count <commit1> <commit2>.\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nrepo_file = open(joinpath(repo_path, test_file), \"a\")\nprintln(repo_file, \"hello world\")\nflush(repo_file)\nLibGit2.add!(repo, test_file)\ncommit_oid1 = LibGit2.commit(repo, \"commit 1\")\nprintln(repo_file, \"hello world again\")\nflush(repo_file)\nLibGit2.add!(repo, test_file)\ncommit_oid2 = LibGit2.commit(repo, \"commit 2\")\nLibGit2.revcount(repo, string(commit_oid1), string(commit_oid2))\n\nThis will return (-1, 0).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.set_remote_url","page":"LibGit2","title":"LibGit2.set_remote_url","text":"set_remote_url(repo::GitRepo, remote_name, url)\nset_remote_url(repo::String, remote_name, url)\n\nSet both the fetch and push url for remote_name for the GitRepo or the git repository located at path. Typically git repos use \"origin\" as the remote name.\n\nExamples\n\nrepo_path = joinpath(tempdir(), \"Example\")\nrepo = LibGit2.init(repo_path)\nLibGit2.set_remote_url(repo, \"upstream\", \"https://github.com/JuliaLang/Example.jl\")\nLibGit2.set_remote_url(repo_path, \"upstream2\", \"https://github.com/JuliaLang/Example2.jl\")\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.shortname","page":"LibGit2","title":"LibGit2.shortname","text":"LibGit2.shortname(ref::GitReference)\n\nReturn a shortened version of the name of ref that's \"human-readable\".\n\njulia> repo = LibGit2.GitRepo(path_to_repo);\n\njulia> branch_ref = LibGit2.head(repo);\n\njulia> LibGit2.name(branch_ref)\n\"refs/heads/master\"\n\njulia> LibGit2.shortname(branch_ref)\n\"master\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.snapshot","page":"LibGit2","title":"LibGit2.snapshot","text":"snapshot(repo::GitRepo) -> State\n\nTake a snapshot of the current state of the repository repo, storing the current HEAD, index, and any uncommitted work. The output State can be used later during a call to restore to return the repository to the snapshotted state.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.split_cfg_entry","page":"LibGit2","title":"LibGit2.split_cfg_entry","text":"LibGit2.split_cfg_entry(ce::LibGit2.ConfigEntry) -> Tuple{String,String,String,String}\n\nBreak the ConfigEntry up to the following pieces: section, subsection, name, and value.\n\nExamples\n\nGiven the git configuration file containing:\n\n[credential \"https://example.com\"]\n    username = me\n\nThe ConfigEntry would look like the following:\n\njulia> entry\nConfigEntry(\"credential.https://example.com.username\", \"me\")\n\njulia> LibGit2.split_cfg_entry(entry)\n(\"credential\", \"https://example.com\", \"username\", \"me\")\n\nRefer to the git config syntax documentation for more details.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.status","page":"LibGit2","title":"LibGit2.status","text":"LibGit2.status(repo::GitRepo, path::String) -> Union{Cuint, Cvoid}\n\nLookup the status of the file at path in the git repository repo. For instance, this can be used to check if the file at path has been modified and needs to be staged and committed.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.stage","page":"LibGit2","title":"LibGit2.stage","text":"stage(ie::IndexEntry) -> Cint\n\nGet the stage number of ie. The stage number 0 represents the current state of the working tree, but other numbers can be used in the case of a merge conflict. In such a case, the various stage numbers on an IndexEntry describe which side(s) of the conflict the current state of the file belongs to. Stage 0 is the state before the attempted merge, stage 1 is the changes which have been made locally, stages 2 and larger are for changes from other branches (for instance, in the case of a multi-branch \"octopus\" merge, stages 2, 3, and 4 might be used).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.tag_create","page":"LibGit2","title":"LibGit2.tag_create","text":"LibGit2.tag_create(repo::GitRepo, tag::AbstractString, commit; kwargs...)\n\nCreate a new git tag tag (e.g. \"v0.5\") in the repository repo, at the commit commit.\n\nThe keyword arguments are:\n\nmsg::AbstractString=\"\": the message for the tag.\nforce::Bool=false: if true, existing references will be overwritten.\nsig::Signature=Signature(repo): the tagger's signature.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.tag_delete","page":"LibGit2","title":"LibGit2.tag_delete","text":"LibGit2.tag_delete(repo::GitRepo, tag::AbstractString)\n\nRemove the git tag tag from the repository repo.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.tag_list","page":"LibGit2","title":"LibGit2.tag_list","text":"LibGit2.tag_list(repo::GitRepo) -> Vector{String}\n\nGet a list of all tags in the git repository repo.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.target","page":"LibGit2","title":"LibGit2.target","text":"LibGit2.target(tag::GitTag)\n\nThe GitHash of the target object of tag.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.toggle","page":"LibGit2","title":"LibGit2.toggle","text":"toggle(val::Integer, flag::Integer)\n\nFlip the bits of val indexed by flag, so that if a bit is 0 it will be 1 after the toggle, and vice-versa.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.transact","page":"LibGit2","title":"LibGit2.transact","text":"transact(f::Function, repo::GitRepo)\n\nApply function f to the git repository repo, taking a snapshot before applying f. If an error occurs within f, repo will be returned to its snapshot state using restore. The error which occurred will be rethrown, but the state of repo will not be corrupted.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.treewalk","page":"LibGit2","title":"LibGit2.treewalk","text":"treewalk(f, tree::GitTree, post::Bool=false)\n\nTraverse the entries in tree and its subtrees in post or pre order. Preorder means beginning at the root and then traversing the leftmost subtree (and recursively on down through that subtree's leftmost subtrees) and moving right through the subtrees. Postorder means beginning at the bottom of the leftmost subtree, traversing upwards through it, then traversing the next right subtree (again beginning at the bottom) and finally visiting the tree root last of all.\n\nThe function parameter f should have following signature:\n\n(String, GitTreeEntry) -> Cint\n\nA negative value returned from f stops the tree walk. A positive value means that the entry will be skipped if post is false.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.upstream","page":"LibGit2","title":"LibGit2.upstream","text":"upstream(ref::GitReference) -> Union{GitReference, Nothing}\n\nDetermine if the branch containing ref has a specified upstream branch.\n\nReturn either a GitReference to the upstream branch if it exists, or nothing if the requested branch does not have an upstream counterpart.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.update!","page":"LibGit2","title":"LibGit2.update!","text":"update!(repo::GitRepo, files::AbstractString...)\nupdate!(idx::GitIndex, files::AbstractString...)\n\nUpdate all the files with paths specified by files in the index idx (or the index of the repo). Match the state of each file in the index with the current state on disk, removing it if it has been removed on disk, or updating its entry in the object database.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.url","page":"LibGit2","title":"LibGit2.url","text":"url(rmt::GitRemote)\n\nGet the fetch URL of a remote git repository.\n\nExamples\n\njulia> repo_url = \"https://github.com/JuliaLang/Example.jl\";\n\njulia> repo = LibGit2.init(mktempdir());\n\njulia> remote = LibGit2.GitRemote(repo, \"origin\", repo_url);\n\njulia> LibGit2.url(remote)\n\"https://github.com/JuliaLang/Example.jl\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.version","page":"LibGit2","title":"LibGit2.version","text":"version() -> VersionNumber\n\nReturn the version of libgit2 in use, as a VersionNumber.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.with","page":"LibGit2","title":"LibGit2.with","text":"with(f::Function, obj)\n\nResource management helper function. Applies f to obj, making sure to call close on obj after f successfully returns or throws an error. Ensures that allocated git resources are finalized as soon as they are no longer needed.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.with_warn","page":"LibGit2","title":"LibGit2.with_warn","text":"with_warn(f::Function, ::Type{T}, args...)\n\nResource management helper function. Apply f to args, first constructing an instance of type T from args. Makes sure to call close on the resulting object after f successfully returns or throws an error. Ensures that allocated git resources are finalized as soon as they are no longer needed. If an error is thrown by f, a warning is shown containing the error.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.workdir","page":"LibGit2","title":"LibGit2.workdir","text":"LibGit2.workdir(repo::GitRepo)\n\nReturn the location of the working directory of repo. This will throw an error for bare repositories.\n\nnote: Note\nThis will typically be the parent directory of gitdir(repo), but can be different in some cases: e.g. if either the core.worktree configuration variable or the GIT_WORK_TREE environment variable is set.\n\nSee also gitdir, path.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.GitObject-Tuple{LibGit2.GitTreeEntry}","page":"LibGit2","title":"LibGit2.GitObject","text":"(::Type{T})(te::GitTreeEntry) where T<:GitObject\n\nGet the git object to which te refers and return it as its actual type (the type entrytype would show), for instance a GitBlob or GitTag.\n\nExamples\n\ntree = LibGit2.GitTree(repo, \"HEAD^{tree}\")\ntree_entry = tree[1]\nblob = LibGit2.GitBlob(tree_entry)\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LibGit2.html#LibGit2.UserPasswordCredential","page":"LibGit2","title":"LibGit2.UserPasswordCredential","text":"Credential that support only user and password parameters\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.SSHCredential","page":"LibGit2","title":"LibGit2.SSHCredential","text":"SSH credential type\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.isfilled","page":"LibGit2","title":"LibGit2.isfilled","text":"isfilled(cred::AbstractCredential) -> Bool\n\nVerifies that a credential is ready for use in authentication.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.CachedCredentials","page":"LibGit2","title":"LibGit2.CachedCredentials","text":"Caches credential information for re-use\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.CredentialPayload","page":"LibGit2","title":"LibGit2.CredentialPayload","text":"LibGit2.CredentialPayload\n\nRetains the state between multiple calls to the credential callback for the same URL. A CredentialPayload instance is expected to be reset! whenever it will be used with a different URL.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LibGit2.html#LibGit2.approve","page":"LibGit2","title":"LibGit2.approve","text":"approve(payload::CredentialPayload; shred::Bool=true) -> Nothing\n\nStore the payload credential for re-use in a future authentication. Should only be called when authentication was successful.\n\nThe shred keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to false during testing.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#LibGit2.reject","page":"LibGit2","title":"LibGit2.reject","text":"reject(payload::CredentialPayload; shred::Bool=true) -> Nothing\n\nDiscard the payload credential from begin re-used in future authentication. Should only be called when authentication was unsuccessful.\n\nThe shred keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to false during testing.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LibGit2.html#","page":"LibGit2","title":"LibGit2","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/Libdl.html#Dynamic-Linker-1","page":"Dynamic Linker","title":"Dynamic Linker","text":"","category":"section"},{"location":"stdlib/Libdl.html#","page":"Dynamic Linker","title":"Dynamic Linker","text":"Libdl.dlopen\nLibdl.dlopen_e\nLibdl.RTLD_NOW\nLibdl.dlsym\nLibdl.dlsym_e\nLibdl.dlclose\nLibdl.dlext\nLibdl.find_library\nLibdl.DL_LOAD_PATH","category":"page"},{"location":"stdlib/Libdl.html#Libdl.dlopen","page":"Dynamic Linker","title":"Libdl.dlopen","text":"dlopen(libfile::AbstractString [, flags::Integer]; throw_error:Bool = true)\n\nLoad a shared library, returning an opaque handle.\n\nThe extension given by the constant dlext (.so, .dll, or .dylib) can be omitted from the libfile string, as it is automatically appended if needed.   If libfile is not an absolute path name, then the paths in the array DL_LOAD_PATH are searched for libfile, followed by the system load path.\n\nThe optional flags argument is a bitwise-or of zero or more of RTLD_LOCAL, RTLD_GLOBAL, RTLD_LAZY, RTLD_NOW, RTLD_NODELETE, RTLD_NOLOAD, RTLD_DEEPBIND, and RTLD_FIRST. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default dlopen flags are RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL while on other platforms the defaults are RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.\n\nIf the library cannot be found, this method throws an error, unless the keyword argument throw_error is set to false, in which case this method returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Libdl.html#Libdl.dlopen_e","page":"Dynamic Linker","title":"Libdl.dlopen_e","text":"dlopen_e(libfile::AbstractString [, flags::Integer])\n\nSimilar to dlopen, except returns C_NULL instead of raising errors. This method is now deprecated in favor of dlopen(libfile::AbstractString [, flags::Integer]; throw_error=false).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Libdl.html#Libdl.RTLD_NOW","page":"Dynamic Linker","title":"Libdl.RTLD_NOW","text":"RTLD_DEEPBIND\nRTLD_FIRST\nRTLD_GLOBAL\nRTLD_LAZY\nRTLD_LOCAL\nRTLD_NODELETE\nRTLD_NOLOAD\nRTLD_NOW\n\nEnum constant for dlopen. See your platform man page for details, if applicable.\n\n\n\n\n\n","category":"constant"},{"location":"stdlib/Libdl.html#Libdl.dlsym","page":"Dynamic Linker","title":"Libdl.dlsym","text":"dlsym(handle, sym)\n\nLook up a symbol from a shared library handle, return callable function pointer on success.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Libdl.html#Libdl.dlsym_e","page":"Dynamic Linker","title":"Libdl.dlsym_e","text":"dlsym_e(handle, sym)\n\nLook up a symbol from a shared library handle, silently return C_NULL on lookup failure. This method is now deprecated in favor of dlsym(handle, sym; throw_error=false).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Libdl.html#Libdl.dlclose","page":"Dynamic Linker","title":"Libdl.dlclose","text":"dlclose(handle)\n\nClose shared library referenced by handle.\n\n\n\n\n\ndlclose(::Nothing)\n\nFor the very common pattern usage pattern of\n\ntry\n    hdl = dlopen(library_name)\n    ... do something\nfinally\n    dlclose(hdl)\nend\n\nWe define a dlclose() method that accepts a parameter of type Nothing, so that user code does not have to change its behavior for the case that library_name was not found.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Libdl.html#Libdl.dlext","page":"Dynamic Linker","title":"Libdl.dlext","text":"dlext\n\nFile extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\n\n\n\n\n","category":"constant"},{"location":"stdlib/Libdl.html#Libdl.find_library","page":"Dynamic Linker","title":"Libdl.find_library","text":"find_library(names, locations)\n\nSearches for the first library in names in the paths in the locations list, DL_LOAD_PATH, or system library paths (in that order) which can successfully be dlopen'd. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a global const and used as the library name in future ccall's. On failure, it returns the empty string.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Libdl.html#Base.DL_LOAD_PATH","page":"Dynamic Linker","title":"Base.DL_LOAD_PATH","text":"DL_LOAD_PATH\n\nWhen calling dlopen, the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.\n\n\n\n\n\n","category":"constant"},{"location":"stdlib/LinearAlgebra.html#Linear-Algebra-1","page":"Linear Algebra","title":"Linear Algebra","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"DocTestSetup = :(using LinearAlgebra)","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations which can be loaded with using LinearAlgebra. Basic operations, such as tr, det, and inv are all supported:","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"julia> A = [1 2 3; 4 1 6; 7 8 1]\n3×3 Array{Int64,2}:\n 1  2  3\n 4  1  6\n 7  8  1\n\njulia> tr(A)\n3\n\njulia> det(A)\n104.0\n\njulia> inv(A)\n3×3 Array{Float64,2}:\n -0.451923   0.211538    0.0865385\n  0.365385  -0.192308    0.0576923\n  0.240385   0.0576923  -0.0673077","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"As well as other useful operations, such as finding eigenvalues or eigenvectors:","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"julia> A = [-4. -17.; 2. 2.]\n2×2 Array{Float64,2}:\n -4.0  -17.0\n  2.0    2.0\n\njulia> eigvals(A)\n2-element Array{Complex{Float64},1}:\n -1.0 - 5.0im\n -1.0 + 5.0im\n\njulia> eigvecs(A)\n2×2 Array{Complex{Float64},2}:\n  0.945905-0.0im        0.945905+0.0im\n -0.166924+0.278207im  -0.166924-0.278207im","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"In addition, Julia provides many factorizations which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on factorize  for more information. As an example:","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"julia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]\n3×3 Array{Float64,2}:\n   1.5   2.0  -4.0\n   3.0  -1.0  -6.0\n -10.0   2.3   4.0\n\njulia> factorize(A)\nLU{Float64,Array{Float64,2}}\nL factor:\n3×3 Array{Float64,2}:\n  1.0    0.0       0.0\n -0.15   1.0       0.0\n -0.3   -0.132196  1.0\nU factor:\n3×3 Array{Float64,2}:\n -10.0  2.3     4.0\n   0.0  2.345  -3.4\n   0.0  0.0    -5.24947","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Since A is not Hermitian, symmetric, triangular, tridiagonal, or bidiagonal, an LU factorization may be the best we can do. Compare with:","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\n3×3 Array{Float64,2}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\njulia> factorize(B)\nBunchKaufman{Float64,Array{Float64,2}}\nD factor:\n3×3 Tridiagonal{Float64,Array{Float64,1}}:\n -1.64286   0.0   ⋅\n  0.0      -2.8  0.0\n   ⋅        0.0  5.0\nU factor:\n3×3 UnitUpperTriangular{Float64,Array{Float64,2}}:\n 1.0  0.142857  -0.8\n  ⋅   1.0       -0.6\n  ⋅    ⋅         1.0\npermutation:\n3-element Array{Int64,1}:\n 1\n 2\n 3","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Here, Julia was able to detect that B is in fact symmetric, and used a more appropriate factorization.  Often it's possible to write more efficient code for a matrix that is known to have certain properties e.g.  it is symmetric, or tridiagonal. Julia provides some special types so that you can \"tag\" matrices as having these properties. For instance:","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\n3×3 Array{Float64,2}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\njulia> sB = Symmetric(B)\n3×3 Symmetric{Float64,Array{Float64,2}}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"sB has been tagged as a matrix that's (real) symmetric, so for later operations we might perform on it, such as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing half of it. For example:","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\n3×3 Array{Float64,2}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\njulia> sB = Symmetric(B)\n3×3 Symmetric{Float64,Array{Float64,2}}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\njulia> x = [1; 2; 3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> sB\\x\n3-element Array{Float64,1}:\n -1.7391304347826084\n -1.1086956521739126\n -1.4565217391304346","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"The \\ operation here performs the linear solution. The left-division operator is pretty powerful and it's easy to write compact, readable code that is flexible enough to solve all sorts of systems of linear equations.","category":"page"},{"location":"stdlib/LinearAlgebra.html#特殊行列-1","page":"Linear Algebra","title":"特殊行列","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Matrices with special symmetries and structures arise often in linear algebra and are frequently associated with various matrix factorizations.  Julia features a rich collection of special matrix types, which allow for fast computation with specialized routines that are specially developed for particular matrix types.","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"The following tables summarize the types of special matrices that have been implemented in Julia, as well as whether hooks to various optimized methods for them in LAPACK are available.","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Type Description\nSymmetric Symmetric matrix\nHermitian Hermitian matrix\nUpperTriangular Upper triangular matrix\nUnitUpperTriangular Upper triangular matrix with unit diagonal\nLowerTriangular Lower triangular matrix\nUnitLowerTriangular Lower triangular matrix with unit diagonal\nTridiagonal Tridiagonal matrix\nSymTridiagonal Symmetric tridiagonal matrix\nBidiagonal Upper/lower bidiagonal matrix\nDiagonal Diagonal matrix\nUniformScaling Uniform scaling operator","category":"page"},{"location":"stdlib/LinearAlgebra.html#Elementary-operations-1","page":"Linear Algebra","title":"Elementary operations","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Matrix type + - * \\ Other functions with optimized methods\nSymmetric    MV inv, sqrt, exp\nHermitian    MV inv, sqrt, exp\nUpperTriangular   MV MV inv, det\nUnitUpperTriangular   MV MV inv, det\nLowerTriangular   MV MV inv, det\nUnitLowerTriangular   MV MV inv, det\nSymTridiagonal M M MS MV eigmax, eigmin\nTridiagonal M M MS MV \nBidiagonal M M MS MV \nDiagonal M M MV MV inv, det, logdet, /\nUniformScaling M M MVS MVS /","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Legend:","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Key Description\nM (matrix) An optimized method for matrix-matrix operations is available\nV (vector) An optimized method for matrix-vector operations is available\nS (scalar) An optimized method for matrix-scalar operations is available","category":"page"},{"location":"stdlib/LinearAlgebra.html#Matrix-factorizations-1","page":"Linear Algebra","title":"Matrix factorizations","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Matrix type LAPACK eigen eigvals eigvecs svd svdvals\nSymmetric SY  ARI   \nHermitian HE  ARI   \nUpperTriangular TR A A A  \nUnitUpperTriangular TR A A A  \nLowerTriangular TR A A A  \nUnitLowerTriangular TR A A A  \nSymTridiagonal ST A ARI AV  \nTridiagonal GT     \nBidiagonal BD    A A\nDiagonal DI  A   ","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Legend:","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Key Description Example\nA (all) An optimized method to find all the characteristic values and/or vectors is available e.g. eigvals(M)\nR (range) An optimized method to find the ilth through the ihth characteristic values are available eigvals(M, il, ih)\nI (interval) An optimized method to find the characteristic values in the interval [vl, vh] is available eigvals(M, vl, vh)\nV (vectors) An optimized method to find the characteristic vectors corresponding to the characteristic values x=[x1, x2,...] is available eigvecs(M, x)","category":"page"},{"location":"stdlib/LinearAlgebra.html#The-uniform-scaling-operator-1","page":"Linear Algebra","title":"The uniform scaling operator","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"A UniformScaling operator represents a scalar times the identity operator, λ*I. The identity operator I is defined as a constant and is an instance of UniformScaling. The size of these operators are generic and match the other matrix in the binary operations +, -, * and \\. For A+I and A-I this means that A must be square. Multiplication with the identity operator I is a noop (except for checking that the scaling factor is one)  and therefore almost without overhead.","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"To see the UniformScaling operator in action:","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"julia> U = UniformScaling(2);\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> a + U\n2×2 Array{Int64,2}:\n 3  2\n 3  6\n\njulia> a * U\n2×2 Array{Int64,2}:\n 2  4\n 6  8\n\njulia> [a U]\n2×4 Array{Int64,2}:\n 1  2  2  0\n 3  4  0  2\n\njulia> b = [1 2 3; 4 5 6]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> b - U\nERROR: DimensionMismatch(\"matrix is not square: dimensions are (2, 3)\")\nStacktrace:\n[...]","category":"page"},{"location":"stdlib/LinearAlgebra.html#man-linalg-factorizations-1","page":"Linear Algebra","title":"Matrix factorizations","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Matrix factorizations (a.k.a. matrix decompositions) compute the factorization of a matrix into a product of matrices, and are one of the central concepts in linear algebra.","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the Standard Functions section of the Linear Algebra documentation.","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Type Description\nCholesky Cholesky factorization\nCholeskyPivoted Pivoted Cholesky factorization\nLU LU factorization\nLUTridiagonal LU factorization for Tridiagonal matrices\nQR QR factorization\nQRCompactWY Compact WY form of the QR factorization\nQRPivoted Pivoted QR factorization\nHessenberg Hessenberg decomposition\nEigen Spectral decomposition\nSVD Singular value decomposition\nGeneralizedSVD Generalized SVD","category":"page"},{"location":"stdlib/LinearAlgebra.html#Standard-Functions-1","page":"Linear Algebra","title":"Standard Functions","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Linear algebra functions in Julia are largely implemented by calling functions from LAPACK.  Sparse factorizations call functions from SuiteSparse.","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Base.:*(::AbstractMatrix, ::AbstractMatrix)\nBase.:\\(::AbstractMatrix, ::AbstractVecOrMat)\nLinearAlgebra.SingularException\nLinearAlgebra.PosDefException\nLinearAlgebra.dot\nLinearAlgebra.cross\nLinearAlgebra.factorize\nLinearAlgebra.Diagonal\nLinearAlgebra.Bidiagonal\nLinearAlgebra.SymTridiagonal\nLinearAlgebra.Tridiagonal\nLinearAlgebra.Symmetric\nLinearAlgebra.Hermitian\nLinearAlgebra.LowerTriangular\nLinearAlgebra.UpperTriangular\nLinearAlgebra.UnitLowerTriangular\nLinearAlgebra.UnitUpperTriangular\nLinearAlgebra.UniformScaling\nLinearAlgebra.lu\nLinearAlgebra.lu!\nLinearAlgebra.cholesky\nLinearAlgebra.cholesky!\nLinearAlgebra.lowrankupdate\nLinearAlgebra.lowrankdowndate\nLinearAlgebra.lowrankupdate!\nLinearAlgebra.lowrankdowndate!\nLinearAlgebra.ldlt\nLinearAlgebra.ldlt!\nLinearAlgebra.qr\nLinearAlgebra.qr!\nLinearAlgebra.QR\nLinearAlgebra.QRCompactWY\nLinearAlgebra.QRPivoted\nLinearAlgebra.lq!\nLinearAlgebra.lq\nLinearAlgebra.bunchkaufman\nLinearAlgebra.bunchkaufman!\nLinearAlgebra.eigvals\nLinearAlgebra.eigvals!\nLinearAlgebra.eigmax\nLinearAlgebra.eigmin\nLinearAlgebra.eigvecs\nLinearAlgebra.eigen\nLinearAlgebra.eigen!\nLinearAlgebra.hessenberg\nLinearAlgebra.hessenberg!\nLinearAlgebra.schur!\nLinearAlgebra.schur\nLinearAlgebra.ordschur\nLinearAlgebra.ordschur!\nLinearAlgebra.svd\nLinearAlgebra.svd!\nLinearAlgebra.svdvals\nLinearAlgebra.svdvals!\nLinearAlgebra.Givens\nLinearAlgebra.givens\nLinearAlgebra.triu\nLinearAlgebra.triu!\nLinearAlgebra.tril\nLinearAlgebra.tril!\nLinearAlgebra.diagind\nLinearAlgebra.diag\nLinearAlgebra.diagm\nLinearAlgebra.rank\nLinearAlgebra.norm\nLinearAlgebra.opnorm\nLinearAlgebra.normalize!\nLinearAlgebra.normalize\nLinearAlgebra.cond\nLinearAlgebra.condskeel\nLinearAlgebra.tr\nLinearAlgebra.det\nLinearAlgebra.logdet\nLinearAlgebra.logabsdet\nBase.inv(::AbstractMatrix)\nLinearAlgebra.pinv\nLinearAlgebra.nullspace\nBase.kron\nLinearAlgebra.exp(::StridedMatrix{<:LinearAlgebra.BlasFloat})\nBase.:^(::AbstractMatrix, ::Number)\nBase.:^(::Number, ::AbstractMatrix)\nLinearAlgebra.log(::StridedMatrix)\nLinearAlgebra.sqrt(::StridedMatrix{<:Real})\nLinearAlgebra.cos(::StridedMatrix{<:Real})\nLinearAlgebra.sin(::StridedMatrix{<:Real})\nLinearAlgebra.sincos(::StridedMatrix{<:Real})\nLinearAlgebra.tan(::StridedMatrix{<:Real})\nLinearAlgebra.sec(::StridedMatrix)\nLinearAlgebra.csc(::StridedMatrix)\nLinearAlgebra.cot(::StridedMatrix)\nLinearAlgebra.cosh(::StridedMatrix)\nLinearAlgebra.sinh(::StridedMatrix)\nLinearAlgebra.tanh(::StridedMatrix)\nLinearAlgebra.sech(::StridedMatrix)\nLinearAlgebra.csch(::StridedMatrix)\nLinearAlgebra.coth(::StridedMatrix)\nLinearAlgebra.acos(::StridedMatrix)\nLinearAlgebra.asin(::StridedMatrix)\nLinearAlgebra.atan(::StridedMatrix)\nLinearAlgebra.asec(::StridedMatrix)\nLinearAlgebra.acsc(::StridedMatrix)\nLinearAlgebra.acot(::StridedMatrix)\nLinearAlgebra.acosh(::StridedMatrix)\nLinearAlgebra.asinh(::StridedMatrix)\nLinearAlgebra.atanh(::StridedMatrix)\nLinearAlgebra.asech(::StridedMatrix)\nLinearAlgebra.acsch(::StridedMatrix)\nLinearAlgebra.acoth(::StridedMatrix)\nLinearAlgebra.lyap\nLinearAlgebra.sylvester\nLinearAlgebra.issuccess\nLinearAlgebra.issymmetric\nLinearAlgebra.isposdef\nLinearAlgebra.isposdef!\nLinearAlgebra.istril\nLinearAlgebra.istriu\nLinearAlgebra.isdiag\nLinearAlgebra.ishermitian\nBase.transpose\nLinearAlgebra.transpose!\nLinearAlgebra.Transpose\nBase.adjoint\nLinearAlgebra.adjoint!\nLinearAlgebra.Adjoint\nBase.copy(::Union{Transpose,Adjoint})\nLinearAlgebra.stride1\nLinearAlgebra.checksquare\nLinearAlgebra.peakflops","category":"page"},{"location":"stdlib/LinearAlgebra.html#Base.:*-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}","page":"Linear Algebra","title":"Base.:*","text":"*(A::AbstractMatrix, B::AbstractMatrix)\n\nMatrix multiplication.\n\nExamples\n\njulia> [1 1; 0 1] * [1 0; 1 1]\n2×2 Array{Int64,2}:\n 2  1\n 1  1\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.:\\-Tuple{AbstractArray{T,2} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}","page":"Linear Algebra","title":"Base.:\\","text":"\\(A, B)\n\nMatrix division using a polyalgorithm. For input matrices A and B, the result X is such that A*X == B when A is square. The solver that is used depends upon the structure of A.  If A is upper or lower triangular (or diagonal), no factorization of A is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.\n\nFor rectangular A the result is the minimum-norm least squares solution computed by a pivoted QR factorization of A and a rank estimate of A based on the R factor.\n\nWhen A is sparse, a similar polyalgorithm is used. For indefinite matrices, the LDLt factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.\n\nExamples\n\njulia> A = [1 0; 1 -2]; B = [32; -4];\n\njulia> X = A \\ B\n2-element Array{Float64,1}:\n 32.0\n 18.0\n\njulia> A * X == B\ntrue\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.SingularException","page":"Linear Algebra","title":"LinearAlgebra.SingularException","text":"SingularException\n\nException thrown when the input matrix has one or more zero-valued eigenvalues, and is not invertible. A linear solve involving such a matrix cannot be computed. The info field indicates the location of (one of) the singular value(s).\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.PosDefException","page":"Linear Algebra","title":"LinearAlgebra.PosDefException","text":"PosDefException\n\nException thrown when the input matrix was not positive definite. Some linear algebra functions and factorizations are only applicable to positive definite matrices. The info field indicates the location of (one of) the eigenvalue(s) which is (are) less than/equal to 0.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.dot","page":"Linear Algebra","title":"LinearAlgebra.dot","text":"dot(x, y)\nx ⋅ y\n\nFor any iterable containers x and y (including arrays of any dimension) of numbers (or any element type for which dot is defined), compute the dot product (or inner product or scalar product), i.e. the sum of dot(x[i],y[i]), as if they were vectors.\n\nx ⋅ y (where ⋅ can be typed by tab-completing \\cdot in the REPL) is a synonym for dot(x, y).\n\nExamples\n\njulia> dot(1:5, 2:6)\n70\n\njulia> x = fill(2., (5,5));\n\njulia> y = fill(3., (5,5));\n\njulia> dot(x, y)\n150.0\n\n\n\n\n\ndot(x, y)\nx ⋅ y\n\nCompute the dot product between two vectors. For complex vectors, the first vector is conjugated. When the vectors have equal lengths, calling dot is semantically equivalent to sum(dot(vx,vy) for (vx,vy) in zip(x, y)).\n\nExamples\n\njulia> dot([1; 1], [2; 3])\n5\n\njulia> dot([im; im], [1; 1])\n0 - 2im\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.cross","page":"Linear Algebra","title":"LinearAlgebra.cross","text":"cross(x, y)\n×(x,y)\n\nCompute the cross product of two 3-vectors.\n\nExamples\n\njulia> a = [0;1;0]\n3-element Array{Int64,1}:\n 0\n 1\n 0\n\njulia> b = [0;0;1]\n3-element Array{Int64,1}:\n 0\n 0\n 1\n\njulia> cross(a,b)\n3-element Array{Int64,1}:\n 1\n 0\n 0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.factorize","page":"Linear Algebra","title":"LinearAlgebra.factorize","text":"factorize(A)\n\nCompute a convenient factorization of A, based upon the type of the input matrix. factorize checks A to see if it is symmetric/triangular/etc. if A is passed as a generic matrix. factorize checks every element of A to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: A=factorize(A); x=A\\b; y=A\\C.\n\nProperties of A type of factorization\nPositive-definite Cholesky (see cholesky)\nDense Symmetric/Hermitian Bunch-Kaufman (see bunchkaufman)\nSparse Symmetric/Hermitian LDLt (see ldlt)\nTriangular Triangular\nDiagonal Diagonal\nBidiagonal Bidiagonal\nTridiagonal LU (see lu)\nSymmetric real tridiagonal LDLt (see ldlt)\nGeneral square LU (see lu)\nGeneral non-square QR (see qr)\n\nIf factorize is called on a Hermitian positive-definite matrix, for instance, then factorize will return a Cholesky factorization.\n\nExamples\n\njulia> A = Array(Bidiagonal(fill(1.0, (5, 5)), :U))\n5×5 Array{Float64,2}:\n 1.0  1.0  0.0  0.0  0.0\n 0.0  1.0  1.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0\n 0.0  0.0  0.0  1.0  1.0\n 0.0  0.0  0.0  0.0  1.0\n\njulia> factorize(A) # factorize will check to see that A is already factorized\n5×5 Bidiagonal{Float64,Array{Float64,1}}:\n 1.0  1.0   ⋅    ⋅    ⋅\n  ⋅   1.0  1.0   ⋅    ⋅\n  ⋅    ⋅   1.0  1.0   ⋅\n  ⋅    ⋅    ⋅   1.0  1.0\n  ⋅    ⋅    ⋅    ⋅   1.0\n\nThis returns a 5×5 Bidiagonal{Float64}, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for Bidiagonal types.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.Diagonal","page":"Linear Algebra","title":"LinearAlgebra.Diagonal","text":"Diagonal(A::AbstractMatrix)\n\nConstruct a matrix from the diagonal of A.\n\nExamples\n\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> Diagonal(A)\n3×3 Diagonal{Int64,Array{Int64,1}}:\n 1  ⋅  ⋅\n ⋅  5  ⋅\n ⋅  ⋅  9\n\n\n\n\n\nDiagonal(V::AbstractVector)\n\nConstruct a matrix with V as its diagonal.\n\nExamples\n\njulia> V = [1, 2]\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> Diagonal(V)\n2×2 Diagonal{Int64,Array{Int64,1}}:\n 1  ⋅\n ⋅  2\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.Bidiagonal","page":"Linear Algebra","title":"LinearAlgebra.Bidiagonal","text":"Bidiagonal(dv::V, ev::V, uplo::Symbol) where V <: AbstractVector\n\nConstructs an upper (uplo=:U) or lower (uplo=:L) bidiagonal matrix using the given diagonal (dv) and off-diagonal (ev) vectors. The result is of type Bidiagonal and provides efficient specialized linear solvers, but may be converted into a regular matrix with convert(Array, _) (or Array(_) for short). The length of ev must be one less than the length of dv.\n\nExamples\n\njulia> dv = [1, 2, 3, 4]\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> ev = [7, 8, 9]\n3-element Array{Int64,1}:\n 7\n 8\n 9\n\njulia> Bu = Bidiagonal(dv, ev, :U) # ev is on the first superdiagonal\n4×4 Bidiagonal{Int64,Array{Int64,1}}:\n 1  7  ⋅  ⋅\n ⋅  2  8  ⋅\n ⋅  ⋅  3  9\n ⋅  ⋅  ⋅  4\n\njulia> Bl = Bidiagonal(dv, ev, :L) # ev is on the first subdiagonal\n4×4 Bidiagonal{Int64,Array{Int64,1}}:\n 1  ⋅  ⋅  ⋅\n 7  2  ⋅  ⋅\n ⋅  8  3  ⋅\n ⋅  ⋅  9  4\n\n\n\n\n\nBidiagonal(A, uplo::Symbol)\n\nConstruct a Bidiagonal matrix from the main diagonal of A and its first super- (if uplo=:U) or sub-diagonal (if uplo=:L).\n\nExamples\n\njulia> A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]\n4×4 Array{Int64,2}:\n 1  1  1  1\n 2  2  2  2\n 3  3  3  3\n 4  4  4  4\n\njulia> Bidiagonal(A, :U) # contains the main diagonal and first superdiagonal of A\n4×4 Bidiagonal{Int64,Array{Int64,1}}:\n 1  1  ⋅  ⋅\n ⋅  2  2  ⋅\n ⋅  ⋅  3  3\n ⋅  ⋅  ⋅  4\n\njulia> Bidiagonal(A, :L) # contains the main diagonal and first subdiagonal of A\n4×4 Bidiagonal{Int64,Array{Int64,1}}:\n 1  ⋅  ⋅  ⋅\n 2  2  ⋅  ⋅\n ⋅  3  3  ⋅\n ⋅  ⋅  4  4\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.SymTridiagonal","page":"Linear Algebra","title":"LinearAlgebra.SymTridiagonal","text":"SymTridiagonal(dv::V, ev::V) where V <: AbstractVector\n\nConstruct a symmetric tridiagonal matrix from the diagonal (dv) and first sub/super-diagonal (ev), respectively. The result is of type SymTridiagonal and provides efficient specialized eigensolvers, but may be converted into a regular matrix with convert(Array, _) (or Array(_) for short).\n\nExamples\n\njulia> dv = [1, 2, 3, 4]\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> ev = [7, 8, 9]\n3-element Array{Int64,1}:\n 7\n 8\n 9\n\njulia> SymTridiagonal(dv, ev)\n4×4 SymTridiagonal{Int64,Array{Int64,1}}:\n 1  7  ⋅  ⋅\n 7  2  8  ⋅\n ⋅  8  3  9\n ⋅  ⋅  9  4\n\n\n\n\n\nSymTridiagonal(A::AbstractMatrix)\n\nConstruct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, of the symmetric matrix A.\n\nExamples\n\njulia> A = [1 2 3; 2 4 5; 3 5 6]\n3×3 Array{Int64,2}:\n 1  2  3\n 2  4  5\n 3  5  6\n\njulia> SymTridiagonal(A)\n3×3 SymTridiagonal{Int64,Array{Int64,1}}:\n 1  2  ⋅\n 2  4  5\n ⋅  5  6\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.Tridiagonal","page":"Linear Algebra","title":"LinearAlgebra.Tridiagonal","text":"Tridiagonal(dl::V, d::V, du::V) where V <: AbstractVector\n\nConstruct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively. The result is of type Tridiagonal and provides efficient specialized linear solvers, but may be converted into a regular matrix with convert(Array, _) (or Array(_) for short). The lengths of dl and du must be one less than the length of d.\n\nExamples\n\njulia> dl = [1, 2, 3];\n\njulia> du = [4, 5, 6];\n\njulia> d = [7, 8, 9, 0];\n\njulia> Tridiagonal(dl, d, du)\n4×4 Tridiagonal{Int64,Array{Int64,1}}:\n 7  4  ⋅  ⋅\n 1  8  5  ⋅\n ⋅  2  9  6\n ⋅  ⋅  3  0\n\n\n\n\n\nTridiagonal(A)\n\nConstruct a tridiagonal matrix from the first sub-diagonal, diagonal and first super-diagonal of the matrix A.\n\nExamples\n\njulia> A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]\n4×4 Array{Int64,2}:\n 1  2  3  4\n 1  2  3  4\n 1  2  3  4\n 1  2  3  4\n\njulia> Tridiagonal(A)\n4×4 Tridiagonal{Int64,Array{Int64,1}}:\n 1  2  ⋅  ⋅\n 1  2  3  ⋅\n ⋅  2  3  4\n ⋅  ⋅  3  4\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.Symmetric","page":"Linear Algebra","title":"LinearAlgebra.Symmetric","text":"Symmetric(A, uplo=:U)\n\nConstruct a Symmetric view of the upper (if uplo = :U) or lower (if uplo = :L) triangle of the matrix A.\n\nExamples\n\njulia> A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]\n5×5 Array{Int64,2}:\n 1  0  2  0  3\n 0  4  0  5  0\n 6  0  7  0  8\n 0  9  0  1  0\n 2  0  3  0  4\n\njulia> Supper = Symmetric(A)\n5×5 Symmetric{Int64,Array{Int64,2}}:\n 1  0  2  0  3\n 0  4  0  5  0\n 2  0  7  0  8\n 0  5  0  1  0\n 3  0  8  0  4\n\njulia> Slower = Symmetric(A, :L)\n5×5 Symmetric{Int64,Array{Int64,2}}:\n 1  0  6  0  2\n 0  4  0  9  0\n 6  0  7  0  3\n 0  9  0  1  0\n 2  0  3  0  4\n\nNote that Supper will not be equal to Slower unless A is itself symmetric (e.g. if A == transpose(A)).\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.Hermitian","page":"Linear Algebra","title":"LinearAlgebra.Hermitian","text":"Hermitian(A, uplo=:U)\n\nConstruct a Hermitian view of the upper (if uplo = :U) or lower (if uplo = :L) triangle of the matrix A.\n\nExamples\n\njulia> A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];\n\njulia> Hupper = Hermitian(A)\n5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:\n 1+0im  0+0im  2+2im  0+0im  3-3im\n 0+0im  4+0im  0+0im  5+0im  0+0im\n 2-2im  0+0im  7+0im  0+0im  8+8im\n 0+0im  5+0im  0+0im  1+0im  0+0im\n 3+3im  0+0im  8-8im  0+0im  4+0im\n\njulia> Hlower = Hermitian(A, :L)\n5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:\n 1+0im  0+0im  6+6im  0+0im  2-2im\n 0+0im  4+0im  0+0im  9+0im  0+0im\n 6-6im  0+0im  7+0im  0+0im  3+3im\n 0+0im  9+0im  0+0im  1+0im  0+0im\n 2+2im  0+0im  3-3im  0+0im  4+0im\n\nNote that Hupper will not be equal to Hlower unless A is itself Hermitian (e.g. if A == adjoint(A)).\n\nAll non-real parts of the diagonal will be ignored.\n\nHermitian(fill(complex(1,1), 1, 1)) == fill(1, 1, 1)\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LowerTriangular","page":"Linear Algebra","title":"LinearAlgebra.LowerTriangular","text":"LowerTriangular(A::AbstractMatrix)\n\nConstruct a LowerTriangular view of the matrix A.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\n3×3 Array{Float64,2}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n 7.0  8.0  9.0\n\njulia> LowerTriangular(A)\n3×3 LowerTriangular{Float64,Array{Float64,2}}:\n 1.0   ⋅    ⋅\n 4.0  5.0   ⋅\n 7.0  8.0  9.0\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.UpperTriangular","page":"Linear Algebra","title":"LinearAlgebra.UpperTriangular","text":"UpperTriangular(A::AbstractMatrix)\n\nConstruct an UpperTriangular view of the matrix A.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\n3×3 Array{Float64,2}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n 7.0  8.0  9.0\n\njulia> UpperTriangular(A)\n3×3 UpperTriangular{Float64,Array{Float64,2}}:\n 1.0  2.0  3.0\n  ⋅   5.0  6.0\n  ⋅    ⋅   9.0\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.UnitLowerTriangular","page":"Linear Algebra","title":"LinearAlgebra.UnitLowerTriangular","text":"UnitLowerTriangular(A::AbstractMatrix)\n\nConstruct a UnitLowerTriangular view of the matrix A. Such a view has the oneunit of the eltype of A on its diagonal.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\n3×3 Array{Float64,2}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n 7.0  8.0  9.0\n\njulia> UnitLowerTriangular(A)\n3×3 UnitLowerTriangular{Float64,Array{Float64,2}}:\n 1.0   ⋅    ⋅\n 4.0  1.0   ⋅\n 7.0  8.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.UnitUpperTriangular","page":"Linear Algebra","title":"LinearAlgebra.UnitUpperTriangular","text":"UnitUpperTriangular(A::AbstractMatrix)\n\nConstruct an UnitUpperTriangular view of the matrix A. Such a view has the oneunit of the eltype of A on its diagonal.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\n3×3 Array{Float64,2}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n 7.0  8.0  9.0\n\njulia> UnitUpperTriangular(A)\n3×3 UnitUpperTriangular{Float64,Array{Float64,2}}:\n 1.0  2.0  3.0\n  ⋅   1.0  6.0\n  ⋅    ⋅   1.0\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.UniformScaling","page":"Linear Algebra","title":"LinearAlgebra.UniformScaling","text":"UniformScaling{T<:Number}\n\nGenerically sized uniform scaling operator defined as a scalar times the identity operator, λ*I. See also I.\n\nExamples\n\njulia> J = UniformScaling(2.)\nUniformScaling{Float64}\n2.0*I\n\njulia> A = [1. 2.; 3. 4.]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> J*A\n2×2 Array{Float64,2}:\n 2.0  4.0\n 6.0  8.0\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.lu","page":"Linear Algebra","title":"LinearAlgebra.lu","text":"lu(A, pivot=Val(true); check = true) -> F::LU\n\nCompute the LU factorization of A.\n\nWhen check = true, an error is thrown if the decomposition fails. When check = false, responsibility for checking the decomposition's validity (via issuccess) lies with the user.\n\nIn most cases, if A is a subtype S of AbstractMatrix{T} with an element type T supporting +, -, * and /, the return type is LU{T,S{T}}. If pivoting is chosen (default) the element type should also support abs and <.\n\nThe individual components of the factorization F can be accessed via getproperty:\n\nComponent Description\nF.L L (lower triangular) part of LU\nF.U U (upper triangular) part of LU\nF.p (right) permutation Vector\nF.P (right) permutation Matrix\n\nIterating the factorization produces the components F.L, F.U, and F.p.\n\nThe relationship between F and A is\n\nF.L*F.U == A[F.p, :]\n\nF further supports the following functions:\n\nSupported function LU LU{T,Tridiagonal{T}}\n/ ✓ \n\\ ✓ ✓\ninv ✓ ✓\ndet ✓ ✓\nlogdet ✓ ✓\nlogabsdet ✓ ✓\nsize ✓ ✓\n\nExamples\n\njulia> A = [4 3; 6 3]\n2×2 Array{Int64,2}:\n 4  3\n 6  3\n\njulia> F = lu(A)\nLU{Float64,Array{Float64,2}}\nL factor:\n2×2 Array{Float64,2}:\n 1.0  0.0\n 1.5  1.0\nU factor:\n2×2 Array{Float64,2}:\n 4.0   3.0\n 0.0  -1.5\n\njulia> F.L * F.U == A[F.p, :]\ntrue\n\njulia> l, u, p = lu(A); # destructuring via iteration\n\njulia> l == F.L && u == F.U && p == F.p\ntrue\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.lu!","page":"Linear Algebra","title":"LinearAlgebra.lu!","text":"lu!(A, pivot=Val(true); check = true) -> LU\n\nlu! is the same as lu, but saves space by overwriting the input A, instead of creating a copy. An InexactError exception is thrown if the factorization produces a number not representable by the element type of A, e.g. for integer types.\n\nExamples\n\njulia> A = [4. 3.; 6. 3.]\n2×2 Array{Float64,2}:\n 4.0  3.0\n 6.0  3.0\n\njulia> F = lu!(A)\nLU{Float64,Array{Float64,2}}\nL factor:\n2×2 Array{Float64,2}:\n 1.0       0.0\n 0.666667  1.0\nU factor:\n2×2 Array{Float64,2}:\n 6.0  3.0\n 0.0  1.0\n\njulia> iA = [4 3; 6 3]\n2×2 Array{Int64,2}:\n 4  3\n 6  3\n\njulia> lu!(iA)\nERROR: InexactError: Int64(0.6666666666666666)\nStacktrace:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.cholesky","page":"Linear Algebra","title":"LinearAlgebra.cholesky","text":"cholesky(A, Val(false); check = true) -> Cholesky\n\nCompute the Cholesky factorization of a dense symmetric positive definite matrix A and return a Cholesky factorization. The matrix A can either be a Symmetric or Hermitian StridedMatrix or a perfectly symmetric or Hermitian StridedMatrix. The triangular Cholesky factor can be obtained from the factorization F with: F.L and F.U. The following functions are available for Cholesky objects: size, \\, inv, det, logdet and isposdef.\n\nWhen check = true, an error is thrown if the decomposition fails. When check = false, responsibility for checking the decomposition's validity (via issuccess) lies with the user.\n\nExamples\n\njulia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]\n3×3 Array{Float64,2}:\n   4.0   12.0  -16.0\n  12.0   37.0  -43.0\n -16.0  -43.0   98.0\n\njulia> C = cholesky(A)\nCholesky{Float64,Array{Float64,2}}\nU factor:\n3×3 UpperTriangular{Float64,Array{Float64,2}}:\n 2.0  6.0  -8.0\n  ⋅   1.0   5.0\n  ⋅    ⋅    3.0\n\njulia> C.U\n3×3 UpperTriangular{Float64,Array{Float64,2}}:\n 2.0  6.0  -8.0\n  ⋅   1.0   5.0\n  ⋅    ⋅    3.0\n\njulia> C.L\n3×3 LowerTriangular{Float64,Array{Float64,2}}:\n  2.0   ⋅    ⋅\n  6.0  1.0   ⋅\n -8.0  5.0  3.0\n\njulia> C.L * C.U == A\ntrue\n\n\n\n\n\ncholesky(A, Val(true); tol = 0.0, check = true) -> CholeskyPivoted\n\nCompute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix A and return a CholeskyPivoted factorization. The matrix A can either be a Symmetric or Hermitian StridedMatrix or a perfectly symmetric or Hermitian StridedMatrix. The triangular Cholesky factor can be obtained from the factorization F with: F.L and F.U. The following functions are available for CholeskyPivoted objects: size, \\, inv, det, and rank. The argument tol determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.\n\nWhen check = true, an error is thrown if the decomposition fails. When check = false, responsibility for checking the decomposition's validity (via issuccess) lies with the user.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.cholesky!","page":"Linear Algebra","title":"LinearAlgebra.cholesky!","text":"cholesky!(A, Val(false); check = true) -> Cholesky\n\nThe same as cholesky, but saves space by overwriting the input A, instead of creating a copy. An InexactError exception is thrown if the factorization produces a number not representable by the element type of A, e.g. for integer types.\n\nExamples\n\njulia> A = [1 2; 2 50]\n2×2 Array{Int64,2}:\n 1   2\n 2  50\n\njulia> cholesky!(A)\nERROR: InexactError: Int64(6.782329983125268)\nStacktrace:\n[...]\n\n\n\n\n\ncholesky!(A, Val(true); tol = 0.0, check = true) -> CholeskyPivoted\n\nThe same as cholesky, but saves space by overwriting the input A, instead of creating a copy. An InexactError exception is thrown if the factorization produces a number not representable by the element type of A, e.g. for integer types.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.lowrankupdate","page":"Linear Algebra","title":"LinearAlgebra.lowrankupdate","text":"lowrankupdate(C::Cholesky, v::StridedVector) -> CC::Cholesky\n\nUpdate a Cholesky factorization C with the vector v. If A = C.U'C.U then CC = cholesky(C.U'C.U + v*v') but the computation of CC only uses O(n^2) operations.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.lowrankdowndate","page":"Linear Algebra","title":"LinearAlgebra.lowrankdowndate","text":"lowrankdowndate(C::Cholesky, v::StridedVector) -> CC::Cholesky\n\nDowndate a Cholesky factorization C with the vector v. If A = C.U'C.U then CC = cholesky(C.U'C.U - v*v') but the computation of CC only uses O(n^2) operations.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.lowrankupdate!","page":"Linear Algebra","title":"LinearAlgebra.lowrankupdate!","text":"lowrankupdate!(C::Cholesky, v::StridedVector) -> CC::Cholesky\n\nUpdate a Cholesky factorization C with the vector v. If A = C.U'C.U then CC = cholesky(C.U'C.U + v*v') but the computation of CC only uses O(n^2) operations. The input factorization C is updated in place such that on exit C == CC. The vector v is destroyed during the computation.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.lowrankdowndate!","page":"Linear Algebra","title":"LinearAlgebra.lowrankdowndate!","text":"lowrankdowndate!(C::Cholesky, v::StridedVector) -> CC::Cholesky\n\nDowndate a Cholesky factorization C with the vector v. If A = C.U'C.U then CC = cholesky(C.U'C.U - v*v') but the computation of CC only uses O(n^2) operations. The input factorization C is updated in place such that on exit C == CC. The vector v is destroyed during the computation.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.ldlt","page":"Linear Algebra","title":"LinearAlgebra.ldlt","text":"ldlt(S::SymTridiagonal) -> LDLt\n\nCompute an LDLt factorization of the real symmetric tridiagonal matrix S such that S = L*Diagonal(d)*L' where L is a unit lower triangular matrix and d is a vector. The main use of an LDLt factorization F = ldlt(S) is to solve the linear system of equations Sx = b with F\\b.\n\nExamples\n\njulia> S = SymTridiagonal([3., 4., 5.], [1., 2.])\n3×3 SymTridiagonal{Float64,Array{Float64,1}}:\n 3.0  1.0   ⋅\n 1.0  4.0  2.0\n  ⋅   2.0  5.0\n\njulia> ldltS = ldlt(S);\n\njulia> b = [6., 7., 8.];\n\njulia> ldltS \\ b\n3-element Array{Float64,1}:\n 1.7906976744186047\n 0.627906976744186\n 1.3488372093023255\n\njulia> S \\ b\n3-element Array{Float64,1}:\n 1.7906976744186047\n 0.627906976744186\n 1.3488372093023255\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.ldlt!","page":"Linear Algebra","title":"LinearAlgebra.ldlt!","text":"ldlt!(S::SymTridiagonal) -> LDLt\n\nSame as ldlt, but saves space by overwriting the input S, instead of creating a copy.\n\nExamples\n\njulia> S = SymTridiagonal([3., 4., 5.], [1., 2.])\n3×3 SymTridiagonal{Float64,Array{Float64,1}}:\n 3.0  1.0   ⋅\n 1.0  4.0  2.0\n  ⋅   2.0  5.0\n\njulia> ldltS = ldlt!(S);\n\njulia> ldltS === S\nfalse\n\njulia> S\n3×3 SymTridiagonal{Float64,Array{Float64,1}}:\n 3.0       0.333333   ⋅\n 0.333333  3.66667   0.545455\n  ⋅        0.545455  3.90909\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.qr","page":"Linear Algebra","title":"LinearAlgebra.qr","text":"qr(A, pivot=Val(false)) -> F\n\nCompute the QR factorization of the matrix A: an orthogonal (or unitary if A is complex-valued) matrix Q, and an upper triangular matrix R such that\n\nA = Q R\n\nThe returned object F stores the factorization in a packed format:\n\nif pivot == Val(true) then F is a QRPivoted object,\notherwise if the element type of A is a BLAS type (Float32, Float64, ComplexF32 or ComplexF64), then F is a QRCompactWY object,\notherwise F is a QR object.\n\nThe individual components of the decomposition F can be retrieved via property accessors:\n\nF.Q: the orthogonal/unitary matrix Q\nF.R: the upper triangular matrix R\nF.p: the permutation vector of the pivot (QRPivoted only)\nF.P: the permutation matrix of the pivot (QRPivoted only)\n\nIterating the decomposition produces the components Q, R, and if extant p.\n\nThe following functions are available for the QR objects: inv, size, and \\. When A is rectangular, \\ will return a least squares solution and if the solution is not unique, the one with smallest norm is returned. When A is not full rank, factorization with (column) pivoting is required to obtain a minimum norm solution.\n\nMultiplication with respect to either full/square or non-full/square Q is allowed, i.e. both F.Q*F.R and F.Q*A are supported. A Q matrix can be converted into a regular matrix with Matrix.  This operation returns the \"thin\" Q factor, i.e., if A is m×n with m>=n, then Matrix(F.Q) yields an m×n matrix with orthonormal columns.  To retrieve the \"full\" Q factor, an m×m orthogonal matrix, use F.Q*Matrix(I,m,m).  If m<=n, then Matrix(F.Q) yields an m×m orthogonal matrix.\n\nExamples\n\njulia> A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]\n3×2 Array{Float64,2}:\n 3.0  -6.0\n 4.0  -8.0\n 0.0   1.0\n\njulia> F = qr(A)\nLinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}\nQ factor:\n3×3 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:\n -0.6   0.0   0.8\n -0.8   0.0  -0.6\n  0.0  -1.0   0.0\nR factor:\n2×2 Array{Float64,2}:\n -5.0  10.0\n  0.0  -1.0\n\njulia> F.Q * F.R == A\ntrue\n\nnote: Note\nqr returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the Q and R matrices can be stored compactly rather as two separate dense matrices.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.qr!","page":"Linear Algebra","title":"LinearAlgebra.qr!","text":"qr!(A, pivot=Val(false))\n\nqr! is the same as qr when A is a subtype of StridedMatrix, but saves space by overwriting the input A, instead of creating a copy. An InexactError exception is thrown if the factorization produces a number not representable by the element type of A, e.g. for integer types.\n\nExamples\n\njulia> a = [1. 2.; 3. 4.]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> qr!(a)\nLinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}\nQ factor:\n2×2 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:\n -0.316228  -0.948683\n -0.948683   0.316228\nR factor:\n2×2 Array{Float64,2}:\n -3.16228  -4.42719\n  0.0      -0.632456\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> qr!(a)\nERROR: InexactError: Int64(-3.1622776601683795)\nStacktrace:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.QR","page":"Linear Algebra","title":"LinearAlgebra.QR","text":"QR <: Factorization\n\nA QR matrix factorization stored in a packed format, typically obtained from qr. If A is an m×n matrix, then\n\nA = Q R\n\nwhere Q is an orthogonal/unitary matrix and R is upper triangular. The matrix Q is stored as a sequence of Householder reflectors v_i and coefficients tau_i where:\n\nQ = prod_i=1^min(mn) (I - tau_i v_i v_i^T)\n\nIterating the decomposition produces the components Q and R.\n\nThe object has two fields:\n\nfactors is an m×n matrix.\nThe upper triangular part contains the elements of R, that is R = triu(F.factors) for a QR object F.\nThe subdiagonal part contains the reflectors v_i stored in a packed format where v_i is the ith column of the matrix V = I + tril(F.factors, -1).\nτ is a vector  of length min(m,n) containing the coefficients au_i.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.QRCompactWY","page":"Linear Algebra","title":"LinearAlgebra.QRCompactWY","text":"QRCompactWY <: Factorization\n\nA QR matrix factorization stored in a compact blocked format, typically obtained from qr. If A is an m×n matrix, then\n\nA = Q R\n\nwhere Q is an orthogonal/unitary matrix and R is upper triangular. It is similar to the QR format except that the orthogonal/unitary matrix Q is stored in Compact WY format [Schreiber1989], as a lower trapezoidal matrix V and an upper triangular matrix T where\n\nQ = prod_i=1^min(mn) (I - tau_i v_i v_i^T) = I - V T V^T\n\nsuch that v_i is the ith column of V, and au_i is the ith diagonal element of T.\n\nIterating the decomposition produces the components Q and R.\n\nThe object has two fields:\n\nfactors, as in the QR type, is an m×n matrix.\nThe upper triangular part contains the elements of R, that is R = triu(F.factors) for a QR object F.\nThe subdiagonal part contains the reflectors v_i stored in a packed format such that V = I + tril(F.factors, -1).\nT is a square matrix with min(m,n) columns, whose upper triangular part gives the matrix T above (the subdiagonal elements are ignored).\n\nnote: Note\nThis format should not to be confused with the older WY representation [Bischof1987].\n\n[Bischof1987]: C Bischof and C Van Loan, \"The WY representation for products of Householder matrices\", SIAM J Sci Stat Comput 8 (1987), s2-s13. doi:10.1137/0908009\n\n[Schreiber1989]: R Schreiber and C Van Loan, \"A storage-efficient WY representation for products of Householder transformations\", SIAM J Sci Stat Comput 10 (1989), 53-57. doi:10.1137/0910005\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.QRPivoted","page":"Linear Algebra","title":"LinearAlgebra.QRPivoted","text":"QRPivoted <: Factorization\n\nA QR matrix factorization with column pivoting in a packed format, typically obtained from qr. If A is an m×n matrix, then\n\nA P = Q R\n\nwhere P is a permutation matrix, Q is an orthogonal/unitary matrix and R is upper triangular. The matrix Q is stored as a sequence of Householder reflectors:\n\nQ = prod_i=1^min(mn) (I - tau_i v_i v_i^T)\n\nIterating the decomposition produces the components Q, R, and p.\n\nThe object has three fields:\n\nfactors is an m×n matrix.\nThe upper triangular part contains the elements of R, that is R = triu(F.factors) for a QR object F.\nThe subdiagonal part contains the reflectors v_i stored in a packed format where v_i is the ith column of the matrix V = I + tril(F.factors, -1).\nτ is a vector of length min(m,n) containing the coefficients au_i.\njpvt is an integer vector of length n corresponding to the permutation P.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.lq!","page":"Linear Algebra","title":"LinearAlgebra.lq!","text":"lq!(A) -> LQ\n\nCompute the LQ factorization of A, using the input matrix as a workspace. See also lq.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.lq","page":"Linear Algebra","title":"LinearAlgebra.lq","text":"lq(A) -> S::LQ\n\nCompute the LQ decomposition of A. The decomposition's lower triangular component can be obtained from the LQ object S via S.L, and the orthogonal/unitary component via S.Q, such that A ≈ S.L*S.Q.\n\nIterating the decomposition produces the components S.L and S.Q.\n\nThe LQ decomposition is the QR decomposition of transpose(A).\n\nExamples\n\njulia> A = [5. 7.; -2. -4.]\n2×2 Array{Float64,2}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> S = lq(A)\nLQ{Float64,Array{Float64,2}} with factors L and Q:\n[-8.60233 0.0; 4.41741 -0.697486]\n[-0.581238 -0.813733; -0.813733 0.581238]\n\njulia> S.L * S.Q\n2×2 Array{Float64,2}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> l, q = S; # destructuring via iteration\n\njulia> l == S.L &&  q == S.Q\ntrue\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.bunchkaufman","page":"Linear Algebra","title":"LinearAlgebra.bunchkaufman","text":"bunchkaufman(A, rook::Bool=false; check = true) -> S::BunchKaufman\n\nCompute the Bunch-Kaufman [Bunch1977] factorization of a Symmetric or Hermitian matrix A as P*U*D*U*P or P*L*D*L*P, depending on which triangle is stored in A, and return a BunchKaufman object. Note that if A is complex symmetric then U' and L' denote the unconjugated transposes, i.e. transpose(U) and transpose(L).\n\nIterating the decomposition produces the components S.D, S.U or S.L as appropriate given S.uplo, and S.p.\n\nIf rook is true, rook pivoting is used. If rook is false, rook pivoting is not used.\n\nWhen check = true, an error is thrown if the decomposition fails. When check = false, responsibility for checking the decomposition's validity (via issuccess) lies with the user.\n\nThe following functions are available for BunchKaufman objects: size, \\, inv, issymmetric, ishermitian, getindex.\n\n[Bunch1977]: J R Bunch and L Kaufman, Some stable methods for calculating inertia\n\nand solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. url.\n\nExamples\n\njulia> A = [1 2; 2 3]\n2×2 Array{Int64,2}:\n 1  2\n 2  3\n\njulia> S = bunchkaufman(A)\nBunchKaufman{Float64,Array{Float64,2}}\nD factor:\n2×2 Tridiagonal{Float64,Array{Float64,1}}:\n -0.333333  0.0\n  0.0       3.0\nU factor:\n2×2 UnitUpperTriangular{Float64,Array{Float64,2}}:\n 1.0  0.666667\n  ⋅   1.0\npermutation:\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> d, u, p = S; # destructuring via iteration\n\njulia> d == S.D && u == S.U && p == S.p\ntrue\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.bunchkaufman!","page":"Linear Algebra","title":"LinearAlgebra.bunchkaufman!","text":"bunchkaufman!(A, rook::Bool=false; check = true) -> BunchKaufman\n\nbunchkaufman! is the same as bunchkaufman, but saves space by overwriting the input A, instead of creating a copy.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigvals","page":"Linear Algebra","title":"LinearAlgebra.eigvals","text":"eigvals(A; permute::Bool=true, scale::Bool=true, sortby) -> values\n\nReturn the eigenvalues of A.\n\nFor general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The permute, scale, and sortby keywords are the same as for eigen!.\n\nExamples\n\njulia> diag_matrix = [1 0; 0 4]\n2×2 Array{Int64,2}:\n 1  0\n 0  4\n\njulia> eigvals(diag_matrix)\n2-element Array{Float64,1}:\n 1.0\n 4.0\n\n\n\n\n\nFor a scalar input, eigvals will return a scalar.\n\nExample\n\njulia> eigvals(-2)\n-2\n\n\n\n\n\neigvals(A, B) -> values\n\nComputes the generalized eigenvalues of A and B.\n\nExamples\n\njulia> A = [1 0; 0 -1]\n2×2 Array{Int64,2}:\n 1   0\n 0  -1\n\njulia> B = [0 1; 1 0]\n2×2 Array{Int64,2}:\n 0  1\n 1  0\n\njulia> eigvals(A,B)\n2-element Array{Complex{Float64},1}:\n 0.0 - 1.0im\n 0.0 + 1.0im\n\n\n\n\n\neigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values\n\nReturns the eigenvalues of A. It is possible to calculate only a subset of the eigenvalues by specifying a UnitRange irange covering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.\n\njulia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])\n3×3 SymTridiagonal{Float64,Array{Float64,1}}:\n 1.0  2.0   ⋅\n 2.0  2.0  3.0\n  ⋅   3.0  1.0\n\njulia> eigvals(A, 2:2)\n1-element Array{Float64,1}:\n 0.9999999999999996\n\njulia> eigvals(A)\n3-element Array{Float64,1}:\n -2.1400549446402604\n  1.0000000000000002\n  5.140054944640259\n\n\n\n\n\neigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values\n\nReturns the eigenvalues of A. It is possible to calculate only a subset of the eigenvalues by specifying a pair vl and vu for the lower and upper boundaries of the eigenvalues.\n\njulia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])\n3×3 SymTridiagonal{Float64,Array{Float64,1}}:\n 1.0  2.0   ⋅\n 2.0  2.0  3.0\n  ⋅   3.0  1.0\n\njulia> eigvals(A, -1, 2)\n1-element Array{Float64,1}:\n 1.0000000000000009\n\njulia> eigvals(A)\n3-element Array{Float64,1}:\n -2.1400549446402604\n  1.0000000000000002\n  5.140054944640259\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigvals!","page":"Linear Algebra","title":"LinearAlgebra.eigvals!","text":"eigvals!(A; permute::Bool=true, scale::Bool=true, sortby) -> values\n\nSame as eigvals, but saves space by overwriting the input A, instead of creating a copy. The permute, scale, and sortby keywords are the same as for eigen.\n\nnote: Note\nThe input matrix A will not contain its eigenvalues after eigvals! is called on it - A is used as a workspace.\n\nExamples\n\njulia> A = [1. 2.; 3. 4.]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> eigvals!(A)\n2-element Array{Float64,1}:\n -0.3722813232690143\n  5.372281323269014\n\njulia> A\n2×2 Array{Float64,2}:\n -0.372281  -1.0\n  0.0        5.37228\n\n\n\n\n\neigvals!(A, B; sortby) -> values\n\nSame as eigvals, but saves space by overwriting the input A (and B), instead of creating copies.\n\nnote: Note\nThe input matrices A and B will not contain their eigenvalues after eigvals! is called. They are used as workspaces.\n\nExamples\n\njulia> A = [1. 0.; 0. -1.]\n2×2 Array{Float64,2}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> B = [0. 1.; 1. 0.]\n2×2 Array{Float64,2}:\n 0.0  1.0\n 1.0  0.0\n\njulia> eigvals!(A, B)\n2-element Array{Complex{Float64},1}:\n 0.0 - 1.0im\n 0.0 + 1.0im\n\njulia> A\n2×2 Array{Float64,2}:\n -0.0  -1.0\n  1.0  -0.0\n\njulia> B\n2×2 Array{Float64,2}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\neigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values\n\nSame as eigvals, but saves space by overwriting the input A, instead of creating a copy. irange is a range of eigenvalue indices to search for - for instance, the 2nd to 8th eigenvalues.\n\n\n\n\n\neigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values\n\nSame as eigvals, but saves space by overwriting the input A, instead of creating a copy. vl is the lower bound of the interval to search for eigenvalues, and vu is the upper bound.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigmax","page":"Linear Algebra","title":"LinearAlgebra.eigmax","text":"eigmax(A; permute::Bool=true, scale::Bool=true)\n\nReturn the largest eigenvalue of A. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of A are complex, this method will fail, since complex numbers cannot be sorted.\n\nExamples\n\njulia> A = [0 im; -im 0]\n2×2 Array{Complex{Int64},2}:\n 0+0im  0+1im\n 0-1im  0+0im\n\njulia> eigmax(A)\n1.0\n\njulia> A = [0 im; -1 0]\n2×2 Array{Complex{Int64},2}:\n  0+0im  0+1im\n -1+0im  0+0im\n\njulia> eigmax(A)\nERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:\n`A` cannot have complex eigenvalues.\nStacktrace:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigmin","page":"Linear Algebra","title":"LinearAlgebra.eigmin","text":"eigmin(A; permute::Bool=true, scale::Bool=true)\n\nReturn the smallest eigenvalue of A. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of A are complex, this method will fail, since complex numbers cannot be sorted.\n\nExamples\n\njulia> A = [0 im; -im 0]\n2×2 Array{Complex{Int64},2}:\n 0+0im  0+1im\n 0-1im  0+0im\n\njulia> eigmin(A)\n-1.0\n\njulia> A = [0 im; -1 0]\n2×2 Array{Complex{Int64},2}:\n  0+0im  0+1im\n -1+0im  0+0im\n\njulia> eigmin(A)\nERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:\n`A` cannot have complex eigenvalues.\nStacktrace:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigvecs","page":"Linear Algebra","title":"LinearAlgebra.eigvecs","text":"eigvecs(A::SymTridiagonal[, eigvals]) -> Matrix\n\nReturn a matrix M whose columns are the eigenvectors of A. (The kth eigenvector can be obtained from the slice M[:, k].)\n\nIf the optional vector of eigenvalues eigvals is specified, eigvecs returns the specific corresponding eigenvectors.\n\nExamples\n\njulia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])\n3×3 SymTridiagonal{Float64,Array{Float64,1}}:\n 1.0  2.0   ⋅\n 2.0  2.0  3.0\n  ⋅   3.0  1.0\n\njulia> eigvals(A)\n3-element Array{Float64,1}:\n -2.1400549446402604\n  1.0000000000000002\n  5.140054944640259\n\njulia> eigvecs(A)\n3×3 Array{Float64,2}:\n  0.418304  -0.83205      0.364299\n -0.656749  -7.39009e-16  0.754109\n  0.627457   0.5547       0.546448\n\njulia> eigvecs(A, [1.])\n3×1 Array{Float64,2}:\n  0.8320502943378438\n  4.263514128092366e-17\n -0.5547001962252291\n\n\n\n\n\neigvecs(A; permute::Bool=true, scale::Bool=true, `sortby`) -> Matrix\n\nReturn a matrix M whose columns are the eigenvectors of A. (The kth eigenvector can be obtained from the slice M[:, k].) The permute, scale, and sortby keywords are the same as for eigen.\n\nExamples\n\njulia> eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n\n\neigvecs(A, B) -> Matrix\n\nReturn a matrix M whose columns are the generalized eigenvectors of A and B. (The kth eigenvector can be obtained from the slice M[:, k].)\n\nExamples\n\njulia> A = [1 0; 0 -1]\n2×2 Array{Int64,2}:\n 1   0\n 0  -1\n\njulia> B = [0 1; 1 0]\n2×2 Array{Int64,2}:\n 0  1\n 1  0\n\njulia> eigvecs(A, B)\n2×2 Array{Complex{Float64},2}:\n  0.0+1.0im   0.0-1.0im\n -1.0+0.0im  -1.0-0.0im\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigen","page":"Linear Algebra","title":"LinearAlgebra.eigen","text":"eigen(A; permute::Bool=true, scale::Bool=true, sortby) -> Eigen\n\nComputes the eigenvalue decomposition of A, returning an Eigen factorization object F which contains the eigenvalues in F.values and the eigenvectors in the columns of the matrix F.vectors. (The kth eigenvector can be obtained from the slice F.vectors[:, k].)\n\nIterating the decomposition produces the components F.values and F.vectors.\n\nThe following functions are available for Eigen objects: inv, det, and isposdef.\n\nFor general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is true for both options.\n\nBy default, the eigenvalues and vectors are sorted lexicographically by (real(λ),imag(λ)). A different comparison function by(λ) can be passed to sortby, or you can pass sortby=nothing to leave the eigenvalues in an arbitrary order.   Some special matrix types (e.g. Diagonal or SymTridiagonal) may implement their own sorting convention and not accept a sortby keyword.\n\nExamples\n\njulia> F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\nEigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}\neigenvalues:\n3-element Array{Float64,1}:\n  1.0\n  3.0\n 18.0\neigenvectors:\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> F.values\n3-element Array{Float64,1}:\n  1.0\n  3.0\n 18.0\n\njulia> F.vectors\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> vals, vecs = F; # destructuring via iteration\n\njulia> vals == F.values && vecs == F.vectors\ntrue\n\n\n\n\n\neigen(A, B) -> GeneralizedEigen\n\nComputes the generalized eigenvalue decomposition of A and B, returning a GeneralizedEigen factorization object F which contains the generalized eigenvalues in F.values and the generalized eigenvectors in the columns of the matrix F.vectors. (The kth generalized eigenvector can be obtained from the slice F.vectors[:, k].)\n\nIterating the decomposition produces the components F.values and F.vectors.\n\nAny keyword arguments passed to eigen are passed through to the lower-level eigen! function.\n\nExamples\n\njulia> A = [1 0; 0 -1]\n2×2 Array{Int64,2}:\n 1   0\n 0  -1\n\njulia> B = [0 1; 1 0]\n2×2 Array{Int64,2}:\n 0  1\n 1  0\n\njulia> F = eigen(A, B);\n\njulia> F.values\n2-element Array{Complex{Float64},1}:\n 0.0 - 1.0im\n 0.0 + 1.0im\n\njulia> F.vectors\n2×2 Array{Complex{Float64},2}:\n  0.0+1.0im   0.0-1.0im\n -1.0+0.0im  -1.0-0.0im\n\njulia> vals, vecs = F; # destructuring via iteration\n\njulia> vals == F.values && vecs == F.vectors\ntrue\n\n\n\n\n\neigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> Eigen\n\nComputes the eigenvalue decomposition of A, returning an Eigen factorization object F which contains the eigenvalues in F.values and the eigenvectors in the columns of the matrix F.vectors. (The kth eigenvector can be obtained from the slice F.vectors[:, k].)\n\nIterating the decomposition produces the components F.values and F.vectors.\n\nThe following functions are available for Eigen objects: inv, det, and isposdef.\n\nThe UnitRange irange specifies indices of the sorted eigenvalues to search for.\n\nnote: Note\nIf irange is not 1:n, where n is the dimension of A, then the returned factorization will be a truncated factorization.\n\n\n\n\n\neigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> Eigen\n\nComputes the eigenvalue decomposition of A, returning an Eigen factorization object F which contains the eigenvalues in F.values and the eigenvectors in the columns of the matrix F.vectors. (The kth eigenvector can be obtained from the slice F.vectors[:, k].)\n\nIterating the decomposition produces the components F.values and F.vectors.\n\nThe following functions are available for Eigen objects: inv, det, and isposdef.\n\nvl is the lower bound of the window of eigenvalues to search for, and vu is the upper bound.\n\nnote: Note\nIf [vl, vu] does not contain all eigenvalues of A, then the returned factorization will be a truncated factorization.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigen!","page":"Linear Algebra","title":"LinearAlgebra.eigen!","text":"eigen!(A, [B]; permute, scale, sortby)\n\nSame as eigen, but saves space by overwriting the input A (and B), instead of creating a copy.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.hessenberg","page":"Linear Algebra","title":"LinearAlgebra.hessenberg","text":"hessenberg(A) -> Hessenberg\n\nCompute the Hessenberg decomposition of A and return a Hessenberg object. If F is the factorization object, the unitary matrix can be accessed with F.Q and the Hessenberg matrix with F.H. When Q is extracted, the resulting type is the HessenbergQ object, and may be converted to a regular matrix with convert(Array, _)  (or Array(_) for short).\n\nIterating the decomposition produces the factors F.Q and F.H.\n\nExamples\n\njulia> A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]\n3×3 Array{Float64,2}:\n 4.0  9.0  7.0\n 4.0  4.0  1.0\n 4.0  3.0  2.0\n\njulia> F = hessenberg(A);\n\njulia> F.Q * F.H * F.Q'\n3×3 Array{Float64,2}:\n 4.0  9.0  7.0\n 4.0  4.0  1.0\n 4.0  3.0  2.0\n\njulia> q, h = F; # destructuring via iteration\n\njulia> q == F.Q && h == F.H\ntrue\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.hessenberg!","page":"Linear Algebra","title":"LinearAlgebra.hessenberg!","text":"hessenberg!(A) -> Hessenberg\n\nhessenberg! is the same as hessenberg, but saves space by overwriting the input A, instead of creating a copy.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.schur!","page":"Linear Algebra","title":"LinearAlgebra.schur!","text":"schur!(A::StridedMatrix) -> F::Schur\n\nSame as schur but uses the input argument A as workspace.\n\nExamples\n\njulia> A = [5. 7.; -2. -4.]\n2×2 Array{Float64,2}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> F = schur!(A)\nSchur{Float64,Array{Float64,2}}\nT factor:\n2×2 Array{Float64,2}:\n 3.0   9.0\n 0.0  -2.0\nZ factor:\n2×2 Array{Float64,2}:\n  0.961524  0.274721\n -0.274721  0.961524\neigenvalues:\n2-element Array{Float64,1}:\n  3.0\n -2.0\n\njulia> A\n2×2 Array{Float64,2}:\n 3.0   9.0\n 0.0  -2.0\n\n\n\n\n\nschur!(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur\n\nSame as schur but uses the input matrices A and B as workspace.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.schur","page":"Linear Algebra","title":"LinearAlgebra.schur","text":"schur(A::StridedMatrix) -> F::Schur\n\nComputes the Schur factorization of the matrix A. The (quasi) triangular Schur factor can be obtained from the Schur object F with either F.Schur or F.T and the orthogonal/unitary Schur vectors can be obtained with F.vectors or F.Z such that A = F.vectors * F.Schur * F.vectors'. The eigenvalues of A can be obtained with F.values.\n\nIterating the decomposition produces the components F.T, F.Z, and F.values.\n\nExamples\n\njulia> A = [5. 7.; -2. -4.]\n2×2 Array{Float64,2}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> F = schur(A)\nSchur{Float64,Array{Float64,2}}\nT factor:\n2×2 Array{Float64,2}:\n 3.0   9.0\n 0.0  -2.0\nZ factor:\n2×2 Array{Float64,2}:\n  0.961524  0.274721\n -0.274721  0.961524\neigenvalues:\n2-element Array{Float64,1}:\n  3.0\n -2.0\n\njulia> F.vectors * F.Schur * F.vectors'\n2×2 Array{Float64,2}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> t, z, vals = F; # destructuring via iteration\n\njulia> t == F.T && z == F.Z && vals == F.values\ntrue\n\n\n\n\n\nschur(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur\n\nComputes the Generalized Schur (or QZ) factorization of the matrices A and B. The (quasi) triangular Schur factors can be obtained from the Schur object F with F.S and F.T, the left unitary/orthogonal Schur vectors can be obtained with F.left or F.Q and the right unitary/orthogonal Schur vectors can be obtained with F.right or F.Z such that A=F.left*F.S*F.right' and B=F.left*F.T*F.right'. The generalized eigenvalues of A and B can be obtained with F.α./F.β.\n\nIterating the decomposition produces the components F.S, F.T, F.Q, F.Z, F.α, and F.β.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.ordschur","page":"Linear Algebra","title":"LinearAlgebra.ordschur","text":"ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur\n\nReorders the Schur factorization F of a matrix A = Z*T*Z' according to the logical array select returning the reordered factorization F object. The selected eigenvalues appear in the leading diagonal of F.Schur and the corresponding leading columns of F.vectors form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via select.\n\n\n\n\n\nordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur\n\nReorders the Generalized Schur factorization F of a matrix pair (A, B) = (Q*S*Z', Q*T*Z') according to the logical array select and returns a GeneralizedSchur object F. The selected eigenvalues appear in the leading diagonal of both F.S and F.T, and the left and right orthogonal/unitary Schur vectors are also reordered such that (A, B) = F.Q*(F.S, F.T)*F.Z' still holds and the generalized eigenvalues of A and B can still be obtained with F.α./F.β.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.ordschur!","page":"Linear Algebra","title":"LinearAlgebra.ordschur!","text":"ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur\n\nSame as ordschur but overwrites the factorization F.\n\n\n\n\n\nordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur\n\nSame as ordschur but overwrites the factorization F.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.svd","page":"Linear Algebra","title":"LinearAlgebra.svd","text":"svd(A; full::Bool = false) -> SVD\n\nCompute the singular value decomposition (SVD) of A and return an SVD object.\n\nU, S, V and Vt can be obtained from the factorization F with F.U, F.S, F.V and F.Vt, such that A = U * Diagonal(S) * Vt. The algorithm produces Vt and hence Vt is more efficient to extract than V. The singular values in S are sorted in descending order.\n\nIterating the decomposition produces the components U, S, and V.\n\nIf full = false (default), a \"thin\" SVD is returned. For a M times N matrix A, in the full factorization U is M \\times M and V is N \\times N, while in the thin factorization U is M \\times K and V is N \\times K, where K = \\min(M,N) is the number of singular values.\n\nExamples\n\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\n4×5 Array{Float64,2}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> F = svd(A);\n\njulia> F.U * Diagonal(F.S) * F.Vt\n4×5 Array{Float64,2}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\n\n\n\n\nsvd(A, B) -> GeneralizedSVD\n\nCompute the generalized SVD of A and B, returning a GeneralizedSVD factorization object F, such that A = F.U*F.D1*F.R0*F.Q' and B = F.V*F.D2*F.R0*F.Q'.\n\nFor an M-by-N matrix A and P-by-N matrix B,\n\nU is a M-by-M orthogonal matrix,\nV is a P-by-P orthogonal matrix,\nQ is a N-by-N orthogonal matrix,\nD1 is a M-by-(K+L) diagonal matrix with 1s in the first K entries,\nD2 is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,\nR0 is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,\n\nK+L is the effective numerical rank of the matrix [A; B].\n\nIterating the decomposition produces the components U, V, Q, D1, D2, and R0.\n\nThe entries of F.D1 and F.D2 are related, as explained in the LAPACK documentation for the generalized SVD and the xGGSVD3 routine which is called underneath (in LAPACK 3.6.0 and newer).\n\nExamples\n\njulia> A = [1. 0.; 0. -1.]\n2×2 Array{Float64,2}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> B = [0. 1.; 1. 0.]\n2×2 Array{Float64,2}:\n 0.0  1.0\n 1.0  0.0\n\njulia> F = svd(A, B);\n\njulia> F.U*F.D1*F.R0*F.Q'\n2×2 Array{Float64,2}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> F.V*F.D2*F.R0*F.Q'\n2×2 Array{Float64,2}:\n 0.0  1.0\n 1.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.svd!","page":"Linear Algebra","title":"LinearAlgebra.svd!","text":"svd!(A; full::Bool = false) -> SVD\n\nsvd! is the same as svd, but saves space by overwriting the input A, instead of creating a copy.\n\nExamples\n\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\n4×5 Array{Float64,2}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> F = svd!(A);\n\njulia> F.U * Diagonal(F.S) * F.Vt\n4×5 Array{Float64,2}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> A\n4×5 Array{Float64,2}:\n -2.23607   0.0   0.0  0.0  0.618034\n  0.0      -3.0   1.0  0.0  0.0\n  0.0       0.0   0.0  0.0  0.0\n  0.0       0.0  -2.0  0.0  0.0\n\n\n\n\n\nsvd!(A, B) -> GeneralizedSVD\n\nsvd! is the same as svd, but modifies the arguments A and B in-place, instead of making copies.\n\nExamples\n\njulia> A = [1. 0.; 0. -1.]\n2×2 Array{Float64,2}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> B = [0. 1.; 1. 0.]\n2×2 Array{Float64,2}:\n 0.0  1.0\n 1.0  0.0\n\njulia> F = svd!(A, B);\n\njulia> F.U*F.D1*F.R0*F.Q'\n2×2 Array{Float64,2}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> F.V*F.D2*F.R0*F.Q'\n2×2 Array{Float64,2}:\n 0.0  1.0\n 1.0  0.0\n\njulia> A\n2×2 Array{Float64,2}:\n 1.41421   0.0\n 0.0      -1.41421\n\njulia> B\n2×2 Array{Float64,2}:\n 1.0  -0.0\n 0.0  -1.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.svdvals","page":"Linear Algebra","title":"LinearAlgebra.svdvals","text":"svdvals(A)\n\nReturn the singular values of A in descending order.\n\nExamples\n\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\n4×5 Array{Float64,2}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> svdvals(A)\n4-element Array{Float64,1}:\n 3.0\n 2.23606797749979\n 2.0\n 0.0\n\n\n\n\n\nsvdvals(A, B)\n\nReturn the generalized singular values from the generalized singular value decomposition of A and B. See also svd.\n\nExamples\n\njulia> A = [1. 0.; 0. -1.]\n2×2 Array{Float64,2}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> B = [0. 1.; 1. 0.]\n2×2 Array{Float64,2}:\n 0.0  1.0\n 1.0  0.0\n\njulia> svdvals(A, B)\n2-element Array{Float64,1}:\n 1.0\n 1.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.svdvals!","page":"Linear Algebra","title":"LinearAlgebra.svdvals!","text":"svdvals!(A)\n\nReturn the singular values of A, saving space by overwriting the input. See also svdvals and svd.\n\nExamples\n\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\n4×5 Array{Float64,2}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> svdvals!(A)\n4-element Array{Float64,1}:\n 3.0\n 2.23606797749979\n 2.0\n 0.0\n\njulia> A\n4×5 Array{Float64,2}:\n -2.23607   0.0   0.0  0.0  0.618034\n  0.0      -3.0   1.0  0.0  0.0\n  0.0       0.0   0.0  0.0  0.0\n  0.0       0.0  -2.0  0.0  0.0\n\n\n\n\n\nsvdvals!(A, B)\n\nReturn the generalized singular values from the generalized singular value decomposition of A and B, saving space by overwriting A and B. See also svd and svdvals.\n\nExamples\n\njulia> A = [1. 0.; 0. -1.]\n2×2 Array{Float64,2}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> B = [0. 1.; 1. 0.]\n2×2 Array{Float64,2}:\n 0.0  1.0\n 1.0  0.0\n\njulia> svdvals!(A, B)\n2-element Array{Float64,1}:\n 1.0\n 1.0\n\njulia> A\n2×2 Array{Float64,2}:\n 1.41421   0.0\n 0.0      -1.41421\n\njulia> B\n2×2 Array{Float64,2}:\n 1.0  -0.0\n 0.0  -1.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.Givens","page":"Linear Algebra","title":"LinearAlgebra.Givens","text":"LinearAlgebra.Givens(i1,i2,c,s) -> G\n\nA Givens rotation linear operator. The fields c and s represent the cosine and sine of the rotation angle, respectively. The Givens type supports left multiplication G*A and conjugated transpose right multiplication A*G'. The type doesn't have a size and can therefore be multiplied with matrices of arbitrary size as long as i2<=size(A,2) for G*A or i2<=size(A,1) for A*G'.\n\nSee also: givens\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.givens","page":"Linear Algebra","title":"LinearAlgebra.givens","text":"givens(f::T, g::T, i1::Integer, i2::Integer) where {T} -> (G::Givens, r::T)\n\nComputes the Givens rotation G and scalar r such that for any vector x where\n\nx[i1] = f\nx[i2] = g\n\nthe result of the multiplication\n\ny = G*x\n\nhas the property that\n\ny[i1] = r\ny[i2] = 0\n\nSee also: LinearAlgebra.Givens\n\n\n\n\n\ngivens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -> (G::Givens, r)\n\nComputes the Givens rotation G and scalar r such that the result of the multiplication\n\nB = G*A\n\nhas the property that\n\nB[i1,j] = r\nB[i2,j] = 0\n\nSee also: LinearAlgebra.Givens\n\n\n\n\n\ngivens(x::AbstractVector, i1::Integer, i2::Integer) -> (G::Givens, r)\n\nComputes the Givens rotation G and scalar r such that the result of the multiplication\n\nB = G*x\n\nhas the property that\n\nB[i1] = r\nB[i2] = 0\n\nSee also: LinearAlgebra.Givens\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.triu","page":"Linear Algebra","title":"LinearAlgebra.triu","text":"triu(M)\n\nUpper triangle of a matrix.\n\nExamples\n\njulia> a = fill(1.0, (4,4))\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> triu(a)\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 0.0  1.0  1.0  1.0\n 0.0  0.0  1.0  1.0\n 0.0  0.0  0.0  1.0\n\n\n\n\n\ntriu(M, k::Integer)\n\nReturns the upper triangle of M starting from the kth superdiagonal.\n\nExamples\n\njulia> a = fill(1.0, (4,4))\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> triu(a,3)\n4×4 Array{Float64,2}:\n 0.0  0.0  0.0  1.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\njulia> triu(a,-3)\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.triu!","page":"Linear Algebra","title":"LinearAlgebra.triu!","text":"triu!(M)\n\nUpper triangle of a matrix, overwriting M in the process. See also triu.\n\n\n\n\n\ntriu!(M, k::Integer)\n\nReturn the upper triangle of M starting from the kth superdiagonal, overwriting M in the process.\n\nExamples\n\njulia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]\n5×5 Array{Int64,2}:\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n\njulia> triu!(M, 1)\n5×5 Array{Int64,2}:\n 0  2  3  4  5\n 0  0  3  4  5\n 0  0  0  4  5\n 0  0  0  0  5\n 0  0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.tril","page":"Linear Algebra","title":"LinearAlgebra.tril","text":"tril(M)\n\nLower triangle of a matrix.\n\nExamples\n\njulia> a = fill(1.0, (4,4))\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> tril(a)\n4×4 Array{Float64,2}:\n 1.0  0.0  0.0  0.0\n 1.0  1.0  0.0  0.0\n 1.0  1.0  1.0  0.0\n 1.0  1.0  1.0  1.0\n\n\n\n\n\ntril(M, k::Integer)\n\nReturns the lower triangle of M starting from the kth superdiagonal.\n\nExamples\n\njulia> a = fill(1.0, (4,4))\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> tril(a,3)\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> tril(a,-3)\n4×4 Array{Float64,2}:\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 1.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.tril!","page":"Linear Algebra","title":"LinearAlgebra.tril!","text":"tril!(M)\n\nLower triangle of a matrix, overwriting M in the process. See also tril.\n\n\n\n\n\ntril!(M, k::Integer)\n\nReturn the lower triangle of M starting from the kth superdiagonal, overwriting M in the process.\n\nExamples\n\njulia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]\n5×5 Array{Int64,2}:\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n\njulia> tril!(M, 2)\n5×5 Array{Int64,2}:\n 1  2  3  0  0\n 1  2  3  4  0\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.diagind","page":"Linear Algebra","title":"LinearAlgebra.diagind","text":"diagind(M, k::Integer=0)\n\nAn AbstractRange giving the indices of the kth diagonal of the matrix M.\n\nExamples\n\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> diagind(A,-1)\n2:4:6\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.diag","page":"Linear Algebra","title":"LinearAlgebra.diag","text":"diag(M, k::Integer=0)\n\nThe kth diagonal of a matrix, as a vector.\n\nSee also: diagm\n\nExamples\n\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> diag(A,1)\n2-element Array{Int64,1}:\n 2\n 6\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.diagm","page":"Linear Algebra","title":"LinearAlgebra.diagm","text":"diagm(kv::Pair{<:Integer,<:AbstractVector}...)\n\nConstruct a square matrix from Pairs of diagonals and vectors. Vector kv.second will be placed on the kv.first diagonal. diagm constructs a full matrix; if you want storage-efficient versions with fast arithmetic, see Diagonal, Bidiagonal Tridiagonal and SymTridiagonal.\n\nExamples\n\njulia> diagm(1 => [1,2,3])\n4×4 Array{Int64,2}:\n 0  1  0  0\n 0  0  2  0\n 0  0  0  3\n 0  0  0  0\n\njulia> diagm(1 => [1,2,3], -1 => [4,5])\n4×4 Array{Int64,2}:\n 0  1  0  0\n 4  0  2  0\n 0  5  0  3\n 0  0  0  0\n\n\n\n\n\ndiagm(v::AbstractVector)\n\nConstruct a square matrix with elements of the vector as diagonal elements.\n\nExamples\n\njulia> diagm([1,2,3])\n3×3 Array{Int64,2}:\n 1  0  0\n 0  2  0\n 0  0  3\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.rank","page":"Linear Algebra","title":"LinearAlgebra.rank","text":"rank(A::AbstractMatrix; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ)\nrank(A::AbstractMatrix, rtol::Real)\n\nCompute the rank of a matrix by counting how many singular values of A have magnitude greater than max(atol, rtol*σ₁) where σ₁ is A's largest singular value. atol and rtol are the absolute and relative tolerances, respectively. The default relative tolerance is n*ϵ, where n is the size of the smallest dimension of A, and ϵ is the eps of the element type of A.\n\ncompat: Julia 1.1\nThe atol and rtol keyword arguments requires at least Julia 1.1. In Julia 1.0 rtol is available as a positional argument, but this will be deprecated in Julia 2.0.\n\nExamples\n\njulia> rank(Matrix(I, 3, 3))\n3\n\njulia> rank(diagm(0 => [1, 0, 2]))\n2\n\njulia> rank(diagm(0 => [1, 0.001, 2]), rtol=0.1)\n2\n\njulia> rank(diagm(0 => [1, 0.001, 2]), rtol=0.00001)\n3\n\njulia> rank(diagm(0 => [1, 0.001, 2]), atol=1.5)\n1\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.norm","page":"Linear Algebra","title":"LinearAlgebra.norm","text":"norm(A, p::Real=2)\n\nFor any iterable container A (including arrays of any dimension) of numbers (or any element type for which norm is defined), compute the p-norm (defaulting to p=2) as if A were a vector of the corresponding length.\n\nThe p-norm is defined as\n\nA_p = left( sum_i=1^n  a_i  ^p right)^1p\n\nwith a_i the entries of A,  a_i  the norm of a_i, and n the length of A. Since the p-norm is computed using the norms of the entries of A, the p-norm of a vector of vectors is not compatible with the interpretation of it as a block vector in general if p != 2.\n\np can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, norm(A, Inf) returns the largest value in abs.(A), whereas norm(A, -Inf) returns the smallest. If A is a matrix and p=2, then this is equivalent to the Frobenius norm.\n\nThe second argument p is not necessarily a part of the interface for norm, i.e. a custom type may only implement norm(A) without second argument.\n\nUse opnorm to compute the operator norm of a matrix.\n\nExamples\n\njulia> v = [3, -2, 6]\n3-element Array{Int64,1}:\n  3\n -2\n  6\n\njulia> norm(v)\n7.0\n\njulia> norm(v, 1)\n11.0\n\njulia> norm(v, Inf)\n6.0\n\njulia> norm([1 2 3; 4 5 6; 7 8 9])\n16.881943016134134\n\njulia> norm([1 2 3 4 5 6 7 8 9])\n16.881943016134134\n\njulia> norm(1:9)\n16.881943016134134\n\njulia> norm(hcat(v,v), 1) == norm(vcat(v,v), 1) != norm([v,v], 1)\ntrue\n\njulia> norm(hcat(v,v), 2) == norm(vcat(v,v), 2) == norm([v,v], 2)\ntrue\n\njulia> norm(hcat(v,v), Inf) == norm(vcat(v,v), Inf) != norm([v,v], Inf)\ntrue\n\n\n\n\n\nnorm(x::Number, p::Real=2)\n\nFor numbers, return left( x^p right)^1p.\n\nExamples\n\njulia> norm(2, 1)\n2.0\n\njulia> norm(-2, 1)\n2.0\n\njulia> norm(2, 2)\n2.0\n\njulia> norm(-2, 2)\n2.0\n\njulia> norm(2, Inf)\n2.0\n\njulia> norm(-2, Inf)\n2.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.opnorm","page":"Linear Algebra","title":"LinearAlgebra.opnorm","text":"opnorm(A::AbstractMatrix, p::Real=2)\n\nCompute the operator norm (or matrix norm) induced by the vector p-norm, where valid values of p are 1, 2, or Inf. (Note that for sparse matrices, p=2 is currently not implemented.) Use norm to compute the Frobenius norm.\n\nWhen p=1, the operator norm is the maximum absolute column sum of A:\n\nA_1 = max_1  j  n sum_i=1^m  a_ij \n\nwith a_ij the entries of A, and m and n its dimensions.\n\nWhen p=2, the operator norm is the spectral norm, equal to the largest singular value of A.\n\nWhen p=Inf, the operator norm is the maximum absolute row sum of A:\n\nA_infty = max_1  i  m sum _j=1^n  a_ij \n\nExamples\n\njulia> A = [1 -2 -3; 2 3 -1]\n2×3 Array{Int64,2}:\n 1  -2  -3\n 2   3  -1\n\njulia> opnorm(A, Inf)\n6.0\n\njulia> opnorm(A, 1)\n5.0\n\n\n\n\n\nopnorm(x::Number, p::Real=2)\n\nFor numbers, return left( x^p right)^1p. This is equivalent to norm.\n\n\n\n\n\nopnorm(A::Adjoint{<:Any,<:AbstracVector}, q::Real=2)\nopnorm(A::Transpose{<:Any,<:AbstracVector}, q::Real=2)\n\nFor Adjoint/Transpose-wrapped vectors, return the operator q-norm of A, which is equivalent to the p-norm with value p = q/(q-1). They coincide at p = q = 2. Use norm to compute the p norm of A as a vector.\n\nThe difference in norm between a vector space and its dual arises to preserve the relationship between duality and the dot product, and the result is consistent with the operator p-norm of a 1 × n matrix.\n\nExamples\n\njulia> v = [1; im];\n\njulia> vc = v';\n\njulia> opnorm(vc, 1)\n1.0\n\njulia> norm(vc, 1)\n2.0\n\njulia> norm(v, 1)\n2.0\n\njulia> opnorm(vc, 2)\n1.4142135623730951\n\njulia> norm(vc, 2)\n1.4142135623730951\n\njulia> norm(v, 2)\n1.4142135623730951\n\njulia> opnorm(vc, Inf)\n2.0\n\njulia> norm(vc, Inf)\n1.0\n\njulia> norm(v, Inf)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.normalize!","page":"Linear Algebra","title":"LinearAlgebra.normalize!","text":"normalize!(v::AbstractVector, p::Real=2)\n\nNormalize the vector v in-place so that its p-norm equals unity, i.e. norm(v, p) == 1. See also normalize and norm.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.normalize","page":"Linear Algebra","title":"LinearAlgebra.normalize","text":"normalize(v::AbstractVector, p::Real=2)\n\nNormalize the vector v so that its p-norm equals unity, i.e. norm(v, p) == 1. See also normalize! and norm.\n\nExamples\n\njulia> a = [1,2,4];\n\njulia> b = normalize(a)\n3-element Array{Float64,1}:\n 0.2182178902359924\n 0.4364357804719848\n 0.8728715609439696\n\njulia> norm(b)\n1.0\n\njulia> c = normalize(a, 1)\n3-element Array{Float64,1}:\n 0.14285714285714285\n 0.2857142857142857\n 0.5714285714285714\n\njulia> norm(c, 1)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.cond","page":"Linear Algebra","title":"LinearAlgebra.cond","text":"cond(M, p::Real=2)\n\nCondition number of the matrix M, computed using the operator p-norm. Valid values for p are 1, 2 (default), or Inf.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.condskeel","page":"Linear Algebra","title":"LinearAlgebra.condskeel","text":"condskeel(M, [x, p::Real=Inf])\n\nkappa_S(M p) = leftVert leftvert M rightvert leftvert M^-1 rightvert rightVert_p \nkappa_S(M x p) = leftVert leftvert M rightvert leftvert M^-1 rightvert leftvert x rightvert rightVert_p\n\nSkeel condition number kappa_S of the matrix M, optionally with respect to the vector x, as computed using the operator p-norm. leftvert M rightvert denotes the matrix of (entry wise) absolute values of M; leftvert M rightvert_ij = leftvert M_ij rightvert. Valid values for p are 1, 2 and Inf (default).\n\nThis quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.tr","page":"Linear Algebra","title":"LinearAlgebra.tr","text":"tr(M)\n\nMatrix trace. Sums the diagonal elements of M.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> tr(A)\n5\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.det","page":"Linear Algebra","title":"LinearAlgebra.det","text":"det(M)\n\nMatrix determinant.\n\nExamples\n\njulia> M = [1 0; 2 2]\n2×2 Array{Int64,2}:\n 1  0\n 2  2\n\njulia> det(M)\n2.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.logdet","page":"Linear Algebra","title":"LinearAlgebra.logdet","text":"logdet(M)\n\nLog of matrix determinant. Equivalent to log(det(M)), but may provide increased accuracy and/or speed.\n\nExamples\n\njulia> M = [1 0; 2 2]\n2×2 Array{Int64,2}:\n 1  0\n 2  2\n\njulia> logdet(M)\n0.6931471805599453\n\njulia> logdet(Matrix(I, 3, 3))\n0.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.logabsdet","page":"Linear Algebra","title":"LinearAlgebra.logabsdet","text":"logabsdet(M)\n\nLog of absolute value of matrix determinant. Equivalent to (log(abs(det(M))), sign(det(M))), but may provide increased accuracy and/or speed.\n\nExamples\n\njulia> A = [-1. 0.; 0. 1.]\n2×2 Array{Float64,2}:\n -1.0  0.0\n  0.0  1.0\n\njulia> det(A)\n-1.0\n\njulia> logabsdet(A)\n(0.0, -1.0)\n\njulia> B = [2. 0.; 0. 1.]\n2×2 Array{Float64,2}:\n 2.0  0.0\n 0.0  1.0\n\njulia> det(B)\n2.0\n\njulia> logabsdet(B)\n(0.6931471805599453, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#Base.inv-Tuple{AbstractArray{T,2} where T}","page":"Linear Algebra","title":"Base.inv","text":"inv(M)\n\nMatrix inverse. Computes matrix N such that M * N = I, where I is the identity matrix. Computed by solving the left-division N = M \\ I.\n\nExamples\n\njulia> M = [2 5; 1 3]\n2×2 Array{Int64,2}:\n 2  5\n 1  3\n\njulia> N = inv(M)\n2×2 Array{Float64,2}:\n  3.0  -5.0\n -1.0   2.0\n\njulia> M*N == N*M == Matrix(I, 2, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.pinv","page":"Linear Algebra","title":"LinearAlgebra.pinv","text":"pinv(M; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ)\npinv(M, rtol::Real) = pinv(M; rtol=rtol) # to be deprecated in Julia 2.0\n\nComputes the Moore-Penrose pseudoinverse.\n\nFor matrices M with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values greater than max(atol, rtol*σ₁) where σ₁ is the largest singular value of M.\n\nThe optimal choice of absolute (atol) and relative tolerance (rtol) varies both with the value of M and the intended application of the pseudoinverse. The default relative tolerance is n*ϵ, where n is the size of the smallest dimension of M, and ϵ is the eps of the element type of M.\n\nFor inverting dense ill-conditioned matrices in a least-squares sense, rtol = sqrt(eps(real(float(one(eltype(M)))))) is recommended.\n\nFor more information, see [issue8859], [B96], [S84], [KY88].\n\nExamples\n\njulia> M = [1.5 1.3; 1.2 1.9]\n2×2 Array{Float64,2}:\n 1.5  1.3\n 1.2  1.9\n\njulia> N = pinv(M)\n2×2 Array{Float64,2}:\n  1.47287   -1.00775\n -0.930233   1.16279\n\njulia> M * N\n2×2 Array{Float64,2}:\n 1.0          -2.22045e-16\n 4.44089e-16   1.0\n\n[issue8859]: Issue 8859, \"Fix least squares\", https://github.com/JuliaLang/julia/pull/8859\n\n[B96]: Åke Björck, \"Numerical Methods for Least Squares Problems\",  SIAM Press, Philadelphia, 1996, \"Other Titles in Applied Mathematics\", Vol. 51. doi:10.1137/1.9781611971484\n\n[S84]: G. W. Stewart, \"Rank Degeneracy\", SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. doi:10.1137/0905030\n\n[KY88]: Konstantinos Konstantinides and Kung Yao, \"Statistical analysis of effective singular values in matrix rank determination\", IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. doi:10.1109/29.1585\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.nullspace","page":"Linear Algebra","title":"LinearAlgebra.nullspace","text":"nullspace(M; atol::Real=0, rtol::Rea=atol>0 ? 0 : n*ϵ)\nnullspace(M, rtol::Real) = nullspace(M; rtol=rtol) # to be deprecated in Julia 2.0\n\nComputes a basis for the nullspace of M by including the singular vectors of A whose singular have magnitude are greater than max(atol, rtol*σ₁), where σ₁ is M's largest singularvalue.\n\nBy default, the relative tolerance rtol is n*ϵ, where n is the size of the smallest dimension of M, and ϵ is the eps of the element type of M.\n\nExamples\n\njulia> M = [1 0 0; 0 1 0; 0 0 0]\n3×3 Array{Int64,2}:\n 1  0  0\n 0  1  0\n 0  0  0\n\njulia> nullspace(M)\n3×1 Array{Float64,2}:\n 0.0\n 0.0\n 1.0\n\njulia> nullspace(M, rtol=3)\n3×3 Array{Float64,2}:\n 0.0  1.0  0.0\n 1.0  0.0  0.0\n 0.0  0.0  1.0\n\njulia> nullspace(M, atol=0.95)\n3×1 Array{Float64,2}:\n 0.0\n 0.0\n 1.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#Base.kron","page":"Linear Algebra","title":"Base.kron","text":"kron(A, B)\n\nKronecker tensor product of two vectors or two matrices.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> B = [im 1; 1 -im]\n2×2 Array{Complex{Int64},2}:\n 0+1im  1+0im\n 1+0im  0-1im\n\njulia> kron(A, B)\n4×4 Array{Complex{Int64},2}:\n 0+1im  1+0im  0+2im  2+0im\n 1+0im  0-1im  2+0im  0-2im\n 0+3im  3+0im  0+4im  4+0im\n 3+0im  0-3im  4+0im  0-4im\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#Base.exp-Tuple{Union{DenseArray{#s5,2}, Base.ReinterpretArray{#s5,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{#s5,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{#s5,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s5<:Union{Complex{Float32}, Complex{Float64}, Float32, Float64}}","page":"Linear Algebra","title":"Base.exp","text":"exp(A::AbstractMatrix)\n\nCompute the matrix exponential of A, defined by\n\ne^A = sum_n=0^infty fracA^nn\n\nFor symmetric or Hermitian A, an eigendecomposition (eigen) is used, otherwise the scaling and squaring algorithm (see [H05]) is chosen.\n\n[H05]: Nicholas J. Higham, \"The squaring and scaling method for the matrix exponential revisited\", SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. doi:10.1137/090768539\n\nExamples\n\njulia> A = Matrix(1.0I, 2, 2)\n2×2 Array{Float64,2}:\n 1.0  0.0\n 0.0  1.0\n\njulia> exp(A)\n2×2 Array{Float64,2}:\n 2.71828  0.0\n 0.0      2.71828\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.:^-Tuple{AbstractArray{T,2} where T,Number}","page":"Linear Algebra","title":"Base.:^","text":"^(A::AbstractMatrix, p::Number)\n\nMatrix power, equivalent to exp(plog(A))\n\nExamples\n\njulia> [1 2; 0 3]^3\n2×2 Array{Int64,2}:\n 1  26\n 0  27\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.:^-Tuple{Number,AbstractArray{T,2} where T}","page":"Linear Algebra","title":"Base.:^","text":"^(b::Number, A::AbstractMatrix)\n\nMatrix exponential, equivalent to exp(log(b)A).\n\ncompat: Julia 1.1\nSupport for raising Irrational numbers (like ℯ) to a matrix was added in Julia 1.1.\n\nExamples\n\njulia> 2^[1 2; 0 3]\n2×2 Array{Float64,2}:\n 2.0  6.0\n 0.0  8.0\n\njulia> ℯ^[1 2; 0 3]\n2×2 Array{Float64,2}:\n 2.71828  17.3673\n 0.0      20.0855\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.log-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.log","text":"log(A{T}::StridedMatrix{T})\n\nIf A has no negative real eigenvalue, compute the principal matrix logarithm of A, i.e. the unique matrix X such that e^X = A and -pi  Im(lambda)  pi for all the eigenvalues lambda of X. If A has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used, if A is triangular an improved version of the inverse scaling and squaring method is employed (see [AH12] and [AHR13]). For general matrices, the complex Schur form (schur) is computed and the triangular algorithm is used on the triangular factor.\n\n[AH12]: Awad H. Al-Mohy and Nicholas J. Higham, \"Improved inverse  scaling and squaring algorithms for the matrix logarithm\", SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. doi:10.1137/110852553\n\n[AHR13]: Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, \"Computing the Fréchet derivative of the matrix logarithm and estimating the condition number\", SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. doi:10.1137/120885991\n\nExamples\n\njulia> A = Matrix(2.7182818*I, 2, 2)\n2×2 Array{Float64,2}:\n 2.71828  0.0\n 0.0      2.71828\n\njulia> log(A)\n2×2 Array{Float64,2}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.sqrt-Tuple{Union{DenseArray{#s5,2}, Base.ReinterpretArray{#s5,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{#s5,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{#s5,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s5<:Real}","page":"Linear Algebra","title":"Base.sqrt","text":"sqrt(A::AbstractMatrix)\n\nIf A has no negative real eigenvalues, compute the principal matrix square root of A, that is the unique matrix X with eigenvalues having positive real part such that X^2 = A. Otherwise, a nonprincipal square root is returned.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the square root. Otherwise, the square root is determined by means of the Björck-Hammarling method [BH83], which computes the complex Schur form (schur) and then the complex square root of the triangular factor.\n\n[BH83]: Åke Björck and Sven Hammarling, \"A Schur method for the square root of a matrix\", Linear Algebra and its Applications, 52-53, 1983, 127-140. doi:10.1016/0024-3795(83)80010-X\n\nExamples\n\njulia> A = [4 0; 0 4]\n2×2 Array{Int64,2}:\n 4  0\n 0  4\n\njulia> sqrt(A)\n2×2 Array{Float64,2}:\n 2.0  0.0\n 0.0  2.0\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.cos-Tuple{Union{DenseArray{#s5,2}, Base.ReinterpretArray{#s5,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{#s5,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{#s5,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s5<:Real}","page":"Linear Algebra","title":"Base.cos","text":"cos(A::AbstractMatrix)\n\nCompute the matrix cosine of a square matrix A.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the cosine. Otherwise, the cosine is determined by calling exp.\n\nExamples\n\njulia> cos(fill(1.0, (2,2)))\n2×2 Array{Float64,2}:\n  0.291927  -0.708073\n -0.708073   0.291927\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.sin-Tuple{Union{DenseArray{#s5,2}, Base.ReinterpretArray{#s5,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{#s5,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{#s5,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s5<:Real}","page":"Linear Algebra","title":"Base.sin","text":"sin(A::AbstractMatrix)\n\nCompute the matrix sine of a square matrix A.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the sine. Otherwise, the sine is determined by calling exp.\n\nExamples\n\njulia> sin(fill(1.0, (2,2)))\n2×2 Array{Float64,2}:\n 0.454649  0.454649\n 0.454649  0.454649\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.sincos-Tuple{Union{DenseArray{#s5,2}, Base.ReinterpretArray{#s5,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{#s5,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{#s5,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s5<:Real}","page":"Linear Algebra","title":"Base.Math.sincos","text":"sincos(A::AbstractMatrix)\n\nCompute the matrix sine and cosine of a square matrix A.\n\nExamples\n\njulia> S, C = sincos(fill(1.0, (2,2)));\n\njulia> S\n2×2 Array{Float64,2}:\n 0.454649  0.454649\n 0.454649  0.454649\n\njulia> C\n2×2 Array{Float64,2}:\n  0.291927  -0.708073\n -0.708073   0.291927\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.tan-Tuple{Union{DenseArray{#s5,2}, Base.ReinterpretArray{#s5,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{#s5,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{#s5,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s5<:Real}","page":"Linear Algebra","title":"Base.tan","text":"tan(A::AbstractMatrix)\n\nCompute the matrix tangent of a square matrix A.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the tangent. Otherwise, the tangent is determined by calling exp.\n\nExamples\n\njulia> tan(fill(1.0, (2,2)))\n2×2 Array{Float64,2}:\n -1.09252  -1.09252\n -1.09252  -1.09252\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.sec-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.Math.sec","text":"sec(A::AbstractMatrix)\n\nCompute the matrix secant of a square matrix A.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.csc-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.Math.csc","text":"csc(A::AbstractMatrix)\n\nCompute the matrix cosecant of a square matrix A.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.cot-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.Math.cot","text":"cot(A::AbstractMatrix)\n\nCompute the matrix cotangent of a square matrix A.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.cosh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.cosh","text":"cosh(A::AbstractMatrix)\n\nCompute the matrix hyperbolic cosine of a square matrix A.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.sinh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.sinh","text":"sinh(A::AbstractMatrix)\n\nCompute the matrix hyperbolic sine of a square matrix A.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.tanh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.tanh","text":"tanh(A::AbstractMatrix)\n\nCompute the matrix hyperbolic tangent of a square matrix A.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.sech-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.Math.sech","text":"sech(A::AbstractMatrix)\n\nCompute the matrix hyperbolic secant of square matrix A.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.csch-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.Math.csch","text":"csch(A::AbstractMatrix)\n\nCompute the matrix hyperbolic cosecant of square matrix A.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.coth-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.Math.coth","text":"coth(A::AbstractMatrix)\n\nCompute the matrix hyperbolic cotangent of square matrix A.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.acos-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.acos","text":"acos(A::AbstractMatrix)\n\nCompute the inverse matrix cosine of a square matrix A.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using log and sqrt.  For the theory and logarithmic formulas used to compute this function, see [AH16_1].\n\n[AH16_1]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\nExamples\n\njulia> acos(cos([0.5 0.1; -0.2 0.3]))\n2×2 Array{Complex{Float64},2}:\n  0.5-8.32667e-17im  0.1+0.0im\n -0.2+2.63678e-16im  0.3-3.46945e-16im\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.asin-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.asin","text":"asin(A::AbstractMatrix)\n\nCompute the inverse matrix sine of a square matrix A.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using log and sqrt.  For the theory and logarithmic formulas used to compute this function, see [AH16_2].\n\n[AH16_2]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\nExamples\n\njulia> asin(sin([0.5 0.1; -0.2 0.3]))\n2×2 Array{Complex{Float64},2}:\n  0.5-4.16334e-17im  0.1-5.55112e-17im\n -0.2+9.71445e-17im  0.3-1.249e-16im\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.atan-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.atan","text":"atan(A::AbstractMatrix)\n\nCompute the inverse matrix tangent of a square matrix A.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using log.  For the theory and logarithmic formulas used to compute this function, see [AH16_3].\n\n[AH16_3]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\nExamples\n\njulia> atan(tan([0.5 0.1; -0.2 0.3]))\n2×2 Array{Complex{Float64},2}:\n  0.5+1.38778e-17im  0.1-2.77556e-17im\n -0.2+6.93889e-17im  0.3-4.16334e-17im\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.asec-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.Math.asec","text":"asec(A::AbstractMatrix)\n\nCompute the inverse matrix secant of A. \n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.acsc-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.Math.acsc","text":"acsc(A::AbstractMatrix)\n\nCompute the inverse matrix cosecant of A. \n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.acot-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.Math.acot","text":"acot(A::AbstractMatrix)\n\nCompute the inverse matrix cotangent of A. \n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.acosh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.acosh","text":"acosh(A::AbstractMatrix)\n\nCompute the inverse hyperbolic matrix cosine of a square matrix A.  For the theory and logarithmic formulas used to compute this function, see [AH16_4].\n\n[AH16_4]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.asinh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.asinh","text":"asinh(A::AbstractMatrix)\n\nCompute the inverse hyperbolic matrix sine of a square matrix A.  For the theory and logarithmic formulas used to compute this function, see [AH16_5].\n\n[AH16_5]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.atanh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.atanh","text":"atanh(A::AbstractMatrix)\n\nCompute the inverse hyperbolic matrix tangent of a square matrix A.  For the theory and logarithmic formulas used to compute this function, see [AH16_6].\n\n[AH16_6]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.asech-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.Math.asech","text":"asech(A::AbstractMatrix)\n\nCompute the inverse matrix hyperbolic secant of A. \n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.acsch-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.Math.acsch","text":"acsch(A::AbstractMatrix)\n\nCompute the inverse matrix hyperbolic cosecant of A. \n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#Base.Math.acoth-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, Base.ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, Base.ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{Base.ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Union{Tuple{Vararg{Real,N} where N}, Tuple{AbstractUnitRange,Vararg{Any,N} where N}} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}","page":"Linear Algebra","title":"Base.Math.acoth","text":"acoth(A::AbstractMatrix)\n\nCompute the inverse matrix hyperbolic cotangent of A. \n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.lyap","page":"Linear Algebra","title":"LinearAlgebra.lyap","text":"lyap(A, C)\n\nComputes the solution X to the continuous Lyapunov equation AX + XA' + C = 0, where no eigenvalue of A has a zero real part and no two eigenvalues are negative complex conjugates of each other.\n\nExamples\n\njulia> A = [3. 4.; 5. 6]\n2×2 Array{Float64,2}:\n 3.0  4.0\n 5.0  6.0\n\njulia> B = [1. 1.; 1. 2.]\n2×2 Array{Float64,2}:\n 1.0  1.0\n 1.0  2.0\n\njulia> X = lyap(A, B)\n2×2 Array{Float64,2}:\n  0.5  -0.5\n -0.5   0.25\n\njulia> A*X + X*A' + B\n2×2 Array{Float64,2}:\n 0.0          6.66134e-16\n 6.66134e-16  8.88178e-16\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.sylvester","page":"Linear Algebra","title":"LinearAlgebra.sylvester","text":"sylvester(A, B, C)\n\nComputes the solution X to the Sylvester equation AX + XB + C = 0, where A, B and C have compatible dimensions and A and -B have no eigenvalues with equal real part.\n\nExamples\n\njulia> A = [3. 4.; 5. 6]\n2×2 Array{Float64,2}:\n 3.0  4.0\n 5.0  6.0\n\njulia> B = [1. 1.; 1. 2.]\n2×2 Array{Float64,2}:\n 1.0  1.0\n 1.0  2.0\n\njulia> C = [1. 2.; -2. 1]\n2×2 Array{Float64,2}:\n  1.0  2.0\n -2.0  1.0\n\njulia> X = sylvester(A, B, C)\n2×2 Array{Float64,2}:\n -4.46667   1.93333\n  3.73333  -1.8\n\njulia> A*X + X*B + C\n2×2 Array{Float64,2}:\n  2.66454e-15  1.77636e-15\n -3.77476e-15  4.44089e-16\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.issuccess","page":"Linear Algebra","title":"LinearAlgebra.issuccess","text":"issuccess(F::Factorization)\n\nTest that a factorization of a matrix succeeded.\n\njulia> F = cholesky([1 0; 0 1]);\n\njulia> LinearAlgebra.issuccess(F)\ntrue\n\njulia> F = lu([1 0; 0 0]; check = false);\n\njulia> LinearAlgebra.issuccess(F)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.issymmetric","page":"Linear Algebra","title":"LinearAlgebra.issymmetric","text":"issymmetric(A) -> Bool\n\nTest whether a matrix is symmetric.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Array{Int64,2}:\n 1   2\n 2  -1\n\njulia> issymmetric(a)\ntrue\n\njulia> b = [1 im; -im 1]\n2×2 Array{Complex{Int64},2}:\n 1+0im  0+1im\n 0-1im  1+0im\n\njulia> issymmetric(b)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.isposdef","page":"Linear Algebra","title":"LinearAlgebra.isposdef","text":"isposdef(A) -> Bool\n\nTest whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of A. See also isposdef!\n\nExamples\n\njulia> A = [1 2; 2 50]\n2×2 Array{Int64,2}:\n 1   2\n 2  50\n\njulia> isposdef(A)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.isposdef!","page":"Linear Algebra","title":"LinearAlgebra.isposdef!","text":"isposdef!(A) -> Bool\n\nTest whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of A, overwriting A in the process. See also isposdef.\n\nExamples\n\njulia> A = [1. 2.; 2. 50.];\n\njulia> isposdef!(A)\ntrue\n\njulia> A\n2×2 Array{Float64,2}:\n 1.0  2.0\n 2.0  6.78233\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.istril","page":"Linear Algebra","title":"LinearAlgebra.istril","text":"istril(A::AbstractMatrix, k::Integer = 0) -> Bool\n\nTest whether A is lower triangular starting from the kth superdiagonal.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Array{Int64,2}:\n 1   2\n 2  -1\n\njulia> istril(a)\nfalse\n\njulia> istril(a, 1)\ntrue\n\njulia> b = [1 0; -im -1]\n2×2 Array{Complex{Int64},2}:\n 1+0im   0+0im\n 0-1im  -1+0im\n\njulia> istril(b)\ntrue\n\njulia> istril(b, -1)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.istriu","page":"Linear Algebra","title":"LinearAlgebra.istriu","text":"istriu(A::AbstractMatrix, k::Integer = 0) -> Bool\n\nTest whether A is upper triangular starting from the kth superdiagonal.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Array{Int64,2}:\n 1   2\n 2  -1\n\njulia> istriu(a)\nfalse\n\njulia> istriu(a, -1)\ntrue\n\njulia> b = [1 im; 0 -1]\n2×2 Array{Complex{Int64},2}:\n 1+0im   0+1im\n 0+0im  -1+0im\n\njulia> istriu(b)\ntrue\n\njulia> istriu(b, 1)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.isdiag","page":"Linear Algebra","title":"LinearAlgebra.isdiag","text":"isdiag(A) -> Bool\n\nTest whether a matrix is diagonal.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Array{Int64,2}:\n 1   2\n 2  -1\n\njulia> isdiag(a)\nfalse\n\njulia> b = [im 0; 0 -im]\n2×2 Array{Complex{Int64},2}:\n 0+1im  0+0im\n 0+0im  0-1im\n\njulia> isdiag(b)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.ishermitian","page":"Linear Algebra","title":"LinearAlgebra.ishermitian","text":"ishermitian(A) -> Bool\n\nTest whether a matrix is Hermitian.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Array{Int64,2}:\n 1   2\n 2  -1\n\njulia> ishermitian(a)\ntrue\n\njulia> b = [1 im; -im 1]\n2×2 Array{Complex{Int64},2}:\n 1+0im  0+1im\n 0-1im  1+0im\n\njulia> ishermitian(b)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#Base.transpose","page":"Linear Algebra","title":"Base.transpose","text":"transpose(A)\n\nLazy transpose. Mutating the returned object should appropriately mutate A. Often, but not always, yields Transpose(A), where Transpose is a lazy transpose wrapper. Note that this operation is recursive.\n\nThis operation is intended for linear algebra usage - for general data manipulation see permutedims, which is non-recursive.\n\nExamples\n\njulia> A = [3+2im 9+2im; 8+7im  4+6im]\n2×2 Array{Complex{Int64},2}:\n 3+2im  9+2im\n 8+7im  4+6im\n\njulia> transpose(A)\n2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:\n 3+2im  8+7im\n 9+2im  4+6im\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.transpose!","page":"Linear Algebra","title":"LinearAlgebra.transpose!","text":"transpose!(dest,src)\n\nTranspose array src and store the result in the preallocated array dest, which should have a size corresponding to (size(src,2),size(src,1)). No in-place transposition is supported and unexpected results will happen if src and dest have overlapping memory regions.\n\nExamples\n\njulia> A = [3+2im 9+2im; 8+7im  4+6im]\n2×2 Array{Complex{Int64},2}:\n 3+2im  9+2im\n 8+7im  4+6im\n\njulia> B = zeros(Complex{Int64}, 2, 2)\n2×2 Array{Complex{Int64},2}:\n 0+0im  0+0im\n 0+0im  0+0im\n\njulia> transpose!(B, A);\n\njulia> B\n2×2 Array{Complex{Int64},2}:\n 3+2im  8+7im\n 9+2im  4+6im\n\njulia> A\n2×2 Array{Complex{Int64},2}:\n 3+2im  9+2im\n 8+7im  4+6im\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.Transpose","page":"Linear Algebra","title":"LinearAlgebra.Transpose","text":"Transpose\n\nLazy wrapper type for a transpose view of the underlying linear algebra object, usually an AbstractVector/AbstractMatrix, but also some Factorization, for instance. Usually, the Transpose constructor should not be called directly, use transpose instead. To materialize the view use copy.\n\nThis type is intended for linear algebra usage - for general data manipulation see permutedims.\n\nExamples\n\njulia> A = [3+2im 9+2im; 8+7im  4+6im]\n2×2 Array{Complex{Int64},2}:\n 3+2im  9+2im\n 8+7im  4+6im\n\njulia> transpose(A)\n2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:\n 3+2im  8+7im\n 9+2im  4+6im\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#Base.adjoint","page":"Linear Algebra","title":"Base.adjoint","text":"adjoint(A)\n\nLazy adjoint (conjugate transposition) (also postfix '). Note that adjoint is applied recursively to elements.\n\nThis operation is intended for linear algebra usage - for general data manipulation see permutedims.\n\nExamples\n\njulia> A = [3+2im 9+2im; 8+7im  4+6im]\n2×2 Array{Complex{Int64},2}:\n 3+2im  9+2im\n 8+7im  4+6im\n\njulia> adjoint(A)\n2×2 Adjoint{Complex{Int64},Array{Complex{Int64},2}}:\n 3-2im  8-7im\n 9-2im  4-6im\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.adjoint!","page":"Linear Algebra","title":"LinearAlgebra.adjoint!","text":"adjoint!(dest,src)\n\nConjugate transpose array src and store the result in the preallocated array dest, which should have a size corresponding to (size(src,2),size(src,1)). No in-place transposition is supported and unexpected results will happen if src and dest have overlapping memory regions.\n\nExamples\n\njulia> A = [3+2im 9+2im; 8+7im  4+6im]\n2×2 Array{Complex{Int64},2}:\n 3+2im  9+2im\n 8+7im  4+6im\n\njulia> B = zeros(Complex{Int64}, 2, 2)\n2×2 Array{Complex{Int64},2}:\n 0+0im  0+0im\n 0+0im  0+0im\n\njulia> adjoint!(B, A);\n\njulia> B\n2×2 Array{Complex{Int64},2}:\n 3-2im  8-7im\n 9-2im  4-6im\n\njulia> A\n2×2 Array{Complex{Int64},2}:\n 3+2im  9+2im\n 8+7im  4+6im\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.Adjoint","page":"Linear Algebra","title":"LinearAlgebra.Adjoint","text":"Adjoint\n\nLazy wrapper type for an adjoint view of the underlying linear algebra object, usually an AbstractVector/AbstractMatrix, but also some Factorization, for instance. Usually, the Adjoint constructor should not be called directly, use adjoint instead. To materialize the view use copy.\n\nThis type is intended for linear algebra usage - for general data manipulation see permutedims.\n\nExamples\n\njulia> A = [3+2im 9+2im; 8+7im  4+6im]\n2×2 Array{Complex{Int64},2}:\n 3+2im  9+2im\n 8+7im  4+6im\n\njulia> adjoint(A)\n2×2 Adjoint{Complex{Int64},Array{Complex{Int64},2}}:\n 3-2im  8-7im\n 9-2im  4-6im\n\n\n\n\n\n","category":"type"},{"location":"stdlib/LinearAlgebra.html#Base.copy-Tuple{Union{Adjoint, Transpose}}","page":"Linear Algebra","title":"Base.copy","text":"copy(A::Transpose)\ncopy(A::Adjoint)\n\nEagerly evaluate the lazy matrix transpose/adjoint. Note that the transposition is applied recursively to elements.\n\nThis operation is intended for linear algebra usage - for general data manipulation see permutedims, which is non-recursive.\n\nExamples\n\njulia> A = [1 2im; -3im 4]\n2×2 Array{Complex{Int64},2}:\n 1+0im  0+2im\n 0-3im  4+0im\n\njulia> T = transpose(A)\n2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:\n 1+0im  0-3im\n 0+2im  4+0im\n\njulia> copy(T)\n2×2 Array{Complex{Int64},2}:\n 1+0im  0-3im\n 0+2im  4+0im\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.stride1","page":"Linear Algebra","title":"LinearAlgebra.stride1","text":"stride1(A) -> Int\n\nReturn the distance between successive array elements in dimension 1 in units of element size.\n\nExamples\n\njulia> A = [1,2,3,4]\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> LinearAlgebra.stride1(A)\n1\n\njulia> B = view(A, 2:2:4)\n2-element view(::Array{Int64,1}, 2:2:4) with eltype Int64:\n 2\n 4\n\njulia> LinearAlgebra.stride1(B)\n2\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.checksquare","page":"Linear Algebra","title":"LinearAlgebra.checksquare","text":"LinearAlgebra.checksquare(A)\n\nCheck that a matrix is square, then return its common dimension. For multiple arguments, return a vector.\n\nExamples\n\njulia> A = fill(1, (4,4)); B = fill(1, (5,5));\n\njulia> LinearAlgebra.checksquare(A, B)\n2-element Array{Int64,1}:\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.peakflops","page":"Linear Algebra","title":"LinearAlgebra.peakflops","text":"LinearAlgebra.peakflops(n::Integer=2000; parallel::Bool=false)\n\npeakflops computes the peak flop rate of the computer by using double precision gemm!. By default, if no arguments are specified, it multiplies a matrix of size n x n, where n = 2000. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with BLAS.set_num_threads(n).\n\nIf the keyword argument parallel is set to true, peakflops is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument n still refers to the size of the problem that is solved on each processor.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1. In Julia 1.0 it is available from the standard library InteractiveUtils.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#Low-level-matrix-operations-1","page":"Linear Algebra","title":"Low-level matrix operations","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix.  This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with ! below (e.g. mul!) according to the usual Julia convention.","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"LinearAlgebra.mul!\nLinearAlgebra.lmul!\nLinearAlgebra.rmul!\nLinearAlgebra.ldiv!\nLinearAlgebra.rdiv!","category":"page"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.mul!","page":"Linear Algebra","title":"LinearAlgebra.mul!","text":"mul!(Y, A, B) -> Y\n\nCalculates the matrix-matrix or matrix-vector product AB and stores the result in Y, overwriting the existing value of Y. Note that Y must not be aliased with either A or B.\n\nExamples\n\njulia> A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); mul!(Y, A, B);\n\njulia> Y\n2×2 Array{Float64,2}:\n 3.0  3.0\n 7.0  7.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.lmul!","page":"Linear Algebra","title":"LinearAlgebra.lmul!","text":"lmul!(a::Number, B::AbstractArray)\n\nScale an array B by a scalar a overwriting B in-place.  Use rmul! to multiply scalar from right.  The scaling operation respects the semantics of the multiplication * between a and an element of B.  In particular, this also applies to multiplication involving non-finite numbers such as NaN and ±Inf.\n\ncompat: Julia 1.1\nPrior to Julia 1.1, NaN and ±Inf entries in B were treated inconsistently.\n\nExamples\n\njulia> B = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> lmul!(2, B)\n2×2 Array{Int64,2}:\n 2  4\n 6  8\n\njulia> lmul!(0.0, [Inf])\n1-element Array{Float64,1}:\n NaN\n\n\n\n\n\nlmul!(A, B)\n\nCalculate the matrix-matrix product AB, overwriting B, and return the result.\n\nExamples\n\njulia> B = [0 1; 1 0];\n\njulia> A = LinearAlgebra.UpperTriangular([1 2; 0 3]);\n\njulia> LinearAlgebra.lmul!(A, B);\n\njulia> B\n2×2 Array{Int64,2}:\n 2  1\n 3  0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.rmul!","page":"Linear Algebra","title":"LinearAlgebra.rmul!","text":"rmul!(A::AbstractArray, b::Number)\n\nScale an array A by a scalar b overwriting A in-place.  Use lmul! to multiply scalar from left.  The scaling operation respects the semantics of the multiplication * between an element of A and b.  In particular, this also applies to multiplication involving non-finite numbers such as NaN and ±Inf.\n\ncompat: Julia 1.1\nPrior to Julia 1.1, NaN and ±Inf entries in A were treated inconsistently.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rmul!(A, 2)\n2×2 Array{Int64,2}:\n 2  4\n 6  8\n\njulia> rmul!([NaN], 0.0)\n1-element Array{Float64,1}:\n NaN\n\n\n\n\n\nrmul!(A, B)\n\nCalculate the matrix-matrix product AB, overwriting A, and return the result.\n\nExamples\n\njulia> A = [0 1; 1 0];\n\njulia> B = LinearAlgebra.UpperTriangular([1 2; 0 3]);\n\njulia> LinearAlgebra.rmul!(A, B);\n\njulia> A\n2×2 Array{Int64,2}:\n 0  3\n 1  2\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.ldiv!","page":"Linear Algebra","title":"LinearAlgebra.ldiv!","text":"ldiv!(Y, A, B) -> Y\n\nCompute A \\ B in-place and store the result in Y, returning the result.\n\nThe argument A should not be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by factorize or cholesky). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., lu!), and performance-critical situations requiring ldiv! usually also require fine-grained control over the factorization of A.\n\nExamples\n\njulia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];\n\njulia> X = [1; 2.5; 3];\n\njulia> Y = zero(X);\n\njulia> ldiv!(Y, qr(A), X);\n\njulia> Y\n3-element Array{Float64,1}:\n  0.7128099173553719\n -0.051652892561983674\n  0.10020661157024757\n\njulia> A\\X\n3-element Array{Float64,1}:\n  0.7128099173553719\n -0.05165289256198333\n  0.10020661157024785\n\n\n\n\n\nldiv!(A, B)\n\nCompute A \\ B in-place and overwriting B to store the result.\n\nThe argument A should not be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by factorize or cholesky). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., lu!), and performance-critical situations requiring ldiv! usually also require fine-grained control over the factorization of A.\n\nExamples\n\njulia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];\n\njulia> X = [1; 2.5; 3];\n\njulia> Y = copy(X);\n\njulia> ldiv!(qr(A), X);\n\njulia> X\n3-element Array{Float64,1}:\n  0.7128099173553719\n -0.051652892561983674\n  0.10020661157024757\n\njulia> A\\Y\n3-element Array{Float64,1}:\n  0.7128099173553719\n -0.05165289256198333\n  0.10020661157024785\n\n\n\n\n\nldiv!(a::Number, B::AbstractArray)\n\nDivide each entry in an array B by a scalar a overwriting B in-place.  Use rdiv! to divide scalar from right.\n\nExamples\n\njulia> B = [1.0 2.0; 3.0 4.0]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> ldiv!(2.0, B)\n2×2 Array{Float64,2}:\n 0.5  1.0\n 1.5  2.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.rdiv!","page":"Linear Algebra","title":"LinearAlgebra.rdiv!","text":"rdiv!(A, B)\n\nCompute A / B in-place and overwriting A to store the result.\n\nThe argument B should not be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by factorize or cholesky). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., lu!), and performance-critical situations requiring rdiv! usually also require fine-grained control over the factorization of B.\n\n\n\n\n\nrdiv!(A::AbstractArray, b::Number)\n\nDivide each entry in an array A by a scalar b overwriting A in-place.  Use ldiv! to divide scalar from left.\n\nExamples\n\njulia> A = [1.0 2.0; 3.0 4.0]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> rdiv!(A, 2.0)\n2×2 Array{Float64,2}:\n 0.5  1.0\n 1.5  2.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#BLAS-Functions-1","page":"Linear Algebra","title":"BLAS Functions","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"In Julia (as in much of scientific computation), dense linear-algebra operations are based on the LAPACK library, which in turn is built on top of basic linear-algebra building-blocks known as the BLAS. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"LinearAlgebra.BLAS provides wrappers for some of the BLAS functions. Those BLAS functions that overwrite one of the input arrays have names ending in '!'.  Usually, a BLAS function has four methods defined, for Float64, Float32, ComplexF64, and ComplexF32 arrays.","category":"page"},{"location":"stdlib/LinearAlgebra.html#stdlib-blas-chars-1","page":"Linear Algebra","title":"BLAS Character Arguments","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Many BLAS functions accept arguments that determine whether to transpose an argument (trans), which triangle of a matrix to reference (uplo or ul), whether the diagonal of a triangular matrix can be assumed to be all ones (dA) or which side of a matrix multiplication the input argument belongs on (side). The possibilities are:","category":"page"},{"location":"stdlib/LinearAlgebra.html#stdlib-blas-side-1","page":"Linear Algebra","title":"Multplication Order","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"side Meaning\n'L' The argument goes on the left side of a matrix-matrix operation.\n'R' The argument goes on the right side of a matrix-matrix operation.","category":"page"},{"location":"stdlib/LinearAlgebra.html#stdlib-blas-uplo-1","page":"Linear Algebra","title":"Triangle Referencing","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"uplo/ul Meaning\n'U' Only the upper triangle of the matrix will be used.\n'L' Only the lower triangle of the matrix will be used.","category":"page"},{"location":"stdlib/LinearAlgebra.html#stdlib-blas-trans-1","page":"Linear Algebra","title":"Transposition Operation","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"trans/tX Meaning\n'N' The input matrix X is not transposed or conjugated.\n'T' The input matrix X will be transposed.\n'C' The input matrix X will be conjugated and transposed.","category":"page"},{"location":"stdlib/LinearAlgebra.html#stdlib-blas-diag-1","page":"Linear Algebra","title":"Unit Diagonal","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"diag/dX Meaning\n'N' The diagonal values of the matrix X will be read.\n'U' The diagonal of the matrix X is assumed to be all ones.","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"LinearAlgebra.BLAS\nLinearAlgebra.BLAS.dotu\nLinearAlgebra.BLAS.dotc\nLinearAlgebra.BLAS.blascopy!\nLinearAlgebra.BLAS.nrm2\nLinearAlgebra.BLAS.asum\nLinearAlgebra.axpy!\nLinearAlgebra.BLAS.scal!\nLinearAlgebra.BLAS.scal\nLinearAlgebra.BLAS.iamax\nLinearAlgebra.BLAS.ger!\nLinearAlgebra.BLAS.syr!\nLinearAlgebra.BLAS.syrk!\nLinearAlgebra.BLAS.syrk\nLinearAlgebra.BLAS.her!\nLinearAlgebra.BLAS.herk!\nLinearAlgebra.BLAS.herk\nLinearAlgebra.BLAS.gbmv!\nLinearAlgebra.BLAS.gbmv\nLinearAlgebra.BLAS.sbmv!\nLinearAlgebra.BLAS.sbmv(::Any, ::Any, ::Any, ::Any, ::Any)\nLinearAlgebra.BLAS.sbmv(::Any, ::Any, ::Any, ::Any)\nLinearAlgebra.BLAS.gemm!\nLinearAlgebra.BLAS.gemm(::Any, ::Any, ::Any, ::Any, ::Any)\nLinearAlgebra.BLAS.gemm(::Any, ::Any, ::Any, ::Any)\nLinearAlgebra.BLAS.gemv!\nLinearAlgebra.BLAS.gemv(::Any, ::Any, ::Any, ::Any)\nLinearAlgebra.BLAS.gemv(::Any, ::Any, ::Any)\nLinearAlgebra.BLAS.symm!\nLinearAlgebra.BLAS.symm(::Any, ::Any, ::Any, ::Any, ::Any)\nLinearAlgebra.BLAS.symm(::Any, ::Any, ::Any, ::Any)\nLinearAlgebra.BLAS.symv!\nLinearAlgebra.BLAS.symv(::Any, ::Any, ::Any, ::Any)\nLinearAlgebra.BLAS.symv(::Any, ::Any, ::Any)\nLinearAlgebra.BLAS.trmm!\nLinearAlgebra.BLAS.trmm\nLinearAlgebra.BLAS.trsm!\nLinearAlgebra.BLAS.trsm\nLinearAlgebra.BLAS.trmv!\nLinearAlgebra.BLAS.trmv\nLinearAlgebra.BLAS.trsv!\nLinearAlgebra.BLAS.trsv\nLinearAlgebra.BLAS.set_num_threads\nLinearAlgebra.I","category":"page"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS","page":"Linear Algebra","title":"LinearAlgebra.BLAS","text":"Interface to BLAS subroutines.\n\n\n\n\n\n","category":"module"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.dotu","page":"Linear Algebra","title":"LinearAlgebra.BLAS.dotu","text":"dotu(n, X, incx, Y, incy)\n\nDot function for two complex vectors consisting of n elements of array X with stride incx and n elements of array Y with stride incy.\n\nExamples\n\njulia> BLAS.dotu(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)\n-10.0 + 10.0im\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.dotc","page":"Linear Algebra","title":"LinearAlgebra.BLAS.dotc","text":"dotc(n, X, incx, U, incy)\n\nDot function for two complex vectors, consisting of n elements of array X with stride incx and n elements of array U with stride incy, conjugating the first vector.\n\nExamples\n\njulia> BLAS.dotc(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)\n10.0 - 10.0im\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.blascopy!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.blascopy!","text":"blascopy!(n, X, incx, Y, incy)\n\nCopy n elements of array X with stride incx to array Y with stride incy. Returns Y.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.nrm2","page":"Linear Algebra","title":"LinearAlgebra.BLAS.nrm2","text":"nrm2(n, X, incx)\n\n2-norm of a vector consisting of n elements of array X with stride incx.\n\nExamples\n\njulia> BLAS.nrm2(4, fill(1.0, 8), 2)\n2.0\n\njulia> BLAS.nrm2(1, fill(1.0, 8), 2)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.asum","page":"Linear Algebra","title":"LinearAlgebra.BLAS.asum","text":"asum(n, X, incx)\n\nSum of the absolute values of the first n elements of array X with stride incx.\n\nExamples\n\njulia> BLAS.asum(5, fill(1.0im, 10), 2)\n5.0\n\njulia> BLAS.asum(2, fill(1.0im, 10), 5)\n2.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.axpy!","page":"Linear Algebra","title":"LinearAlgebra.axpy!","text":"axpy!(a, X, Y)\n\nOverwrite Y with a*X + Y, where a is a scalar. Return Y.\n\nExamples\n\njulia> x = [1; 2; 3];\n\njulia> y = [4; 5; 6];\n\njulia> BLAS.axpy!(2, x, y)\n3-element Array{Int64,1}:\n  6\n  9\n 12\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.scal!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.scal!","text":"scal!(n, a, X, incx)\n\nOverwrite X with a*X for the first n elements of array X with stride incx. Returns X.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.scal","page":"Linear Algebra","title":"LinearAlgebra.BLAS.scal","text":"scal(n, a, X, incx)\n\nReturn X scaled by a for the first n elements of array X with stride incx.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.iamax","page":"Linear Algebra","title":"LinearAlgebra.BLAS.iamax","text":"iamax(n, dx, incx)\niamax(dx)\n\nFind the index of the element of dx with the maximum absolute value. n is the length of dx, and incx is the stride. If n and incx are not provided, they assume default values of n=length(dx) and incx=stride1(dx).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.ger!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.ger!","text":"ger!(alpha, x, y, A)\n\nRank-1 update of the matrix A with vectors x and y as alpha*x*y' + A.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.syr!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.syr!","text":"syr!(uplo, alpha, x, A)\n\nRank-1 update of the symmetric matrix A with vector x as alpha*x*transpose(x) + A. uplo controls which triangle of A is updated. Returns A.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.syrk!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.syrk!","text":"syrk!(uplo, trans, alpha, A, beta, C)\n\nRank-k update of the symmetric matrix C as alpha*A*transpose(A) + beta*C or alpha*transpose(A)*A + beta*C according to trans. Only the uplo triangle of C is used. Returns C.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.syrk","page":"Linear Algebra","title":"LinearAlgebra.BLAS.syrk","text":"syrk(uplo, trans, alpha, A)\n\nReturns either the upper triangle or the lower triangle of A, according to uplo, of alpha*A*transpose(A) or alpha*transpose(A)*A, according to trans.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.her!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.her!","text":"her!(uplo, alpha, x, A)\n\nMethods for complex arrays only. Rank-1 update of the Hermitian matrix A with vector x as alpha*x*x' + A. uplo controls which triangle of A is updated. Returns A.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.herk!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.herk!","text":"herk!(uplo, trans, alpha, A, beta, C)\n\nMethods for complex arrays only. Rank-k update of the Hermitian matrix C as alpha*A*A' + beta*C or alpha*A'*A + beta*C according to trans. Only the uplo triangle of C is updated. Returns C.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.herk","page":"Linear Algebra","title":"LinearAlgebra.BLAS.herk","text":"herk(uplo, trans, alpha, A)\n\nMethods for complex arrays only. Returns the uplo triangle of alpha*A*A' or alpha*A'*A, according to trans.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gbmv!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.gbmv!","text":"gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)\n\nUpdate vector y as alpha*A*x + beta*y or alpha*A'*x + beta*y according to trans. The matrix A is a general band matrix of dimension m by size(A,2) with kl sub-diagonals and ku super-diagonals. alpha and beta are scalars. Return the updated y.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gbmv","page":"Linear Algebra","title":"LinearAlgebra.BLAS.gbmv","text":"gbmv(trans, m, kl, ku, alpha, A, x)\n\nReturn alpha*A*x or alpha*A'*x according to trans. The matrix A is a general band matrix of dimension m by size(A,2) with kl sub-diagonals and ku super-diagonals, and alpha is a scalar.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.sbmv!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.sbmv!","text":"sbmv!(uplo, k, alpha, A, x, beta, y)\n\nUpdate vector y as alpha*A*x + beta*y where A is a a symmetric band matrix of order size(A,2) with k super-diagonals stored in the argument A. The storage layout for A is described the reference BLAS module, level-2 BLAS at http://www.netlib.org/lapack/explore-html/. Only the uplo triangle of A is used.\n\nReturn the updated y.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.sbmv-NTuple{5,Any}","page":"Linear Algebra","title":"LinearAlgebra.BLAS.sbmv","text":"sbmv(uplo, k, alpha, A, x)\n\nReturn alpha*A*x where A is a symmetric band matrix of order size(A,2) with k super-diagonals stored in the argument A. Only the uplo triangle of A is used.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.sbmv-NTuple{4,Any}","page":"Linear Algebra","title":"LinearAlgebra.BLAS.sbmv","text":"sbmv(uplo, k, A, x)\n\nReturn A*x where A is a symmetric band matrix of order size(A,2) with k super-diagonals stored in the argument A. Only the uplo triangle of A is used.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemm!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.gemm!","text":"gemm!(tA, tB, alpha, A, B, beta, C)\n\nUpdate C as alpha*A*B + beta*C or the other three variants according to tA and tB. Return the updated C.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemm-NTuple{5,Any}","page":"Linear Algebra","title":"LinearAlgebra.BLAS.gemm","text":"gemm(tA, tB, alpha, A, B)\n\nReturn alpha*A*B or the other three variants according to tA and tB.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemm-NTuple{4,Any}","page":"Linear Algebra","title":"LinearAlgebra.BLAS.gemm","text":"gemm(tA, tB, A, B)\n\nReturn A*B or the other three variants according to tA and tB.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemv!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.gemv!","text":"gemv!(tA, alpha, A, x, beta, y)\n\nUpdate the vector y as alpha*A*x + beta*y or alpha*A'x + beta*y according to tA. alpha and beta are scalars. Return the updated y.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemv-NTuple{4,Any}","page":"Linear Algebra","title":"LinearAlgebra.BLAS.gemv","text":"gemv(tA, alpha, A, x)\n\nReturn alpha*A*x or alpha*A'x according to tA. alpha is a scalar.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemv-Tuple{Any,Any,Any}","page":"Linear Algebra","title":"LinearAlgebra.BLAS.gemv","text":"gemv(tA, A, x)\n\nReturn A*x or A'x according to tA.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symm!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.symm!","text":"symm!(side, ul, alpha, A, B, beta, C)\n\nUpdate C as alpha*A*B + beta*C or alpha*B*A + beta*C according to side. A is assumed to be symmetric. Only the ul triangle of A is used. Return the updated C.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symm-NTuple{5,Any}","page":"Linear Algebra","title":"LinearAlgebra.BLAS.symm","text":"symm(side, ul, alpha, A, B)\n\nReturn alpha*A*B or alpha*B*A according to side. A is assumed to be symmetric. Only the ul triangle of A is used.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symm-NTuple{4,Any}","page":"Linear Algebra","title":"LinearAlgebra.BLAS.symm","text":"symm(side, ul, A, B)\n\nReturn A*B or B*A according to side. A is assumed to be symmetric. Only the ul triangle of A is used.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symv!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.symv!","text":"symv!(ul, alpha, A, x, beta, y)\n\nUpdate the vector y as alpha*A*x + beta*y. A is assumed to be symmetric. Only the ul triangle of A is used. alpha and beta are scalars. Return the updated y.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symv-NTuple{4,Any}","page":"Linear Algebra","title":"LinearAlgebra.BLAS.symv","text":"symv(ul, alpha, A, x)\n\nReturn alpha*A*x. A is assumed to be symmetric. Only the ul triangle of A is used. alpha is a scalar.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symv-Tuple{Any,Any,Any}","page":"Linear Algebra","title":"LinearAlgebra.BLAS.symv","text":"symv(ul, A, x)\n\nReturn A*x. A is assumed to be symmetric. Only the ul triangle of A is used.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trmm!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.trmm!","text":"trmm!(side, ul, tA, dA, alpha, A, B)\n\nUpdate B as alpha*A*B or one of the other three variants determined by side and tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones. Returns the updated B.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trmm","page":"Linear Algebra","title":"LinearAlgebra.BLAS.trmm","text":"trmm(side, ul, tA, dA, alpha, A, B)\n\nReturns alpha*A*B or one of the other three variants determined by side and tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trsm!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.trsm!","text":"trsm!(side, ul, tA, dA, alpha, A, B)\n\nOverwrite B with the solution to A*X = alpha*B or one of the other three variants determined by side and tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones. Returns the updated B.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trsm","page":"Linear Algebra","title":"LinearAlgebra.BLAS.trsm","text":"trsm(side, ul, tA, dA, alpha, A, B)\n\nReturn the solution to A*X = alpha*B or one of the other three variants determined by determined by side and tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trmv!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.trmv!","text":"trmv!(ul, tA, dA, A, b)\n\nReturn op(A)*b, where op is determined by tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones. The multiplication occurs in-place on b.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trmv","page":"Linear Algebra","title":"LinearAlgebra.BLAS.trmv","text":"trmv(ul, tA, dA, A, b)\n\nReturn op(A)*b, where op is determined by tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trsv!","page":"Linear Algebra","title":"LinearAlgebra.BLAS.trsv!","text":"trsv!(ul, tA, dA, A, b)\n\nOverwrite b with the solution to A*x = b or one of the other two variants determined by tA and ul. dA determines if the diagonal values are read or are assumed to be all ones. Return the updated b.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trsv","page":"Linear Algebra","title":"LinearAlgebra.BLAS.trsv","text":"trsv(ul, tA, dA, A, b)\n\nReturn the solution to A*x = b or one of the other two variants determined by tA and ul. dA determines if the diagonal values are read or are assumed to be all ones.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.set_num_threads","page":"Linear Algebra","title":"LinearAlgebra.BLAS.set_num_threads","text":"set_num_threads(n)\n\nSet the number of threads the BLAS library should use.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.I","page":"Linear Algebra","title":"LinearAlgebra.I","text":"I\n\nAn object of type UniformScaling, representing an identity matrix of any size.\n\nExamples\n\njulia> fill(1, (5,6)) * I == fill(1, (5,6))\ntrue\n\njulia> [1 2im 3; 1im 2 3] * I\n2×3 Array{Complex{Int64},2}:\n 1+0im  0+2im  3+0im\n 0+1im  2+0im  3+0im\n\n\n\n\n\n","category":"constant"},{"location":"stdlib/LinearAlgebra.html#LAPACK-Functions-1","page":"Linear Algebra","title":"LAPACK Functions","text":"","category":"section"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"LinearAlgebra.LAPACK provides wrappers for some of the LAPACK functions for linear algebra.  Those functions that overwrite one of the input arrays have names ending in '!'.","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Usually a function has 4 methods defined, one each for Float64, Float32, ComplexF64 and ComplexF32 arrays.","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Note that the LAPACK API provided by Julia can and will change in the future. Since this API is not user-facing, there is no commitment to support/deprecate this specific set of functions in future releases.","category":"page"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"LinearAlgebra.LAPACK\nLinearAlgebra.LAPACK.gbtrf!\nLinearAlgebra.LAPACK.gbtrs!\nLinearAlgebra.LAPACK.gebal!\nLinearAlgebra.LAPACK.gebak!\nLinearAlgebra.LAPACK.gebrd!\nLinearAlgebra.LAPACK.gelqf!\nLinearAlgebra.LAPACK.geqlf!\nLinearAlgebra.LAPACK.geqrf!\nLinearAlgebra.LAPACK.geqp3!\nLinearAlgebra.LAPACK.gerqf!\nLinearAlgebra.LAPACK.geqrt!\nLinearAlgebra.LAPACK.geqrt3!\nLinearAlgebra.LAPACK.getrf!\nLinearAlgebra.LAPACK.tzrzf!\nLinearAlgebra.LAPACK.ormrz!\nLinearAlgebra.LAPACK.gels!\nLinearAlgebra.LAPACK.gesv!\nLinearAlgebra.LAPACK.getrs!\nLinearAlgebra.LAPACK.getri!\nLinearAlgebra.LAPACK.gesvx!\nLinearAlgebra.LAPACK.gelsd!\nLinearAlgebra.LAPACK.gelsy!\nLinearAlgebra.LAPACK.gglse!\nLinearAlgebra.LAPACK.geev!\nLinearAlgebra.LAPACK.gesdd!\nLinearAlgebra.LAPACK.gesvd!\nLinearAlgebra.LAPACK.ggsvd!\nLinearAlgebra.LAPACK.ggsvd3!\nLinearAlgebra.LAPACK.geevx!\nLinearAlgebra.LAPACK.ggev!\nLinearAlgebra.LAPACK.gtsv!\nLinearAlgebra.LAPACK.gttrf!\nLinearAlgebra.LAPACK.gttrs!\nLinearAlgebra.LAPACK.orglq!\nLinearAlgebra.LAPACK.orgqr!\nLinearAlgebra.LAPACK.orgql!\nLinearAlgebra.LAPACK.orgrq!\nLinearAlgebra.LAPACK.ormlq!\nLinearAlgebra.LAPACK.ormqr!\nLinearAlgebra.LAPACK.ormql!\nLinearAlgebra.LAPACK.ormrq!\nLinearAlgebra.LAPACK.gemqrt!\nLinearAlgebra.LAPACK.posv!\nLinearAlgebra.LAPACK.potrf!\nLinearAlgebra.LAPACK.potri!\nLinearAlgebra.LAPACK.potrs!\nLinearAlgebra.LAPACK.pstrf!\nLinearAlgebra.LAPACK.ptsv!\nLinearAlgebra.LAPACK.pttrf!\nLinearAlgebra.LAPACK.pttrs!\nLinearAlgebra.LAPACK.trtri!\nLinearAlgebra.LAPACK.trtrs!\nLinearAlgebra.LAPACK.trcon!\nLinearAlgebra.LAPACK.trevc!\nLinearAlgebra.LAPACK.trrfs!\nLinearAlgebra.LAPACK.stev!\nLinearAlgebra.LAPACK.stebz!\nLinearAlgebra.LAPACK.stegr!\nLinearAlgebra.LAPACK.stein!\nLinearAlgebra.LAPACK.syconv!\nLinearAlgebra.LAPACK.sysv!\nLinearAlgebra.LAPACK.sytrf!\nLinearAlgebra.LAPACK.sytri!\nLinearAlgebra.LAPACK.sytrs!\nLinearAlgebra.LAPACK.hesv!\nLinearAlgebra.LAPACK.hetrf!\nLinearAlgebra.LAPACK.hetri!\nLinearAlgebra.LAPACK.hetrs!\nLinearAlgebra.LAPACK.syev!\nLinearAlgebra.LAPACK.syevr!\nLinearAlgebra.LAPACK.sygvd!\nLinearAlgebra.LAPACK.bdsqr!\nLinearAlgebra.LAPACK.bdsdc!\nLinearAlgebra.LAPACK.gecon!\nLinearAlgebra.LAPACK.gehrd!\nLinearAlgebra.LAPACK.orghr!\nLinearAlgebra.LAPACK.gees!\nLinearAlgebra.LAPACK.gges!\nLinearAlgebra.LAPACK.trexc!\nLinearAlgebra.LAPACK.trsen!\nLinearAlgebra.LAPACK.tgsen!\nLinearAlgebra.LAPACK.trsyl!","category":"page"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK","page":"Linear Algebra","title":"LinearAlgebra.LAPACK","text":"Interfaces to LAPACK subroutines.\n\n\n\n\n\n","category":"module"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gbtrf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gbtrf!","text":"gbtrf!(kl, ku, m, AB) -> (AB, ipiv)\n\nCompute the LU factorization of a banded matrix AB. kl is the first subdiagonal containing a nonzero band, ku is the last superdiagonal containing one, and m is the first dimension of the matrix AB. Returns the LU factorization in-place and ipiv, the vector of pivots used.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gbtrs!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gbtrs!","text":"gbtrs!(trans, kl, ku, m, AB, ipiv, B)\n\nSolve the equation AB * X = B. trans determines the orientation of AB. It may be N (no transpose), T (transpose), or C (conjugate transpose). kl is the first subdiagonal containing a nonzero band, ku is the last superdiagonal containing one, and m is the first dimension of the matrix AB. ipiv is the vector of pivots returned from gbtrf!. Returns the vector or matrix X, overwriting B in-place.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gebal!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gebal!","text":"gebal!(job, A) -> (ilo, ihi, scale)\n\nBalance the matrix A before computing its eigensystem or Schur factorization. job can be one of N (A will not be permuted or scaled), P (A will only be permuted), S (A will only be scaled), or B (A will be both permuted and scaled). Modifies A in-place and returns ilo, ihi, and scale. If permuting was turned on, A[i,j] = 0 if j > i and 1 < j < ilo or j > ihi. scale contains information about the scaling/permutations performed.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gebak!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gebak!","text":"gebak!(job, side, ilo, ihi, scale, V)\n\nTransform the eigenvectors V of a matrix balanced using gebal! to the unscaled/unpermuted eigenvectors of the original matrix. Modifies V in-place. side can be L (left eigenvectors are transformed) or R (right eigenvectors are transformed).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gebrd!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gebrd!","text":"gebrd!(A) -> (A, d, e, tauq, taup)\n\nReduce A in-place to bidiagonal form A = QBP'. Returns A, containing the bidiagonal matrix B; d, containing the diagonal elements of B; e, containing the off-diagonal elements of B; tauq, containing the elementary reflectors representing Q; and taup, containing the elementary reflectors representing P.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gelqf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gelqf!","text":"gelqf!(A, tau)\n\nCompute the LQ factorization of A, A = LQ. tau contains scalars which parameterize the elementary reflectors of the factorization. tau must have length greater than or equal to the smallest dimension of A.\n\nReturns A and tau modified in-place.\n\n\n\n\n\ngelqf!(A) -> (A, tau)\n\nCompute the LQ factorization of A, A = LQ.\n\nReturns A, modified in-place, and tau, which contains scalars which parameterize the elementary reflectors of the factorization.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqlf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.geqlf!","text":"geqlf!(A, tau)\n\nCompute the QL factorization of A, A = QL. tau contains scalars which parameterize the elementary reflectors of the factorization. tau must have length greater than or equal to the smallest dimension of A.\n\nReturns A and tau modified in-place.\n\n\n\n\n\ngeqlf!(A) -> (A, tau)\n\nCompute the QL factorization of A, A = QL.\n\nReturns A, modified in-place, and tau, which contains scalars which parameterize the elementary reflectors of the factorization.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqrf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.geqrf!","text":"geqrf!(A, tau)\n\nCompute the QR factorization of A, A = QR. tau contains scalars which parameterize the elementary reflectors of the factorization. tau must have length greater than or equal to the smallest dimension of A.\n\nReturns A and tau modified in-place.\n\n\n\n\n\ngeqrf!(A) -> (A, tau)\n\nCompute the QR factorization of A, A = QR.\n\nReturns A, modified in-place, and tau, which contains scalars which parameterize the elementary reflectors of the factorization.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqp3!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.geqp3!","text":"geqp3!(A, jpvt, tau)\n\nCompute the pivoted QR factorization of A, AP = QR using BLAS level 3. P is a pivoting matrix, represented by jpvt. tau stores the elementary reflectors. jpvt must have length length greater than or equal to n if A is an (m x n) matrix. tau must have length greater than or equal to the smallest dimension of A.\n\nA, jpvt, and tau are modified in-place.\n\n\n\n\n\ngeqp3!(A, jpvt) -> (A, jpvt, tau)\n\nCompute the pivoted QR factorization of A, AP = QR using BLAS level 3. P is a pivoting matrix, represented by jpvt. jpvt must have length greater than or equal to n if A is an (m x n) matrix.\n\nReturns A and jpvt, modified in-place, and tau, which stores the elementary reflectors.\n\n\n\n\n\ngeqp3!(A) -> (A, jpvt, tau)\n\nCompute the pivoted QR factorization of A, AP = QR using BLAS level 3.\n\nReturns A, modified in-place, jpvt, which represents the pivoting matrix P, and tau, which stores the elementary reflectors.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gerqf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gerqf!","text":"gerqf!(A, tau)\n\nCompute the RQ factorization of A, A = RQ. tau contains scalars which parameterize the elementary reflectors of the factorization. tau must have length greater than or equal to the smallest dimension of A.\n\nReturns A and tau modified in-place.\n\n\n\n\n\ngerqf!(A) -> (A, tau)\n\nCompute the RQ factorization of A, A = RQ.\n\nReturns A, modified in-place, and tau, which contains scalars which parameterize the elementary reflectors of the factorization.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqrt!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.geqrt!","text":"geqrt!(A, T)\n\nCompute the blocked QR factorization of A, A = QR. T contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of T sets the block size and it must be between 1 and n. The second dimension of T must equal the smallest dimension of A.\n\nReturns A and T modified in-place.\n\n\n\n\n\ngeqrt!(A, nb) -> (A, T)\n\nCompute the blocked QR factorization of A, A = QR. nb sets the block size and it must be between 1 and n, the second dimension of A.\n\nReturns A, modified in-place, and T, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqrt3!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.geqrt3!","text":"geqrt3!(A, T)\n\nRecursively computes the blocked QR factorization of A, A = QR. T contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.  The first dimension of T sets the block size and it must be between 1 and n. The second dimension of T must equal the smallest dimension of A.\n\nReturns A and T modified in-place.\n\n\n\n\n\ngeqrt3!(A) -> (A, T)\n\nRecursively computes the blocked QR factorization of A, A = QR.\n\nReturns A, modified in-place, and T, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.getrf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.getrf!","text":"getrf!(A) -> (A, ipiv, info)\n\nCompute the pivoted LU factorization of A, A = LU.\n\nReturns A, modified in-place, ipiv, the pivoting information, and an info code which indicates success (info = 0), a singular value in U (info = i, in which case U[i,i] is singular), or an error code (info < 0).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.tzrzf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.tzrzf!","text":"tzrzf!(A) -> (A, tau)\n\nTransforms the upper trapezoidal matrix A to upper triangular form in-place. Returns A and tau, the scalar parameters for the elementary reflectors of the transformation.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormrz!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.ormrz!","text":"ormrz!(side, trans, A, tau, C)\n\nMultiplies the matrix C by Q from the transformation supplied by tzrzf!. Depending on side or trans the multiplication can be left-sided (side = L, Q*C) or right-sided (side = R, C*Q) and Q can be unmodified (trans = N), transposed (trans = T), or conjugate transposed (trans = C). Returns matrix C which is modified in-place with the result of the multiplication.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gels!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gels!","text":"gels!(trans, A, B) -> (F, B, ssr)\n\nSolves the linear equation A * X = B, transpose(A) * X = B, or adjoint(A) * X = B using a QR or LQ factorization. Modifies the matrix/vector B in place with the solution. A is overwritten with its QR or LQ factorization. trans may be one of N (no modification), T (transpose), or C (conjugate transpose). gels! searches for the minimum norm/least squares solution. A may be under or over determined. The solution is returned in B.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gesv!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gesv!","text":"gesv!(A, B) -> (B, A, ipiv)\n\nSolves the linear equation A * X = B where A is a square matrix using the LU factorization of A. A is overwritten with its LU factorization and B is overwritten with the solution X. ipiv contains the pivoting information for the LU factorization of A.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.getrs!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.getrs!","text":"getrs!(trans, A, ipiv, B)\n\nSolves the linear equation A * X = B, transpose(A) * X = B, or adjoint(A) * X = B for square A. Modifies the matrix/vector B in place with the solution. A is the LU factorization from getrf!, with ipiv the pivoting information. trans may be one of N (no modification), T (transpose), or C (conjugate transpose).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.getri!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.getri!","text":"getri!(A, ipiv)\n\nComputes the inverse of A, using its LU factorization found by getrf!. ipiv is the pivot information output and A contains the LU factorization of getrf!. A is overwritten with its inverse.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gesvx!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gesvx!","text":"gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -> (X, equed, R, C, B, rcond, ferr, berr, work)\n\nSolves the linear equation A * X = B (trans = N), transpose(A) * X = B (trans = T), or adjoint(A) * X = B (trans = C) using the LU factorization of A. fact may be E, in which case A will be equilibrated and copied to AF; F, in which case AF and ipiv from a previous LU factorization are inputs; or N, in which case A will be copied to AF and then factored. If fact = F, equed may be N, meaning A has not been equilibrated; R, meaning A was multiplied by Diagonal(R) from the left; C, meaning A was multiplied by Diagonal(C) from the right; or B, meaning A was multiplied by Diagonal(R) from the left and Diagonal(C) from the right. If fact = F and equed = R or B the elements of R must all be positive. If fact = F and equed = C or B the elements of C must all be positive.\n\nReturns the solution X; equed, which is an output if fact is not N, and describes the equilibration that was performed; R, the row equilibration diagonal; C, the column equilibration diagonal; B, which may be overwritten with its equilibrated form Diagonal(R)*B (if trans = N and equed = R,B) or Diagonal(C)*B (if trans = T,C and equed = C,B); rcond, the reciprocal condition number of A after equilbrating; ferr, the forward error bound for each solution vector in X; berr, the forward error bound for each solution vector in X; and work, the reciprocal pivot growth factor.\n\n\n\n\n\ngesvx!(A, B)\n\nThe no-equilibration, no-transpose simplification of gesvx!.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gelsd!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gelsd!","text":"gelsd!(A, B, rcond) -> (B, rnk)\n\nComputes the least norm solution of A * X = B by finding the SVD factorization of A, then dividing-and-conquering the problem. B is overwritten with the solution X. Singular values below rcond will be treated as zero. Returns the solution in B and the effective rank of A in rnk.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gelsy!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gelsy!","text":"gelsy!(A, B, rcond) -> (B, rnk)\n\nComputes the least norm solution of A * X = B by finding the full QR factorization of A, then dividing-and-conquering the problem. B is overwritten with the solution X. Singular values below rcond will be treated as zero. Returns the solution in B and the effective rank of A in rnk.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gglse!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gglse!","text":"gglse!(A, c, B, d) -> (X,res)\n\nSolves the equation A * x = c where x is subject to the equality constraint B * x = d. Uses the formula ||c - A*x||^2 = 0 to solve. Returns X and the residual sum-of-squares.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geev!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.geev!","text":"geev!(jobvl, jobvr, A) -> (W, VL, VR)\n\nFinds the eigensystem of A. If jobvl = N, the left eigenvectors of A aren't computed. If jobvr = N, the right eigenvectors of A aren't computed. If jobvl = V or jobvr = V, the corresponding eigenvectors are computed. Returns the eigenvalues in W, the right eigenvectors in VR, and the left eigenvectors in VL.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gesdd!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gesdd!","text":"gesdd!(job, A) -> (U, S, VT)\n\nFinds the singular value decomposition of A, A = U * S * V', using a divide and conquer approach. If job = A, all the columns of U and the rows of V' are computed. If job = N, no columns of U or rows of V' are computed. If job = O, A is overwritten with the columns of (thin) U and the rows of (thin) V'. If job = S, the columns of (thin) U and the rows of (thin) V' are computed and returned separately.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gesvd!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gesvd!","text":"gesvd!(jobu, jobvt, A) -> (U, S, VT)\n\nFinds the singular value decomposition of A, A = U * S * V'. If jobu = A, all the columns of U are computed. If jobvt = A all the rows of V' are computed. If jobu = N, no columns of U are computed. If jobvt = N no rows of V' are computed. If jobu = O, A is overwritten with the columns of (thin) U. If jobvt = O, A is overwritten with the rows of (thin) V'. If jobu = S, the columns of (thin) U are computed and returned separately. If jobvt = S the rows of (thin) V' are computed and returned separately. jobu and jobvt can't both be O.\n\nReturns U, S, and Vt, where S are the singular values of A.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ggsvd!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.ggsvd!","text":"ggsvd!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)\n\nFinds the generalized singular value decomposition of A and B, U'*A*Q = D1*R and V'*B*Q = D2*R. D1 has alpha on its diagonal and D2 has beta on its diagonal. If jobu = U, the orthogonal/unitary matrix U is computed. If jobv = V the orthogonal/unitary matrix V is computed. If jobq = Q, the orthogonal/unitary matrix Q is computed. If jobu, jobv or jobq is N, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ggsvd3!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.ggsvd3!","text":"ggsvd3!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)\n\nFinds the generalized singular value decomposition of A and B, U'*A*Q = D1*R and V'*B*Q = D2*R. D1 has alpha on its diagonal and D2 has beta on its diagonal. If jobu = U, the orthogonal/unitary matrix U is computed. If jobv = V the orthogonal/unitary matrix V is computed. If jobq = Q, the orthogonal/unitary matrix Q is computed. If jobu, jobv, or jobq is N, that matrix is not computed. This function requires LAPACK 3.6.0.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geevx!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.geevx!","text":"geevx!(balanc, jobvl, jobvr, sense, A) -> (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)\n\nFinds the eigensystem of A with matrix balancing. If jobvl = N, the left eigenvectors of A aren't computed. If jobvr = N, the right eigenvectors of A aren't computed. If jobvl = V or jobvr = V, the corresponding eigenvectors are computed. If balanc = N, no balancing is performed. If balanc = P, A is permuted but not scaled. If balanc = S, A is scaled but not permuted. If balanc = B, A is permuted and scaled. If sense = N, no reciprocal condition numbers are computed. If sense = E, reciprocal condition numbers are computed for the eigenvalues only. If sense = V, reciprocal condition numbers are computed for the right eigenvectors only. If sense = B, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If sense = E,B, the right and left eigenvectors must be computed.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ggev!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.ggev!","text":"ggev!(jobvl, jobvr, A, B) -> (alpha, beta, vl, vr)\n\nFinds the generalized eigendecomposition of A and B. If jobvl = N, the left eigenvectors aren't computed. If jobvr = N, the right eigenvectors aren't computed. If jobvl = V or jobvr = V, the corresponding eigenvectors are computed.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gtsv!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gtsv!","text":"gtsv!(dl, d, du, B)\n\nSolves the equation A * X = B where A is a tridiagonal matrix with dl on the subdiagonal, d on the diagonal, and du on the superdiagonal.\n\nOverwrites B with the solution X and returns it.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gttrf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gttrf!","text":"gttrf!(dl, d, du) -> (dl, d, du, du2, ipiv)\n\nFinds the LU factorization of a tridiagonal matrix with dl on the subdiagonal, d on the diagonal, and du on the superdiagonal.\n\nModifies dl, d, and du in-place and returns them and the second superdiagonal du2 and the pivoting vector ipiv.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gttrs!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gttrs!","text":"gttrs!(trans, dl, d, du, du2, ipiv, B)\n\nSolves the equation A * X = B (trans = N), transpose(A) * X = B (trans = T), or adjoint(A) * X = B (trans = C) using the LU factorization computed by gttrf!. B is overwritten with the solution X.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orglq!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.orglq!","text":"orglq!(A, tau, k = length(tau))\n\nExplicitly finds the matrix Q of a LQ factorization after calling gelqf! on A. Uses the output of gelqf!. A is overwritten by Q.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orgqr!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.orgqr!","text":"orgqr!(A, tau, k = length(tau))\n\nExplicitly finds the matrix Q of a QR factorization after calling geqrf! on A. Uses the output of geqrf!. A is overwritten by Q.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orgql!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.orgql!","text":"orgql!(A, tau, k = length(tau))\n\nExplicitly finds the matrix Q of a QL factorization after calling geqlf! on A. Uses the output of geqlf!. A is overwritten by Q.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orgrq!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.orgrq!","text":"orgrq!(A, tau, k = length(tau))\n\nExplicitly finds the matrix Q of a RQ factorization after calling gerqf! on A. Uses the output of gerqf!. A is overwritten by Q.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormlq!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.ormlq!","text":"ormlq!(side, trans, A, tau, C)\n\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a LQ factorization of A computed using gelqf!. C is overwritten.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormqr!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.ormqr!","text":"ormqr!(side, trans, A, tau, C)\n\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a QR factorization of A computed using geqrf!. C is overwritten.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormql!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.ormql!","text":"ormql!(side, trans, A, tau, C)\n\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a QL factorization of A computed using geqlf!. C is overwritten.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormrq!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.ormrq!","text":"ormrq!(side, trans, A, tau, C)\n\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a RQ factorization of A computed using gerqf!. C is overwritten.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gemqrt!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gemqrt!","text":"gemqrt!(side, trans, V, T, C)\n\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a QR factorization of A computed using geqrt!. C is overwritten.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.posv!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.posv!","text":"posv!(uplo, A, B) -> (A, B)\n\nFinds the solution to A * X = B where A is a symmetric or Hermitian positive definite matrix. If uplo = U the upper Cholesky decomposition of A is computed. If uplo = L the lower Cholesky decomposition of A is computed. A is overwritten by its Cholesky decomposition. B is overwritten with the solution X.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.potrf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.potrf!","text":"potrf!(uplo, A)\n\nComputes the Cholesky (upper if uplo = U, lower if uplo = L) decomposition of positive-definite matrix A. A is overwritten and returned with an info code.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.potri!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.potri!","text":"potri!(uplo, A)\n\nComputes the inverse of positive-definite matrix A after calling potrf! to find its (upper if uplo = U, lower if uplo = L) Cholesky decomposition.\n\nA is overwritten by its inverse and returned.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.potrs!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.potrs!","text":"potrs!(uplo, A, B)\n\nFinds the solution to A * X = B where A is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by potrf!. If uplo = U the upper Cholesky decomposition of A was computed. If uplo = L the lower Cholesky decomposition of A was computed. B is overwritten with the solution X.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.pstrf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.pstrf!","text":"pstrf!(uplo, A, tol) -> (A, piv, rank, info)\n\nComputes the (upper if uplo = U, lower if uplo = L) pivoted Cholesky decomposition of positive-definite matrix A with a user-set tolerance tol. A is overwritten by its Cholesky decomposition.\n\nReturns A, the pivots piv, the rank of A, and an info code. If info = 0, the factorization succeeded. If info = i > 0, then A is indefinite or rank-deficient.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ptsv!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.ptsv!","text":"ptsv!(D, E, B)\n\nSolves A * X = B for positive-definite tridiagonal A. D is the diagonal of A and E is the off-diagonal. B is overwritten with the solution X and returned.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.pttrf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.pttrf!","text":"pttrf!(D, E)\n\nComputes the LDLt factorization of a positive-definite tridiagonal matrix with D as diagonal and E as off-diagonal. D and E are overwritten and returned.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.pttrs!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.pttrs!","text":"pttrs!(D, E, B)\n\nSolves A * X = B for positive-definite tridiagonal A with diagonal D and off-diagonal E after computing A's LDLt factorization using pttrf!. B is overwritten with the solution X.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trtri!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.trtri!","text":"trtri!(uplo, diag, A)\n\nFinds the inverse of (upper if uplo = U, lower if uplo = L) triangular matrix A. If diag = N, A has non-unit diagonal elements. If diag = U, all diagonal elements of A are one. A is overwritten with its inverse.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trtrs!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.trtrs!","text":"trtrs!(uplo, trans, diag, A, B)\n\nSolves A * X = B (trans = N), transpose(A) * X = B (trans = T), or adjoint(A) * X = B (trans = C) for (upper if uplo = U, lower if uplo = L) triangular matrix A. If diag = N, A has non-unit diagonal elements. If diag = U, all diagonal elements of A are one. B is overwritten with the solution X.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trcon!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.trcon!","text":"trcon!(norm, uplo, diag, A)\n\nFinds the reciprocal condition number of (upper if uplo = U, lower if uplo = L) triangular matrix A. If diag = N, A has non-unit diagonal elements. If diag = U, all diagonal elements of A are one. If norm = I, the condition number is found in the infinity norm. If norm = O or 1, the condition number is found in the one norm.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trevc!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.trevc!","text":"trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))\n\nFinds the eigensystem of an upper triangular matrix T. If side = R, the right eigenvectors are computed. If side = L, the left eigenvectors are computed. If side = B, both sets are computed. If howmny = A, all eigenvectors are found. If howmny = B, all eigenvectors are found and backtransformed using VL and VR. If howmny = S, only the eigenvectors corresponding to the values in select are computed.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trrfs!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.trrfs!","text":"trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -> (Ferr, Berr)\n\nEstimates the error in the solution to A * X = B (trans = N), transpose(A) * X = B (trans = T), adjoint(A) * X = B (trans = C) for side = L, or the equivalent equations a right-handed side = R X * A after computing X using trtrs!. If uplo = U, A is upper triangular. If uplo = L, A is lower triangular. If diag = N, A has non-unit diagonal elements. If diag = U, all diagonal elements of A are one. Ferr and Berr are optional inputs. Ferr is the forward error and Berr is the backward error, each component-wise.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.stev!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.stev!","text":"stev!(job, dv, ev) -> (dv, Zmat)\n\nComputes the eigensystem for a symmetric tridiagonal matrix with dv as diagonal and ev as off-diagonal. If job = N only the eigenvalues are found and returned in dv. If job = V then the eigenvectors are also found and returned in Zmat.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.stebz!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.stebz!","text":"stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -> (dv, iblock, isplit)\n\nComputes the eigenvalues for a symmetric tridiagonal matrix with dv as diagonal and ev as off-diagonal. If range = A, all the eigenvalues are found. If range = V, the eigenvalues in the half-open interval (vl, vu] are found. If range = I, the eigenvalues with indices between il and iu are found. If order = B, eigvalues are ordered within a block. If order = E, they are ordered across all the blocks. abstol can be set as a tolerance for convergence.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.stegr!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.stegr!","text":"stegr!(jobz, range, dv, ev, vl, vu, il, iu) -> (w, Z)\n\nComputes the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) for a symmetric tridiagonal matrix with dv as diagonal and ev as off-diagonal. If range = A, all the eigenvalues are found. If range = V, the eigenvalues in the half-open interval (vl, vu] are found. If range = I, the eigenvalues with indices between il and iu are found. The eigenvalues are returned in w and the eigenvectors in Z.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.stein!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.stein!","text":"stein!(dv, ev_in, w_in, iblock_in, isplit_in)\n\nComputes the eigenvectors for a symmetric tridiagonal matrix with dv as diagonal and ev_in as off-diagonal. w_in specifies the input eigenvalues for which to find corresponding eigenvectors. iblock_in specifies the submatrices corresponding to the eigenvalues in w_in. isplit_in specifies the splitting points between the submatrix blocks.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.syconv!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.syconv!","text":"syconv!(uplo, A, ipiv) -> (A, work)\n\nConverts a symmetric matrix A (which has been factorized into a triangular matrix) into two matrices L and D. If uplo = U, A is upper triangular. If uplo = L, it is lower triangular. ipiv is the pivot vector from the triangular factorization. A is overwritten by L and D.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sysv!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.sysv!","text":"sysv!(uplo, A, B) -> (B, A, ipiv)\n\nFinds the solution to A * X = B for symmetric matrix A. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. B is overwritten by the solution X. A is overwritten by its Bunch-Kaufman factorization. ipiv contains pivoting information about the factorization.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sytrf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.sytrf!","text":"sytrf!(uplo, A) -> (A, ipiv, info)\n\nComputes the Bunch-Kaufman factorization of a symmetric matrix A. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored.\n\nReturns A, overwritten by the factorization, a pivot vector ipiv, and the error code info which is a non-negative integer. If info is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position info.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sytri!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.sytri!","text":"sytri!(uplo, A, ipiv)\n\nComputes the inverse of a symmetric matrix A using the results of sytrf!. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. A is overwritten by its inverse.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sytrs!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.sytrs!","text":"sytrs!(uplo, A, ipiv, B)\n\nSolves the equation A * X = B for a symmetric matrix A using the results of sytrf!. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. B is overwritten by the solution X.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hesv!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.hesv!","text":"hesv!(uplo, A, B) -> (B, A, ipiv)\n\nFinds the solution to A * X = B for Hermitian matrix A. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. B is overwritten by the solution X. A is overwritten by its Bunch-Kaufman factorization. ipiv contains pivoting information about the factorization.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hetrf!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.hetrf!","text":"hetrf!(uplo, A) -> (A, ipiv, info)\n\nComputes the Bunch-Kaufman factorization of a Hermitian matrix A. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored.\n\nReturns A, overwritten by the factorization, a pivot vector ipiv, and the error code info which is a non-negative integer. If info is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position info.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hetri!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.hetri!","text":"hetri!(uplo, A, ipiv)\n\nComputes the inverse of a Hermitian matrix A using the results of sytrf!. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. A is overwritten by its inverse.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hetrs!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.hetrs!","text":"hetrs!(uplo, A, ipiv, B)\n\nSolves the equation A * X = B for a Hermitian matrix A using the results of sytrf!. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. B is overwritten by the solution X.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.syev!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.syev!","text":"syev!(jobz, uplo, A)\n\nFinds the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric matrix A. If uplo = U, the upper triangle of A is used. If uplo = L, the lower triangle of A is used.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.syevr!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.syevr!","text":"syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -> (W, Z)\n\nFinds the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric matrix A. If uplo = U, the upper triangle of A is used. If uplo = L, the lower triangle of A is used. If range = A, all the eigenvalues are found. If range = V, the eigenvalues in the half-open interval (vl, vu] are found. If range = I, the eigenvalues with indices between il and iu are found. abstol can be set as a tolerance for convergence.\n\nThe eigenvalues are returned in W and the eigenvectors in Z.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sygvd!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.sygvd!","text":"sygvd!(itype, jobz, uplo, A, B) -> (w, A, B)\n\nFinds the generalized eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric matrix A and symmetric positive-definite matrix B. If uplo = U, the upper triangles of A and B are used. If uplo = L, the lower triangles of A and B are used. If itype = 1, the problem to solve is A * x = lambda * B * x. If itype = 2, the problem to solve is A * B * x = lambda * x. If itype = 3, the problem to solve is B * A * x = lambda * x.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.bdsqr!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.bdsqr!","text":"bdsqr!(uplo, d, e_, Vt, U, C) -> (d, Vt, U, C)\n\nComputes the singular value decomposition of a bidiagonal matrix with d on the diagonal and e_ on the off-diagonal. If uplo = U, e_ is the superdiagonal. If uplo = L, e_ is the subdiagonal. Can optionally also compute the product Q' * C.\n\nReturns the singular values in d, and the matrix C overwritten with Q' * C.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.bdsdc!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.bdsdc!","text":"bdsdc!(uplo, compq, d, e_) -> (d, e, u, vt, q, iq)\n\nComputes the singular value decomposition of a bidiagonal matrix with d on the diagonal and e_ on the off-diagonal using a divide and conqueq method. If uplo = U, e_ is the superdiagonal. If uplo = L, e_ is the subdiagonal. If compq = N, only the singular values are found. If compq = I, the singular values and vectors are found. If compq = P, the singular values and vectors are found in compact form. Only works for real types.\n\nReturns the singular values in d, and if compq = P, the compact singular vectors in iq.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gecon!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gecon!","text":"gecon!(normtype, A, anorm)\n\nFinds the reciprocal condition number of matrix A. If normtype = I, the condition number is found in the infinity norm. If normtype = O or 1, the condition number is found in the one norm. A must be the result of getrf! and anorm is the norm of A in the relevant norm.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gehrd!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gehrd!","text":"gehrd!(ilo, ihi, A) -> (A, tau)\n\nConverts a matrix A to Hessenberg form. If A is balanced with gebal! then ilo and ihi are the outputs of gebal!. Otherwise they should be ilo = 1 and ihi = size(A,2). tau contains the elementary reflectors of the factorization.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orghr!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.orghr!","text":"orghr!(ilo, ihi, A, tau)\n\nExplicitly finds Q, the orthogonal/unitary matrix from gehrd!. ilo, ihi, A, and tau must correspond to the input/output to gehrd!.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gees!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gees!","text":"gees!(jobvs, A) -> (A, vs, w)\n\nComputes the eigenvalues (jobvs = N) or the eigenvalues and Schur vectors (jobvs = V) of matrix A. A is overwritten by its Schur form.\n\nReturns A, vs containing the Schur vectors, and w, containing the eigenvalues.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gges!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.gges!","text":"gges!(jobvsl, jobvsr, A, B) -> (A, B, alpha, beta, vsl, vsr)\n\nComputes the generalized eigenvalues, generalized Schur form, left Schur vectors (jobsvl = V), or right Schur vectors (jobvsr = V) of A and B.\n\nThe generalized eigenvalues are returned in alpha and beta. The left Schur vectors are returned in vsl and the right Schur vectors are returned in vsr.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trexc!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.trexc!","text":"trexc!(compq, ifst, ilst, T, Q) -> (T, Q)\n\nReorder the Schur factorization of a matrix. If compq = V, the Schur vectors Q are reordered. If compq = N they are not modified. ifst and ilst specify the reordering of the vectors.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trsen!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.trsen!","text":"trsen!(compq, job, select, T, Q) -> (T, Q, w, s, sep)\n\nReorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If job = N, no condition numbers are found. If job = E, only the condition number for this cluster of eigenvalues is found. If job = V, only the condition number for the invariant subspace is found. If job = B then the condition numbers for the cluster and subspace are found. If compq = V the Schur vectors Q are updated. If compq = N the Schur vectors are not modified. select determines which eigenvalues are in the cluster.\n\nReturns T, Q, reordered eigenvalues in w, the condition number of the cluster of eigenvalues s, and the condition number of the invariant subspace sep.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.tgsen!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.tgsen!","text":"tgsen!(select, S, T, Q, Z) -> (S, T, alpha, beta, Q, Z)\n\nReorders the vectors of a generalized Schur decomposition. select specifies the eigenvalues in each cluster.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trsyl!","page":"Linear Algebra","title":"LinearAlgebra.LAPACK.trsyl!","text":"trsyl!(transa, transb, A, B, C, isgn=1) -> (C, scale)\n\nSolves the Sylvester matrix equation A * X +/- X * B = scale*C where A and B are both quasi-upper triangular. If transa = N, A is not modified. If transa = T, A is transposed. If transa = C, A is conjugate transposed. Similarly for transb and B. If isgn = 1, the equation A * X + X * B = scale * C is solved. If isgn = -1, the equation A * X - X * B = scale * C is solved.\n\nReturns X (overwriting C) and scale.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/LinearAlgebra.html#","page":"Linear Algebra","title":"Linear Algebra","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/Logging.html#Logging-1","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"The Logging module provides a way to record the history and progress of a computation as a log of events.  Events are created by inserting a logging statement into the source code, for example:","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"@warn \"Abandon printf debugging, all ye who enter here!\"\n┌ Warning: Abandon printf debugging, all ye who enter here!\n└ @ Main REPL[1]:1","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"The system provides several advantages over peppering your source code with calls to println().  First, it allows you to control the visibility and presentation of messages without editing the source code.  For example, in contrast to the @warn above","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"@debug \"The sum of some values $(sum(rand(100)))\"","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"will produce no output by default.  Furthermore, it's very cheap to leave debug statements like this in the source code because the system avoids evaluating the message if it would later be ignored.  In this case sum(rand(100)) and the associated string processing will never be executed unless debug logging is enabled.","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Second, the logging tools allow you to attach arbitrary data to each event as a set of key–value pairs. This allows you to capture local variables and other program state for later analysis. For example, to attach the local array variable A and the sum of a vector v as the key s you can use","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"A = ones(Int, 4, 4)\nv = ones(100)\n@info \"Some variables\"  A  s=sum(v)\n\n# output\n┌ Info: Some variables\n│   A =\n│    4×4 Array{Int64,2}:\n│     1  1  1  1\n│     1  1  1  1\n│     1  1  1  1\n│     1  1  1  1\n└   s = 100.0","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"All of the logging macros @debug, @info, @warn and @error share common features that are described in detail in the documentation for the more general macro @logmsg.","category":"page"},{"location":"stdlib/Logging.html#Log-event-structure-1","page":"Logging","title":"Log event structure","text":"","category":"section"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Each event generates several pieces of data, some provided by the user and some automatically extracted. Let's examine the user-defined data first:","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"The log level is a broad category for the message that is used for early filtering. There are several standard levels of type LogLevel; user-defined levels are also possible.\nUse Debug for verbose information that could be useful when debugging an application or module. These events are disabled by default.\nUse Info to inform the user about the normal operation of the program.\nUse Warn when a potential problem is detected.\nUse Error to report errors where the code has enough context to recover and continue.  (When the code doesn't have enough context, an exception or early return is more appropriate.)\nThe message  is an object describing the event. By convention AbstractStrings passed as messages are assumed to be in markdown format. Other types will be displayed using show(io,mime,obj) according to the display capabilities of the installed logger.\nOptional key–value pairs allow arbitrary data to be attached to each event. Some keys have conventional meaning that can affect the way an event is interpreted (see @logmsg).","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"The system also generates some standard information for each event:","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"The module in which the logging macro was expanded.\nThe file and line where the logging macro occurs in the source code.\nA message id that is a unique, fixed identifier for the source code statement where the logging macro appears. This identifier is designed to be fairly stable even if the source code of the file changes, as long as the logging statement itself remains the same.\nA group for the event, which is set to the base name of the file by default, without extension.  This can be used to group messages into categories more finely than the log level (for example, all deprecation warnings have group :depwarn), or into logical groupings across or within modules.","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Notice that some useful information such as the event time is not included by default. This is because such information can be expensive to extract and is also dynamically available to the current logger. It's simple to define a custom logger to augment event data with the time, backtrace, values of global variables and other useful information as required.","category":"page"},{"location":"stdlib/Logging.html#Processing-log-events-1","page":"Logging","title":"Processing log events","text":"","category":"section"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Creating log events is the concern of the module author who needs to decide where events are triggered and which information to include.\nProcessing of log events — that is, display, filtering, aggregation and recording — is the concern of the application author who needs to bring multiple modules together into a cooperating application.","category":"page"},{"location":"stdlib/Logging.html#Loggers-1","page":"Logging","title":"Loggers","text":"","category":"section"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Processing of events is performed by a logger, which is the first piece of user configurable code to see the event. All loggers must be subtypes of AbstractLogger.","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"When an event is triggered, the appropriate logger is found by looking for a task-local logger with the global logger as fallback.  The idea here is that the application code knows how log events should be processed and exists somewhere at the top of the call stack. So we should look up through the call stack to discover the logger — that is, the logger should be dynamically scoped. (This is a point of contrast with logging frameworks where the logger is lexically scoped; provided explicitly by the module author or as a simple global variable. In such a system it's awkward to control logging while composing functionality from multiple modules.)","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"The global logger may be set with global_logger, and task-local loggers controlled using with_logger.  Newly spawned tasks inherit the logger of the parent task.","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"There are three logger types provided by the library. ConsoleLogger  is the default logger you see when starting the REPL.  It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering. NullLogger is a convenient way to drop all messages where necessary; it is the logging equivalent of the devnull  stream. SimpleLogger is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Custom loggers should come with overloads for the functions described in the reference section.","category":"page"},{"location":"stdlib/Logging.html#Early-filtering-and-message-handling-1","page":"Logging","title":"Early filtering and message handling","text":"","category":"section"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"When an event occurs, a few steps of early filtering occur to avoid generating messages that will be discarded:","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"The message log level is checked against a global minimum level (set via disable_logging).  This is a crude but extremely cheap global setting.\nThe current logger state is looked up and the message level checked against the logger's cached minimum level, as found by calling Logging.min_enabled_level.  This behavior can be overridden via environment variables (more on this later).\nThe Logging.shouldlog function is called with the current logger, taking some minimal information (level, module, group, id) which can be computed statically.  Most usefully, shouldlog is passed an event id which can be used to discard events early based on a cached predicate.","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"If all these checks pass, the message and key–value pairs are evaluated in full and passed to the current logger via the Logging.handle_message function.  handle_message() may perform additional filtering as required and display the event to the screen, save it to a file, etc.","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Exceptions that occur while generating the log event are captured and logged by default.  This prevents individual broken events from crashing the application, which is helpful when enabling little-used debug events in a production system.  This behavior can be customized per logger type by extending Logging.catch_exceptions.","category":"page"},{"location":"stdlib/Logging.html#Testing-log-events-1","page":"Logging","title":"Testing log events","text":"","category":"section"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Log events are a side effect of running normal code, but you might find yourself wanting to test particular informational messages and warnings. The Test module provides a @test_logs macro that can be used to pattern match against the log event stream.","category":"page"},{"location":"stdlib/Logging.html#Environment-variables-1","page":"Logging","title":"Environment variables","text":"","category":"section"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Message filtering can be influenced through the JULIA_DEBUG environment variable, and serves as an easy way to enable debug logging for a file or module. For example, loading julia with JULIA_DEBUG=loading will activate @debug log messages in loading.jl:","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"$ JULIA_DEBUG=loading julia -e 'using OhMyREPL'\n┌ Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji due to it containing an invalid cache header\n└ @ Base loading.jl:1328\n[ Info: Recompiling stale cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji for module OhMyREPL\n┌ Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/Tokenize.ji due to it containing an invalid cache header\n└ @ Base loading.jl:1328\n...","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Similarly, the environment variable can be used to enable debug logging of modules, such as Pkg, or module roots (see Base.moduleroot). To enable all debug logging, use the special value all.","category":"page"},{"location":"stdlib/Logging.html#Writing-log-events-to-a-file-1","page":"Logging","title":"Writing log events to a file","text":"","category":"section"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Sometimes it can be useful to write log events to a file. Here is an example of how to use a task-local and global logger to write information to a text file:","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"# Load the logging module\njulia> using Logging\n\n# Open a textfile for writing\njulia> io = open(\"log.txt\", \"w+\")\nIOStream(<file log.txt>)\n\n# Create a simple logger\njulia> logger = SimpleLogger(io)\nSimpleLogger(IOStream(<file log.txt>), Info, Dict{Any,Int64}())\n\n# Log a task-specific message\njulia> with_logger(logger) do\n           @info(\"a context specific log message\")\n       end\n\n# Write all buffered messages to the file\njulia> flush(io)\n\n# Set the global logger to logger\njulia> global_logger(logger)\nSimpleLogger(IOStream(<file log.txt>), Info, Dict{Any,Int64}())\n\n# This message will now also be written to the file\njulia> @info(\"a global log message\")\n\n# Close the file\njulia> close(io)","category":"page"},{"location":"stdlib/Logging.html#Reference-1","page":"Logging","title":"Reference","text":"","category":"section"},{"location":"stdlib/Logging.html#Logging-module-1","page":"Logging","title":"Logging module","text":"","category":"section"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Logging.Logging","category":"page"},{"location":"stdlib/Logging.html#Logging.Logging","page":"Logging","title":"Logging.Logging","text":"Utilities for capturing, filtering and presenting streams of log events. Normally you don't need to import Logging to create log events; for this the standard logging macros such as @info are already exported by Base and available by default.\n\n\n\n\n\n","category":"module"},{"location":"stdlib/Logging.html#Creating-events-1","page":"Logging","title":"Creating events","text":"","category":"section"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Logging.@logmsg\nLogging.LogLevel","category":"page"},{"location":"stdlib/Logging.html#Base.CoreLogging.@logmsg","page":"Logging","title":"Base.CoreLogging.@logmsg","text":"@debug message  [key=value | value ...]\n@info  message  [key=value | value ...]\n@warn  message  [key=value | value ...]\n@error message  [key=value | value ...]\n\n@logmsg level message [key=value | value ...]\n\nCreate a log record with an informational message.  For convenience, four logging macros @debug, @info, @warn and @error are defined which log at the standard severity levels Debug, Info, Warn and Error.  @logmsg allows level to be set programmatically to any LogLevel or custom log level types.\n\nmessage should be an expression which evaluates to a string which is a human readable description of the log event.  By convention, this string will be formatted as markdown when presented.\n\nThe optional list of key=value pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record.  If only a value expression is supplied, a key representing the expression will be generated using Symbol. For example, x becomes x=x, and foo(10) becomes Symbol(\"foo(10)\")=foo(10).  For splatting a list of key value pairs, use the normal splatting syntax, @info \"blah\" kws....\n\nThere are some keys which allow automatically generated log data to be overridden:\n\n_module=mod can be used to specify a different originating module from the source location of the message.\n_group=symbol can be used to override the message group (this is normally derived from the base name of the source file).\n_id=symbol can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.\n_file=string and _line=integer can be used to override the apparent source location of a log message.\n\nThere's also some key value pairs which have conventional meaning:\n\nmaxlog=integer should be used as a hint to the backend that the message should be displayed no more than maxlog times.\nexception=ex should be used to transport an exception with a log message, often used with @error. An associated backtrace bt may be attached using the tuple exception=(ex,bt).\n\nExamples\n\n@debug \"Verbose debugging information.  Invisible by default\"\n@info  \"An informational message\"\n@warn  \"Something was odd.  You should pay attention\"\n@error \"A non fatal error occurred\"\n\nx = 10\n@info \"Some variables attached to the message\" x a=42.0\n\n@debug begin\n    sA = sum(A)\n    \"sum(A) = $sA is an expensive operation, evaluated only when `shouldlog` returns true\"\nend\n\nfor i=1:10000\n    @info \"With the default backend, you will only see (i = $i) ten times\"  maxlog=10\n    @debug \"Algorithm1\" i progress=i/10000\nend\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Logging.html#Base.CoreLogging.LogLevel","page":"Logging","title":"Base.CoreLogging.LogLevel","text":"LogLevel(level)\n\nSeverity/verbosity of a log record.\n\nThe log level provides a key against which potential log records may be filtered, before any other work is done to construct the log record data structure itself.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Logging.html#AbstractLogger-interface-1","page":"Logging","title":"Processing events with AbstractLogger","text":"","category":"section"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Event processing is controlled by overriding functions associated with AbstractLogger:","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Methods to implement  Brief description\nLogging.handle_message  Handle a log event\nLogging.shouldlog  Early filtering of events\nLogging.min_enabled_level  Lower bound for log level of accepted events\nOptional methods Default definition Brief description\nLogging.catch_exceptions true Catch exceptions during event evaluation","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Logging.AbstractLogger\nLogging.handle_message\nLogging.shouldlog\nLogging.min_enabled_level\nLogging.catch_exceptions\nLogging.disable_logging","category":"page"},{"location":"stdlib/Logging.html#Base.CoreLogging.AbstractLogger","page":"Logging","title":"Base.CoreLogging.AbstractLogger","text":"A logger controls how log records are filtered and dispatched.  When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Logging.html#Base.CoreLogging.handle_message","page":"Logging","title":"Base.CoreLogging.handle_message","text":"handle_message(logger, level, message, _module, group, id, file, line; key1=val1, ...)\n\nLog a message to logger at level.  The logical location at which the message was generated is given by module _module and group; the source location by file and line. id is an arbitrary unique Symbol to be used as a key to identify the log statement when filtering.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Logging.html#Base.CoreLogging.shouldlog","page":"Logging","title":"Base.CoreLogging.shouldlog","text":"shouldlog(logger, level, _module, group, id)\n\nReturn true when logger accepts a message at level, generated for _module, group and with unique log identifier id.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Logging.html#Base.CoreLogging.min_enabled_level","page":"Logging","title":"Base.CoreLogging.min_enabled_level","text":"min_enabled_level(logger)\n\nReturn the maximum disabled level for logger for early filtering.  That is, the log level below or equal to which all messages are filtered.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Logging.html#Base.CoreLogging.catch_exceptions","page":"Logging","title":"Base.CoreLogging.catch_exceptions","text":"catch_exceptions(logger)\n\nReturn true if the logger should catch exceptions which happen during log record construction.  By default, messages are caught\n\nBy default all exceptions are caught to prevent log message generation from crashing the program.  This lets users confidently toggle little-used functionality - such as debug logging - in a production system.\n\nIf you want to use logging as an audit trail you should disable this for your logger type.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Logging.html#Base.CoreLogging.disable_logging","page":"Logging","title":"Base.CoreLogging.disable_logging","text":"disable_logging(level)\n\nDisable all log messages at log levels equal to or less than level.  This is a global setting, intended to make debug logging extremely cheap when disabled.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Logging.html#Using-Loggers-1","page":"Logging","title":"Using Loggers","text":"","category":"section"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"ロガーのインストールとインストロスペクション:","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Logging.global_logger\nLogging.with_logger\nLogging.current_logger","category":"page"},{"location":"stdlib/Logging.html#Base.CoreLogging.global_logger","page":"Logging","title":"Base.CoreLogging.global_logger","text":"global_logger()\n\nReturn the global logger, used to receive messages when no specific logger exists for the current task.\n\nglobal_logger(logger)\n\nSet the global logger to logger, and return the previous global logger.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Logging.html#Base.CoreLogging.with_logger","page":"Logging","title":"Base.CoreLogging.with_logger","text":"with_logger(function, logger)\n\nExecute function, directing all log messages to logger.\n\nExample\n\nfunction test(x)\n    @info \"x = $x\"\nend\n\nwith_logger(logger) do\n    test(1)\n    test([1,2])\nend\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Logging.html#Base.CoreLogging.current_logger","page":"Logging","title":"Base.CoreLogging.current_logger","text":"current_logger()\n\nReturn the logger for the current task, or the global logger if none is attached to the task.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Loggers that are supplied with the system:","category":"page"},{"location":"stdlib/Logging.html#","page":"Logging","title":"Logging","text":"Logging.NullLogger\nLogging.ConsoleLogger\nLogging.SimpleLogger","category":"page"},{"location":"stdlib/Logging.html#Base.CoreLogging.NullLogger","page":"Logging","title":"Base.CoreLogging.NullLogger","text":"NullLogger()\n\nLogger which disables all messages and produces no output - the logger equivalent of /dev/null.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Logging.html#Logging.ConsoleLogger","page":"Logging","title":"Logging.ConsoleLogger","text":"ConsoleLogger(stream=stderr, min_level=Info; meta_formatter=default_metafmt,\n              show_limited=true, right_justify=0)\n\nLogger with formatting optimized for readability in a text console, for example interactive work with the Julia REPL.\n\nLog levels less than min_level are filtered out.\n\nMessage formatting can be controlled by setting keyword arguments:\n\nmeta_formatter is a function which takes the log event metadata (level, _module, group, id, file, line) and returns a color (as would be passed to printstyled), prefix and suffix for the log message.  The default is to prefix with the log level and a suffix containing the module, file and line location.\nshow_limited limits the printing of large data structures to something which can fit on the screen by setting the :limit IOContext key during formatting.\nright_justify is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Logging.html#Base.CoreLogging.SimpleLogger","page":"Logging","title":"Base.CoreLogging.SimpleLogger","text":"SimpleLogger(stream=stderr, min_level=Info)\n\nSimplistic logger for logging all messages with level greater than or equal to min_level to stream.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Markdown.html#Markdown-1","page":"Markdown","title":"Markdown","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"This section describes Julia's markdown syntax, which is enabled by the Markdown standard library. The following Markdown elements are supported:","category":"page"},{"location":"stdlib/Markdown.html#Inline-elements-1","page":"Markdown","title":"Inline elements","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Here \"inline\" refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.","category":"page"},{"location":"stdlib/Markdown.html#Bold-1","page":"Markdown","title":"Bold","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Surround words with two asterisks, **, to display the enclosed text in boldface.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"A paragraph containing a **bold** word.","category":"page"},{"location":"stdlib/Markdown.html#Italics-1","page":"Markdown","title":"Italics","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Surround words with one asterisk, *, to display the enclosed text in italics.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"A paragraph containing an *emphasized* word.","category":"page"},{"location":"stdlib/Markdown.html#Literals-1","page":"Markdown","title":"Literals","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Surround text that should be displayed exactly as written with single backticks, ` .","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"A paragraph containing a `literal` word.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia program.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"tip: Tip\nTo include a backtick character within literal text use three backticks rather than one to enclose the text.A paragraph containing a ``` `backtick` character ```.By extension any odd number of backticks may be used to enclose a lesser number of backticks.","category":"page"},{"location":"stdlib/Markdown.html#\\LaTeX-1","page":"Markdown","title":"LaTeX","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Surround text that should be displayed as mathematics using LaTeX syntax with double backticks, `` .","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"A paragraph containing some ``\\LaTeX`` markup.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"tip: Tip\nAs with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within LaTeX markup then two enclosing backticks is sufficient.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"note: Note\nThe \\ character should be escaped appropriately if the text is embedded in a Julia source code, for example, \"``\\\\LaTeX`` syntax in a docstring.\", since it is interpreted as a string literal. Alternatively, in order to avoid escaping, it is possible to use the raw string macro together with the @doc macro:@doc raw\"``\\LaTeX`` syntax in a docstring.\" functionname","category":"page"},{"location":"stdlib/Markdown.html#Links-1","page":"Markdown","title":"Links","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Links to either external or internal addresses can be written using the following syntax, where the text enclosed in square brackets, [ ], is the name of the link and the text enclosed in parentheses, ( ), is the URL.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"A paragraph containing a link to [Julia](http://www.julialang.org).","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"It's also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"\"\"\"\n    tryparse(type, str; base)\n\nLike [`parse`](@ref), but returns either a value of the requested type,\nor [`nothing`](@ref) if the string does not contain a valid number.\n\"\"\"","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"This will create a link in the generated docs to the parse documentation (which has more information about what this function actually does), and to the nothing documentation. It's good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"note: Note\nThe above cross referencing is not a Markdown feature, and relies on Documenter.jl, which is used to build base Julia's documentation.","category":"page"},{"location":"stdlib/Markdown.html#Footnote-references-1","page":"Markdown","title":"Footnote references","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Named and numbered footnote references can be written using the following syntax. A footnote name must be a single alphanumeric word containing no punctuation.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"A paragraph containing a numbered footnote [^1] and a named one [^named].","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"note: Note\nThe text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the Footnotes section below.","category":"page"},{"location":"stdlib/Markdown.html#Toplevel-elements-1","page":"Markdown","title":"Toplevel elements","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"The following elements can be written either at the \"toplevel\" of a document or within another \"toplevel\" element.","category":"page"},{"location":"stdlib/Markdown.html#Paragraphs-1","page":"Markdown","title":"Paragraphs","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"A paragraph is a block of plain text, possibly containing any number of inline elements defined in the Inline elements section above, with one or more blank lines above and below it.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"This is a paragraph.\n\nAnd this is *another* one containing some emphasized text.\nA new line, but still part of the same paragraph.","category":"page"},{"location":"stdlib/Markdown.html#Headers-1","page":"Markdown","title":"Headers","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"A document can be split up into different sections using headers. Headers use the following syntax:","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"# Level One\n## Level Two\n### Level Three\n#### Level Four\n##### Level Five\n###### Level Six","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"A header line can contain any inline syntax in the same way as a paragraph can.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"tip: Tip\nTry to avoid using too many levels of header within a single document. A heavily nested document may be indicative of a need to restructure it or split it into several pages covering separate topics.","category":"page"},{"location":"stdlib/Markdown.html#Code-blocks-1","page":"Markdown","title":"コードブロック","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Source code can be displayed as a literal block using an indent of four spaces as shown in the following example.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"This is a paragraph.\n\n    function func(x)\n        # ...\n    end\n\nAnother paragraph.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Additionally, code blocks can be enclosed using triple backticks with an optional \"language\" to specify how a block of code should be highlighted.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"A code block without a \"language\":\n\n```\nfunction func(x)\n    # ...\nend\n```\n\nand another one with the \"language\" specified as `julia`:\n\n```julia\nfunction func(x)\n    # ...\nend\n```","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"note: Note\n\"Fenced\" code blocks, as shown in the last example, should be preferred over indented code blocks since there is no way to specify what language an indented code block is written in.","category":"page"},{"location":"stdlib/Markdown.html#Block-quotes-1","page":"Markdown","title":"Block quotes","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Text from external sources, such as quotations from books or websites, can be quoted using > characters prepended to each line of the quote as follows.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Here's a quote:\n\n> Julia is a high-level, high-performance dynamic programming language for\n> technical computing, with syntax that is familiar to users of other\n> technical computing environments.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Note that a single space must appear after the > character on each line. Quoted blocks may themselves contain other toplevel or inline elements.","category":"page"},{"location":"stdlib/Markdown.html#Images-1","page":"Markdown","title":"Images","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"The syntax for images is similar to the link syntax mentioned above. Prepending a ! character to a link will display an image from the specified URL rather than a link to it.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"![alternative text](link/to/image.png)","category":"page"},{"location":"stdlib/Markdown.html#Lists-1","page":"Markdown","title":"Lists","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Unordered lists can be written by prepending each item in a list with either *, +, or -.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"A list of items:\n\n  * item one\n  * item two\n  * item three","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Note the two spaces before each * and the single space after each one.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should be left between each list item when including any toplevel elements within a list.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Another list:\n\n  * item one\n\n  * item two\n\n    ```\n    f(x) = x\n    ```\n\n  * And a sublist:\n\n      + sub-item one\n      + sub-item two","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"note: Note\nThe contents of each item in the list must line up with the first line of the item. In the above example the fenced code block must be indented by four spaces to align with the i in item two.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Ordered lists are written by replacing the \"bullet\" character, either *, +, or -, with a positive integer followed by either . or ).","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Two ordered lists:\n\n 1. item one\n 2. item two\n 3. item three\n\n 5) item five\n 6) item six\n 7) item seven","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"An ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.","category":"page"},{"location":"stdlib/Markdown.html#Display-equations-1","page":"Markdown","title":"Display equations","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Large LaTeX equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the \"language\" math as in the example below.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"```math\nf(a) = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} (\\alpha+R\\cos(\\theta))d\\theta\n```","category":"page"},{"location":"stdlib/Markdown.html#Footnotes-1","page":"Markdown","title":"Footnotes","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"This syntax is paired with the inline syntax for Footnote references. Make sure to read that section as well.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from the : character that is appended to the footnote label.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"[^1]: Numbered footnote text.\n\n[^note]:\n\n    Named footnote text containing several toplevel elements.\n\n      * item one\n      * item two\n      * item three\n\n    ```julia\n    function func(x)\n        # ...\n    end\n    ```","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"note: Note\nNo checks are done during parsing to make sure that all footnote references have matching footnotes.","category":"page"},{"location":"stdlib/Markdown.html#Horizontal-rules-1","page":"Markdown","title":"Horizontal rules","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"The equivalent of an <hr> HTML tag can be written using the following syntax:","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Text above the line.\n\n---\n\nAnd text below the line.","category":"page"},{"location":"stdlib/Markdown.html#Tables-1","page":"Markdown","title":"Tables","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above – only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"| Column One | Column Two | Column Three |\n|:---------- | ---------- |:------------:|\n| Row `1`    | Column `2` |              |\n| *Row* 2    | **Row** 2  | Column ``3`` |","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"note: Note\nAs illustrated in the above example each column of | characters must be aligned vertically.A : character on either end of a column's header separator (the row containing - characters) specifies whether the row is left-aligned, right-aligned, or (when : appears on both ends) center-aligned. Providing no : characters will default to right-aligning the column.","category":"page"},{"location":"stdlib/Markdown.html#Admonitions-1","page":"Markdown","title":"Admonitions","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Specially formatted blocks, known as admonitions, can be used to highlight particular remarks.  They can be defined using the following !!! syntax:","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"!!! note\n\n    This is the content of the note.\n\n!!! warning \"Beware!\"\n\n    And this is another one.\n\n    This warning admonition has a custom title: `\"Beware!\"`.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"The type of the admonition can be any word, but some types produce special styling, namely (in order of decreasing severity): danger, warning, info/note, and tip.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"A custom title for the box can be provided as a string (in double quotes) after the admonition type.  If no title text is specified after the admonition type, then the title used will be the type of the block, i.e. \"Note\" in the case of the note admonition.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Admonitions, like most other toplevel elements, can contain other toplevel elements.","category":"page"},{"location":"stdlib/Markdown.html#Markdown-Syntax-Extensions-1","page":"Markdown","title":"Markdown Syntax Extensions","text":"","category":"section"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"Julia's markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual show methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.","category":"page"},{"location":"stdlib/Markdown.html#","page":"Markdown","title":"Markdown","text":"In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.","category":"page"},{"location":"stdlib/Mmap.html#Memory-mapped-I/O-1","page":"Memory-mapped I/O","title":"Memory-mapped I/O","text":"","category":"section"},{"location":"stdlib/Mmap.html#","page":"Memory-mapped I/O","title":"Memory-mapped I/O","text":"DocTestSetup = :(using Mmap)","category":"page"},{"location":"stdlib/Mmap.html#","page":"Memory-mapped I/O","title":"Memory-mapped I/O","text":"Mmap.Anonymous\nMmap.mmap\nMmap.sync!","category":"page"},{"location":"stdlib/Mmap.html#Mmap.Anonymous","page":"Memory-mapped I/O","title":"Mmap.Anonymous","text":"Mmap.Anonymous(name::AbstractString=\"\", readonly::Bool=false, create::Bool=true)\n\nCreate an IO-like object for creating zeroed-out mmapped-memory that is not tied to a file for use in Mmap.mmap. Used by SharedArray for creating shared memory arrays.\n\nExamples\n\njulia> anon = Mmap.Anonymous();\n\njulia> isreadable(anon)\ntrue\n\njulia> iswritable(anon)\ntrue\n\njulia> isopen(anon)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Mmap.html#Mmap.mmap","page":"Memory-mapped I/O","title":"Mmap.mmap","text":"Mmap.mmap(io::Union{IOStream,AbstractString,Mmap.AnonymousMmap}[, type::Type{Array{T,N}}, dims, offset]; grow::Bool=true, shared::Bool=true)\nMmap.mmap(type::Type{Array{T,N}}, dims)\n\nCreate an Array whose values are linked to a file, using memory-mapping. This provides a convenient way of working with data too large to fit in the computer's memory.\n\nThe type is an Array{T,N} with a bits-type element of T and dimension N that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).\n\ndims is a tuple or single Integer specifying the size or length of the array.\n\nThe file is passed via the stream argument, either as an open IOStream or filename string. When you initialize the stream, use \"r\" for a \"read-only\" array, and \"w+\" to create a new array used to write values to disk.\n\nIf no type argument is specified, the default is Vector{UInt8}.\n\nOptionally, you can specify an offset (in bytes) if, for example, you want to skip over a header in the file. The default value for the offset is the current stream position for an IOStream.\n\nThe grow keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is < requested array size). Write privileges are required to grow the file.\n\nThe shared keyword argument specifies whether the resulting Array and changes made to it will be visible to other processes mapping the same file.\n\nFor example, the following code\n\n# Create a file for mmapping\n# (you could alternatively use mmap to do this step, too)\nA = rand(1:20, 5, 30)\ns = open(\"/tmp/mmap.bin\", \"w+\")\n# We'll write the dimensions of the array as the first two Ints in the file\nwrite(s, size(A,1))\nwrite(s, size(A,2))\n# Now write the data\nwrite(s, A)\nclose(s)\n\n# Test by reading it back in\ns = open(\"/tmp/mmap.bin\")   # default is read-only\nm = read(s, Int)\nn = read(s, Int)\nA2 = Mmap.mmap(s, Matrix{Int}, (m,n))\n\ncreates a m-by-n Matrix{Int}, linked to the file associated with stream s.\n\nA more portable file would need to encode the word size – 32 bit or 64 bit – and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).\n\n\n\n\n\nMmap.mmap(io, BitArray, [dims, offset])\n\nCreate a BitArray whose values are linked to a file, using memory-mapping; it has the same purpose, works in the same way, and has the same arguments, as mmap, but the byte representation is different.\n\nExamples\n\njulia> io = open(\"mmap.bin\", \"w+\");\n\njulia> B = Mmap.mmap(io, BitArray, (25,30000));\n\njulia> B[3, 4000] = true;\n\njulia> Mmap.sync!(B);\n\njulia> close(io);\n\njulia> io = open(\"mmap.bin\", \"r+\");\n\njulia> C = Mmap.mmap(io, BitArray, (25,30000));\n\njulia> C[3, 4000]\ntrue\n\njulia> C[2, 4000]\nfalse\n\njulia> close(io)\n\njulia> rm(\"mmap.bin\")\n\nThis creates a 25-by-30000 BitArray, linked to the file associated with stream io.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Mmap.html#Mmap.sync!","page":"Memory-mapped I/O","title":"Mmap.sync!","text":"Mmap.sync!(array)\n\nForces synchronization between the in-memory version of a memory-mapped Array or BitArray and the on-disk version.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Mmap.html#","page":"Memory-mapped I/O","title":"Memory-mapped I/O","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/Pkg.html#Pkg-1","page":"Pkg","title":"Pkg","text":"","category":"section"},{"location":"stdlib/Pkg.html#","page":"Pkg","title":"Pkg","text":"Pkg は Julia の組み込みパッケージ マネージャであり、パッケージのインストール、更新、削除などの操作を処理します。","category":"page"},{"location":"stdlib/Pkg.html#","page":"Pkg","title":"Pkg","text":"!!!メモ     以下は、Pkg の非常に簡単な紹介です。以下で入手可能な完全なマニュアルを読むことを強くお勧めします: https://julialang.github.io/Pkg.jl/v1/。","category":"page"},{"location":"stdlib/Pkg.html#","page":"Pkg","title":"Pkg","text":"import Markdown\nfile = joinpath(Sys.STDLIB, \"Pkg\", \"docs\", \"src\", \"getting-started.md\")\nstr = read(file, String)\nstr = replace(str, r\"^#.*$\"m => \"\")\nstr = replace(str, \"[API Reference](@ref)\" =>\n          \"[API Reference](https://julialang.github.io/Pkg.jl/v1/api/)\")\nMarkdown.parse(str)","category":"page"},{"location":"stdlib/Printf.html#Printf-1","page":"Printf","title":"Printf","text":"","category":"section"},{"location":"stdlib/Printf.html#","page":"Printf","title":"Printf","text":"DocTestSetup = :(using Printf)","category":"page"},{"location":"stdlib/Printf.html#","page":"Printf","title":"Printf","text":"Printf.@printf\nPrintf.@sprintf","category":"page"},{"location":"stdlib/Printf.html#Printf.@printf","page":"Printf","title":"Printf.@printf","text":"@printf([io::IOStream], \"%Fmt\", args...)\n\nPrint args using C printf style format specification string, with some caveats: Inf and NaN are printed consistently as Inf and NaN for flags %a, %A, %e, %E, %f, %F, %g, and %G. Furthermore, if a floating point number is equally close to the numeric values of two possible output strings, the output string further away from zero is chosen.\n\nOptionally, an IOStream may be passed as the first argument to redirect output.\n\nExamples\n\njulia> @printf(\"%f %F %f %F\\n\", Inf, Inf, NaN, NaN)\nInf Inf NaN NaN\n\n\njulia> @printf \"%.0f %.1f %f\\n\" 0.5 0.025 -0.0078125\n1 0.0 -0.007813\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Printf.html#Printf.@sprintf","page":"Printf","title":"Printf.@sprintf","text":"@sprintf(\"%Fmt\", args...)\n\nReturn @printf formatted output as string.\n\nExamples\n\njulia> s = @sprintf \"this is a %s %15.1f\" \"test\" 34.567;\n\njulia> println(s)\nthis is a test            34.6\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Printf.html#","page":"Printf","title":"Printf","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/Profile.html#lib-profiling-1","page":"Profiling","title":"Profiling","text":"","category":"section"},{"location":"stdlib/Profile.html#","page":"Profiling","title":"Profiling","text":"Profile.@profile","category":"page"},{"location":"stdlib/Profile.html#Profile.@profile","page":"Profiling","title":"Profile.@profile","text":"@profile\n\n@profile <expression> runs your expression while taking periodic backtraces. These are appended to an internal buffer of backtraces.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Profile.html#","page":"Profiling","title":"Profiling","text":"The methods in Profile are not exported and need to be called e.g. as Profile.print().","category":"page"},{"location":"stdlib/Profile.html#","page":"Profiling","title":"Profiling","text":"Profile.clear\nProfile.print\nProfile.init\nProfile.fetch\nProfile.retrieve\nProfile.callers\nProfile.clear_malloc_data","category":"page"},{"location":"stdlib/Profile.html#Profile.clear","page":"Profiling","title":"Profile.clear","text":"clear()\n\nClear any existing backtraces from the internal buffer.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Profile.html#Profile.print","page":"Profiling","title":"Profile.print","text":"print([io::IO = stdout,] [data::Vector]; kwargs...)\n\nPrints profiling results to io (by default, stdout). If you do not supply a data vector, the internal buffer of accumulated backtraces will be used.\n\nThe keyword arguments can be any combination of:\n\nformat – Determines whether backtraces are printed with (default, :tree) or without (:flat) indentation indicating tree structure.\nC – If true, backtraces from C and Fortran code are shown (normally they are excluded).\ncombine – If true (default), instruction pointers are merged that correspond to the same line of code.\nmaxdepth – Limits the depth higher than maxdepth in the :tree format.\nsortedby – Controls the order in :flat format. :filefuncline (default) sorts by the source  line, whereas :count sorts in order of number of collected samples.\nnoisefloor – Limits frames that exceed the heuristic noise floor of the sample (only applies to format :tree).  A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which n <= noisefloor * √N,  where n is the number of samples on this line, and N is the number of samples for the callee.\nmincount – Limits the printout to only those lines with at least mincount occurrences.\n\n\n\n\n\nprint([io::IO = stdout,] data::Vector, lidict::LineInfoDict; kwargs...)\n\nPrints profiling results to io. This variant is used to examine results exported by a previous call to retrieve. Supply the vector data of backtraces and a dictionary lidict of line information.\n\nSee Profile.print([io], data) for an explanation of the valid keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Profile.html#Profile.init","page":"Profiling","title":"Profile.init","text":"init(; n::Integer, delay::Float64)\n\nConfigure the delay between backtraces (measured in seconds), and the number n of instruction pointers that may be stored. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long list of instruction pointers. Default settings can be obtained by calling this function with no arguments, and each can be set independently using keywords or in the order (n, delay).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Profile.html#Profile.fetch","page":"Profiling","title":"Profile.fetch","text":"fetch() -> data\n\nReturns a reference to the internal buffer of backtraces. Note that subsequent operations, like clear, can affect data unless you first make a copy. Note that the values in data have meaning only on this machine in the current session, because it depends on the exact memory addresses used in JIT-compiling. This function is primarily for internal use; retrieve may be a better choice for most users.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Profile.html#Profile.retrieve","page":"Profiling","title":"Profile.retrieve","text":"retrieve() -> data, lidict\n\n\"Exports\" profiling results in a portable format, returning the set of all backtraces (data) and a dictionary that maps the (session-specific) instruction pointers in data to LineInfo values that store the file name, function name, and line number. This function allows you to save profiling results for future analysis.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Profile.html#Profile.callers","page":"Profiling","title":"Profile.callers","text":"callers(funcname, [data, lidict], [filename=<filename>], [linerange=<start:stop>]) -> Vector{Tuple{count, lineinfo}}\n\nGiven a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace data obtained from retrieve; otherwise, the current internal profile buffer is used.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Profile.html#Profile.clear_malloc_data","page":"Profiling","title":"Profile.clear_malloc_data","text":"clear_malloc_data()\n\nClears any stored memory allocation data when running julia with --track-allocation. Execute the command(s) you want to test (to force JIT-compilation), then call clear_malloc_data. Then execute your command(s) again, quit Julia, and examine the resulting *.mem files.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/REPL.html#The-Julia-REPL-1","page":"The Julia REPL","title":"The Julia REPL","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Julia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into the julia executable. In addition to allowing quick and easy evaluation of Julia statements, it has a searchable history, tab-completion, many helpful keybindings, and dedicated help and shell modes. The REPL can be started by simply calling julia with no arguments or double-clicking on the executable:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"io = IOBuffer()\nBase.banner(io)\nbanner = String(take!(io))\nimport Markdown\nMarkdown.parse(\"```\\n\\$ julia\\n\\n$(banner)\\njulia>\\n```\")","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"To exit the interactive session, type ^D – the control key together with the d key on a blank line – or type exit() followed by the return or enter key. The REPL greets you with a banner and a julia> prompt.","category":"page"},{"location":"stdlib/REPL.html#The-different-prompt-modes-1","page":"The Julia REPL","title":"The different prompt modes","text":"","category":"section"},{"location":"stdlib/REPL.html#The-Julian-mode-1","page":"The Julia REPL","title":"The Julian mode","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"The REPL has four main modes of operation. The first and most common is the Julian prompt. It is the default mode of operation; each new line initially starts with julia>. It is here that you can enter Julia expressions. Hitting return or enter after a complete expression has been entered will evaluate the entry and show the result of the last expression.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> string(1 + 2)\n\"3\"","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"There are a number useful features unique to interactive work. In addition to showing the result, the REPL also binds the result to the variable ans. A trailing semicolon on the line can be used as a flag to suppress showing the result.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> string(3 * 4);\n\njulia> ans\n\"12\"","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"In Julia mode, the REPL supports something called prompt pasting. This activates when pasting text that starts with julia> into the REPL. In that case, only expressions starting with julia> are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with REPL.enable_promptpaste(::Bool). If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.","category":"page"},{"location":"stdlib/REPL.html#Help-mode-1","page":"The Julia REPL","title":"Help mode","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"When the cursor is at the beginning of the line, the prompt can be changed to a help mode by typing ?. Julia will attempt to print help or documentation for anything entered in help mode:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> ? # upon typing ?, the prompt changes (in place) to: help?>\n\nhelp?> string\nsearch: string String Cstring Cwstring RevString randstring bytestring SubString\n\n  string(xs...)\n\n  Create a string from any values using the print function.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Macros, types and variables can also be queried:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"help?> @time\n  @time\n\n  A macro to execute an expression, printing the time it took to execute, the number of allocations,\n  and the total number of bytes its execution caused to be allocated, before returning the value of the\n  expression.\n\n  See also @timev, @timed, @elapsed, and @allocated.\n\nhelp?> Int32\nsearch: Int32 UInt32\n\n  Int32 <: Signed\n\n  32-bit signed integer type.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Help mode can be exited by pressing backspace at the beginning of the line.","category":"page"},{"location":"stdlib/REPL.html#man-shell-mode-1","page":"The Julia REPL","title":"Shell mode","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Just as help mode is useful for quick access to documentation, another common task is to use the system shell to execute system commands. Just as ? entered help mode when at the beginning of the line, a semicolon (;) will enter the shell mode. And it can be exited by pressing backspace at the beginning of the line.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> ; # upon typing ;, the prompt changes (in place) to: shell>\n\nshell> echo hello\nhello","category":"page"},{"location":"stdlib/REPL.html#Search-modes-1","page":"The Julia REPL","title":"Search modes","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"In all of the above modes, the executed lines get saved to a history file, which can be searched.  To initiate an incremental search through the previous history, type ^R – the control key together with the r key. The prompt will change to (reverse-i-search)`':, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type ^R again.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Just as ^R is a reverse search, ^S is a forward search, with the prompt (i-search)`':.  The two may be used in conjunction with each other to move through the previous or next matching results, respectively.","category":"page"},{"location":"stdlib/REPL.html#Key-bindings-1","page":"The Julia REPL","title":"Key bindings","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (^D to exit, ^R and ^S for searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so).","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Keybinding Description\nProgram control \n^D Exit (when buffer is empty)\n^C Interrupt or cancel\n^L Clear console screen\nReturn/Enter, ^J New line, executing if it is complete\nmeta-Return/Enter Insert new line without executing it\n? or ; Enter help or shell mode (when at start of a line)\n^R, ^S Incremental history search, described above\nCursor movement \nRight arrow, ^F Move right one character\nLeft arrow, ^B Move left one character\nctrl-Right, meta-F Move right one word\nctrl-Left, meta-B Move left one word\nHome, ^A Move to beginning of line\nEnd, ^E Move to end of line\nUp arrow, ^P Move up one line (or change to the previous history entry that matches the text before the cursor)\nDown arrow, ^N Move down one line (or change to the next history entry that matches the text before the cursor)\nShift-Arrow Key Move cursor according to the direction of the Arrow key, while activating the region (\"shift selection\")\nPage-up, meta-P Change to the previous history entry\nPage-down, meta-N Change to the next history entry\nmeta-< Change to the first history entry (of the current session if it is before the current position in history)\nmeta-> Change to the last history entry\n^-Space Set the \"mark\" in the editing region (and de-activate the region if it's active)\n^-Space ^-Space Set the \"mark\" in the editing region and make the region \"active\", i.e. highlighted\n^G De-activate the region (i.e. make it not highlighted)\n^X^X Exchange the current position with the mark\nEditing \nBackspace, ^H Delete the previous character, or the whole region when it's active\nDelete, ^D Forward delete one character (when buffer has text)\nmeta-Backspace Delete the previous word\nmeta-d Forward delete the next word\n^W Delete previous text up to the nearest whitespace\nmeta-w Copy the current region in the kill ring\nmeta-W \"Kill\" the current region, placing the text in the kill ring\n^K \"Kill\" to end of line, placing the text in the kill ring\n^Y \"Yank\" insert the text from the kill ring\nmeta-y Replace a previously yanked text with an older entry from the kill ring\n^T Transpose the characters about the cursor\nmeta-Up arrow Transpose current line with line above\nmeta-Down arrow Transpose current line with line below\nmeta-u Change the next word to uppercase\nmeta-c Change the next word to titlecase\nmeta-l Change the next word to lowercase\n^/, ^_ Undo previous editing action\n^Q Write a number in REPL and press ^Q to open editor at corresponding stackframe or method\nmeta-Left Arrow indent the current line on the left\nmeta-Right Arrow indent the current line on the right","category":"page"},{"location":"stdlib/REPL.html#Customizing-keybindings-1","page":"The Julia REPL","title":"Customizing keybindings","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary to REPL.setup_interface. The keys of this dictionary may be characters or strings. The key '*' refers to the default action. Control plus character x bindings are indicated with \"^x\".  Meta plus x can be written \"\\\\Mx\". The values of the custom keymap must be nothing (indicating that the input should be ignored) or functions that accept the signature (PromptState, AbstractREPL, Char).  The REPL.setup_interface function must be called before the REPL is initialized, by registering the operation with atreplinit . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in ~/.julia/config/startup.jl:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"import REPL\nimport REPL.LineEdit\n\nconst mykeys = Dict{Any,Any}(\n    # Up Arrow\n    \"\\e[A\" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_prev(s, LineEdit.mode(s).hist)),\n    # Down Arrow\n    \"\\e[B\" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_next(s, LineEdit.mode(s).hist))\n)\n\nfunction customize_keys(repl)\n    repl.interface = REPL.setup_interface(repl; extra_repl_keymap = mykeys)\nend\n\natreplinit(customize_keys)","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Users should refer to LineEdit.jl to discover the available actions on key input.","category":"page"},{"location":"stdlib/REPL.html#Tab-completion-1","page":"The Julia REPL","title":"Tab completion","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> stri[TAB]\nstride     strides     string      strip\n\njulia> Stri[TAB]\nStridedArray    StridedMatrix    StridedVecOrMat  StridedVector    String","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"The tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents, and get a list of LaTeX matches as well:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> \\pi[TAB]\njulia> π\nπ = 3.1415926535897...\n\njulia> e\\_1[TAB] = [1,0]\njulia> e₁ = [1,0]\n2-element Array{Int64,1}:\n 1\n 0\n\njulia> e\\^1[TAB] = [1 0]\njulia> e¹ = [1 0]\n1×2 Array{Int64,2}:\n 1  0\n\njulia> \\sqrt[TAB]2     # √ is equivalent to the sqrt function\njulia> √2\n1.4142135623730951\n\njulia> \\hbar[TAB](h) = h / 2\\pi[TAB]\njulia> ħ(h) = h / 2π\nħ (generic function with 1 method)\n\njulia> \\h[TAB]\n\\hat              \\hermitconjmatrix  \\hkswarow          \\hrectangle\n\\hatapprox        \\hexagon           \\hookleftarrow     \\hrectangleblack\n\\hbar             \\hexagonblack      \\hookrightarrow    \\hslash\n\\heartsuit        \\hksearow          \\house             \\hspace\n\njulia> α=\"\\alpha[TAB]\"   # LaTeX completion also works in strings\njulia> α=\"α\"","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"A full list of tab-completions can be found in the Unicode Input section of the manual.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Completion of paths works for strings and julia's shell mode:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> path=\"/[TAB]\"\n.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/\n.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/\nshell> /[TAB]\n.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/\n.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Tab completion can help with investigation of the available methods matching the input arguments:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> max([TAB] # All methods are displayed, not shown here due to size of the list\n\njulia> max([1, 2], [TAB] # All methods where `Vector{Int}` matches as first argument\nmax(x, y) in Base at operators.jl:215\nmax(a, b, c, xs...) in Base at operators.jl:281\n\njulia> max([1, 2], max(1, 2), [TAB] # All methods matching the arguments.\nmax(x, y) in Base at operators.jl:215\nmax(a, b, c, xs...) in Base at operators.jl:281","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Keywords are also displayed in the suggested methods after ;, see below line where limit and keepempty are keyword arguments:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> split(\"1 1 1\", [TAB]\nsplit(str::AbstractString; limit, keepempty) in Base at strings/util.jl:302\nsplit(str::T, splitter; limit, keepempty) where T<:AbstractString in Base at strings/util.jl:277","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"The completion of the methods uses type inference and can therefore see if the arguments match even if the arguments are output from functions. The function needs to be type stable for the completion to be able to remove non-matching methods.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Tab completion can also help completing fields:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> import UUIDs\n\njulia> UUIDs.uuid[TAB]\nuuid1        uuid4         uuid_version","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Fields for output from functions can also be completed:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> split(\"\",\"\")[1].[TAB]\nlastindex  offset  string","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"The completion of fields for output from functions uses type inference, and it can only suggest fields if the function is type stable.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Dictionary keys can also be tab completed:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> foo = Dict(\"qwer1\"=>1, \"qwer2\"=>2, \"asdf\"=>3)\nDict{String,Int64} with 3 entries:\n  \"qwer2\" => 2\n  \"asdf\"  => 3\n  \"qwer1\" => 1\n\njulia> foo[\"q[TAB]\n\n\"qwer1\" \"qwer2\"\njulia> foo[\"qwer","category":"page"},{"location":"stdlib/REPL.html#Customizing-Colors-1","page":"The Julia REPL","title":"Customizing Colors","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"The colors used by Julia and the REPL can be customized, as well. To change the color of the Julia prompt you can add something like the following to your ~/.julia/config/startup.jl file, which is to be placed inside your home directory:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"function customize_colors(repl)\n    repl.prompt_color = Base.text_colors[:cyan]\nend\n\natreplinit(customize_colors)","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"The available color keys can be seen by typing Base.text_colors in the help mode of the REPL.  In addition, the integers 0 to 255 can be used as color keys for terminals with 256 color support.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"You can also change the colors for the help and shell prompts and input and answer text by setting the appropriate field of repl in the customize_colors function above (respectively, help_color, shell_color, input_color, and answer_color). For the latter two, be sure that the envcolors field is also set to false.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"It is also possible to apply boldface formatting by using Base.text_colors[:bold] as a color. For instance, to print answers in boldface font, one can use the following as a ~/.julia/config/startup.jl:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"function customize_colors(repl)\n    repl.envcolors = false\n    repl.answer_color = Base.text_colors[:bold]\nend\n\natreplinit(customize_colors)","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"You can also customize the color used to render warning and informational messages by setting the appropriate environment variables. For instance, to render error, warning, and informational messages respectively in magenta, yellow, and cyan you can add the following to your ~/.julia/config/startup.jl file:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"ENV[\"JULIA_ERROR_COLOR\"] = :magenta\nENV[\"JULIA_WARN_COLOR\"] = :yellow\nENV[\"JULIA_INFO_COLOR\"] = :cyan","category":"page"},{"location":"stdlib/REPL.html#TerminalMenus-1","page":"The Julia REPL","title":"TerminalMenus","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"TerminalMenus is a submodule of the Julia REPL and enables small, low-profile interactive menus in the terminal.","category":"page"},{"location":"stdlib/REPL.html#例-1","page":"The Julia REPL","title":"例","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"import REPL\nusing REPL.TerminalMenus\n\noptions = [\"apple\", \"orange\", \"grape\", \"strawberry\",\n            \"blueberry\", \"peach\", \"lemon\", \"lime\"]\n","category":"page"},{"location":"stdlib/REPL.html#RadioMenu-1","page":"The Julia REPL","title":"RadioMenu","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"The RadioMenu allows the user to select one option from the list. The request function displays the interactive menu and returns the index of the selected choice. If a user presses 'q' or ctrl-c, request will return a -1.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"# `pagesize` is the number of items to be displayed at a time.\n#  The UI will scroll if the number of options is greater\n#   than the `pagesize`\nmenu = RadioMenu(options, pagesize=4)\n\n# `request` displays the menu and returns the index after the\n#   user has selected a choice\nchoice = request(\"Choose your favorite fruit:\", menu)\n\nif choice != -1\n    println(\"Your favorite fruit is \", options[choice], \"!\")\nelse\n    println(\"Menu canceled.\")\nend\n","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Output:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Choose your favorite fruit:\n^  grape\n   strawberry\n > blueberry\nv  peach\nYour favorite fruit is blueberry!","category":"page"},{"location":"stdlib/REPL.html#MultiSelectMenu-1","page":"The Julia REPL","title":"MultiSelectMenu","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"The MultiSelectMenu allows users to select many choices from a list.","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"# here we use the default `pagesize` 10\nmenu = MultiSelectMenu(options)\n\n# `request` returns a `Set` of selected indices\n# if the menu us canceled (ctrl-c or q), return an empty set\nchoices = request(\"Select the fruits you like:\", menu)\n\nif length(choices) > 0\n    println(\"You like the following fruits:\")\n    for i in choices\n        println(\"  - \", options[i])\n    end\nelse\n    println(\"Menu canceled.\")\nend","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Output:","category":"page"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Select the fruits you like:\n[press: d=done, a=all, n=none]\n   [ ] apple\n > [X] orange\n   [X] grape\n   [ ] strawberry\n   [ ] blueberry\n   [X] peach\n   [ ] lemon\n   [ ] lime\nYou like the following fruits:\n  - orange\n  - grape\n  - peach","category":"page"},{"location":"stdlib/REPL.html#Customization-/-Configuration-1","page":"The Julia REPL","title":"Customization / Configuration","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"All interface customization is done through the keyword only TerminalMenus.config() function.","category":"page"},{"location":"stdlib/REPL.html#Arguments-1","page":"The Julia REPL","title":"Arguments","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"charset::Symbol=:na: ui characters to use (:ascii or :unicode); overridden by other arguments\ncursor::Char='>'|'→': character to use for cursor\nup_arrow::Char='^'|'↑': character to use for up arrow\ndown_arrow::Char='v'|'↓': character to use for down arrow\nchecked::String=\"[X]\"|\"✓\": string to use for checked\nunchecked::String=\"[ ]\"|\"⬚\"): string to use for unchecked\nscroll::Symbol=:na: If :wrap then wrap the cursor around top and bottom, if :nowrap do not wrap cursor\nsupress_output::Bool=false: For testing. If true, menu will not be printed to console.\nctrl_c_interrupt::Bool=true: If false, return empty on ^C, if true throw InterruptException() on ^C","category":"page"},{"location":"stdlib/REPL.html#例-2","page":"The Julia REPL","title":"例","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"julia> menu = MultiSelectMenu(options, pagesize=5);\n\njulia> request(menu) # ASCII is used by default\n[press: d=done, a=all, n=none]\n   [ ] apple\n   [X] orange\n   [ ] grape\n > [X] strawberry\nv  [ ] blueberry\nSet([4, 2])\n\njulia> TerminalMenus.config(charset=:unicode)\n\njulia> request(menu)\n[press: d=done, a=all, n=none]\n   ⬚ apple\n   ✓ orange\n   ⬚ grape\n → ✓ strawberry\n↓  ⬚ blueberry\nSet([4, 2])\n\njulia> TerminalMenus.config(checked=\"YEP!\", unchecked=\"NOPE\", cursor='⧐')\n\njulia> request(menu)\n[press: d=done, a=all, n=none]\n   NOPE apple\n   YEP! orange\n   NOPE grape\n ⧐ YEP! strawberry\n↓  NOPE blueberry\nSet([4, 2])\n","category":"page"},{"location":"stdlib/REPL.html#References-1","page":"The Julia REPL","title":"References","text":"","category":"section"},{"location":"stdlib/REPL.html#","page":"The Julia REPL","title":"The Julia REPL","text":"Base.atreplinit","category":"page"},{"location":"stdlib/REPL.html#Base.atreplinit","page":"The Julia REPL","title":"Base.atreplinit","text":"atreplinit(f)\n\nRegister a one-argument function to be called before the REPL interface is initialized in interactive sessions; this is useful to customize the interface. The argument of f is the REPL object. This function should be called from within the .julia/config/startup.jl initialization file.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random-Numbers-1","page":"Random Numbers","title":"Random Numbers","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"DocTestSetup = :(using Random)","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Random number generation in Julia uses the Mersenne Twister library  via MersenneTwister objects. Julia has a global RNG, which is used by default. Other RNG types can be plugged in by inheriting the AbstractRNG type; they can then be used to have multiple streams of random numbers. Besides MersenneTwister, Julia also provides the RandomDevice RNG type, which is a wrapper over the OS provided entropy.","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Most functions related to random generation accept an optional AbstractRNG object as first argument, which defaults to the global one if not provided. Moreover, some of them accept optionally dimension specifications dims... (which can be given as a tuple) to generate arrays of random values.","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"A MersenneTwister or RandomDevice RNG can generate uniformly random numbers of the following types: Float16, Float32, Float64, BigFloat, Bool, Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Int128, UInt128, BigInt (or complex numbers of those types). Random floating point numbers are generated uniformly in 0 1). As BigInt represents unbounded integers, the interval must be specified (e.g. rand(big.(1:6))).","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Additionally, normal and exponential distributions are implemented for some AbstractFloat and Complex types, see randn and randexp for details.","category":"page"},{"location":"stdlib/Random.html#Random-numbers-module-1","page":"Random Numbers","title":"Random numbers module","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Random.Random","category":"page"},{"location":"stdlib/Random.html#Random.Random","page":"Random Numbers","title":"Random.Random","text":"Random\n\nSupport for generating random numbers. Provides rand, randn, AbstractRNG, MersenneTwister, and RandomDevice.\n\n\n\n\n\n","category":"module"},{"location":"stdlib/Random.html#Random-generation-functions-1","page":"Random Numbers","title":"Random generation functions","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Random.rand\nRandom.rand!\nRandom.bitrand\nRandom.randn\nRandom.randn!\nRandom.randexp\nRandom.randexp!\nRandom.randstring","category":"page"},{"location":"stdlib/Random.html#Base.rand","page":"Random Numbers","title":"Base.rand","text":"rand([rng=GLOBAL_RNG], [S], [dims...])\n\nPick a random element or array of random elements from the set of values specified by S; S can be\n\nan indexable collection (for example 1:9 or ('x', \"y\", :z)),\nan AbstractDict or AbstractSet object,\na string (considered as a collection of characters), or\na type: the set of values to pick from is then equivalent to typemin(S):typemax(S) for integers (this is not applicable to BigInt), and to 0 1) for floating point numbers;\n\nS defaults to Float64.\n\ncompat: Julia 1.1\nSupport for S as a tuple requires at least Julia 1.1.\n\nExamples\n\njulia> rand(Int, 2)\n2-element Array{Int64,1}:\n 1339893410598768192\n 1575814717733606317\n\njulia> using Random\n\njulia> rand(MersenneTwister(0), Dict(1=>2, 3=>4))\n1=>2\n\nnote: Note\nThe complexity of rand(rng, s::Union{AbstractDict,AbstractSet}) is linear in the length of s, unless an optimized method with constant complexity is available, which is the case for Dict, Set and BitSet. For more than a few calls, use rand(rng, collect(s)) instead, or either rand(rng, Dict(s)) or rand(rng, Set(s)) as appropriate.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.rand!","page":"Random Numbers","title":"Random.rand!","text":"rand!([rng=GLOBAL_RNG], A, [S=eltype(A)])\n\nPopulate the array A with random values. If S is specified (S can be a type or a collection, cf. rand for details), the values are picked randomly from S. This is equivalent to copyto!(A, rand(rng, S, size(A))) but without allocating a new array.\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> rand!(rng, zeros(5))\n5-element Array{Float64,1}:\n 0.5908446386657102\n 0.7667970365022592\n 0.5662374165061859\n 0.4600853424625171\n 0.7940257103317943\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.bitrand","page":"Random Numbers","title":"Random.bitrand","text":"bitrand([rng=GLOBAL_RNG], [dims...])\n\nGenerate a BitArray of random boolean values.\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> bitrand(rng, 10)\n10-element BitArray{1}:\n 0\n 1\n 1\n 1\n 1\n 0\n 1\n 0\n 0\n 1\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Base.randn","page":"Random Numbers","title":"Base.randn","text":"randn([rng=GLOBAL_RNG], [T=Float64], [dims...])\n\nGenerate a normally-distributed random number of type T with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The Base module currently provides an implementation for the types Float16, Float32, and Float64 (the default), and their Complex counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution.\n\nExamples\n\njulia> using Random\n\njulia> rng = MersenneTwister(1234);\n\njulia> randn(rng, ComplexF64)\n0.6133070881429037 - 0.6376291670853887im\n\njulia> randn(rng, ComplexF32, (2, 3))\n2×3 Array{Complex{Float32},2}:\n -0.349649-0.638457im  0.376756-0.192146im  -0.396334-0.0136413im\n  0.611224+1.56403im   0.355204-0.365563im  0.0905552+1.31012im\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.randn!","page":"Random Numbers","title":"Random.randn!","text":"randn!([rng=GLOBAL_RNG], A::AbstractArray) -> A\n\nFill the array A with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the rand function.\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> randn!(rng, zeros(5))\n5-element Array{Float64,1}:\n  0.8673472019512456\n -0.9017438158568171\n -0.4944787535042339\n -0.9029142938652416\n  0.8644013132535154\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.randexp","page":"Random Numbers","title":"Random.randexp","text":"randexp([rng=GLOBAL_RNG], [T=Float64], [dims...])\n\nGenerate a random number of type T according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The Base module currently provides an implementation for the types Float16, Float32, and Float64 (the default).\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> randexp(rng, Float32)\n2.4835055f0\n\njulia> randexp(rng, 3, 3)\n3×3 Array{Float64,2}:\n 1.5167    1.30652   0.344435\n 0.604436  2.78029   0.418516\n 0.695867  0.693292  0.643644\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.randexp!","page":"Random Numbers","title":"Random.randexp!","text":"randexp!([rng=GLOBAL_RNG], A::AbstractArray) -> A\n\nFill the array A with random numbers following the exponential distribution (with scale 1).\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> randexp!(rng, zeros(5))\n5-element Array{Float64,1}:\n 2.4835053723904896\n 1.516703605376473\n 0.6044364871025417\n 0.6958665886385867\n 1.3065196315496677\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.randstring","page":"Random Numbers","title":"Random.randstring","text":"randstring([rng=GLOBAL_RNG], [chars], [len=8])\n\nCreate a random string of length len, consisting of characters from chars, which defaults to the set of upper- and lower-case letters and the digits 0-9. The optional rng argument specifies a random number generator, see Random Numbers.\n\nExamples\n\njulia> Random.seed!(0); randstring()\n\"0IPrGg0J\"\n\njulia> randstring(MersenneTwister(0), 'a':'z', 6)\n\"aszvqk\"\n\njulia> randstring(\"ACGT\")\n\"TATCGGTC\"\n\nnote: Note\nchars can be any collection of characters, of type Char or UInt8 (more efficient), provided rand can randomly pick characters from it.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Subsequences,-permutations-and-shuffling-1","page":"Random Numbers","title":"Subsequences, permutations and shuffling","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Random.randsubseq\nRandom.randsubseq!\nRandom.randperm\nRandom.randperm!\nRandom.randcycle\nRandom.randcycle!\nRandom.shuffle\nRandom.shuffle!","category":"page"},{"location":"stdlib/Random.html#Random.randsubseq","page":"Random Numbers","title":"Random.randsubseq","text":"randsubseq([rng=GLOBAL_RNG,] A, p) -> Vector\n\nReturn a vector consisting of a random subsequence of the given array A, where each element of A is included (in order) with independent probability p. (Complexity is linear in p*length(A), so this function is efficient even if p is small and A is large.) Technically, this process is known as \"Bernoulli sampling\" of A.\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> randsubseq(rng, collect(1:8), 0.3)\n2-element Array{Int64,1}:\n 7\n 8\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.randsubseq!","page":"Random Numbers","title":"Random.randsubseq!","text":"randsubseq!([rng=GLOBAL_RNG,] S, A, p)\n\nLike randsubseq, but the results are stored in S (which is resized as needed).\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> S = Int64[];\n\njulia> randsubseq!(rng, S, collect(1:8), 0.3);\n\njulia> S\n2-element Array{Int64,1}:\n 7\n 8\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.randperm","page":"Random Numbers","title":"Random.randperm","text":"randperm([rng=GLOBAL_RNG,] n::Integer)\n\nConstruct a random permutation of length n. The optional rng argument specifies a random number generator (see Random Numbers). The element type of the result is the same as the type of n.\n\nTo randomly permute an arbitrary vector, see shuffle or shuffle!.\n\ncompat: Julia 1.1\nIn Julia 1.1 randperm returns a vector v with eltype(v) == typeof(n) while in Julia 1.0 eltype(v) == Int.\n\nExamples\n\njulia> randperm(MersenneTwister(1234), 4)\n4-element Array{Int64,1}:\n 2\n 1\n 4\n 3\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.randperm!","page":"Random Numbers","title":"Random.randperm!","text":"randperm!([rng=GLOBAL_RNG,] A::Array{<:Integer})\n\nConstruct in A a random permutation of length length(A). The optional rng argument specifies a random number generator (see Random Numbers). To randomly permute an arbitrary vector, see shuffle or shuffle!.\n\nExamples\n\njulia> randperm!(MersenneTwister(1234), Vector{Int}(undef, 4))\n4-element Array{Int64,1}:\n 2\n 1\n 4\n 3\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.randcycle","page":"Random Numbers","title":"Random.randcycle","text":"randcycle([rng=GLOBAL_RNG,] n::Integer)\n\nConstruct a random cyclic permutation of length n. The optional rng argument specifies a random number generator, see Random Numbers. The element type of the result is the same as the type of n.\n\ncompat: Julia 1.1\nIn Julia 1.1 randcycle returns a vector v with eltype(v) == typeof(n) while in Julia 1.0 eltype(v) == Int.\n\nExamples\n\njulia> randcycle(MersenneTwister(1234), 6)\n6-element Array{Int64,1}:\n 3\n 5\n 4\n 6\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.randcycle!","page":"Random Numbers","title":"Random.randcycle!","text":"randcycle!([rng=GLOBAL_RNG,] A::Array{<:Integer})\n\nConstruct in A a random cyclic permutation of length length(A). The optional rng argument specifies a random number generator, see Random Numbers.\n\nExamples\n\njulia> randcycle!(MersenneTwister(1234), Vector{Int}(undef, 6))\n6-element Array{Int64,1}:\n 3\n 5\n 4\n 6\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.shuffle","page":"Random Numbers","title":"Random.shuffle","text":"shuffle([rng=GLOBAL_RNG,] v::AbstractArray)\n\nReturn a randomly permuted copy of v. The optional rng argument specifies a random number generator (see Random Numbers). To permute v in-place, see shuffle!. To obtain randomly permuted indices, see randperm.\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> shuffle(rng, Vector(1:10))\n10-element Array{Int64,1}:\n  6\n  1\n 10\n  2\n  3\n  9\n  5\n  7\n  4\n  8\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.shuffle!","page":"Random Numbers","title":"Random.shuffle!","text":"shuffle!([rng=GLOBAL_RNG,] v::AbstractArray)\n\nIn-place version of shuffle: randomly permute v in-place, optionally supplying the random-number generator rng.\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> shuffle!(rng, Vector(1:16))\n16-element Array{Int64,1}:\n  2\n 15\n  5\n 14\n  1\n  9\n 10\n  6\n 11\n  3\n 16\n  7\n  4\n 12\n  8\n 13\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Generators-(creation-and-seeding)-1","page":"Random Numbers","title":"Generators (creation and seeding)","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Random.seed!\nRandom.AbstractRNG\nRandom.MersenneTwister\nRandom.RandomDevice","category":"page"},{"location":"stdlib/Random.html#Random.seed!","page":"Random Numbers","title":"Random.seed!","text":"seed!([rng=GLOBAL_RNG], seed) -> rng\nseed!([rng=GLOBAL_RNG]) -> rng\n\nReseed the random number generator: rng will give a reproducible sequence of numbers if and only if a seed is provided. Some RNGs don't accept a seed, like RandomDevice. After the call to seed!, rng is equivalent to a newly created object initialized with the same seed.\n\nExamples\n\njulia> Random.seed!(1234);\n\njulia> x1 = rand(2)\n2-element Array{Float64,1}:\n 0.590845\n 0.766797\n\njulia> Random.seed!(1234);\n\njulia> x2 = rand(2)\n2-element Array{Float64,1}:\n 0.590845\n 0.766797\n\njulia> x1 == x2\ntrue\n\njulia> rng = MersenneTwister(1234); rand(rng, 2) == x1\ntrue\n\njulia> MersenneTwister(1) == Random.seed!(rng, 1)\ntrue\n\njulia> rand(Random.seed!(rng), Bool) # not reproducible\ntrue\n\njulia> rand(Random.seed!(rng), Bool)\nfalse\n\njulia> rand(MersenneTwister(), Bool) # not reproducible either\ntrue\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Random.html#Random.AbstractRNG","page":"Random Numbers","title":"Random.AbstractRNG","text":"AbstractRNG\n\nSupertype for random number generators such as MersenneTwister and RandomDevice.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Random.html#Random.MersenneTwister","page":"Random Numbers","title":"Random.MersenneTwister","text":"MersenneTwister(seed)\nMersenneTwister()\n\nCreate a MersenneTwister RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers. The seed may be a non-negative integer or a vector of UInt32 integers. If no seed is provided, a randomly generated one is created (using entropy from the system). See the seed! function for reseeding an already existing MersenneTwister object.\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> x1 = rand(rng, 2)\n2-element Array{Float64,1}:\n 0.5908446386657102\n 0.7667970365022592\n\njulia> rng = MersenneTwister(1234);\n\njulia> x2 = rand(rng, 2)\n2-element Array{Float64,1}:\n 0.5908446386657102\n 0.7667970365022592\n\njulia> x1 == x2\ntrue\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Random.html#Random.RandomDevice","page":"Random Numbers","title":"Random.RandomDevice","text":"RandomDevice()\n\nCreate a RandomDevice RNG object. Two such objects will always generate different streams of random numbers. The entropy is obtained from the operating system.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Random.html#Hooking-into-the-Random-API-1","page":"Random Numbers","title":"Hooking into the Random API","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"There are two mostly orthogonal ways to extend Random functionalities: 1) generating random values of custom types 2) creating new generators","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"The API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases of the Random module.  For example, it's typically sufficient to implement one rand method in order to have all other usual methods work automatically.","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"The API for 2) is still rudimentary, and may require more work than strictly necessary from the implementor, in order to support usual types of generated values.","category":"page"},{"location":"stdlib/Random.html#Generating-random-values-of-custom-types-1","page":"Random Numbers","title":"Generating random values of custom types","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"There are two categories: generating values from a type (e.g. rand(Int)), or from a collection (e.g. rand(1:3)).  The simple cases are explained first, and more advanced usage is presented later.  We assume here that the choice of algorithm is independent of the RNG, so we use AbstractRNG in our signatures.","category":"page"},{"location":"stdlib/Random.html#Generating-values-from-a-type-1","page":"Random Numbers","title":"Generating values from a type","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Given a type T, it's currently assumed that if rand(T) is defined, an object of type T will be produced.  In order to define random generation of values of type T, the following method can be defined: rand(rng::AbstractRNG, ::Random.SamplerType{T}) (this should return what rand(rng, T) is expected to return).","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Let's take the following example: we implement a Die type, with a variable number n of sides, numbered from 1 to n.  We want rand(Die) to produce a die with a random number of up to 20 sides (and at least 4):","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"struct Die\n    nsides::Int # number of sides\nend\n\nRandom.rand(rng::AbstractRNG, ::Random.SamplerType{Die}) = Die(rand(rng, 4:20))\n\n# output\n","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Scalar and array methods for Die now work as expected:","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"julia> rand(Die)\nDie(18)\n\njulia> rand(MersenneTwister(0), Die)\nDie(4)\n\njulia> rand(Die, 3)\n3-element Array{Die,1}:\n Die(6)\n Die(11)\n Die(5)\n\njulia> a = Vector{Die}(undef, 3); rand!(a)\n3-element Array{Die,1}:\n Die(18)\n Die(6)\n Die(8)","category":"page"},{"location":"stdlib/Random.html#Generating-values-from-a-collection-1","page":"Random Numbers","title":"Generating values from a collection","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Given a collection type S, it's currently assumed that if rand(::S) is defined, an object of type eltype(S) will be produced.  In order to define random generation out of objects of type S, the following method can be defined: rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S}). Here, sp simply wraps an object of type S, which can be accessed via sp[]. Continuing the Die example, we want now to define rand(d::Die) to produce an Int corresponding to one of d's sides:","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"julia> Random.rand(rng::AbstractRNG, d::Random.SamplerTrivial{Die}) = rand(rng, 1:d[].nsides);\n\njulia> rand(Die(4))\n3\n\njulia> rand(Die(4), 3)\n3-element Array{Any,1}:\n 3\n 4\n 2","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"In the last example, a Vector{Any} is produced; the reason is that eltype(Die) == Any. The remedy is to define Base.eltype(::Type{Die}) = Int.","category":"page"},{"location":"stdlib/Random.html#Generating-values-for-an-AbstractFloat-type-1","page":"Random Numbers","title":"Generating values for an AbstractFloat type","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"AbstractFloat types are special-cased, because by default random values are not produced in the whole type domain, but rather in [0,1). The following method should be implemented for T <: AbstractFloat: Random.rand(::AbstractRNG, ::Random.SamplerTrivial{Random.CloseOpen01{T}})","category":"page"},{"location":"stdlib/Random.html#Optimizing-generation-with-cached-computation-between-calls-1","page":"Random Numbers","title":"Optimizing generation with cached computation between calls","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"When repeatedly generating random values (with the same rand parameters), it happens for some types that the result of a computation is used for each call. In this case, the computation can be decoupled from actually generating the values. This is the case for example with the default implementation for AbstractArray. Assume that rand(rng, 1:20) has to be called repeatedly in a loop: the way to take advantage of this decoupling is as follows:","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"rng = MersenneTwister()\nsp = Random.Sampler(rng, 1:20) # or Random.Sampler(MersenneTwister,1:20)\nfor x in X\n    n = rand(rng, sp) # similar to n = rand(rng, 1:20)\n    # use n\nend","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"This mechanism is of course used by the default implementation of random array generation (like in rand(1:20, 10)).  In order to implement this decoupling for a custom type, a helper type can be used.  Going back to our Die example: rand(::Die) uses random generation from a range, so there is an opportunity for this optimization:","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"import Random: Sampler, rand\n\nstruct SamplerDie <: Sampler{Int} # generates values of type Int\n    die::Die\n    sp::Sampler{Int} # this is an abstract type, so this could be improved\nend\n\nSampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =\n    SamplerDie(die, Sampler(RNG, 1:die.nsides, r))\n# the `r` parameter will be explained later on\n\nrand(rng::AbstractRNG, sp::SamplerDie) = rand(rng, sp.sp)","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"It's now possible to get a sampler with sp = Sampler(rng, die), and use sp instead of die in any rand call involving rng.  In the simplistic example above, die doesn't need to be stored in SamplerDie but this is often the case in practice.","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"This pattern is so frequent that a helper type named Random.SamplerSimple is available, saving us the definition of SamplerDie: we could have implemented our decoupling with:","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Sampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =\n    SamplerSimple(die, Sampler(RNG, 1:die.nsides, r))\n\nrand(rng::AbstractRNG, sp::SamplerSimple{Die}) = rand(rng, sp.data)","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Here, sp.data refers to the second parameter in the call to the SamplerSimple constructor (in this case equal to Sampler(rng, 1:die.nsides, r)), while the Die object can be accessed via sp[].","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Another helper type is currently available for other cases, Random.SamplerTag, but is considered as internal API, and can break at any time without proper deprecations.","category":"page"},{"location":"stdlib/Random.html#Using-distinct-algorithms-for-scalar-or-array-generation-1","page":"Random Numbers","title":"Using distinct algorithms for scalar or array generation","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of algorithm. This is handled with the third parameter of the Sampler constructor. Let's assume we defined two helper types for Die, say SamplerDie1 which should be used to generate only few random values, and SamplerDieMany for many values.  We can use those types as follows:","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Sampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{1}) = SamplerDie1(...)\nSampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{Inf}) = SamplerDieMany(...)","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Of course, rand must also be defined on those types (i.e. rand(::AbstractRNG, ::SamplerDie1) and rand(::AbstractRNG, ::SamplerDieMany)).","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Note: Sampler(rng, x) is simply a shorthand for Sampler(rng, x, Val(Inf)), and Random.Repetition is an alias for Union{Val{1}, Val{Inf}}.","category":"page"},{"location":"stdlib/Random.html#Creating-new-generators-1","page":"Random Numbers","title":"Creating new generators","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"The API is not clearly defined yet, but as a rule of thumb:","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"any rand method producing \"basic\" types (isbitstype integer and floating types in Base) should be defined for this specific RNG, if they are needed;\nother documented rand methods accepting an AbstractRNG should work out of the box, (provided the methods from 1) what are relied on are implemented), but can of course be specialized for this RNG if there is room for optimization.","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Concerning 1), a rand method may happen to work automatically, but it's not officially supported and may break without warnings in a subsequent release.","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"To define a new rand method for an hypothetical MyRNG generator, and a value specification s (e.g. s == Int, or s == 1:10) of type S==typeof(s) or S==Type{s} if s is a type, the same two methods as we saw before must be defined:","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"Sampler(::Type{MyRNG}, ::S, ::Repetition), which returns an object of type say SamplerS\nrand(rng::MyRNG, sp::SamplerS)","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"It can happen that Sampler(rng::AbstractRNG, ::S, ::Repetition) is already defined in the Random module. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding SamplerS type is considered as internal detail, and may be changed without warning.","category":"page"},{"location":"stdlib/Random.html#Specializing-array-generation-1","page":"Random Numbers","title":"Specializing array generation","text":"","category":"section"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely using the decoupling technique explained before. This is for example the case for MersenneTwister, which natively writes random values in an array.","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"To implement this specialization for MyRNG and for a specification s, producing elements of type S, the following method can be defined: rand!(rng::MyRNG, a::AbstractArray{S}, ::SamplerS), where SamplerS is the type of the sampler returned by Sampler(MyRNG, s, Val(Inf)).  Instead of AbstractArray, it's possible to implement the functionality only for a subtype, e.g. Array{S}.  The non-mutating array method of rand will automatically call this specialization internally.","category":"page"},{"location":"stdlib/Random.html#","page":"Random Numbers","title":"Random Numbers","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/SHA.html#SHA-1","page":"SHA","title":"SHA","text":"","category":"section"},{"location":"stdlib/SHA.html#","page":"SHA","title":"SHA","text":"Usage is very straightforward:","category":"page"},{"location":"stdlib/SHA.html#","page":"SHA","title":"SHA","text":"julia> using SHA\n\njulia> bytes2hex(sha256(\"test\"))\n\"9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\"","category":"page"},{"location":"stdlib/SHA.html#","page":"SHA","title":"SHA","text":"Each exported function (at the time of this writing, SHA-1, SHA-2 224, 256, 384 and 512, and SHA-3 224, 256, 384 and 512 functions are implemented) takes in either an Array{UInt8}, a ByteString or an IO object.  This makes it trivial to checksum a file:","category":"page"},{"location":"stdlib/SHA.html#","page":"SHA","title":"SHA","text":"shell> cat /tmp/test.txt\ntest\njulia> using SHA\n\njulia> open(\"/tmp/test.txt\") do f\n           sha2_256(f)\n       end\n32-element Array{UInt8,1}:\n 0x9f\n 0x86\n 0xd0\n 0x81\n 0x88\n 0x4c\n 0x7d\n 0x65\n    ⋮\n 0x5d\n 0x6c\n 0x15\n 0xb0\n 0xf0\n 0x0a\n 0x08","category":"page"},{"location":"stdlib/SHA.html#","page":"SHA","title":"SHA","text":"Note the lack of a newline at the end of /tmp/text.txt.  Julia automatically inserts a newline before the julia> prompt.","category":"page"},{"location":"stdlib/SHA.html#","page":"SHA","title":"SHA","text":"Due to the colloquial usage of sha256 to refer to sha2_256, convenience functions are provided, mapping shaxxx() function calls to sha2_xxx(). For SHA-3, no such colloquialisms exist and the user must use the full sha3_xxx() names.","category":"page"},{"location":"stdlib/SHA.html#","page":"SHA","title":"SHA","text":"shaxxx() takes AbstractString and array-like objects (NTuple and Array) with elements of type UInt8.","category":"page"},{"location":"stdlib/SHA.html#","page":"SHA","title":"SHA","text":"Note that, at the time of this writing, the SHA3 code is not optimized, and as such is roughly an order of magnitude slower than SHA2.","category":"page"},{"location":"stdlib/Serialization.html#Serialization-1","page":"Serialization","title":"Serialization","text":"","category":"section"},{"location":"stdlib/Serialization.html#","page":"Serialization","title":"Serialization","text":"Serialization.serialize\nSerialization.deserialize\nSerialization.writeheader","category":"page"},{"location":"stdlib/Serialization.html#Serialization.serialize","page":"Serialization","title":"Serialization.serialize","text":"serialize(stream::IO, value)\n\nWrite an arbitrary value to a stream in an opaque format, such that it can be read back by deserialize. The read-back value will be as identical as possible to the original. In general, this process will not work if the reading and writing are done by different versions of Julia, or an instance of Julia with a different system image. Ptr values are serialized as all-zero bit patterns (NULL).\n\nAn 8-byte identifying header is written to the stream first. To avoid writing the header, construct a Serializer and use it as the first argument to serialize instead. See also Serialization.writeheader.\n\n\n\n\n\nserialize(filename::AbstractString, value)\n\nOpen a file and serialize the given value to it.\n\ncompat: Julia 1.1\nThis method is available as of Julia 1.1.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Serialization.html#Serialization.deserialize","page":"Serialization","title":"Serialization.deserialize","text":"deserialize(stream)\n\nRead a value written by serialize. deserialize assumes the binary data read from stream is correct and has been serialized by a compatible implementation of serialize. It has been designed with simplicity and performance as a goal and does not validate the data read. Malformed data can result in process termination. The caller has to ensure the integrity and correctness of data read from stream.\n\n\n\n\n\ndeserialize(filename::AbstractString)\n\nOpen a file and deserialize its contents.\n\ncompat: Julia 1.1\nThis method is available as of Julia 1.1.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Serialization.html#Serialization.writeheader","page":"Serialization","title":"Serialization.writeheader","text":"Serialization.writeheader(s::AbstractSerializer)\n\nWrite an identifying header to the specified serializer. The header consists of 8 bytes as follows:\n\nOffset Description\n0 tag byte (0x37)\n1-2 signature bytes \"JL\"\n3 protocol version\n4 bits 0-1: endianness: 0 = little, 1 = big\n4 bits 2-3: platform: 0 = 32-bit, 1 = 64-bit\n5-7 reserved\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SharedArrays.html#Shared-Arrays-1","page":"Shared Arrays","title":"Shared Arrays","text":"","category":"section"},{"location":"stdlib/SharedArrays.html#","page":"Shared Arrays","title":"Shared Arrays","text":"SharedArrays.SharedArray\nSharedArrays.SharedVector\nSharedArrays.SharedMatrix\nSharedArrays.procs(::SharedArray)\nSharedArrays.sdata\nSharedArrays.indexpids\nSharedArrays.localindices","category":"page"},{"location":"stdlib/SharedArrays.html#SharedArrays.SharedArray","page":"Shared Arrays","title":"SharedArrays.SharedArray","text":"SharedArray{T}(dims::NTuple; init=false, pids=Int[])\nSharedArray{T,N}(...)\n\nConstruct a SharedArray of a bits type T and size dims across the processes specified by pids - all of which have to be on the same host.  If N is specified by calling SharedArray{T,N}(dims), then N must match the length of dims.\n\nIf pids is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, localindices and indexpids will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.\n\nIf an init function of the type initfn(S::SharedArray) is specified, it is called on all the participating workers.\n\nThe shared array is valid as long as a reference to the SharedArray object exists on the node which created the mapping.\n\nSharedArray{T}(filename::AbstractString, dims::NTuple, [offset=0]; mode=nothing, init=false, pids=Int[])\nSharedArray{T,N}(...)\n\nConstruct a SharedArray backed by the file filename, with element type T (must be a bits type) and size dims, across the processes specified by pids - all of which have to be on the same host. This file is mmapped into the host memory, with the following consequences:\n\nThe array data must be represented in binary format (e.g., an ASCII format like CSV cannot be supported)\nAny changes you make to the array values (e.g., A[3] = 0) will also change the values on disk\n\nIf pids is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, localindices and indexpids will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.\n\nmode must be one of \"r\", \"r+\", \"w+\", or \"a+\", and defaults to \"r+\" if the file specified by filename already exists, or \"w+\" if not. If an init function of the type initfn(S::SharedArray) is specified, it is called on all the participating workers. You cannot specify an init function if the file is not writable.\n\noffset allows you to skip the specified number of bytes at the beginning of the file.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/SharedArrays.html#SharedArrays.SharedVector","page":"Shared Arrays","title":"SharedArrays.SharedVector","text":"SharedVector\n\nA one-dimensional SharedArray.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/SharedArrays.html#SharedArrays.SharedMatrix","page":"Shared Arrays","title":"SharedArrays.SharedMatrix","text":"SharedMatrix\n\nA two-dimensional SharedArray.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/SharedArrays.html#Distributed.procs-Tuple{SharedArray}","page":"Shared Arrays","title":"Distributed.procs","text":"procs(S::SharedArray)\n\nGet the vector of processes mapping the shared array.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/SharedArrays.html#SharedArrays.sdata","page":"Shared Arrays","title":"SharedArrays.sdata","text":"sdata(S::SharedArray)\n\nReturns the actual Array object backing S.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SharedArrays.html#SharedArrays.indexpids","page":"Shared Arrays","title":"SharedArrays.indexpids","text":"indexpids(S::SharedArray)\n\nReturns the current worker's index in the list of workers mapping the SharedArray (i.e. in the same list returned by procs(S)), or 0 if the SharedArray is not mapped locally.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SharedArrays.html#SharedArrays.localindices","page":"Shared Arrays","title":"SharedArrays.localindices","text":"localindices(S::SharedArray)\n\nReturns a range describing the \"default\" indices to be handled by the current process.  This range should be interpreted in the sense of linear indexing, i.e., as a sub-range of 1:length(S).  In multi-process contexts, returns an empty range in the parent process (or any process for which indexpids returns 0).\n\nIt's worth emphasizing that localindices exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a SharedArray, all indices should be equally fast for each worker process.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets-1","page":"Sockets","title":"Sockets","text":"","category":"section"},{"location":"stdlib/Sockets.html#","page":"Sockets","title":"Sockets","text":"DocTestSetup = :(using Sockets)","category":"page"},{"location":"stdlib/Sockets.html#","page":"Sockets","title":"Sockets","text":"Sockets.Sockets\nSockets.connect(::TCPSocket, ::Integer)\nSockets.connect(::AbstractString)\nSockets.listen(::Any)\nSockets.listen(::AbstractString)\nSockets.getaddrinfo\nSockets.getipaddr\nSockets.getipaddrs\nSockets.getalladdrinfo\nSockets.getnameinfo\nSockets.getsockname\nSockets.getpeername\nSockets.IPAddr\nSockets.IPv4\nSockets.IPv6\nSockets.@ip_str\nSockets.TCPSocket\nSockets.UDPSocket\nSockets.accept\nSockets.listenany\nSockets.bind\nSockets.send\nSockets.recv\nSockets.recvfrom\nSockets.setopt","category":"page"},{"location":"stdlib/Sockets.html#Sockets.Sockets","page":"Sockets","title":"Sockets.Sockets","text":"Support for sockets. Provides IPAddr and subtypes, TCPSocket, and UDPSocket.\n\n\n\n\n\n","category":"module"},{"location":"stdlib/Sockets.html#Sockets.connect-Tuple{TCPSocket,Integer}","page":"Sockets","title":"Sockets.connect","text":"connect([host], port::Integer) -> TCPSocket\n\nConnect to the host host on port port.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Sockets.html#Sockets.connect-Tuple{AbstractString}","page":"Sockets","title":"Sockets.connect","text":"connect(path::AbstractString) -> PipeEndpoint\n\nConnect to the named pipe / UNIX domain socket at path.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Sockets.html#Sockets.listen-Tuple{Any}","page":"Sockets","title":"Sockets.listen","text":"listen([addr, ]port::Integer; backlog::Integer=BACKLOG_DEFAULT) -> TCPServer\n\nListen on port on the address specified by addr. By default this listens on localhost only. To listen on all interfaces pass IPv4(0) or IPv6(0) as appropriate. backlog determines how many connections can be pending (not having called accept) before the server will begin to reject them. The default value of backlog is 511.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Sockets.html#Sockets.listen-Tuple{AbstractString}","page":"Sockets","title":"Sockets.listen","text":"listen(path::AbstractString) -> PipeServer\n\nCreate and listen on a named pipe / UNIX domain socket.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/Sockets.html#Sockets.getaddrinfo","page":"Sockets","title":"Sockets.getaddrinfo","text":"getalladdrinfo(host::AbstractString, IPAddr=IPv4) -> IPAddr\n\nGets the first IP address of the host of the specified IPAddr type. Uses the operating system's underlying getaddrinfo implementation, which may do a DNS lookup.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets.getipaddr","page":"Sockets","title":"Sockets.getipaddr","text":"getipaddr() -> IPAddr\n\nGet an IP address of the local machine, preferring IPv4 over IPv6. Throws if no addresses are available.\n\ngetipaddr(addr_type::Type{T}) where T<:IPAddr -> T\n\nGet an IP address of the local machine of the specified type. Throws if no addresses of the specified type are available.\n\nExamples\n\njulia> getipaddr()\nip\"192.168.1.28\"\n\njulia> getipaddr(IPv6)\nip\"fe80::9731:35af:e1c5:6e49\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets.getipaddrs","page":"Sockets","title":"Sockets.getipaddrs","text":"getipaddrs(; loopback::Bool=false) -> Vector{IPAddr}\n\nGet the IPv4 addresses of the local machine.\n\ngetipaddrs(addr_type::Type{T}; loopback::Bool=false) where T<:IPAddr -> Vector{T}\n\nGet the IP addresses of the local machine of the specified type.\n\nThe loopback keyword argument dictates whether loopback addresses are included.\n\ncompat: Julia 1.2\nThis function is available as of Julia 1.2.\n\nExamples\n\njulia> getipaddrs()\n2-element Array{IPv4,1}:\n ip\"10.255.0.183\"\n ip\"172.17.0.1\"\n\njulia> getipaddrs(IPv6)\n2-element Array{IPv6,1}:\n ip\"fe80::9731:35af:e1c5:6e49\"\n ip\"fe80::445e:5fff:fe5d:5500\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets.getalladdrinfo","page":"Sockets","title":"Sockets.getalladdrinfo","text":"getalladdrinfo(host::AbstractString) -> Vector{IPAddr}\n\nGets all of the IP addresses of the host. Uses the operating system's underlying getaddrinfo implementation, which may do a DNS lookup.\n\nExample\n\njulia> getalladdrinfo(\"google.com\")\n2-element Array{IPAddr,1}:\n ip\"172.217.6.174\"\n ip\"2607:f8b0:4000:804::200e\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets.getnameinfo","page":"Sockets","title":"Sockets.getnameinfo","text":"getnameinfo(host::IPAddr) -> String\n\nPerforms a reverse-lookup for IP address to return a hostname and service using the operating system's underlying getnameinfo implementation.\n\nExamples\n\njulia> getnameinfo(Sockets.IPv4(\"8.8.8.8\"))\n\"google-public-dns-a.google.com\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets.getsockname","page":"Sockets","title":"Sockets.getsockname","text":"getsockname(sock::Union{TCPServer, TCPSocket}) -> (IPAddr, UInt16)\n\nGet the IP address and port that the given socket is bound to.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets.getpeername","page":"Sockets","title":"Sockets.getpeername","text":"getpeername(sock::TCPSocket) -> (IPAddr, UInt16)\n\nGet the IP address and port of the remote endpoint that the given socket is connected to. Valid only for connected TCP sockets.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets.IPAddr","page":"Sockets","title":"Sockets.IPAddr","text":"IPAddr\n\nAbstract supertype for IP addresses. IPv4 and IPv6 are subtypes of this.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Sockets.html#Sockets.IPv4","page":"Sockets","title":"Sockets.IPv4","text":"IPv4(host::Integer) -> IPv4\n\nReturns an IPv4 object from ip address host formatted as an Integer.\n\nExamples\n\njulia> IPv4(3223256218)\nip\"192.30.252.154\"\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Sockets.html#Sockets.IPv6","page":"Sockets","title":"Sockets.IPv6","text":"IPv6(host::Integer) -> IPv6\n\nReturns an IPv6 object from ip address host formatted as an Integer.\n\nExamples\n\njulia> IPv6(3223256218)\nip\"::c01e:fc9a\"\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Sockets.html#Sockets.@ip_str","page":"Sockets","title":"Sockets.@ip_str","text":"@ip_str str -> IPAddr\n\nParse str as an IP address.\n\nExamples\n\njulia> ip\"127.0.0.1\"\nip\"127.0.0.1\"\n\njulia> @ip_str \"2001:db8:0:0:0:0:2:1\"\nip\"2001:db8::2:1\"\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Sockets.html#Sockets.TCPSocket","page":"Sockets","title":"Sockets.TCPSocket","text":"TCPSocket(; delay=true)\n\nOpen a TCP socket using libuv. If delay is true, libuv delays creation of the socket's file descriptor till the first bind call. TCPSocket has various fields to denote the state of the socket as well as its send/receive buffers.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Sockets.html#Sockets.UDPSocket","page":"Sockets","title":"Sockets.UDPSocket","text":"UDPSocket()\n\nOpen a UDP socket using libuv. UDPSocket has various fields to denote the state of the socket.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/Sockets.html#Sockets.accept","page":"Sockets","title":"Sockets.accept","text":"accept(server[,client])\n\nAccepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets.listenany","page":"Sockets","title":"Sockets.listenany","text":"listenany([host::IPAddr,] port_hint) -> (UInt16, TCPServer)\n\nCreate a TCPServer on any port, using hint as a starting point. Returns a tuple of the actual port that the server was created on and the server itself.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Base.bind","page":"Sockets","title":"Base.bind","text":"bind(socket::Union{UDPSocket, TCPSocket}, host::IPAddr, port::Integer; ipv6only=false, reuseaddr=false, kws...)\n\nBind socket to the given host:port. Note that 0.0.0.0 will listen on all devices.\n\nThe ipv6only parameter disables dual stack mode. If ipv6only=true, only an IPv6 stack is created.\nIf reuseaddr=true, multiple threads or processes can bind to the same address without error if they all set reuseaddr=true, but only the last to bind will receive any traffic.\n\n\n\n\n\nbind(chnl::Channel, task::Task)\n\nAssociate the lifetime of chnl with a task. Channel chnl is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on chnl.\n\nThe chnl object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed Channel objects.\n\nWhen a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.\n\nExamples\n\njulia> c = Channel(0);\n\njulia> task = @async foreach(i->put!(c, i), 1:4);\n\njulia> bind(c,task);\n\njulia> for i in c\n           @show i\n       end;\ni = 1\ni = 2\ni = 3\ni = 4\n\njulia> isopen(c)\nfalse\n\njulia> c = Channel(0);\n\njulia> task = @async (put!(c,1);error(\"foo\"));\n\njulia> bind(c,task);\n\njulia> take!(c)\n1\n\njulia> put!(c,1);\nERROR: foo\nStacktrace:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets.send","page":"Sockets","title":"Sockets.send","text":"send(socket::UDPSocket, host, port::Integer, msg)\n\nSend msg over socket to host:port.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets.recv","page":"Sockets","title":"Sockets.recv","text":"recv(socket::UDPSocket)\n\nRead a UDP packet from the specified socket, and return the bytes received. This call blocks.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets.recvfrom","page":"Sockets","title":"Sockets.recvfrom","text":"recvfrom(socket::UDPSocket) -> (address, data)\n\nRead a UDP packet from the specified socket, returning a tuple of (address, data), where address will be either IPv4 or IPv6 as appropriate.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#Sockets.setopt","page":"Sockets","title":"Sockets.setopt","text":"setopt(sock::UDPSocket; multicast_loop = nothing, multicast_ttl=nothing, enable_broadcast=nothing, ttl=nothing)\n\nSet UDP socket options.\n\nmulticast_loop: loopback for multicast packets (default: true).\nmulticast_ttl: TTL for multicast packets (default: nothing).\nenable_broadcast: flag must be set to true if socket will be used for broadcast messages, or else the UDP system will return an access error (default: false).\nttl: Time-to-live of packets sent on the socket (default: nothing).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Sockets.html#","page":"Sockets","title":"Sockets","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/SparseArrays.html#Sparse-Arrays-1","page":"Sparse Arrays","title":"Sparse Arrays","text":"","category":"section"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"DocTestSetup = :(using SparseArrays, LinearAlgebra)","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"Julia has support for sparse vectors and sparse matrices  in the SparseArrays stdlib module. Sparse arrays are arrays that contain enough zeros that storing them in a special data structure leads to savings in space and execution time, compared to dense arrays.","category":"page"},{"location":"stdlib/SparseArrays.html#man-csc-1","page":"Sparse Arrays","title":"Compressed Sparse Column (CSC) Sparse Matrix Storage","text":"","category":"section"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"In Julia, sparse matrices are stored in the Compressed Sparse Column (CSC) format. Julia sparse matrices have the type SparseMatrixCSC{Tv,Ti}, where Tv is the type of the stored values, and Ti is the integer type for storing column pointers and row indices. The internal representation of SparseMatrixCSC is as follows:","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"struct SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}\n    m::Int                  # Number of rows\n    n::Int                  # Number of columns\n    colptr::Vector{Ti}      # Column i is in colptr[i]:(colptr[i+1]-1)\n    rowval::Vector{Ti}      # Row indices of stored values\n    nzval::Vector{Tv}       # Stored values, typically nonzeros\nend","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"The compressed sparse column storage makes it easy and quick to access the elements in the column of a sparse matrix, whereas accessing the sparse matrix by rows is considerably slower. Operations such as insertion of previously unstored entries one at a time in the CSC structure tend to be slow. This is because all elements of the sparse matrix that are beyond the point of insertion have to be moved one place over.","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your SparseMatrixCSC object contains unsorted row indices, one quick way to sort them is by doing a double transpose.","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"In some applications, it is convenient to store explicit zero values in a SparseMatrixCSC. These are accepted by functions in Base (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The nnz function returns the number of elements explicitly stored in the sparse data structure, including structural nonzeros. In order to count the exact number of numerical nonzeros, use count(!iszero, x), which inspects every stored element of a sparse matrix. dropzeros, and the in-place dropzeros!, can be used to remove stored zeros from the sparse matrix.","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"julia> A = sparse([1, 2, 3], [1, 2, 3], [0, 2, 0])\n3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\n  [1, 1]  =  0\n  [2, 2]  =  2\n  [3, 3]  =  0\n\njulia> dropzeros(A)\n3×3 SparseMatrixCSC{Int64,Int64} with 1 stored entry:\n  [2, 2]  =  2","category":"page"},{"location":"stdlib/SparseArrays.html#Sparse-Vector-Storage-1","page":"Sparse Arrays","title":"Sparse Vector Storage","text":"","category":"section"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"Sparse vectors are stored in a close analog to compressed sparse column format for sparse matrices. In Julia, sparse vectors have the type SparseVector{Tv,Ti} where Tv is the type of the stored values and Ti the integer type for the indices. The internal representation is as follows:","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"struct SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}\n    n::Int              # Length of the sparse vector\n    nzind::Vector{Ti}   # Indices of stored values\n    nzval::Vector{Tv}   # Stored values, typically nonzeros\nend","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"As for SparseMatrixCSC, the SparseVector type can also contain explicitly stored zeros. (See Sparse Matrix Storage.).","category":"page"},{"location":"stdlib/SparseArrays.html#Sparse-Vector-and-Matrix-Constructors-1","page":"Sparse Arrays","title":"Sparse Vector and Matrix Constructors","text":"","category":"section"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"The simplest way to create a sparse array is to use a function equivalent to the zeros  function that Julia provides for working with dense arrays. To produce a sparse array instead, you can use the same name with an sp prefix:","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"julia> spzeros(3)\n3-element SparseVector{Float64,Int64} with 0 stored entries","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"The sparse function is often a handy way to construct sparse arrays. For example, to construct a sparse matrix we can input a vector I of row indices, a vector J of column indices, and a vector V of stored values (this is also known as the COO (coordinate) format). sparse(I,J,V) then constructs a sparse matrix such that S[I[k], J[k]] = V[k]. The equivalent sparse vector constructor is sparsevec, which takes the (row) index vector I and the vector V with the stored values and constructs a sparse vector R such that R[I[k]] = V[k].","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"julia> I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];\n\njulia> S = sparse(I,J,V)\n5×18 SparseMatrixCSC{Int64,Int64} with 4 stored entries:\n  [1,  4]  =  1\n  [4,  7]  =  2\n  [5,  9]  =  3\n  [3, 18]  =  -5\n\njulia> R = sparsevec(I,V)\n5-element SparseVector{Int64,Int64} with 4 stored entries:\n  [1]  =  1\n  [3]  =  -5\n  [4]  =  2\n  [5]  =  3","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"The inverse of the sparse and sparsevec functions is findnz, which retrieves the inputs used to create the sparse array.  findall(!iszero, x) returns the cartesian indices of non-zero entries in x (including stored entries equal to zero).","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"julia> findnz(S)\n([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])\n\njulia> findall(!iszero, S)\n4-element Array{CartesianIndex{2},1}:\n CartesianIndex(1, 4)\n CartesianIndex(4, 7)\n CartesianIndex(5, 9)\n CartesianIndex(3, 18)\n\njulia> findnz(R)\n([1, 3, 4, 5], [1, -5, 2, 3])\n\njulia> findall(!iszero, R)\n4-element Array{Int64,1}:\n 1\n 3\n 4\n 5","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"Another way to create a sparse array is to convert a dense array into a sparse array using the sparse function:","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"julia> sparse(Matrix(1.0I, 5, 5))\n5×5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  1.0\n  [3, 3]  =  1.0\n  [4, 4]  =  1.0\n  [5, 5]  =  1.0\n\njulia> sparse([1.0, 0.0, 1.0])\n3-element SparseVector{Float64,Int64} with 2 stored entries:\n  [1]  =  1.0\n  [3]  =  1.0","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"You can go in the other direction using the Array constructor. The issparse  function can be used to query if a matrix is sparse.","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"julia> issparse(spzeros(5))\ntrue","category":"page"},{"location":"stdlib/SparseArrays.html#Sparse-matrix-operations-1","page":"Sparse Arrays","title":"Sparse matrix operations","text":"","category":"section"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices.  Indexing operations, especially assignment, are expensive, when carried out one element at a time.  In many cases it may be better to convert the sparse matrix into (I,J,V) format using findnz, manipulate the values or the structure in the dense vectors (I,J,V), and then reconstruct the sparse matrix.","category":"page"},{"location":"stdlib/SparseArrays.html#Correspondence-of-dense-and-sparse-methods-1","page":"Sparse Arrays","title":"Correspondence of dense and sparse methods","text":"","category":"section"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrix S, or that the resulting sparse matrix has density d, i.e. each matrix element has a probability d of being non-zero.","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"Details can be found in the Sparse Vectors and Matrices  section of the standard library reference.","category":"page"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"Sparse Dense Description\nspzeros(m,n) zeros(m,n) Creates a m-by-n matrix of zeros. (spzeros(m,n) is empty.)\nsparse(I, n, n) Matrix(I,n,n) Creates a n-by-n identity matrix.\nArray(S) sparse(A) Interconverts between dense and sparse formats.\nsprand(m,n,d) rand(m,n) Creates a m-by-n random matrix (of density d) with iid non-zero elements distributed uniformly on the half-open interval 0 1).\nsprandn(m,n,d) randn(m,n) Creates a m-by-n random matrix (of density d) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.\nsprandn(m,n,d,X) randn(m,n,X) Creates a m-by-n random matrix (of density d) with iid non-zero elements distributed according to the X distribution. (Requires the Distributions package.)","category":"page"},{"location":"stdlib/SparseArrays.html#stdlib-sparse-arrays-1","page":"Sparse Arrays","title":"Sparse Arrays","text":"","category":"section"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"SparseArrays.AbstractSparseArray\nSparseArrays.AbstractSparseVector\nSparseArrays.AbstractSparseMatrix\nSparseArrays.SparseVector\nSparseArrays.SparseMatrixCSC\nSparseArrays.sparse\nSparseArrays.sparsevec\nSparseArrays.issparse\nSparseArrays.nnz\nSparseArrays.findnz\nSparseArrays.spzeros\nSparseArrays.spdiagm\nSparseArrays.blockdiag\nSparseArrays.sprand\nSparseArrays.sprandn\nSparseArrays.nonzeros\nSparseArrays.rowvals\nSparseArrays.nzrange\nSparseArrays.droptol!\nSparseArrays.dropzeros!\nSparseArrays.dropzeros\nSparseArrays.permute\npermute!{Tv, Ti, Tp <: Integer, Tq <: Integer}(::SparseMatrixCSC{Tv,Ti}, ::SparseMatrixCSC{Tv,Ti}, ::AbstractArray{Tp,1}, ::AbstractArray{Tq,1})","category":"page"},{"location":"stdlib/SparseArrays.html#SparseArrays.AbstractSparseArray","page":"Sparse Arrays","title":"SparseArrays.AbstractSparseArray","text":"AbstractSparseArray{Tv,Ti,N}\n\nSupertype for N-dimensional sparse arrays (or array-like types) with elements of type Tv and index type Ti. SparseMatrixCSC, SparseVector and SuiteSparse.CHOLMOD.Sparse are subtypes of this.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/SparseArrays.html#SparseArrays.AbstractSparseVector","page":"Sparse Arrays","title":"SparseArrays.AbstractSparseVector","text":"AbstractSparseVector{Tv,Ti}\n\nSupertype for one-dimensional sparse arrays (or array-like types) with elements of type Tv and index type Ti. Alias for AbstractSparseArray{Tv,Ti,1}`.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/SparseArrays.html#SparseArrays.AbstractSparseMatrix","page":"Sparse Arrays","title":"SparseArrays.AbstractSparseMatrix","text":"AbstractSparseMatrix{Tv,Ti}\n\nSupertype for two-dimensional sparse arrays (or array-like types) with elements of type Tv and index type Ti. Alias for AbstractSparseArray{Tv,Ti,2}.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/SparseArrays.html#SparseArrays.SparseVector","page":"Sparse Arrays","title":"SparseArrays.SparseVector","text":"SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}\n\nVector type for storing sparse vectors.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/SparseArrays.html#SparseArrays.SparseMatrixCSC","page":"Sparse Arrays","title":"SparseArrays.SparseMatrixCSC","text":"SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}\n\nMatrix type for storing sparse matrices in the Compressed Sparse Column format. The standard way of constructing SparseMatrixCSC is through the sparse function. See also spzeros, spdiagm and sprand.\n\n\n\n\n\n","category":"type"},{"location":"stdlib/SparseArrays.html#SparseArrays.sparse","page":"Sparse Arrays","title":"SparseArrays.sparse","text":"sparse(A)\n\nConvert an AbstractMatrix A into a sparse matrix.\n\nExamples\n\njulia> A = Matrix(1.0I, 3, 3)\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> sparse(A)\n3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  1.0\n  [3, 3]  =  1.0\n\n\n\n\n\nsparse(I, J, V,[ m, n, combine])\n\nCreate a sparse matrix S of dimensions m x n such that S[I[k], J[k]] = V[k]. The combine function is used to combine duplicates. If m and n are not specified, they are set to maximum(I) and maximum(J) respectively. If the combine function is not supplied, combine defaults to + unless the elements of V are Booleans in which case combine defaults to |. All elements of I must satisfy 1 <= I[k] <= m, and all elements of J must satisfy 1 <= J[k] <= n. Numerical zeros in (I, J, V) are retained as structural nonzeros; to drop numerical zeros, use dropzeros!.\n\nFor additional documentation and an expert driver, see SparseArrays.sparse!.\n\nExamples\n\njulia> Is = [1; 2; 3];\n\njulia> Js = [1; 2; 3];\n\njulia> Vs = [1; 2; 3];\n\njulia> sparse(Is, Js, Vs)\n3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\n  [1, 1]  =  1\n  [2, 2]  =  2\n  [3, 3]  =  3\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.sparsevec","page":"Sparse Arrays","title":"SparseArrays.sparsevec","text":"sparsevec(I, V, [m, combine])\n\nCreate a sparse vector S of length m such that S[I[k]] = V[k]. Duplicates are combined using the combine function, which defaults to + if no combine argument is provided, unless the elements of V are Booleans in which case combine defaults to |.\n\nExamples\n\njulia> II = [1, 3, 3, 5]; V = [0.1, 0.2, 0.3, 0.2];\n\njulia> sparsevec(II, V)\n5-element SparseVector{Float64,Int64} with 3 stored entries:\n  [1]  =  0.1\n  [3]  =  0.5\n  [5]  =  0.2\n\njulia> sparsevec(II, V, 8, -)\n8-element SparseVector{Float64,Int64} with 3 stored entries:\n  [1]  =  0.1\n  [3]  =  -0.1\n  [5]  =  0.2\n\njulia> sparsevec([1, 3, 1, 2, 2], [true, true, false, false, false])\n3-element SparseVector{Bool,Int64} with 3 stored entries:\n  [1]  =  1\n  [2]  =  0\n  [3]  =  1\n\n\n\n\n\nsparsevec(d::Dict, [m])\n\nCreate a sparse vector of length m where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.\n\nExamples\n\njulia> sparsevec(Dict(1 => 3, 2 => 2))\n2-element SparseVector{Int64,Int64} with 2 stored entries:\n  [1]  =  3\n  [2]  =  2\n\n\n\n\n\nsparsevec(A)\n\nConvert a vector A into a sparse vector of length m.\n\nExamples\n\njulia> sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])\n6-element SparseVector{Float64,Int64} with 3 stored entries:\n  [1]  =  1.0\n  [2]  =  2.0\n  [5]  =  3.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.issparse","page":"Sparse Arrays","title":"SparseArrays.issparse","text":"issparse(S)\n\nReturns true if S is sparse, and false otherwise.\n\nExamples\n\njulia> sv = sparsevec([1, 4], [2.3, 2.2], 10)\n10-element SparseVector{Float64,Int64} with 2 stored entries:\n  [1 ]  =  2.3\n  [4 ]  =  2.2\n\njulia> issparse(sv)\ntrue\n\njulia> issparse(Array(sv))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.nnz","page":"Sparse Arrays","title":"SparseArrays.nnz","text":"nnz(A)\n\nReturns the number of stored (filled) elements in a sparse array.\n\nExamples\n\njulia> A = sparse(2I, 3, 3)\n3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\n  [1, 1]  =  2\n  [2, 2]  =  2\n  [3, 3]  =  2\n\njulia> nnz(A)\n3\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.findnz","page":"Sparse Arrays","title":"SparseArrays.findnz","text":"findnz(A)\n\nReturn a tuple (I, J, V) where I and J are the row and column indices of the stored (\"structurally non-zero\") values in sparse matrix A, and V is a vector of the values.\n\nExamples\n\njulia> A = sparse([1 2 0; 0 0 3; 0 4 0])\n3×3 SparseMatrixCSC{Int64,Int64} with 4 stored entries:\n  [1, 1]  =  1\n  [1, 2]  =  2\n  [3, 2]  =  4\n  [2, 3]  =  3\n\njulia> findnz(A)\n([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.spzeros","page":"Sparse Arrays","title":"SparseArrays.spzeros","text":"spzeros([type,]m[,n])\n\nCreate a sparse vector of length m or sparse matrix of size m x n. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to Float64 if not specified.\n\nExamples\n\njulia> spzeros(3, 3)\n3×3 SparseMatrixCSC{Float64,Int64} with 0 stored entries\n\njulia> spzeros(Float32, 4)\n4-element SparseVector{Float32,Int64} with 0 stored entries\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.spdiagm","page":"Sparse Arrays","title":"SparseArrays.spdiagm","text":"spdiagm(kv::Pair{<:Integer,<:AbstractVector}...)\n\nConstruct a square sparse diagonal matrix from Pairs of vectors and diagonals. Vector kv.second will be placed on the kv.first diagonal.\n\nExamples\n\njulia> spdiagm(-1 => [1,2,3,4], 1 => [4,3,2,1])\n5×5 SparseMatrixCSC{Int64,Int64} with 8 stored entries:\n  [2, 1]  =  1\n  [1, 2]  =  4\n  [3, 2]  =  2\n  [2, 3]  =  3\n  [4, 3]  =  3\n  [3, 4]  =  2\n  [5, 4]  =  4\n  [4, 5]  =  1\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.blockdiag","page":"Sparse Arrays","title":"SparseArrays.blockdiag","text":"blockdiag(A...)\n\nConcatenate matrices block-diagonally. Currently only implemented for sparse matrices.\n\nExamples\n\njulia> blockdiag(sparse(2I, 3, 3), sparse(4I, 2, 2))\n5×5 SparseMatrixCSC{Int64,Int64} with 5 stored entries:\n  [1, 1]  =  2\n  [2, 2]  =  2\n  [3, 3]  =  2\n  [4, 4]  =  4\n  [5, 5]  =  4\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.sprand","page":"Sparse Arrays","title":"SparseArrays.sprand","text":"sprand([rng],[type],m,[n],p::AbstractFloat,[rfn])\n\nCreate a random length m sparse vector or m by n sparse matrix, in which the probability of any element being nonzero is independently given by p (and hence the mean density of nonzeros is also exactly p). Nonzero values are sampled from the distribution specified by rfn and have the type type. The uniform distribution is used in case rfn is not specified. The optional rng argument specifies a random number generator, see Random Numbers.\n\nExamples\n\njulia> sprand(Bool, 2, 2, 0.5)\n2×2 SparseMatrixCSC{Bool,Int64} with 1 stored entry:\n  [2, 2]  =  1\n\njulia> sprand(Float64, 3, 0.75)\n3-element SparseVector{Float64,Int64} with 1 stored entry:\n  [3]  =  0.298614\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.sprandn","page":"Sparse Arrays","title":"SparseArrays.sprandn","text":"sprandn([rng][,Type],m[,n],p::AbstractFloat)\n\nCreate a random sparse vector of length m or sparse matrix of size m by n with the specified (independent) probability p of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional rng argument specifies a random number generator, see Random Numbers.\n\ncompat: Julia 1.1\nSpecifying the output element type Type requires at least Julia 1.1.\n\nExamples\n\njulia> sprandn(2, 2, 0.75)\n2×2 SparseMatrixCSC{Float64,Int64} with 2 stored entries:\n  [1, 2]  =  0.586617\n  [2, 2]  =  0.297336\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.nonzeros","page":"Sparse Arrays","title":"SparseArrays.nonzeros","text":"nonzeros(A)\n\nReturn a vector of the structural nonzero values in sparse array A. This includes zeros that are explicitly stored in the sparse array. The returned vector points directly to the internal nonzero storage of A, and any modifications to the returned vector will mutate A as well. See rowvals and nzrange.\n\nExamples\n\njulia> A = sparse(2I, 3, 3)\n3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\n  [1, 1]  =  2\n  [2, 2]  =  2\n  [3, 3]  =  2\n\njulia> nonzeros(A)\n3-element Array{Int64,1}:\n 2\n 2\n 2\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.rowvals","page":"Sparse Arrays","title":"SparseArrays.rowvals","text":"rowvals(A::SparseMatrixCSC)\n\nReturn a vector of the row indices of A. Any modifications to the returned vector will mutate A as well. Providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See also nonzeros and nzrange.\n\nExamples\n\njulia> A = sparse(2I, 3, 3)\n3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\n  [1, 1]  =  2\n  [2, 2]  =  2\n  [3, 3]  =  2\n\njulia> rowvals(A)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.nzrange","page":"Sparse Arrays","title":"SparseArrays.nzrange","text":"nzrange(A::SparseMatrixCSC, col::Integer)\n\nReturn the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with nonzeros and rowvals, this allows for convenient iterating over a sparse matrix :\n\nA = sparse(I,J,V)\nrows = rowvals(A)\nvals = nonzeros(A)\nm, n = size(A)\nfor i = 1:n\n   for j in nzrange(A, i)\n      row = rows[j]\n      val = vals[j]\n      # perform sparse wizardry...\n   end\nend\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.droptol!","page":"Sparse Arrays","title":"SparseArrays.droptol!","text":"droptol!(A::SparseMatrixCSC, tol; trim::Bool = true)\n\nRemoves stored values from A whose absolute value is less than or equal to tol, optionally trimming resulting excess space from A.rowval and A.nzval when trim is true.\n\n\n\n\n\ndroptol!(x::SparseVector, tol; trim::Bool = true)\n\nRemoves stored values from x whose absolute value is less than or equal to tol, optionally trimming resulting excess space from A.rowval and A.nzval when trim is true.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.dropzeros!","page":"Sparse Arrays","title":"SparseArrays.dropzeros!","text":"dropzeros!(A::SparseMatrixCSC; trim::Bool = true)\n\nRemoves stored numerical zeros from A, optionally trimming resulting excess space from A.rowval and A.nzval when trim is true.\n\nFor an out-of-place version, see dropzeros. For algorithmic information, see fkeep!.\n\n\n\n\n\ndropzeros!(x::SparseVector; trim::Bool = true)\n\nRemoves stored numerical zeros from x, optionally trimming resulting excess space from x.nzind and x.nzval when trim is true.\n\nFor an out-of-place version, see dropzeros. For algorithmic information, see fkeep!.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.dropzeros","page":"Sparse Arrays","title":"SparseArrays.dropzeros","text":"dropzeros(A::SparseMatrixCSC; trim::Bool = true)\n\nGenerates a copy of A and removes stored numerical zeros from that copy, optionally trimming excess space from the result's rowval and nzval arrays when trim is true.\n\nFor an in-place version and algorithmic information, see dropzeros!.\n\nExamples\n\njulia> A = sparse([1, 2, 3], [1, 2, 3], [1.0, 0.0, 1.0])\n3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  0.0\n  [3, 3]  =  1.0\n\njulia> dropzeros(A)\n3×3 SparseMatrixCSC{Float64,Int64} with 2 stored entries:\n  [1, 1]  =  1.0\n  [3, 3]  =  1.0\n\n\n\n\n\ndropzeros(x::SparseVector; trim::Bool = true)\n\nGenerates a copy of x and removes numerical zeros from that copy, optionally trimming excess space from the result's nzind and nzval arrays when trim is true.\n\nFor an in-place version and algorithmic information, see dropzeros!.\n\nExamples\n\njulia> A = sparsevec([1, 2, 3], [1.0, 0.0, 1.0])\n3-element SparseVector{Float64,Int64} with 3 stored entries:\n  [1]  =  1.0\n  [2]  =  0.0\n  [3]  =  1.0\n\njulia> dropzeros(A)\n3-element SparseVector{Float64,Int64} with 2 stored entries:\n  [1]  =  1.0\n  [3]  =  1.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#SparseArrays.permute","page":"Sparse Arrays","title":"SparseArrays.permute","text":"permute(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},\n        q::AbstractVector{<:Integer}) where {Tv,Ti}\n\nBilaterally permute A, returning PAQ (A[p,q]). Column-permutation q's length must match A's column count (length(q) == A.n). Row-permutation p's length must match A's row count (length(p) == A.m).\n\nFor expert drivers and additional information, see permute!.\n\nExamples\n\njulia> A = spdiagm(0 => [1, 2, 3, 4], 1 => [5, 6, 7])\n4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:\n  [1, 1]  =  1\n  [1, 2]  =  5\n  [2, 2]  =  2\n  [2, 3]  =  6\n  [3, 3]  =  3\n  [3, 4]  =  7\n  [4, 4]  =  4\n\njulia> permute(A, [4, 3, 2, 1], [1, 2, 3, 4])\n4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:\n  [4, 1]  =  1\n  [3, 2]  =  2\n  [4, 2]  =  5\n  [2, 3]  =  3\n  [3, 3]  =  6\n  [1, 4]  =  4\n  [2, 4]  =  7\n\njulia> permute(A, [1, 2, 3, 4], [4, 3, 2, 1])\n4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:\n  [3, 1]  =  7\n  [4, 1]  =  4\n  [2, 2]  =  6\n  [3, 2]  =  3\n  [1, 3]  =  5\n  [2, 3]  =  2\n  [1, 4]  =  1\n\n\n\n\n\n","category":"function"},{"location":"stdlib/SparseArrays.html#Base.permute!-Union{Tuple{Tq}, Tuple{Tp}, Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv,Ti},SparseMatrixCSC{Tv,Ti},AbstractArray{Tp,1},AbstractArray{Tq,1}}} where Tq<:Integer where Tp<:Integer where Ti where Tv","page":"Sparse Arrays","title":"Base.permute!","text":"permute!(X::SparseMatrixCSC{Tv,Ti}, A::SparseMatrixCSC{Tv,Ti},\n         p::AbstractVector{<:Integer}, q::AbstractVector{<:Integer},\n         [C::SparseMatrixCSC{Tv,Ti}]) where {Tv,Ti}\n\nBilaterally permute A, storing result PAQ (A[p,q]) in X. Stores intermediate result (AQ)^T (transpose(A[:,q])) in optional argument C if present. Requires that none of X, A, and, if present, C alias each other; to store result PAQ back into A, use the following method lacking X:\n\npermute!(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},\n         q::AbstractVector{<:Integer}[, C::SparseMatrixCSC{Tv,Ti},\n         [workcolptr::Vector{Ti}]]) where {Tv,Ti}\n\nX's dimensions must match those of A (X.m == A.m and X.n == A.n), and X must have enough storage to accommodate all allocated entries in A (length(X.rowval) >= nnz(A) and length(X.nzval) >= nnz(A)). Column-permutation q's length must match A's column count (length(q) == A.n). Row-permutation p's length must match A's row count (length(p) == A.m).\n\nC's dimensions must match those of transpose(A) (C.m == A.n and C.n == A.m), and C must have enough storage to accommodate all allocated entries in A (length(C.rowval) >= nnz(A) and length(C.nzval) >= nnz(A)).\n\nFor additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods unchecked_noalias_permute! and unchecked_aliasing_permute!.\n\nSee also: permute.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/SparseArrays.html#","page":"Sparse Arrays","title":"Sparse Arrays","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/Statistics.html#Statistics-1","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"stdlib/Statistics.html#","page":"Statistics","title":"Statistics","text":"DocTestSetup = :(using Statistics)","category":"page"},{"location":"stdlib/Statistics.html#","page":"Statistics","title":"Statistics","text":"The Statistics module contains basic statistics functionality.","category":"page"},{"location":"stdlib/Statistics.html#","page":"Statistics","title":"Statistics","text":"Statistics.std\nStatistics.stdm\nStatistics.var\nStatistics.varm\nStatistics.cor\nStatistics.cov\nStatistics.mean!\nStatistics.mean\nStatistics.median!\nStatistics.median\nStatistics.middle\nStatistics.quantile!\nStatistics.quantile","category":"page"},{"location":"stdlib/Statistics.html#Statistics.std","page":"Statistics","title":"Statistics.std","text":"std(itr; corrected::Bool=true, mean=nothing[, dims])\n\nCompute the sample standard deviation of collection itr.\n\nThe algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of itr is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false with n the number of elements in itr.\n\nA pre-computed mean may be provided.\n\nIf itr is an AbstractArray, dims can be provided to compute the standard deviation over dimensions, and means may contain means for each dimension of itr.\n\nnote: Note\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the standard deviation of non-missing values.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#Statistics.stdm","page":"Statistics","title":"Statistics.stdm","text":"stdm(itr, m; corrected::Bool=true)\n\nCompute the sample standard deviation of collection itr, with known mean(s) m.\n\nThe algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of itr is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false with n the number of elements in itr.\n\nA pre-computed mean may be provided.\n\nIf itr is an AbstractArray, dims can be provided to compute the standard deviation over dimensions, and m may contain means for each dimension of itr.\n\nnote: Note\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the standard deviation of non-missing values.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#Statistics.var","page":"Statistics","title":"Statistics.var","text":"var(itr; dims, corrected::Bool=true, mean=nothing)\n\nCompute the sample variance of collection itr.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of itr is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating sum((itr .- mean(itr)).^2) / (length(itr) - 1)). Ifcorrectedistrue, then the sum is scaled withn-1, whereas the sum is scaled withnifcorrectedisfalsewithnthe number of elements initr`.\n\nA pre-computed mean may be provided.\n\nIf itr is an AbstractArray, dims can be provided to compute the variance over dimensions, and mean may contain means for each dimension of itr.\n\nnote: Note\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the variance of non-missing values.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#Statistics.varm","page":"Statistics","title":"Statistics.varm","text":"varm(itr, m; dims, corrected::Bool=true)\n\nCompute the sample variance of collection itr, with known mean(s) m.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of itr is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating sum((itr .- mean(itr)).^2) / (length(itr) - 1). If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false with n the number of elements in itr.\n\nIf itr is an AbstractArray, dims can be provided to compute the variance over dimensions, and m may contain means for each dimension of itr.\n\nnote: Note\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the variance of non-missing values.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#Statistics.cor","page":"Statistics","title":"Statistics.cor","text":"cor(x::AbstractVector)\n\nReturn the number one.\n\n\n\n\n\ncor(X::AbstractMatrix; dims::Int=1)\n\nCompute the Pearson correlation matrix of the matrix X along the dimension dims.\n\n\n\n\n\ncor(x::AbstractVector, y::AbstractVector)\n\nCompute the Pearson correlation between the vectors x and y.\n\n\n\n\n\ncor(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims=1)\n\nCompute the Pearson correlation between the vectors or matrices X and Y along the dimension dims.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#Statistics.cov","page":"Statistics","title":"Statistics.cov","text":"cov(x::AbstractVector; corrected::Bool=true)\n\nCompute the variance of the vector x. If corrected is true (the default) then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(x).\n\n\n\n\n\ncov(X::AbstractMatrix; dims::Int=1, corrected::Bool=true)\n\nCompute the covariance matrix of the matrix X along the dimension dims. If corrected is true (the default) then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = size(X, dims).\n\n\n\n\n\ncov(x::AbstractVector, y::AbstractVector; corrected::Bool=true)\n\nCompute the covariance between the vectors x and y. If corrected is true (the default), computes frac1n-1sum_i=1^n (x_i-bar x) (y_i-bar y)^* where * denotes the complex conjugate and n = length(x) = length(y). If corrected is false, computes frac1nsum_i=1^n (x_i-bar x) (y_i-bar y)^*.\n\n\n\n\n\ncov(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims::Int=1, corrected::Bool=true)\n\nCompute the covariance between the vectors or matrices X and Y along the dimension dims. If corrected is true (the default) then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = size(X, dims) = size(Y, dims).\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#Statistics.mean!","page":"Statistics","title":"Statistics.mean!","text":"mean!(r, v)\n\nCompute the mean of v over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> v = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> mean!([1., 1.], v)\n2-element Array{Float64,1}:\n 1.5\n 3.5\n\njulia> mean!([1. 1.], v)\n1×2 Array{Float64,2}:\n 2.0  3.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#Statistics.mean","page":"Statistics","title":"Statistics.mean","text":"mean(itr)\n\nCompute the mean of all elements in a collection.\n\nnote: Note\nIf itr contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the mean of non-missing values.\n\nExamples\n\njulia> mean(1:20)\n10.5\n\njulia> mean([1, missing, 3])\nmissing\n\njulia> mean(skipmissing([1, missing, 3]))\n2.0\n\n\n\n\n\nmean(f::Function, itr)\n\nApply the function f to each element of collection itr and take the mean.\n\njulia> mean(√, [1, 2, 3])\n1.3820881233139908\n\njulia> mean([√1, √2, √3])\n1.3820881233139908\n\n\n\n\n\nmean(A::AbstractArray; dims)\n\nCompute the mean of an array over the given dimensions.\n\ncompat: Julia 1.1\nmean for empty arrays requires at least Julia 1.1.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> mean(A, dims=1)\n1×2 Array{Float64,2}:\n 2.0  3.0\n\njulia> mean(A, dims=2)\n2×1 Array{Float64,2}:\n 1.5\n 3.5\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#Statistics.median!","page":"Statistics","title":"Statistics.median!","text":"median!(v)\n\nLike median, but may overwrite the input vector.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#Statistics.median","page":"Statistics","title":"Statistics.median","text":"median(itr)\n\nCompute the median of all elements in a collection. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.\n\nnote: Note\nIf itr contains NaN or missing values, the result is also NaN or missing (missing takes precedence if itr contains both). Use the skipmissing function to omit missing entries and compute the median of non-missing values.\n\nExamples\n\njulia> median([1, 2, 3])\n2.0\n\njulia> median([1, 2, 3, 4])\n2.5\n\njulia> median([1, 2, missing, 4])\nmissing\n\njulia> median(skipmissing([1, 2, missing, 4]))\n2.0\n\n\n\n\n\nmedian(A::AbstractArray; dims)\n\nCompute the median of an array along the given dimensions.\n\nExamples\n\njulia> median([1 2; 3 4], dims=1)\n1×2 Array{Float64,2}:\n 2.0  3.0\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#Statistics.middle","page":"Statistics","title":"Statistics.middle","text":"middle(x)\n\nCompute the middle of a scalar value, which is equivalent to x itself, but of the type of middle(x, x) for consistency.\n\n\n\n\n\nmiddle(x, y)\n\nCompute the middle of two reals x and y, which is equivalent in both value and type to computing their mean ((x + y) / 2).\n\n\n\n\n\nmiddle(range)\n\nCompute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.\n\njulia> middle(1:10)\n5.5\n\n\n\n\n\nmiddle(a)\n\nCompute the middle of an array a, which consists of finding its extrema and then computing their mean.\n\njulia> a = [1,2,3.6,10.9]\n4-element Array{Float64,1}:\n  1.0\n  2.0\n  3.6\n 10.9\n\njulia> middle(a)\n5.95\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#Statistics.quantile!","page":"Statistics","title":"Statistics.quantile!","text":"quantile!([q::AbstractArray, ] v::AbstractVector, p; sorted=false)\n\nCompute the quantile(s) of a vector v at a specified probability or vector or tuple of probabilities p on the interval [0,1]. If p is a vector, an optional output array q may also be specified. (If not provided, a new output array is created.) The keyword argument sorted indicates whether v can be assumed to be sorted; if false (the default), then the elements of v will be partially sorted in-place.\n\nQuantiles are computed via linear interpolation between the points ((k-1)/(n-1), v[k]), for k = 1:n where n = length(v). This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.\n\nnote: Note\nAn ArgumentError is thrown if v contains NaN or missing values.\n\nHyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", The American Statistician, Vol. 50, No. 4, pp. 361-365\n\nExamples\n\njulia> x = [3, 2, 1];\n\njulia> quantile!(x, 0.5)\n2.0\n\njulia> x\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> y = zeros(3);\n\njulia> quantile!(y, x, [0.1, 0.5, 0.9]) === y\ntrue\n\njulia> y\n3-element Array{Float64,1}:\n 1.2\n 2.0\n 2.8\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#Statistics.quantile","page":"Statistics","title":"Statistics.quantile","text":"quantile(itr, p; sorted=false)\n\nCompute the quantile(s) of a collection itr at a specified probability or vector or tuple of probabilities p on the interval [0,1]. The keyword argument sorted indicates whether itr can be assumed to be sorted.\n\nQuantiles are computed via linear interpolation between the points ((k-1)/(n-1), v[k]), for k = 1:n where n = length(itr). This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.\n\nnote: Note\nAn ArgumentError is thrown if itr contains NaN or missing values. Use the skipmissing function to omit missing entries and compute the quantiles of non-missing values.\n\nHyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", The American Statistician, Vol. 50, No. 4, pp. 361-365\n\nExamples\n\njulia> quantile(0:20, 0.5)\n10.0\n\njulia> quantile(0:20, [0.1, 0.5, 0.9])\n3-element Array{Float64,1}:\n  2.0\n 10.0\n 18.0\n\njulia> quantile(skipmissing([1, 10, missing]), 0.5)\n5.5\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Statistics.html#","page":"Statistics","title":"Statistics","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/Test.html#Unit-Testing-1","page":"Unit Testing","title":"Unit Testing","text":"","category":"section"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"DocTestSetup = :(using Test)","category":"page"},{"location":"stdlib/Test.html#Testing-Base-Julia-1","page":"Unit Testing","title":"Testing Base Julia","text":"","category":"section"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from source, you can run this test suite with make test.  In a binary install, you can run the test suite using Base.runtests().","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Base.runtests","category":"page"},{"location":"stdlib/Test.html#Base.runtests","page":"Unit Testing","title":"Base.runtests","text":"Base.runtests(tests=[\"all\"]; ncores=ceil(Int, Sys.CPU_THREADS / 2),\n              exit_on_error=false, [seed])\n\nRun the Julia unit tests listed in tests, which can be either a string or an array of strings, using ncores processors. If exit_on_error is false, when one test fails, all remaining tests in other files will still be run; they are otherwise discarded, when exit_on_error == true. If a seed is provided via the keyword argument, it is used to seed the global RNG in the context where the tests are run; otherwise the seed is chosen randomly.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Test.html#Basic-Unit-Tests-1","page":"Unit Testing","title":"Basic Unit Tests","text":"","category":"section"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"The Test module provides simple unit testing functionality. Unit testing is a way to see if your code is correct by checking that the results are what you expect. It can be helpful to ensure your code still works after you make changes, and can be used when developing as a way of specifying the behaviors your code should have when complete.","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Simple unit testing can be performed with the @test and @test_throws macros:","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Test.@test\nTest.@test_throws","category":"page"},{"location":"stdlib/Test.html#Test.@test","page":"Unit Testing","title":"Test.@test","text":"@test ex\n@test f(args...) key=val ...\n\nTests that the expression ex evaluates to true. Returns a Pass Result if it does, a Fail Result if it is false, and an Error Result if it could not be evaluated.\n\nExamples\n\njulia> @test true\nTest Passed\n\njulia> @test [1, 2] + [2, 1] == [3, 3]\nTest Passed\n\nThe @test f(args...) key=val... form is equivalent to writing @test f(args..., key=val...) which can be useful when the expression is a call using infix syntax such as approximate comparisons:\n\njulia> @test π ≈ 3.14 atol=0.01\nTest Passed\n\nThis is equivalent to the uglier test @test ≈(π, 3.14, atol=0.01). It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (k=v).\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Test.html#Test.@test_throws","page":"Unit Testing","title":"Test.@test_throws","text":"@test_throws exception expr\n\nTests that the expression expr throws exception. The exception may specify either a type, or a value (which will be tested for equality by comparing fields). Note that @test_throws does not support a trailing keyword form.\n\nExamples\n\njulia> @test_throws BoundsError [1, 2, 3][4]\nTest Passed\n      Thrown: BoundsError\n\njulia> @test_throws DimensionMismatch [1, 2, 3] + [1, 2]\nTest Passed\n      Thrown: DimensionMismatch\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"For example, suppose we want to check our new function foo(x) works as expected:","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"julia> using Test\n\njulia> foo(x) = length(x)^2\nfoo (generic function with 1 method)","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"If the condition is true, a Pass is returned:","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"julia> @test foo(\"bar\") == 9\nTest Passed\n\njulia> @test foo(\"fizz\") >= 10\nTest Passed","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"If the condition is false, then a Fail is returned and an exception is thrown:","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"julia> @test foo(\"f\") == 20\nTest Failed at none:1\n  Expression: foo(\"f\") == 20\n   Evaluated: 1 == 20\nERROR: There was an error during testing","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"If the condition could not be evaluated because an exception was thrown, which occurs in this case because length is not defined for symbols, an Error object is returned and an exception is thrown:","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"julia> @test foo(:cat) == 1\nError During Test\n  Test threw an exception of type MethodError\n  Expression: foo(:cat) == 1\n  MethodError: no method matching length(::Symbol)\n  Closest candidates are:\n    length(::SimpleVector) at essentials.jl:256\n    length(::Base.MethodList) at reflection.jl:521\n    length(::MethodTable) at reflection.jl:597\n    ...\n  Stacktrace:\n  [...]\nERROR: There was an error during testing","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"If we expect that evaluating an expression should throw an exception, then we can use @test_throws to check that this occurs:","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"julia> @test_throws MethodError foo(:cat)\nTest Passed\n      Thrown: MethodError","category":"page"},{"location":"stdlib/Test.html#Working-with-Test-Sets-1","page":"Unit Testing","title":"Working with Test Sets","text":"","category":"section"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Typically a large number of tests are used to make sure functions work correctly over a range of inputs. In the event a test fails, the default behavior is to throw an exception immediately.  However, it is normally preferable to run the rest of the tests first to get a better picture of how many errors there are in the code being tested.","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"The @testset macro can be used to group tests into sets. All the tests in a test set will be run, and at the end of the test set a summary will be printed. If any of the tests failed, or could not be evaluated due to an error, the test set will then throw a TestSetException.","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Test.@testset","category":"page"},{"location":"stdlib/Test.html#Test.@testset","page":"Unit Testing","title":"Test.@testset","text":"@testset [CustomTestSet] [option=val  ...] [\"description\"] begin ... end\n@testset [CustomTestSet] [option=val  ...] [\"description $v\"] for v in (...) ... end\n@testset [CustomTestSet] [option=val  ...] [\"description $v, $w\"] for v in (...), w in (...) ... end\n\nStarts a new test set, or multiple test sets if a for loop is provided.\n\nIf no custom testset type is given it defaults to creating a DefaultTestSet. DefaultTestSet records all the results and, if there are any Fails or Errors, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.\n\nAny custom testset type (subtype of AbstractTestSet) can be given and it will also be used for any nested @testset invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.\n\nThe description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.\n\nBy default the @testset macro will return the testset object itself, though this behavior can be customized in other testset types. If a for loop is used then the macro collects and returns a list of the return values of the finish method, which by default will return a list of the testset objects used in each iteration.\n\nBefore the execution of the body of a @testset, there is an implicit call to Random.seed!(seed) where seed is the current seed of the global RNG. Moreover, after the execution of the body, the state of the global RNG is restored to what it was before the @testset. This is meant to ease reproducibility in case of failure, and to allow seamless re-arrangements of @testsets regardless of their side-effect on the global RNG state.\n\nExamples\n\njulia> @testset \"trigonometric identities\" begin\n           θ = 2/3*π\n           @test sin(-θ) ≈ -sin(θ)\n           @test cos(-θ) ≈ cos(θ)\n           @test sin(2θ) ≈ 2*sin(θ)*cos(θ)\n           @test cos(2θ) ≈ cos(θ)^2 - sin(θ)^2\n       end;\nTest Summary:            | Pass  Total\ntrigonometric identities |    4      4\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"We can put our tests for the foo(x) function in a test set:","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"julia> @testset \"Foo Tests\" begin\n           @test foo(\"a\")   == 1\n           @test foo(\"ab\")  == 4\n           @test foo(\"abc\") == 9\n       end;\nTest Summary: | Pass  Total\nFoo Tests     |    3      3","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Test sets can also be nested:","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"julia> @testset \"Foo Tests\" begin\n           @testset \"Animals\" begin\n               @test foo(\"cat\") == 9\n               @test foo(\"dog\") == foo(\"cat\")\n           end\n           @testset \"Arrays $i\" for i in 1:3\n               @test foo(zeros(i)) == i^2\n               @test foo(fill(1.0, i)) == i^2\n           end\n       end;\nTest Summary: | Pass  Total\nFoo Tests     |    8      8","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"julia> @testset \"Foo Tests\" begin\n           @testset \"Animals\" begin\n               @testset \"Felines\" begin\n                   @test foo(\"cat\") == 9\n               end\n               @testset \"Canines\" begin\n                   @test foo(\"dog\") == 9\n               end\n           end\n           @testset \"Arrays\" begin\n               @test foo(zeros(2)) == 4\n               @test foo(fill(1.0, 4)) == 15\n           end\n       end\n\nArrays: Test Failed\n  Expression: foo(fill(1.0, 4)) == 15\n   Evaluated: 16 == 15\n[...]\nTest Summary: | Pass  Fail  Total\nFoo Tests     |    3     1      4\n  Animals     |    2            2\n  Arrays      |    1     1      2\nERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken.","category":"page"},{"location":"stdlib/Test.html#Other-Test-Macros-1","page":"Unit Testing","title":"Other Test Macros","text":"","category":"section"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either @test a ≈ b (where ≈, typed via tab completion of \\approx, is the isapprox function) or use isapprox directly.","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"julia> @test 1 ≈ 0.999999999\nTest Passed\n\njulia> @test 1 ≈ 0.999999\nTest Failed at none:1\n  Expression: 1 ≈ 0.999999\n   Evaluated: 1 ≈ 0.999999\nERROR: There was an error during testing","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Test.@inferred\nTest.@test_logs\nTest.@test_deprecated\nTest.@test_warn\nTest.@test_nowarn","category":"page"},{"location":"stdlib/Test.html#Test.@inferred","page":"Unit Testing","title":"Test.@inferred","text":"@inferred [AllowedType] f(x)\n\nTests that the call expression f(x) returns a value of the same type inferred by the compiler. It is useful to check for type stability.\n\nf(x) can be any call expression. Returns the result of f(x) if the types match, and an Error Result if it finds different types.\n\nOptionally, AllowedType relaxes the test, by making it pass when either the type of f(x) matches the inferred type modulo AllowedType, or when the return type is a subtype of AllowedType. This is useful when testing type stability of functions returning a small union such as Union{Nothing, T} or Union{Missing, T}.\n\njulia> f(a) = a > 1 ? 1 : 1.0\nf (generic function with 1 method)\n\njulia> typeof(f(2))\nInt64\n\njulia> @code_warntype f(2)\nVariables\n  #self#::Core.Compiler.Const(f, false)\n  a::Int64\n\nBody::UNION{FLOAT64, INT64}\n1 ─ %1 = (a > 1)::Bool\n└──      goto #3 if not %1\n2 ─      return 1\n3 ─      return 1.0\n\njulia> @inferred f(2)\nERROR: return type Int64 does not match inferred return type Union{Float64, Int64}\n[...]\n\njulia> @inferred max(1, 2)\n2\n\njulia> g(a) = a < 10 ? missing : 1.0\ng (generic function with 1 method)\n\njulia> @inferred g(20)\nERROR: return type Float64 does not match inferred return type Union{Missing, Float64}\n[...]\n\njulia> @inferred Missing g(20)\n1.0\n\njulia> h(a) = a < 10 ? missing : f(a)\nh (generic function with 1 method)\n\njulia> @inferred Missing h(20)\nERROR: return type Int64 does not match inferred return type Union{Missing, Float64, Int64}\n[...]\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Test.html#Test.@test_logs","page":"Unit Testing","title":"Test.@test_logs","text":"@test_logs [log_patterns...] [keywords] expression\n\nCollect a list of log records generated by expression using collect_test_logs, check that they match the sequence log_patterns, and return the value of expression.  The keywords provide some simple filtering of log records: the min_level keyword controls the minimum log level which will be collected for the test, the match_mode keyword defines how matching will be performed (the default :all checks that all logs and patterns match pairwise; use :any to check that the pattern matches at least once somewhere in the sequence.)\n\nThe most useful log pattern is a simple tuple of the form (level,message). A different number of tuple elements may be used to match other log metadata, corresponding to the arguments to passed to AbstractLogger via the handle_message function: (level,message,module,group,id,file,line). Elements which are present will be matched pairwise with the log record fields using == by default, with the special cases that Symbols may be used for the standard log levels, and Regexs in the pattern will match string or Symbol fields using occursin.\n\nExamples\n\nConsider a function which logs a warning, and several debug messages:\n\nfunction foo(n)\n    @info \"Doing foo with n=$n\"\n    for i=1:n\n        @debug \"Iteration $i\"\n    end\n    42\nend\n\nWe can test the info message using\n\n@test_logs (:info,\"Doing foo with n=2\") foo(2)\n\nIf we also wanted to test the debug messages, these need to be enabled with the min_level keyword:\n\n@test_logs (:info,\"Doing foo with n=2\") (:debug,\"Iteration 1\") (:debug,\"Iteration 2\") min_level=Debug foo(2)\n\nThe macro may be chained with @test to also test the returned value:\n\n@test (@test_logs (:info,\"Doing foo with n=2\") foo(2)) == 42\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Test.html#Test.@test_deprecated","page":"Unit Testing","title":"Test.@test_deprecated","text":"@test_deprecated [pattern] expression\n\nWhen --depwarn=yes, test that expression emits a deprecation warning and return the value of expression.  The log message string will be matched against pattern which defaults to r\"deprecated\"i.\n\nWhen --depwarn=no, simply return the result of executing expression.  When --depwarn=error, check that an ErrorException is thrown.\n\nExamples\n\n# Deprecated in julia 0.7\n@test_deprecated num2hex(1)\n\n# The returned value can be tested by chaining with @test:\n@test (@test_deprecated num2hex(1)) == \"0000000000000001\"\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Test.html#Test.@test_warn","page":"Unit Testing","title":"Test.@test_warn","text":"@test_warn msg expr\n\nTest whether evaluating expr results in stderr output that contains the msg string or matches the msg regular expression.  If msg is a boolean function, tests whether msg(output) returns true.  If msg is a tuple or array, checks that the error output contains/matches each item in msg. Returns the result of evaluating expr.\n\nSee also @test_nowarn to check for the absence of error output.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Test.html#Test.@test_nowarn","page":"Unit Testing","title":"Test.@test_nowarn","text":"@test_nowarn expr\n\nTest whether evaluating expr results in empty stderr output (no warnings or other messages).  Returns the result of evaluating expr.\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Test.html#Broken-Tests-1","page":"Unit Testing","title":"Broken Tests","text":"","category":"section"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"If a test fails consistently it can be changed to use the @test_broken macro. This will denote the test as Broken if the test continues to fail and alerts the user via an Error if the test succeeds.","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Test.@test_broken","category":"page"},{"location":"stdlib/Test.html#Test.@test_broken","page":"Unit Testing","title":"Test.@test_broken","text":"@test_broken ex\n@test_broken f(args...) key=val ...\n\nIndicates a test that should pass but currently consistently fails. Tests that the expression ex evaluates to false or causes an exception. Returns a Broken Result if it does, or an Error Result if the expression evaluates to true.\n\nThe @test_broken f(args...) key=val... form works as for the @test macro.\n\nExamples\n\njulia> @test_broken 1 == 2\nTest Broken\n  Expression: 1 == 2\n\njulia> @test_broken 1 == 2 atol=0.1\nTest Broken\n  Expression: ==(1, 2, atol=0.1)\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"@test_skip is also available to skip a test without evaluation, but counting the skipped test in the test set reporting. The test will not run but gives a Broken Result.","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Test.@test_skip","category":"page"},{"location":"stdlib/Test.html#Test.@test_skip","page":"Unit Testing","title":"Test.@test_skip","text":"@test_skip ex\n@test_skip f(args...) key=val ...\n\nMarks a test that should not be executed but should be included in test summary reporting as Broken. This can be useful for tests that intermittently fail, or tests of not-yet-implemented functionality.\n\nThe @test_skip f(args...) key=val... form works as for the @test macro.\n\nExamples\n\njulia> @test_skip 1 == 2\nTest Broken\n  Skipped: 1 == 2\n\njulia> @test_skip 1 == 2 atol=0.1\nTest Broken\n  Skipped: ==(1, 2, atol=0.1)\n\n\n\n\n\n","category":"macro"},{"location":"stdlib/Test.html#Creating-Custom-AbstractTestSet-Types-1","page":"Unit Testing","title":"Creating Custom AbstractTestSet Types","text":"","category":"section"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Packages can create their own AbstractTestSet subtypes by implementing the record and finish methods. The subtype should have a one-argument constructor taking a description string, with any options passed in as keyword arguments.","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Test.record\nTest.finish","category":"page"},{"location":"stdlib/Test.html#Test.record","page":"Unit Testing","title":"Test.record","text":"record(ts::AbstractTestSet, res::Result)\n\nRecord a result to a testset. This function is called by the @testset infrastructure each time a contained @test macro completes, and is given the test result (which could be an Error). This will also be called with an Error if an exception is thrown inside the test block but outside of a @test context.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Test.html#Test.finish","page":"Unit Testing","title":"Test.finish","text":"finish(ts::AbstractTestSet)\n\nDo any final processing necessary for the given testset. This is called by the @testset infrastructure after a test block executes. One common use for this function is to record the testset to the parent's results list, using get_testset.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Test takes responsibility for maintaining a stack of nested testsets as they are executed, but any result accumulation is the responsibility of the AbstractTestSet subtype. You can access this stack with the get_testset and get_testset_depth methods. Note that these functions are not exported.","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Test.get_testset\nTest.get_testset_depth","category":"page"},{"location":"stdlib/Test.html#Test.get_testset","page":"Unit Testing","title":"Test.get_testset","text":"get_testset()\n\nRetrieve the active test set from the task's local storage. If no test set is active, use the fallback default test set.\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Test.html#Test.get_testset_depth","page":"Unit Testing","title":"Test.get_testset_depth","text":"get_testset_depth()\n\nReturns the number of active test sets, not including the default test set\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Test also makes sure that nested @testset invocations use the same AbstractTestSet subtype as their parent unless it is set explicitly. It does not propagate any properties of the testset. Option inheritance behavior can be implemented by packages using the stack infrastructure that Test provides.","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"Defining a basic AbstractTestSet subtype might look like:","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"import Test: record, finish\nusing Test: AbstractTestSet, Result, Pass, Fail, Error\nusing Test: get_testset_depth, get_testset\nstruct CustomTestSet <: Test.AbstractTestSet\n    description::AbstractString\n    foo::Int\n    results::Vector\n    # constructor takes a description string and options keyword arguments\n    CustomTestSet(desc; foo=1) = new(desc, foo, [])\nend\n\nrecord(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)\nrecord(ts::CustomTestSet, res::Result) = push!(ts.results, res)\nfunction finish(ts::CustomTestSet)\n    # just record if we're not the top-level parent\n    if get_testset_depth() > 0\n        record(get_testset(), ts)\n    end\n    ts\nend","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"And using that testset looks like:","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"@testset CustomTestSet foo=4 \"custom testset inner 2\" begin\n    # this testset should inherit the type, but not the argument.\n    @testset \"custom testset inner\" begin\n        @test true\n    end\nend","category":"page"},{"location":"stdlib/Test.html#","page":"Unit Testing","title":"Unit Testing","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/UUIDs.html#UUIDs-1","page":"UUIDs","title":"UUIDs","text":"","category":"section"},{"location":"stdlib/UUIDs.html#","page":"UUIDs","title":"UUIDs","text":"DocTestSetup = :(using UUIDs, Random)","category":"page"},{"location":"stdlib/UUIDs.html#","page":"UUIDs","title":"UUIDs","text":"UUIDs.uuid1\nUUIDs.uuid4\nUUIDs.uuid5\nUUIDs.uuid_version","category":"page"},{"location":"stdlib/UUIDs.html#UUIDs.uuid1","page":"UUIDs","title":"UUIDs.uuid1","text":"uuid1([rng::AbstractRNG=GLOBAL_RNG]) -> UUID\n\nGenerates a version 1 (time-based) universally unique identifier (UUID), as specified by RFC 4122. Note that the Node ID is randomly generated (does not identify the host) according to section 4.5 of the RFC.\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> uuid1(rng)\nUUID(\"cfc395e8-590f-11e8-1f13-43a2532b2fa8\")\n\n\n\n\n\n","category":"function"},{"location":"stdlib/UUIDs.html#UUIDs.uuid4","page":"UUIDs","title":"UUIDs.uuid4","text":"uuid4([rng::AbstractRNG=GLOBAL_RNG]) -> UUID\n\nGenerates a version 4 (random or pseudo-random) universally unique identifier (UUID), as specified by RFC 4122.\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> uuid4(rng)\nUUID(\"196f2941-2d58-45ba-9f13-43a2532b2fa8\")\n\n\n\n\n\n","category":"function"},{"location":"stdlib/UUIDs.html#UUIDs.uuid5","page":"UUIDs","title":"UUIDs.uuid5","text":"uuid5(ns::UUID, name::String) -> UUID\n\nGenerates a version 5 (namespace and domain-based) universally unique identifier (UUID), as specified by RFC 4122.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> u4 = uuid4(rng)\nUUID(\"196f2941-2d58-45ba-9f13-43a2532b2fa8\")\n\njulia> u5 = uuid5(u4, \"julia\")\nUUID(\"b37756f8-b0c0-54cd-a466-19b3d25683bc\")\n\n\n\n\n\n","category":"function"},{"location":"stdlib/UUIDs.html#UUIDs.uuid_version","page":"UUIDs","title":"UUIDs.uuid_version","text":"uuid_version(u::UUID) -> Int\n\nInspects the given UUID and returns its version (see RFC 4122).\n\nExamples\n\njulia> uuid_version(uuid4())\n4\n\n\n\n\n\n","category":"function"},{"location":"stdlib/UUIDs.html#","page":"UUIDs","title":"UUIDs","text":"DocTestSetup = nothing","category":"page"},{"location":"stdlib/Unicode.html#Unicode-1","page":"Unicode","title":"Unicode","text":"","category":"section"},{"location":"stdlib/Unicode.html#","page":"Unicode","title":"Unicode","text":"DocTestSetup = :(using Unicode)","category":"page"},{"location":"stdlib/Unicode.html#","page":"Unicode","title":"Unicode","text":"Unicode.isassigned\nUnicode.normalize\nUnicode.graphemes","category":"page"},{"location":"stdlib/Unicode.html#Unicode.isassigned","page":"Unicode","title":"Unicode.isassigned","text":"Unicode.isassigned(c) -> Bool\n\nReturns true if the given char or integer is an assigned Unicode code point.\n\nExamples\n\njulia> Unicode.isassigned(101)\ntrue\n\njulia> Unicode.isassigned('\\x01')\ntrue\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Unicode.html#Unicode.normalize","page":"Unicode","title":"Unicode.normalize","text":"Unicode.normalize(s::AbstractString, normalform::Symbol)\n\nNormalize the string s according to one of the four \"normal forms\" of the Unicode standard: normalform can be :NFC, :NFD, :NFKC, or :NFKD.  Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact.  Normal forms KC and KD additionally canonicalize \"compatibility equivalents\": they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.\n\nAlternatively, finer control and additional transformations may be be obtained by calling Unicode.normalize(s; keywords...), where any number of the following boolean keywords options (which all default to false except for compose) are specified:\n\ncompose=false: do not perform canonical composition\ndecompose=true: do canonical decomposition instead of canonical composition (compose=true is ignored if present)\ncompat=true: compatibility equivalents are canonicalized\ncasefold=true: perform Unicode case folding, e.g. for case-insensitive string comparison\nnewline2lf=true, newline2ls=true, or newline2ps=true: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively\nstripmark=true: strip diacritical marks (e.g. accents)\nstripignore=true: strip Unicode's \"default ignorable\" characters (e.g. the soft hyphen or the left-to-right marker)\nstripcc=true: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified\nrejectna=true: throw an error if unassigned code points are found\nstable=true: enforce Unicode Versioning Stability\n\nFor example, NFKC corresponds to the options compose=true, compat=true, stable=true.\n\nExamples\n\njulia> \"μ\" == Unicode.normalize(\"µ\", compat=true) #LHS: Unicode U+03bc, RHS: Unicode U+00b5\ntrue\n\njulia> Unicode.normalize(\"JuLiA\", casefold=true)\n\"julia\"\n\njulia> Unicode.normalize(\"JúLiA\", stripmark=true)\n\"JuLiA\"\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Unicode.html#Unicode.graphemes","page":"Unicode","title":"Unicode.graphemes","text":"graphemes(s::AbstractString) -> GraphemeIterator\n\nReturns an iterator over substrings of s that correspond to the extended graphemes in the string, as defined by Unicode UAX #29. (Roughly, these are what users would perceive as single characters, even though they may contain more than one codepoint; for example a letter combined with an accent mark is a single grapheme.)\n\n\n\n\n\n","category":"function"},{"location":"stdlib/Unicode.html#","page":"Unicode","title":"Unicode","text":"DocTestSetup = nothing","category":"page"},{"location":"devdocs/reflection.html#リフレクションとインストロスペクション-1","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"","category":"section"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"Julia は、さまざまな実行時リフレクション機能を提供します。","category":"page"},{"location":"devdocs/reflection.html#モジュールバインディング-1","page":"リフレクションとインストロスペクション","title":"モジュールバインディング","text":"","category":"section"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"The exported names for a Module are available using names(m::Module), which will return an array of Symbol elements representing the exported bindings. names(m::Module, all = true) returns symbols for all bindings in m, regardless of export status.","category":"page"},{"location":"devdocs/reflection.html#DataType-fields-1","page":"リフレクションとインストロスペクション","title":"DataType fields","text":"","category":"section"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"The names of DataType fields may be interrogated using fieldnames. For example, given the following type, fieldnames(Point) returns a tuple of Symbols representing the field names:","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"julia> struct Point\n           x::Int\n           y\n       end\n\njulia> fieldnames(Point)\n(:x, :y)","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"The type of each field in a Point object is stored in the types field of the Point variable itself:","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"julia> Point.types\nsvec(Int64, Any)","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"While x is annotated as an Int, y was unannotated in the type definition, therefore y defaults to the Any type.","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"Types are themselves represented as a structure called DataType:","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"julia> typeof(Point)\nDataType","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"Note that fieldnames(DataType) gives the names for each field of DataType itself, and one of these fields is the types field observed in the example above.","category":"page"},{"location":"devdocs/reflection.html#Subtypes-1","page":"リフレクションとインストロスペクション","title":"Subtypes","text":"","category":"section"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"The direct subtypes of any DataType may be listed using subtypes. For example, the abstract DataType AbstractFloat has four (concrete) subtypes:","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"julia> subtypes(AbstractFloat)\n4-element Array{Any,1}:\n BigFloat\n Float16\n Float32\n Float64","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"Any abstract subtype will also be included in this list, but further subtypes thereof will not; recursive application of subtypes may be used to inspect the full type tree.","category":"page"},{"location":"devdocs/reflection.html#DataType-layout-1","page":"リフレクションとインストロスペクション","title":"DataType layout","text":"","category":"section"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"The internal representation of a DataType is critically important when interfacing with C code and several functions are available to inspect these details. isbits(T::DataType) returns true if T is stored with C-compatible alignment. fieldoffset(T::DataType, i::Integer) returns the (byte) offset for field i relative to the start of the type.","category":"page"},{"location":"devdocs/reflection.html#Function-methods-1","page":"リフレクションとインストロスペクション","title":"Function methods","text":"","category":"section"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"The methods of any generic function may be listed using methods. The method dispatch table may be searched for methods accepting a given type using methodswith.","category":"page"},{"location":"devdocs/reflection.html#Expansion-and-lowering-1","page":"リフレクションとインストロスペクション","title":"Expansion and lowering","text":"","category":"section"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"メタプログラミングセクションで説明したように、macroexpand 関数は、引用符をとりさり、式展開がされた式(Expr) の形式を提供します。macroexpand を使用するには、式ブロック自体に引用符を付けます (そうでなければ、マクロが評価され、代わりに結果が渡されます)。例えば:","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"julia> macroexpand(@__MODULE__, :(@edit println(\"\")) )\n:(InteractiveUtils.edit(println, (Base.typesof)(\"\")))","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"The functions Base.Meta.show_sexpr and dump are used to display S-expr style views and depth-nested detail views for any expression.","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"Finally, the Meta.lower function gives the lowered form of any expression and is of particular interest for understanding how language constructs map to primitive operations such as assignments, branches, and calls:","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"julia> Meta.lower(@__MODULE__, :( [1+2, sin(0.5)] ))\n:($(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope'\n1 ─ %1 = 1 + 2\n│   %2 = sin(0.5)\n│   %3 = Base.vect(%1, %2)\n└──      return %3\n))))","category":"page"},{"location":"devdocs/reflection.html#Intermediate-and-compiled-representations-1","page":"リフレクションとインストロスペクション","title":"Intermediate and compiled representations","text":"","category":"section"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"Inspecting the lowered form for functions requires selection of the specific method to display, because generic functions may have many methods with different type signatures. For this purpose, method-specific code-lowering is available using code_lowered, and the type-inferred form is available using code_typed.  code_warntype adds highlighting to the output of code_typed.","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"Closer to the machine, the LLVM intermediate representation of a function may be printed using by code_llvm, and finally the compiled machine code is available using code_native (this will trigger JIT compilation/code generation for any function which has not previously been called).","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"For convenience, there are macro versions of the above functions which take standard function calls and expand argument types automatically:","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"julia> @code_llvm +(1,1)\n\ndefine i64 @\"julia_+_130862\"(i64, i64) {\ntop:\n    %2 = add i64 %1, %0\n    ret i64 %2\n}","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"For more informations see @code_lowered, @code_typed, @code_warntype, @code_llvm, and @code_native.","category":"page"},{"location":"devdocs/reflection.html#Printing-of-debug-information-1","page":"リフレクションとインストロスペクション","title":"Printing of debug information","text":"","category":"section"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"The aforementioned functions and macros take the keyword argument debuginfo that controls the level debug information printed.","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"julia> @code_typed debuginfo=:source +(1,1)\nCodeInfo(\n    @ int.jl:53 within `+'\n1 ─ %1 = Base.add_int(x, y)::Int64\n└──      return %1\n) => Int64","category":"page"},{"location":"devdocs/reflection.html#","page":"リフレクションとインストロスペクション","title":"リフレクションとインストロスペクション","text":"Possible values for debuginfo are: :none, :source, and:default.  Per default debug information is not printed, but that can be changed by setting Base.IRShow.default_debuginfo[] = :source.","category":"page"},{"location":"devdocs/init.html#Julia-ランタイムの初期化-1","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"","category":"section"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Julia のランタイムは、コマンド julia -e 'println(\"Hello World!\")'  をどの様に実行するでしょうか?","category":"page"},{"location":"devdocs/init.html#main()-1","page":"Julia ランタイムの初期化","title":"main()","text":"","category":"section"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"プログラムの実行は、 ui/repl.cのmain()関数 から開始します。","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"main() は、 libsupport_init() を呼んで、Cライブラリの ロケールを設定し、 to set the C library locale and to initialize the \"ios\" ライブラリを初期化します( ios_init_stdstreams() と Legacy ios.c library を参照)。","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Next jl_parse_opts() is called to process command line options. Note that jl_parse_opts() only deals with options that affect code generation or early initialization. Other options are handled later by process_options() in base/client.jl.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_parse_opts() stores command line options in the global jl_options struct.","category":"page"},{"location":"devdocs/init.html#julia_init()-1","page":"Julia ランタイムの初期化","title":"julia_init()","text":"","category":"section"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"julia_init() in task.c is called by main() and calls _julia_init() in init.c.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"_julia_init() begins by calling libsupport_init() again (it does nothing the second time).","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"restore_signals() is called to zero the signal handler mask.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_resolve_sysimg_location() searches configured paths for the base system image. See Building the Julia system image.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_gc_init() sets up allocation pools and lists for weak refs, preserved values and finalization.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_init_frontend() loads and initializes a pre-compiled femtolisp image containing the scanner/parser.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_init_types() creates jl_datatype_t type description objects for the built-in types defined in julia.h. e.g.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_any_type = jl_new_abstracttype(jl_symbol(\"Any\"), core, NULL, jl_emptysvec);\njl_any_type->super = jl_any_type;\n\njl_type_type = jl_new_abstracttype(jl_symbol(\"Type\"), core, jl_any_type, jl_emptysvec);\n\njl_int32_type = jl_new_primitivetype(jl_symbol(\"Int32\"), core,\n                                     jl_any_type, jl_emptysvec, 32);","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_init_tasks() creates the jl_datatype_t* jl_task_type object; initializes the global jl_root_task struct; and sets jl_current_task to the root task.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_init_codegen() initializes the LLVM library.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_init_serializer() initializes 8-bit serialization tags for builtin jl_value_t values.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"If there is no sysimg file (!jl_options.image_file) then the Core and Main modules are created and boot.jl is evaluated:","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_core_module = jl_new_module(jl_symbol(\"Core\")) creates the Julia Core module.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_init_intrinsic_functions() creates a new Julia module Intrinsics containing constant jl_intrinsic_type symbols. These define an integer code for each intrinsic function. emit_intrinsic() translates these symbols into LLVM instructions during code generation.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_init_primitives() hooks C functions up to Julia function symbols. e.g. the symbol Core.:(===)() is bound to C function pointer jl_f_is() by calling add_builtin_func(\"===\", jl_f_is).","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_new_main_module() creates the global \"Main\" module and sets jl_current_task->current_module = jl_main_module.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Note: _julia_init() then sets jl_root_task->current_module = jl_core_module. jl_root_task is an alias of jl_current_task at this point, so the current_module set by jl_new_main_module() above is overwritten.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_load(\"boot.jl\", sizeof(\"boot.jl\")) calls jl_parse_eval_all which repeatedly calls jl_toplevel_eval_flex() to execute boot.jl. <!– TODO – drill down into eval? –>","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_get_builtin_hooks() initializes global C pointers to Julia globals defined in boot.jl.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_init_box_caches() pre-allocates global boxed integer value objects for values up to 1024. This speeds up allocation of boxed ints later on. e.g.:","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_value_t *jl_box_uint8(uint32_t x)\n{\n    return boxed_uint8_cache[(uint8_t)x];\n}","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"_julia_init() iterates over the jl_core_module->bindings.table looking for jl_datatype_t values and sets the type name's module prefix to jl_core_module.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_add_standard_imports(jl_main_module) does \"using Base\" in the \"Main\" module.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Note: _julia_init() now reverts to jl_root_task->current_module = jl_main_module as it was before being set to jl_core_module above.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Platform specific signal handlers are initialized for SIGSEGV (OSX, Linux), and SIGFPE (Windows).","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Other signals (SIGINFO, SIGBUS, SIGILL, SIGTERM, SIGABRT, SIGQUIT, SIGSYS and SIGPIPE) are hooked up to sigdie_handler() which prints a backtrace.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_init_restored_modules() calls jl_module_run_initializer() for each deserialized module to run the __init__() function.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Finally sigint_handler() is hooked up to SIGINT and calls jl_throw(jl_interrupt_exception).","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"_julia_init() then returns back to main() in ui/repl.c  and main() calls true_main(argc, (char**)argv).","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"sidebar: sysimg\nIf there is a sysimg file, it contains a pre-cooked image of the Core and Main modules (and whatever else is created by boot.jl). See Building the Julia system image.jl_restore_system_image() deserializes the saved sysimg into the current Julia runtime environment and initialization continues after jl_init_box_caches() below...Note: jl_restore_system_image() (and staticdata.c in general) uses the Legacy ios.c library.","category":"page"},{"location":"devdocs/init.html#true_main()-1","page":"Julia ランタイムの初期化","title":"true_main()","text":"","category":"section"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"true_main() loads the contents of argv[] into Base.ARGS.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"If a .jl \"program\" file was supplied on the command line, then exec_program() calls jl_load(program,len) which calls jl_parse_eval_all which repeatedly calls jl_toplevel_eval_flex() to execute the program.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"However, in our example (julia -e 'println(\"Hello World!\")'), jl_get_global(jl_base_module, jl_symbol(\"_start\")) looks up Base._start and jl_apply() executes it.","category":"page"},{"location":"devdocs/init.html#Base._start-1","page":"Julia ランタイムの初期化","title":"Base._start","text":"","category":"section"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Base._start calls Base.process_options which calls jl_parse_input_line(\"println(\"Hello World!\")\")  to create an expression object and Base.eval() to execute it.","category":"page"},{"location":"devdocs/init.html#Base.eval-1","page":"Julia ランタイムの初期化","title":"Base.eval","text":"","category":"section"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Base.eval() was mapped to jl_f_top_eval by jl_init_primitives().","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_f_top_eval() calls jl_toplevel_eval_in(jl_main_module, ex), where ex is the parsed expression println(\"Hello World!\").","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_toplevel_eval_in() calls jl_toplevel_eval_flex() which calls eval() in interpreter.c.","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"The stack dump below shows how the interpreter works its way through various methods of Base.println() and Base.print() before arriving at write(s::IO, a::Array{T}) where T  which does ccall(jl_uv_write()).","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"jl_uv_write() calls uv_write() to write \"Hello World!\" to JL_STDOUT. See Libuv wrappers for stdio.:","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Hello World!","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Stack frame Source code Notes\njl_uv_write() jl_uv.c called though ccall\njulia_write_282942 stream.jl function write!(s::IO, a::Array{T}) where T\njulia_print_284639 ascii.jl print(io::IO, s::String) = (write(io, s); nothing)\njlcall_print_284639  \njl_apply() julia.h \njl_trampoline() builtins.c \njl_apply() julia.h \njl_apply_generic() gf.c Base.print(Base.TTY, String)\njl_apply() julia.h \njl_trampoline() builtins.c \njl_apply() julia.h \njl_apply_generic() gf.c Base.print(Base.TTY, String, Char, Char...)\njl_apply() julia.h \njl_f_apply() builtins.c \njl_apply() julia.h \njl_trampoline() builtins.c \njl_apply() julia.h \njl_apply_generic() gf.c Base.println(Base.TTY, String, String...)\njl_apply() julia.h \njl_trampoline() builtins.c \njl_apply() julia.h \njl_apply_generic() gf.c Base.println(String,)\njl_apply() julia.h \ndo_call() interpreter.c \neval() interpreter.c \njl_interpret_toplevel_expr() interpreter.c \njl_toplevel_eval_flex() toplevel.c \njl_toplevel_eval() toplevel.c \njl_toplevel_eval_in() builtins.c \njl_f_top_eval() builtins.c ","category":"page"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Since our example has just one function call, which has done its job of printing \"Hello World!\", the stack now rapidly unwinds back to main().","category":"page"},{"location":"devdocs/init.html#jl_atexit_hook()-1","page":"Julia ランタイムの初期化","title":"jl_atexit_hook()","text":"","category":"section"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"main() calls jl_atexit_hook(). This calls _atexit for each module, then calls jl_gc_run_all_finalizers() and cleans up libuv handles.","category":"page"},{"location":"devdocs/init.html#julia_save()-1","page":"Julia ランタイムの初期化","title":"julia_save()","text":"","category":"section"},{"location":"devdocs/init.html#","page":"Julia ランタイムの初期化","title":"Julia ランタイムの初期化","text":"Finally, main() calls julia_save(), which if requested on the command line, saves the runtime state to a new system image. See jl_compile_all() and jl_save_system_image().","category":"page"},{"location":"devdocs/ast.html#Julia-ASTs-1","page":"Julia ASTs","title":"Julia ASTs","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Julia has two representations of code. First there is a surface syntax AST returned by the parser (e.g. the Meta.parse function), and manipulated by macros. It is a structured representation of code as it is written, constructed by julia-parser.scm from a character stream. Next there is a lowered form, or IR (intermediate representation), which is used by type inference and code generation. In the lowered form there are fewer types of nodes, all macros are expanded, and all control flow is converted to explicit branches and sequences of statements. The lowered form is constructed by julia-syntax.scm.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"First we will focus on the AST, since it is needed to write macros.","category":"page"},{"location":"devdocs/ast.html#Surface-syntax-AST-1","page":"Julia ASTs","title":"Surface syntax AST","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Front end ASTs consist almost entirely of Exprs and atoms (e.g. symbols, numbers).  There is generally a different expression head for each visually distinct syntactic form.  Examples will be given in s-expression syntax.  Each parenthesized list corresponds to an Expr, where the first element is the head.  For example (call f x) corresponds to Expr(:call, :f, :x) in Julia.","category":"page"},{"location":"devdocs/ast.html#Calls-1","page":"Julia ASTs","title":"Calls","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Input AST\nf(x) (call f x)\nf(x, y=1, z=2) (call f x (kw y 1) (kw z 2))\nf(x; y=1) (call f (parameters (kw y 1)) x)\nf(x...) (call f (... x))","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"do syntax:","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"f(x) do a,b\n    body\nend","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"parses as (do (call f x) (-> (tuple a b) (block body))).","category":"page"},{"location":"devdocs/ast.html#Operators-1","page":"Julia ASTs","title":"Operators","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Most uses of operators are just function calls, so they are parsed with the head call. However some operators are special forms (not necessarily function calls), and in those cases the operator itself is the expression head. In julia-parser.scm these are referred to as \"syntactic operators\". Some operators (+ and *) use N-ary parsing; chained calls are parsed as a single N-argument call. Finally, chains of comparisons have their own special expression structure.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Input AST\nx+y (call + x y)\na+b+c+d (call + a b c d)\n2x (call * 2 x)\na&&b (&& a b)\nx += 1 (+= x 1)\na ? 1 : 2 (if a 1 2)\na:b (: a b)\na:b:c (: a b c)\na,b (tuple a b)\na==b (call == a b)\n1<i<=n (comparison 1 < i <= n)\na.b (. a (quote b))\na.(b) (. a b)","category":"page"},{"location":"devdocs/ast.html#Bracketed-forms-1","page":"Julia ASTs","title":"Bracketed forms","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Input AST\na[i] (ref a i)\nt[i;j] (typed_vcat t i j)\nt[i j] (typed_hcat t i j)\nt[a b; c d] (typed_vcat t (row a b) (row c d))\na{b} (curly a b)\na{b;c} (curly a (parameters c) b)\n[x] (vect x)\n[x,y] (vect x y)\n[x;y] (vcat x y)\n[x y] (hcat x y)\n[x y; z t] (vcat (row x y) (row z t))\n[x for y in z, a in b] (comprehension x (= y z) (= a b))\nT[x for y in z] (typed_comprehension T x (= y z))\n(a, b, c) (tuple a b c)\n(a; b; c) (block a (block b c))","category":"page"},{"location":"devdocs/ast.html#マクロ-1","page":"Julia ASTs","title":"マクロ","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Input AST\n@m x y (macrocall @m (line) x y)\nBase.@m x y (macrocall (. Base (quote @m)) (line) x y)\n@Base.m x y (macrocall (. Base (quote @m)) (line) x y)","category":"page"},{"location":"devdocs/ast.html#Strings-1","page":"Julia ASTs","title":"Strings","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Input AST\n\"a\" \"a\"\nx\"y\" (macrocall @x_str (line) \"y\")\nx\"y\"z (macrocall @x_str (line) \"y\" \"z\")\n\"x = $x\" (string \"x = \" x)\n`a b c` (macrocall @cmd (line) \"a b c\")","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Doc string syntax:","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"\"some docs\"\nf(x) = x","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"parses as (macrocall (|.| Core '@doc) (line) \"some docs\" (= (call f x) (block x))).","category":"page"},{"location":"devdocs/ast.html#Imports-and-such-1","page":"Julia ASTs","title":"Imports and such","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Input AST\nimport a (import (. a))\nimport a.b.c (import (. a b c))\nimport ...a (import (. . . . a))\nimport a.b, c.d (import (. a b) (. c d))\nimport Base: x (import (: (. Base) (. x)))\nimport Base: x, y (import (: (. Base) (. x) (. y)))\nexport a, b (export a b)","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"using has the same representation as import, but with expression head :using instead of :import.","category":"page"},{"location":"devdocs/ast.html#Numbers-1","page":"Julia ASTs","title":"Numbers","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Julia supports more number types than many scheme implementations, so not all numbers are represented directly as scheme numbers in the AST.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Input AST\n11111111111111111111 (macrocall @int128_str (null) \"11111111111111111111\")\n0xfffffffffffffffff (macrocall @uint128_str (null) \"0xfffffffffffffffff\")\n1111...many digits... (macrocall @big_str (null) \"1111....\")","category":"page"},{"location":"devdocs/ast.html#Block-forms-1","page":"Julia ASTs","title":"Block forms","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"A block of statements is parsed as (block stmt1 stmt2 ...).","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"If statement:","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"if a\n    b\nelseif c\n    d\nelse\n    e\nend","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"parses as:","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"(if a (block (line 2) b)\n    (elseif (block (line 3) c) (block (line 4) d)\n            (block (line 5 e))))","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"A while loop parses as (while condition body).","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"A for loop parses as (for (= var iter) body). If there is more than one iteration specification, they are parsed as a block: (for (block (= v1 iter1) (= v2 iter2)) body).","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"break and continue are parsed as 0-argument expressions (break) and (continue).","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"let is parsed as (let (= var val) body) or (let (block (= var1 val1) (= var2 val2) ...) body), like for loops.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"A basic function definition is parsed as (function (call f x) body). A more complex example:","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"function f(x::T; k = 1) where T\n    return x+1\nend","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"parses as:","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"(function (where (call f (parameters (kw k 1))\n                       (:: x T))\n                 T)\n          (block (line 2) (return (call + x 1))))","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Type definition:","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"mutable struct Foo{T<:S}\n    x::T\nend","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"parses as:","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"(struct true (curly Foo (<: T S))\n        (block (line 2) (:: x T)))","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"The first argument is a boolean telling whether the type is mutable.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"try blocks parse as (try try_block var catch_block finally_block). If no variable is present after catch, var is #f. If there is no finally clause, then the last argument is not present.","category":"page"},{"location":"devdocs/ast.html#Quote-expressions-1","page":"Julia ASTs","title":"Quote expressions","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Julia source syntax forms for code quoting (quote and :( )) support interpolation with $.  In Lisp terminology, this means they are actually \"backquote\" or \"quasiquote\" forms.  Internally, there is also a need for code quoting without interpolation.  In Julia's scheme code, non-interpolating quote is represented with the expression head inert.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"inert expressions are converted to Julia QuoteNode objects.  These objects wrap a single value of any type, and when evaluated simply return that value.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"A quote expression whose argument is an atom also gets converted to a QuoteNode.","category":"page"},{"location":"devdocs/ast.html#Line-numbers-1","page":"Julia ASTs","title":"Line numbers","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Source location information is represented as (line line_num file_name) where the third component is optional (and omitted when the current line number, but not file name, changes).","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"These expressions are represented as LineNumberNodes in Julia.","category":"page"},{"location":"devdocs/ast.html#マクロ-2","page":"Julia ASTs","title":"マクロ","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Macro hygiene is represented through the expression head pair escape and hygienic-scope.  The result of a macro expansion is automatically wrapped in (hygienic-scope block module), to represent the result of the new scope. The user can insert (escape block) inside to interpolate code from the caller.","category":"page"},{"location":"devdocs/ast.html#Lowered-form-1","page":"Julia ASTs","title":"Lowered form","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Lowered form (IR) is more important to the compiler, since it is used for type inference, optimizations like inlining, and and code generation. It is also less obvious to the human, since it results from a significant rearrangement of the input syntax.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"In addition to Symbols and some number types, the following data types exist in lowered form:","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Expr\nHas a node type indicated by the head field, and an args field which is a Vector{Any} of subexpressions. While almost every part of a surface AST is represented by an Expr, the IR uses only a limited number of Exprs, mostly for calls, conditional branches (gotoifnot), and returns.\nSlot\nIdentifies arguments and local variables by consecutive numbering. Slot is an abstract type with subtypes SlotNumber and TypedSlot. Both types have an integer-valued id field giving the slot index. Most slots have the same type at all uses, and so are represented with SlotNumber. The types of these slots are found in the slottypes field of their MethodInstance object. Slots that require per-use type annotations are represented with TypedSlot, which has a typ field.\nCodeInfo\nWraps the IR of a group of statements. Its code field is an array of expressions to execute.\nGotoNode\nUnconditional branch. The argument is the branch target, represented as an index in the code array to jump to.\nQuoteNode\nWraps an arbitrary value to reference as data. For example, the function f() = :a contains a QuoteNode whose value field is the symbol a, in order to return the symbol itself instead of evaluating it.\nGlobalRef\nRefers to global variable name in module mod.\nSSAValue\nRefers to a consecutively-numbered (starting at 1) static single assignment (SSA) variable inserted by the compiler. The number (id) of an SSAValue is the code array index of the expression whose value it represents.\nNewvarNode\nMarks a point where a variable (slot) is created. This has the effect of resetting a variable to undefined.","category":"page"},{"location":"devdocs/ast.html#Expr-types-1","page":"Julia ASTs","title":"Expr types","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"These symbols appear in the head field of Exprs in lowered form.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"call\nFunction call (dynamic dispatch). args[1] is the function to call, args[2:end] are the arguments.\ninvoke\nFunction call (static dispatch). args[1] is the MethodInstance to call, args[2:end] are the arguments (including the function that is being called, at args[2]).\nstatic_parameter\nReference a static parameter by index.\ngotoifnot\nConditional branch. If args[1] is false, goes to the index identified in args[2].\n=\nAssignment. In the IR, the first argument is always a Slot or a GlobalRef.\nmethod\nAdds a method to a generic function and assigns the result if necessary.\nHas a 1-argument form and a 3-argument form. The 1-argument form arises from the syntax function foo end. In the 1-argument form, the argument is a symbol. If this symbol already names a function in the current scope, nothing happens. If the symbol is undefined, a new function is created and assigned to the identifier specified by the symbol. If the symbol is defined but names a non-function, an error is raised. The definition of \"names a function\" is that the binding is constant, and refers to an object of singleton type. The rationale for this is that an instance of a singleton type uniquely identifies the type to add the method to. When the type has fields, it wouldn't be clear whether the method was being added to the instance or its type.\nThe 3-argument form has the following arguments:\nargs[1]\nA function name, or false if unknown. If a symbol, then the expression first behaves like the 1-argument form above. This argument is ignored from then on. When this is false, it means a method is being added strictly by type, (::T)(x) = x.\nargs[2]\nA SimpleVector of argument type data. args[2][1] is a SimpleVector of the argument types, and args[2][2] is a SimpleVector of type variables corresponding to the method's static parameters.\nargs[3]\nA CodeInfo of the method itself. For \"out of scope\" method definitions (adding a method to a function that also has methods defined in different scopes) this is an expression that evaluates to a :lambda expression.\nstruct_type\nA 7-argument expression that defines a new struct:\nargs[1]\nThe name of the struct\nargs[2]\nA call expression that creates SimpleVector specifying its parameters\nargs[3]\nA call expression that creates SimpleVector specifying its fieldnames\nargs[4]\nA Symbol or GlobalRef specifying the supertype (e.g., :Integer or GlobalRef(Core, :Any))\nargs[5]\nA call expression that creates SimpleVector specifying its fieldtypes\nargs[6]\nA Bool, true if mutable\nargs[7]\nThe number of arguments to initialize. This will be the number of fields, or the minimum number of fields called by an inner constructor's new statement.\nabstract_type\nA 3-argument expression that defines a new abstract type. The arguments are the same as the first three arguments of struct_type expressions.\nprimitive_type\nA 4-argument expression that defines a new primitive type. Arguments 1, 2, and 4 are the same as struct_type. Argument 3 is the number of bits.\nglobal\nDeclares a global binding.\nconst\nDeclares a (global) variable as constant.\nnew\nAllocates a new struct-like object. First argument is the type. The new pseudo-function is lowered to this, and the type is always inserted by the compiler.  This is very much an internal-only feature, and does no checking. Evaluating arbitrary new expressions can easily segfault.\nsplatnew\nSimilar to new, except field values are passed as a single tuple. Works similarly to Base.splat(new) if new were a first-class function, hence the name.\nreturn\nReturns its argument as the value of the enclosing function.\nisdefined\nExpr(:isdefined, :x) returns a Bool indicating whether x has already been defined in the current scope.\nthe_exception\nYields the caught exception inside a catch block, as returned by jl_current_exception().\nenter\nEnters an exception handler (setjmp). args[1] is the label of the catch block to jump to on error.  Yields a token which is consumed by pop_exception.\nleave\nPop exception handlers. args[1] is the number of handlers to pop.\npop_exception\nPop the stack of current exceptions back to the state at the associated enter when leaving a catch block. args[1] contains the token from the associated enter.\ncompat: Julia 1.1\npop_exception is new in Julia 1.1.\ninbounds\nControls turning bounds checks on or off. A stack is maintained; if the first argument of this expression is true or false (true means bounds checks are disabled), it is pushed onto the stack. If the first argument is :pop, the stack is popped.\nboundscheck\nHas the value false if inlined into a section of code marked with @inbounds, otherwise has the value true.\nloopinfo\nMarks the end of the a loop. Contains metadata that is passed to LowerSimdLoop to either mark the inner loop of @simd expression, or to propagate information to LLVM loop passes.\ncopyast\nPart of the implementation of quasi-quote. The argument is a surface syntax AST that is simply copied recursively and returned at run time.\nmeta\nMetadata. args[1] is typically a symbol specifying the kind of metadata, and the rest of the arguments are free-form. The following kinds of metadata are commonly used:\n:inline and :noinline: Inlining hints.","category":"page"},{"location":"devdocs/ast.html#Method-1","page":"Julia ASTs","title":"Method","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"A unique'd container describing the shared metadata for a single method.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"name, module, file, line, sig\nMetadata to uniquely identify the method for the computer and the human.\nambig\nCache of other methods that may be ambiguous with this one.\nspecializations\nCache of all MethodInstance ever created for this Method, used to ensure uniqueness. Uniqueness is required for efficiency, especially for incremental precompile and tracking of method invalidation.\nsource\nThe original source code (if available, usually compressed).\ngenerator\nA callable object which can be executed to get specialized source for a specific method signature.\nroots\nPointers to non-AST things that have been interpolated into the AST, required by compression of the AST, type-inference, or the generation of native code.\nnargs, isva, called, isstaged, pure\nDescriptive bit-fields for the source code of this Method.\nprimary_world\nThe world age that \"owns\" this Method.","category":"page"},{"location":"devdocs/ast.html#MethodInstance-1","page":"Julia ASTs","title":"MethodInstance","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"A unique'd container describing a single callable signature for a Method. See especially Proper maintenance and care of multi-threading locks  for important details on how to modify these fields safely.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"specTypes\nThe primary key for this MethodInstance. Uniqueness is guaranteed through a def.specializations lookup.\ndef\nThe Method that this function describes a specialization of. Or a Module, if this is a top-level Lambda expanded in Module, and which is not part of a Method.\nsparam_vals\nThe values of the static parameters in specTypes indexed by def.sparam_syms. For the MethodInstance at Method.unspecialized, this is the empty SimpleVector. But for a runtime MethodInstance from the MethodTable cache, this will always be defined and indexable.\nuninferred\nThe uncompressed source code for a toplevel thunk. Additionally, for a generated function, this is one of many places that the source code might be found.\nbackedges\nWe store the reverse-list of cache dependencies for efficient tracking of incremental reanalysis/recompilation work that may be needed after a new method definitions. This works by keeping a list of the other MethodInstance that have been inferred or optimized to contain a possible call to this MethodInstance. Those optimization results might be stored somewhere in the cache, or it might have been the result of something we didn't want to cache, such as constant propagation. Thus we merge all of those backedges to various cache entries here (there's almost always only the one applicable cache entry with a sentinal value for max_world anyways).\ncache\nCache of CodeInstance objects that share this template instantiation.","category":"page"},{"location":"devdocs/ast.html#CodeInstance-1","page":"Julia ASTs","title":"CodeInstance","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"def\nThe MethodInstance that this cache entry is derived from.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"rettype/rettype_const\nThe inferred return type for the specFunctionObject field, which (in most cases) is also the computed return type for the function in general.\ninferred\nMay contain a cache of the inferred source for this function, or it could be set to nothing to just indicate rettype is inferred.\nftpr\nThe generic jlcall entry point.\njlcall_api\nThe ABI to use when calling fptr. Some significant ones include:\n0 - Not compiled yet\n1 - JLCALLABLE `jlvaluet ()(jlfunctiont *f, jlvaluet *args[nargs], uint32t nargs)`\n2 - Constant (value stored in rettype_const)\n3 - With Static-parameters forwarded jl_value_t *(*)(jl_svec_t *sparams, jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)\n4 - Run in interpreter jl_value_t *(*)(jl_method_instance_t *meth, jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)\nmin_world / max_world\nThe range of world ages for which this method instance is valid to be called. If max_world is the special token value -1, the value is not yet known. It may continue to be used until we encounter a backedge that requires us to reconsider.","category":"page"},{"location":"devdocs/ast.html#CodeInfo-1","page":"Julia ASTs","title":"CodeInfo","text":"","category":"section"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"A (usually temporary) container for holding lowered source code.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"code\nAn Any array of statements\nslotnames\nAn array of symbols giving names for each slot (argument or local variable).\nslotflags\nA UInt8 array of slot properties, represented as bit flags:\n2 - assigned (only false if there are no assignment statements with this var on the left)\n8 - const (currently unused for local variables)\n16 - statically assigned once\n32 - might be used before assigned. This flag is only valid after type inference.\nssavaluetypes\nEither an array or an Int.\nIf an Int, it gives the number of compiler-inserted temporary locations in the function (the length of code array). If an array, specifies a type for each location.\nssaflags\nStatement-level flags for each expression in the function. Many of these are reserved, but not yet implemented:\n0 = inbounds\n1,2 = <reserved> inlinehint,always-inline,noinline\n3 = <reserved> strict-ieee (strictfp)\n4-6 = <unused>\n7 = <reserved> has out-of-band info\nlinetable\nAn array of source location objects\ncodelocs\nAn array of integer indices into the linetable, giving the location associated with each statement.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"オプション引数:","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"slottypes\nAn array of types for the slots.\nrettype\nThe inferred return type of the lowered form (IR). Default value is Any.\nmethod_for_inference_limit_heuristics\nThe method_for_inference_heuristics will expand the given method's generator if necessary during inference.\nparent\nThe MethodInstance that \"owns\" this object (if applicable).\nmin_world/max_world\nThe range of world ages for which this code was valid at the time when it had been inferred.","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"Boolean properties:","category":"page"},{"location":"devdocs/ast.html#","page":"Julia ASTs","title":"Julia ASTs","text":"inferred\nWhether this has been produced by type inference.\ninlineable\nWhether this should be eligible for inlining.\npropagate_inbounds\nWhether this should propagate @inbounds when inlined for the purpose of eliding @boundscheck blocks.\npure\nWhether this is known to be a pure function of its arguments, without respect to the state of the method caches or other mutable global state.","category":"page"},{"location":"devdocs/types.html#More-about-types-1","page":"More about types","title":"More about types","text":"","category":"section"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"If you've used Julia for a while, you understand the fundamental role that types play.  Here we try to get under the hood, focusing particularly on Parametric Types.","category":"page"},{"location":"devdocs/types.html#Types-and-sets-(and-Any-and-Union{}/Bottom)-1","page":"More about types","title":"Types and sets (and Any and Union{}/Bottom)","text":"","category":"section"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"It's perhaps easiest to conceive of Julia's type system in terms of sets. While programs manipulate individual values, a type refers to a set of values. This is not the same thing as a collection; for example a Set of values is itself a single Set value.  Rather, a type describes a set of possible values, expressing uncertainty about which value we have.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"A concrete type T describes the set of values whose direct tag, as returned by the typeof  function, is T. An abstract type describes some possibly-larger set of values.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Any describes the entire universe of possible values. Integer is a subset of Any that includes Int, Int8, and other concrete types.  Internally, Julia also makes heavy use of another type known as Bottom, which can also be written as Union{}. This corresponds to the empty set.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Julia's types support the standard operations of set theory: you can ask whether T1 is a \"subset\" (subtype) of T2 with T1 <: T2. Likewise, you intersect two types using typeintersect, take their union with Union, and compute a type that contains their union with typejoin:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> typeintersect(Int, Float64)\nUnion{}\n\njulia> Union{Int, Float64}\nUnion{Float64, Int64}\n\njulia> typejoin(Int, Float64)\nReal\n\njulia> typeintersect(Signed, Union{UInt8, Int8})\nInt8\n\njulia> Union{Signed, Union{UInt8, Int8}}\nUnion{UInt8, Signed}\n\njulia> typejoin(Signed, Union{UInt8, Int8})\nInteger\n\njulia> typeintersect(Tuple{Integer,Float64}, Tuple{Int,Real})\nTuple{Int64,Float64}\n\njulia> Union{Tuple{Integer,Float64}, Tuple{Int,Real}}\nUnion{Tuple{Int64,Real}, Tuple{Integer,Float64}}\n\njulia> typejoin(Tuple{Integer,Float64}, Tuple{Int,Real})\nTuple{Integer,Real}","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"While these operations may seem abstract, they lie at the heart of Julia.  For example, method dispatch is implemented by stepping through the items in a method list until reaching one for which the type of the argument tuple is a subtype of the method signature. For this algorithm to work, it's important that methods be sorted by their specificity, and that the search begins with the most specific methods. Consequently, Julia also implements a partial order on types; this is achieved by functionality that is similar to <:, but with differences that will be discussed below.","category":"page"},{"location":"devdocs/types.html#UnionAll-types-1","page":"More about types","title":"UnionAll types","text":"","category":"section"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Julia's type system can also express an iterated union of types: a union of types over all values of some variable. This is needed to describe parametric types where the values of some parameters are not known.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"For example, Array has two parameters as in Array{Int,2}. If we did not know the element type, we could write Array{T,2} where T, which is the union of Array{T,2} for all values of T: Union{Array{Int8,2}, Array{Int16,2}, ...}.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Such a type is represented by a UnionAll object, which contains a variable (T in this example, of type TypeVar), and a wrapped type (Array{T,2} in this example).","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Consider the following methods:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"f1(A::Array) = 1\nf2(A::Array{Int}) = 2\nf3(A::Array{T}) where {T<:Any} = 3\nf4(A::Array{Any}) = 4","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"The signature - as decribed in Function calls - of f3 is a UnionAll type wrapping a tuple type: Tuple{typeof(f3), Array{T}} where T.  All but f4 can be called with a = [1,2]; all but f2 can be called with b = Any[1,2].","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Let's look at these types a little more closely:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> dump(Array)\nUnionAll\n  var: TypeVar\n    name: Symbol T\n    lb: Core.TypeofBottom Union{}\n    ub: Any\n  body: UnionAll\n    var: TypeVar\n      name: Symbol N\n      lb: Core.TypeofBottom Union{}\n      ub: Any\n    body: Array{T,N} <: DenseArray{T,N}","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"This indicates that Array actually names a UnionAll type. There is one UnionAll type for each parameter, nested. The syntax Array{Int,2} is equivalent to Array{Int}{2}; internally each UnionAll is instantiated with a particular variable value, one at a time, outermost-first. This gives a natural meaning to the omission of trailing type parameters; Array{Int} gives a type equivalent to Array{Int,N} where N.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"A TypeVar is not itself a type, but rather should be considered part of the structure of a UnionAll type. Type variables have lower and upper bounds on their values (in the fields lb and ub). The symbol name is purely cosmetic. Internally, TypeVars are compared by address, so they are defined as mutable types to ensure that \"different\" type variables can be distinguished. However, by convention they should not be mutated.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"One can construct TypeVars manually:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> TypeVar(:V, Signed, Real)\nSigned<:V<:Real","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"There are convenience versions that allow you to omit any of these arguments except the name symbol.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"The syntax Array{T} where T<:Integer is lowered to","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"let T = TypeVar(:T,Integer)\n    UnionAll(T, Array{T})\nend","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"so it is seldom necessary to construct a TypeVar manually (indeed, this is to be avoided).","category":"page"},{"location":"devdocs/types.html#Free-variables-1","page":"More about types","title":"Free variables","text":"","category":"section"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"The concept of a free type variable is extremely important in the type system. We say that a variable V is free in type T if T does not contain the UnionAll that introduces variable V. For example, the type Array{Array{V} where V<:Integer} has no free variables, but the Array{V} part inside of it does have a free variable, V.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"A type with free variables is, in some sense, not really a type at all. Consider the type Array{Array{T}} where T, which refers to all homogeneous arrays of arrays.  The inner type Array{T}, seen by itself, might seem to refer to any kind of array.  However, every element of the outer array must have the same array type, so Array{T} cannot refer to just any old array. One could say that Array{T} effectively \"occurs\" multiple times, and T must have the same value each \"time\".","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"For this reason, the function jl_has_free_typevars in the C API is very important. Types for which it returns true will not give meaningful answers in subtyping and other type functions.","category":"page"},{"location":"devdocs/types.html#TypeNames-1","page":"More about types","title":"TypeNames","text":"","category":"section"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"The following two Array types are functionally equivalent, yet print differently:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> TV, NV = TypeVar(:T), TypeVar(:N)\n(T, N)\n\njulia> Array\nArray\n\njulia> Array{TV,NV}\nArray{T,N}","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"These can be distinguished by examining the name field of the type, which is an object of type TypeName:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> dump(Array{Int,1}.name)\nTypeName\n  name: Symbol Array\n  module: Module Core\n  names: empty SimpleVector\n  wrapper: UnionAll\n    var: TypeVar\n      name: Symbol T\n      lb: Core.TypeofBottom Union{}\n      ub: Any\n    body: UnionAll\n      var: TypeVar\n        name: Symbol N\n        lb: Core.TypeofBottom Union{}\n        ub: Any\n      body: Array{T,N} <: DenseArray{T,N}\n  cache: SimpleVector\n    ...\n\n  linearcache: SimpleVector\n    ...\n\n  hash: Int64 -7900426068641098781\n  mt: MethodTable\n    name: Symbol Array\n    defs: Nothing nothing\n    cache: Nothing nothing\n    max_args: Int64 0\n    kwsorter: #undef\n    module: Module Core\n    : Int64 0\n    : Int64 0","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"In this case, the relevant field is wrapper, which holds a reference to the top-level type used to make new Array types.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> pointer_from_objref(Array)\nPtr{Cvoid} @0x00007fcc7de64850\n\njulia> pointer_from_objref(Array.body.body.name.wrapper)\nPtr{Cvoid} @0x00007fcc7de64850\n\njulia> pointer_from_objref(Array{TV,NV})\nPtr{Cvoid} @0x00007fcc80c4d930\n\njulia> pointer_from_objref(Array{TV,NV}.name.wrapper)\nPtr{Cvoid} @0x00007fcc7de64850","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"The wrapper field of Array points to itself, but for Array{TV,NV} it points back to the original definition of the type.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"What about the other fields? hash assigns an integer to each type.  To examine the cache field, it's helpful to pick a type that is less heavily used than Array. Let's first create our own type:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> struct MyType{T,N} end\n\njulia> MyType{Int,2}\nMyType{Int64,2}\n\njulia> MyType{Float32, 5}\nMyType{Float32,5}\n\njulia> MyType.body.body.name.cache\nsvec(MyType{Int64,2}, MyType{Float32,5}, #undef, #undef, #undef, #undef, #undef, #undef)","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"(The cache is pre-allocated to have length 8, but only the first two entries are populated.) Consequently, when you instantiate a parametric type, each concrete type gets saved in a type cache.  However, instances containing free type variables are not cached.","category":"page"},{"location":"devdocs/types.html#Tuple-types-1","page":"More about types","title":"Tuple types","text":"","category":"section"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Tuple types constitute an interesting special case.  For dispatch to work on declarations like x::Tuple, the type has to be able to accommodate any tuple.  Let's check the parameters:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> Tuple\nTuple\n\njulia> Tuple.parameters\nsvec(Vararg{Any,N} where N)","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Unlike other types, tuple types are covariant in their parameters, so this definition permits Tuple to match any type of tuple:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> typeintersect(Tuple, Tuple{Int,Float64})\nTuple{Int64,Float64}\n\njulia> typeintersect(Tuple{Vararg{Any}}, Tuple{Int,Float64})\nTuple{Int64,Float64}","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"However, if a variadic (Vararg) tuple type has free variables it can describe different kinds of tuples:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> typeintersect(Tuple{Vararg{T} where T}, Tuple{Int,Float64})\nTuple{Int64,Float64}\n\njulia> typeintersect(Tuple{Vararg{T}} where T, Tuple{Int,Float64})\nUnion{}","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Notice that when T is free with respect to the Tuple type (i.e. its binding UnionAll type is outside the Tuple type), only one T value must work over the whole type.  Therefore a heterogeneous tuple does not match.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Finally, it's worth noting that Tuple{} is distinct:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> Tuple{}\nTuple{}\n\njulia> Tuple{}.parameters\nsvec()\n\njulia> typeintersect(Tuple{}, Tuple{Int})\nUnion{}","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"What is the \"primary\" tuple-type?","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> pointer_from_objref(Tuple)\nPtr{Cvoid} @0x00007f5998a04370\n\njulia> pointer_from_objref(Tuple{})\nPtr{Cvoid} @0x00007f5998a570d0\n\njulia> pointer_from_objref(Tuple.name.wrapper)\nPtr{Cvoid} @0x00007f5998a04370\n\njulia> pointer_from_objref(Tuple{}.name.wrapper)\nPtr{Cvoid} @0x00007f5998a04370","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"so Tuple == Tuple{Vararg{Any}} is indeed the primary type.","category":"page"},{"location":"devdocs/types.html#Diagonal-types-1","page":"More about types","title":"Diagonal types","text":"","category":"section"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Consider the type Tuple{T,T} where T.  A method with this signature would look like:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"f(x::T, y::T) where {T} = ...","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"According to the usual interpretation of a UnionAll type, this T ranges over all types, including Any, so this type should be equivalent to Tuple{Any,Any}.  However, this interpretation causes some practical problems.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"First, a value of T needs to be available inside the method definition. For a call like f(1, 1.0), it's not clear what T should be.  It could be Union{Int,Float64}, or perhaps Real.  Intuitively, we expect the declaration x::T to mean T === typeof(x).  To make sure that invariant holds, we need typeof(x) === typeof(y) === T in this method.  That implies the method should only be called for arguments of the exact same type.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"It turns out that being able to dispatch on whether two values have the same type is very useful (this is used by the promotion system for example), so we have multiple reasons to want a different interpretation of Tuple{T,T} where T.  To make this work we add the following rule to subtyping: if a variable occurs more than once in covariant position, it is restricted to ranging over only concrete types.  (\"Covariant position\" means that only Tuple and Union types occur between an occurrence of a variable and the UnionAll type that introduces it.)  Such variables are called \"diagonal variables\" or \"concrete variables\".","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"So for example, Tuple{T,T} where T can be seen as Union{Tuple{Int8,Int8}, Tuple{Int16,Int16}, ...}, where T ranges over all concrete types. This gives rise to some interesting subtyping results. For example Tuple{Real,Real} is not a subtype of Tuple{T,T} where T, because it includes some types like Tuple{Int8,Int16} where the two elements have different types. Tuple{Real,Real} and Tuple{T,T} where T have the non-trivial intersection Tuple{T,T} where T<:Real. However, Tuple{Real} is a subtype of Tuple{T} where T, because in that case T occurs only once and so is not diagonal.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Next consider a signature like the following:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"f(a::Array{T}, x::T, y::T) where {T} = ...","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"In this case, T occurs in invariant position inside Array{T}.  That means whatever type of array is passed unambiguously determines the value of T – we say T has an equality constraint on it.  Therefore in this case the diagonal rule is not really necessary, since the array determines T and we can then allow x and y to be of any subtypes of T.  So variables that occur in invariant position are never considered diagonal. This choice of behavior is slightly controversial –- some feel this definition should be written as","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"f(a::Array{T}, x::S, y::S) where {T, S<:T} = ...","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"to clarify whether x and y need to have the same type.  In this version of the signature they would, or we could introduce a third variable for the type of y if x and y can have different types.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"The next complication is the interaction of unions and diagonal variables, e.g.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"f(x::Union{Nothing,T}, y::T) where {T} = ...","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Consider what this declaration means.  y has type T. x then can have either the same type T, or else be of type Nothing.  So all of the following calls should match:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"f(1, 1)\nf(\"\", \"\")\nf(2.0, 2.0)\nf(nothing, 1)\nf(nothing, \"\")\nf(nothing, 2.0)","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"These examples are telling us something: when x is nothing::Nothing, there are no extra constraints on y.  It is as if the method signature had y::Any.  This means that whether a variable is diagonal is not a static property based on where it appears in a type.  Rather, it depends on where a variable appears when the subtyping algorithm uses it.  When x has type Nothing, we don't need to use the T in Union{Nothing,T}, so T does not \"occur\".  Indeed, we have the following type equivalence:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"(Tuple{Union{Nothing,T},T} where T) == Union{Tuple{Nothing,Any}, Tuple{T,T} where T}","category":"page"},{"location":"devdocs/types.html#Subtyping-diagonal-variables-1","page":"More about types","title":"Subtyping diagonal variables","text":"","category":"section"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"The subtyping algorithm for diagonal variables has two components: (1) identifying variable occurrences, and (2) ensuring that diagonal variables range over concrete types only.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"The first task is accomplished by keeping counters occurs_inv and occurs_cov (in src/subtype.c) for each variable in the environment, tracking the number of invariant and covariant occurrences, respectively. A variable is diagonal when occurs_inv == 0 && occurs_cov > 1.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"The second task is accomplished by imposing a condition on a variable's lower bound.  As the subtyping algorithm runs, it narrows the bounds of each variable (raising lower bounds and lowering upper bounds) to keep track of the range of variable values for which the subtype relation would hold. When we are done evaluating the body of a UnionAll type whose variable is diagonal, we look at the final values of the bounds.  Since the variable must be concrete, a contradiction occurs if its lower bound could not be a subtype of a concrete type.  For example, an abstract type like AbstractArray cannot be a subtype of a concrete type, but a concrete type like Int can be, and the empty type Bottom can be as well.  If a lower bound fails this test the algorithm stops with the answer false.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"For example, in the problem Tuple{Int,String} <: Tuple{T,T} where T, we derive that this would be true if T were a supertype of Union{Int,String}. However, Union{Int,String} is an abstract type, so the relation does not hold.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"This concreteness test is done by the function is_leaf_bound.  Note that this test is slightly different from jl_is_leaf_type, since it also returns true for Bottom.  Currently this function is heuristic, and does not catch all possible concrete types.  The difficulty is that whether a lower bound is concrete might depend on the values of other type variable bounds.  For example, Vector{T} is equivalent to the concrete type Vector{Int} only if both the upper and lower bounds of T equal Int. We have not yet worked out a complete algorithm for this.","category":"page"},{"location":"devdocs/types.html#Introduction-to-the-internal-machinery-1","page":"More about types","title":"Introduction to the internal machinery","text":"","category":"section"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Most operations for dealing with types are found in the files jltypes.c and subtype.c.  A good way to start is to watch subtyping in action. Build Julia with make debug and fire up Julia within a debugger.  gdb debugging tips has some tips which may be useful.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"Because the subtyping code is used heavily in the REPL itself–and hence breakpoints in this code get triggered often–it will be easiest if you make the following definition:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"julia> function mysubtype(a,b)\n           ccall(:jl_breakpoint, Cvoid, (Any,), nothing)\n           a <: b\n       end","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"and then set a breakpoint in jl_breakpoint.  Once this breakpoint gets triggered, you can set breakpoints in other functions.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"As a warm-up, try the following:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"mysubtype(Tuple{Int,Float64}, Tuple{Integer,Real})","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"We can make it more interesting by trying a more complex case:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"mysubtype(Tuple{Array{Int,2}, Int8}, Tuple{Array{T}, T} where T)","category":"page"},{"location":"devdocs/types.html#Subtyping-and-method-sorting-1","page":"More about types","title":"Subtyping and method sorting","text":"","category":"section"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"The type_morespecific functions are used for imposing a partial order on functions in method tables (from most-to-least specific). Specificity is strict; if a is more specific than b, then a does not equal b and b is not more specific than a.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"If a is a strict subtype of b, then it is automatically considered more specific.  From there, type_morespecific employs some less formal rules. For example, subtype is sensitive to the number of arguments, but type_morespecific may not be.  In particular, Tuple{Int,AbstractFloat} is more specific than Tuple{Integer}, even though it is not a subtype. (Of Tuple{Int,AbstractFloat} and Tuple{Integer,Float64}, neither is more specific than the other.)  Likewise, Tuple{Int,Vararg{Int}} is not a subtype of Tuple{Integer}, but it is considered more specific. However, morespecific does get a bonus for length: in particular, Tuple{Int,Int} is more specific than Tuple{Int,Vararg{Int}}.","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"If you're debugging how methods get sorted, it can be convenient to define the function:","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"type_morespecific(a, b) = ccall(:jl_type_morespecific, Cint, (Any,Any), a, b)","category":"page"},{"location":"devdocs/types.html#","page":"More about types","title":"More about types","text":"which allows you to test whether tuple type a is more specific than tuple type b.","category":"page"},{"location":"devdocs/object.html#Memory-layout-of-Julia-Objects-1","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"","category":"section"},{"location":"devdocs/object.html#Object-layout-(jl_value_t)-1","page":"Memory layout of Julia Objects","title":"Object layout (jl_value_t)","text":"","category":"section"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"The jl_value_t struct is the name for a block of memory owned by the Julia Garbage Collector, representing the data associated with a Julia object in memory. Absent any type information, it is simply an opaque pointer:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"typedef struct jl_value_t* jl_pvalue_t;","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Each jl_value_t struct is contained in a jl_typetag_t struct that contains metadata information about the Julia object, such as its type and garbage collector (gc) reachability:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"typedef struct {\n    opaque metadata;\n    jl_value_t value;\n} jl_typetag_t;","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"The type of any Julia object is an instance of a leaf jl_datatype_t object. The jl_typeof() function can be used to query for it:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"jl_value_t *jl_typeof(jl_value_t *v);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"The layout of the object depends on its type. Reflection methods can be used to inspect that layout.  A field can be accessed by calling one of the get-field methods:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);\njl_value_t *jl_get_field(jl_value_t *o, char *fld);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"If the field types are known, a priori, to be all pointers, the values can also be extracted directly as an array access:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"jl_value_t *v = value->fieldptr[n];","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"As an example, a \"boxed\" uint16_t is stored as follows:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"struct {\n    opaque metadata;\n    struct {\n        uint16_t data;        // -- 2 bytes\n    } jl_value_t;\n};","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"This object is created by jl_box_uint16(). Note that the jl_value_t pointer references the data portion, not the metadata at the top of the struct.","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"A value may be stored \"unboxed\" in many circumstances (just the data, without the metadata, and possibly not even stored but just kept in registers), so it is unsafe to assume that the address of a box is a unique identifier. The \"egal\" test (corresponding to the === function in Julia), should instead be used to compare two unknown objects for equivalence:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"int jl_egal(jl_value_t *a, jl_value_t *b);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"This optimization should be relatively transparent to the API, since the object will be \"boxed\" on-demand, whenever a jl_value_t pointer is needed.","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Note that modification of a jl_value_t pointer in memory is permitted only if the object is mutable. Otherwise, modification of the value may corrupt the program and the result will be undefined.  The mutability property of a value can be queried for with:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"int jl_is_mutable(jl_value_t *v);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"If the object being stored is a jl_value_t, the Julia garbage collector must be notified also:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"void jl_gc_wb(jl_value_t *parent, jl_value_t *ptr);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"ただし、マニュアルの Julia の埋め込みセクションは、この時点で読んで置くべきです。様々な型のboxing/unboxing の詳細や、gc の相互作用などのトピックをカバーできるでしょう。","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Mirror structs for some of the built-in types are defined in julia.h.  The corresponding global jl_datatype_t objects are created by jl_init_types in jltypes.c.","category":"page"},{"location":"devdocs/object.html#Garbage-collector-mark-bits-1","page":"Memory layout of Julia Objects","title":"Garbage collector mark bits","text":"","category":"section"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"The garbage collector uses several bits from the metadata portion of the jl_typetag_t to track each object in the system. Further details about this algorithm can be found in the comments of the garbage collector implementation in gc.c.","category":"page"},{"location":"devdocs/object.html#Object-allocation-1","page":"Memory layout of Julia Objects","title":"Object allocation","text":"","category":"section"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Most new objects are allocated by jl_new_structv():","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"jl_value_t *jl_new_struct(jl_datatype_t *type, ...);\njl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Although, isbits objects can be also constructed directly from memory:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"jl_value_t *jl_new_bits(jl_value_t *bt, void *data)","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"And some objects have special constructors that must be used instead of the above functions:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Types:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"jl_datatype_t *jl_apply_type(jl_datatype_t *tc, jl_tuple_t *params);\njl_datatype_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"While these are the most commonly used options, there are more low-level constructors too, which you can find declared in julia.h. These are used in jl_init_types() to create the initial types needed to bootstrap the creation of the Julia system image.","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Tuples:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"jl_tuple_t *jl_tuple(size_t n, ...);\njl_tuple_t *jl_tuplev(size_t n, jl_value_t **v);\njl_tuple_t *jl_alloc_tuple(size_t n);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"The representation of tuples is highly unique in the Julia object representation ecosystem. In some cases, a Base.tuple() object may be an array of pointers to the objects contained by the tuple equivalent to:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"typedef struct {\n    size_t length;\n    jl_value_t *data[length];\n} jl_tuple_t;","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"However, in other cases, the tuple may be converted to an anonymous isbits type and stored unboxed, or it may not stored at all (if it is not being used in a generic context as a jl_value_t*).","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Symbols:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"jl_sym_t *jl_symbol(const char *str);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Functions and MethodInstance:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"jl_function_t *jl_new_generic_function(jl_sym_t *name);\njl_method_instance_t *jl_new_method_instance(jl_value_t *ast, jl_tuple_t *sparams);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Arrays:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"jl_array_t *jl_new_array(jl_value_t *atype, jl_tuple_t *dims);\njl_array_t *jl_new_arrayv(jl_value_t *atype, ...);\njl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);\njl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr, size_t nc);\njl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr, size_t nc, size_t z);\njl_array_t *jl_alloc_vec_any(size_t n);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Note that many of these have alternative allocation functions for various special-purposes. The list here reflects the more common usages, but a more complete list can be found by reading the julia.h header file.","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Internal to Julia, storage is typically allocated by newstruct() (or newobj() for the special types):","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"jl_value_t *newstruct(jl_value_t *type);\njl_value_t *newobj(jl_value_t *type, size_t nfields);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"And at the lowest level, memory is getting allocated by a call to the garbage collector (in gc.c), then tagged with its type:","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"jl_value_t *jl_gc_allocobj(size_t nbytes);\nvoid jl_set_typeof(jl_value_t *v, jl_datatype_t *type);","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"Note that all objects are allocated in multiples of 4 bytes and aligned to the platform pointer size. Memory is allocated from a pool for smaller objects, or directly with malloc() for large objects.","category":"page"},{"location":"devdocs/object.html#","page":"Memory layout of Julia Objects","title":"Memory layout of Julia Objects","text":"sidebar: Singleton Types\nSingleton types have only one instance and no data fields. Singleton instances have a size of 0 bytes, and consist only of their metadata. e.g. nothing::Nothing.See Singleton Types and Nothingness and missing values","category":"page"},{"location":"devdocs/eval.html#Eval-of-Julia-code-1","page":"Eval of Julia code","title":"Eval of Julia code","text":"","category":"section"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"One of the hardest parts about learning how the Julia Language runs code is learning how all of the pieces work together to execute a block of code.","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"Each chunk of code typically makes a trip through many steps with potentially unfamiliar names, such as (in no particular order): flisp, AST, C++, LLVM, eval, typeinf, macroexpand, sysimg (or system image), bootstrapping, compile, parse, execute, JIT, interpret, box, unbox, intrinsic function, and primitive function, before turning into the desired result (hopefully).","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"sidebar: Definitions\nREPL\nREPL stands for Read-Eval-Print Loop. It's just what we call the command line environment for short.\nAST\nAbstract Syntax Tree The AST is the digital representation of the code structure. In this form the code has been tokenized for meaning so that it is more suitable for manipulation and execution.","category":"page"},{"location":"devdocs/eval.html#Julia-Execution-1","page":"Eval of Julia code","title":"Julia Execution","text":"","category":"section"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"The 10,000 foot view of the whole process is as follows:","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"The user starts julia.\nThe C function main() from ui/repl.c gets called. This function processes the command line arguments, filling in the jl_options struct and setting the variable ARGS. It then initializes Julia (by calling julia_init in task.c, which may load a previously compiled sysimg). Finally, it passes off control to Julia by calling Base._start().\nWhen _start() takes over control, the subsequent sequence of commands depends on the command line arguments given. For example, if a filename was supplied, it will proceed to execute that file. Otherwise, it will start an interactive REPL.\nSkipping the details about how the REPL interacts with the user, let's just say the program ends up with a block of code that it wants to run.\nIf the block of code to run is in a file, jl_load(char *filename) gets invoked to load the file and parse it. Each fragment of code is then passed to eval to execute.\nEach fragment of code (or AST), is handed off to eval() to turn into results.\neval() takes each code fragment and tries to run it in jl_toplevel_eval_flex().\njl_toplevel_eval_flex() decides whether the code is a \"toplevel\" action (such as using or module), which would be invalid inside a function. If so, it passes off the code to the toplevel interpreter.\njl_toplevel_eval_flex() then expands the code to eliminate any macros and to \"lower\" the AST to make it simpler to execute.\njl_toplevel_eval_flex() then uses some simple heuristics to decide  whether to JIT compiler the AST or to interpret it directly.\nThe bulk of the work to interpret code is handled by eval in  interpreter.c.\n代わりに、コードがコンパイルされている場合、作業の大部分は codegen.cpp  によって処理されます。型指定された引数とともに、Julia 関数が初めて呼ばれるときはいつも、その関数で  型推論 が実行されます。この情報は、  codegen ステップでより高速なコードを生成するために使用されます。\nEventually, the user quits the REPL, or the end of the program is  reached, and the _start() method returns.\nJust before exiting, main() calls  jl_atexit_hook(exit_code).  This calls Base._atexit() (which calls any functions registered to  atexit() inside Julia). Then it calls  jl_gc_run_all_finalizers().  Finally, it gracefully cleans up all libuv handles and waits for them  to flush and close.","category":"page"},{"location":"devdocs/eval.html#dev-parsing-1","page":"Eval of Julia code","title":"Parsing","text":"","category":"section"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"The Julia parser is a small lisp program written in femtolisp, the source-code for which is distributed inside Julia in src/flisp.","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"The interface functions for this are primarily defined in jlfrontend.scm. The code in ast.c handles this handoff on the Julia side.","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"The other relevant files at this stage are julia-parser.scm, which handles tokenizing Julia code and turning it into an AST, and julia-syntax.scm, which handles transforming complex AST representations into simpler, \"lowered\" AST representations which are more suitable for analysis and execution.","category":"page"},{"location":"devdocs/eval.html#dev-macro-expansion-1","page":"Eval of Julia code","title":"Macro Expansion","text":"","category":"section"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"When eval() encounters a macro, it expands that AST node before attempting to evaluate the expression. Macro expansion involves a handoff from eval() (in Julia), to the parser function jl_macroexpand() (written in flisp) to the Julia macro itself (written in - what else - Julia) via fl_invoke_julia_macro(), and back.","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"Typically, macro expansion is invoked as a first step during a call to Meta.lower()/jl_expand(), although it can also be invoked directly by a call to macroexpand()/jl_macroexpand().","category":"page"},{"location":"devdocs/eval.html#dev-type-inference-1","page":"Eval of Julia code","title":"型推論","text":"","category":"section"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"Type inference is implemented in Julia by typeinf() in compiler/typeinfer.jl. Type inference is the process of examining a Julia function and determining bounds for the types of each of its variables, as well as bounds on the type of the return value from the function.  This enables many future optimizations, such as unboxing of known immutable values, and compile-time hoisting of various run-time operations such as computing field offsets and function pointers.  Type inference may also include other steps such as constant propagation and inlining.","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"sidebar: More Definitions\nJIT\nJust-In-Time Compilation The process of generating native-machine code into memory right when it is needed.\nLLVM\nLow-Level Virtual Machine (a compiler) The Julia JIT compiler is a program/library called libLLVM. Codegen in Julia refers both to the process of taking a Julia AST and turning it into LLVM instructions, and the process of LLVM optimizing that and turning it into native assembly instructions.\nC++\nThe programming language that LLVM is implemented in, which means that codegen is also implemented in this language. The rest of Julia's library is implemented in C, in part because its smaller feature set makes it more usable as a cross-language interface layer.\nbox\nThis term is used to describe the process of taking a value and allocating a wrapper around the data that is tracked by the garbage collector (gc) and is tagged with the object's type.\nunbox\nThe reverse of boxing a value. This operation enables more efficient manipulation of data when the type of that data is fully known at compile-time (through type inference).\ngeneric function\nA Julia function composed of multiple \"methods\" that are selected for dynamic dispatch based on the argument type-signature\nanonymous function or \"method\"\nA Julia function without a name and without type-dispatch capabilities\nprimitive function\nA function implemented in C but exposed in Julia as a named function \"method\" (albeit without generic function dispatch capabilities, similar to a anonymous function)\nintrinsic function\nA low-level operation exposed as a function in Julia. These pseudo-functions implement operations on raw bits such as add and sign extend that cannot be expressed directly in any other way. Since they operate on bits directly, they must be compiled into a function and surrounded by a call to Core.Intrinsics.box(T, ...) to reassign type information to the value.","category":"page"},{"location":"devdocs/eval.html#dev-codegen-1","page":"Eval of Julia code","title":"JIT Code Generation","text":"","category":"section"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"Codegen is the process of turning a Julia AST into native machine code.","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"The JIT environment is initialized by an early call to jl_init_codegen in codegen.cpp.","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"On demand, a Julia method is converted into a native function by the function emit_function(jl_method_instance_t*).  (note, when using the MCJIT (in LLVM v3.4+), each function must be JIT into a new module.) This function recursively calls emit_expr() until the entire function has been emitted.","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"Much of the remaining bulk of this file is devoted to various manual optimizations of specific code patterns. For example, emit_known_call() knows how to inline many of the primitive functions (defined in builtins.c) for various combinations of argument types.","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"Other parts of codegen are handled by various helper files:","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"debuginfo.cpp\nHandles backtraces for JIT functions\nccall.cpp\nHandles the ccall and llvmcall FFI, along with various abi_*.cpp files\nintrinsics.cpp\nHandles the emission of various low-level intrinsic functions","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"sidebar: Bootstrapping\nThe process of creating a new system image is called \"bootstrapping\".The etymology of this word comes from the phrase \"pulling oneself up by the bootstraps\", and refers to the idea of starting from a very limited set of available functions and definitions and ending with the creation of a full-featured environment.","category":"page"},{"location":"devdocs/eval.html#dev-sysimg-1","page":"Eval of Julia code","title":"System Image","text":"","category":"section"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"The system image is a precompiled archive of a set of Julia files. The sys.ji file distributed with Julia is one such system image, generated by executing the file sysimg.jl, and serializing the resulting environment (including Types, Functions, Modules, and all other defined values) into a file. Therefore, it contains a frozen version of the Main, Core, and Base modules (and whatever else was in the environment at the end of bootstrapping). This serializer/deserializer is implemented by jl_save_system_image/jl_restore_system_image in staticdata.c.","category":"page"},{"location":"devdocs/eval.html#","page":"Eval of Julia code","title":"Eval of Julia code","text":"If there is no sysimg file (jl_options.image_file == NULL), this also implies that --build was given on the command line, so the final result should be a new sysimg file. During Julia initialization, minimal Core and Main modules are created. Then a file named boot.jl is evaluated from the current directory. Julia then evaluates any file given as a command line argument until it reaches the end. Finally, it saves the resulting environment to a \"sysimg\" file for use as a starting point for a future Julia run.","category":"page"},{"location":"devdocs/callconv.html#Calling-Conventions-1","page":"Calling Conventions","title":"Calling Conventions","text":"","category":"section"},{"location":"devdocs/callconv.html#","page":"Calling Conventions","title":"Calling Conventions","text":"Julia uses three calling conventions for four distinct purposes:","category":"page"},{"location":"devdocs/callconv.html#","page":"Calling Conventions","title":"Calling Conventions","text":"Name Prefix Purpose\nNative julia_ Speed via specialized signatures\nJL Call jlcall_ Wrapper for generic calls\nJL Call jl_ Builtins\nC ABI jlcapi_ Wrapper callable from C","category":"page"},{"location":"devdocs/callconv.html#Julia-Native-Calling-Convention-1","page":"Calling Conventions","title":"Julia Native Calling Convention","text":"","category":"section"},{"location":"devdocs/callconv.html#","page":"Calling Conventions","title":"Calling Conventions","text":"The native calling convention is designed for fast non-generic calls. It usually uses a specialized signature.","category":"page"},{"location":"devdocs/callconv.html#","page":"Calling Conventions","title":"Calling Conventions","text":"LLVM ghosts (zero-length types) are omitted.\nLLVM scalars and vectors are passed by value.\nLLVM aggregates (arrays and structs) are passed by reference.","category":"page"},{"location":"devdocs/callconv.html#","page":"Calling Conventions","title":"Calling Conventions","text":"A small return values is returned as LLVM return values. A large return values is returned via the \"structure return\" (sret) convention, where the caller provides a pointer to a return slot.","category":"page"},{"location":"devdocs/callconv.html#","page":"Calling Conventions","title":"Calling Conventions","text":"An argument or return values that is a homogeneous tuple is sometimes represented as an LLVM vector instead of an LLVM array.","category":"page"},{"location":"devdocs/callconv.html#JL-Call-Convention-1","page":"Calling Conventions","title":"JL Call Convention","text":"","category":"section"},{"location":"devdocs/callconv.html#","page":"Calling Conventions","title":"Calling Conventions","text":"The JL Call convention is for builtins and generic dispatch. Hand-written functions using this convention are declared via the macro JL_CALLABLE. The convention uses exactly 3 parameters:","category":"page"},{"location":"devdocs/callconv.html#","page":"Calling Conventions","title":"Calling Conventions","text":"F - Julia representation of function that is being applied\nargs - pointer to array of pointers to boxes\nnargs - length of the array","category":"page"},{"location":"devdocs/callconv.html#","page":"Calling Conventions","title":"Calling Conventions","text":"The return value is a pointer to a box.","category":"page"},{"location":"devdocs/callconv.html#C-ABI-1","page":"Calling Conventions","title":"C ABI","text":"","category":"section"},{"location":"devdocs/callconv.html#","page":"Calling Conventions","title":"Calling Conventions","text":"C ABI wrappers enable calling Julia from C. The wrapper calls a function using the native calling convention.","category":"page"},{"location":"devdocs/callconv.html#","page":"Calling Conventions","title":"Calling Conventions","text":"Tuples are always represented as C arrays.","category":"page"},{"location":"devdocs/compiler.html#High-level-Overview-of-the-Native-Code-Generation-Process-1","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"","category":"section"},{"location":"devdocs/compiler.html#Representation-of-Pointers-1","page":"High-level Overview of the Native-Code Generation Process","title":"Representation of Pointers","text":"","category":"section"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"When emitting code to an object file, pointers will be emitted as relocations.  The deserialization code will ensure any object that pointed to one of these constants gets recreated and contains the right runtime pointer.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"Otherwise, they will be emitted as literal constants.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"To emit one of these objects, call literal_pointer_val.  It'll handle tracking the Julia value and the LLVM global, ensuring they are valid both for the current runtime and after deserialization.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"When emitted into the object file, these globals are stored as references in a large gvals table. This allows the deserializer to reference them by index, and implement a custom manual mechanism similar to a Global Offset Table (GOT) to restore them.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"Function pointers are handled similarly.  They are stored as values in a large fvals table.  Like globals, this allows the deserializer to reference them by index.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"Note that extern functions are handled separately, with names, via the usual symbol resolution mechanism in the linker.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"Note too that ccall functions are also handled separately, via a manual GOT and Procedure Linkage Table (PLT).","category":"page"},{"location":"devdocs/compiler.html#Representation-of-Intermediate-Values-1","page":"High-level Overview of the Native-Code Generation Process","title":"Representation of Intermediate Values","text":"","category":"section"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"Values are passed around in a jl_cgval_t struct.  This represents an R-value, and includes enough information to determine how to assign or pass it somewhere.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"They are created via one of the helper constructors, usually: mark_julia_type (for immediate values) and mark_julia_slot (for pointers to values).","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"The function convert_julia_type can transform between any two types.  It returns an R-value with cgval.typ set to typ.  It'll cast the object to the requested representation, making heap boxes, allocating stack copies, and computing tagged unions as needed to change the representation.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"By contrast update_julia_type will change cgval.typ to typ, only if it can be done at zero-cost (i.e. without emitting any code).","category":"page"},{"location":"devdocs/compiler.html#Union-representation-1","page":"High-level Overview of the Native-Code Generation Process","title":"Union representation","text":"","category":"section"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"Inferred union types may be stack allocated via a tagged type representation.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"The primitive routines that need to be able to handle tagged unions are: - mark-type - load-local - store-local - isa - is - emittypeof - emitsizeof","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"boxed - unbox - specialized cc-ret","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"Everything else should be possible to handle in inference by using these primitives to implement union-splitting.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"The representation of the tagged-union is as a pair of < void* union, byte selector >. The selector is fixed-size as byte & 0x7f, and will union-tag the first 126 isbits. It records the one-based depth-first count into the type-union of the isbits objects inside. An index of zero indicates that the union* is actually a tagged heap-allocated jl_value_t*, and needs to be treated as normal for a boxed object rather than as a tagged union.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"The high bit of the selector (byte & 0x80) can be tested to determine if the void* is actually a heap-allocated (jl_value_t*) box, thus avoiding the cost of re-allocating a box, while maintaining the ability to efficiently handle union-splitting based on the low bits.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"It is guaranteed that byte & 0x7f is an exact test for the type, if the value can be represented by a tag – it will never be marked byte = 0x80. It is not necessary to also test the type-tag when testing isa.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"The union* memory region may be allocated at any size.  The only constraint is that it is big enough to contain the data currently specified by selector.  It might not be big enough to contain the union of all types that could be stored there according to the associated Union type field. Use appropriate care when copying.","category":"page"},{"location":"devdocs/compiler.html#Specialized-Calling-Convention-Signature-Representation-1","page":"High-level Overview of the Native-Code Generation Process","title":"Specialized Calling Convention Signature Representation","text":"","category":"section"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"A jl_returninfo_t object describes the calling convention details of any callable.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"If any of the arguments or return type of a method can be represented unboxed, and the method is not varargs, it'll be given an optimized calling convention signature based on its specTypes and rettype fields.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"The general principles are that:","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"Primitive types get passed in int/float registers.\nTuples of VecElement types get passed in vector registers.\nStructs get passed on the stack.\nReturn values are handle similarly to arguments, with a size-cutoff at which they will instead be returned via a hidden sret argument.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"The total logic for this is implemented by get_specsig_function and deserves_sret.","category":"page"},{"location":"devdocs/compiler.html#","page":"High-level Overview of the Native-Code Generation Process","title":"High-level Overview of the Native-Code Generation Process","text":"Additionally, if the return type is a union, it may be returned as a pair of values (a pointer and a tag).  If the union values can be stack-allocated, then sufficient space to store them will also be passed as a hidden first argument.  It is up to the callee whether the returned pointer will point to this space, a boxed object, or even other constant memory.","category":"page"},{"location":"devdocs/functions.html#Julia-Functions-1","page":"Julia Functions","title":"Julia Functions","text":"","category":"section"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"This document will explain how functions, method definitions, and method tables work.","category":"page"},{"location":"devdocs/functions.html#Method-Tables-1","page":"Julia Functions","title":"Method Tables","text":"","category":"section"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"Every function in Julia is a generic function. A generic function is conceptually a single function, but consists of many definitions, or methods. The methods of a generic function are stored in a method table. Method tables (type MethodTable) are associated with TypeNames. A TypeName describes a family of parameterized types. For example Complex{Float32} and Complex{Float64} share the same Complex type name object.","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"All objects in Julia are potentially callable, because every object has a type, which in turn has a TypeName.","category":"page"},{"location":"devdocs/functions.html#Function-calls-1","page":"Julia Functions","title":"Function calls","text":"","category":"section"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"Given the call f(x,y), the following steps are performed: first, the method table to use is accessed as typeof(f).name.mt. Second, an argument tuple type is formed, Tuple{typeof(f), typeof(x), typeof(y)}.  Note that the type of the function itself is the first element. This is because the type might have parameters, and so needs to take part in dispatch. This tuple type is looked up in the method table.","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"This dispatch process is performed by jl_apply_generic, which takes two arguments: a pointer to an array of the values f, x, and y, and the number of values (in this case 3).","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"Throughout the system, there are two kinds of APIs that handle functions and argument lists: those that accept the function and arguments separately, and those that accept a single argument structure.  In the first kind of API, the \"arguments\" part does not contain information about the function, since that is passed separately. In the second kind of API, the function is the first element of the argument structure.","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"For example, the following function for performing a call accepts just an args pointer, so the first element of the args array will be the function to call:","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"This entry point for the same functionality accepts the function separately, so the args array does not contain the function:","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);","category":"page"},{"location":"devdocs/functions.html#Adding-methods-1","page":"Julia Functions","title":"Adding methods","text":"","category":"section"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"Given the above dispatch process, conceptually all that is needed to add a new method is (1) a tuple type, and (2) code for the body of the method. jl_method_def implements this operation. jl_first_argument_datatype is called to extract the relevant method table from what would be the type of the first argument. This is much more complicated than the corresponding procedure during dispatch, since the argument tuple type might be abstract. For example, we can define:","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"(::Union{Foo{Int},Foo{Int8}})(x) = 0","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"which works since all possible matching methods would belong to the same method table.","category":"page"},{"location":"devdocs/functions.html#Creating-generic-functions-1","page":"Julia Functions","title":"Creating generic functions","text":"","category":"section"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"Since every object is callable, nothing special is needed to create a generic function. Therefore jl_new_generic_function simply creates a new singleton (0 size) subtype of Function and returns its instance. A function can have a mnemonic \"display name\" which is used in debug info and when printing objects. For example the name of Base.sin is sin. By convention, the name of the created type is the same as the function name, with a # prepended. So typeof(sin) is Base.#sin.","category":"page"},{"location":"devdocs/functions.html#Closures-1","page":"Julia Functions","title":"Closures","text":"","category":"section"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"A closure is simply a callable object with field names corresponding to captured variables. For example, the following code:","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"function adder(x)\n    return y->x+y\nend","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"is lowered to (roughly):","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"struct ##1{T}\n    x::T\nend\n\n(_::##1)(y) = _.x + y\n\nfunction adder(x)\n    return ##1(x)\nend","category":"page"},{"location":"devdocs/functions.html#Constructors-1","page":"Julia Functions","title":"Constructors","text":"","category":"section"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"A constructor call is just a call to a type. The method table for Type contains all constructor definitions. All subtypes of Type (Type, UnionAll, Union, and DataType)  currently share a method table via special arrangement.","category":"page"},{"location":"devdocs/functions.html#Builtins-1","page":"Julia Functions","title":"Builtins","text":"","category":"section"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"The \"builtin\" functions, defined in the Core module, are:","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"=== typeof sizeof <: isa typeassert throw tuple getfield setfield! fieldtype\nnfields isdefined arrayref arrayset arraysize applicable invoke apply_type _apply\n_expr svec","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"These are all singleton objects whose types are subtypes of Builtin, which is a subtype of Function. Their purpose is to expose entry points in the run time that use the \"jlcall\" calling convention:","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"jl_value_t *(jl_value_t*, jl_value_t**, uint32_t)","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"The method tables of builtins are empty. Instead, they have a single catch-all method cache entry (Tuple{Vararg{Any}}) whose jlcall fptr points to the correct function. This is kind of a hack but works reasonably well.","category":"page"},{"location":"devdocs/functions.html#Keyword-arguments-1","page":"Julia Functions","title":"Keyword arguments","text":"","category":"section"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"Keyword arguments work by associating a special, hidden function object with each method table that has definitions with keyword arguments. This function is called the \"keyword argument sorter\" or \"keyword sorter\", or \"kwsorter\", and is stored in the kwsorter field of MethodTable objects.  Every definition in the kwsorter function has the same arguments as some definition in the normal method table, except with a single NamedTuple argument prepended, which gives the names and values of passed keyword arguments. The kwsorter's job is to move keyword arguments into their canonical positions based on name, plus evaluate and substitute any needed default value expressions. The result is a normal positional argument list, which is then passed to yet another compiler-generated function.","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"The easiest way to understand the process is to look at how a keyword argument method definition is lowered. The code:","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"function circle(center, radius; color = black, fill::Bool = true, options...)\n    # draw\nend","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"actually produces three method definitions. The first is a function that accepts all arguments (including keyword arguments) as positional arguments, and includes the code for the method body.  It has an auto-generated name:","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"function #circle#1(color, fill::Bool, options, circle, center, radius)\n    # draw\nend","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"The second method is an ordinary definition for the original circle function, which handles the case where no keyword arguments are passed:","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"function circle(center, radius)\n    #circle#1(black, true, pairs(NamedTuple()), circle, center, radius)\nend","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"This simply dispatches to the first method, passing along default values. pairs is applied to the named tuple of rest arguments to provide key-value pair iteration.  Note that if the method doesn't accept rest keyword arguments then this argument is absent.","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"Finally there is the kwsorter definition:","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"function (::Core.kwftype(typeof(circle)))(kws, circle, center, radius)\n    if haskey(kws, :color)\n        color = kws.color\n    else\n        color = black\n    end\n    # etc.\n\n    # put remaining kwargs in `options`\n    options = structdiff(kws, NamedTuple{(:color, :fill)})\n\n    # if the method doesn't accept rest keywords, throw an error\n    # unless `options` is empty\n\n    #circle#1(color, fill, pairs(options), circle, center, radius)\nend","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"The function Core.kwftype(t) creates the field t.name.mt.kwsorter (if it hasn't been created yet), and returns the type of that function.","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"This design has the feature that call sites that don't use keyword arguments require no special handling; everything works as if they were not part of the language at all. Call sites that do use keyword arguments are dispatched directly to the called function's kwsorter. For example the call:","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"circle((0,0), 1.0, color = red; other...)","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"is lowered to:","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"kwfunc(circle)(merge((color = red,), other), circle, (0,0), 1.0)","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"kwfunc (also inCore) fetches the kwsorter for the called function. The keyword splatting operation (written as other...) calls the named tuple merge function. This function further unpacks each element of other, expecting each one to contain two values (a symbol and a value). Naturally, a more efficient implementation is available if all splatted arguments are named tuples. Notice that the original circle function is passed through, to handle closures.","category":"page"},{"location":"devdocs/functions.html#Compiler-efficiency-issues-1","page":"Julia Functions","title":"Compiler efficiency issues","text":"","category":"section"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"Generating a new type for every function has potentially serious consequences for compiler resource use when combined with Julia's \"specialize on all arguments by default\" design. Indeed, the initial implementation of this design suffered from much longer build and test times, higher memory use, and a system image nearly 2x larger than the baseline. In a naive implementation, the problem is bad enough to make the system nearly unusable. Several significant optimizations were needed to make the design practical.","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"The first issue is excessive specialization of functions for different values of function-valued arguments. Many functions simply \"pass through\" an argument to somewhere else, e.g. to another function or to a storage location. Such functions do not need to be specialized for every closure that might be passed in. Fortunately this case is easy to distinguish by simply considering whether a function calls one of its arguments (i.e. the argument appears in \"head position\" somewhere).  Performance-critical higher-order functions like map certainly call their argument function and so will still be specialized as expected. This optimization is implemented by recording which arguments are called during the analyze-variables pass in the front end. When cache_method sees an argument in the Function type hierarchy passed to a slot declared as Any or Function, it behaves as if the @nospecialize annotation were applied. This heuristic seems to be extremely effective in practice.","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"The next issue concerns the structure of method cache hash tables. Empirical studies show that the vast majority of dynamically-dispatched calls involve one or two arguments. In turn, many of these cases can be resolved by considering only the first argument. (Aside: proponents of single dispatch would not be surprised by this at all. However, this argument means \"multiple dispatch is easy to optimize in practice\", and that we should therefore use it, not \"we should use single dispatch\"!) So the method cache uses the type of the first argument as its primary key. Note, however, that this corresponds to the second element of the tuple type for a function call (the first element being the type of the function itself). Typically, type variation in head position is extremely low – indeed, the majority of functions belong to singleton types with no parameters.  However, this is not the case for constructors, where a single method table holds constructors for every type. Therefore the Type method table is special-cased to use the first tuple type element instead of the second.","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"The front end generates type declarations for all closures. Initially, this was implemented by generating normal type declarations. However, this produced an extremely large number of constructors, all of which were trivial (simply passing all arguments through to new). Since methods are partially ordered, inserting all of these methods is O(n^2), plus there are just too many of them to keep around. This was optimized by generating struct_type expressions directly (bypassing default constructor generation), and using new directly to create closure instances. Not the prettiest thing ever, but you do what you gotta do.","category":"page"},{"location":"devdocs/functions.html#","page":"Julia Functions","title":"Julia Functions","text":"The next problem was the @test macro, which generated a 0-argument closure for each test case.  This is not really necessary, since each test case is simply run once in place. Therefore, @test was modified to expand to a try-catch block that records the test result (true, false, or exception raised) and calls the test suite handler on it.","category":"page"},{"location":"devdocs/cartesian.html#Base.Cartesian-1","page":"Base.Cartesian","title":"Base.Cartesian","text":"","category":"section"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"The (non-exported) Cartesian module provides macros that facilitate writing multidimensional algorithms.  It is hoped that Cartesian will not, in the long term, be necessary; however, at present it is one of the few ways to write compact and performant multidimensional code.","category":"page"},{"location":"devdocs/cartesian.html#Principles-of-usage-1","page":"Base.Cartesian","title":"Principles of usage","text":"","category":"section"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"A simple example of usage is:","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"@nloops 3 i A begin\n    s += @nref 3 A i\nend","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"which generates the following code:","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"for i_3 = 1:size(A,3)\n    for i_2 = 1:size(A,2)\n        for i_1 = 1:size(A,1)\n            s += A[i_1,i_2,i_3]\n        end\n    end\nend","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"In general, Cartesian allows you to write generic code that contains repetitive elements, like the nested loops in this example.  Other applications include repeated expressions (e.g., loop unwinding) or creating function calls with variable numbers of arguments without using the \"splat\" construct (i...).","category":"page"},{"location":"devdocs/cartesian.html#Basic-syntax-1","page":"Base.Cartesian","title":"Basic syntax","text":"","category":"section"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"The (basic) syntax of @nloops is as follows:","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"The first argument must be an integer (not a variable) specifying the number of loops.\nThe second argument is the symbol-prefix used for the iterator variable. Here we used i, and variables i_1, i_2, i_3 were generated.\nThe third argument specifies the range for each iterator variable. If you use a variable (symbol)  here, it's taken as 1:size(A,dim). More flexibly, you can use the anonymous-function expression syntax described below.\nThe last argument is the body of the loop. Here, that's what appears between the begin...end.","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"There are some additional features of @nloops described in the reference section.","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"@nref follows a similar pattern, generating A[i_1,i_2,i_3] from @nref 3 A i. The general practice is to read from left to right, which is why @nloops is @nloops 3 i A expr (as in for i_2 = 1:size(A,2), where i_2 is to the left and the range is to the right) whereas @nref is @nref 3 A i (as in A[i_1,i_2,i_3], where the array comes first).","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"If you're developing code with Cartesian, you may find that debugging is easier when you examine the generated code, using @macroexpand:","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"DocTestSetup = quote\n    import Base.Cartesian: @nref\nend","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"julia> @macroexpand @nref 2 A i\n:(A[i_1, i_2])","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"DocTestSetup = nothing","category":"page"},{"location":"devdocs/cartesian.html#Supplying-the-number-of-expressions-1","page":"Base.Cartesian","title":"Supplying the number of expressions","text":"","category":"section"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"The first argument to both of these macros is the number of expressions, which must be an integer.  When you're writing a function that you intend to work in multiple dimensions, this may not be something you want to hard-code. If you're writing code that you need to work with older Julia versions, currently you should use the @ngenerate macro described in an older version of this documentation.","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"Starting in Julia 0.4-pre, the recommended approach is to use a @generated function.  Here's an example:","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"@generated function mysum(A::Array{T,N}) where {T,N}\n    quote\n        s = zero(T)\n        @nloops $N i A begin\n            s += @nref $N A i\n        end\n        s\n    end\nend","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"Naturally, you can also prepare expressions or perform calculations before the quote block.","category":"page"},{"location":"devdocs/cartesian.html#Anonymous-function-expressions-as-macro-arguments-1","page":"Base.Cartesian","title":"Anonymous-function expressions as macro arguments","text":"","category":"section"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"Perhaps the single most powerful feature in Cartesian is the ability to supply anonymous-function expressions that get evaluated at parsing time. Let's consider a simple example:","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"@nexprs 2 j->(i_j = 1)","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"@nexprs generates n expressions that follow a pattern. This code would generate the following statements:","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"i_1 = 1\ni_2 = 1","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"In each generated statement, an \"isolated\" j (the variable of the anonymous function) gets replaced by values in the range 1:2. Generally speaking, Cartesian employs a LaTeX-like syntax.  This allows you to do math on the index j.  Here's an example computing the strides of an array:","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"s_1 = 1\n@nexprs 3 j->(s_{j+1} = s_j * size(A, j))","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"would generate expressions","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"s_1 = 1\ns_2 = s_1 * size(A, 1)\ns_3 = s_2 * size(A, 2)\ns_4 = s_3 * size(A, 3)","category":"page"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"Anonymous-function expressions have many uses in practice.","category":"page"},{"location":"devdocs/cartesian.html#dev-cartesian-reference-1","page":"Base.Cartesian","title":"Macro reference","text":"","category":"section"},{"location":"devdocs/cartesian.html#","page":"Base.Cartesian","title":"Base.Cartesian","text":"Base.Cartesian.@nloops\nBase.Cartesian.@nref\nBase.Cartesian.@nextract\nBase.Cartesian.@nexprs\nBase.Cartesian.@ncall\nBase.Cartesian.@ntuple\nBase.Cartesian.@nall\nBase.Cartesian.@nany\nBase.Cartesian.@nif","category":"page"},{"location":"devdocs/cartesian.html#Base.Cartesian.@nloops","page":"Base.Cartesian","title":"Base.Cartesian.@nloops","text":"@nloops N itersym rangeexpr bodyexpr\n@nloops N itersym rangeexpr preexpr bodyexpr\n@nloops N itersym rangeexpr preexpr postexpr bodyexpr\n\nGenerate N nested loops, using itersym as the prefix for the iteration variables. rangeexpr may be an anonymous-function expression, or a simple symbol var in which case the range is axes(var, d) for dimension d.\n\nOptionally, you can provide \"pre\" and \"post\" expressions. These get executed first and last, respectively, in the body of each loop. For example:\n\n@nloops 2 i A d -> j_d = min(i_d, 5) begin\n    s += @nref 2 A j\nend\n\nwould generate:\n\nfor i_2 = axes(A, 2)\n    j_2 = min(i_2, 5)\n    for i_1 = axes(A, 1)\n        j_1 = min(i_1, 5)\n        s += A[j_1, j_2]\n    end\nend\n\nIf you want just a post-expression, supply nothing for the pre-expression. Using parentheses and semicolons, you can supply multi-statement expressions.\n\n\n\n\n\n","category":"macro"},{"location":"devdocs/cartesian.html#Base.Cartesian.@nref","page":"Base.Cartesian","title":"Base.Cartesian.@nref","text":"@nref N A indexexpr\n\nGenerate expressions like A[i_1, i_2, ...]. indexexpr can either be an iteration-symbol prefix, or an anonymous-function expression.\n\nExamples\n\njulia> @macroexpand Base.Cartesian.@nref 3 A i\n:(A[i_1, i_2, i_3])\n\n\n\n\n\n","category":"macro"},{"location":"devdocs/cartesian.html#Base.Cartesian.@nextract","page":"Base.Cartesian","title":"Base.Cartesian.@nextract","text":"@nextract N esym isym\n\nGenerate N variables esym_1, esym_2, ..., esym_N to extract values from isym. isym can be either a Symbol or anonymous-function expression.\n\n@nextract 2 x y would generate\n\nx_1 = y[1]\nx_2 = y[2]\n\nwhile @nextract 3 x d->y[2d-1] yields\n\nx_1 = y[1]\nx_2 = y[3]\nx_3 = y[5]\n\n\n\n\n\n","category":"macro"},{"location":"devdocs/cartesian.html#Base.Cartesian.@nexprs","page":"Base.Cartesian","title":"Base.Cartesian.@nexprs","text":"@nexprs N expr\n\nGenerate N expressions. expr should be an anonymous-function expression.\n\nExamples\n\njulia> @macroexpand Base.Cartesian.@nexprs 4 i -> y[i] = A[i+j]\nquote\n    y[1] = A[1 + j]\n    y[2] = A[2 + j]\n    y[3] = A[3 + j]\n    y[4] = A[4 + j]\nend\n\n\n\n\n\n","category":"macro"},{"location":"devdocs/cartesian.html#Base.Cartesian.@ncall","page":"Base.Cartesian","title":"Base.Cartesian.@ncall","text":"@ncall N f sym...\n\nGenerate a function call expression. sym represents any number of function arguments, the last of which may be an anonymous-function expression and is expanded into N arguments.\n\nFor example, @ncall 3 func a generates\n\nfunc(a_1, a_2, a_3)\n\nwhile @ncall 2 func a b i->c[i] yields\n\nfunc(a, b, c[1], c[2])\n\n\n\n\n\n","category":"macro"},{"location":"devdocs/cartesian.html#Base.Cartesian.@ntuple","page":"Base.Cartesian","title":"Base.Cartesian.@ntuple","text":"@ntuple N expr\n\nGenerates an N-tuple. @ntuple 2 i would generate (i_1, i_2), and @ntuple 2 k->k+1 would generate (2,3).\n\n\n\n\n\n","category":"macro"},{"location":"devdocs/cartesian.html#Base.Cartesian.@nall","page":"Base.Cartesian","title":"Base.Cartesian.@nall","text":"@nall N expr\n\nCheck whether all of the expressions generated by the anonymous-function expression expr evaluate to true.\n\n@nall 3 d->(i_d > 1) would generate the expression (i_1 > 1 && i_2 > 1 && i_3 > 1). This can be convenient for bounds-checking.\n\n\n\n\n\n","category":"macro"},{"location":"devdocs/cartesian.html#Base.Cartesian.@nany","page":"Base.Cartesian","title":"Base.Cartesian.@nany","text":"@nany N expr\n\nCheck whether any of the expressions generated by the anonymous-function expression expr evaluate to true.\n\n@nany 3 d->(i_d > 1) would generate the expression (i_1 > 1 || i_2 > 1 || i_3 > 1).\n\n\n\n\n\n","category":"macro"},{"location":"devdocs/cartesian.html#Base.Cartesian.@nif","page":"Base.Cartesian","title":"Base.Cartesian.@nif","text":"@nif N conditionexpr expr\n@nif N conditionexpr expr elseexpr\n\nGenerates a sequence of if ... elseif ... else ... end statements. For example:\n\n@nif 3 d->(i_d >= size(A,d)) d->(error(\"Dimension \", d, \" too big\")) d->println(\"All OK\")\n\nwould generate:\n\nif i_1 > size(A, 1)\n    error(\"Dimension \", 1, \" too big\")\nelseif i_2 > size(A, 2)\n    error(\"Dimension \", 2, \" too big\")\nelse\n    println(\"All OK\")\nend\n\n\n\n\n\n","category":"macro"},{"location":"devdocs/meta.html#Talking-to-the-compiler-(the-:meta-mechanism)-1","page":"Talking to the compiler (the :meta mechanism)","title":"Talking to the compiler (the :meta mechanism)","text":"","category":"section"},{"location":"devdocs/meta.html#","page":"Talking to the compiler (the :meta mechanism)","title":"Talking to the compiler (the :meta mechanism)","text":"In some circumstances, one might wish to provide hints or instructions that a given block of code has special properties: you might always want to inline it, or you might want to turn on special compiler optimization passes.  Starting with version 0.4, Julia has a convention that these instructions can be placed inside a :meta expression, which is typically (but not necessarily) the first expression in the body of a function.","category":"page"},{"location":"devdocs/meta.html#","page":"Talking to the compiler (the :meta mechanism)","title":"Talking to the compiler (the :meta mechanism)","text":":meta expressions are created with macros. As an example, consider the implementation of the @inline macro:","category":"page"},{"location":"devdocs/meta.html#","page":"Talking to the compiler (the :meta mechanism)","title":"Talking to the compiler (the :meta mechanism)","text":"macro inline(ex)\n    esc(isa(ex, Expr) ? pushmeta!(ex, :inline) : ex)\nend","category":"page"},{"location":"devdocs/meta.html#","page":"Talking to the compiler (the :meta mechanism)","title":"Talking to the compiler (the :meta mechanism)","text":"Here, ex is expected to be an expression defining a function. A statement like this:","category":"page"},{"location":"devdocs/meta.html#","page":"Talking to the compiler (the :meta mechanism)","title":"Talking to the compiler (the :meta mechanism)","text":"@inline function myfunction(x)\n    x*(x+3)\nend","category":"page"},{"location":"devdocs/meta.html#","page":"Talking to the compiler (the :meta mechanism)","title":"Talking to the compiler (the :meta mechanism)","text":"gets turned into an expression like this:","category":"page"},{"location":"devdocs/meta.html#","page":"Talking to the compiler (the :meta mechanism)","title":"Talking to the compiler (the :meta mechanism)","text":"quote\n    function myfunction(x)\n        Expr(:meta, :inline)\n        x*(x+3)\n    end\nend","category":"page"},{"location":"devdocs/meta.html#","page":"Talking to the compiler (the :meta mechanism)","title":"Talking to the compiler (the :meta mechanism)","text":"Base.pushmeta!(ex, :symbol, args...) appends :symbol to the end of the :meta expression, creating a new :meta expression if necessary. If args is specified, a nested expression containing :symbol and these arguments is appended instead, which can be used to specify additional information.","category":"page"},{"location":"devdocs/meta.html#","page":"Talking to the compiler (the :meta mechanism)","title":"Talking to the compiler (the :meta mechanism)","text":"To use the metadata, you have to parse these :meta expressions. If your implementation can be performed within Julia, Base.popmeta! is very handy: Base.popmeta!(body, :symbol) will scan a function body expression (one without the function signature) for the first :meta expression containing :symbol, extract any arguments, and return a tuple (found::Bool, args::Array{Any}).  If the metadata did not have any arguments, or :symbol was not found, the args array will be empty.","category":"page"},{"location":"devdocs/meta.html#","page":"Talking to the compiler (the :meta mechanism)","title":"Talking to the compiler (the :meta mechanism)","text":"Not yet provided is a convenient infrastructure for parsing :meta expressions from C++.","category":"page"},{"location":"devdocs/subarrays.html#SubArrays-1","page":"SubArrays","title":"SubArrays","text":"","category":"section"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"Julia's SubArray type is a container encoding a \"view\" of a parent AbstractArray.  This page documents some of the design principles and implementation of SubArrays.","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"One of the major design goals is to ensure high performance for views of both IndexLinear and IndexCartesian arrays. Furthermore, views of IndexLinear arrays should themselves be IndexLinear to the extent that it is possible.","category":"page"},{"location":"devdocs/subarrays.html#Index-replacement-1","page":"SubArrays","title":"Index replacement","text":"","category":"section"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"Consider making 2d slices of a 3d array:","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"DocTestSetup = :(import Random; Random.seed!(1234))","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"julia> A = rand(2,3,4);\n\njulia> S1 = view(A, :, 1, 2:3)\n2×2 view(::Array{Float64,3}, :, 1, 2:3) with eltype Float64:\n 0.200586  0.066423\n 0.298614  0.956753\n\njulia> S2 = view(A, 1, :, 2:3)\n3×2 view(::Array{Float64,3}, 1, :, 2:3) with eltype Float64:\n 0.200586  0.066423\n 0.246837  0.646691\n 0.648882  0.276021","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"DocTestSetup = nothing","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"view drops \"singleton\" dimensions (ones that are specified by an Int), so both S1 and S2 are two-dimensional SubArrays. Consequently, the natural way to index these is with S1[i,j].  To extract the value from the parent array A, the natural approach is to replace S1[i,j] with A[i,1,(2:3)[j]] and S2[i,j] with A[1,i,(2:3)[j]].","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"The key feature of the design of SubArrays is that this index replacement can be performed without any runtime overhead.","category":"page"},{"location":"devdocs/subarrays.html#SubArray-design-1","page":"SubArrays","title":"SubArray design","text":"","category":"section"},{"location":"devdocs/subarrays.html#Type-parameters-and-fields-1","page":"SubArrays","title":"Type parameters and fields","text":"","category":"section"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"The strategy adopted is first and foremost expressed in the definition of the type:","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"struct SubArray{T,N,P,I,L} <: AbstractArray{T,N}\n    parent::P\n    indices::I\n    offset1::Int       # for linear indexing and pointer, only valid when L==true\n    stride1::Int       # used only for linear indexing\n    ...\nend","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"SubArray has 5 type parameters.  The first two are the standard element type and dimensionality.  The next is the type of the parent AbstractArray.  The most heavily-used is the fourth parameter, a Tuple of the types of the indices for each dimension. The final one, L, is only provided as a convenience for dispatch; it's a boolean that represents whether the index types support fast linear indexing. More on that later.","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"If in our example above A is a Array{Float64, 3}, our S1 case above would be a SubArray{Float64,2,Array{Float64,3},Tuple{Base.Slice{Base.OneTo{Int64}},Int64,UnitRange{Int64}},false}. Note in particular the tuple parameter, which stores the types of the indices used to create S1. Likewise,","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"julia> S1.indices\n(Base.Slice(Base.OneTo(2)), 1, 2:3)","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"Storing these values allows index replacement, and having the types encoded as parameters allows one to dispatch to efficient algorithms.","category":"page"},{"location":"devdocs/subarrays.html#Index-translation-1","page":"SubArrays","title":"Index translation","text":"","category":"section"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"Performing index translation requires that you do different things for different concrete SubArray types.  For example, for S1, one needs to apply the i,j indices to the first and third dimensions of the parent array, whereas for S2 one needs to apply them to the second and third. The simplest approach to indexing would be to do the type-analysis at runtime:","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"parentindices = Vector{Any}()\nfor thisindex in S.indices\n    ...\n    if isa(thisindex, Int)\n        # Don't consume one of the input indices\n        push!(parentindices, thisindex)\n    elseif isa(thisindex, AbstractVector)\n        # Consume an input index\n        push!(parentindices, thisindex[inputindex[j]])\n        j += 1\n    elseif isa(thisindex, AbstractMatrix)\n        # Consume two input indices\n        push!(parentindices, thisindex[inputindex[j], inputindex[j+1]])\n        j += 2\n    elseif ...\nend\nS.parent[parentindices...]","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"Unfortunately, this would be disastrous in terms of performance: each element access would allocate memory, and involves the running of a lot of poorly-typed code.","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"The better approach is to dispatch to specific methods to handle each type of stored index. That's what reindex does: it dispatches on the type of the first stored index and consumes the appropriate number of input indices, and then it recurses on the remaining indices. In the case of S1, this expands to","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"Base.reindex(S1, S1.indices, (i, j)) == (i, S1.indices[2], S1.indices[3][j])","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"for any pair of indices (i,j) (except CartesianIndexs and arrays thereof, see below).","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"This is the core of a SubArray; indexing methods depend upon reindex to do this index translation.  Sometimes, though, we can avoid the indirection and make it even faster.","category":"page"},{"location":"devdocs/subarrays.html#Linear-indexing-1","page":"SubArrays","title":"Linear indexing","text":"","category":"section"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"Linear indexing can be implemented efficiently when the entire array has a single stride that separates successive elements, starting from some offset. This means that we can pre-compute these values and represent linear indexing simply as an addition and multiplication, avoiding the indirection of reindex and (more importantly) the slow computation of the cartesian coordinates entirely.","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"For SubArray types, the availability of efficient linear indexing is based purely on the types of the indices, and does not depend on values like the size of the parent array. You can ask whether a given set of indices supports fast linear indexing with the internal Base.viewindexing function:","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"julia> Base.viewindexing(S1.indices)\nIndexCartesian()\n\njulia> Base.viewindexing(S2.indices)\nIndexLinear()","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"This is computed during construction of the SubArray and stored in the L type parameter as a boolean that encodes fast linear indexing support. While not strictly necessary, it means that we can define dispatch directly on SubArray{T,N,A,I,true} without any intermediaries.","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"Since this computation doesn't depend on runtime values, it can miss some cases in which the stride happens to be uniform:","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"julia> A = reshape(1:4*2, 4, 2)\n4×2 reshape(::UnitRange{Int64}, 4, 2) with eltype Int64:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> diff(A[2:2:4,:][:])\n3-element Array{Int64,1}:\n 2\n 2\n 2","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"A view constructed as view(A, 2:2:4, :) happens to have uniform stride, and therefore linear indexing indeed could be performed efficiently. However, success in this case depends on the size of the array: if the first dimension instead were odd,","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"julia> A = reshape(1:5*2, 5, 2)\n5×2 reshape(::UnitRange{Int64}, 5, 2) with eltype Int64:\n 1   6\n 2   7\n 3   8\n 4   9\n 5  10\n\njulia> diff(A[2:2:4,:][:])\n3-element Array{Int64,1}:\n 2\n 3\n 2","category":"page"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"then A[2:2:4,:] does not have uniform stride, so we cannot guarantee efficient linear indexing.  Since we have to base this decision based purely on types encoded in the parameters of the SubArray, S = view(A, 2:2:4, :) cannot implement efficient linear indexing.","category":"page"},{"location":"devdocs/subarrays.html#A-few-details-1","page":"SubArrays","title":"A few details","text":"","category":"section"},{"location":"devdocs/subarrays.html#","page":"SubArrays","title":"SubArrays","text":"Note that the Base.reindex function is agnostic to the types of the input indices; it simply determines how and where the stored indices should be reindexed. It not only supports integer indices, but it supports non-scalar indexing, too. This means that views of views don't need two levels of indirection; they can simply re-compute the indices into the original parent array!\nHopefully by now it's fairly clear that supporting slices means that the dimensionality, given by the parameter N, is not necessarily equal to the dimensionality of the parent array or the length of the indices tuple.  Neither do user-supplied indices necessarily line up with entries in the indices tuple (e.g., the second user-supplied index might correspond to the third dimension of the parent array, and the third element in the indices tuple).\nWhat might be less obvious is that the dimensionality of the stored parent array must be equal to the number of effective indices in the indices tuple. Some examples:\nA = reshape(1:35, 5, 7) # A 2d parent Array\nS = view(A, 2:7)         # A 1d view created by linear indexing\nS = view(A, :, :, 1:1)   # Appending extra indices is supported\nNaively, you'd think you could just set S.parent = A and S.indices = (:,:,1:1), but supporting this dramatically complicates the reindexing process, especially for views of views. Not only do you need to dispatch on the types of the stored indices, but you need to examine whether a given index is the final one and \"merge\" any remaining stored indices together. This is not an easy task, and even worse: it's slow since it implicitly depends upon linear indexing.\nFortunately, this is precisely the computation that ReshapedArray performs, and it does so linearly if possible. Consequently, view ensures that the parent array is the appropriate dimensionality for the given indices by reshaping it if needed. The inner SubArray constructor ensures that this invariant is satisfied.\nCartesianIndex and arrays thereof throw a nasty wrench into the reindex scheme. Recall that reindex simply dispatches on the type of the stored indices in order to determine how many passed indices should be used and where they should go. But with CartesianIndex, there's no longer a one-to-one correspondence between the number of passed arguments and the number of dimensions that they index into. If we return to the above example of Base.reindex(S1, S1.indices, (i, j)), you can see that the expansion is incorrect for i, j = CartesianIndex(), CartesianIndex(2,1). It should skip the CartesianIndex() entirely and return:\n(CartesianIndex(2,1)[1], S1.indices[2], S1.indices[3][CartesianIndex(2,1)[2]])\nInstead, though, we get:\n(CartesianIndex(), S1.indices[2], S1.indices[3][CartesianIndex(2,1)])\nDoing this correctly would require combined dispatch on both the stored and passed indices across all combinations of dimensionalities in an intractable manner. As such, reindex must never be called with CartesianIndex indices. Fortunately, the scalar case is easily handled by first flattening the CartesianIndex arguments to plain integers. Arrays of CartesianIndex, however, cannot be split apart into orthogonal pieces so easily. Before attempting to use reindex, view must ensure that there are no arrays of CartesianIndex in the argument list. If there are, it can simply \"punt\" by avoiding the reindex calculation entirely, constructing a nested SubArray with two levels of indirection instead.","category":"page"},{"location":"devdocs/isbitsunionarrays.html#isbits-Union-Optimizations-1","page":"isbits Union Optimizations","title":"isbits Union Optimizations","text":"","category":"section"},{"location":"devdocs/isbitsunionarrays.html#","page":"isbits Union Optimizations","title":"isbits Union Optimizations","text":"In Julia, the Array type holds both \"bits\" values as well as heap-allocated \"boxed\" values. The distinction is whether the value itself is stored inline (in the direct allocated memory of the array), or if the memory of the array is simply a collection of pointers to objects allocated elsewhere. In terms of performance, accessing values inline is clearly an advantage over having to follow a pointer to the actual value. The definition of \"isbits\" generally means any Julia type with a fixed, determinate size, meaning no \"pointer\" fields, see ?isbitstype.","category":"page"},{"location":"devdocs/isbitsunionarrays.html#","page":"isbits Union Optimizations","title":"isbits Union Optimizations","text":"Julia also supports Union types, quite literally the union of a set of types. Custom Union type definitions can be extremely handy for applications wishing to \"cut across\" the nominal type system (i.e. explicit subtype relationships) and define methods or functionality on these, otherwise unrelated, set of types. A compiler challenge, however, is in determining how to treat these Union types. The naive approach (and indeed, what Julia itself did pre-0.7), is to simply make a \"box\" and then a pointer in the box to the actual value, similar to the previously mentioned \"boxed\" values. This is unfortunate, however, because of the number of small, primitive \"bits\" types (think UInt8, Int32, Float64, etc.) that would easily fit themselves inline in this \"box\" without needing any indirection for value access. There are two main ways Julia can take advantage of this optimization as of 0.7: isbits Union fields in types, and isbits Union Arrays.","category":"page"},{"location":"devdocs/isbitsunionarrays.html#isbits-Union-Structs-1","page":"isbits Union Optimizations","title":"isbits Union Structs","text":"","category":"section"},{"location":"devdocs/isbitsunionarrays.html#","page":"isbits Union Optimizations","title":"isbits Union Optimizations","text":"Julia now includes an optimization wherein \"isbits Union\" fields in types (mutable struct, struct, etc.) will be stored inline. This is accomplished by determining the \"inline size\" of the Union type (e.g. Union{UInt8, Int16} will have a size of two bytes, which represents the size needed of the largest Union type Int16), and in addition, allocating an extra \"type tag byte\" (UInt8), whose value signals the type of the actual value stored inline of the \"Union bytes\". The type tag byte value is the index of the actual value's type in the Union type's order of types. For example, a type tag value of 0x02 for a field with type Union{Nothing, UInt8, Int16} would indicate that an Int16 value is stored in the 2 bytes of the field in the structure's memory; a 0x01 value would indicate that a UInt8 value was stored in the first 1 byte of the 2 bytes of the field's memory. Lastly, a value of 0x00 signals that the nothing value will be returned for this field, even though, as a singleton type with a single type instance, it technically has a size of 0. The type tag byte for a type's Union field is stored directly after the field's computed Union memory.","category":"page"},{"location":"devdocs/isbitsunionarrays.html#isbits-Union-Arrays-1","page":"isbits Union Optimizations","title":"isbits Union Arrays","text":"","category":"section"},{"location":"devdocs/isbitsunionarrays.html#","page":"isbits Union Optimizations","title":"isbits Union Optimizations","text":"Julia can now also store \"isbits Union\" values inline in an Array, as opposed to requiring an indirection box. The optimization is accomplished by storing an extra \"type tag array\" of bytes, one byte per array element, alongside the bytes of the actual array data. This type tag array serves the same function as the type field case: its value signals the type of the actual stored Union value in the array. In terms of layout, a Julia Array can include extra \"buffer\" space before and after its actual data values, which are tracked in the a->offset and a->maxsize fields of the jl_array_t* type. The \"type tag array\" is treated exactly as another jl_array_t*, but which shares the same a->offset, a->maxsize, and a->len fields. So the formula to access an isbits Union Array's type tag bytes is a->data + (a->maxsize - a->offset) * a->elsize + a->offset; i.e. the Array's a->data pointer is already shifted by a->offset, so correcting for that, we follow the data all the way to the max of what it can hold a->maxsize, then adjust by a->ofset more bytes to account for any present \"front buffering\" the array might be doing. This layout in particular allows for very efficient resizing operations as the type tag data only ever has to move when the actual array's data has to move.","category":"page"},{"location":"devdocs/sysimg.html#システムイメージのビルド-1","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"","category":"section"},{"location":"devdocs/sysimg.html#Building-the-Julia-system-image-1","page":"システムイメージのビルド","title":"Julia のシステムイメージをビルドする","text":"","category":"section"},{"location":"devdocs/sysimg.html#","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"Julia には、sys.ji という名前の、 Base モジュールの内容を含む事前解析済みのシステム イメージが付属しています。 このファイルは、起動時間を大幅に改善できるように、できるだけ多くのプラットフォーム上で、sys.{so,dll,dylib}という共有ライブラリにもプリコンパイルされます。 プリコンパイル済みシステムイメージファイル が Julia に付属されないようなシステムでであれば、Julia の DATAROOTDIR/julia/base フォルダーに同梱されているソース・ファイルからシステムイメージファイルを生成できます。","category":"page"},{"location":"devdocs/sysimg.html#","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"システムイメージの自前ビルドは、複数の理由で役立ちます。 ユーザーは以下を実行できます:","category":"page"},{"location":"devdocs/sysimg.html#","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"Julia にシステムイメージが付属していないようなプラットフォーム上で プリコンパイル済みの共有ライブラリ システム イメージをビルドし、起動時間を短縮します。\nBaseを変更し、システムイメージを再ビルドし、次回 Julia を起動する時に新しいBaseを使用します。\nパッケージのinclude 処理を行う userimg.jl をシステムイメージに含めることで、スタートアップ環境にパッケージが埋め込まれたシステム イメージを作成します。","category":"page"},{"location":"devdocs/sysimg.html#","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"PackageCompiler.jl package には、このプロセスを自動化するための便利なラッパー関数が含まれています。","category":"page"},{"location":"devdocs/sysimg.html#複数のマイクロアーキテクチャ向けに最適化されたシステムイメージ-1","page":"システムイメージのビルド","title":"複数のマイクロアーキテクチャ向けに最適化されたシステムイメージ","text":"","category":"section"},{"location":"devdocs/sysimg.html#","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"システム イメージは、同じ命令セット アーキテクチャ (ISA) の下で複数の CPU マイクロアーキテクチャーに対して同時にコンパイルできます。異なる ISA 拡張機能やその他のマイクロアーキテクチャ機能を利用するために、共有関数には最小限のディスパッチポイントを挿入することで、複数バージョンの関数を作成できます。最高のパフォーマンスを提供するバージョンは、利用可能な CPU 機能に基づいて実行時に自動的に選択されます。","category":"page"},{"location":"devdocs/sysimg.html#複数のシステム・イメージ・ターゲットを指定する-1","page":"システムイメージのビルド","title":"複数のシステム・イメージ・ターゲットを指定する","text":"","category":"section"},{"location":"devdocs/sysimg.html#","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"マルチマイクロアーキテクチャーのシステム・イメージは、システム・イメージのコンパイル中に複数のターゲットを渡すことによって使用することができます。複数ターゲットの指定は、JULIA_CPU_TARGET make オプションをつかってもできますし、コンパイルコマンドを手動で実行する場合は-C コマンドラインオプションを使用することもできます。 オプション文字列内で複数のターゲットは ; で区切ります。 各ターゲットの構文は、CPU 名の後に , で区切られた複数の機能を記します。 LLVM でサポートされているすべての機能がサポートされており、- プレフィックスを使用して機能を無効にすることができます。 (+ 接頭部も許可され、LLVM 構文と一致するように無視されます)。 さらに、関数の複製動作を制御するいくつかの特別な機能がサポートされています。","category":"page"},{"location":"devdocs/sysimg.html#","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"clone_all\nデフォルトでは、マイクロアーキテクチャ機能から最も恩恵を受ける可能性が最も高い関数のみクローンされます。  ターゲットに clone_all が指定されている場合は、全ての 関数がターゲットに対して複製されます。  負形式 -clone_all を使用すると、全関数のクローンから、組み込みのヒューリスティック操作を抑制することができます。\nbase(<n>)\nここで、<n> は負でない数値のプレースホルダを示します (たとえば、base(0)、base(1))など。  部分的に複製された(つまりcloneallではない)ターゲットで、ある関数が複数されていなければ、基本ターゲットの関数が使用されます。デフォルトで基本ターゲットは、0番 (最初に指定されたターゲット)です。base(<n>)オプションでn番目のターゲット (0 から始まる) を基本ターゲットとして指定することができます。  基本ターゲットに指定できるのは、0または別のターゲットの中でもcloneall`指定がされているものでなければいけません.。そうでないと、エラーが発生します。\nopt_size\n実行時間性能への影響が重大でない限りは、関数のサイズ最適化が行われます。  これはGCCやClang でいうところの -Os オプションに相当します。\nmin_size\n実行時間性能に重大な影響があったとしても、強制的にサイズ最適化をします。  Clang オプションでいうところの -Oz に相当します。","category":"page"},{"location":"devdocs/sysimg.html#","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"例として示しますが、本ページ執筆時点で julialang.orgからダウンロード可能な公式のx86_64 Julia バイナリの作成には、次のオプション文字列が使用されています:","category":"page"},{"location":"devdocs/sysimg.html#","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"generic;sandybridge,-xsaveopt,clone_all;haswell,-rdrnd,base(1)","category":"page"},{"location":"devdocs/sysimg.html#","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"これにより、3 つの別個のターゲットを持つシステム イメージが作成されます。一つは、一般的な x86_64 プロセッサ、もう一つは sandybridge ISA (明示的に xsaveopt を除いています) を持つプロセッサで、すべての関数を明示的にクローン化するオプションを指定しました。最後は haswell ISA をターゲットにプロセッサで、 sandybridge sysimg バージョンに基づいており、rdrnd を除外しました。Julia 実装が生成された sysimg を読み込むと、ホスト プロセッサが CPU 機能フラグとの一致をチェックし、可能な限り最高の ISA レベルを有効にします。 基本レベル (generic) にはcx16 命令が必要です。 あるいは、互換性を高めるためにターゲット generic,-cx16 で sysimg を生成することもできますが、一部のコードではパフォーマンスと安定性の問題が発生する可能性があることに注意してください。","category":"page"},{"location":"devdocs/sysimg.html#実装概要-1","page":"システムイメージのビルド","title":"実装概要","text":"","category":"section"},{"location":"devdocs/sysimg.html#","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"これは、実装に関連するさまざまな部分の簡単な概要です。 実装の詳細については、各コンポーネントのコード コメントを参照してください。","category":"page"},{"location":"devdocs/sysimg.html#","page":"システムイメージのビルド","title":"システムイメージのビルド","text":"システムイメージのコンパイル\n解析とクローン作成の決定は src/processor* で行われます。  現在、サポートしているのは、ループ、simd命令、または他の数学演算(例えば、fastmath, fma、muladd)などの存在に基づく関数のclone 機能です。  この情報は、実際のクローン作成を行う src/llvm-multiversioning.cpp に渡されます。  この情報の受け渡しで、クローニングとディスパッチスロットの挿入に加えて (この方法については、MultiVersioning::runOnModuleのコメントを参照してください)、 メタデータの生成も行われるため、ランタイムは、システム イメージがロード・初期化することができます。  メタデータの詳細な説明は src/processor.h をみると分かります。\nシステムイメージの読み込み\nシステム イメージの読み込みと初期化はsrc/processor* で、システム イメージの生成中に保存されたメタデータで解析することで行われます。  ホスト機能の検出と選択の決定はsrc/processor_*.cpp で行われます。ファイルは、ISA によって異なります。  ターゲットの選択では、まずは、完全に一致する CPU 名、より大きいベクター レジスタサイズ、そしてより多いフィーチャーの数のものが優先されます。  このプロセスの概要はsrc/processor.cppにあります。","category":"page"},{"location":"devdocs/llvm.html#Working-with-LLVM-1","page":"Working with LLVM","title":"Working with LLVM","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"This is not a replacement for the LLVM documentation, but a collection of tips for working on LLVM for Julia.","category":"page"},{"location":"devdocs/llvm.html#Overview-of-Julia-to-LLVM-Interface-1","page":"Working with LLVM","title":"Overview of Julia to LLVM Interface","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Julia dynamically links against LLVM by default. Build with USE_LLVM_SHLIB=0 to link statically.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"The code for lowering Julia AST to LLVM IR or interpreting it directly is in directory src/.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"File Description\nbuiltins.c Builtin functions\nccall.cpp Lowering ccall\ncgutils.cpp Lowering utilities, notably for array and tuple accesses\ncodegen.cpp Top-level of code generation, pass list, lowering builtins\ndebuginfo.cpp Tracks debug information for JIT code\ndisasm.cpp Handles native object file and JIT code diassembly\ngf.c Generic functions\nintrinsics.cpp Lowering intrinsics\nllvm-simdloop.cpp Custom LLVM pass for @simd\nsys.c I/O and operating system utility functions","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Some of the .cpp files form a group that compile to a single object.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"The difference between an intrinsic and a builtin is that a builtin is a first class function that can be used like any other Julia function.  An intrinsic can operate only on unboxed data, and therefore its arguments must be statically typed.","category":"page"},{"location":"devdocs/llvm.html#Alias-Analysis-1","page":"Working with LLVM","title":"Alias Analysis","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Julia currently uses LLVM's Type Based Alias Analysis.  To find the comments that document the inclusion relationships, look for static MDNode* in src/codegen.cpp.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"The -O option enables LLVM's Basic Alias Analysis.","category":"page"},{"location":"devdocs/llvm.html#Building-Julia-with-a-different-version-of-LLVM-1","page":"Working with LLVM","title":"Building Julia with a different version of LLVM","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"The default version of LLVM is specified in deps/Versions.make. You can override it by creating a file called Make.user in the top-level directory and adding a line to it such as:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"LLVM_VER = 6.0.1","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Besides the LLVM release numerals, you can also use LLVM_VER = svn to build against the latest development version of LLVM.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"You can also specify to build a debug version of LLVM, by setting either LLVM_DEBUG = 1 or LLVM_DEBUG = Release in your Make.user file. The former will be a fully unoptimized build of LLVM and the latter will produce an optimized build of LLVM. Depending on your needs the latter will suffice and it quite a bit faster. If you use LLVM_DEBUG = Release you will also want to set LLVM_ASSERTIONS = 1 to enable diagonstics for different passes. Only LLVM_DEBUG = 1 implies that option by default.","category":"page"},{"location":"devdocs/llvm.html#Passing-options-to-LLVM-1","page":"Working with LLVM","title":"Passing options to LLVM","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"You can pass options to LLVM via the environment variable JULIA_LLVM_ARGS.  Here are example settings using bash syntax:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"export JULIA_LLVM_ARGS = -print-after-all dumps IR after each pass.\nexport JULIA_LLVM_ARGS = -debug-only=loop-vectorize dumps LLVM DEBUG(...) diagnostics for loop vectorizer. If you get warnings about \"Unknown command line argument\", rebuild LLVM with LLVM_ASSERTIONS = 1.","category":"page"},{"location":"devdocs/llvm.html#Debugging-LLVM-transformations-in-isolation-1","page":"Working with LLVM","title":"Debugging LLVM transformations in isolation","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"On occasion, it can be useful to debug LLVM's transformations in isolation from the rest of the Julia system, e.g. because reproducing the issue inside julia would take too long, or because one wants to take advantage of LLVM's tooling (e.g. bugpoint). To get unoptimized IR for the entire system image, pass the --output-unopt-bc unopt.bc option to the system image build process, which will output the unoptimized IR to an unopt.bc file. This file can then be passed to LLVM tools as usual. libjulia can function as an LLVM pass plugin and can be loaded into LLVM tools, to make julia-specific passes available in this environment. In addition, it exposes the -julia meta-pass, which runs the entire Julia pass-pipeline over the IR. As an example, to generate a system image, one could do:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"opt -load libjulia.so -julia -o opt.bc unopt.bc\nllc -o sys.o opt.bc\ncc -shared -o sys.so sys.o","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"This system image can then be loaded by julia as usual.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Alternatively, you can use --output-jit-bc jit.bc to obtain a trace of all IR passed to the JIT.  This is useful for code that cannot be run as part of the sysimg generation process (e.g. because it creates unserializable state). However, the resulting jit.bc does not include sysimage data, and can thus not be used as such.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"It is also possible to dump an LLVM IR module for just one Julia function, using:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"f, T = +, Tuple{Int,Int} # Substitute your function of interest here\noptimize = false\nopen(\"plus.ll\", \"w\") do f\n    println(f, Base._dump_function(f, T, false, false, false, true, :att, optimize))\nend","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"These files can be processed the same way as the unoptimized sysimg IR shown above.","category":"page"},{"location":"devdocs/llvm.html#Improving-LLVM-optimizations-for-Julia-1","page":"Working with LLVM","title":"Improving LLVM optimizations for Julia","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Improving LLVM code generation usually involves either changing Julia lowering to be more friendly to LLVM's passes, or improving a pass.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"If you are planning to improve a pass, be sure to read the LLVM developer policy.  The best strategy is to create a code example in a form where you can use LLVM's opt tool to study it and the pass of interest in isolation.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Create an example Julia code of interest.\nUse JULIA_LLVM_ARGS = -print-after-all to dump the IR.\nPick out the IR at the point just before the pass of interest runs.\nStrip the debug metadata and fix up the TBAA metadata by hand.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"The last step is labor intensive.  Suggestions on a better way would be appreciated.","category":"page"},{"location":"devdocs/llvm.html#The-jlcall-calling-convention-1","page":"Working with LLVM","title":"The jlcall calling convention","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Julia has a generic calling convention for unoptimized code, which looks somewhat as follows:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"jl_value_t *any_unoptimized_call(jl_value_t *, jl_value_t **, int);","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"where the first argument is the boxed function object, the second argument is an on-stack array of arguments and the third is the number of arguments. Now, we could perform a straightforward lowering and emit an alloca for the argument array. However, this would betray the SSA nature of the uses at the call site, making optimizations (including GC root placement), significantly harder.  Instead, we emit it as follows:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"%bitcast = bitcast @any_unoptimized_call to %jl_value_t *(*)(%jl_value_t *, %jl_value_t *)\ncall cc 37 %jl_value_t *%bitcast(%jl_value_t *%arg1, %jl_value_t *%arg2)","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"The special cc 37 annotation marks the fact that this call site is really using the jlcall calling convention. This allows us to retain the SSA-ness of the uses throughout the optimizer. GC root placement will later lower this call to the original C ABI. In the code the calling convention number is represented by the JLCALL_F_CC constant. In addition, there is the JLCALL_CC calling convention which functions similarly, but omits the first argument.","category":"page"},{"location":"devdocs/llvm.html#GC-root-placement-1","page":"Working with LLVM","title":"GC root placement","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"GC root placement is done by an LLVM pass late in the pass pipeline. Doing GC root placement this late enables LLVM to make more aggressive optimizations around code that requires GC roots, as well as allowing us to reduce the number of required GC roots and GC root store operations (since LLVM doesn't understand our GC, it wouldn't otherwise know what it is and is not allowed to do with values stored to the GC frame, so it'll conservatively do very little). As an example, consider an error path","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"if some_condition()\n    #= Use some variables maybe =#\n    error(\"An error occurred\")\nend","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"During constant folding, LLVM may discover that the condition is always false, and can remove the basic block. However, if GC root lowering is done early, the GC root slots used in the deleted block, as well as any values kept alive in those slots only because they were used in the error path, would be kept alive by LLVM. By doing GC root lowering late, we give LLVM the license to do any of its usual optimizations (constant folding, dead code elimination, etc.), without having to worry (too much) about which values may or may not be GC tracked.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"However, in order to be able to do late GC root placement, we need to be able to identify a) which pointers are GC tracked and b) all uses of such pointers. The goal of the GC placement pass is thus simple:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Minimize the number of needed GC roots/stores to them subject to the constraint that at every safepoint, any live GC-tracked pointer (i.e. for which there is a path after this point that contains a use of this pointer) is in some GC slot.","category":"page"},{"location":"devdocs/llvm.html#Representation-1","page":"Working with LLVM","title":"Representation","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"The primary difficulty is thus choosing an IR representation that allows us to identify GC-tracked pointers and their uses, even after the program has been run through the optimizer. Our design makes use of three LLVM features to achieve this: - Custom address spaces - Operand Bundles - Non-integral pointers","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Custom address spaces allow us to tag every point with an integer that needs to be preserved through optimizations. The compiler may not insert casts between address spaces that did not exist in the original program and it must never change the address space of a pointer on a load/store/etc operation. This allows us to annotate which pointers are GC-tracked in an optimizer-resistant way. Note that metadata would not be able to achieve the same purpose. Metadata is supposed to always be discardable without altering the semantics of the program. However, failing to identify a GC-tracked pointer alters the resulting program behavior dramatically - it'll probably crash or return wrong results. We currently use three different address spaces (their numbers are defined in src/codegen_shared.cpp):","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"GC Tracked Pointers (currently 10): These are pointers to boxed values that may be put into a GC frame. It is loosely equivalent to a jl_value_t* pointer on the C side. N.B. It is illegal to ever have a pointer in this address space that may not be stored to a GC slot.\nDerived Pointers (currently 11): These are pointers that are derived from some GC tracked pointer. Uses of these pointers generate uses of the original pointer.  However, they need not themselves be known to the GC. The GC root placement pass MUST always find the GC tracked pointer from which this pointer is derived and use that as the pointer to root.\nCallee Rooted Pointers (currently 12): This is a utility address space to express the notion of a callee rooted value. All values of this address space MUST be storable to a GC root (though it is possible to relax this condition in the future), but unlike the other pointers need not be rooted if passed to a call (they do still need to be rooted if they are live across another safepoint between the definition and the call).\nPointers loaded from tracked object (currently 13): This is used by arrays, which themselves contain a pointer to the managed data. This data area is owned by the array, but is not a GC-tracked object by itself. The compiler guarantees that as long as this pointer is live, the object that this pointer was loaded from will keep being live.","category":"page"},{"location":"devdocs/llvm.html#Invariants-1","page":"Working with LLVM","title":"Invariants","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"The GC root placement pass makes use of several invariants, which need to be observed by the frontend and are preserved by the optimizer.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"First, only the following address space casts are allowed:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"0->{Tracked,Derived,CalleeRooted}: It is allowable to decay an untracked pointer to any of the others. However, do note that the optimizer has broad license to not root such a value. It is never safe to have a value in address space 0 in any part of the program if it is (or is derived from) a value that requires a GC root.\nTracked->Derived: This is the standard decay route for interior values. The placement pass will look for these to identify the base pointer for any use.\nTracked->CalleeRooted: Addrspace CalleeRooted serves merely as a hint that a GC root is not required. However, do note that the Derived->CalleeRooted decay is prohibited, since pointers should generally be storable to a GC slot, even in this address space.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Now let us consider what constitutes a use: - Loads whose loaded values is in one of the address spaces - Stores of a value in one of the address spaces to a location - Stores to a pointer in one of the address spaces - Calls for which a value in one of the address spaces is an operand - Calls in jlcall ABI, for which the argument array contains a value - Return instructions.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"We explicitly allow load/stores and simple calls in address spaces Tracked/Derived. Elements of jlcall argument arrays must always be in address space Tracked (it is required by the ABI that they are valid jl_value_t* pointers). The same is true for return instructions (though note that struct return arguments are allowed to have any of the address spaces). The only allowable use of an address space CalleeRooted pointer is to pass it to a call (which must have an appropriately typed operand).","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Further, we disallow getelementptr in addrspace Tracked. This is because unless the operation is a noop, the resulting pointer will not be validly storable to a GC slot and may thus not be in this address space. If such a pointer is required, it should be decayed to addrspace Derived first.","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"Lastly, we disallow inttoptr/ptrtoint instructions in these address spaces.  Having these instructions would mean that some i64 values are really GC tracked.  This is problematic, because it breaks that stated requirement that we're able to identify GC-relevant pointers. This invariant is accomplished using the LLVM \"non-integral pointers\" feature, which is new in LLVM 5.0. It prohibits the optimizer from making optimizations that would introduce these operations. Note we can still insert static constants at JIT time by using inttoptr in address space 0 and then decaying to the appropriate address space afterwards.","category":"page"},{"location":"devdocs/llvm.html#Supporting-[ccall](@ref)-1","page":"Working with LLVM","title":"Supporting ccall","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"One important aspect missing from the discussion so far is the handling of ccall. ccall has the peculiar feature that the location and scope of a use do not coincide. As an example consider:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"A = randn(1024)\nccall(:foo, Cvoid, (Ptr{Float64},), A)","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"In lowering, the compiler will insert a conversion from the array to the pointer which drops the reference to the array value. However, we of course need to make sure that the array does stay alive while we're doing the ccall. To understand how this is done, first recall the lowering of the above code:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"return $(Expr(:foreigncall, :(:foo), Cvoid, svec(Ptr{Float64}), :(:ccall), 1, :($(Expr(:foreigncall, :(:jl_array_ptr), Ptr{Float64}, svec(Any), :(:ccall), 1, :(A)))), :(A)))","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"The last :(A), is an extra argument list inserted during lowering that informs the code generator which Julia level values need to be kept alive for the duration of this ccall. We then take this information and represent it in an \"operand bundle\" at the IR level. An operand bundle is essentially a fake use that is attached to the call site. At the IR level, this looks like so:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"call void inttoptr (i64 ... to void (double*)*)(double* %5) [ \"jl_roots\"(%jl_value_t addrspace(10)* %A) ]","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"The GC root placement pass will treat the jl_roots operand bundle as if it were a regular operand. However, as a final step, after the GC roots are inserted, it will drop the operand bundle to avoid confusing instruction selection.","category":"page"},{"location":"devdocs/llvm.html#Supporting-[pointer_from_objref](@ref)-1","page":"Working with LLVM","title":"Supporting pointer_from_objref","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"pointer_from_objref is special because it requires the user to take explicit control of GC rooting. By our above invariants, this function is illegal, because it performs an address space cast from 10 to 0. However, it can be useful, in certain situations, so we provide a special intrinsic:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"declared %jl_value_t *julia.pointer_from_objref(%jl_value_t addrspace(10)*)","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"which is lowered to the corresponding address space cast after GC root lowering.  Do note however that by using this intrinsic, the caller assumes all responsibility for making sure that the value in question is rooted. Further this intrinsic is not considered a use, so the GC root placement pass will not provide a GC root for the function. As a result, the external rooting must be arranged while the value is still tracked by the system. I.e. it is not valid to attempt to use the result of this operation to establish a global root - the optimizer may have already dropped the value.","category":"page"},{"location":"devdocs/llvm.html#Keeping-values-alive-in-the-absence-of-uses-1","page":"Working with LLVM","title":"Keeping values alive in the absence of uses","text":"","category":"section"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"In certain cases it is necessary to keep an object alive, even though there is no compiler-visible use of said object. This may be case for low level code that operates on the memory-representation of an object directly or code that needs to interface with C code. In order to allow this, we provide the following intrinsics at the LLVM level:","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"token @llvm.julia.gc_preserve_begin(...)\nvoid @llvm.julia.gc_preserve_end(token)","category":"page"},{"location":"devdocs/llvm.html#","page":"Working with LLVM","title":"Working with LLVM","text":"(The llvm. in the name is required in order to be able to use the token type). The semantics of these intrinsics are as follows: At any safepoint that is dominated by a gc_preserve_begin call, but that is not not dominated by a corresponding gc_preserve_end call (i.e. a call whose argument is the token returned by a gc_preserve_begin call), the values passed as arguments to that gc_preserve_begin will be kept live. Note that the gc_preserve_begin still counts as a regular use of those values, so the standard lifetime semantics will ensure that the values will be kept alive before entering the preserve region.","category":"page"},{"location":"devdocs/stdio.html#printf()-and-stdio-in-the-Julia-runtime-1","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"","category":"section"},{"location":"devdocs/stdio.html#Libuv-wrappers-for-stdio-1","page":"printf() and stdio in the Julia runtime","title":"Libuv wrappers for stdio","text":"","category":"section"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"julia.h defines libuv wrappers for the stdio.h streams:","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"uv_stream_t *JL_STDIN;\nuv_stream_t *JL_STDOUT;\nuv_stream_t *JL_STDERR;","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"... and corresponding output functions:","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"int jl_printf(uv_stream_t *s, const char *format, ...);\nint jl_vprintf(uv_stream_t *s, const char *format, va_list args);","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"These printf functions are used by the .c files in the src/ and ui/ directories wherever stdio is needed to ensure that output buffering is handled in a unified way.","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"In special cases, like signal handlers, where the full libuv infrastructure is too heavy, jl_safe_printf() can be used to write(2) directly to STDERR_FILENO:","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"void jl_safe_printf(const char *str, ...);","category":"page"},{"location":"devdocs/stdio.html#Interface-between-JL_STD*-and-Julia-code-1","page":"printf() and stdio in the Julia runtime","title":"Interface between JL_STD* and Julia code","text":"","category":"section"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"Base.stdin, Base.stdout and Base.stderr are bound to the JL_STD* libuv streams defined in the runtime.","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"Julia's __init__() function (in base/sysimg.jl) calls reinit_stdio() (in base/stream.jl)  to create Julia objects for Base.stdin, Base.stdout and Base.stderr.","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"reinit_stdio() uses ccall to retrieve pointers to JL_STD* and calls jl_uv_handle_type() to inspect the type of each stream.  It then creates a Julia Base.IOStream, Base.TTY or Base.PipeEndpoint object to represent each stream, e.g.:","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"$ julia -e 'println(typeof((stdin, stdout, stderr)))'\nTuple{Base.TTY,Base.TTY,Base.TTY}\n\n$ julia -e 'println(typeof((stdin, stdout, stderr)))' < /dev/null 2>/dev/null\nTuple{IOStream,Base.TTY,IOStream}\n\n$ echo hello | julia -e 'println(typeof((stdin, stdout, stderr)))' | cat\nTuple{Base.PipeEndpoint,Base.PipeEndpoint,Base.TTY}","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"The Base.read and Base.write methods for these streams use ccall  to call libuv wrappers in src/jl_uv.c, e.g.:","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"stream.jl: function write(s::IO, p::Ptr, nb::Integer)\n               -> ccall(:jl_uv_write, ...)\n  jl_uv.c:          -> int jl_uv_write(uv_stream_t *stream, ...)\n                        -> uv_write(uvw, stream, buf, ...)","category":"page"},{"location":"devdocs/stdio.html#printf()-during-initialization-1","page":"printf() and stdio in the Julia runtime","title":"printf() during initialization","text":"","category":"section"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"The libuv streams relied upon by jl_printf() etc., are not available until midway through initialization of the runtime (see init.c, init_stdio()).  Error messages or warnings that need to be printed before this are routed to the standard C library fwrite() function by the following mechanism:","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"In sys.c, the JL_STD* stream pointers are statically initialized to integer constants: STD*_FILENO (0, 1 and 2).  In jl_uv.c the jl_uv_puts() function checks its uv_stream_t* stream argument and calls fwrite() if stream is set to STDOUT_FILENO or STDERR_FILENO.","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"This allows for uniform use of jl_printf() throughout the runtime regardless of whether or not any particular piece of code is reachable before initialization is complete.","category":"page"},{"location":"devdocs/stdio.html#Legacy-ios.c-library-1","page":"printf() and stdio in the Julia runtime","title":"Legacy ios.c library","text":"","category":"section"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"The src/support/ios.c library is inherited from femtolisp.  It provides cross-platform buffered file IO and in-memory temporary buffers.","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"ios.c is still used by:","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"src/flisp/*.c\nsrc/dump.c – for serialization file IO and for memory buffers.\nsrc/staticdata.c – for serialization file IO and for memory buffers.\nbase/iostream.jl – for file IO (see base/fs.jl for libuv equivalent).","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"Use of ios.c in these modules is mostly self-contained and separated from the libuv I/O system.  However, there is one place where femtolisp calls through to jl_printf() with a legacy ios_t stream.","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"There is a hack in ios.h that makes the ios_t.bm field line up with the uv_stream_t.type and ensures that the values used for ios_t.bm to not overlap with valid UV_HANDLE_TYPE values.  This allows uv_stream_t pointers to point to ios_t streams.","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"This is needed because jl_printf() caller jl_static_show() is passed an ios_t stream by femtolisp's fl_print() function. Julia's jl_uv_puts() function has special handling for this:","category":"page"},{"location":"devdocs/stdio.html#","page":"printf() and stdio in the Julia runtime","title":"printf() and stdio in the Julia runtime","text":"if (stream->type > UV_HANDLE_TYPE_MAX) {\n    return ios_write((ios_t*)stream, str, n);\n}","category":"page"},{"location":"devdocs/boundscheck.html#Bounds-checking-1","page":"Bounds checking","title":"Bounds checking","text":"","category":"section"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"Like many modern programming languages, Julia uses bounds checking to ensure program safety when accessing arrays. In tight inner loops or other performance critical situations, you may wish to skip these bounds checks to improve runtime performance. For instance, in order to emit vectorized (SIMD) instructions, your loop body cannot contain branches, and thus cannot contain bounds checks.  Consequently, Julia includes an @inbounds(...) macro to tell the compiler to skip such bounds checks within the given block. User-defined array types can use the @boundscheck(...) macro to achieve context-sensitive code selection.","category":"page"},{"location":"devdocs/boundscheck.html#Eliding-bounds-checks-1","page":"Bounds checking","title":"Eliding bounds checks","text":"","category":"section"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"The @boundscheck(...) macro marks blocks of code that perform bounds checking.  When such blocks are inlined into an @inbounds(...) block, the compiler may remove these blocks.  The compiler removes the @boundscheck block only if it is inlined into the calling function.  For example, you might write the method sum as:","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"function sum(A::AbstractArray)\n    r = zero(eltype(A))\n    for i = 1:length(A)\n        @inbounds r += A[i]\n    end\n    return r\nend","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"With a custom array-like type MyArray having:","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"@inline getindex(A::MyArray, i::Real) = (@boundscheck checkbounds(A,i); A.data[to_index(i)])","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"Then when getindex is inlined into sum, the call to checkbounds(A,i) will be elided. If your function contains multiple layers of inlining, only @boundscheck blocks at most one level of inlining deeper are eliminated. The rule prevents unintended changes in program behavior from code further up the stack.","category":"page"},{"location":"devdocs/boundscheck.html#Propagating-inbounds-1","page":"Bounds checking","title":"Propagating inbounds","text":"","category":"section"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"There may be certain scenarios where for code-organization reasons you want more than one layer between the @inbounds and @boundscheck declarations. For instance, the default getindex methods have the chain getindex(A::AbstractArray, i::Real) calls getindex(IndexStyle(A), A, i) calls _getindex(::IndexLinear, A, i).","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"To override the \"one layer of inlining\" rule, a function may be marked with Base.@propagate_inbounds to propagate an inbounds context (or out of bounds context) through one additional layer of inlining.","category":"page"},{"location":"devdocs/boundscheck.html#The-bounds-checking-call-hierarchy-1","page":"Bounds checking","title":"The bounds checking call hierarchy","text":"","category":"section"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"The overall hierarchy is:","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"checkbounds(A, I...) which calls\ncheckbounds(Bool, A, I...) which calls\ncheckbounds_indices(Bool, axes(A), I) which recursively calls\ncheckindex for each dimension","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"Here A is the array, and I contains the \"requested\" indices. axes(A) returns a tuple of \"permitted\" indices of A.","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"checkbounds(A, I...) throws an error if the indices are invalid, whereas checkbounds(Bool, A, I...) returns false in that circumstance. checkbounds_indices discards any information about the array other than its axes tuple, and performs a pure indices-vs-indices comparison: this allows relatively few compiled methods to serve a huge variety of array types. Indices are specified as tuples, and are usually compared in a 1-1 fashion with individual dimensions handled by calling another important function, checkindex: typically,","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"checkbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &\n                                                      checkbounds_indices(Bool, IA, I)","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"so checkindex checks a single dimension.  All of these functions, including the unexported checkbounds_indices have docstrings accessible with ? .","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"If you have to customize bounds checking for a specific array type, you should specialize checkbounds(Bool, A, I...).  However, in most cases you should be able to rely on checkbounds_indices as long as you supply useful axes for your array type.","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"If you have novel index types, first consider specializing checkindex, which handles a single index for a particular dimension of an array.  If you have a custom multidimensional index type (similar to CartesianIndex), then you may have to consider specializing checkbounds_indices.","category":"page"},{"location":"devdocs/boundscheck.html#","page":"Bounds checking","title":"Bounds checking","text":"Note this hierarchy has been designed to reduce the likelihood of method ambiguities.  We try to make checkbounds the place to specialize on array type, and try to avoid specializations on index types; conversely, checkindex is intended to be specialized only on index type (especially, the last argument).","category":"page"},{"location":"devdocs/locks.html#Proper-maintenance-and-care-of-multi-threading-locks-1","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"","category":"section"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"The following strategies are used to ensure that the code is dead-lock free (generally by addressing the 4th Coffman condition: circular wait).","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"structure code such that only one lock will need to be acquired at a time\nalways acquire shared locks in the same order, as given by the table below\navoid constructs that expect to need unrestricted recursion","category":"page"},{"location":"devdocs/locks.html#Locks-1","page":"Proper maintenance and care of multi-threading locks","title":"Locks","text":"","category":"section"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"Below are all of the locks that exist in the system and the mechanisms for using them that avoid the potential for deadlocks (no Ostrich algorithm allowed here):","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"The following are definitely leaf locks (level 1), and must not try to acquire any other lock:","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"safepoint\nNote that this lock is acquired implicitly by JL_LOCK and JL_UNLOCK. use the _NOGC variants to avoid that for level 1 locks.While holding this lock, the code must not do any allocation or hit any safepoints. Note that there are safepoints when doing allocation, enabling / disabling GC, entering / restoring exception frames, and taking / releasing locks.\nshared_map\nfinalizers\npagealloc\ngcpermlock\nflisp\nflisp itself is already threadsafe, this lock only protects the jl_ast_context_list_t pool","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"The following is a leaf lock (level 2), and only acquires level 1 locks (safepoint) internally:","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"typecache","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"The following is a level 3 lock, which can only acquire level 1 or level 2 locks internally:","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"Method->writelock","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"The following is a level 4 lock, which can only recurse to acquire level 1, 2, or 3 locks:","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"MethodTable->writelock","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"No Julia code may be called while holding a lock above this point.","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"The following is a level 6 lock, which can only recurse to acquire locks at lower levels:","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"codegen","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"The following is an almost root lock (level end-1), meaning only the root look may be held when trying to acquire it:","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"typeinf\nthis one is perhaps one of the most tricky ones, since type-inference can be invoked from many pointscurrently the lock is merged with the codegen lock, since they call each other recursively","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"The following is the root lock, meaning no other lock shall be held when trying to acquire it:","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"toplevel\nthis should be held while attempting a top-level action (such as making a new type or defining a new method): trying to obtain this lock inside a staged function will cause a deadlock condition!additionally, it's unclear if any code can safely run in parallel with an arbitrary toplevel expression, so it may require all threads to get to a safepoint first","category":"page"},{"location":"devdocs/locks.html#Broken-Locks-1","page":"Proper maintenance and care of multi-threading locks","title":"Broken Locks","text":"","category":"section"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"The following locks are broken:","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"toplevel\ndoesn't exist right nowfix: create it","category":"page"},{"location":"devdocs/locks.html#Shared-Global-Data-Structures-1","page":"Proper maintenance and care of multi-threading locks","title":"Shared Global Data Structures","text":"","category":"section"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"These data structures each need locks due to being shared mutable global state. It is the inverse list for the above lock priority list. This list does not include level 1 leaf resources due to their simplicity.","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"MethodTable modifications (def, cache, kwsorter type) : MethodTable->writelock","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"Type declarations : toplevel lock","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"Type application : typecache lock","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"Module serializer : toplevel lock","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"JIT & type-inference : codegen lock","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"MethodInstance updates : codegen lock","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"These fields are generally lazy initialized, using the test-and-test-and-set pattern.\nThese are set at construction and immutable:\nspecTypes\nsparam_vals\ndef\nThese are set by jl_type_infer (while holding codegen lock):\nrettype\ninferred\nthese can also be reset, see jl_set_lambda_rettype for that logic as it needs to keep functionObjectsDecls in sync\ninInference flag:\noptimization to quickly avoid recurring into jl_type_infer while it is already running\nactual state (of setting inferred, then fptr) is protected by codegen lock\nFunction pointers (jlcall_api and fptr, unspecialized_ducttape):\nthese transition once, from NULL to a value, while the codegen lock is held\nCode-generator cache (the contents of functionObjectsDecls):\nthese can transition multiple times, but only while the codegen lock is held\nit is valid to use old version of this, or block for new versions of this, so races are benign, as long as the code is careful not to reference other data in the method instance (such as rettype) and assume it is coordinated, unless also holding the codegen lock\ncompile_traced flag:\nunknown","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"LLVMContext : codegen lock","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"Method : Method->writelock","category":"page"},{"location":"devdocs/locks.html#","page":"Proper maintenance and care of multi-threading locks","title":"Proper maintenance and care of multi-threading locks","text":"roots array (serializer and codegen)\ninvoke / specializations / tfunc modifications","category":"page"},{"location":"devdocs/offset-arrays.html#man-custom-indices-1","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Conventionally, Julia's arrays are indexed starting at 1, whereas some other languages start numbering at 0, and yet others (e.g., Fortran) allow you to specify arbitrary starting indices.  While there is much merit in picking a standard (i.e., 1 for Julia), there are some algorithms which simplify considerably if you can index outside the range 1:size(A,d) (and not just 0:size(A,d)-1, either).  To facilitate such computations, Julia supports arrays with arbitrary indices.","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"The purpose of this page is to address the question, \"what do I have to do to support such arrays in my own code?\" First, let's address the simplest case: if you know that your code will never need to handle arrays with unconventional indexing, hopefully the answer is \"nothing.\" Old code, on conventional arrays, should function essentially without alteration as long as it was using the exported interfaces of Julia.  If you find it more convenient to just force your users to supply traditional arrays where indexing starts at one, you can add","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Base.require_one_based_indexing(arrays...)","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"where arrays... is a list of the array objects that you wish to check for anything that violates 1-based indexing.","category":"page"},{"location":"devdocs/offset-arrays.html#Generalizing-existing-code-1","page":"Arrays with custom indices","title":"Generalizing existing code","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"As an overview, the steps are:","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"replace many uses of size with axes\nreplace 1:length(A) with eachindex(A), or in some cases LinearIndices(A)\nreplace explicit allocations like Array{Int}(undef, size(B)) with similar(Array{Int}, axes(B))","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"These are described in more detail below.","category":"page"},{"location":"devdocs/offset-arrays.html#Things-to-watch-out-for-1","page":"Arrays with custom indices","title":"Things to watch out for","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Because unconventional indexing breaks many people's assumptions that all arrays start indexing with 1, there is always the chance that using such arrays will trigger errors.  The most frustrating bugs would be incorrect results or segfaults (total crashes of Julia).  For example, consider the following function:","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"function mycopy!(dest::AbstractVector, src::AbstractVector)\n    length(dest) == length(src) || throw(DimensionMismatch(\"vectors must match\"))\n    # OK, now we're safe to use @inbounds, right? (not anymore!)\n    for i = 1:length(src)\n        @inbounds dest[i] = src[i]\n    end\n    dest\nend","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"This code implicitly assumes that vectors are indexed from 1; if dest starts at a different index than src, there is a chance that this code would trigger a segfault.  (If you do get segfaults, to help locate the cause try running julia with the option --check-bounds=yes.)","category":"page"},{"location":"devdocs/offset-arrays.html#Using-axes-for-bounds-checks-and-loop-iteration-1","page":"Arrays with custom indices","title":"Using axes for bounds checks and loop iteration","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"axes(A) (reminiscent of size(A)) returns a tuple of AbstractUnitRange objects, specifying the range of valid indices along each dimension of A. When A has unconventional indexing, the ranges may not start at 1.  If you just want the range for a particular dimension d, there is axes(A, d).","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Base implements a custom range type, OneTo, where OneTo(n) means the same thing as 1:n but in a form that guarantees (via the type system) that the lower index is 1. For any new AbstractArray  type, this is the default returned by axes, and it indicates that this array type uses \"conventional\" 1-based indexing.","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"For bounds checking, note that there are dedicated functions checkbounds and checkindex which can sometimes simplify such tests.","category":"page"},{"location":"devdocs/offset-arrays.html#Linear-indexing-(LinearIndices)-1","page":"Arrays with custom indices","title":"Linear indexing (LinearIndices)","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Some algorithms are most conveniently (or efficiently) written in terms of a single linear index, A[i] even if A is multi-dimensional. Regardless of the array's native indices, linear indices always range from 1:length(A). However, this raises an ambiguity for one-dimensional arrays (a.k.a., AbstractVector): does v[i] mean linear indexing , or Cartesian indexing with the array's native indices?","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"For this reason, your best option may be to iterate over the array with eachindex(A), or, if you require the indices to be sequential integers, to get the index range by calling LinearIndices(A). This will return axes(A, 1) if A is an AbstractVector, and the equivalent of 1:length(A) otherwise.","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"By this definition, 1-dimensional arrays always use Cartesian indexing with the array's native indices. To help enforce this, it's worth noting that the index conversion functions will throw an error if shape indicates a 1-dimensional array with unconventional indexing (i.e., is a Tuple{UnitRange} rather than a tuple of OneTo). For arrays with conventional indexing, these functions continue to work the same as always.","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Using axes and LinearIndices, here is one way you could rewrite mycopy!:","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"function mycopy!(dest::AbstractVector, src::AbstractVector)\n    axes(dest) == axes(src) || throw(DimensionMismatch(\"vectors must match\"))\n    for i in LinearIndices(src)\n        @inbounds dest[i] = src[i]\n    end\n    dest\nend","category":"page"},{"location":"devdocs/offset-arrays.html#Allocating-storage-using-generalizations-of-similar-1","page":"Arrays with custom indices","title":"Allocating storage using generalizations of similar","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Storage is often allocated with Array{Int}(undef, dims) or similar(A, args...). When the result needs to match the indices of some other array, this may not always suffice. The generic replacement for such patterns is to use similar(storagetype, shape).  storagetype indicates the kind of underlying \"conventional\" behavior you'd like, e.g., Array{Int} or BitArray or even dims->zeros(Float32, dims) (which would allocate an all-zeros array). shape is a tuple of Integer or AbstractUnitRange values, specifying the indices that you want the result to use. Note that a convenient way of producing an all-zeros array that matches the indices of A is simply zeros(A).","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Let's walk through a couple of explicit examples. First, if A has conventional indices, then similar(Array{Int}, axes(A)) would end up calling Array{Int}(undef, size(A)), and thus return an array.  If A is an AbstractArray type with unconventional indexing, then similar(Array{Int}, axes(A)) should return something that \"behaves like\" an Array{Int} but with a shape (including indices)  that matches A. (The most obvious implementation is to allocate an Array{Int}(undef, size(A)) and then \"wrap\" it in a type that shifts the indices.)","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Note also that similar(Array{Int}, (axes(A, 2),)) would allocate an AbstractVector{Int} (i.e., 1-dimensional array) that matches the indices of the columns of A.","category":"page"},{"location":"devdocs/offset-arrays.html#Writing-custom-array-types-with-non-1-indexing-1","page":"Arrays with custom indices","title":"Writing custom array types with non-1 indexing","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Most of the methods you'll need to define are standard for any AbstractArray type, see Abstract Arrays.  This page focuses on the steps needed to define unconventional indexing.","category":"page"},{"location":"devdocs/offset-arrays.html#Custom-AbstractUnitRange-types-1","page":"Arrays with custom indices","title":"Custom AbstractUnitRange types","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"If you're writing a non-1 indexed array type, you will want to specialize axes so it returns a UnitRange, or (perhaps better) a custom AbstractUnitRange.  The advantage of a custom type is that it \"signals\" the allocation type for functions like similar. If we're writing an array type for which indexing will start at 0, we likely want to begin by creating a new AbstractUnitRange, ZeroRange, where ZeroRange(n) is equivalent to 0:n-1.","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"In general, you should probably not export ZeroRange from your package: there may be other packages that implement their own ZeroRange, and having multiple distinct ZeroRange types is (perhaps counterintuitively) an advantage: ModuleA.ZeroRange indicates that similar should create a ModuleA.ZeroArray, whereas ModuleB.ZeroRange indicates a ModuleB.ZeroArray type.  This design allows peaceful coexistence among many different custom array types.","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Note that the Julia package CustomUnitRanges.jl can sometimes be used to avoid the need to write your own ZeroRange type.","category":"page"},{"location":"devdocs/offset-arrays.html#Specializing-axes-1","page":"Arrays with custom indices","title":"Specializing axes","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Once you have your AbstractUnitRange type, then specialize axes:","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Base.axes(A::ZeroArray) = map(n->ZeroRange(n), A.size)","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"where here we imagine that ZeroArray has a field called size (there would be other ways to implement this).","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"In some cases, the fallback definition for axes(A, d):","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"axes(A::AbstractArray{T,N}, d) where {T,N} = d <= N ? axes(A)[d] : OneTo(1)","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"may not be what you want: you may need to specialize it to return something other than OneTo(1) when d > ndims(A).  Likewise, in Base there is a dedicated function indices1 which is equivalent to axes(A, 1) but which avoids checking (at runtime) whether ndims(A) > 0. (This is purely a performance optimization.)  It is defined as:","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"indices1(A::AbstractArray{T,0}) where {T} = OneTo(1)\nindices1(A::AbstractArray) = axes(A)[1]","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"If the first of these (the zero-dimensional case) is problematic for your custom array type, be sure to specialize it appropriately.","category":"page"},{"location":"devdocs/offset-arrays.html#Specializing-similar-1","page":"Arrays with custom indices","title":"Specializing similar","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Given your custom ZeroRange type, then you should also add the following two specializations for similar:","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"function Base.similar(A::AbstractArray, T::Type, shape::Tuple{ZeroRange,Vararg{ZeroRange}})\n    # body\nend\n\nfunction Base.similar(f::Union{Function,DataType}, shape::Tuple{ZeroRange,Vararg{ZeroRange}})\n    # body\nend","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Both of these should allocate your custom array type.","category":"page"},{"location":"devdocs/offset-arrays.html#Specializing-reshape-1","page":"Arrays with custom indices","title":"Specializing reshape","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Optionally, define a method","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Base.reshape(A::AbstractArray, shape::Tuple{ZeroRange,Vararg{ZeroRange}}) = ...","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"and you can reshape an array so that the result has custom indices.","category":"page"},{"location":"devdocs/offset-arrays.html#For-objects-that-mimic-AbstractArray-but-are-not-subtypes-1","page":"Arrays with custom indices","title":"For objects that mimic AbstractArray but are not subtypes","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"has_offset_axes depends on having axes defined for the objects you call it on. If there is some reason you don't have an axes method defined for your object, consider defining a method","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"Base.has_offset_axes(obj::MyNon1IndexedArraylikeObject) = true","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"This will allow code that assumes 1-based indexing to detect a problem and throw a helpful error, rather than returning incorrect results or segfaulting julia.","category":"page"},{"location":"devdocs/offset-arrays.html#Catching-errors-1","page":"Arrays with custom indices","title":"Catching errors","text":"","category":"section"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"If your new array type triggers errors in other code, one helpful debugging step can be to comment out @boundscheck in your getindex and setindex! implementation.  This will ensure that every element access checks bounds. Or, restart julia with --check-bounds=yes.","category":"page"},{"location":"devdocs/offset-arrays.html#","page":"Arrays with custom indices","title":"Arrays with custom indices","text":"In some cases it may also be helpful to temporarily disable size and length for your new array type, since code that makes incorrect assumptions frequently uses these functions.","category":"page"},{"location":"devdocs/require.html#Module-loading-1","page":"Module loading","title":"Module loading","text":"","category":"section"},{"location":"devdocs/require.html#","page":"Module loading","title":"Module loading","text":"Base.require is responsible for loading modules and it also manages the precompilation cache. It is the implementation of the import statement.","category":"page"},{"location":"devdocs/require.html#Experimental-features-1","page":"Module loading","title":"Experimental features","text":"","category":"section"},{"location":"devdocs/require.html#","page":"Module loading","title":"Module loading","text":"The features below are experimental and not part of the stable Julia API. Before building upon them inform yourself about the current thinking and whether they might change soon.","category":"page"},{"location":"devdocs/require.html#Module-loading-callbacks-1","page":"Module loading","title":"Module loading callbacks","text":"","category":"section"},{"location":"devdocs/require.html#","page":"Module loading","title":"Module loading","text":"It is possible to listen to the modules loaded by Base.require, by registering a callback.","category":"page"},{"location":"devdocs/require.html#","page":"Module loading","title":"Module loading","text":"loaded_packages = Channel{Symbol}()\ncallback = (mod::Symbol) -> put!(loaded_packages, mod)\npush!(Base.package_callbacks, callback)","category":"page"},{"location":"devdocs/require.html#","page":"Module loading","title":"Module loading","text":"Please note that the symbol given to the callback is a non-unique identifier and it is the responsibility of the callback provider to walk the module chain to determine the fully qualified name of the loaded binding.","category":"page"},{"location":"devdocs/require.html#","page":"Module loading","title":"Module loading","text":"The callback below is an example of how to do that:","category":"page"},{"location":"devdocs/require.html#","page":"Module loading","title":"Module loading","text":"# Get the fully-qualified name of a module.\nfunction module_fqn(name::Symbol)\n    fqn = fullname(Base.root_module(name))\n    return join(fqn, '.')\nend","category":"page"},{"location":"devdocs/inference.html#Inference-1","page":"Inference","title":"Inference","text":"","category":"section"},{"location":"devdocs/inference.html#How-inference-works-1","page":"Inference","title":"How inference works","text":"","category":"section"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"Type inference refers to the process of deducing the types of later values from the types of input values. Julia's approach to inference has been described in blog posts (1, 2).","category":"page"},{"location":"devdocs/inference.html#Debugging-compiler.jl-1","page":"Inference","title":"Debugging compiler.jl","text":"","category":"section"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"You can start a Julia session, edit compiler/*.jl (for example to insert print statements), and then replace Core.Compiler in your running session by navigating to base/compiler and executing include(\"compiler.jl\"). This trick typically leads to much faster development than if you rebuild Julia for each change.","category":"page"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"A convenient entry point into inference is typeinf_code. Here's a demo running inference on convert(Int, UInt(1)):","category":"page"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"# Get the method\natypes = Tuple{Type{Int}, UInt}  # argument types\nmths = methods(convert, atypes)  # worth checking that there is only one\nm = first(mths)\n\n# Create variables needed to call `typeinf_code`\nparams = Core.Compiler.Params(typemax(UInt))  # parameter is the world age,\n                                                        #   typemax(UInt) -> most recent\nsparams = Core.svec()      # this particular method doesn't have type-parameters\noptimize = true            # run all inference optimizations\ncached = false             # force inference to happen (do not use cached results)\nCore.Compiler.typeinf_code(m, atypes, sparams, optimize, cached, params)","category":"page"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"If your debugging adventures require a MethodInstance, you can look it up by calling Core.Compiler.specialize_method using many of the variables above.  A CodeInfo object may be obtained with","category":"page"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"# Returns the CodeInfo object for `convert(Int, ::UInt)`:\nci = (@code_typed convert(Int, UInt(1)))[1]","category":"page"},{"location":"devdocs/inference.html#The-inlining-algorithm-(inline_worthy)-1","page":"Inference","title":"The inlining algorithm (inline_worthy)","text":"","category":"section"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"Much of the hardest work for inlining runs in inlining_pass. However, if your question is \"why didn't my function inline?\" then you will most likely be interested in isinlineable and its primary callee, inline_worthy. isinlineable handles a number of special cases (e.g., critical functions like next and done, incorporating a bonus for functions that return tuples, etc.). The main decision-making happens in inline_worthy, which returns true if the function should be inlined.","category":"page"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"inline_worthy implements a cost-model, where \"cheap\" functions get inlined; more specifically, we inline functions if their anticipated run-time is not large compared to the time it would take to issue a call to them if they were not inlined. The cost-model is extremely simple and ignores many important details: for example, all for loops are analyzed as if they will be executed once, and the cost of an if...else...end includes the summed cost of all branches. It's also worth acknowledging that we currently lack a suite of functions suitable for testing how well the cost model predicts the actual run-time cost, although BaseBenchmarks  provides a great deal of indirect information about the successes and failures of any modification to the inlining algorithm.","category":"page"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"The foundation of the cost-model is a lookup table, implemented in add_tfunc and its callers, that assigns an estimated cost (measured in CPU cycles) to each of Julia's intrinsic functions. These costs are based on standard ranges for common architectures (see Agner Fog's analysis  for more detail).","category":"page"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"We supplement this low-level lookup table with a number of special cases. For example, an :invoke expression (a call for which all input and output types were inferred in advance) is assigned a fixed cost (currently 20 cycles). In contrast, a :call expression, for functions other than intrinsics/builtins, indicates that the call will require dynamic dispatch, in which case we assign a cost set by Params.inline_nonleaf_penalty (currently set at 1000). Note that this is not a \"first-principles\" estimate of the raw cost of dynamic dispatch, but a mere heuristic indicating that dynamic dispatch is extremely expensive.","category":"page"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"Each statement gets analyzed for its total cost in a function called statement_cost. You can run this yourself by following the sketch below, where f is your function and tt is the Tuple-type of the arguments:","category":"page"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"# A demo on `fill(3.5, (2, 3))\nf = fill\ntt = Tuple{Float64, Tuple{Int,Int}}\n# Create the objects we need to interact with the compiler\nparams = Core.Compiler.Params(typemax(UInt))\nmi = Base.method_instances(f, tt)[1]\nci = code_typed(f, tt)[1][1]\nopt = Core.Compiler.OptimizationState(mi, params)\n# Calculate cost of each statement\ncost(stmt::Expr) = Core.Compiler.statement_cost(stmt, -1, ci, opt.sptypes, opt.slottypes, opt.params)\ncost(stmt) = 0\ncst = map(cost, ci.code)\n\n# output\n\n5-element Array{Int64,1}:\n  0\n  0\n 20\n 20\n  0","category":"page"},{"location":"devdocs/inference.html#","page":"Inference","title":"Inference","text":"The output is a Vector{Int} holding the estimated cost of each statement in ci.code.  Note that ci includes the consequences of inlining callees, and consequently the costs do too.","category":"page"},{"location":"devdocs/ssair.html#Julia-SSA-form-IR-1","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"","category":"section"},{"location":"devdocs/ssair.html#Background-1","page":"Julia SSA-form IR","title":"Background","text":"","category":"section"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"Beginning in Julia 0.7, parts of the compiler use a new SSA-form intermediate representation. Historically, the compiler used to directly generate LLVM IR, from a lowered form of the Julia AST. This form had most syntactic abstractions removed, but still looked a lot like an abstract syntax tree.  Over time, in order to facilitate optimizations, SSA values were introduced to this IR and the IR was linearized (i.e. a form where function arguments may only be SSA values or constants). However, non-ssa values (slots) remained in the IR due to the lack of Phi nodes in the IR (necessary for back-edges and re-merging of conditional control flow), negating much of the usefulfulness of the SSA form representation to perform middle end optimizations. Some heroic effort was put into making these optimizations work without a complete SSA form representation, but the lack of such a representation ultimately proved prohibitive.","category":"page"},{"location":"devdocs/ssair.html#New-IR-nodes-1","page":"Julia SSA-form IR","title":"New IR nodes","text":"","category":"section"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"With the new IR representation, the compiler learned to handle four new IR nodes, Phi nodes, Pi nodes as well as PhiC nodes and Upsilon nodes (the latter two are only used for exception handling).","category":"page"},{"location":"devdocs/ssair.html#Phi-nodes-and-Pi-nodes-1","page":"Julia SSA-form IR","title":"Phi nodes and Pi nodes","text":"","category":"section"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"Phi nodes are part of generic SSA abstraction (see the link above if you're not familiar with the concept). In the Julia IR, these nodes are represented as:","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"struct PhiNode\n    edges::Vector{Int}\n    values::Vector{Any}\nend","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"where we ensure that both vectors always have the same length. In the canonical representation (the one handles by codegen and the interpreter), the edge values indicate come-from statement numbers (i.e.  if edge has an entry of 15, there must be a goto, gotoifnot or implicit fall through from statement 15 that targets this phi node). Values are either SSA values or constants. It is also possible for a value to be unassigned if the variable was not defined on this path. However, undefinedness checks get explicitly inserted and represented as booleans after middle end optimizations, so code generators may assume that any use of a phi node will have an assigned value in the corresponding slot. It is also legal for the mapping to be incomplete, i.e. for a phi node to have missing incoming edges. In that case, it must be dynamically guaranteed that the corresponding value will not be used.","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"PiNodes encode statically proven information that may be implicitly assumed in basic blocks dominated by a given pi node. They are conceptually equivalent to the technique introduced in the paper \"ABCD: Eliminating Array Bounds Checks on Demand\" or the predicate info nodes in LLVM. To see how they work, consider, e.g.","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"%x::Union{Int, Float64} # %x is some Union{Int, Float64} typed ssa value\nif isa(x, Int)\n    # use x\nelse\n    # use x\nend","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"we can perform predicate insertion and turn this into:","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"%x::Union{Int, Float64} # %x is some Union{Int, Float64} typed ssa value\nif isa(x, Int)\n    %x_int = PiNode(x, Int)\n    # use %x_int\nelse\n    %x_float = PiNode(x, Float64)\n    # use %x_float\nend","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"Pi nodes are generally ignored in the interpreter, since they don't have any effect on the values, but they may sometimes lead to code generation in the compiler (e.g. to change from an implicitly union split representation to a plain unboxed representation). The main usefulness of PiNodes stems from the fact that path conditions of the values can be accumulated simply by def-use chain walking that is generally done for most optimizations that care about these conditions anyway.","category":"page"},{"location":"devdocs/ssair.html#PhiC-nodes-and-Upsilon-nodes-1","page":"Julia SSA-form IR","title":"PhiC nodes and Upsilon nodes","text":"","category":"section"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"Exception handling complicates the SSA story moderately, because exception handling introduces additional control flow edges into the IR across which values must be tracked.  One approach to do so, which is followed by LLVM is to make calls which may throw exceptions into basic block terminators and add an explicit control flow edge to the catch handler:","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"invoke @function_that_may_throw() to label %regular unwind to %catch\n\nregular:\n# Control flow continues here\n\ncatch:\n# Exceptions go here","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"However, this is problematic in a language like julia where at the start of the optimization pipeline, we do not now which calls throw. We would have to conservatively assume that every call (which in julia is every statement) throws. This would have several negative effects.  On the one hand, it would essentially recuce the scope of every basic block to a single call, defeating the purpose of having operations be performed at the basic block level. On the other hand, every catch basic block would have n*m phi node arguments (n, the number of statements in the critical region, m the number of live values through the catch block). To work around this, we use a combination of Upsilon and PhiC (the C standing for catch, written φᶜ in the IR pretty printer, because unicode subscript c is not available) nodes. There is several ways to think of these nodes, but perhaps the easiest is to think of each PhiC as a load from a unique store-many, read-once slot, with Upsilon being the corresponding store operation. The PhiC has an operand list of all the upsilon nodes that store to its implicit slot. The Upsilon nodes however, do not record which PhiC node they store to. This is done for more natural integration with the rest of the SSA IR. E.g.  if there are no more uses of a PhiC node, it is safe to delete is and the same is true of an Upsilon node. In most IR passes, PhiC nodes can be treated similar to Phi nodes. One can follow use-def chains through them, and they can be lifted to new PhiC nodes and new Upsilon nodes (in the same places as the original Upsilon nodes). The result of this scheme is that the number of Upsilon nodes (and PhiC arguments) is proportional to the number of assigned values to a particular variable (before SSA conversion), rather than the number of statements in the critical region.","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"To see this scheme in action, consider the function","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"function foo()\n    x = 1\n    try\n        y = 2\n        error()\n    catch\n    end\n    (x, y)\nend","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"The corresponding IR (with irrelevant types stripped) is:","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"ir = Code\n1 ─       nothing\n2 ─       $(Expr(:enter, 5))\n3 ─ %3  = ϒ (#undef)\n│   %4  = ϒ (1)\n│   %5  = ϒ (2)\n│         Main.bar()\n│   %7  = ϒ (3)\n└──       $(Expr(:leave, 1))\n4 ─       goto 6\n5 ─ %10 = φᶜ (%3, %5)\n│   %11 = φᶜ (%4, %7)\n└──       $(Expr(:leave, 1))\n6 ┄ %13 = φ (4 => 2, 5 => %10)::NotInferenceDontLookHere.MaybeUndef(NotInferenceDontLookHere.Const(2, false))\n│   %14 = φ (4 => 3, 5 => %11)::Int64\n│         $(Expr(:undefcheck, :y, Core.SSAValue(13)))\n│   %16 = Core.tuple(%14, %13)\n└──       return %17","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"Note in particular that every value live into the critical region gets an upsilon node at the top of the critical region. This is because catch blocks are considered to have an invisible control flow edge from outside the function. As a result, no SSA value dominates the catch blocks, and all incoming values have to come through a φᶜ node.","category":"page"},{"location":"devdocs/ssair.html#Main-SSA-data-structure-1","page":"Julia SSA-form IR","title":"Main SSA data structure","text":"","category":"section"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"The main SSAIR data structure is worthy of discussion. It draws inspiration from LLVM and Webkit's B3 IR.  The core of the data structure is a flat vector of statements. Each statement is implicitly assigned an SSA values based on its position in the vector (i.e. the result of the statement at idx 1 can be accessed using SSAValue(1) etc). For each SSA value, we additionally maintain its type. Since, SSA values are definitionally assigned only once, this type is also the result type of the expression at the corresponding index. However, while this representation is rather efficient (since the assignments don't need to be explicitly)  encoded, if of course carries the drawback that order is semantically significant, so reorderings and insertions change statement numbers. Additionally, we do not keep use lists (i.e. it is impossible to walk from a def to all its uses without explicitly computing this map - def lists however are trivial since you can lookup the corresponding statement from the index), so the LLVM-style RAUW (replace-all-uses-with) operation is unavailable.","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"Instead, we do the following:","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"We keep a separate buffer of nodes to insert (including the position to insert them at, the type of the corresponding value and the node itself). These nodes are numbered by their occurrence in the insertion buffer, allowing their values to be immediately used elesewhere in the IR (i.e. if there is 12 statements in the original statement list, the first new statement will be accessible as SSAValue(13))\nRAUW style operations are performed by setting the corresponding statement index to the replacement value.\nStatements are erased by setting the corresponding statement to nothing (this is essentially just a special-case convention of the above\nif there are any uses of the statement being erased they will be set to nothing)","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"There is a compact! function that compacts the above data structure by performing the insertion of nodes in the appropriate place, trivial copy propagation and renaming of uses to any changed SSA values. However, the clever part of this scheme is that this compaction can be done lazily as part of the subsequent pass. Most optimization passes need to walk over the entire list of statements, performing analysis or modifications along the way. We provide an IncrementalCompact iterator that can be used to iterate over the statement list. It will perform any necessary compaction, and return the new index of the node, as well as the node itself. It is legal at this point to walk def-use chains, as well as make any modifications or deletions to the IR (insertions are disallowed however).","category":"page"},{"location":"devdocs/ssair.html#","page":"Julia SSA-form IR","title":"Julia SSA-form IR","text":"The idea behind this arrangement is that, since the optimization passes need to touch the corresponding memory anyway, and incur the corresponding memory access penalty, performing the extra housekeeping should have comparatively little overhead (and save the overhead of maintaining these data structures during IR modification).","category":"page"},{"location":"devdocs/gc-sa.html#Static-analyzer-annotations-for-GC-correctness-in-C-code-1","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"","category":"section"},{"location":"devdocs/gc-sa.html#General-Overview-1","page":"Static analyzer annotations for GC correctness in C code","title":"General Overview","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"Since Julia's GC is precise, it needs to maintain correct rooting information for any value that may be referenced at any time GC may occur. These places are known as safepoints and in the function local context, we extend this designation to any function call that may recursively end up at a safepoint.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"In generated code, this is taken care of automatically by the GC root placement pass (see the chapter on GC rooting in the LLVM codegen devdocs). However, in C code, we need to inform the runtime of any GC roots manually. This is done using the following macros:","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"// The value assigned to any slot passed as an argument to these\n// is rooted for the duration of this GC frame.\nJL_GC_PUSH{1,...,6}(args...)\n// The values assigned into the size `n` array `rts` are rooted\n// for the duration of this GC frame.\nJL_GC_PUSHARGS(rts, n)\n// Pop a GC frame\nJL_GC_POP","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"If these macros are not used where they need to be, or they are used incorrectly, the result is silent memory corruption. As such it is very important that they are placed correctly in all applicable code.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"As such, we employ static analysis (and in particular the clang static analyzer) to help ensure that these macros are used correctly. The remainder of this document gives an overview of this static analysis and describes the support needed in the julia code base to make things work.","category":"page"},{"location":"devdocs/gc-sa.html#GC-Invariants-1","page":"Static analyzer annotations for GC correctness in C code","title":"GC Invariants","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"There is two simple invariants correctness:","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"All GCPUSH calls need to be followed by an appropriate GCPOP (in practice we enforce this at the function level)\nIf a value was previously not rooted at any safepoint, it may no longer be referenced afterwards","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"Of course the devil is in the details here. In particular to satisfy the second of the above conditions, we need to know: - Which calls are safepoints and which are not - Which values are rooted at any given safepoint and which are not - When is a value referenced","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"For the second point in particular, we need to know which memory locations will be considered rooting at runtime (i.e. values assigned to such locations are rooted). This includes locations explicitly designated as such by passing them to one of the GC_PUSH macros, globally rooted locations and values, as well as any location recursively reachable from one of those locations.","category":"page"},{"location":"devdocs/gc-sa.html#Static-Analysis-Algorithm-1","page":"Static analyzer annotations for GC correctness in C code","title":"Static Analysis Algorithm","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"The idea itself is very simple, although the implementation is quite a bit more complicated (mainly due to a large number of special cases and intricacies of C and C++). In essence, we keep track of all locations that are rooting, all values that are rootable and any expression (assignments, allocations, etc) affect the rootedness of any rootable values.  Then, at any safepoint, we perform a \"symbolic GC\" and poison any values that are not rooted at said location. If these values are later referenced, we emit an error.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"The clang static analyzer works by constructing a graph of states and exploring this graph for sources of errors. Several nodes in this graph are generated by the analyzer itself (e.g. for control flow), but the definitions above augment this graph with our own state.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"The static analyzer is interprocedural and can analyze control flow across function boundaries.  However, the static analyzer is not fully recursive and makes heuristic decisions about which calls to explore (additionally some calls are cross-translation unit and invisible to the analyzer).  In our case, our definition of correctness requires total information.  As such, we need to annotate the prototypes of all function calls with whatever information the analysis required, even if that information would otherwise be available by interprocedural static analysis.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"Luckily however, we can still use this interprocedural analysis to ensure that the annotations we place on a given function are indeed correct given the implementation of said function.","category":"page"},{"location":"devdocs/gc-sa.html#The-analyzer-annotations-1","page":"Static analyzer annotations for GC correctness in C code","title":"The analyzer annotations","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"These annotations are found in src/support/analyzer_annotations.h.  The are only active when the analyzer is being used and expand either to nothing (for prototype annotations) or to no-ops (for function like annotations).","category":"page"},{"location":"devdocs/gc-sa.html#JL_NOTSAFEPOINT-1","page":"Static analyzer annotations for GC correctness in C code","title":"JL_NOTSAFEPOINT","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"This is perhaps the most common annotation, and should be placed on any function that is known not to possibly lead to reaching a GC safepoint. In general, it is only safe for such a function to perform arithmetic, memory accesses and calls to functions either annotated JL_NOTSAFEPOINT or otherwise known not to be safepoints (e.g.  function in the C standard library, which are hardcoded as such in the analyzer)","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"It is valid to keep values unrooted across calls to any function annotated with this attribute:","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"Usage Example:","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"void jl_get_one() JL_NOTSAFEPOINT {\n  return 1;\n}\n\njl_value_t *example() {\n  jl_value_t *val = jl_alloc_whatever();\n  // This is valid, even though `val` is unrooted, because\n  // jl_get_one is not a safepoint\n  jl_get_one();\n  return val;\n}","category":"page"},{"location":"devdocs/gc-sa.html#JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY-1","page":"Static analyzer annotations for GC correctness in C code","title":"JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"When JL_MAYBE_UNROOTED is annotated as an argument on a function, indicates that said argument may be passed, even if it is not rooted.  In the ordinary course of events, the julia ABI guarantees that callers root values before passing them to callees. However, some functions do not follow this ABI and allow values to be passed to them even though they are not rooted. Note however, that this does not automatically imply that said argument will be preserved.  The ROOTS_TEMPORARILY annotation provides the stronger guarantee that, not only may the value be unrooted when passed, it will also be preserved across any internal safepoints by the callee.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"Note that JL_NOTSAFEPOINT essentially implies JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY, because the rootedness of an argument is irrelevant if the function contains no safepoints.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"One additional point to note is that these annotations apply on both the caller and the callee side. On the caller side, they lift rootedness restrictions that are normally required for julia ABI functions. On the callee side, they have the reverse effect of preventing these arguments from being considered implicitly rooted.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"If either of these annotations is applied to the function as a whole, it applies to all arguments of the function. This should generally only be necessary for varargs functions.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"Usage example:","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"JL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e JL_MAYBE_UNROOTED);\njl_value_t *jl_alloc_error();\n\nvoid example() {\n  // The return value of the allocation is unrooted. This would normally\n  // be an error, but is allowed because of the above annotation.\n  jl_throw(jl_alloc_error());\n}","category":"page"},{"location":"devdocs/gc-sa.html#JL_PROPAGATES_ROOT-1","page":"Static analyzer annotations for GC correctness in C code","title":"JL_PROPAGATES_ROOT","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"This annotation is commonly found on accessor functions that return one rootable object stored within another. When annotated on a function argument, it tells the analyzer that the root for that argument also applies to the value returned by the function.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"Usage Example:","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"jl_value_t *jl_svecref(jl_svec_t *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;\n\nsize_t example(jl_svec_t *svec) {\n  jl_value_t *val = jl_svecref(svec, 1)\n  // This is valid, because, as annotated by the PROPAGATES_ROOT annotation,\n  // jl_svecref propagates the rooted-ness from `svec` to `val`\n  jl_gc_safepoint();\n  return jl_unbox_long(val);\n}","category":"page"},{"location":"devdocs/gc-sa.html#JL_ROOTING_ARGUMENT/JL_ROOTED_ARGUMENT-1","page":"Static analyzer annotations for GC correctness in C code","title":"JL_ROOTING_ARGUMENT/JL_ROOTED_ARGUMENT","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"This is essentially the assignment counterpart to JL_PROPAGATES_ROOT. When assigning a value to a field of another value that is already rooted, the assigned value will inherit the root of the value it is assigned into.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"Usage Example:","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"void jl_svecset(void *t JL_ROOTING_ARGUMENT, size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT\n\n\nsize_t example(jl_svec_t *svec) {\n  jl_value_t *val = jl_box_long(10000);\n  jl_svecset(svec, val);\n  // This is valid, because the annotations imply that the\n  // jl_svecset propagates the rooted-ness from `svec` to `val`\n  jl_gc_safepoint();\n  return jl_unbox_long(val);\n}","category":"page"},{"location":"devdocs/gc-sa.html#JL_GC_DISABLED-1","page":"Static analyzer annotations for GC correctness in C code","title":"JL_GC_DISABLED","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"This annotation implies that this function is only called with the GC runtime-disabled.  Functions of this kind are most often encountered during startup and in the GC code itself.  Note that this annotation is checked against the runtime enable/disable calls, so clang will know if you lie. This is not a good way to disable processing of a given function if the GC is not actually disabled (use ifdef __clang_analyzer__ for that if you must).","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"Usage example:","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"void jl_do_magic() JL_GC_DISABLED {\n  // Wildly allocate here with no regard for roots\n}\n\nvoid example() {\n  int en = jl_gc_enable(0);\n  jl_do_magic();\n  jl_gc_enable(en);\n}","category":"page"},{"location":"devdocs/gc-sa.html#JL_REQUIRE_ROOTED_SLOT-1","page":"Static analyzer annotations for GC correctness in C code","title":"JL_REQUIRE_ROOTED_SLOT","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"This annotation requires the caller to pass in a slot that is rooted (i.e. values assigned to this slot will be rooted).","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"Usage example:","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"void jl_do_processing(jl_value_t **slot JL_REQUIRE_ROOTED_SLOT) {\n  *slot = jl_box_long(1);\n  // Ok, only, because the slot was annotated as rooting\n  jl_gc_safepoint();\n}\n\nvoid example() {\n  jl_value_t *slot = NULL;\n  JL_GC_PUSH1(&slot);\n  jl_do_processing(&slot);\n  JL_GC_POP();\n}","category":"page"},{"location":"devdocs/gc-sa.html#JL_GLOBALLY_ROOTED-1","page":"Static analyzer annotations for GC correctness in C code","title":"JL_GLOBALLY_ROOTED","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"This annotation implies that a given value is always globally rooted.  It can be applied to global variable declarations, in which case it will apply to the value of those variables (or values if the declaration if for an array), or to functions, in which case it will apply to the return value of such functions (e.g. for functions that always return some private, globally rooted value).","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"Usage example:","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"extern JL_DLLEXPORT jl_datatype_t *jl_any_type JL_GLOBALLY_ROOTED;\njl_ast_context_t *jl_ast_ctx(fl_context_t *fl) JL_GLOBALLY_ROOTED;","category":"page"},{"location":"devdocs/gc-sa.html#JL_ALWAYS_LEAFTYPE-1","page":"Static analyzer annotations for GC correctness in C code","title":"JL_ALWAYS_LEAFTYPE","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"This annotations is essentially equivalent to JL_GLOBALLY_ROOTED, except that is should only be used if those values are globally rooted by virtue of being a leaftype. The rooting of leaftypes is a bit complicated. They are generally rooted through cache field of the corresponding TypeName, which itself is rooted by the containing module (so they're rooted as long as the containing module is ok) and we can generally assume that leaftypes are rooted where they are used, but we may refine this property in the future, so the separate annotation helps split out the reason for being globally rooted.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"The analyzer also automatically detects checks for leaftype-ness and will not complain about missing GC roots on these paths.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"JL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_value_t *type, size_t dim) JL_ALWAYS_LEAFTYPE;","category":"page"},{"location":"devdocs/gc-sa.html#JL_GC_PROMISE_ROOTED-1","page":"Static analyzer annotations for GC correctness in C code","title":"JL_GC_PROMISE_ROOTED","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"This is a function-like annotation. Any value passed to this annotation will be considered rooted for the scope of the current function. It is designed as an escape hatch for analyzer inadequacy or complicated situations. However, it should be used sparingly, in favor of improving the analyzer itself.","category":"page"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"void example() {\n  jl_value_t *val = jl_alloc_something();\n  if (some_condition) {\n    // We happen to know for complicated external reasons\n    // that val is rooted under these conditions\n    JL_GC_PROMISE_ROOTED(val);\n  }\n}","category":"page"},{"location":"devdocs/gc-sa.html#Completeness-of-analysis-1","page":"Static analyzer annotations for GC correctness in C code","title":"Completeness of analysis","text":"","category":"section"},{"location":"devdocs/gc-sa.html#","page":"Static analyzer annotations for GC correctness in C code","title":"Static analyzer annotations for GC correctness in C code","text":"The analyzer only looks at local information. In particular, e.g. in the PROPAGATES_ROOT case above, it assumes that such memory is only modified in ways it can see, not in any called functions (unless it happens to decide to consider them in its analysis) and not in any concurrently running threads. As such, it may miss a few problematic cases, though in practice such concurrent modification is fairly rare. Improving the analyzer to handle more such cases may be an interesting topic for future work.","category":"page"},{"location":"devdocs/backtraces.html#クラッシュ(セグメンテーションフォルト)の報告と分析-1","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"","category":"section"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"Julia を壊した?おめでとうございます! 何かおかしいことが起きた時によく遭遇する症状に対する一般的な手順をここに集めました。セグメンテーションフォールトを追跡したり、あなたのスクリプトが予想よりも遅い理由を突き止める際には、ここで述べるデバッグ手順から得られる情報を含めて報告すると、メンテナは大いに助かるでしょう。","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"もしあなたが、このページを見るように、と言われたのであれば、今直面している問題に最も一致する現象を見つけて、このページに書かれた指示に従って、要求されたデバッグ情報を生成してください。現象の一覧は下記の通りです:","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"ブートストラップ(sysimg.jl)中のセグメンテーションフォルト\nスクリプトの実行時のセグフォールト\nJulia起動中のエラー","category":"page"},{"location":"devdocs/backtraces.html#dev-version-info-1","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"バージョン情報/環境情報","text":"","category":"section"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"エラーの内容に関係なく、常に、実行しているJulia のバージョンを知る必要があります。Julia が最初に起動すると、ヘッダーにバージョン番号と日付が出力されます。また、作成するレポートには、versioninfo()(InteractiveUtils 標準ライブラリからエクスポートされています) の出力を含めてください:","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"using InteractiveUtils\nversioninfo()","category":"page"},{"location":"devdocs/backtraces.html#Segfaults-during-bootstrap-(sysimg.jl)-1","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"ブートストラップ(sysimg.jl)中のセグメンテーションフォルト","text":"","category":"section"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"Julia をビルドする make プロセスの終盤でのセグメンテーションフォールトは、一般的な症状です。Julia がbase/フォルダ内のコードのコーパスを事前解析している間に何かがおかしいことが起きたりします。 プロセスが突然落ちてしまう原因には、多くの要因が考えられますが、どちらかというと、Julia の C コード部分のエラーが原因であることが多く、通常は gdb のデバッグビルドでデバッグしなければならないことが多いです。デバッグビルドを作るには明示的に：","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"Julia のデバッグビルドを作成します:","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"$ cd <julia_root>\n$ make debug","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"このデバッグビルドのプロセスは、通常のmake と同じエラーで失敗する可能性がありますが、(そうならなければ) 正確なバックトレースをするために必要なデバッグシンボルを gdbに提供する、デバッグ用実行可能ファイルが作成されます。 次に、gdb内でブートストラッププロセスを手動で実行します:","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"$ cd base/\n$ gdb -x ../contrib/debug_bootstrap.gdb","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"このコマンドで、gdbを開始し、Julia のデバッグビルドを使用したブートストラッププロセスを実行しようとし、もしセグメンテーションフォルトが起きれば、バックトーレスの結果を出力します。全ての出力を得るには、なんどか <enter>キーを押す必要があるかもしれません。こうして得られたバックトレースと、バージョン情報、その他関連情報をまとめた gist を作成して、Github の issue をオープンし、作成したgistへのリンクを貼ってください。","category":"page"},{"location":"devdocs/backtraces.html#segfaults-when-running-a-script-1","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"スクリプトの実行時のセグフォールト","text":"","category":"section"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"この手順は、スクリプトの実行時のセグフォールトに非常によく似ています。 Julia のデバッグ ビルドを作成し、デバッグされた Julia プロセス内でスクリプトを実行します:","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"$ cd <julia_root>\n$ make debug\n$ gdb --args usr/bin/julia-debug <path_to_your_script>","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"gdb は起動しただけでは何もしません。ただ命令を待っている状態です。r と打って、プロセスを実行します。btでセグメンテーションフォルトが発生した時に、バックトレースを生成します:","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"(gdb) r\nStarting program: /home/sabae/src/julia/usr/bin/julia-debug ./test.jl\n...\n(gdb) bt","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"得られたバックトーレスの内容、バージョン情報、その他関連情報をまとめて、gist を作成して、Github の issue をオープンし作成したgistへのリンクを貼ってください。","category":"page"},{"location":"devdocs/backtraces.html#errors-during-julia-startup-1","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"Julia起動中のエラー","text":"","category":"section"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"Julia の起動中 (ソースからコンパイルしたものでなく、特にバイナリ配布されているもの実行したとき)に時々エラーが起きます。例えば下記の様なものです:","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"$ julia\nexec: error -5","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"このようなエラーの典型的な原因は、Julia 起動のごくごく初期段階で、何かが正しくロードされていないことだったりします。何が悪いかを判断するのに最もおすすめなのは、Julia processがディスクにどうアクセスしているかを監査する外部ツールを使うことです:","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"Linux では strace を使います:\n$ strace julia\nOSX(Mac)では、dtruss を使います:\n$ dtruss -f julia","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"strace/dtrussの出力、バージョン情報、その他関連情報をまとめて、gist を作成して、Github の issue をオープンし作成したgistへのリンクを貼ってください。","category":"page"},{"location":"devdocs/backtraces.html#用語集-1","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"用語集","text":"","category":"section"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"このガイドとしては、いくつかの用語が短縮記号として使われている:","category":"page"},{"location":"devdocs/backtraces.html#","page":"クラッシュ(セグメンテーションフォルト)の報告と分析","title":"クラッシュ(セグメンテーションフォルト)の報告と分析","text":"<julia_root> は、Julia のソースツリーのルートディレクトリを指すものです; すなわち、base, deps, src, test, などのフォルダーを含んでいるはずです。","category":"page"},{"location":"devdocs/debuggingtips.html#gdb-debugging-tips-1","page":"gdb debugging tips","title":"gdb debugging tips","text":"","category":"section"},{"location":"devdocs/debuggingtips.html#Displaying-Julia-variables-1","page":"gdb debugging tips","title":"Displaying Julia variables","text":"","category":"section"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Within gdb, any jl_value_t* object obj can be displayed using","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(gdb) call jl_(obj)","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"The object will be displayed in the julia session, not in the gdb session. This is a useful way to discover the types and values of objects being manipulated by Julia's C code.","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Similarly, if you're debugging some of Julia's internals (e.g., compiler.jl), you can print obj using","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"ccall(:jl_, Cvoid, (Any,), obj)","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"This is a good way to circumvent problems that arise from the order in which julia's output streams are initialized.","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Julia's flisp interpreter uses value_t objects; these can be displayed with call fl_print(fl_ctx, ios_stdout, obj).","category":"page"},{"location":"devdocs/debuggingtips.html#Useful-Julia-variables-for-Inspecting-1","page":"gdb debugging tips","title":"Useful Julia variables for Inspecting","text":"","category":"section"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"While the addresses of many variables, like singletons, can be be useful to print for many failures, there are a number of additional variables (see julia.h for a complete list) that are even more useful.","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(when in jl_apply_generic) mfunc and jl_uncompress_ast(mfunc->def, mfunc->code) :: for figuring out a bit about the call-stack\njl_lineno and jl_filename :: for figuring out what line in a test to go start debugging from (or figure out how far into a file has been parsed)\n$1 :: not really a variable, but still a useful shorthand for referring to the result of the last gdb command (such as print)\njl_options :: sometimes useful, since it lists all of the command line options that were successfully parsed\njl_uv_stderr :: because who doesn't like to be able to interact with stdio","category":"page"},{"location":"devdocs/debuggingtips.html#Useful-Julia-functions-for-Inspecting-those-variables-1","page":"gdb debugging tips","title":"Useful Julia functions for Inspecting those variables","text":"","category":"section"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"jl_gdblookup($rip) :: For looking up the current function and line. (use $eip on i686 platforms)\njlbacktrace() :: For dumping the current Julia backtrace stack to stderr. Only usable after record_backtrace() has been called.\njl_dump_llvm_value(Value*) :: For invoking Value->dump() in gdb, where it doesn't work natively.  For example, f->linfo->functionObject, f->linfo->specFunctionObject, and to_function(f->linfo).\nType->dump() :: only works in lldb. Note: add something like ;1 to prevent lldb from printing its prompt over the output\njl_eval_string(\"expr\") :: for invoking side-effects to modify the current state or to lookup symbols\njl_typeof(jl_value_t*) :: for extracting the type tag of a Julia value (in gdb, call macro define jl_typeof jl_typeof first, or pick something short like ty for the first arg to define a shorthand)","category":"page"},{"location":"devdocs/debuggingtips.html#Inserting-breakpoints-for-inspection-from-gdb-1","page":"gdb debugging tips","title":"Inserting breakpoints for inspection from gdb","text":"","category":"section"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"In your gdb session, set a breakpoint in jl_breakpoint like so:","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(gdb) break jl_breakpoint","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Then within your Julia code, insert a call to jl_breakpoint by adding","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"ccall(:jl_breakpoint, Cvoid, (Any,), obj)","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"where obj can be any variable or tuple you want to be accessible in the breakpoint.","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"It's particularly helpful to back up to the jl_apply frame, from which you can display the arguments to a function using, e.g.,","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(gdb) call jl_(args[0])","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Another useful frame is to_function(jl_method_instance_t *li, bool cstyle). The jl_method_instance_t* argument is a struct with a reference to the final AST sent into the compiler. However, the AST at this point will usually be compressed; to view the AST, call jl_uncompress_ast and then pass the result to jl_:","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"#2  0x00007ffff7928bf7 in to_function (li=0x2812060, cstyle=false) at codegen.cpp:584\n584          abort();\n(gdb) p jl_(jl_uncompress_ast(li, li->ast))","category":"page"},{"location":"devdocs/debuggingtips.html#Inserting-breakpoints-upon-certain-conditions-1","page":"gdb debugging tips","title":"Inserting breakpoints upon certain conditions","text":"","category":"section"},{"location":"devdocs/debuggingtips.html#Loading-a-particular-file-1","page":"gdb debugging tips","title":"Loading a particular file","text":"","category":"section"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Let's say the file is sysimg.jl:","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(gdb) break jl_load if strcmp(fname, \"sysimg.jl\")==0","category":"page"},{"location":"devdocs/debuggingtips.html#Calling-a-particular-method-1","page":"gdb debugging tips","title":"Calling a particular method","text":"","category":"section"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(gdb) break jl_apply_generic if strcmp((char*)(jl_symbol_name)(jl_gf_mtable(F)->name), \"method_to_break\")==0","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Since this function is used for every call, you will make everything 1000x slower if you do this.","category":"page"},{"location":"devdocs/debuggingtips.html#Dealing-with-signals-1","page":"gdb debugging tips","title":"Dealing with signals","text":"","category":"section"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Julia requires a few signal to function property. The profiler uses SIGUSR2 for sampling and the garbage collector uses SIGSEGV for threads synchronization. If you are debugging some code that uses the profiler or multiple threads, you may want to let the debugger ignore these signals since they can be triggered very often during normal operations. The command to do this in GDB is (replace SIGSEGV with SIGUSRS or other signals you want to ignore):","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(gdb) handle SIGSEGV noprint nostop pass","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"The corresponding LLDB command is (after the process is started):","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(lldb) pro hand -p true -s false -n false SIGSEGV","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"If you are debugging a segfault with threaded code, you can set a breakpoint on jl_critical_error (sigdie_handler should also work on Linux and BSD) in order to only catch the actual segfault rather than the GC synchronization points.","category":"page"},{"location":"devdocs/debuggingtips.html#Debugging-during-Julia's-build-process-(bootstrap)-1","page":"gdb debugging tips","title":"Debugging during Julia's build process (bootstrap)","text":"","category":"section"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Errors that occur during make need special handling. Julia is built in two stages, constructing sys0 and sys.ji. To see what commands are running at the time of failure, use make VERBOSE=1.","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"At the time of this writing, you can debug build errors during the sys0 phase from the base directory using:","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys0 sysimg.jl","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"You might need to delete all the files in usr/lib/julia/ to get this to work.","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"You can debug the sys.ji phase using:","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys -J ../usr/lib/julia/sys0.ji sysimg.jl","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"By default, any errors will cause Julia to exit, even under gdb. To catch an error \"in the act\", set a breakpoint in jl_error (there are several other useful spots, for specific kinds of failures, including: jl_too_few_args, jl_too_many_args, and jl_throw).","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Once an error is caught, a useful technique is to walk up the stack and examine the function by inspecting the related call to jl_apply. To take a real-world example:","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Breakpoint 1, jl_throw (e=0x7ffdf42de400) at task.c:802\n802 {\n(gdb) p jl_(e)\nErrorException(\"auto_unbox: unable to determine argument type\")\n$2 = void\n(gdb) bt 10\n#0  jl_throw (e=0x7ffdf42de400) at task.c:802\n#1  0x00007ffff65412fe in jl_error (str=0x7ffde56be000 <_j_str267> \"auto_unbox:\n   unable to determine argument type\")\n   at builtins.c:39\n#2  0x00007ffde56bd01a in julia_convert_16886 ()\n#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281\n...","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"The most recent jl_apply is at frame #3, so we can go back there and look at the AST for the function julia_convert_16886. This is the uniqued name for some method of convert. f in this frame is a jl_function_t*, so we can look at the type signature, if any, from the specTypes field:","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(gdb) f 3\n#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281\n1281            return f->fptr((jl_value_t*)f, args, nargs);\n(gdb) p f->linfo->specTypes\n$4 = (jl_tupletype_t *) 0x7ffdf39b1030\n(gdb) p jl_( f->linfo->specTypes )\nTuple{Type{Float32}, Float64}           # <-- type signature for julia_convert_16886","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Then, we can look at the AST for this function:","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(gdb) p jl_( jl_uncompress_ast(f->linfo, f->linfo->ast) )\nExpr(:lambda, Array{Any, 1}[:#s29, :x], Array{Any, 1}[Array{Any, 1}[], Array{Any, 1}[Array{Any, 1}[:#s29, :Any, 0], Array{Any, 1}[:x, :Any, 0]], Array{Any, 1}[], 0], Expr(:body,\nExpr(:line, 90, :float.jl)::Any,\nExpr(:return, Expr(:call, :box, :Float32, Expr(:call, :fptrunc, :Float32, :x)::Any)::Any)::Any)::Any)::Any","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Finally, and perhaps most usefully, we can force the function to be recompiled in order to step through the codegen process. To do this, clear the cached functionObject from the jl_lamdbda_info_t*:","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(gdb) p f->linfo->functionObject\n$8 = (void *) 0x1289d070\n(gdb) set f->linfo->functionObject = NULL","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Then, set a breakpoint somewhere useful (e.g. emit_function, emit_expr, emit_call, etc.), and run codegen:","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(gdb) p jl_compile(f)\n... # your breakpoint here","category":"page"},{"location":"devdocs/debuggingtips.html#Debugging-precompilation-errors-1","page":"gdb debugging tips","title":"Debugging precompilation errors","text":"","category":"section"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Module precompilation spawns a separate Julia process to precompile each module. Setting a breakpoint or catching failures in a precompile worker requires attaching a debugger to the worker. The easiest approach is to set the debugger watch for new process launches matching a given name. For example:","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(gdb) attach -w -n julia-debug","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"or:","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"(lldb) process attach -w -n julia-debug","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Then run a script/command to start precompilation. As described earlier, use conditional breakpoints in the parent process to catch specific file-loading events and narrow the debugging window. (some operating systems may require alternative approaches, such as following each fork from the parent process)","category":"page"},{"location":"devdocs/debuggingtips.html#Mozilla's-Record-and-Replay-Framework-(rr)-1","page":"gdb debugging tips","title":"Mozilla's Record and Replay Framework (rr)","text":"","category":"section"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"Julia now works out of the box with rr, the lightweight recording and deterministic debugging framework from Mozilla. This allows you to replay the trace of an execution deterministically.  The replayed execution's address spaces, register contents, syscall data etc are exactly the same in every run.","category":"page"},{"location":"devdocs/debuggingtips.html#","page":"gdb debugging tips","title":"gdb debugging tips","text":"A recent version of rr (3.1.0 or higher) is required.","category":"page"},{"location":"devdocs/valgrind.html#Using-Valgrind-with-Julia-1","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"","category":"section"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"Valgrind is a tool for memory debugging, memory leak detection, and profiling.  This section describes things to keep in mind when using Valgrind to debug memory issues with Julia.","category":"page"},{"location":"devdocs/valgrind.html#General-considerations-1","page":"Using Valgrind with Julia","title":"General considerations","text":"","category":"section"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"By default, Valgrind assumes that there is no self modifying code in the programs it runs.  This assumption works fine in most instances but fails miserably for a just-in-time compiler like julia.  For this reason it is crucial to pass --smc-check=all-non-file to valgrind, else code may crash or behave unexpectedly (often in subtle ways).","category":"page"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"In some cases, to better detect memory errors using Valgrind it can help to compile julia with memory pools disabled.  The compile-time flag MEMDEBUG disables memory pools in Julia, and MEMDEBUG2 disables memory pools in FemtoLisp.  To build julia with both flags, add the following line to Make.user:","category":"page"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"CFLAGS = -DMEMDEBUG -DMEMDEBUG2","category":"page"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"Another thing to note: if your program uses multiple workers processes, it is likely that you want all such worker processes to run under Valgrind, not just the parent process.  To do this, pass --trace-children=yes to valgrind.","category":"page"},{"location":"devdocs/valgrind.html#Suppressions-1","page":"Using Valgrind with Julia","title":"Suppressions","text":"","category":"section"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"Valgrind will typically display spurious warnings as it runs.  To reduce the number of such warnings, it helps to provide a suppressions file to Valgrind.  A sample suppressions file is included in the Julia source distribution at contrib/valgrind-julia.supp.","category":"page"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"The suppressions file can be used from the julia/ source directory as follows:","category":"page"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"$ valgrind --smc-check=all-non-file --suppressions=contrib/valgrind-julia.supp ./julia progname.jl","category":"page"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"Any memory errors that are displayed should either be reported as bugs or contributed as additional suppressions.  Note that some versions of Valgrind are shipped with insufficient default suppressions, so that may be one thing to consider before submitting any bugs.","category":"page"},{"location":"devdocs/valgrind.html#Running-the-Julia-test-suite-under-Valgrind-1","page":"Using Valgrind with Julia","title":"Running the Julia test suite under Valgrind","text":"","category":"section"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"It is possible to run the entire Julia test suite under Valgrind, but it does take quite some time (typically several hours).  To do so, run the following command from the julia/test/ directory:","category":"page"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"valgrind --smc-check=all-non-file --trace-children=yes --suppressions=$PWD/../contrib/valgrind-julia.supp ../julia runtests.jl all","category":"page"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"If you would like to see a report of \"definite\" memory leaks, pass the flags --leak-check=full --show-leak-kinds=definite to valgrind as well.","category":"page"},{"location":"devdocs/valgrind.html#Caveats-1","page":"Using Valgrind with Julia","title":"Caveats","text":"","category":"section"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"Valgrind currently does not support multiple rounding modes, so code that adjusts the rounding mode will behave differently when run under Valgrind.","category":"page"},{"location":"devdocs/valgrind.html#","page":"Using Valgrind with Julia","title":"Using Valgrind with Julia","text":"In general, if after setting --smc-check=all-non-file you find that your program behaves differently when run under Valgrind, it may help to pass --tool=none to valgrind as you investigate further.  This will enable the minimal Valgrind machinery but will also run much faster than when the full memory checker is enabled.","category":"page"},{"location":"devdocs/sanitizers.html#Sanitizer-support-1","page":"Sanitizer support","title":"Sanitizer support","text":"","category":"section"},{"location":"devdocs/sanitizers.html#General-considerations-1","page":"Sanitizer support","title":"General considerations","text":"","category":"section"},{"location":"devdocs/sanitizers.html#","page":"Sanitizer support","title":"Sanitizer support","text":"Using Clang's sanitizers obviously require you to use Clang (USECLANG=1), but there's another catch: most sanitizers require a run-time library, provided by the host compiler, while the instrumented code generated by Julia's JIT relies on functionality from that library. This implies that the LLVM version of your host compiler matches that of the LLVM library used within Julia.","category":"page"},{"location":"devdocs/sanitizers.html#","page":"Sanitizer support","title":"Sanitizer support","text":"An easy solution is to have an dedicated build folder for providing a matching toolchain, by building with BUILD_LLVM_CLANG=1. You can then refer to this toolchain from another build folder by specifying USECLANG=1 while overriding the CC and CXX variables.","category":"page"},{"location":"devdocs/sanitizers.html#Address-Sanitizer-(ASAN)-1","page":"Sanitizer support","title":"Address Sanitizer (ASAN)","text":"","category":"section"},{"location":"devdocs/sanitizers.html#","page":"Sanitizer support","title":"Sanitizer support","text":"For detecting or debugging memory bugs, you can use Clang's address sanitizer (ASAN).  By compiling with SANITIZE=1 you enable ASAN for the Julia compiler and its generated code.  In addition, you can specify LLVM_SANITIZE=1 to sanitize the LLVM library as well. Note that these options incur a high performance and memory cost. For example, using ASAN for Julia and LLVM makes testall1 takes 8-10 times as long while using 20 times as much memory (this can be reduced to respectively a factor of 3 and 4 by using the options described below).","category":"page"},{"location":"devdocs/sanitizers.html#","page":"Sanitizer support","title":"Sanitizer support","text":"By default, Julia sets the allow_user_segv_handler=1 ASAN flag, which is required for signal delivery to work properly. You can define other options using the ASAN_OPTIONS environment flag, in which case you'll need to repeat the default option mentioned before. For example, memory usage can be reduced by specifying fast_unwind_on_malloc=0 and malloc_context_size=2, at the cost of backtrace accuracy. For now, Julia also sets detect_leaks=0, but this should be removed in the future.","category":"page"},{"location":"devdocs/sanitizers.html#Memory-Sanitizer-(MSAN)-1","page":"Sanitizer support","title":"Memory Sanitizer (MSAN)","text":"","category":"section"},{"location":"devdocs/sanitizers.html#","page":"Sanitizer support","title":"Sanitizer support","text":"For detecting use of uninitialized memory, you can use Clang's memory sanitizer (MSAN)  by compiling with SANITIZE_MEMORY=1.","category":"page"}]
}
