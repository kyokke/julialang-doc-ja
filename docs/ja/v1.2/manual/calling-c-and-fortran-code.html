<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>C, Fortran コードの呼び出し · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">はじめよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">モジュール</a></li><li><a class="toctext" href="documentation.html">ドキュメンテーション</a></li><li><a class="toctext" href="metaprogramming.html">メタプログラミング</a></li><li><a class="toctext" href="arrays.html">多次元配列</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">ネットワークとストリーム</a></li><li><a class="toctext" href="parallel-computing.html">並列コンピューティング</a></li><li><a class="toctext" href="running-external-programs.html">外部プログラムの実行</a></li><li class="current"><a class="toctext" href="calling-c-and-fortran-code.html">C, Fortran コードの呼び出し</a><ul class="internal"><li><a class="toctext" href="#C言語コンパチな-Julia関数のポインタをつくる-1">C言語コンパチな Julia関数のポインタをつくる</a></li><li><a class="toctext" href="#Mapping-C-Types-to-Julia-1">Mapping C Types to Julia</a></li><li><a class="toctext" href="#Mapping-C-Functions-to-Julia-1">Mapping C Functions to Julia</a></li><li><a class="toctext" href="#Some-Examples-of-C-Wrappers-1">Some Examples of C Wrappers</a></li><li><a class="toctext" href="#Garbage-Collection-Safety-1">Garbage Collection Safety</a></li><li><a class="toctext" href="#Non-constant-Function-Specifications-1">Non-constant Function Specifications</a></li><li><a class="toctext" href="#Indirect-Calls-1">Indirect Calls</a></li><li><a class="toctext" href="#Closure-cfunctions-1">Closure cfunctions</a></li><li><a class="toctext" href="#Closing-a-Library-1">Closing a Library</a></li><li><a class="toctext" href="#Calling-Convention-1">Calling Convention</a></li><li><a class="toctext" href="#Accessing-Global-Variables-1">Accessing Global Variables</a></li><li><a class="toctext" href="#Accessing-Data-through-a-Pointer-1">Accessing Data through a Pointer</a></li><li><a class="toctext" href="#Thread-safety-1">Thread-safety</a></li><li><a class="toctext" href="#More-About-Callbacks-1">More About Callbacks</a></li><li><a class="toctext" href="#C-1">C++</a></li></ul></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Julia の埋め込み</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">プロファイリング</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">パフォーマンス・ティップス</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">スタイルガイド</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">他の言語との注目すべき違い</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">リフレクションとインストロスペクション</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Julia ランタイムの初期化</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">システムイメージのビルド</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li><li><a class="toctext" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="toctext" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">クラッシュ(セグメンテーションフォルト)の報告と分析</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="calling-c-and-fortran-code.html">C, Fortran コードの呼び出し</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>C, Fortran コードの呼び出し</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Calling-C-and-Fortran-Code-1" href="#Calling-C-and-Fortran-Code-1">C, Fortran コードの呼び出し</a></h1><p>ほとんどのコードは Julia で記述できますが、C と Fortran で既に記述されている数値計算用の高品質で成熟したライブラリが多数あります。この既存のコードを簡単に使用できるように、Julia は C 関数と Fortran 関数を簡単かつ効率的に呼び出すことができます。Julia は「定型文なし」の哲学を持っています:関数は「接着剤」コードやコード生成もしくはコンパイルなしでJulia から直接呼び出すことができます。– 対話プロンプトからでも、です。通常の関数呼び出しのように見える <a href="../base/c.html#ccall"><code>ccall</code></a> 構文を使用して適切な呼び出しを行うだけで実現することができます。</p><p>Julia から呼び出されるコードは、共有ライブラリとして使用できなければなりません。ほとんどの C ライブラリと Fortran ライブラリは既に共有ライブラリとしてコンパイルされていますが、GCC (または Clang) を使用してコードを自分でコンパイルする場合は、<code>-shared</code> および <code>fPIC</code> オプションを使用してください。Julia の JIT によって生成されるマシン命令はネイティブ C 呼び出しと同じなので、結果として生じるオーバーヘッドは C コードからライブラリ関数を呼び出すのと同じです。(C と Julia の両方の非ライブラリ関数呼び出しはインライン化できるため、共有ライブラリ関数の呼び出しよりもオーバーヘッドが少ない場合があります。ライブラリと実行可能ファイルの両方が LLVM によって生成される場合、この境界を越えて最適化できるプログラム全体の最適化を実行することもできますが、Julia はまだサポートしていません。ただし、将来的にはそれが行えるようになり、パフォーマンスがさらに向上する可能性があります。）</p><p>共有ライブラリと関数は、<code>(:function, &quot;library&quot;)</code> or <code>(&quot;function&quot;, &quot;library&quot;)</code> の書式のタプルで参照できます。ここで 、<code>function</code> は、C出エクスポートされた関数名、library` は共有ライブラリの名前です: ライブラリ読み込みパス(プラットフォーム固有の物も含む)中の共用ライブラリーはその名前のみで解決されますが、必要に応じて直接パスを指定することもできます。</p><p>関数名は、タプルの代わりに単独で(単に <code>:function</code> または &quot;function&quot; として) 使用できます。この場合、名前は現在のプロセス内で解決されます。この形式を使用できるのは、C ライブラリ関数、Julia ランタイムの関数、または Julia にリンクされたアプリケーションの関数のいずれかを呼び出す時です。</p><p>デフォルトでは、Fortran コンパイラは<a href="https://en.wikipedia.org/wiki/Name_mangling#Fortran">マングリングされた名前を生成するので</a> (たとえば、関数名を小文字または大文字に変換し、アンダースコアを追加する）、<a href="../base/c.html#ccall"><code>ccall</code></a>経由でFortranの関数を呼ぶためには、Fortran コンパイラが従うルールに対応してマングリングされた関数名を渡す必要があります。 また、Fortran 関数を呼び出す時は、すべての入力をヒープまたはスタックに割り当てられた値へのポインターとして渡す必要があります。これは、通常ヒープ割り当てされる配列やその他のミュータブルなオブジェクトだけでなく、通常スタック割り当てられ、C または Julia 呼び出し規約を使用する時にレジスタに一般的に渡される整数や浮動小数点数などのスカラー値についても同様です。</p><p>最後に、<a href="../base/c.html#ccall"><code>ccall</code></a>を使用して、ライブラリ関数の呼び出しを行う実際に生成することができます。<a href="../base/c.html#ccall"><code>ccall</code></a>の引数は次のとおりです:</p><ol><li><p><code>(:function, &quot;library&quot;)</code> を定数リテラルとして書く,</p><p>もしくは</p><p><code>:function</code>と関数名シンボルで書くか、<code>&quot;function&quot;</code> と関数名文字列として書き、現在のプロセスの内部で解決する,</p><p>もしくは</p><p>関数ポインタ(例えば、<code>dlsym</code> 関数から).</p></li><li><p>戻り値の型（Cの型からJuliaへのマッピングについては後述）</p><ul><li>この引数は、対象のメソッドが定義されたとき、コンパイル時に評価されます。</li></ul></li><li><p>A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression.</p><ul><li>この引数は、対象のメソッドが定義されたとき、コンパイル時に評価されます。</li></ul></li><li><p>そのあとに続く引数(もしあれば)は、その関数に実際に渡される引数の値です。</p></li></ol><p>上記全ての内容を含むシンプルな例ですが、次の関数は標準 C ライブラリから <code>clock</code> 関数を呼び出します:</p><pre><code class="language-julia-repl">julia&gt; t = ccall((:clock, &quot;libc&quot;), Int32, ())
2292761

julia&gt; t
2292761

julia&gt; typeof(ans)
Int32</code></pre><p><code>clock</code> は引数を受け取らず、<a href="../base/numbers.html#Core.Int32"><code>Int32</code></a>を返します。よくある落とし穴1 つは、1要素の タプルにも末尾のコンマが必要になる点です。たとえば、<code>getenv</code> 関数を呼び出して環境変数の値へのポインターを取得するには、次のような呼び出しを行います:</p><pre><code class="language-julia-repl">julia&gt; path = ccall((:getenv, &quot;libc&quot;), Cstring, (Cstring,), &quot;SHELL&quot;)
Cstring(@0x00007fff5fbffc45)

julia&gt; unsafe_string(path)
&quot;/bin/bash&quot;</code></pre><p>Note that the argument type tuple must be written as <code>(Cstring,)</code>, rather than <code>(Cstring)</code>. This is because <code>(Cstring)</code> is just the expression <code>Cstring</code> surrounded by parentheses, rather than a 1-tuple containing <code>Cstring</code>:</p><pre><code class="language-julia-repl">julia&gt; (Cstring)
Cstring

julia&gt; (Cstring,)
(Cstring,)</code></pre><p>実際には、特に再利用可能な機能を提供する場合の話ですが、<a href="../base/c.html#ccall"><code>ccall</code></a>を使用するコードに対して、引数を設定して、CまたはFortranのターゲット関数の振る舞いのエラーチェックをして、例外をJulia側にまで伝播させるようなラッパー関数を準備することが多いです。C API と Fortran API は、エラー条件を示す方法に関して一貫性がないため、これは特に重要です。たとえば、<code>getenv</code> C ライブラリ関数は、<a href="https://github.com/JuliaLang/julia/blob/master/base/env.jl"><code>env.jl</code></a> から実際の定義の簡略化されたバージョンである次の Julia 関数にラップされます:</p><pre><code class="language-julia">function getenv(var::AbstractString)
    val = ccall((:getenv, &quot;libc&quot;),
                Cstring, (Cstring,), var)
    if val == C_NULL
        error(&quot;getenv: undefined variable: &quot;, var)
    end
    unsafe_string(val)
end</code></pre><p>C言語の <code>getenv</code> 関数は <code>NULL</code> を返すことによってエラーを示しますが、他の標準 C 関数は-1、0、1 およびその他の特殊値を返すなど、さまざまな方法でエラーを示します。 このラッパーは、呼び出し元が存在しない環境変数を取得しようとした場合に問題を明確に示す例外をスローします:</p><pre><code class="language-julia-repl">julia&gt; getenv(&quot;SHELL&quot;)
&quot;/bin/bash&quot;

julia&gt; getenv(&quot;FOOBAR&quot;)
getenv: undefined variable: FOOBAR</code></pre><p>ローカル マシンのホスト名を検出するもう少し複雑な例を次に示します:</p><pre><code class="language-julia">function gethostname()
    hostname = Vector{UInt8}(undef, 128)
    ccall((:gethostname, &quot;libc&quot;), Int32,
          (Ptr{UInt8}, Csize_t),
          hostname, sizeof(hostname))
    hostname[end] = 0; # ensure null-termination
    return unsafe_string(pointer(hostname))
end</code></pre><p>次の使用例は、最初にバイトの配列を割り当て、次に C ライブラリ関数 <code>gethostname</code> を呼び出して配列をホスト名で埋め、ホスト名バッファーへのポインターを取得し、NULL 終端 C 文字列であると仮定してJulia 文字列にポインタを変換します。C ライブラリでは、呼び出し元にメモリを割り当てて、呼び出し先に渡して入力するように要求するこのパターンを使用するのが一般的です。このような Julia からのメモリの割り当ては、一般に、初期化されていない配列を作成し、そのデータへのポインタを C 関数に渡すことによって行われます。配列が初期化されていないため、NULL バイトを含むことができるため、ここで <code>Cstring</code> 型を使用しない理由です。<a href="../base/c.html#ccall"><code>ccall</code></a>の一部として<code>Cstring</code>に変換すると、含まれる NULL バイトがチェックされるため、変換エラーがスローされる可能性があります。</p><h2><a class="nav-anchor" id="C言語コンパチな-Julia関数のポインタをつくる-1" href="#C言語コンパチな-Julia関数のポインタをつくる-1">C言語コンパチな Julia関数のポインタをつくる</a></h2><p>It is possible to pass Julia functions to native C functions that accept function pointer arguments.  For example, to match C prototypes of the form:</p><pre><code class="language-c">typedef returntype (*functiontype)(argumenttype, ...)</code></pre><p>The macro <a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a> generates the C-compatible function pointer for a call to a Julia function. Arguments to <a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a> are as follows:</p><ol><li>A Julia Function</li><li>Return type</li><li>A literal tuple of input types</li></ol><p>Like ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined.</p><p>Currently, only the platform-default C calling convention is supported. This means that <code>@cfunction</code>-generated pointers cannot be used in calls where WINAPI expects <code>stdcall</code> function on 32-bit windows, but can be used on WIN64 (where <code>stdcall</code> is unified with the C calling convention).</p><p>A classic example is the standard C library <code>qsort</code> function, declared as:</p><pre><code class="language-c">void qsort(void *base, size_t nmemb, size_t size,
           int (*compare)(const void*, const void*));</code></pre><p>The <code>base</code> argument is a pointer to an array of length <code>nmemb</code>, with elements of <code>size</code> bytes each. <code>compare</code> is a callback function which takes pointers to two elements <code>a</code> and <code>b</code> and returns an integer less/greater than zero if <code>a</code> should appear before/after <code>b</code> (or zero if any order is permitted). Now, suppose that we have a 1d array <code>A</code> of values in Julia that we want to sort using the <code>qsort</code> function (rather than Julia&#39;s built-in <code>sort</code> function). Before we worry about calling <code>qsort</code> and passing arguments, we need to write a comparison function that works for some arbitrary objects (which define <code>&lt;</code>):</p><pre><code class="language-julia-repl">julia&gt; function mycompare(a, b)::Cint
           return (a &lt; b) ? -1 : ((a &gt; b) ? +1 : 0)
       end
mycompare (generic function with 1 method)</code></pre><p>Notice that we have to be careful about the return type: <code>qsort</code> expects a function returning a C <code>int</code>, so we annotate the return type of the function to be sure it returns a <code>Cint</code>.</p><p>In order to pass this function to C, we obtain its address using the macro <code>@cfunction</code>:</p><pre><code class="language-julia-repl">julia&gt; mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));</code></pre><p><a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a> requires three arguments: the Julia function (<code>mycompare</code>), the return type (<code>Cint</code>), and a literal tuple of the input argument types, in this case to sort an array of <code>Cdouble</code> (<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>) elements.</p><p>The final call to <code>qsort</code> looks like this:</p><pre><code class="language-julia-repl">julia&gt; A = [1.3, -2.7, 4.4, 3.1]
4-element Array{Float64,1}:
  1.3
 -2.7
  4.4
  3.1

julia&gt; ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),
             A, length(A), sizeof(eltype(A)), mycompare_c)

julia&gt; A
4-element Array{Float64,1}:
 -2.7
  1.3
  3.1
  4.4</code></pre><p>As can be seen, <code>A</code> is changed to the sorted array <code>[-2.7, 1.3, 3.1, 4.4]</code>. Note that Julia knows how to convert an array into a <code>Ptr{Cdouble}</code>, how to compute the size of a type in bytes (identical to C&#39;s <code>sizeof</code> operator), and so on. For fun, try inserting a <code>println(&quot;mycompare($a, $b)&quot;)</code> line into <code>mycompare</code>, which will allow you to see the comparisons that <code>qsort</code> is performing (and to verify that it is really calling the Julia function that you passed to it).</p><h2><a class="nav-anchor" id="Mapping-C-Types-to-Julia-1" href="#Mapping-C-Types-to-Julia-1">Mapping C Types to Julia</a></h2><p>It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.</p><p>Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file. (The <a href="https://github.com/ihnorton/Clang.jl">Clang package</a> can be used to auto-generate Julia code from a C header file.)</p><h3><a class="nav-anchor" id="Auto-conversion:-1" href="#Auto-conversion:-1">Auto-conversion:</a></h3><p>Julia automatically inserts calls to the <a href="../base/c.html#Base.cconvert"><code>Base.cconvert</code></a> function to convert each argument to the specified type. For example, the following call:</p><pre><code class="language-julia">ccall((:foo, &quot;libfoo&quot;), Cvoid, (Int32, Float64), x, y)</code></pre><p>will behave as if the following were written:</p><pre><code class="language-julia">ccall((:foo, &quot;libfoo&quot;), Cvoid, (Int32, Float64),
      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),
      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))</code></pre><p><a href="../base/c.html#Base.cconvert"><code>Base.cconvert</code></a> normally just calls <a href="../base/base.html#Base.convert"><code>convert</code></a>, but can be defined to return an arbitrary new object more appropriate for passing to C.  This should be used to perform all allocations of memory that will be accessed by the C code.  For example, this is used to convert an <code>Array</code> of objects (e.g. strings) to an array of pointers.</p><p><a href="../base/c.html#Base.unsafe_convert"><code>Base.unsafe_convert</code></a> handles conversion to <a href="../base/c.html#Core.Ptr"><code>Ptr</code></a> types. It is considered unsafe because converting an object to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely.</p><h3><a class="nav-anchor" id="Type-Correspondences:-1" href="#Type-Correspondences:-1">Type Correspondences:</a></h3><p>First, a review of some relevant Julia type terminology:</p><table><tr><th style="text-align: left">Syntax / Keyword</th><th style="text-align: left">Example</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>mutable struct</code></td><td style="text-align: left"><code>BitSet</code></td><td style="text-align: left">&quot;Leaf Type&quot; :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no <code>TypeVars</code> are allowed) in order for the instance to be constructed.</td></tr><tr><td style="text-align: left"><code>abstract type</code></td><td style="text-align: left"><code>Any</code>, <code>AbstractArray{T, N}</code>, <code>Complex{T}</code></td><td style="text-align: left">&quot;Super Type&quot; :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.</td></tr><tr><td style="text-align: left"><code>T{A}</code></td><td style="text-align: left"><code>Vector{Int}</code></td><td style="text-align: left">&quot;Type Parameter&quot; :: A specialization of a type (typically used for dispatch or storage optimization).</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">&quot;TypeVar&quot; :: The <code>T</code> in the type parameter declaration is referred to as a TypeVar (short for type variable).</td></tr><tr><td style="text-align: left"><code>primitive type</code></td><td style="text-align: left"><code>Int</code>, <code>Float64</code></td><td style="text-align: left">&quot;Primitive Type&quot; :: A type with no fields, but a size. It is stored and defined by-value.</td></tr><tr><td style="text-align: left"><code>struct</code></td><td style="text-align: left"><code>Pair{Int, Int}</code></td><td style="text-align: left">&quot;Struct&quot; :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>ComplexF64</code> (<code>isbits</code>)</td><td style="text-align: left">&quot;Is-Bits&quot;   :: A <code>primitive type</code>, or a <code>struct</code> type where all fields are other <code>isbits</code> types. It is defined by-value, and is stored without a type-tag.</td></tr><tr><td style="text-align: left"><code>struct ...; end</code></td><td style="text-align: left"><code>nothing</code></td><td style="text-align: left">&quot;Singleton&quot; :: a Leaf Type or Struct with no fields.</td></tr><tr><td style="text-align: left"><code>(...)</code> or <code>tuple(...)</code></td><td style="text-align: left"><code>(1, 2, 3)</code></td><td style="text-align: left">&quot;Tuple&quot; :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct.</td></tr></table><h3><a class="nav-anchor" id="man-bits-types-1" href="#man-bits-types-1">Bits Types</a></h3><p>There are several special types to be aware of, as no other type can be defined to behave the same:</p><ul><li><p><code>Float32</code></p><p>Exactly corresponds to the <code>float</code> type in C (or <code>REAL*4</code> in Fortran).</p></li><li><p><code>Float64</code></p><p>Exactly corresponds to the <code>double</code> type in C (or <code>REAL*8</code> in Fortran).</p></li><li><p><code>ComplexF32</code></p><p>Exactly corresponds to the <code>complex float</code> type in C (or <code>COMPLEX*8</code> in Fortran).</p></li><li><p><code>ComplexF64</code></p><p>Exactly corresponds to the <code>complex double</code> type in C (or <code>COMPLEX*16</code> in Fortran).</p></li><li><p><code>Signed</code></p><p>Exactly corresponds to the <code>signed</code> type annotation in C (or any <code>INTEGER</code> type in Fortran). Any Julia type that is not a subtype of <a href="../base/numbers.html#Core.Signed"><code>Signed</code></a> is assumed to be unsigned.</p></li></ul><ul><li><p><code>Ref{T}</code></p><p>Behaves like a <code>Ptr{T}</code> that can manage its memory via the Julia GC.</p></li></ul><ul><li><p><code>Array{T,N}</code></p><p>When an array is passed to C as a <code>Ptr{T}</code> argument, it is not reinterpret-cast: Julia requires that the element type of the array matches <code>T</code>, and the address of the first element is passed.</p><p>Therefore, if an <code>Array</code> contains data in the wrong format, it will have to be explicitly converted using a call such as <code>trunc(Int32, a)</code>.</p><p>To pass an array <code>A</code> as a pointer of a different type <em>without</em> converting the data beforehand (for example, to pass a <code>Float64</code> array to a function that operates on uninterpreted bytes), you can declare the argument as <code>Ptr{Cvoid}</code>.</p><p>If an array of eltype <code>Ptr{T}</code> is passed as a <code>Ptr{Ptr{T}}</code> argument, <a href="../base/c.html#Base.cconvert"><code>Base.cconvert</code></a> will attempt to first make a null-terminated copy of the array with each element replaced by its <a href="../base/c.html#Base.cconvert"><code>Base.cconvert</code></a> version. This allows, for example, passing an <code>argv</code> pointer array of type <code>Vector{String}</code> to an argument of type <code>Ptr{Ptr{Cchar}}</code>.</p></li></ul><p>On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C.  This can help for writing portable code (and remembering that an <code>int</code> in C is not the same as an <code>Int</code> in Julia).</p><p><strong>System Independent:</strong></p><table><tr><th style="text-align: left">C name</th><th style="text-align: left">Fortran name</th><th style="text-align: left">Standard Julia Alias</th><th style="text-align: left">Julia Base Type</th></tr><tr><td style="text-align: left"><code>unsigned char</code></td><td style="text-align: left"><code>CHARACTER</code></td><td style="text-align: left"><code>Cuchar</code></td><td style="text-align: left"><code>UInt8</code></td></tr><tr><td style="text-align: left"><code>bool</code> (only in C++)</td><td style="text-align: left"></td><td style="text-align: left"><code>Cuchar</code></td><td style="text-align: left"><code>UInt8</code></td></tr><tr><td style="text-align: left"><code>short</code></td><td style="text-align: left"><code>INTEGER*2</code>, <code>LOGICAL*2</code></td><td style="text-align: left"><code>Cshort</code></td><td style="text-align: left"><code>Int16</code></td></tr><tr><td style="text-align: left"><code>unsigned short</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cushort</code></td><td style="text-align: left"><code>UInt16</code></td></tr><tr><td style="text-align: left"><code>int</code>, <code>BOOL</code> (C, typical)</td><td style="text-align: left"><code>INTEGER*4</code>, <code>LOGICAL*4</code></td><td style="text-align: left"><code>Cint</code></td><td style="text-align: left"><code>Int32</code></td></tr><tr><td style="text-align: left"><code>unsigned int</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cuint</code></td><td style="text-align: left"><code>UInt32</code></td></tr><tr><td style="text-align: left"><code>long long</code></td><td style="text-align: left"><code>INTEGER*8</code>, <code>LOGICAL*8</code></td><td style="text-align: left"><code>Clonglong</code></td><td style="text-align: left"><code>Int64</code></td></tr><tr><td style="text-align: left"><code>unsigned long long</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Culonglong</code></td><td style="text-align: left"><code>UInt64</code></td></tr><tr><td style="text-align: left"><code>intmax_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cintmax_t</code></td><td style="text-align: left"><code>Int64</code></td></tr><tr><td style="text-align: left"><code>uintmax_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cuintmax_t</code></td><td style="text-align: left"><code>UInt64</code></td></tr><tr><td style="text-align: left"><code>float</code></td><td style="text-align: left"><code>REAL*4i</code></td><td style="text-align: left"><code>Cfloat</code></td><td style="text-align: left"><code>Float32</code></td></tr><tr><td style="text-align: left"><code>double</code></td><td style="text-align: left"><code>REAL*8</code></td><td style="text-align: left"><code>Cdouble</code></td><td style="text-align: left"><code>Float64</code></td></tr><tr><td style="text-align: left"><code>complex float</code></td><td style="text-align: left"><code>COMPLEX*8</code></td><td style="text-align: left"><code>ComplexF32</code></td><td style="text-align: left"><code>Complex{Float32}</code></td></tr><tr><td style="text-align: left"><code>complex double</code></td><td style="text-align: left"><code>COMPLEX*16</code></td><td style="text-align: left"><code>ComplexF64</code></td><td style="text-align: left"><code>Complex{Float64}</code></td></tr><tr><td style="text-align: left"><code>ptrdiff_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cptrdiff_t</code></td><td style="text-align: left"><code>Int</code></td></tr><tr><td style="text-align: left"><code>ssize_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cssize_t</code></td><td style="text-align: left"><code>Int</code></td></tr><tr><td style="text-align: left"><code>size_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Csize_t</code></td><td style="text-align: left"><code>UInt</code></td></tr><tr><td style="text-align: left"><code>void</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Cvoid</code></td></tr><tr><td style="text-align: left"><code>void</code> and <code>[[noreturn]]</code> or <code>_Noreturn</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Union{}</code></td></tr><tr><td style="text-align: left"><code>void*</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Ptr{Cvoid}</code></td></tr><tr><td style="text-align: left"><code>T*</code> (where T represents an appropriately defined type)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Ref{T}</code></td></tr><tr><td style="text-align: left"><code>char*</code> (or <code>char[]</code>, e.g. a string)</td><td style="text-align: left"><code>CHARACTER*N</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cstring</code> if NUL-terminated, or <code>Ptr{UInt8}</code> if not</td></tr><tr><td style="text-align: left"><code>char**</code> (or <code>*char[]</code>)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Ptr{Ptr{UInt8}}</code></td></tr><tr><td style="text-align: left"><code>jl_value_t*</code> (any Julia Type)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Any</code></td></tr><tr><td style="text-align: left"><code>jl_value_t**</code> (a reference to a Julia Type)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Ref{Any}</code></td></tr><tr><td style="text-align: left"><code>va_arg</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">Not supported</td></tr><tr><td style="text-align: left"><code>...</code> (variadic function specification)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>T...</code> (where <code>T</code> is one of the above types, variadic functions of different argument types are not supported)</td></tr></table><p>The <a href="../base/c.html#Base.Cstring"><code>Cstring</code></a> type is essentially a synonym for <code>Ptr{UInt8}</code>, except the conversion to <code>Cstring</code> throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator).  If you are passing a <code>char*</code> to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use <code>Ptr{UInt8}</code> as the argument type. <code>Cstring</code> can also be used as the <a href="../base/c.html#ccall"><code>ccall</code></a> return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.</p><p><strong>System-dependent:</strong></p><table><tr><th style="text-align: left">C name</th><th style="text-align: left">Standard Julia Alias</th><th style="text-align: left">Julia Base Type</th></tr><tr><td style="text-align: left"><code>char</code></td><td style="text-align: left"><code>Cchar</code></td><td style="text-align: left"><code>Int8</code> (x86, x86_64), <code>UInt8</code> (powerpc, arm)</td></tr><tr><td style="text-align: left"><code>long</code></td><td style="text-align: left"><code>Clong</code></td><td style="text-align: left"><code>Int</code> (UNIX), <code>Int32</code> (Windows)</td></tr><tr><td style="text-align: left"><code>unsigned long</code></td><td style="text-align: left"><code>Culong</code></td><td style="text-align: left"><code>UInt</code> (UNIX), <code>UInt32</code> (Windows)</td></tr><tr><td style="text-align: left"><code>wchar_t</code></td><td style="text-align: left"><code>Cwchar_t</code></td><td style="text-align: left"><code>Int32</code> (UNIX), <code>UInt16</code> (Windows)</td></tr></table><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>When calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated values, so all type correspondences above should contain an additional <code>Ptr{..}</code> or <code>Ref{..}</code> wrapper around their type specification.</p></div></div><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>For string arguments (<code>char*</code>) the Julia type should be <code>Cstring</code> (if NUL- terminated data is expected) or either <code>Ptr{Cchar}</code> or <code>Ptr{UInt8}</code> otherwise (these two pointer types have the same effect), as described above, not <code>String</code>. Similarly, for array arguments (<code>T[]</code> or <code>T*</code>), the Julia type should again be <code>Ptr{T}</code>, not <code>Vector{T}</code>.</p></div></div><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Julia&#39;s <code>Char</code> type is 32 bits, which is not the same as the wide character type (<code>wchar_t</code> or <code>wint_t</code>) on all platforms.</p></div></div><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>A return type of <code>Union{}</code> means the function will not return i.e. C++11 <code>[[noreturn]]</code> or C11 <code>_Noreturn</code> (e.g. <code>jl_throw</code> or <code>longjmp</code>). Do not use this for functions that return no value (<code>void</code>) but do return, use <code>Cvoid</code> instead.</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>For <code>wchar_t*</code> arguments, the Julia type should be <a href="../base/c.html#Base.Cwstring"><code>Cwstring</code></a> (if the C routine expects a NUL-terminated string) or <code>Ptr{Cwchar_t}</code> otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the <code>Cwstring</code> type will cause an error to be thrown if the string itself contains NUL characters).</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>C functions that take an argument of the type <code>char**</code> can be called by using a <code>Ptr{Ptr{UInt8}}</code> type within Julia. For example, C functions of the form:</p><pre><code class="language-c">int main(int argc, char **argv);</code></pre><p>can be called via the following Julia code:</p><pre><code class="language-julia">argv = [ &quot;a.out&quot;, &quot;arg1&quot;, &quot;arg2&quot; ]
ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)</code></pre></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>For Fortran functions taking variable length strings of type <code>character(len=*)</code> the string lengths are provided as <em>hidden arguments</em>. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using <code>Csize_t</code> as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others <em>optionally</em> permit placing hidden arguments directly after the character argument (Intel,PGI). For example, Fortran subroutines of the form</p><pre><code class="language-fortran">subroutine test(str1, str2)
character(len=*) :: str1,str2</code></pre><p>can be called via the following Julia code, where the lengths are appended</p><pre><code class="language-julia">str1 = &quot;foo&quot;
str2 = &quot;bar&quot;
ccall(:test, Void, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),
                    str1, str2, sizeof(str1), sizeof(str2))</code></pre></div></div><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Fortran compilers <em>may</em> also add other hidden arguments for pointers, assumed-shape (<code>:</code>) and assumed-size (<code>*</code>) arrays. Such behaviour can be avoided by using <code>ISO_C_BINDING</code> and including <code>bind(c)</code> in the definition of the subroutine, which is strongly recommended for interoperable code. In this case there will be no hidden arguments, at the cost of some language features (e.g. only <code>character(len=1)</code> will be permitted to pass strings).</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>A C function declared to return <code>Cvoid</code> will return the value <code>nothing</code> in Julia.</p></div></div><h3><a class="nav-anchor" id="Struct-Type-correspondences-1" href="#Struct-Type-correspondences-1">Struct Type correspondences</a></h3><p>Composite types, aka <code>struct</code> in C or <code>TYPE</code> in Fortran90 (or <code>STRUCTURE</code> / <code>RECORD</code> in some variants of F77), can be mirrored in Julia by creating a <code>struct</code> definition with the same field layout.</p><p>When used recursively, <code>isbits</code> types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare an <code>isbits</code> struct type and use that instead. Unnamed structs are not possible in the translation to Julia.</p><p>Packed structs and union declarations are not supported by Julia.</p><p>You can get a near approximation of a <code>union</code> if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.</p><p>Arrays of parameters can be expressed with <code>NTuple</code>:</p><p>in C:</p><pre><code class="language-c">struct B {
    int A[3];
};
b_a_2 = B.A[2];</code></pre><p>in Julia:</p><pre><code class="language-julia">struct B
    A::NTuple{3, Cint}
end
b_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)</code></pre><p>Arrays of unknown size (C99-compliant variable length structs specified by <code>[]</code> or <code>[0]</code>) are not directly supported.  Often the best way to deal with these is to deal with the byte offsets directly.  For example, if a C library declared a proper string type and returned a pointer to it:</p><pre><code class="language-c">struct String {
    int strlen;
    char data[];
};</code></pre><p>In Julia, we can access the parts independently to make a copy of that string:</p><pre><code class="language-julia">str = from_c::Ptr{Cvoid}
len = unsafe_load(Ptr{Cint}(str))
unsafe_string(str + Core.sizeof(Cint), len)</code></pre><h3><a class="nav-anchor" id="Type-Parameters-1" href="#Type-Parameters-1">Type Parameters</a></h3><p>The type arguments to <code>ccall</code> and <code>@cfunction</code> are evaluated statically, when the method containing the usage is defined.  They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.</p><p>This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.</p><p>However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment.  The static parameters of the function may be used as type parameters in the call signature, as long as they don&#39;t affect the layout of the type.  For example, <code>f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)</code> is valid, since <code>Ptr</code> is always a word-size primitive type.  But, <code>g(x::T) where {T} = ccall(:notvalid, T, (T,), x)</code> is not valid, since the type layout of <code>T</code> is not known statically.</p><h3><a class="nav-anchor" id="SIMD-Values-1" href="#SIMD-Values-1">SIMD Values</a></h3><p>Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.</p><p>If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of <code>VecElement</code> that naturally maps to the SIMD type.  Specifically:</p><blockquote><ul><li>The tuple must be the same size as the SIMD type. For example, a tuple representing an <code>__m128</code> on x86 must have a size of 16 bytes.</li><li>The element type of the tuple must be an instance of <code>VecElement{T}</code> where <code>T</code> is a primitive type that is 1, 2, 4 or 8 bytes.</li></ul></blockquote><p>For instance, consider this C routine that uses AVX intrinsics:</p><pre><code class="language-c">#include &lt;immintrin.h&gt;

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}</code></pre><p>The following Julia code calls <code>dist</code> using <code>ccall</code>:</p><pre><code class="language-julia">const m256 = NTuple{8, VecElement{Float32}}

a = m256(ntuple(i -&gt; VecElement(sin(Float32(i))), 8))
b = m256(ntuple(i -&gt; VecElement(cos(Float32(i))), 8))

function call_dist(a::m256, b::m256)
    ccall((:dist, &quot;libdist&quot;), m256, (m256, m256), a, b)
end

println(call_dist(a,b))</code></pre><p>The host machine must have the requisite SIMD registers.  For example, the code above will not work on hosts without AVX support.</p><h3><a class="nav-anchor" id="Memory-Ownership-1" href="#Memory-Ownership-1">Memory Ownership</a></h3><p><strong>malloc/free</strong></p><p>Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with <a href="../base/libc.html#Base.Libc.free"><code>Libc.free</code></a> in Julia, as this may result in the <code>free</code> function being called via the wrong <code>libc</code> library and cause Julia to crash. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.</p><h3><a class="nav-anchor" id="When-to-use-T,-Ptr{T}-and-Ref{T}-1" href="#When-to-use-T,-Ptr{T}-and-Ref{T}-1">When to use T, Ptr{T} and Ref{T}</a></h3><p>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type <code>T</code> inside the <a href="../base/c.html#ccall"><code>ccall</code></a>, as they are passed by value.  For C code accepting pointers, <a href="../base/c.html#Core.Ref"><code>Ref{T}</code></a> should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to <a href="../base/c.html#Base.cconvert"><code>Base.cconvert</code></a>.  In contrast, pointers returned by the C function called should be declared to be of output type <a href="../base/c.html#Core.Ptr"><code>Ptr{T}</code></a>, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type <code>Ptr{T}</code> within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.</p><p>In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type <code>Ref{T}</code>, as Fortran passes all variables by pointers to memory locations. The return type should either be <code>Cvoid</code> for Fortran subroutines, or a <code>T</code> for Fortran functions returning the type <code>T</code>.</p><h2><a class="nav-anchor" id="Mapping-C-Functions-to-Julia-1" href="#Mapping-C-Functions-to-Julia-1">Mapping C Functions to Julia</a></h2><h3><a class="nav-anchor" id="ccall-/-@cfunction-argument-translation-guide-1" href="#ccall-/-@cfunction-argument-translation-guide-1"><code>ccall</code> / <code>@cfunction</code> argument translation guide</a></h3><p>For translating a C argument list to Julia:</p><ul><li><p><code>T</code>, where <code>T</code> is one of the primitive types: <code>char</code>, <code>int</code>, <code>long</code>, <code>short</code>, <code>float</code>, <code>double</code>, <code>complex</code>, <code>enum</code> or any of their <code>typedef</code> equivalents</p><ul><li><code>T</code>, where <code>T</code> is an equivalent Julia Bits Type (per the table above)</li><li>if <code>T</code> is an <code>enum</code>, the argument type should be equivalent to <code>Cint</code> or <code>Cuint</code></li><li>argument value will be copied (passed by value)</li></ul></li><li><p><code>struct T</code> (including typedef to a struct)</p><ul><li><code>T</code>, where <code>T</code> is a Julia leaf type</li><li>argument value will be copied (passed by value)</li></ul></li><li><p><code>void*</code></p><ul><li>depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list</li><li>this argument may be declared as <code>Ptr{Cvoid}</code>, if it really is just an unknown pointer</li></ul></li><li><p><code>jl_value_t*</code></p><ul><li><code>Any</code></li><li>argument value must be a valid Julia object</li></ul></li><li><p><code>jl_value_t**</code></p><ul><li><code>Ref{Any}</code></li><li>argument value must be a valid Julia object (or <code>C_NULL</code>)</li></ul></li><li><p><code>T*</code></p><ul><li><code>Ref{T}</code>, where <code>T</code> is the Julia type corresponding to <code>T</code></li><li>argument value will be copied if it is an <code>isbits</code> type otherwise, the value must be a valid Julia object</li></ul></li><li><p><code>T (*)(...)</code> (e.g. a pointer to a function)</p><ul><li><code>Ptr{Cvoid}</code> (you may need to use <a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a> explicitly to create this pointer)</li></ul></li><li><p><code>...</code> (e.g. a vararg)</p><ul><li><code>T...</code>, where <code>T</code> is the Julia type</li><li>currently unsupported by <code>@cfunction</code></li></ul></li><li><p><code>va_arg</code></p><ul><li>not supported by <code>ccall</code> or <code>@cfunction</code></li></ul></li></ul><h3><a class="nav-anchor" id="ccall-/-@cfunction-return-type-translation-guide-1" href="#ccall-/-@cfunction-return-type-translation-guide-1"><code>ccall</code> / <code>@cfunction</code> return type translation guide</a></h3><p>For translating a C return type to Julia:</p><ul><li><p><code>void</code></p><ul><li><code>Cvoid</code> (this will return the singleton instance <code>nothing::Cvoid</code>)</li></ul></li><li><p><code>T</code>, where <code>T</code> is one of the primitive types: <code>char</code>, <code>int</code>, <code>long</code>, <code>short</code>, <code>float</code>, <code>double</code>, <code>complex</code>, <code>enum</code> or any of their <code>typedef</code> equivalents</p><ul><li><code>T</code>, where <code>T</code> is an equivalent Julia Bits Type (per the table above)</li><li>if <code>T</code> is an <code>enum</code>, the argument type should be equivalent to <code>Cint</code> or <code>Cuint</code></li><li>argument value will be copied (returned by-value)</li></ul></li><li><p><code>struct T</code> (including typedef to a struct)</p><ul><li><code>T</code>, where <code>T</code> is a Julia Leaf Type</li><li>argument value will be copied (returned by-value)</li></ul></li><li><p><code>void*</code></p><ul><li>depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list</li><li>this argument may be declared as <code>Ptr{Cvoid}</code>, if it really is just an unknown pointer</li></ul></li><li><p><code>jl_value_t*</code></p><ul><li><code>Any</code></li><li>argument value must be a valid Julia object</li></ul></li><li><p><code>jl_value_t**</code></p><ul><li><code>Ptr{Any}</code> (<code>Ref{Any}</code> is invalid as a return type)</li><li>argument value must be a valid Julia object (or <code>C_NULL</code>)</li></ul></li><li><p><code>T*</code></p><ul><li><p>If the memory is already owned by Julia, or is an <code>isbits</code> type, and is known to be non-null:</p><ul><li><code>Ref{T}</code>, where <code>T</code> is the Julia type corresponding to <code>T</code></li><li>a return type of <code>Ref{Any}</code> is invalid, it should either be <code>Any</code> (corresponding to <code>jl_value_t*</code>)  or <code>Ptr{Any}</code> (corresponding to <code>jl_value_t**</code>)</li><li>C <strong>MUST NOT</strong> modify the memory returned via <code>Ref{T}</code> if <code>T</code> is an <code>isbits</code> type</li></ul></li><li><p>If the memory is owned by C:</p><ul><li><code>Ptr{T}</code>, where <code>T</code> is the Julia type corresponding to <code>T</code></li></ul></li></ul></li><li><p><code>T (*)(...)</code> (e.g. a pointer to a function)</p><ul><li><code>Ptr{Cvoid}</code> (you may need to use <a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a> explicitly to create this pointer)</li></ul></li></ul><h3><a class="nav-anchor" id="Passing-Pointers-for-Modifying-Inputs-1" href="#Passing-Pointers-for-Modifying-Inputs-1">Passing Pointers for Modifying Inputs</a></h3><p>Because C doesn&#39;t support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a <a href="../base/c.html#ccall"><code>ccall</code></a>, you need to first encapsulate the value inside a <a href="../base/c.html#Core.Ref"><code>Ref{T}</code></a> of the appropriate type. When you pass this <code>Ref</code> object as an argument, Julia will automatically pass a C pointer to the encapsulated data:</p><pre><code class="language-julia">width = Ref{Cint}(0)
range = Ref{Cfloat}(0)
ccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)</code></pre><p>Upon return, the contents of <code>width</code> and <code>range</code> can be retrieved (if they were changed by <code>foo</code>)  by <code>width[]</code> and <code>range[]</code>; that is, they act like zero-dimensional arrays.</p><h3><a class="nav-anchor" id="Special-Reference-Syntax-for-ccall-(deprecated):-1" href="#Special-Reference-Syntax-for-ccall-(deprecated):-1">Special Reference Syntax for ccall (deprecated):</a></h3><p>The <code>&amp;</code> syntax is deprecated, use the <code>Ref{T}</code> argument type instead.</p><p>A prefix <code>&amp;</code> is used on an argument to <a href="../base/c.html#ccall"><code>ccall</code></a> to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.</p><pre><code class="language-julia">function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})
    @assert length(DX) == length(DY)
    n = length(DX)
    incx = incy = 1
    product = ccall((:ddot_, &quot;libLAPACK&quot;),
                    Float64,
                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),
                    n, DX, incx, DY, incy)
    return product
end</code></pre><p>The meaning of prefix <code>&amp;</code> is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via <code>mutable struct</code>). However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, <code>&amp;</code> may be used with any expression, such as <code>&amp;0</code> or <code>&amp;f(x)</code>.</p><p>When a scalar value is passed with <code>&amp;</code> as an argument of type <code>Ptr{T}</code>, the value will first be converted to type <code>T</code>.</p><h2><a class="nav-anchor" id="Some-Examples-of-C-Wrappers-1" href="#Some-Examples-of-C-Wrappers-1">Some Examples of C Wrappers</a></h2><p>Here is a simple example of a C wrapper that returns a <code>Ptr</code> type:</p><pre><code class="language-julia">mutable struct gsl_permutation
end

# The corresponding C signature is
#     gsl_permutation * gsl_permutation_alloc (size_t n);
function permutation_alloc(n::Integer)
    output_ptr = ccall(
        (:gsl_permutation_alloc, :libgsl), # name of C function and library
        Ptr{gsl_permutation},              # output type
        (Csize_t,),                        # tuple of input types
        n                                  # name of Julia variable to pass in
    )
    if output_ptr == C_NULL # Could not allocate memory
        throw(OutOfMemoryError())
    end
    return output_ptr
end</code></pre><p>The <a href="https://www.gnu.org/software/gsl/">GNU Scientific Library</a> (here assumed to be accessible through <code>:libgsl</code>) defines an opaque pointer, <code>gsl_permutation *</code>, as the return type of the C function <code>gsl_permutation_alloc</code>. As user code never has to look inside the <code>gsl_permutation</code> struct, the corresponding Julia wrapper simply needs a new type declaration, <code>gsl_permutation</code>, that has no internal fields and whose sole purpose is to be placed in the type parameter of a <code>Ptr</code> type.  The return type of the <a href="../base/c.html#ccall"><code>ccall</code></a> is declared as <code>Ptr{gsl_permutation}</code>, since the memory allocated and pointed to by <code>output_ptr</code> is controlled by C (and not Julia).</p><p>The input <code>n</code> is passed by value, and so the function&#39;s input signature is simply declared as <code>(Csize_t,)</code> without any <code>Ref</code> or <code>Ptr</code> necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be <code>(Ref{Csize_t},)</code>, since Fortran variables are passed by pointers.) Furthermore, <code>n</code> can be any type that is convertible to a <code>Csize_t</code> integer; the <a href="../base/c.html#ccall"><code>ccall</code></a> implicitly calls <a href="../base/c.html#Base.cconvert"><code>Base.cconvert(Csize_t, n)</code></a>.</p><p>Here is a second example wrapping the corresponding destructor:</p><pre><code class="language-julia"># The corresponding C signature is
#     void gsl_permutation_free (gsl_permutation * p);
function permutation_free(p::Ref{gsl_permutation})
    ccall(
        (:gsl_permutation_free, :libgsl), # name of C function and library
        Cvoid,                             # output type
        (Ref{gsl_permutation},),          # tuple of input types
        p                                 # name of Julia variable to pass in
    )
end</code></pre><p>Here, the input <code>p</code> is declared to be of type <code>Ref{gsl_permutation}</code>, meaning that the memory that <code>p</code> points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type <code>Ptr{gsl_permutation}</code>, but it is convertible using <a href="../base/c.html#Base.cconvert"><code>Base.cconvert</code></a> and therefore can be used in the same (covariant) context of the input argument to a <a href="../base/c.html#ccall"><code>ccall</code></a>. A pointer to memory allocated by Julia must be of type <code>Ref{gsl_permutation}</code>, to ensure that the memory address pointed to is valid and that Julia&#39;s garbage collector manages the chunk of memory pointed to correctly. Therefore, the <code>Ref{gsl_permutation}</code> declaration allows pointers managed by C or Julia to be used.</p><p>If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using <code>p::Ptr{gsl_permutation}</code> for the method signature of the wrapper and similarly in the <a href="../base/c.html#ccall"><code>ccall</code></a>  is also acceptable.</p><p>Here is a third example passing Julia arrays:</p><pre><code class="language-julia"># The corresponding C signature is
#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,
#                                double result_array[])
function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)
    if nmax &lt; nmin
        throw(DomainError())
    end
    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)
    errorcode = ccall(
        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library
        Cint,                               # output type
        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types
        nmin, nmax, x, result_array         # names of Julia variables to pass in
    )
    if errorcode != 0
        error(&quot;GSL error code $errorcode&quot;)
    end
    return result_array
end</code></pre><p>The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array <code>result_array</code>. This variable can only be used with corresponding input type declaration <code>Ref{Cdouble}</code>, since its memory is allocated and managed by Julia, not C. The implicit call to <a href="../base/c.html#Base.cconvert"><code>Base.cconvert(Ref{Cdouble}, result_array)</code></a> unpacks the Julia pointer to a Julia array data structure into a form understandable by C.</p><p>Note that for this code to work correctly, <code>result_array</code> must be declared to be of type <code>Ref{Cdouble}</code> and not <code>Ptr{Cdouble}</code>. The memory is managed by Julia and the <code>Ref</code> signature alerts Julia&#39;s garbage collector to keep managing the memory for <code>result_array</code> while the <a href="../base/c.html#ccall"><code>ccall</code></a> executes. If <code>Ptr{Cdouble}</code> were used instead, the <a href="../base/c.html#ccall"><code>ccall</code></a> may still work, but Julia&#39;s garbage collector would not be aware that the memory declared for <code>result_array</code> is being used by the external C function. As a result, the code may produce a memory leak if <code>result_array</code> never gets freed by the garbage collector, or if the garbage collector prematurely frees <code>result_array</code>, the C function may end up throwing an invalid memory access exception.</p><h2><a class="nav-anchor" id="Garbage-Collection-Safety-1" href="#Garbage-Collection-Safety-1">Garbage Collection Safety</a></h2><p>When passing data to a <a href="../base/c.html#ccall"><code>ccall</code></a>, it is best to avoid using the <a href="../base/c.html#Base.pointer"><code>pointer</code></a> function.  Instead define a convert method and pass the variables directly to the <a href="../base/c.html#ccall"><code>ccall</code></a>. <a href="../base/c.html#ccall"><code>ccall</code></a>  automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the <a href="../base/c.html#ccall"><code>ccall</code></a>  returns, you must arrange that the object remains visible to the garbage collector. The suggested way to handle this is to make a global variable of type <code>Array{Ref,1}</code> to hold these values, until the C library notifies you that it is finished with them.</p><p>Whenever you have created a pointer to Julia data, you must ensure the original data exists until you are done with using the pointer. Many methods in Julia such as <a href="../base/c.html#Base.unsafe_load"><code>unsafe_load</code></a> and <a href="../base/strings.html#Core.String-Tuple{AbstractString}"><code>String</code></a> make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is <a href="../base/c.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T,N} where N}, Type{Array{T,N}}},Ptr{T},Tuple{Vararg{Int64,N}}}} where N where T"><code>unsafe_wrap</code></a>  which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.</p><p>The garbage collector does not guarantee any order of finalization. That is, if <code>a</code> contained a reference to <code>b</code> and both <code>a</code> and <code>b</code> are due for garbage collection, there is no guarantee that <code>b</code> would be finalized after <code>a</code>. If proper finalization of <code>a</code> depends on <code>b</code> being valid, it must be handled in other ways.</p><h2><a class="nav-anchor" id="Non-constant-Function-Specifications-1" href="#Non-constant-Function-Specifications-1">Non-constant Function Specifications</a></h2><p>A <code>(name, library)</code> function specification must be a constant expression. However, it is possible to use computed values as function names by staging through <a href="../base/base.html#Base.MainInclude.eval"><code>eval</code></a> as follows:</p><pre><code class="language-none">@eval ccall(($(string(&quot;a&quot;, &quot;b&quot;)), &quot;lib&quot;), ...</code></pre><p>This expression constructs a name using <code>string</code>, then substitutes this name into a new <a href="../base/c.html#ccall"><code>ccall</code></a>  expression, which is then evaluated. Keep in mind that <code>eval</code> only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with <code>$</code>). For this reason, <code>eval</code> is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions.  A similar example can be constructed for <a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a>.</p><p>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading.  The next section discusses how to use indirect calls to efficiently accomplish a similar effect.</p><h2><a class="nav-anchor" id="Indirect-Calls-1" href="#Indirect-Calls-1">Indirect Calls</a></h2><p>The first argument to <a href="../base/c.html#ccall"><code>ccall</code></a> can also be an expression evaluated at run time. In this case, the expression must evaluate to a <code>Ptr</code>, which will be used as the address of the native function to call. This behavior occurs when the first <a href="../base/c.html#ccall"><code>ccall</code></a> argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.</p><p>For example, you might look up the function via <code>dlsym</code>, then cache it in a shared reference for that session. For example:</p><pre><code class="language-julia">macro dlsym(func, lib)
    z = Ref{Ptr{Cvoid}}(C_NULL)
    quote
        let zlocal = $z[]
            if zlocal == C_NULL
                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}
                $z[] = $zlocal
            end
            zlocal
        end
    end
end

mylibvar = Libdl.dlopen(&quot;mylib&quot;)
ccall(@dlsym(&quot;myfunc&quot;, mylibvar), Cvoid, ())</code></pre><h2><a class="nav-anchor" id="Closure-cfunctions-1" href="#Closure-cfunctions-1">Closure cfunctions</a></h2><p>The first argument to <a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a> can be marked with a <code>$</code>, in which case the return value will instead be a <code>struct CFunction</code> which closes over the argument.  You must ensure that this return object is kept alive until all uses of it are done.  The contents and code at the cfunction pointer will be erased via a <a href="../base/base.html#Base.finalizer"><code>finalizer</code></a>  when this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don&#39;t provide a separate closure environment parameter.</p><pre><code class="language-julia">function qsort(a::Vector{T}, cmp) where T
    isbits(T) || throw(ArgumentError(&quot;this method can only qsort isbits arrays&quot;))
    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})
    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}
    # (and protected against finalization) by the ccall
    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),
        a, length(a), Base.elsize(a), callback)
    # We could instead use:
    #    GC.@preserve callback begin
    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))
    #    end
    # if we needed to use it outside of a `ccall`
    return a
end</code></pre><h2><a class="nav-anchor" id="Closing-a-Library-1" href="#Closing-a-Library-1">Closing a Library</a></h2><p>It is sometimes useful to close (unload) a library so that it can be reloaded.  For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the <code>Libdl</code> functions to manage the library explicitly, such as:</p><pre><code class="language-julia">lib = Libdl.dlopen(&quot;./my_lib.so&quot;) # Open the library explicitly.
sym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.
ccall(sym, ...) # Use the pointer `sym` instead of the (symbol, library) tuple (remaining arguments are the same).
Libdl.dlclose(lib) # Close the library explicitly.</code></pre><p>Note that when using <code>ccall</code> with the tuple input (e.g., <code>ccall((:my_fcn, &quot;./my_lib.so&quot;), ...)</code>), the library is opened implicitly and it may not be explicitly closed.</p><h2><a class="nav-anchor" id="Calling-Convention-1" href="#Calling-Convention-1">Calling Convention</a></h2><p>The second argument to <a href="../base/c.html#ccall"><code>ccall</code></a> can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used.  Other supported conventions are: <code>stdcall</code>, <code>cdecl</code>, <code>fastcall</code>, and <code>thiscall</code> (no-op on 64-bit Windows). For example (from <code>base/libc.jl</code>) we see the same <code>gethostname</code><a href="../base/c.html#ccall"><code>ccall</code></a> as above, but with the correct signature for Windows:</p><pre><code class="language-julia">hn = Vector{UInt8}(undef, 256)
err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))</code></pre><p>For more information, please see the <a href="http://llvm.org/docs/LangRef.html#calling-conventions">LLVM Language Reference</a>.</p><p>There is one additional special calling convention <a href="../base/c.html#Core.Intrinsics.llvmcall"><code>llvmcall</code></a>, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs.  For example, for <a href="http://llvm.org/docs/NVPTXUsage.html">CUDA</a>, we need to be able to read the thread index:</p><pre><code class="language-julia">ccall(&quot;llvm.nvvm.read.ptx.sreg.tid.x&quot;, llvmcall, Int32, ())</code></pre><p>As with any <code>ccall</code>, it is essential to get the argument signature exactly correct.  Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by <code>Core.Intrinsics</code>.</p><h2><a class="nav-anchor" id="Accessing-Global-Variables-1" href="#Accessing-Global-Variables-1">Accessing Global Variables</a></h2><p>Global variables exported by native libraries can be accessed by name using the <a href="../base/c.html#Core.Intrinsics.cglobal"><code>cglobal</code></a>  function. The arguments to <a href="../base/c.html#Core.Intrinsics.cglobal"><code>cglobal</code></a> are a symbol specification identical to that used by <a href="../base/c.html#ccall"><code>ccall</code></a>, and a type describing the value stored in the variable:</p><pre><code class="language-julia-repl">julia&gt; cglobal((:errno, :libc), Int32)
Ptr{Int32} @0x00007f418d0816b8</code></pre><p>The result is a pointer giving the address of the value. The value can be manipulated through this pointer using <a href="../base/c.html#Base.unsafe_load"><code>unsafe_load</code></a> and <a href="../base/c.html#Base.unsafe_store!"><code>unsafe_store!</code></a>.</p><h2><a class="nav-anchor" id="Accessing-Data-through-a-Pointer-1" href="#Accessing-Data-through-a-Pointer-1">Accessing Data through a Pointer</a></h2><p>The following methods are described as &quot;unsafe&quot; because a bad pointer or type declaration can cause Julia to terminate abruptly.</p><p>Given a <code>Ptr{T}</code>, the contents of type <code>T</code> can generally be copied from the referenced memory into a Julia object using <code>unsafe_load(ptr, [index])</code>. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of <a href="../base/collections.html#Base.getindex"><code>getindex</code></a> and <a href="../base/collections.html#Base.setindex!"><code>setindex!</code></a> (e.g. <code>[]</code> access syntax).</p><p>The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.</p><p>If <code>T</code> is <code>Any</code>, then the memory is assumed to contain a reference to a Julia object (a <code>jl_value_t*</code>), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia&#39;s garbage collector.  If the <code>Ptr</code> itself is actually a <code>jl_value_t*</code>, it can be converted back to a Julia object reference by <a href="../base/c.html#Base.unsafe_pointer_to_objref"><code>unsafe_pointer_to_objref(ptr)</code></a>. (Julia values <code>v</code> can be converted to <code>jl_value_t*</code> pointers, as <code>Ptr{Cvoid}</code>, by calling <a href="../base/c.html#Base.pointer_from_objref"><code>pointer_from_objref(v)</code></a>.)</p><p>The reverse operation (writing data to a <code>Ptr{T}</code>), can be performed using <a href="../base/c.html#Base.unsafe_store!"><code>unsafe_store!(ptr, value, [index])</code></a>.  Currently, this is only supported for primitive types or other pointer-free (<code>isbits</code>) immutable struct types.</p><p>Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.</p><p>If the pointer of interest is a plain-data array (primitive type or immutable struct), the function <a href="../base/c.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T,N} where N}, Type{Array{T,N}}},Ptr{T},Tuple{Vararg{Int64,N}}}} where N where T"><code>unsafe_wrap(Array, ptr,dims, own = false)</code></a>  may be more useful. The final parameter should be true if Julia should &quot;take ownership&quot; of the underlying buffer and call <code>free(ptr)</code> when the returned <code>Array</code> object is finalized.  If the <code>own</code> parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.</p><p>Arithmetic on the <code>Ptr</code> type in Julia (e.g. using <code>+</code>) does not behave the same as C&#39;s pointer arithmetic. Adding an integer to a <code>Ptr</code> in Julia always moves the pointer by some number of <em>bytes</em>, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.</p><h2><a class="nav-anchor" id="Thread-safety-1" href="#Thread-safety-1">Thread-safety</a></h2><p>Some C libraries execute their callbacks from a different thread, and since Julia isn&#39;t thread-safe you&#39;ll need to take some extra precautions. In particular, you&#39;ll need to set up a two-layered system: the C callback should only <em>schedule</em> (via Julia&#39;s event loop) the execution of your &quot;real&quot; callback. To do this, create an <a href="../base/base.html#Base.AsyncCondition"><code>AsyncCondition</code></a> object and <a href="../base/parallel.html#Base.wait"><code>wait</code></a> on it:</p><pre><code class="language-julia">cond = Base.AsyncCondition()
wait(cond)</code></pre><p>The callback you pass to C should only execute a <a href="../base/c.html#ccall"><code>ccall</code></a> to <code>:uv_async_send</code>, passing <code>cond.handle</code> as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.</p><p>Note that events may be coalesced, so multiple calls to <code>uv_async_send</code> may result in a single wakeup notification to the condition.</p><h2><a class="nav-anchor" id="More-About-Callbacks-1" href="#More-About-Callbacks-1">More About Callbacks</a></h2><p>For more details on how to pass callbacks to C libraries, see this <a href="https://julialang.org/blog/2013/05/callback">blog post</a>.</p><h2><a class="nav-anchor" id="C-1" href="#C-1">C++</a></h2><p>For direct C++ interfacing, see the <a href="https://github.com/Keno/Cxx.jl">Cxx</a> package. For tools to create C++ bindings, see the <a href="https://github.com/JuliaInterop/CxxWrap.jl">CxxWrap</a> package.</p><footer><hr/><a class="previous" href="running-external-programs.html"><span class="direction">Previous</span><span class="title">外部プログラムの実行</span></a><a class="next" href="handling-operating-system-variation.html"><span class="direction">Next</span><span class="title">Handling Operating System Variation</span></a></footer></article></body></html>
