<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ドキュメンテーション · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">はじめよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">モジュール</a></li><li class="current"><a class="toctext" href="documentation.html">ドキュメンテーション</a><ul class="internal"><li><a class="toctext" href="#ドキュメントへのアクセス-1">ドキュメントへのアクセス</a></li><li><a class="toctext" href="#関数とメソッド-1">関数とメソッド</a></li><li><a class="toctext" href="#高度な使い方-1">高度な使い方</a></li><li><a class="toctext" href="#構文ガイド-1">構文ガイド</a></li></ul></li><li><a class="toctext" href="metaprogramming.html">メタプログラミング</a></li><li><a class="toctext" href="arrays.html">多次元配列</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">ネットワークとストリーム</a></li><li><a class="toctext" href="parallel-computing.html">並列コンピューティング</a></li><li><a class="toctext" href="running-external-programs.html">外部プログラムの実行</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">C, Fortran コードの呼び出し</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Julia の埋め込み</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">プロファイリング</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">パフォーマンス・ティップス</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">スタイルガイド</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">他の言語との注目すべき違い</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">リフレクションとインストロスペクション</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Julia ランタイムの初期化</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">システムイメージのビルド</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li><li><a class="toctext" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="toctext" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">クラッシュ(セグメンテーションフォルト)の報告と分析</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="documentation.html">ドキュメンテーション</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/documentation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>ドキュメンテーション</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Documentation-1" href="#Documentation-1">ドキュメンテーション</a></h1><p>パッケージ開発者やユーザーは、Julia v0.4 以降で組み込みのドキュメントシステムを使って、関数、型、およびその他のオブジェクトのドキュメンテーションを簡単に行えます。</p><p>基本的な構文は単純です: オブジェクト (関数、マクロ、型、またはインスタンス)の直前・最上位の文字列を書くと その文字列はドキュメントと解釈されます (これらは <em>docstrings</em>と呼ばれます)。 docstring とドキュメント化したいオブジェクトの間に、空白行やコメントがないようにしてください。基本的な例は以下の通りです:</p><pre><code class="language-julia">&quot;Tell whether there are too foo items in the array.&quot;
foo(xs::Array) = ...</code></pre><p>ドキュメンテーションは<a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>として解釈されます。そのため、インデントやコードフェンスを使って、テキストとコード例を分けて書くことができます。技術的には、全てのオブジェクトをメタデータとして、別のオブジェクトに関連付けることができます。デフォルトでは、ドキュメントはマークダウンとして解釈されますが、他の文字列のマクロを定義して、<code>@doc</code>マクロに渡してドキュメントとすることもできます。</p><p>!!! メモ     Markdown サポートは <code>Markdown</code> 標準ライブラリで実装されています。サポートされている構文一覧は <a href="../stdlib/Markdown.html#Markdown-1">Markdownのドキュメント</a> を参照してください</p><p>Markdownを使用した、より複雑な例を次に示します:</p><pre><code class="language-julia">&quot;&quot;&quot;
    bar(x[, y])

Compute the Bar index between `x` and `y`. If `y` is missing, compute
the Bar index between all pairs of columns of `x`.

# Examples
```julia-repl
julia&gt; bar([1, 2], [1, 2])
1
```
&quot;&quot;&quot;
function bar(x, y) ...</code></pre><p>上記の例と同様に、ドキュメントを作成する際には、いくつかの簡単な規則に従うことをお勧めします:</p><ol><li><p>ドキュメントの上部に関数のシグネチャを常に表示し、スペース4つのインデントを使用して、Julia コードとして印刷します。</p><p>ここでの表記は、Juliaコードのシグネチャと全く同じにしてもよいですし (<code>mean(x::AbstractArray)</code>などのように)、簡略表記としてもよいしょう。 オプション引数は、可能な場合は実際のJuliaの構文に従って、デフォルト値も示すべきです(つまり<code>f(x, y=1)</code>のように)。 デフォルト値を持たないオプション引数は、括弧内に入れてください (つまり、<code>f(x[,y])</code>や <code>f(x[,y[,z]]</code>のように)。 その他の方法としては、複数行を使用することです: 1行を通常引数に、ほかの行をオプション引数に使う、ということです。 この方法は、ある関数に対して、いくつかの関連するメソッドのドキュメンテーションにも使用ですまう。 関数が多くのキーワード引数を持つ時には、<code>&lt;keyword arguments&gt;</code>プレースホルダのみをシグネチャに含むシグネチャに含めて (すなわち<code>f(x;&lt;keyword arguments&gt;)</code>)、完全な引数リストを <code>#Arguments</code> セクション以下に書いてください(ポイント4参照)。</p></li><li><p>簡略化されたシグニチャの後には、関数の振る舞い、やオブジェクトが何者であるか、1行で説明しましょう 必要に応じて、1行空けたあとの段落でより詳細について記述してください。</p><p>関数の1 行説明は、3単現のsを付けずに、命令形で書いてください。最後にピリオドを付けます。 関数の意味を簡単に要約できない場合は、関数の構成要素を分割するとよいかもしれません(絶対的な要件ではなく、あくまで一例です)。</p></li><li><p>繰り返しを避けましょう(DRY)。</p><p>関数名はシグネチャによって与えられるので、「関数<code>bar</code>は..」という文言でドキュメントを開始する必要はありません: はじめから要点を書いてください。同様に、シグネチャで引数の型が指定されているならば、説明で型に言及することは冗長です。</p></li><li><p>本当に必要な場合にのみ引数リストを書きます。</p><p>単純な関数の場合、関数の目的を説明する際に直接 引数の役割に言及する方が明らかにわかりやすいことがあります。 (そのような場合、)引数リストは、他の場所で言及された情報を繰り返すだけです ただし、多くの引数(特にキーワード引数)を使う、複雑な関数に対しては、引数リストを書くのはよいアイディアです。 その場合、一般的な関数説明の後、<code>#Arguments</code> ヘッダの下に引数リストを挿入します。引数1つずつに対して <code>-</code> の箇条書きを使いましょう。 リストには、引数の型と既定値 (ある場合) を指定する必要があります。</p><pre><code class="language-julia">&quot;&quot;&quot;
...
# Arguments
- `n::Integer`: the number of elements to compute.
- `dim::Integer=1`: the dimensions along which to perform the computation.
...
&quot;&quot;&quot;</code></pre></li><li><p>関連する関数にヒント(see. also)を加えましょう。</p><p>関連する機能をもつ関数がある場合は、適切な関数を発見して貰う可能性を高めるために、<code>See also:</code> の段落でに関連する関数の短いリストを加えましょう。</p><pre><code class="language-none">See also: [`bar!`](@ref), [`baz`](@ref), [`baaz`](@ref)</code></pre></li><li><p><code># Examples</code>セクションになんからのコード例を示しましょう。</p><p>例は、可能な限り <em>doctests</em>として記述する必要があります。<em>doctest</em> はフェンスで囲まれたコードブロックです(<a href="../stdlib/Markdown.html#Code-blocks-1">コードブロック</a> 参照) 。 <code>```jldoctest</code>で始まり、任意の数の <code>julia&gt;</code> プロンプトが、その入出力とともに含まれます。ここでの出力はJuliaのREPLであれば与えられた入力に対して、この出力を出すだろうという期待値です。</p><p>!!!メモ     doctest は<a href="https://github.com/JuliaDocs/Documenter.jl"><code>Documenter.jl</code></a>によって有効化されます。     詳細なドキュメントについては、Documenter の<a href="https://juliadocs.github.io/Documenter.jl/">マニュアル</a>を見てください。</p><p>たとえば、次の docstring では変数 <code>a</code> が定義され、期待される結果が Julia のREPLにプリント出力されるのと同じように後で表示されます。</p><pre><code class="language-julia">&quot;&quot;&quot;
Some nice documentation here.

# Examples
```jldoctest
julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4
```
&quot;&quot;&quot;</code></pre><p>!!!警告     <code>rand</code> およびその他の RNG 関連の関数の呼び出しは、doctest では避けて下さい。     RNG関連の関数は、異なる Julia セッションで一貫した出力を生成しないからです。何らかの乱数生成関連の機能を示したい場合の一つの選択肢は、<a href="../stdlib/Random.html#Random.MersenneTwister"><code>MersenneTwister</code></a>(もしくはその他の疑似乱数生成の関数)に明示的にシードを与え、その結果をdoctest を書いている関数に与えることです。</p><pre><code class="language-none">オペレーティング システムのワードサイズ ([`Int32`](@ref) または [`Int64`](@ref))とパス区切り記号の違い
(`/` または `\`) は、一部のdoctestの再現性にも影響します。

doctest の空白は重要です。doctest は例えば配列のpritty-printの出力位置が(期待値と)ずれていると失敗します。</code></pre><p>JuliaのマニュアルとAPIドキュメントではコードexampleが確実に機能します。 すべてのdoctestを実行するには <code>make -C doctest=true</code>を実行してください</p><p>出力結果が切り捨てられることを示すには、チェックを停止すべき行で<code>[...]</code>と書くことができます。 これは、doctest で何か例外がスローされたとき、スタックトレース(これは、Julia のコード行への非永続的な参照を含みます) を非表示にするのに役立ちます。例えば:</p><pre><code class="language-julia">```jldoctest
julia&gt; div(1, 0)
ERROR: DivideError: integer division error
[...]
```</code></pre><p>Examples that are untestable should be written within fenced code blocks starting with <code>```julia</code> so that they are highlighted correctly in the generated documentation.</p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>Wherever possible examples should be <strong>self-contained</strong> and <strong>runnable</strong> so that readers are able to try them out without having to include any dependencies.</p></div></div></li><li><p>Use backticks to identify code and equations.</p><p>Julia identifiers and code excerpts should always appear between backticks <code>`</code> to enable highlighting. Equations in the LaTeX syntax can be inserted between double backticks <code>``</code>. Use Unicode characters rather than their LaTeX escape sequence, i.e. <code>``α = 1``</code> rather than <code>``\\alpha = 1``</code>.</p></li><li><p>Place the starting and ending <code>&quot;&quot;&quot;</code> characters on lines by themselves.</p><p>That is, write:</p><pre><code class="language-julia">&quot;&quot;&quot;
...

...
&quot;&quot;&quot;
f(x, y) = ...</code></pre><p>rather than:</p><pre><code class="language-julia">&quot;&quot;&quot;...

...&quot;&quot;&quot;
f(x, y) = ...</code></pre><p>This makes it more clear where docstrings start and end.</p></li><li><p>Respect the line length limit used in the surrounding code.</p><p>Docstrings are edited using the same tools as code. Therefore, the same conventions should apply. It is advised to add line breaks after 92 characters.</p></li><li><p>Provide information allowing custom types to implement the function in an <code># Implementation</code> section. These implementation details intended for developers rather than users, explaining e.g. which functions should be overridden and which functions automatically use appropriate fallbacks, are better kept separate from the main description of the function&#39;s behavior.</p></li></ol><h2><a class="nav-anchor" id="ドキュメントへのアクセス-1" href="#ドキュメントへのアクセス-1">ドキュメントへのアクセス</a></h2><p>Documentation can be accessed at the REPL or in <a href="https://github.com/JuliaLang/IJulia.jl">IJulia</a>  by typing <code>?</code> followed by the name of a function or macro, and pressing <code>Enter</code>. For example,</p><pre><code class="language-julia">?cos
?@time
?r&quot;&quot;</code></pre><p>will bring up docs for the relevant function, macro or string macro respectively. In <a href="http://junolab.org">Juno</a>  using <code>Ctrl-J, Ctrl-D</code> will bring up documentation for the object under the cursor.</p><h2><a class="nav-anchor" id="関数とメソッド-1" href="#関数とメソッド-1">関数とメソッド</a></h2><p>Functions in Julia may have multiple implementations, known as methods. While it&#39;s good practice for generic functions to have a single purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or even the function itself (i.e. the object created without any methods by <code>function bar end</code>). Specific methods should only be documented if their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:</p><pre><code class="language-julia">&quot;&quot;&quot;
    *(x, y, z...)

Multiplication operator. `x * y * z *...` calls this function with multiple
arguments, i.e. `*(x, y, z...)`.
&quot;&quot;&quot;
function *(x, y, z...)
    # ... [implementation sold separately] ...
end

&quot;&quot;&quot;
    *(x::AbstractString, y::AbstractString, z::AbstractString...)

When applied to strings, concatenates them.
&quot;&quot;&quot;
function *(x::AbstractString, y::AbstractString, z::AbstractString...)
    # ... [insert secret sauce here] ...
end

help?&gt; *
search: * .*

  *(x, y, z...)

  Multiplication operator. x * y * z *... calls this function with multiple
  arguments, i.e. *(x,y,z...).

  *(x::AbstractString, y::AbstractString, z::AbstractString...)

  When applied to strings, concatenates them.</code></pre><p>When retrieving documentation for a generic function, the metadata for each method is concatenated with the <code>catdoc</code> function, which can of course be overridden for custom types.</p><h2><a class="nav-anchor" id="高度な使い方-1" href="#高度な使い方-1">高度な使い方</a></h2><p>The <code>@doc</code> macro associates its first argument with its second in a per-module dictionary called <code>META</code>. By default, documentation is expected to be written in Markdown, and the <code>doc&quot;&quot;</code> string macro simply creates an object representing the Markdown content. In the future it is likely to do more advanced things such as allowing for relative image or link paths.</p><p>To make it easier to write documentation, the parser treats the macro name <code>@doc</code> specially: if a call to <code>@doc</code> has one argument, but another expression appears after a single line break, then that additional expression is added as an argument to the macro.  Therefore the following syntax is parsed as a 2-argument call to <code>@doc</code>:</p><pre><code class="language-julia">@doc raw&quot;&quot;&quot;
...
&quot;&quot;&quot;
f(x) = x</code></pre><p>This makes it easy to use an arbitrary object (here a <code>raw</code> string) as a docstring.</p><p>When used for retrieving documentation, the <code>@doc</code> macro (or equally, the <code>doc</code> function) will search all <code>META</code> dictionaries for metadata relevant to the given object and return it. The returned object (some Markdown content, for example) will by default display itself intelligently. This design also makes it easy to use the doc system in a programmatic way; for example, to re-use documentation between different versions of a function:</p><pre><code class="language-julia">@doc &quot;...&quot; foo!
@doc (@doc foo!) foo</code></pre><p>Or for use with Julia&#39;s metaprogramming functionality:</p><pre><code class="language-julia">for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))
    @eval begin
        $f(a,b) = $op(a,b)
    end
end
@doc &quot;`add(a,b)` adds `a` and `b` together&quot; add
@doc &quot;`subtract(a,b)` subtracts `b` from `a`&quot; subtract</code></pre><p>Documentation written in non-toplevel blocks, such as <code>begin</code>, <code>if</code>, <code>for</code>, and <code>let</code>, is added to the documentation system as blocks are evaluated. For example:</p><pre><code class="language-julia">if condition()
    &quot;...&quot;
    f(x) = x
end</code></pre><p>will add documentation to <code>f(x)</code> when <code>condition()</code> is <code>true</code>. Note that even if <code>f(x)</code> goes out of scope at the end of the block, its documentation will remain.</p><h3><a class="nav-anchor" id="動的ドキュメント-1" href="#動的ドキュメント-1">動的ドキュメント</a></h3><p>Sometimes the appropriate documentation for an instance of a type depends on the field values of that instance, rather than just on the type itself. In these cases, you can add a method to <code>Docs.getdoc</code> for your custom type that returns the documentation on a per-instance basis. For instance,</p><pre><code class="language-julia">struct MyType
    value::String
end

Docs.getdoc(t::MyType) = &quot;Documentation for MyType with value $(t.value)&quot;

x = MyType(&quot;x&quot;)
y = MyType(&quot;y&quot;)</code></pre><p><code>?x</code> will display &quot;Documentation for MyType with value x&quot; while <code>?y</code> will display &quot;Documentation for MyType with value y&quot;.</p><h2><a class="nav-anchor" id="構文ガイド-1" href="#構文ガイド-1">構文ガイド</a></h2><p>A comprehensive overview of all documentable Julia syntax.</p><p>In the following examples <code>&quot;...&quot;</code> is used to illustrate an arbitrary docstring.</p><p><code>doc&quot;&quot;</code> should only be used when the docstring contains <code>$</code> or <code>\</code> characters that should not be parsed by Julia such as LaTeX syntax or Julia source code examples containing interpolation.</p><h3><a class="nav-anchor" id="関数とメソッド-2" href="#関数とメソッド-2">関数とメソッド</a></h3><pre><code class="language-julia">&quot;...&quot;
function f end

&quot;...&quot;
f</code></pre><p>Adds docstring <code>&quot;...&quot;</code> to the function <code>f</code>. The first version is the preferred syntax, however both are equivalent.</p><pre><code class="language-julia">&quot;...&quot;
f(x) = x

&quot;...&quot;
function f(x)
    x
end

&quot;...&quot;
f(x)</code></pre><p>Adds docstring <code>&quot;...&quot;</code> to the method <code>f(::Any)</code>.</p><pre><code class="language-julia">&quot;...&quot;
f(x, y = 1) = x + y</code></pre><p>Adds docstring <code>&quot;...&quot;</code> to two <code>Method</code>s, namely <code>f(::Any)</code> and <code>f(::Any, ::Any)</code>.</p><h3><a class="nav-anchor" id="マクロ-1" href="#マクロ-1">マクロ</a></h3><pre><code class="language-julia">&quot;...&quot;
macro m(x) end</code></pre><p>Adds docstring <code>&quot;...&quot;</code> to the <code>@m(::Any)</code> macro definition.</p><pre><code class="language-julia">&quot;...&quot;
:(@m)</code></pre><p>Adds docstring <code>&quot;...&quot;</code> to the macro named <code>@m</code>.</p><h3><a class="nav-anchor" id="型-1" href="#型-1">型</a></h3><pre><code class="language-none">&quot;...&quot;
abstract type T1 end

&quot;...&quot;
mutable struct T2
    ...
end

&quot;...&quot;
struct T3
    ...
end</code></pre><p>Adds the docstring <code>&quot;...&quot;</code> to types <code>T1</code>, <code>T2</code>, and <code>T3</code>.</p><pre><code class="language-julia">&quot;...&quot;
struct T
    &quot;x&quot;
    x
    &quot;y&quot;
    y
end</code></pre><p>Adds docstring <code>&quot;...&quot;</code> to type <code>T</code>, <code>&quot;x&quot;</code> to field <code>T.x</code> and <code>&quot;y&quot;</code> to field <code>T.y</code>. Also applicable to <code>mutable struct</code> types.</p><h3><a class="nav-anchor" id="モジュール-1" href="#モジュール-1">モジュール</a></h3><pre><code class="language-julia">&quot;...&quot;
module M end

module M

&quot;...&quot;
M

end</code></pre><p>Adds docstring <code>&quot;...&quot;</code> to the <code>Module</code><code>M</code>. Adding the docstring above the <code>Module</code> is the preferred syntax, however both are equivalent.</p><pre><code class="language-julia">&quot;...&quot;
baremodule M
# ...
end

baremodule M

import Base: @doc

&quot;...&quot;
f(x) = x

end</code></pre><p>Documenting a <code>baremodule</code> by placing a docstring above the expression automatically imports <code>@doc</code> into the module. These imports must be done manually when the module expression is not documented. Empty <code>baremodule</code>s cannot be documented.</p><h3><a class="nav-anchor" id="グローバル変数-1" href="#グローバル変数-1">グローバル変数</a></h3><pre><code class="language-julia">&quot;...&quot;
const a = 1

&quot;...&quot;
b = 2

&quot;...&quot;
global c = 3</code></pre><p>Adds docstring <code>&quot;...&quot;</code> to the <code>Binding</code>s <code>a</code>, <code>b</code>, and <code>c</code>.</p><p><code>Binding</code>s are used to store a reference to a particular <code>Symbol</code> in a <code>Module</code> without storing the referenced value itself.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>When a <code>const</code> definition is only used to define an alias of another definition, such as is the case with the function <code>div</code> and its alias <code>÷</code> in <code>Base</code>, do not document the alias and instead document the actual function.</p><p>If the alias is documented and not the real definition then the docsystem (<code>?</code> mode) will not return the docstring attached to the alias when the real definition is searched for.</p><p>For example you should write</p><pre><code class="language-julia">&quot;...&quot;
f(x) = x + 1
const alias = f</code></pre><p>rather than</p><pre><code class="language-julia">f(x) = x + 1
&quot;...&quot;
const alias = f</code></pre></div></div><pre><code class="language-julia">&quot;...&quot;
sym</code></pre><p>Adds docstring <code>&quot;...&quot;</code> to the value associated with <code>sym</code>. Users should prefer documenting <code>sym</code> at its definition.</p><h3><a class="nav-anchor" id="Multiple-Objects-1" href="#Multiple-Objects-1">Multiple Objects</a></h3><pre><code class="language-julia">&quot;...&quot;
a, b</code></pre><p>Adds docstring <code>&quot;...&quot;</code> to <code>a</code> and <code>b</code> each of which should be a documentable expression. This syntax is equivalent to</p><pre><code class="language-julia">&quot;...&quot;
a

&quot;...&quot;
b</code></pre><p>Any number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions <code>f</code> and <code>f!</code>.</p><h3><a class="nav-anchor" id="Macro-generated-code-1" href="#Macro-generated-code-1">Macro-generated code</a></h3><pre><code class="language-julia">&quot;...&quot;
@m expression</code></pre><p>Adds docstring <code>&quot;...&quot;</code> to expression generated by expanding <code>@m expression</code>. This allows for expressions decorated with <code>@inline</code>, <code>@noinline</code>, <code>@generated</code>, or any other macro to be documented in the same way as undecorated expressions.</p><p>Macro authors should take note that only macros that generate a single expression will automatically support docstrings. If a macro returns a block containing multiple subexpressions then the subexpression that should be documented must be marked using the <a href="documentation.html#Core.@__doc__"><code>@__doc__</code></a> macro.</p><p>The <a href="../base/base.html#Base.Enums.@enum"><code>@enum</code></a> macro makes use of <code>@__doc__</code> to allow for documenting <a href="../base/base.html#Base.Enums.Enum"><code>Enum</code></a>s.  Examining its definition should serve as an example of how to use <code>@__doc__</code> correctly.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.@__doc__" href="#Core.@__doc__"><code>Core.@__doc__</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@__doc__(ex)</code></pre><p>Low-level macro used to mark expressions returned by a macro that should be documented. If more than one expression is marked then the same docstring is applied to each expression.</p><pre><code class="language-none">macro example(f)
    quote
        $(f)() = 0
        @__doc__ $(f)(x) = 1
        $(f)(x, y) = 2
    end |&gt; esc
end</code></pre><p><code>@__doc__</code> has no effect when a macro that uses it is not documented.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/Docs.jl#L420-L435">source</a></section><footer><hr/><a class="previous" href="modules.html"><span class="direction">Previous</span><span class="title">モジュール</span></a><a class="next" href="metaprogramming.html"><span class="direction">Next</span><span class="title">メタプログラミング</span></a></footer></article></body></html>
