<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>プロファイリング · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">はじめよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">モジュール</a></li><li><a class="toctext" href="documentation.html">ドキュメンテーション</a></li><li><a class="toctext" href="metaprogramming.html">メタプログラミング</a></li><li><a class="toctext" href="arrays.html">多次元配列</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">ネットワークとストリーム</a></li><li><a class="toctext" href="parallel-computing.html">並列コンピューティング</a></li><li><a class="toctext" href="running-external-programs.html">外部プログラムの実行</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">C, Fortran コードの呼び出し</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Julia の埋め込み</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li class="current"><a class="toctext" href="profile.html">プロファイリング</a><ul class="internal"><li><a class="toctext" href="#基本的な使い方-1">基本的な使い方</a></li><li><a class="toctext" href="#蓄積とクリア-1">蓄積とクリア</a></li><li><a class="toctext" href="#プロファイル結果の表示を制御するオプション-1">プロファイル結果の表示を制御するオプション</a></li><li><a class="toctext" href="#構成・設定-1">構成・設定</a></li><li class="toplevel"><a class="toctext" href="#Memory-allocation-analysis-1">メモリ割り当て分析</a></li><li class="toplevel"><a class="toctext" href="#外部のプロファイリングツール-1">外部のプロファイリングツール</a></li></ul></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">パフォーマンス・ティップス</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">スタイルガイド</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">他の言語との注目すべき違い</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">リフレクションとインストロスペクション</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Julia ランタイムの初期化</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li><li><a class="toctext" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="toctext" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">クラッシュ(セグメンテーションフォルト)の報告と分析</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="profile.html">プロファイリング</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/profile.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>プロファイリング</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Profiling-1" href="#Profiling-1">プロファイリング</a></h1><p><code>Profile</code>モジュールには、開発者がコードのパフォーマンスを向上させるのに役立つツールが用意されています。使用すると、実行中のコードを測定し、各行の演算にどれくらいの時間が費やされているかを理解するのに役立つ出力を生成します。最も一般的な使用法は、最適化のターゲットとして「ボトルネック」を特定することです。</p><p><code>Profile</code>には、「サンプリング」すなわち、<a href="https://en.wikipedia.org/wiki/Profiling_(computer_programming)">統計的プロファイラー</a>として知られているものを実装されています。  これは、任意のタスクの実行中に定期的にバックトレースを取ることによって動作します。 各バックトレースは、現在実行中の関数と行番号、そして、この行の実行につながる関数呼び出しの完全な連鎖を補足します。そのため、(バックトレースで得られる状態は)現在の実行状態の &quot;スナップショット&quot; になります。</p><p>実行時間の多くが特定のコード行の実行に費やされている場合、この行はすべてのバックトレースのセットに頻繁に現れます。言い換えれば、特定の行の「コスト」、つまり、この行を含む関数の一連の呼び出しのコストは、すべてのバックトレースのセットに表示される頻度に比例します。</p><p>サンプリング プロファイラは、1行1行の実行に対する完全なカバレッジを提供しません。バックトレースが一定時間間隔で発生するからです(既定では、Unix システムで 1 ミリ秒、Windows では 10 ミリ秒ですが、実際のスケジューリングはオペレーティング システムの負荷の影響を受けます)。さらに、後で説明するように、サンプルは全実行ポイントに対してサンプル数のまばらな部分集合として収集されるため、サンプリング プロファイラによって収集されたデータは統計的ノイズの影響を受けます。</p><p>これらの制限にもかかわらず、サンプリング プロファイラには大きな強みがあります:</p><ul><li>演算時間測定を行うためにコードを変更する必要はありません(代替手段である <a href="https://github.com/timholy/IProfile.jl">インストルメンテーションプロファイラ</a>とは対照的です)。</li><li>Juliaのコアコードの中まで、さらには(オプションで)CおよびFortranライブラリの中もプロファイルすることができます。</li><li>&quot;まれに&quot; 実行する分には、パフォーマンスのオーバーヘッドはほとんどありません。プロファイリング中は、コードはほぼネイティブの速度で実行できます。</li></ul><p>このような理由から、代替案を検討する前に、組み込みのサンプリング プロファイラを使用することをお勧めします。</p><h2><a class="nav-anchor" id="基本的な使い方-1" href="#基本的な使い方-1">基本的な使い方</a></h2><p>簡単なテストケースを試してみましょう:</p><pre><code class="language-julia-repl">julia&gt; function myfunc()
           A = rand(200, 200, 400)
           maximum(A)
       end</code></pre><p>プロファイルするコードを少なくとも 1 回実行しておくのはよいアイディアです (Julia の JIT コンパイラをプロファイリングする場合を除く):</p><pre><code class="language-julia-repl">julia&gt; myfunc() # run once to force compilation</code></pre><p>これで、この関数をプロファイルする準備ができました:</p><pre><code class="language-julia-repl">julia&gt; using Profile

julia&gt; @profile myfunc()</code></pre><p>プロファイリング結果を確認するには、<a href="https://github.com/timholy/ProfileView.jl">グラフィカルブラウザ</a>を使用できますが、ここでは標準ライブラリに付属のテキストベースの表示を使用します:</p><pre><code class="language-julia-repl">julia&gt; Profile.print()
80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
 80 ./REPL.jl:97; macro expansion
  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)
   80 ./boot.jl:235; eval(::Module, ::Any)
    80 ./&lt;missing&gt;:?; anonymous
     80 ./profile.jl:23; macro expansion
      52 ./REPL[1]:2; myfunc()
       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...
        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...
       14 ./random.jl:278; rand
        14 ./random.jl:277; rand
         14 ./random.jl:366; rand
          14 ./random.jl:369; rand
      28 ./REPL[1]:3; myfunc()
       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...
        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...
        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...</code></pre><p>この表示の各行は、コード内の特定のスポット (行番号) を表します。インデントは、入れ子になった関数呼び出しのシーケンスを示すために使用され、よりインデントされた行は呼び出しのシーケンスの中でより深くなります。各行で、最初の「フィールド」は、<em>この行またはこの行で実行される関数</em>で受け取られたバックトレース(サンプル)の数です。 2 番目のフィールドはファイル名と行番号で、3 番目のフィールドは関数名です。 ジュリアのコードが変更されるにつれて、特定の行番号が変更される可能性があることに注意してください。この後の話についていくために、この例を自分で実行するのがベストです。</p><p>この例では、呼び出される最上位関数がファイル <code>event.jl</code> にあることがわかります。これは、Julia 起動時に REPL を実行する関数です。<code>REPL.jl</code> の 97 行を調べると、<code>eval_user_input()</code> 関数が呼び出される場所であることが分かります。これはREPLで入力した内容を評価する関数です。今は 対話的に作業しているので、<code>@profile myfunc()</code> をREPLから入力したときに、これら(訳注: <code>eval_user_input()のことだろうが、なぜ複数?) の関数が呼び出されました。次の行は[</code>@profile`](@ref)マクロで実行されたアクションを反映しています。</p><p>最初の行は<code>event.jl</code>の73行目で80個のバックトレースが取られたことを示していますが、この行自体の演算コストが高いわけでは有りません。: 3行目を見れば、これらのバックトレースの80個すべてが実際に<code>eval_user_input</code>への呼び出しの中でトリガされたことが明らかです。実際に時間がかかっている操作を調べるには、コール チェーンをより深く調べる必要があります。</p><p>この出力の最初の &quot;重要な&quot; 行はこれです:</p><pre><code class="language-none">52 ./REPL[1]:2; myfunc()</code></pre><p><code>REPL</code> は、REPL で <code>myfunc</code> を定義したという事実を指します。ファイルに<code>myfunc</code>が定義されたというわけではありません。ファイルを使用していた場合は、(<code>REPL</code>の代わりに)ファイル名が表示されます。<code>[1]</code> は、関数 <code>myfunc</code> がこの REPL セッションで評価された最初の式であることを示しています。<code>myfunc()</code> の 2 行目には <code>rand</code> の呼び出しが含まれており、この行で発生したバックトレースは 52 (80 のうち) でした。その下には、<code>dSFMT.jl</code> 内の<code>dSfmt_fill_array_close_open!</code> の呼び出しがあります。</p><p>もう少し下に行くと、下記の行が見つかります:</p><pre><code class="language-none">28 ./REPL[1]:3; myfunc()</code></pre><p><code>myfunc</code> の 3 行目には<code>maximum</code>の呼び出しがあり、ここで 28 (80 件中) のバックトレースがカウントされています。その下には、このタイプの入力データに対する<code>maximum</code> 関数内の時間のかかる処理を実行している、<code>base/reduce.jl</code>のある場所を確認できます。</p><p>全体として、乱数の生成は、最大の要素を見つける処理の約2倍のコストがかかると暫定的に結論付けることができます。より多くのサンプルを収集することで、この結果に対する確信を深めることができました:</p><pre><code class="language-julia-repl">julia&gt; @profile (for i = 1:100; myfunc(); end)

julia&gt; Profile.print()
[....]
 3821 ./REPL[1]:2; myfunc()
  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...
   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...
  310  ./random.jl:278; rand
   [....]
 2893 ./REPL[1]:3; myfunc()
  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...
   [....]</code></pre><p>一般に、ある行でのカウントが<code>N</code> サンプルであった場合、(コンピュータが他のタスクでビジー状態にあるかなど、他のノイズ源を除いて), その値の不確実性は、 <code>sqrt(N)</code>のオーダーであることが期待できます。このルールの主な例外は、実行頻度は低いが、非常に演算コストの高い傾向があるガベージ コレクションです。(Julia のガベージ コレクタは C で記述されているので、このようなイベントは、以下に説明する &#39;C=true&#39; 出力モードを使用するか、<a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a> を使用して検出できます。)</p><p>これは、デフォルト出力である 「ツリー型」ダンプを示しています; 他には、代替案は、入れ子構造に依存せずにカウントを蓄積する「フラット」ダンプです:\v</p><pre><code class="language-julia-repl">julia&gt; Profile.print(format=:flat)
 Count File          Line Function
  6714 ./&lt;missing&gt;     -1 anonymous
  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)
  6714 ./REPL.jl       97 macro expansion
  3821 ./REPL[1]        2 myfunc()
  2893 ./REPL[1]        3 myfunc()
  6714 ./REPL[7]        1 macro expansion
  6714 ./boot.jl      235 eval(::Module, ::Any)
  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...
  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
  6714 ./profile.jl    23 macro expansion
  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...
   310 ./random.jl    277 rand
   310 ./random.jl    278 rand
   310 ./random.jl    366 rand
   310 ./random.jl    369 rand
  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...
     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...</code></pre><p>コードで再帰が使われている場合、&quot;子&quot; 関数の行が合計バックトレースよりも多くのカウントを蓄積する可能性があります。次の関数定義を考えてみましょう:\v</p><pre><code class="language-julia">dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)
dumbsum3() = dumbsum(3)</code></pre><p><code>dumbsum3</code> をプロファイリングし、<code>dumbsum(1)</code> の実行中にバックトレースが取得された場合、バックトレースは次のようになります:</p><pre><code class="language-julia">dumbsum3
    dumbsum(3)
        dumbsum(2)
            dumbsum(1)</code></pre><p>その結果、親では1カウントのみなのに対して、この子関数は 3 カウントを取得します。「ツリー」表現はこれをより明確にします。そのため、ツリー表現は (特に) 結果を表示する際に最も便利な方法です。</p><h2><a class="nav-anchor" id="蓄積とクリア-1" href="#蓄積とクリア-1">蓄積とクリア</a></h2><p><a href="../stdlib/Profile.html#Profile.@profile"><code>@profile</code></a>の結果はバッファに蓄積されます。<a href="../stdlib/Profile.html#Profile.@profile"><code>@profile</code></a>で複数のコードを実行すると、<a href="../stdlib/Profile.html#Profile.print"><code>Profile.print()</code></a>は、それら複数のコードのプロファイルの結果を結合した結果を出力します。これは非常に便利ですが、プロファイルを新たに開始したい場合があります。その場合は、<a href="../stdlib/Profile.html#Profile.clear"><code>Profile.clear()</code></a>で、クリアできます。</p><h2><a class="nav-anchor" id="プロファイル結果の表示を制御するオプション-1" href="#プロファイル結果の表示を制御するオプション-1">プロファイル結果の表示を制御するオプション</a></h2><p><a href="../stdlib/Profile.html#Profile.print"><code>Profile.print</code></a> は、これまで説明した以外にも多くのオプションを持っています。全てここで見てみましょう:</p><pre><code class="language-julia">function print(io::IO = stdout, data = fetch(); kwargs...)</code></pre><p>まず 2 つの位置引数について説明し、後にキーワード引数を説明します:</p><ul><li><p><code>io</code> – ファイルなどのバッファに結果を保存する。デフォルトでは<code>stdout</code> (コンソール) へのプリント出力。</p></li><li><p><code>data</code> – 分析したいデータを指定する; デフォルトでは、事前割り当てされたバッファーからバックトレース情報を取り出す <a href="../stdlib/Profile.html#Profile.fetch"><code>Profile.fetch()</code></a> から取得されま。たとえば、プロファイラーをプロファイリングする場合は、次のように指定できます:</p><pre><code class="language-julia">data = copy(Profile.fetch())
Profile.clear()
@profile Profile.print(stdout, data) # Prints the previous results
Profile.print()                      # Prints results from Profile.print()</code></pre></li></ul><p>キーワード引数には、次の任意の組み合わせを指定できます:</p><ul><li><code>format</code> – 上で紹介したように、バックトレースの表示形式を決定します。  関数コールの木構造を示すインデントを用いる <code>:tree</code>(デフォルト) とインデント無しの<code>:flat</code></li><li><code>C</code> – <code>true</code> の場合、C コードと Fortran コードからのバックトレースが表示されます (通常は除外されます)。 <code>Profile.print(C = true)</code>の紹介例を示すので実行してみてください。この機能は、ボトルネックになっているのが Juliaコードなのか、Cコードの部分なのか判断するのに大変役立ちます。 <code>C = true</code> を設定すると、より長いプロファイルダンプになってしまいますが、ネストの解釈はしやすくなります。</li><li><code>combine</code> – コード行の中には複数の操作が含まれていることがあります。たとえば、<code>s += A[i]</code> には配列の参照(<code>A[i]</code>)と加算の両方が含まれています。 これらは、生成されたマシンコードでは、別々の行に対応しています。そのため、この行のバックトレース中で2つ以上の異なるアドレスがキャプチャかもしれません。 <code>combine = true</code> オプションはそれらを一緒にまとめます。これはおそらくあなたが通常望む動作でしょう。 ただし、<code>combine = false</code> オプションを使えば、一意の命令ポインターごとにに出力を生成することもできます。</li><li><code>maxdepth</code> – <code>:tree</code> 形式での <code>maxdepth</code> よりさらに大きい値を持つ深さで表示するフレームを制限します。</li><li><code>sortby</code> – <code>:flat</code> 形式での表示順序を制御します。<code>:filefuncline</code> (デフォルト) はソースファイルによるソート、<code>:count</code> は収集されたサンプルの数の順番でのソートです。</li><li><code>noisefloor</code> – サンプル数のノイズフロアをヒューリスティックに指定します。ノイズフロアより下のフレームは表示が制限されます(フォーマット<code>:tree</code>にのみ適用されます)。 これを試す際の推奨値は 2.0 です (デフォルトは 0)。このパラメーターは、<code>n &lt;= ノイズフロア * √N</code> のサンプルを非表示にします。 ここで <code>n</code> は、この行のサンプルの数で、<code>N</code> は呼び出し先のサンプルの数です。</li><li><code>mincount</code> – ここで指定した値よりも小さいオカレンスのフレームを制限します。</li></ul><p>ファイル/関数名は、(<code>...</code>) を使って切り捨て表示されることがあります。 また、インデントは先頭で <code>+n</code> で切り捨てられます。ここで <code>n</code> は挿入される追加のスペースの数です。深くネストされたコードの完全なプロファイルが必要な場合は、<a href="../base/io-network.html#Base.IOContext"><code>IOContext</code></a>で広い「表示サイズ」を使用してファイルに保存することをお考えめします:</p><pre><code class="language-julia">open(&quot;/tmp/prof.txt&quot;, &quot;w&quot;) do s
    Profile.print(IOContext(s, :displaysize =&gt; (24, 500)))
end</code></pre><h2><a class="nav-anchor" id="構成・設定-1" href="#構成・設定-1">構成・設定</a></h2><p><a href="../stdlib/Profile.html#Profile.@profile"><code>@profile</code></a> はバックトレースを蓄積するだけです。実際の分析は、<a href="../stdlib/Profile.html#Profile.print"><code>Profile.print()</code></a>を呼び出したときに行われます。実行時間の長い計算では、バックトレースを格納するために事前に割り当てられたバッファがいっぱいになる可能性があります。その場合、バックトレースは停止しますが、プロファイル対象の計算自体は続行されます。 その結果、いくつかの重要なプロファイリング データを見逃す可能性があります (その場合は警告が表示されます)。</p><p>以下で、関連するパラメータを取得および構成できます:</p><pre><code class="language-julia">Profile.init() # returns the current settings
Profile.init(n = 10^7, delay = 0.01)</code></pre><p><code>n</code> は、格納できる命令ポインターの合計数で、デフォルト値は <code>10^6</code> です。 一般的なバックトレースが 20 の命令ポインタである場合は、50000 バックトレースを収集できるため、統計的な不確実性が 1% 未満であることを示唆しています。これは、ほとんどのアプリケーションで十分でしょう。</p><p><code>delay</code>は、要求された計算を実行するための複数スナップショットの間でJuliaが取得する時間長を秒単位で表記するものですが、前文のような状況であればその結果、この<code>delay</code>の修正が必要になる可能性が高くなります。非常に長い時間実行されるジョブでは、頻繁なバックトレースは必要ない場合があります。デフォルトの設定は&#39;遅延 = 0.001&#39;です。 もちろん、遅延を減らすだけでなく、遅延を増やすことができます。ただし、遅延がバックトレース (作成者のラップトップで約 30 マイクロ秒) を取るのに必要な時間に近くなると、プロファイリングのオーバーヘッドが大きくなります。</p><h1><a class="nav-anchor" id="Memory-allocation-analysis-1" href="#Memory-allocation-analysis-1">メモリ割り当て分析</a></h1><p>パフォーマンスを向上させる最も一般的な手法の 1 つは、メモリ割り当てを減らすことです。メモリ割り当ての合計量は<a href="../base/base.html#Base.@time"><code>@time</code></a>と<a href="../base/base.html#Base.@allocated"><code>@allocated</code></a>で測定することができ、メモリ割り当てをトリガする特定の行は、多くの場合、これらの行で発生するガベージコレクションによる演算コストを介してプロファイリングから推測することができます。ただし、コード行ごとに割り当てられるメモリの量を直接測定する方が効率的な場合もあります。</p><p>メモリ割り当てを 1 行ずつ測定するには、<code>--track-allocation=&lt;setting&gt;</code>コマンドラインオプションをついけてJulia を起動します。 選択可能なオプションは、<code>none</code> (デフォルト値。メモリ割り当てを測定しない) 、<code>user</code>(Juliaのコアコードを除く、Juliaコードの各行におけるメモリ割り当てを測定する), <code>all</code>(全Juliaコードの各行でメモリ割り当てを測定)です。 Julia終了時、各ソースファイルのファイル名の後に<code>.mem</code>が付加されたテキストファイルに書き込まれます。出力先は、ソース ファイルと同じディレクトリです。 各行には、合計バイト数が一覧表示されます。<a href="https://github.com/JuliaCI/Coverage.jl"><code>Coverage</code> パッケージ</a> には、基本的な分析ツール、例えば メモリ割り当てのバイト数での行ソートなど、が含まれています。</p><p>結果を解釈する際には、いくつか重要な詳細情報があるので気をつけてください。 <code>--track-allocation=user</code> で実行した場合、REPL から直接呼び出される関数の最初の行には、REPLからの関数コール自体に含まれメモリ割り当ての情報が示されます。 さらに重要なのは、ジュリアのコンパイラの多くはジュリアで書かれているので(そしてコンパイルは通常メモリ割当が必要なので)、JIT コンパイルによってメモリ割り当てカウントが追加されるということです。推奨される手順は、すべての分析したいすべてのコマンドをを実行して強制的にコンパイルしておき、<a href="../stdlib/Profile.html#Profile.clear_malloc_data"><code>Profile.clear_malloc_data()</code></a>を呼び出して、すべての割り当てカウンタをリセットすることです。  最後に、目的のコマンドを実行し、ジュリアを終了して &#39;.mem&#39;ファイルの生成をトリガーします。</p><h1><a class="nav-anchor" id="外部のプロファイリングツール-1" href="#外部のプロファイリングツール-1">外部のプロファイリングツール</a></h1><p>現在、Juliaは外部プロファイリングツールとして<code>Intel VTune</code>、<code>OProfile</code>、<code>perf</code>をサポートしています。</p><p>選択したツールに応じて、<code>Make.user</code>ファイル内で、<code>USE_INTEL_JITEVENTS</code>、<code>USE_OPROFILE_JITEVENTS</code>、<code>USE_PERF_JITEVENTS</code> などを1に設定してコンパイルしてください。複数のフラグがサポートされています。</p><p>Julia を実行する前に、環境変数 <code>ENABLE_JITPROFILING</code> を 1 に設定します。</p><p>これで、あなたはこれらのツールを使用する多数の方法を手に入れました。たとえば、<code>OProfile</code> を使用すると、簡単な記録をすることができます:</p><pre><code class="language-none">&gt;ENABLE_JITPROFILING=1 sudo operf -Vdebug ./julia test/fastmath.jl
&gt;opreport -l `which ./julia`</code></pre><p>または <code>perf</code>とにたやり方で:</p><pre><code class="language-none">$ ENABLE_JITPROFILING=1 perf record -o /tmp/perf.data --call-graph dwarf ./julia /test/fastmath.jl
$ perf report --call-graph -G</code></pre><p>あなたのプログラムついて測定を行う方法は他にもたくさんあり、興味深いです。包括的なリストを見たければ,<a href="http://www.brendangregg.com/perf.html">Linux perfの例のページ</a>を読んでください。</p><p>実行ごとにperfは、 <code>perf.data</code> ファイルを保存し、小規模なプログラムの場合でも非常に大きなファイルを保存できることを覚えておいてください。また、perf LLVMモジュールは、一時的にデバッグオブジェクトを<code>~/.debug/jit</code>に保存しますから、そのフォルダを頻繁にクリーンアップすることを忘れないでください。</p><footer><hr/><a class="previous" href="code-loading.html"><span class="direction">Previous</span><span class="title">Code Loading</span></a><a class="next" href="stacktraces.html"><span class="direction">Next</span><span class="title">Stack Traces</span></a></footer></article></body></html>
