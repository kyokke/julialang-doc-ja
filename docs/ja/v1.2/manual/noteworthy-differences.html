<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>他の言語との注目すべき違い · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">はじめよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">モジュール</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">メタプログラミング</a></li><li><a class="toctext" href="arrays.html">多次元配列</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">ネットワークとストリーム</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">C, Fortran コードの呼び出し</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Julia の埋め込み</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">パフォーマンス・ティップス</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">スタイルガイド</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li class="current"><a class="toctext" href="noteworthy-differences.html">他の言語との注目すべき違い</a><ul class="internal"><li><a class="toctext" href="#MATLAB-との注目すべき違い-1">MATLAB との注目すべき違い</a></li><li><a class="toctext" href="#R-との注目すべき違い-1">R との注目すべき違い</a></li><li><a class="toctext" href="#Python-との注目すべき違い-1">Python との注目すべき違い</a></li><li><a class="toctext" href="#C/C-との注目すべき違い-1">C/C++ との注目すべき違い</a></li></ul></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">プロファイリング</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">リフレクションとインストロスペクション</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Julia ランタイムの初期化</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li><li><a class="toctext" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="toctext" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">クラッシュ(セグメンテーションフォルト)の報告と分析</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="noteworthy-differences.html">他の言語との注目すべき違い</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/noteworthy-differences.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>他の言語との注目すべき違い</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="他の言語との注目すべき違い-1" href="#他の言語との注目すべき違い-1">他の言語との注目すべき違い</a></h1><h2><a class="nav-anchor" id="MATLAB-との注目すべき違い-1" href="#MATLAB-との注目すべき違い-1">MATLAB との注目すべき違い</a></h2><p>MATLAB ユーザーはジュリアの構文を親しみやすいと思うかもしれませんが、Juliaは MATLAB クローンではありません。構文や機能の違いは大きいです。MATLAB に慣れているJuliaユーザーがつまずきやすい注目すべき違いは次のとおりです:</p><ul><li>Julia の配列は角かっこで <code>A[i,j]</code>のようにインデックス付けされる。</li><li>Juliaでは、配列は他の変数に代入してもコピーされません。 <code>A = B</code>の後、<code>B</code>の要素を変更すると <code>A</code>も同様に変更されます。</li><li>Juliaでは、値は関数に渡されてもコピーされません。関数が配列を変更すると、その変更は呼び出し元にも影響を与えます。</li><li>Juliaでは、代入文の中で配列のサイズが自動的に拡張されません。 MATLABでは <code>a(4)= 3.2</code>で<code>a = [0 0 0 3.2]</code>が生成され、その後<code>a(5)= 7</code>とすると<code>a = [0 0 0 3.2 7]</code>と配列のサイズが大きくなります。対して、Juliaで <code>a [5] = 7</code>とすると、<code>a</code>の長さが5より場合、もしくは、この代入式が識別子<code>a</code>を初めて使用する式である場合には、エラーが発生します。Juliaには、<a href="../base/collections.html#Base.push!"><code>push!</code></a>関数や<a href="../base/collections.html#Base.append!"><code>append!</code></a>関数があり、ベクトルのサイズを拡張する手段として、MATLABの <code>a(end + 1)= val</code>よりもはるかに効率的です。</li><li>虚数単位 <code>sqrt(-1)</code>は、MATLABでは<code>i</code>や<code>j</code>が用いられますが、Juliaでは<a href="../base/numbers.html#Base.im"><code>im</code></a>と表記します。</li><li>Juliaでは、小数点のない数値リテラル( <code>42</code>など)は浮動小数点ではなく整数を作成します。任意の大きな整数リテラルがサポートされています。その結果、一部の演算では 例えば <code>julia&gt; a = -1; 2^a</code> のように 浮動小数点を想定している場合、「演算結果が整数ではない」というドメインエラーが発生します(詳細については、<a href="faq.html#faq-domain-errors-1">ドメインエラーに関するFAQ</a>を参照)。</li><li>Juliaでは、複数の値が返され、タプルとして割り当てられます。例えば <code>(a,b) = (1,2)</code> や <code>a, b = 1, 2</code> という具合です。MATLABの <code>nargout</code>は、呼び出し側から期待される戻り値の数に基づいて選択的な処理をを行うもので、MATLABではよく使用されますが、Julia では使用できません。代わりに、ユーザーはオプション引数、キーワード引数の機能を使って、似たようなことをできます。</li><li>Juliaは真の1次元配列を持っています。列ベクトルは、サイズが<code>N</code>で、<code>Nx1</code>ではありません。例えば、<a href="../stdlib/Random.html#Base.rand"><code>rand(N)</code></a>は1次元配列を作成します。</li><li>Juliaでは、 <code>[x、y、z]</code>は常に <code>x</code>、<code>y</code>、 <code>z</code>を含む3要素の配列を構築します。<ul><li>最初の( &quot;垂直方向の&quot;)次元で連結するには、<a href="../base/arrays.html#Base.vcat"><code>vcat(x, y, z)</code></a>を使うか、配列の要素をセミコロンで分割します( <code>[x; y; z]</code>)。</li><li>2番目の( &quot;水平方向の&quot;)次元で連結するには、<a href="../base/arrays.html#Base.hcat"><code>hcat(x, y, z)</code></a>を使うか、配列の要素をスペースで分割します( <code>[x y z]</code>)。</li><li>ブロック行列を構築する(最初の2つの次元で連結する)には、<a href="../base/arrays.html#Base.hvcat"><code>hvcat</code></a>を使うか、スペースとセミコロンを組み合わせます( <code>[a b; c d]</code>)。</li></ul></li><li>Juliaでは、 <code>a：b</code>と<code>a：b：c</code>は <code>AbstractRange</code>オブジェクトを構成します。 MATLABのように完全なベクトルを作成するには、<a href="../base/collections.html#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a>を使用してください。しかし、一般的には <code>collect</code>を呼び出す必要はありません。 AbstractRangeオブジェクトはほとんどのケースで通常の配列のように振る舞いますが、その値を遅延計算するためより効率的です。完全な配列ではなく特殊化されたオブジェクトを作成するというこのパターンはよく使用されていて、<a href="../base/math.html#Base.range"><code>range</code></a>のような関数や、<code>enumerate</code>や、<code>zip</code> のようなイテレータでも見られます。特殊オブジェクトは、通常の配列のように使用することができます。</li><li>Juliaの関数は、最後の式または <code>return</code>キーワードから戻り値を返します。MATLABのように、関数定義で戻り値の名前を列挙するのではありません。(詳細は<a href="functions.html#the-return-keyword-1">returnキーワード</a>を参照)。</li><li>Juliaスクリプトには関数をいくつでも含めることができ、ファイルがロードされれば、すべての関数定義は外部から見えます。現在の作業ディレクトリの外にあるファイルからも関数定義はロードすることができます。</li><li>Juliaでは、<a href="../base/collections.html#Base.sum"><code>sum</code></a>、<a href="../base/collections.html#Base.prod"><code>prod</code></a>、<a href="../base/math.html#Base.max"><code>max</code></a>のような簡約処理は、<code>sum(A)</code>のように単一の引数で呼び出された場合、全ての要素に対して行われます。たとえ <code>A</code>が2次元以上だったとしても、です。</li><li>Juliaでは、<a href="../stdlib/Random.html#Base.rand"><code>rand()</code></a>のように、ゼロ引数で関数を呼び出すには括弧を使用する必要があります。</li><li>Juliaは、文を終了するのにセミコロンを使用することを推奨していません。（対話式プロンプトでの実行を除き）式の結果が自動出力されませんので（出力を抑制したいのだとしても)コードの行末にセミコロンを使う必要はありません。<a href="../base/io-network.html#Base.println"><code>println</code></a>または<a href="../stdlib/Printf.html#Printf.@printf"><code>@printf</code></a>を使ってプリント出力することができます。</li><li>Juliaでは、 <code>A</code>と<code>B</code>が配列の場合、 <code>A == B</code>のような論理比較演算は真偽値の配列を返しません。(要素ごとの比較結果が欲しい場合には) 代わりに<code>A.== B</code>を使用してください。<a href="../base/math.html#Base.:&lt;"><code>&lt;</code></a>や<a href="../base/math.html#Base.:&gt;"><code>&gt;</code></a>。のような他のブール演算子についても同様です。</li><li>Juliaでは、演算子<a href="../base/math.html#Base.:&amp;"><code>&amp;</code></a>、<a href="../base/math.html#Base.:|"><code>|</code></a>、および<a href="../base/math.html#Base.xor"><code>⊻</code></a>(<a href="../base/math.html#Base.xor"><code>xor</code></a>)で、それぞれMATLABにおける <code>and</code>、<code>or</code>、および <code>xor</code>と等価なビット演算が行われます。演算の優先度は、Pythonのビット演算子に似ています(Cとは異なります)。それらはスカラーまたは要素ごとに操作でき、論理配列と組み合わせることもできますが、操作の順序の違いに注意してください: 括弧が必要な場合があります(例えば、1または2に等しい <code>A</code>の要素を選択するには、<code>(A。== 1)|(A。== 2)</code>を使用します)。</li><li>Juliaでは、接合演算子<code>...</code> を使って<code>xs = [1,2]; f(xs...)</code>のようにして、コレクションの要素を引数として関数に渡すことができます。</li></ul><p>  * Juliaの<a href="../stdlib/LinearAlgebra.html#LinearAlgebra.svd"><code>svd</code></a>は特異値を密な対角行列ではなくベクトルとして返します。   * Juliaでは、 <code>...</code>はコード行を継続するためには使用されません。代わりに、不完全な式は自動的に、次の行へと解釈が継続します。</p><ul><li>JuliaとMATLABの両方で、対話式セッションでは、変数 <code>ans</code>は最後に発行された式の値に設定されますが、 Juliaでは、MATLABと異なり、Juliaコードが非インタラクティブモードで実行されるときには、 <code>ans</code>は設定されません。</li><li>Juliaの <code>struct</code>は、MATLABの<code>class</code>とは異なり、実行時に動的なフィールドを追加をサポートしません。代わりに、<a href="../base/collections.html#Base.Dict"><code>Dict</code></a>を使ってください。</li><li>Juliaでは各モジュールは独自のグローバルスコープ/名前空間を持ちますが、MATLABでは1つのグローバルスコープしかありません。</li><li>MATLABでは、不要な値を削除するための慣用的な方法は、次のように論理インデックスを使用すること　で、<code>x(x&gt; 3)</code>としたり <code>x(x&gt; 3)= []</code>と<code>x</code>を上書きしたりします。対してJuliaでは、より高次の関数<a href="../base/collections.html#Base.filter"><code>filter</code></a>と<a href="../base/collections.html#Base.filter!"><code>filter!</code></a>が利用できます。MATLABのコードをそのままJuliaに書き換えた<code>x [x.&gt; 3]</code>や <code>x = x [x.&gt; 3]</code> の代わりに、<code>filter(z-&gt; z&gt; 3,x)</code>や、<code>filter!(z-&gt; z&gt; 3,x)</code>と書くことができます。 <a href="../base/collections.html#Base.filter!"><code>filter!</code></a>を使うと一時配列の使用を減らすことができます。</li><li>セル配列のすべての要素を抽出する(つまり「間接参照する」)には、MATLABでは<code>vertcat(A {:})</code>が使われますが、Julia で同様のことを行うには、接合演算子を使って<code>vcat(A ...)</code>と書きます。</li></ul><h2><a class="nav-anchor" id="R-との注目すべき違い-1" href="#R-との注目すべき違い-1">R との注目すべき違い</a></h2><p>One of Julia&#39;s goals is to provide an effective language for data analysis and statistical programming.  For users coming to Julia from R, these are some noteworthy differences:</p><ul><li><p>Julia&#39;s single quotes enclose characters, not strings.</p></li><li><p>Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.</p></li><li><p>In Julia, like Python but unlike R, strings can be created with triple quotes <code>&quot;&quot;&quot; ... &quot;&quot;&quot;</code>. This syntax is convenient for constructing strings that contain line breaks.</p></li><li><p>In Julia, varargs are specified using the splat operator <code>...</code>, which always follows the name of a specific variable, unlike R, for which <code>...</code> can occur in isolation.</p></li><li><p>In Julia, modulus is <code>mod(a, b)</code>, not <code>a %% b</code>. <code>%</code> in Julia is the remainder operator.</p></li><li><p>In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:</p><ul><li>In R, <code>c(1, 2, 3, 4)[c(TRUE, FALSE)]</code> is equivalent to <code>c(1, 3)</code>.</li><li>In R, <code>c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]</code> is equivalent to <code>c(1, 3)</code>.</li><li>In Julia, <code>[1, 2, 3, 4][[true, false]]</code> throws a <a href="../base/base.html#Core.BoundsError"><code>BoundsError</code></a>.</li><li>In Julia, <code>[1, 2, 3, 4][[true, false, true, false]]</code> produces <code>[1, 3]</code>.</li></ul></li><li><p>Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range.  For example, <code>c(1, 2, 3, 4) + c(1, 2)</code> is valid R but the equivalent <code>[1, 2, 3, 4] + [1, 2]</code> will throw an error in Julia.</p></li><li><p>Julia allows an optional trailing comma when that comma does not change the meaning of code. This can cause confusion among R users when indexing into arrays. For example, <code>x[1,]</code> in R would return the first row of a matrix; in Julia, however, the comma is ignored, so <code>x[1,] == x[1]</code>, and will return the first element. To extract a row, be sure to use <code>:</code>, as in <code>x[1,:]</code>.</p></li><li><p>Julia&#39;s <a href="../base/collections.html#Base.map"><code>map</code></a> takes the function first, then its arguments, unlike <code>lapply(&lt;structure&gt;, function, ...)</code> in R. Similarly Julia&#39;s equivalent of <code>apply(X, MARGIN, FUN, ...)</code> in R is <a href="../base/arrays.html#Base.mapslices"><code>mapslices</code></a> where the function is the first argument.</p></li><li><p>Multivariate apply in R, e.g. <code>mapply(choose, 11:13, 1:3)</code>, can be written as <code>broadcast(binomial, 11:13, 1:3)</code> in Julia. Equivalently Julia offers a shorter dot syntax for vectorizing functions <code>binomial.(11:13, 1:3)</code>.</p></li><li><p>Julia uses <code>end</code> to denote the end of conditional blocks, like <code>if</code>, loop blocks, like <code>while</code>/ <code>for</code>, and functions. In lieu of the one-line <code>if ( cond ) statement</code>, Julia allows statements of the form <code>if cond; statement; end</code>, <code>cond &amp;&amp; statement</code> and <code>!cond || statement</code>. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. <code>cond &amp;&amp; (x = value)</code>.</p></li><li><p>In Julia, <code>&lt;-</code>, <code>&lt;&lt;-</code> and <code>-&gt;</code> are not assignment operators.</p></li><li><p>Julia&#39;s <code>-&gt;</code> creates an anonymous function.</p></li><li><p>Julia constructs vectors using brackets. Julia&#39;s <code>[1, 2, 3]</code> is the equivalent of R&#39;s <code>c(1, 2, 3)</code>.</p></li><li><p>Julia&#39;s <a href="../base/strings.html#Base.:*-Tuple{Union{AbstractChar, AbstractString},Vararg{Union{AbstractChar, AbstractString},N} where N}"><code>*</code></a> operator can perform matrix multiplication, unlike in R. If <code>A</code> and <code>B</code> are matrices, then <code>A * B</code> denotes a matrix multiplication in Julia, equivalent to R&#39;s <code>A %*% B</code>. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write <code>A .* B</code> in Julia.</p></li><li><p>Julia performs matrix transposition using the <code>transpose</code> function and conjugated transposition using the <code>&#39;</code> operator or the <code>adjoint</code> function. Julia&#39;s <code>transpose(A)</code> is therefore equivalent to R&#39;s <code>t(A)</code>. Additionally a non-recursive transpose in Julia is provided by the <code>permutedims</code> function.</p></li><li><p>Julia does not require parentheses when writing <code>if</code> statements or <code>for</code>/<code>while</code> loops: use <code>for i in [1, 2, 3]</code> instead of <code>for (i in c(1, 2, 3))</code> and <code>if i == 1</code> instead of <code>if (i == 1)</code>.</p></li><li><p>Julia does not treat the numbers <code>0</code> and <code>1</code> as Booleans. You cannot write <code>if (1)</code> in Julia, because <code>if</code> statements accept only booleans. Instead, you can write <code>if true</code>, <code>if Bool(1)</code>, or <code>if 1==1</code>.</p></li><li><p>Julia does not provide <code>nrow</code> and <code>ncol</code>. Instead, use <code>size(M, 1)</code> for <code>nrow(M)</code> and <code>size(M, 2)</code> for <code>ncol(M)</code>.</p></li><li><p>Julia is careful to distinguish scalars, vectors and matrices.  In R, <code>1</code> and <code>c(1)</code> are the same. In Julia, they cannot be used interchangeably.</p></li><li><p>Julia&#39;s <a href="../stdlib/LinearAlgebra.html#LinearAlgebra.diag"><code>diag</code></a> and <a href="../stdlib/LinearAlgebra.html#LinearAlgebra.diagm"><code>diagm</code></a> are not like R&#39;s.</p></li><li><p>Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write <code>diag(M) = fill(1, n)</code>.</p></li><li><p>Julia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in <a href="https://pkg.julialang.org/">packages</a> under the <a href="https://github.com/JuliaStats">JuliaStats organization</a>. For example:</p><ul><li>Functions pertaining to probability distributions are provided by the <a href="https://github.com/JuliaStats/Distributions.jl">Distributions package</a>.</li><li>The <a href="https://github.com/JuliaData/DataFrames.jl">DataFrames package</a> provides data frames.</li><li>Generalized linear models are provided by the <a href="https://github.com/JuliaStats/GLM.jl">GLM package</a>.</li></ul></li><li><p>Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple or a named tuple: instead of <code>list(a = 1, b = 2)</code>, use <code>(1, 2)</code> or <code>(a=1, b=2)</code>.</p></li><li><p>Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia&#39;s multiple dispatch system means that <code>table(x::TypeA)</code> and <code>table(x::TypeB)</code> act like R&#39;s <code>table.TypeA(x)</code> and <code>table.TypeB(x)</code>.</p></li><li><p>In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</p></li><li><p>In Julia, vectors and matrices are concatenated using <a href="../base/arrays.html#Base.hcat"><code>hcat</code></a>, <a href="../base/arrays.html#Base.vcat"><code>vcat</code></a> and <a href="../base/arrays.html#Base.hvcat"><code>hvcat</code></a>, not <code>c</code>, <code>rbind</code> and <code>cbind</code> like in R.</p></li><li><p>In Julia, a range like <code>a:b</code> is not shorthand for a vector like in R, but is a specialized <code>AbstractRange</code> object that is used for iteration without high memory overhead. To convert a range into a vector, use <a href="../base/collections.html#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a>.</p></li><li><p>Julia&#39;s <a href="../base/math.html#Base.max"><code>max</code></a> and <a href="../base/math.html#Base.min"><code>min</code></a> are the equivalent of <code>pmax</code> and <code>pmin</code> respectively in R, but both arguments need to have the same dimensions.  While <a href="../base/collections.html#Base.maximum"><code>maximum</code></a> and <a href="../base/collections.html#Base.minimum"><code>minimum</code></a> replace <code>max</code> and <code>min</code> in R, there are important differences.</p></li><li><p>Julia&#39;s <a href="../base/collections.html#Base.sum"><code>sum</code></a>, <a href="../base/collections.html#Base.prod"><code>prod</code></a>, <a href="../base/collections.html#Base.maximum"><code>maximum</code></a>, and <a href="../base/collections.html#Base.minimum"><code>minimum</code></a> are different from their counterparts in R. They all accept an optional keyword argument <code>dims</code>, which indicates the dimensions, over which the operation is carried out.  For instance, let <code>A = [1 2; 3 4]</code> in Julia and <code>B &lt;- rbind(c(1,2),c(3,4))</code> be the same matrix in R.  Then <code>sum(A)</code> gives the same result as <code>sum(B)</code>, but <code>sum(A, dims=1)</code> is a row vector containing the sum over each column and <code>sum(A, dims=2)</code> is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate <code>colSums(B)</code> and <code>rowSums(B)</code> functions provide these functionalities. If the <code>dims</code> keyword argument is a vector, then it specifies all the dimensions over which the sum is performed, while retaining the dimensions of the summed array, e.g. <code>sum(A, dims=(1,2)) == hcat(10)</code>. It should be noted that there is no error checking regarding the second argument.</p></li><li><p>Julia has several functions that can mutate their arguments. For example, it has both <a href="../base/sort.html#Base.sort"><code>sort</code></a> and <a href="../base/sort.html#Base.sort!"><code>sort!</code></a>.</p></li><li><p>In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</p></li><li><p>Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.</p></li><li><p>Julia does not support the <code>NULL</code> type. The closest equivalent is <a href="../base/constants.html#Core.nothing"><code>nothing</code></a>, but it behaves like a scalar value rather than like a list. Use <code>x === nothing</code> instead of <code>is.null(x)</code>.</p></li><li><p>In Julia, missing values are represented by the <a href="../base/base.html#Base.missing"><code>missing</code></a> object rather than by <code>NA</code>. Use <a href="../base/base.html#Base.ismissing"><code>ismissing(x)</code></a> (or <code>ismissing.(x)</code> for element-wise operation on vectors) instead of <code>is.na(x)</code>. The <a href="../base/base.html#Base.skipmissing"><code>skipmissing</code></a> function is generally used instead of <code>na.rm=TRUE</code> (though in some particular cases functions take a <code>skipmissing</code> argument).</p></li><li><p>Julia lacks the equivalent of R&#39;s <code>assign</code> or <code>get</code>.</p></li><li><p>In Julia, <code>return</code> does not require parentheses.</p></li><li><p>In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression <code>x[x&gt;3]</code> or in the statement <code>x = x[x&gt;3]</code> to modify <code>x</code> in-place. In contrast, Julia provides the higher order functions <a href="../base/collections.html#Base.filter"><code>filter</code></a> and <a href="../base/collections.html#Base.filter!"><code>filter!</code></a>, allowing users to write <code>filter(z-&gt;z&gt;3, x)</code> and <code>filter!(z-&gt;z&gt;3, x)</code> as alternatives to the corresponding transliterations <code>x[x.&gt;3]</code> and <code>x = x[x.&gt;3]</code>. Using <a href="../base/collections.html#Base.filter!"><code>filter!</code></a> reduces the use of temporary arrays.</p></li></ul><h2><a class="nav-anchor" id="Python-との注目すべき違い-1" href="#Python-との注目すべき違い-1">Python との注目すべき違い</a></h2><ul><li>Julia は、コードブロックの終わりに<code>end</code> が必要です。Pythonとは違って Julia には <code>pass</code> キーワードがありません。</li><li>Julia では、配列、文字列などのインデックスは 0 からではなく 1 から始まります。</li><li>Julia のスライス インデックス作成には、Python とは異なり、最後の要素が含まれています。ジュリアの<code>a[2:3]</code> は Python の <code>a[1:3]</code> です。</li><li>Julia は負のインデックスをサポートしていません。特に、リストまたは配列の最後の要素は、Python では <code>-1</code> ですが、Julia では <code>end</code> でインデックス付けされます。</li><li>Julia の <code>for</code>、<code>if</code>、<code>while</code>などのブロックは <code>end</code> キーワードで終了します。インデントレベルはPythonほど重要ではありません。</li><li>Julia には行継続構文がありません: 行末で、これまでの入力が完全な式である場合は、完了したと見なされますが、それ以外の場合は、入力が続行されます。式を括弧でくくると(そして行内で括弧を閉じなければ) 強制的に次の行に続行することができます。</li><li>Julia 配列は列メジャー (Fortran オーダー) ですが、NumPy 配列はデフォルトで行メジャー (C オーダー) です。配列をループする際に最適なパフォーマンスを得るには、NumPy に対して Julia でループの順序を逆にする必要があります (<a href="performance-tips.html#man-performance-tips-1">パフォーマンス・ティップス</a>の関連する節を参照)。</li><li>Julia の更新演算子(例:<code>+=</code>、<code>-=</code>、...)は<em>インプレースではありません</em>(NumPy の更新演算子は インプレースですが) 。どういうことかというと、 <code>A = [1, 1]; B = A; B += [3, 3]</code> は <code>A</code> の値を変更せず、新しい配列である右側の <code>B = B + 3</code> の結果に <code>B</code> という名前を再バインドします。インプレース操作の場合は、<code>B.+= 3</code>を使用してください。 ( <a href="mathematical-operations.html#man-dot-operators-1">ドット演算子</a>、示的なループ、または <code>InplaceOps.jl</code>を参照)</li><li>Julia は、関数の定義時に既定値が 1 回だけ評価される Python とは異なり、メソッドが呼び出されるたびに関数引数の既定値を評価します。たとえば、関数 <code>f(x=rand()= x</code> は、引数なしで呼び出されるたびに新しい乱数を返します。 一方、関数 <code>g(x=[1,2]) = push!(x,3)</code> は <code>g()</code> と呼ばれるたびに <code>[1,2,3]</code> を返します。</li><li>Julia では、<code>%</code> は reminder 演算子ですが、Python ではモジュラスです。(訳者注: reminder は商に負の数を許した上での剰余)</li><li>The commonly used <code>Int</code> type corresponds to the machine integer type (<code>Int32</code> or <code>Int64</code>).  This means it will overflow, such that <code>2^64 == 0</code>. If you need larger values use another appropriate type, such as <code>Int128</code>, <a href="../base/numbers.html#Base.GMP.BigInt"><code>BigInt</code></a> or a floating point type like <code>Float64</code>.</li></ul><h2><a class="nav-anchor" id="C/C-との注目すべき違い-1" href="#C/C-との注目すべき違い-1">C/C++ との注目すべき違い</a></h2><ul><li>Julia 配列は角かっこでインデックス付けされ、複数次元の配列を扱えます <code>A[i,j]</code>のように。この構文は、C/C++ のようにポインタまたはアドレスへの参照のための単なる糖衣構文ではありません。配列構築の構文については、Julia のドキュメントを参照してください (バージョン間で構文が変更されています)。</li><li>Julia では、配列、文字列などのインデックスは 0 からではなく 1 から始まります。</li><li>Julia 配列は、別の変数に割り当てられた場合はコピーされません。<code>A = B</code> の後、<code>B</code> の要素を変更すると <code>A</code> も変更されます。<code>+=</code> のような更新演算子は、インプレースでの動作はしませんが、左辺を右辺の式の結果に最バインドする、 <code>A = A + B</code> に相当します。</li><li>Julia 配列は列メジャー (Fortran オーダー) ですが、C/C++ 配列はデフォルトで行メジャーです。配列をループする際に最適なパフォーマンスを得るには、C/C++ に対して Julia でループの順序を逆にする必要があります (<a href="performance-tips.html#man-performance-tips-1">パフォーマンス・ティップス</a>の関連セクションを参照)。</li><li>Julia では、値は、関数に割り当てられたり渡されたりしてもコピーされません。関数が配列を変更すると、その変更は呼び出し元にも影響を及ぼします。</li><li>Julia では、空白は C/C++ とは異なり重要です。Julia プログラムから空白を追加/削除する場合は注意が必要です。</li><li>Juliaでは、小数点のないリテラル数( <code>42</code>など)は、<code>Int</code>型の符号付き整数を作成します。しかし機械語のサイズに収まらないほど大きいリテラルは自動的に<code>Int64</code>(<code>Int</code>が <code>Int32</code>の場合)や<code>Int128</code>、または任意の大きさのより大きなサイズの型のBigInt型に昇格されます。<code>L</code>、<code>LL</code>、<code>U</code>、<code>UL</code>、<code>ULL</code> などの、符号なしおよび/または　符号付き と 符号なしの積などを示す、数値リテラルの接尾辞はありません。10進数リテラルは常に符号付き、16進数リテラル(C / C ++のように <code>0x</code>で始まる)は符号なしです。また、16進リテラルは、 C / C ++ / Javaの16進数リテラルや、Juliaの10進数リテラルとは違い、<em>リテラルの長さ</em>に基づいた型があります。先頭に0が複数が付くものも含みます。例えば、 <code>0x0</code>と<code>0x00</code>は型 <a href="../base/numbers.html#Core.UInt8"><code>UInt8</code></a>を持ち、<code>0x000</code>と <code>0x0000</code>は型 <a href="../base/numbers.html#Core.UInt16"><code>UInt16</code></a>になります。5から8桁の16進数のリテラルは型<code>UInt32</code>に、9から16桁の16進数リテラルは型<code>UInt64</code>に、そして17から32桁の16進数リテラルは型<code>UInt128</code>です。16進数マスクを定義するときには、このことを考慮する必要があります。例えば<code>~0xf == 0xf0</code> は <code>~0x000f == 0xfff0</code>と全く異なります。 64ビットの <code>Float64</code>や、32ビットの <a href="../base/numbers.html#Core.Float32"><code>Float32</code></a>のビットリテラルはそれぞれ<code>1.0</code>と <code>1.0f0</code>とひょうきします。浮動小数点リテラルが正確に表現できない場合は、丸められます(<code>BigFloat</code>型には昇格されません)。浮動小数点リテラルの動作はC / C ++に近いです。 8進数(接頭辞 <code>0o</code>)とバイナリ(接頭辞 <code>0b</code>)リテラルも符号なしとして扱われます。</li></ul><p>*文字列リテラルは <code>&quot;</code>または<code>&quot;&quot;&quot;</code> で囲って表記することができます。 <code>&quot;&quot;&quot;</code> を使った文字列リテラルは、<code>&quot;\&quot;&quot;</code> のようにクオートすることなく、文字 <code>&quot;</code> を内に含むことができます。文字列リテラルは他の変数や式の値を 展開して用いることができます。そこでは、<code>$variablename</code> や <code>$(expression)</code> と言った具合に書かれ、変数名や式をその文字列を用いたコンテキストの中で評価されます。</p><ul><li><code>//</code>は<a href="../base/numbers.html#Base.Rational"><code>有理数</code></a>を表し、単一行のコメントではありません (Juliaのコメントは<code>#</code>です)</li><li><code>#=</code>は複数行コメントの始まりを示し、 <code>=#</code>は終了を示します。</li><li>Juliaの関数は最後の式または <code>return</code>キーワードから値を返します。複数の値を関数から返すことができ、タプルとして割り当てられます。例えば、 <code>(a, b)= myfunction()</code>や、<code>a, b = myfunction()</code>といった具合です。C / C ++のように(すなわち <code>a=myfunction(&amp;b)</code>というふうに)値へのポインタを渡す必要はありません。</li><li>Juliaでは、文を終了するためにセミコロンを使用する必要はありません。(対話型プロンプト、すなわちREPLを除き)、式の結果は自動的に出力されませんので、コードの行末にセミコロンをつける必要はありません。特段プリント出力が必要なときには、<a href="../base/io-network.html#Base.println"><code>println</code></a>や<a href="../stdlib/Printf.html#Printf.@printf"><code>@printf</code></a>を使います。REPLでは、 <code>;</code>を使って出力を抑制することができます。<code>[]</code>内では <code>;</code>は注目に値する、別の意味を持ちます。同じ行の中で、複数の式を区切るのに使うことができるのです。しかし、この機能は、多くの場合で必ず必要ということではなく、可読性向上のために役立つという意味合いが強いです。</li><li>Juliaでは、演算子<a href="../base/math.html#Base.xor"><code>⊻</code></a>(<a href="../base/math.html#Base.xor"><code>xor</code></a>)はXORビット演算を実行します。C / C ++でいうところの<a href="../base/strings.html#Base.:^-Tuple{AbstractString,Integer}"><code>^</code></a>にあたります。また、ビット演算子はC / ++とは優先順位が異なるので、括弧が必要な場合があります。</li><li>Juliaの<a href="../base/strings.html#Base.:^-Tuple{AbstractString,Integer}"><code>^</code></a>はべき乗(pow)であり、C / C ++の場合のようなビット演算のXORではありません(Julia では<a href="../base/math.html#Base.xor"><code>⊻</code></a>または<a href="../base/math.html#Base.xor"><code>xor</code></a>を使ってください)</li><li>Juliaには2つの右シフト演算子、 <code>&gt;&gt;</code>と <code>&gt;&gt;&gt;</code>があります。 <code>&gt;&gt;&gt;</code>は算術シフトを実行します、 <code>&gt;&gt;</code> は C / C ++とは異なり、常に論理シフトを実行します。ここで、 <code>&gt;&gt;</code>の意味は、シフトされる値の型によって異なります。</li><li>Juliaの <code>-&gt;</code>は無名関数を作成し、ポインタ経由のメンバへのアクセスではありません。</li><li>Juliaは <code>if</code>ステートメントや<code>for</code> / <code>while</code>ループを書くときに括弧を必要としません: <code>for(int i = 1; i &lt;= 3; i ++)</code>ではなく<code>for i in [1, 2, 3]</code>です。<code>if(i == 1)</code>ではなく <code>if i == 1</code>です。</li><li>Juliaは数字の0と1をブール値として扱いません。 Juliaでは <code>if(1)</code>と書くことはできません。なぜなら、if文はブール値だけを受け入れるからです。代わりに、 <code>if true</code>、<code>if Bool(1) 、</code>if 1 == 1`と書くことはできます。</li><li>Juliaは、<code>if</code>などの条件付きブロックの終わりを示すのに <code>end</code>を使います。同様に、<code>while</code>や<code>for</code>などのループブロックのの終わりにも<code>end</code>を使います。ワンラインで書く<code>if ( cond ) statement</code>の代わりに、Juliaでは、<code>if cond; statement; end</code>　や、 <code>cond &amp;&amp; statement</code> や、 <code>!cond || statement</code> のように書くことができます。終わり2つの構文で、代入式を書く場合には、括弧で明示的に囲う必要があります。例えば、<code>cond &amp;&amp;(x = value)</code>といった具合で、これは演算子の優先順位のためです。</li><li>Juliaには行継続構文はありません。行末で、これまでの入力が完全な式である場合、完了したとみなされますが、そうでなければ、入力が続行されます。式を括弧でくくることで、強制的に次の行に続行することができます。</li><li>Juliaのマクロは、プログラムのテキストではなく、解析された式を操作します。これにより、Juliaコードの洗練された変換を実行することができます。マクロ名は <code>@</code>文字で始まり、<code>mymacro(arg1, arg2,arg3)</code> という形の関数のような構文であったり、<code>@mymacro arg1 arg2 arg3</code>という形の文のような構文を持ちます。書式は書き換え可能です。関数のような形式は特にマクロが別の式の中にある場合に便利で、多くの場合明確です。文のような形式は、ブロックに注釈を付けるためによく使われます。例えば、分散実行型の <code>for</code>構文のようでは、<code>@distributed for i in 1:n; #= body =#;end</code>のように書きます。マクロの終わりがはっきりしないコードでは、関数のような形式を使用してください。</li><li>Juliaは列挙型を持ち、 <code>@enum(name, value1, value2, ...)</code>マクロを使って表現されます。例えば、@enum(Fruit, banana = 1, apple, pear)のように書きます。</li></ul><p>*慣例により、引数を変更する関数は名前の最後に <code>!</code>を持ちます。例えば、<code>push!</code> などです。</p><ul><li>C ++では、デフォルトでは静的ディスパッチを利用可能です。つまり、動的なディスパッチを行うには、関数を仮想関数であるようにアノテーションする必要があります。一方、Juliaでは、すべてのメソッドは「仮想」です(ただし、より一般的です。メソッドは、最も具体的な宣言規則を使用するような、ディスパッチを、thisだけではなくすべての引数の型に対して行います)。</li></ul><footer><hr/><a class="previous" href="faq.html"><span class="direction">Previous</span><span class="title">Frequently Asked Questions</span></a><a class="next" href="unicode-input.html"><span class="direction">Next</span><span class="title">Unicode Input</span></a></footer></article></body></html>
