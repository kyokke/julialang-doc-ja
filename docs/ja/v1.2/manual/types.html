<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>型 · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">はじめよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li class="current"><a class="toctext" href="types.html">型</a><ul class="internal"><li><a class="toctext" href="#type-declarations-1">型宣言</a></li><li><a class="toctext" href="#抽象型-1">抽象型</a></li><li><a class="toctext" href="#プリミティブ型-1">プリミティブ型</a></li><li><a class="toctext" href="#Composite-Types-1">複合型</a></li><li><a class="toctext" href="#Mutable-Composite-Types-1">可変複合型</a></li><li><a class="toctext" href="#宣言型-1">宣言型</a></li><li><a class="toctext" href="#合併型-1">合併型</a></li><li><a class="toctext" href="#Parametric-Types-1">パラメトリック型</a></li><li><a class="toctext" href="#UnionAll-Types-1">UnionAll Types</a></li><li><a class="toctext" href="#Type-Aliases-1">Type Aliases</a></li><li><a class="toctext" href="#Operations-on-Types-1">Operations on Types</a></li><li><a class="toctext" href="#man-custom-pretty-printing-1">Custom pretty-printing</a></li><li><a class="toctext" href="#&quot;Value-types&quot;-1">&quot;値型&quot;</a></li></ul></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">モジュール</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">メタプログラミング</a></li><li><a class="toctext" href="arrays.html">多次元配列</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">ネットワークとストリーム</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">C, Fortran コードの呼び出し</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Julia の埋め込み</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">パフォーマンス・ティップス</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">スタイルガイド</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">他の言語との注目すべき違い</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">プロファイリング</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">リフレクションとインストロスペクション</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Julia ランタイムの初期化</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li><li><a class="toctext" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="toctext" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">クラッシュ(セグメンテーションフォルト)の報告と分析</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="types.html">型</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>型</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="man-types-1" href="#man-types-1">型</a></h1><p>型システムは、従来、2 つの全く異なる陣営に分類されてきました。: 静的型システムと動的型システムです。静的型システムでは、 すべてのプログラムの式は、プログラムの実行前に算出可能な型を持つ必要があります。一方動的型システムでは、プログラムによって処理されるされる実際の値が使用可能になる実行時まで、型については何もわかりません。オブジェクト志向プログラミングをすれば、静的型付け言語でも、コンパイル時に正確な値の型が分からなくてもコードを記述でき、あるていど柔軟性は高くなります。複数の異なる型を操作できるコードを記述する機能は、ポリモーフィズムと呼ばれます。 従来の動的型付け言語のすべてのコードはポリモーフィックです: 型に制約が生じるのは、明示的な型検査を行う場合もしくは、オブジェクトが実行時に操作に対応できなくなった場合です。</p><p>Julia の型システムは動的ですが、特定の値が特定の型であることを明示することで、静的型システムの利点の一部を得ることができます。これは効率的なコードを生成する上で大いに助けになるのですが、さらに重要なことに、関数引数の型に対するメソッドディスパッチを言語と深く統合できるのです。メソッドディスパッチは<a href="methods.html#Methods-1">メソッド</a>で詳しく説明しますが、ここで説明する型システムに根ざしています。</p><p>型を省略した場合の Julia の既定の挙動では、値に対して任意の型が許容されます。したがって、型を明示的に使用しなくても、多くの便利な Julia 関数を記述できます。ただし、追加の表現力が必要な場合は、元の &quot;型指定されていない&quot; コードに対して明示的な型注釈を徐々に導入することは簡単です。型注釈の目的は主に3つあります。Julia の強力な多重ディスパッチ メカニズムを利用すること、人間にとって読みやすくすること、プログラマのエラーを補足できるようにすることです。</p><p>Julia を、<a href="https://en.wikipedia.org/wiki/Type_system">型システム</a>の言葉で説明するならば、動的で、公称的で、パラメトリック、といういことになります。ジェネリック型はパラメータ化でき、型同士が持つ階層的な関係は<a href="https://en.wikipedia.org/wiki/Structural_type_system">互換性のある構造によって暗示される</a>のではなく、<a href="https://en.wikipedia.org/wiki/Nominal_type_system">明示的に宣言</a>されます。Julia の型システムの特に特徴的な特徴の 1 つは、具象型が互いに互いのサブタイプにはできないということです。全ての具体型は全てファイナル(下の階層を持たない)で、具象型のサブタイプ(上の階層)は抽象型のみです。最初は過度な制限に見えるかもしれませんが、この制約は驚くほど欠点が少なく、多くの有益な結果を導きます。動作を継承できることは、構造を継承するよりもはるかに重要であり、その両方を継承すると、従来のオブジェクト指向言語のように大きな困難が生じます。前もって言及すべきJuliaの型システムの他の高レベルの側面は次のとおりです:</p><ul><li>オブジェクトか非オブジェクトかという区分はありません: Julia のすべての値は、単一の完全に接続された型グラフに属する型を持つ真のオブジェクトであり、すべてのノードは型として等しくファーストクラスです。</li><li>「コンパイル時の型」という考え方は意味がありません: 値が持つ型は、プログラムの実行中の実際の型だけです。静的コンパイルとポリモーフィズムの組み合わせで成り立つオブジェクト指向の言語においては、コンパイル時/実行中の型の区別が重要になり、実行中の型のことは「ランタイム型」と呼びます。</li><li>変数ではなく値だけが型を持ちます。変数は単に値にバインドされた名前です。</li><li>抽象型と具象型の両方を他の型でパラメータ化できます。また、シンボル、値でその型が <a href="../base/base.html#Base.isbits"><code>isbits</code></a>で true が返されるもの(本質的には、数値や真偽値などで、他のオブジェクトへのポインタを持たないC型や<code>struct</code>などに格納されているもの)、およびそれらのタプルなどによってパラメータ化することもできます。型パラメーターは、参照や制限をする必要がない場合には省略できます。</li></ul><p>Julia の型システムは、強力で表現力豊かでありながら、明確で直感的で控えめであるように設計されています。 Julia プログラマの多くは、型を明示的に使用するコードを記述する必要性を感じないかもしれません。ただし、ある種のプログラミングでは、宣言された型を使用すると、より明確で、よりシンプルで、より速く、より堅牢になります。</p><h2><a class="nav-anchor" id="type-declarations-1" href="#type-declarations-1">型宣言</a></h2><p>演算子 <code>::</code> を使用すると、プログラム内の式や変数に型注釈をつけることができます。これを行う理由は主に2 つです:</p><ol><li>プログラムが期待どおりに動作することを確認するためのアサーションとして、</li><li>コンパイラに追加の型情報を提供し、状況によってはパフォーマンスを向上できるようにすること</li></ol><p>計算式に追加した<code>::</code>演算子は &quot;is an instance of&quot; と読み下すことができます。この演算子はどこでも使用することができ、演算子の左側の式の値が右側の型のインスタンスであることを表明します。演算子の右側の型が具象型の場合、左側の値はその型の実装でなければなりません。全ての具象型は、ファイナルで、その実装は他のどの具象型のサブタイプにもならないことを思い出してください。一方、演算子の右側の型が抽象型の場合、演算子の左側の値は、抽象型のサブタイプである具体的な型によって実装されれていれば十分です。型アサーションが 真でない場合は、例外が投げられますが、それ以外の場合は演算子の左側の値が返されます:</p><pre><code class="language-julia-repl">julia&gt; (1+2)::AbstractFloat
ERROR: TypeError: in typeassert, expected AbstractFloat, got Int64

julia&gt; (1+2)::Int
3</code></pre><p>これにより、型アサーションを任意の式に差し込むことができます。</p><p>代入文の左辺や、<code>local</code> 宣言の一部に追加すると、<code>::</code> 演算子の持つ意味が少し変わります。C言語のような、静的型付き言語の型宣言のように、常に指定された型を持つ変数を宣言になります。変数に割り当てられた値はすべて、<a href="../base/base.html#Base.convert"><code>convert()</code></a> を使用して宣言された型に変換されます:</p><pre><code class="language-julia-repl">julia&gt; function foo()
           x::Int8 = 100
           x
       end
foo (generic function with 1 method)

julia&gt; foo()
100

julia&gt; typeof(ans)
Int8</code></pre><p>この機能は、変数への代入を行って、 値が想定しない型に変更されてしまった時に起こることのある、パフォーマンス上の 「落とし穴」 を回避するのに役立ちます。</p><p>この 「宣言」の動作は、特定のコンテキストでのみ発生します:</p><pre><code class="language-julia">local x::Int8  # in a local declaration
x::Int8 = 10   # as the left-hand side of an assignment</code></pre><p>そして、宣言の前であっても、現在のスコープ全体に適用されます。現在、Julia には定数型グローバルがないため、型宣言は REPL などのグローバル スコープでは使用できません。</p><p>また、宣言を、関数定義に差し込むこともできます:</p><pre><code class="language-julia">function sinc(x)::Float64
    if x == 0
        return 1
    end
    return sin(pi*x)/(pi*x)
end</code></pre><p>この関数の戻り値は、宣言された型の変数への代入と同じ様に処理されます。値は常に<code>Float64</code> に変換されます。</p><h2><a class="nav-anchor" id="抽象型-1" href="#抽象型-1">抽象型</a></h2><p>抽象型はインスタンス化できず、型グラフ内のノードとしてのみ機能するだけですが、だからこそ関連する具象型の集合(抽象型の子孫である具象型)を説明できます。型の説明は抽象型から始めます。インスタンス化はできないですが、抽象型は型システムのバックボーンだからです。抽象型は概念的な(型の)階層を形成します。この階層が、Julia No型システムを単なるオブジェクト実装の寄せ集め以上のものにしているのです。</p><p><a href="integers-and-floating-point-numbers.html#integers-and-floating-point-numbers-1">整数と浮動小数点数</a>では、さまざまな具体的な数値を導入しました: <a href="../base/numbers.html#Core.Int8"><code>Int8</code></a>、<a href="../base/numbers.html#Core.UInt8"><code>UInt8</code></a>、<a href="../base/numbers.html#Core.Int16"><code>Int16</code></a>、<a href="../base/numbers.html#Core.UInt16"><code>UInt16</code></a>、<a href="../base/numbers.html#Core.Int32"><code>Int32</code></a>、<a href="../base/numbers.html#Core.UInt32"><code>UInt32</code></a>、<a href="../base/numbers.html#Core.Int64"><code>Int64</code></a>、[<code>UInt64]</code>(@ref)、<a href="../base/numbers.html#Core.Int128"><code>Int128</code></a>、<a href="../base/numbers.html#Core.UInt128"><code>UInt128</code></a>、<a href="../base/numbers.html#Core.Float16"><code>Float16</code></a>、<a href="../base/numbers.html#Core.Float32"><code>Float32</code></a>、および<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>です。表現のサイズは異なりますが、<code>Int8</code>、<code>Int16</code>、<code>Int32</code>、<code>Int64</code>、<code>Int128</code> には、すべて整数型が符号付き型であるという共通点があります。同様に、<code>UInt8</code>、<code>UInt16</code>、<code>UInt32</code>、<code>UInt64</code>および<code>UInt128</code>は符号なし整数型であり、<code>Float16</code>、<code>Float32</code>、<code>Float64</code>は整数ではなく浮動小数点型とは異なります。たとえば、引数が何らかの整数である場合にのみ、コードの一部が意味をなすのが一般的ですが、実際には整数の特定の <em>種類</em> に依存しません。たとえば、最大公約数を求めるアルゴリズムは、あらゆる種類の整数に対して機能しますが、浮動小数点数では機能しません。抽象型を使用すると、型の階層を構築でき、具体的な型が適合するコンテキストを提供できます。これにより、たとえば、アルゴリズムを特定の整数に制限することなく、整数である任意の型に対してプログラミングすることが簡単にできます。</p><p>抽象型は<a href="../base/base.html#abstract type"><code>abstract type</code></a>キーワードを使用して宣言されます。抽象型を宣言するための一般的な構文は次のとおりです:</p><pre><code class="language-none">abstract type «name» end
abstract type «name» &lt;: «supertype» end</code></pre><p><code>abstract type</code> キーワードは、名前が <code>«name»</code> で指定される新しい抽象型を導入します。この型名の後には、<a href="../base/base.html#Core.:&lt;:"><code>&lt;:</code></a> と 既存の型が続くことがあり、これは新しく宣言された抽象型が、&quot;親&quot;とするサブタイプであることを示します。</p><p>スーパータイプが指定されていない場合、デフォルトのスーパータイプは <code>Any</code> です。これは、定義済みの抽象型で、全てのオブジェクトは<code>Any</code>のインスタンスであり、すべての型が<code>Any</code>のサブタイプになります。型理論で<code>Any</code>は、型グラフの頂点にあるため、一般的に 「トップ」 と呼ばれます。Julia には定義済の抽象型の 「ボトム」もあります。これは、型のグラフの最下層にあって、<code>Union{}</code> と書きます。これは <code>Any</code> の正反対です: 全てのオブジェクトは <code>Union{}</code> のインスタンスではなく、、すべての型は <code>Union{}</code> のスーパータイプです。</p><p>Julia の数値型の階層を構成する抽象型のいくつかを考えてみましょう:</p><pre><code class="language-julia">abstract type Number end
abstract type Real     &lt;: Number end
abstract type AbstractFloat &lt;: Real end
abstract type Integer  &lt;: Real end
abstract type Signed   &lt;: Integer end
abstract type Unsigned &lt;: Integer end</code></pre><p><a href="../base/numbers.html#Core.Number"><code>Number</code></a>は「Any」の直接の子です。<a href="../base/numbers.html#Core.Real"><code>Real</code></a>はそのさらに子に当たります。そして、<code>Real</code> には2人の子供がいます(本当はもっとありますが、ここでは2つだけ示します。他のものは後述します): 一つは <a href="../base/numbers.html#Core.Integer"><code>Integer</code></a>、もう一つは<a href="../base/numbers.html#Core.AbstractFloat"><code>AbstractFloat</code></a> です。数の世界を整数と実数の表現に分けます。実数の表現には、もちろん浮動小数点型が含まれるのですが、有理数など他の型もあります。したがって、<code>AbstractFloat</code>は <code>Real</code> の真のサブタイプで、実数の浮動小数点表現のみを含みます。整数はさらに<a href="../base/numbers.html#Base.signed"><code>signed</code></a>と<a href="../base/numbers.html#Base.unsigned"><code>unsigned</code></a> に細分されます。</p><p><code>&lt;:</code> 演算子は一般に&quot;is a subtype of&quot; を意味しており、次のように宣言で使用します。演算子の右側の型が、新しく宣言した型のスーパータイプである、という宣言をします。また、式の中では　サブタイプ演算子として利用することもでき、左のオペランドが、右のオペランドのサブタイプである場合に <code>true</code>を返します:</p><pre><code class="language-julia-repl">julia&gt; Integer &lt;: Number
true

julia&gt; Integer &lt;: AbstractFloat
false</code></pre><p>抽象型の重要な使用方法に、具象型の既定の実装の提供があります。簡単な例として、以下を考えてみましょう:</p><pre><code class="language-julia">function myplus(x,y)
    x+y
end</code></pre><p>最初に注意すべき点は、上記の引数宣言は、 <code>x::Any</code> および <code>y::Any</code> としたのに相当する、ということです。この関数が<code>myplus(2,5)</code>のように呼び出されると、ディスパッチャーは指定された引数に一致する <code>myplus</code>という名前の最も具体的なメソッドを選択します。(多重ディスパッチの詳細については、<a href="methods.html#Methods-1">メソッド</a>を参照してください。）</p><p>上記のメソッドより具体的なメソッドが見つからない場合、Julia は次に内部で <code>myplus</code>という名前のメソッドを定義しコンパイルします。この例では、定義・コンパイルされるメソッドは、上記のジェネリック関数から、引数2個を<code>Int</code>型に特化させたものです。つまり、定義とコンパイルは暗黙裡に行われます:</p><pre><code class="language-julia">function myplus(x::Int,y::Int)
    x+y
end</code></pre><p>最後に、この特化したメソッドを呼び出します。</p><p>このように、抽象型を使用することでプログラマはジェネリック関数を書くことができます。これは後に、具象型を組み合わせて使う時の、既定のメソッドとして使うことができるのです。多重ディスパッチのおかげで、プログラマはデフォルトの関数を使うか、より特化したメソッドを使うかを完全に制御できます。</p><p>注意すべき重要な点は、プログラマが　引数が抽象型の引数を持つ関数使っても、パフォーマンスが低下しない、ということです。このメソッドが呼び出される毎に、具象型の引数のタプルそれぞれに対してメソッドが再コンパイルするからです。(ただし、関数の引数が抽象型のコンテナーであるは、パフォーマンス上の問題が発生するかもしれません <a href="performance-tips.html#man-performance-tips-1">パフォーマンス・ティップス</a>を参照のこと。)</p><h2><a class="nav-anchor" id="プリミティブ型-1" href="#プリミティブ型-1">プリミティブ型</a></h2><p>プリミティブ型は、データが普通ビットで構成される具象型です。プリミティブ型の典型的な例は、整数と浮動小数点の値です。ほとんどの言語とは異なり、Julia では、組み込みの決められたセットのみを提供するのではなく、独自のプリミティブ型を宣言できます。実際、標準のプリミティブ型はすべて(C言語ではなく)Julia 言語自体で定義されています:</p><pre><code class="language-julia">primitive type Float16 &lt;: AbstractFloat 16 end
primitive type Float32 &lt;: AbstractFloat 32 end
primitive type Float64 &lt;: AbstractFloat 64 end

primitive type Bool &lt;: Integer 8 end
primitive type Char &lt;: AbstractChar 32 end

primitive type Int8    &lt;: Signed   8 end
primitive type UInt8   &lt;: Unsigned 8 end
primitive type Int16   &lt;: Signed   16 end
primitive type UInt16  &lt;: Unsigned 16 end
primitive type Int32   &lt;: Signed   32 end
primitive type UInt32  &lt;: Unsigned 32 end
primitive type Int64   &lt;: Signed   64 end
primitive type UInt64  &lt;: Unsigned 64 end
primitive type Int128  &lt;: Signed   128 end
primitive type UInt128 &lt;: Unsigned 128 end</code></pre><p>プリミティブ型を宣言するための一般的な構文は次のとおりです:</p><pre><code class="language-none">primitive type «name» «bits» end
primitive type «name» &lt;: «supertype» «bits» end</code></pre><p>ビット数 «bits»は、その型に必要なストレージの量です。名前 «name» は新しい型につける名前です。プリミティブ型は、必要に応じて、いくつかのスーパータイプのサブタイプとして宣言できます。スーパータイプを省略した場合、その型はデフォルトで <code>Any</code> を直接のスーパータイプとして設定します。したがって、上記の <a href="../base/numbers.html#Core.Bool"><code>Bool</code></a> の宣言は、ブール値を格納するのに 8 ビットかかり、<a href="../base/numbers.html#Core.Integer"><code>Integer</code></a> を直接のスーパータイプとして持っていることを意味します。現在、8 ビットの倍数のサイズのみがサポートされています。したがって、ブール値は実際には 1 ビットしか必要としませんが、8 ビットより小さい値を宣言することはできません。</p><p><a href="../base/numbers.html#Core.Bool"><code>Bool</code></a>、<a href="../base/numbers.html#Core.Int8"><code>Int8</code></a>および<a href="../base/numbers.html#Core.UInt8"><code>UInt8</code></a>の型はすべて同じ表現を持っています: どれも8ビットのメモリチャンクです。しかし、Juliaの型システムは公称的であるため、同一の構造であっても互換性はありません。これらの基本的な違いは、異なるスーパータイプを持っているということです:<a href="../base/numbers.html#Core.Bool"><code>Bool</code></a><code>の直接スーパータイプは[</code>Integer<code>](@ref)、[</code>Int8<code>](@ref)は[</code>Signed<code>](@ref)、</code>UInt8<code>(@ref)は[</code>Unsigned<code>](@ref)です。[</code>Bool<code>](@ref)、[</code>Int8<code>](@ref)、および[</code>UInt8<code>](@ref)のその他違いはすべて挙動に関するものです。これらの型のオブジェクトを引数として指定した場合に関数の挙動がどう定義されているかの違いです。もし、型の構造によって挙動が決まってしまうのであれば、[</code>Int8<code>](@ref)または[</code>UInt8<code>](@ref)とは異なる動作をする[</code>Bool`](@ref)を作ることは不可能なるでしょう。</p><h2><a class="nav-anchor" id="Composite-Types-1" href="#Composite-Types-1">複合型</a></h2><p><a href="https://en.wikipedia.org/wiki/Composite_data_type">複合型</a> は様々な言語で、レコード、構造体、またはオブジェクトと呼ばれます。複合型は名前付きフィールドのコレクションで、そのインスタンスは単一の値として扱うことができます。多くの言語では、複合型はユーザー定義可能な型の唯一の種類であり、Julia でも最も一般的に使用されるユーザー定義型です。</p><p>C++、Java、Python、Rubyなどの主流のオブジェクト指向言語では、複合型は、名前付けされた関数が関連付けられており、その組み合わせは &quot;オブジェクト&quot; と呼ばれます。Ruby や Smalltalk などの純粋なオブジェクト指向言語では、それが複合型であろうとなかろうと、すべての値がオブジェクトです。C++ や Java を含む純粋でないオブジェクト指向言語では、整数や浮動小数点値などの一部の値はオブジェクトではなく、ユーザー定義の複合型のインスタンスは真のオブジェクトで、関連付けられたメソッドを持ちます。Julia では、すべての値はオブジェクトですが、関数は操作対象のオブジェクトにバンドルされていません。これは、Juliaが多重ディスパッチで使用する関数のメソッドを選択するためです。これは、関数の最初の引数だけでなく、<em>全ての</em>引数がメソッド選択の際に考慮されるということを意味しています(メソッドとディスパッチについての詳細は <a href="methods.html#Methods-1">メソッド</a> 参照)。したがって、関数がその最初の引数だけに 「属している」という考え方は不適切です。各オブジェクトの「内部に」名前付きのメソッドのバッグ(メソッドの集合）を持つのではなく、メソッドを関数オブジェクトに編成する、ということをします。これは、Julia の言語設計の非常に有益な側面です。</p><p>複合型は <a href="../base/base.html#struct"><code>struct</code></a> キーワードの後にフィールド名のブロックが付加され、必要に応じて <code>::</code> 演算子を使用して型にアノテーションがされます:</p><pre><code class="language-julia-repl">julia&gt; struct Foo
           bar
           baz::Int
           qux::Float64
       end</code></pre><p>型アノテーションのないフィールドはデフォルトで <code>Any</code>になります。それに応じて任意の型の値を保持できます。</p><p>型<code>Foo</code>の新しいオブジェクトは、関数のような <code>Foo</code> 型のオブジェクトを関数のようにしてフィールドの値に適用することで作成できます:</p><pre><code class="language-julia-repl">julia&gt; foo = Foo(&quot;Hello, world.&quot;, 23, 1.5)
Foo(&quot;Hello, world.&quot;, 23, 1.5)

julia&gt; typeof(foo)
Foo</code></pre><p>型が関数のように適用される時、これは <em>コンストラクター</em>と呼ばれています。2 つのコンストラクターが自動的に生成されます (これらは <em>デフォルト コンストラクター</em>と呼ばれています)。1 つは引数を受け入れ、フィールドの型に変換するために <a href="../base/base.html#Base.convert"><code>convert</code></a> を呼び出し、もう 1 つはフィールドの型と完全に一致する引数だけを受け入れます。これらの両方が生成される理由は、誤って既定のコンストラクタを置き換えることなく、新しい定義を簡単に追加できるからです。</p><p><code>bar</code>フィールドには型の制約はないので、値は何でも構いません。ただし、<code>baz</code>の値は<code>Int</code>に変換できる必要があります:</p><pre><code class="language-julia-repl">julia&gt; Foo((), 23.5, 1)
ERROR: InexactError: Int64(23.5)
Stacktrace:
[...]</code></pre><p><a href="../base/base.html#Base.fieldnames"><code>fieldnames</code></a>関数をつかって、フィールド名の一覧を取得できます。</p><pre><code class="language-julia-repl">julia&gt; fieldnames(Foo)
(:bar, :baz, :qux)</code></pre><p>従来の表記法 <code>foo.bar</code>を使用して、複合オブジェクトのフィールド値にアクセスできます:</p><pre><code class="language-julia-repl">julia&gt; foo.bar
&quot;Hello, world.&quot;

julia&gt; foo.baz
23

julia&gt; foo.qux
1.5</code></pre><p><code>struct</code> で宣言された複合型オブジェクトは <em>不変</em>です。作成後に変更できません。これは最初は奇妙に見えるかもしれませんが、いくつかの利点があります:</p><ul><li>より効率的になることがあります。一部の構造体は配列に効率的にパックでき、場合によってはコンパイラは不変オブジェクト全体を別のメモリに割り当てることを回避できることがあります。</li><li>型コンストラクタで規定される不変性を破ることはできません。</li><li>不変オブジェクトを使用するコードは、推論しやすくなります。</li></ul><p>不変オブジェクトには、配列などの変更可能なオブジェクトがフィールドに含まれている場合があります。含まれるオブジェクトは変更可能なままです。その不変オブジェクト自体フィールドが、異なるオブジェクトを指すよう変更することができなくなるだけです。</p><p>必要に応じて、次のセクションで説明するキーワード <a href="manual/@ref "><code>mutable struct</code></a> で、変更可能な複合オブジェクトを宣言できます。</p><p>フィールドのない不変複合型はシングルトンです。このような型のインスタンスは 1 つだけです:</p><pre><code class="language-julia-repl">julia&gt; struct NoFields
       end

julia&gt; NoFields() === NoFields()
true</code></pre><p><a href="../base/base.html#Core.:==="><code>===</code></a> によって、<code>NoFields</code>の「２つの」インスタンスが、実際には一つで同じものであることを確認できます。 シングルトンタイプについては、<a href="types.html#man-singleton-types-1">以下</a> でさらに詳しく説明します。</p><p>複合型のインスタンスがどのように生成されるかについては、まだまだ説明すべきことがありますが、その議論は [パラメトリック型(@ref Parametric-types)と<a href="methods.html#Methods-1">メソッド</a>の両方にも関わりがあり、とても重要な事項なので、<a href="constructors.html#man-constructors-1">コンストラクタ</a> という独立のセクションを設けてそこで扱うことにします。</p><h2><a class="nav-anchor" id="Mutable-Composite-Types-1" href="#Mutable-Composite-Types-1">可変複合型</a></h2><p>複合型が、<code>struct</code> ではなく <code>mutable struct</code> キーワードで宣言されていれば、その型のインスタンスは変更可能です:</p><pre><code class="language-julia-repl">julia&gt; mutable struct Bar
           baz
           qux::Float64
       end

julia&gt; bar = Bar(&quot;Hello&quot;, 1.5);

julia&gt; bar.qux = 2.0
2.0

julia&gt; bar.baz = 1//2
1//2</code></pre><p>変更に対応できるように、このようなオブジェクトは、一般にヒープ上に割り当てられ、メモリアドレスが一定になっています。可変オブジェクトは、時間によって値の変わりうる小さなコンテナのようなもので、アドレスだけで確実に識別できます。対称的に、変更不可能な型のインスタンスは、特定のフィールド値に関連付けられています。フィールド値だけで、オブジェクトに関する全てがわかります。型を可変にするかどうかを決めるには、同じフィールド値を持つ2つのインスタンスは同一だとみなせるか、あるいは時間とともに別々に変更する必要があるかを考えます。同一であるとみなせるならば、おそらくその型は不変にすべきでしょう。</p><p>まとめると、Julia では2 つの重要な特性で不変性を定義できます:</p><ul><li>不変型の値を変更することはできません。<ul><li>ビット型(プリミティブ型)の場合、一度設定された値のビット パターンは決して変わらず、その値はその型で恒等的であることを意味します。</li><li>複合型の場合、フィールドの値の恒等性は決して変わらないことを意味します。フィールドがビット型の場合、そのビットは決して変わらず、フィールドが配列のような変更可能な型である場合、その変更可能な型の中身は変わっても、そのフィールドは常に同じ可変の値を参照することを意味します。</li></ul></li><li>不変型のオブジェクトは、コンパイラが自由にコピーすることができます。というのも、不変性によって、元のオブジェクトとコピーしたものを見分けることができないからです。<ul><li>特に、十分(メモリを専有する領域が)小さな 整数や浮動小数点数などの不変型は、通常はレジスタ (または割り当てられたスタック) にある関数にそのまま渡されます。</li><li>変更可能な値は、(配列など、一般にメモリの使用量が大きくなり得るので)一方でヒープに割り当てられ、その配置された値へのポインタとして関数に渡されます。ただし、このような事象が起こっているかどうかを判別することがどうやっても不可能な状況だとコンパイラが判断した場合には、その限りではありません。</li></ul></li></ul><h2><a class="nav-anchor" id="宣言型-1" href="#宣言型-1">宣言型</a></h2><p>上記セクションで説明した 3 種類の型 (抽象、プリミティブ型、複合型) は、実際には密接に関連しています。これらは、共通する重要な特徴を持ちます:</p><ul><li>明示的に宣言されます。</li><li>名前を持っています。</li><li>スーパータイプを明示的に宣言します。</li><li>パラメータを付けることができます。</li></ul><p>こうした共通の特徴を持つため、これらの型は、内部的に同じ概念の <code>DataType</code> のインスタンスとして表現されます。<code>DataType</code> これら3つの型のいずれかをさします:</p><pre><code class="language-julia-repl">julia&gt; typeof(Real)
DataType

julia&gt; typeof(Int)
DataType</code></pre><p><code>DataType</code>は抽象型、具象型どちらでもかまいません。具象型ならば、特定のサイズ、格納領域上のレイアウト、(場合によっては）フィールド名などがあります。プリミティブ型はゼロ以外のサイズの <code>DataType</code> ですが、フィールド名はありません。複合型は、フィールド名を持つか、、または空 (ゼロ サイズ)の<code>DataType</code>です。</p><p>システム内のすべての具象型の値は、なんらかの <code>DataType</code> のインスタンスです。</p><h2><a class="nav-anchor" id="合併型-1" href="#合併型-1">合併型</a></h2><p>合併型は特殊な抽象型で、引数のいずれかの型のインスタンスが全てオブジェクトとして含みます。特殊なキーワード<code>Union</code>を使って構築します:</p><pre><code class="language-julia-repl">julia&gt; IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia&gt; 1 :: IntOrString
1

julia&gt; &quot;Hello!&quot; :: IntOrString
&quot;Hello!&quot;

julia&gt; 1.0 :: IntOrString
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64</code></pre><p>多くの言語のコンパイラには、型推論のために内部で使う合併構文があります。Juliaは単にそれをプログラマにも公開しているというわけです。Julia のコンパイラは、少数の型 の <code>Union</code> 型 を使うと効率的なコードを生成することがあります<a href="#footnote-1">[1]</a>。なりうる型すべてに個別に特化したコードを生成するためです。</p><p>合併型のユースケースで特に便利なのは、<code>Uniton{T, Nothing}</code>です。ここで<code>T</code>は、任意の型を指定でき、<a href="../base/base.html#Core.Nothing"><code>Nothing</code></a>は、唯一のインスタンスが <code>nothing</code>オブジェクトである、シングルトン型です。Julia のこのパターンは、他の言語の<a href="https://en.wikipedia.org/wiki/Nullable_type"><code>Nullable</code>, <code>Option</code>, <code>Maybe</code></a> 型などと同等です。関数の引数やフィールドを<code>Uniton{T, Nothing}</code>として宣言すると型<code>T</code>の値か、値がないことを示す<code>nothing</code>のどちらかに設定することができます。詳細については、<a href="faq.html#faq-nothing-1">FATのこの項目</a>を見てください。</p><h2><a class="nav-anchor" id="Parametric-Types-1" href="#Parametric-Types-1">パラメトリック型</a></h2><p>Juliaの型システムの重要かつ強力な特徴は、型がパラメトリックであるということです: 型にパラメータをとることができます。そうすると型宣言は、実質的にとりうるそれぞれのパラメータの組み合わせに対応して、新しい型の一族を導入します。多くの言語が、何らかの形で<a href="https://en.wikipedia.org/wiki/Generic_programming">汎化プログラミング</a>をサポートしていますが、この汎化プログラミングでは、必要な型を正確にしなくても、処理すべきデータ構造とアルゴリズムを指定することができます。 たとえば、ML、Haskell、Ada、Eiffel、C++、Java、C#、F#、Scala には、何らかの形の汎化プログラミングを取り入れています。これらの言語の中には、真のパラメトリック多相性をサポートするものもあれば(ML、Haskell、Scalaなど)、アドホックなテンプレートベースの汎用プログラミングスタイルをサポートするもの(例えばC++、Java)もあります。さまざまな言語で多種多様な汎化プログラミングとパラメトリック型が使われているので、ここでは、それらと、Julia のパラメトリック型を比較するのではなく、Julia のシステムを単体について説明することに焦点を当てます。ただし、Julia は動的に型付け言語であり、コンパイル時にすべての型決定を行う必要がないため、静的パラメトリック型システムで発生する多くの従来の困難は比較的簡単に処理できることに注意してください。</p><p>すべての宣言型 (<code>DataType</code> の仲間) は、それぞれ同じ構文でパラメータ化できます。最初に、パラメトリック複合型、次にパラメトリック抽象型、最後にパラメトリック プリミティブ型の順で説明します。</p><h3><a class="nav-anchor" id="パラメトリック複合型-1" href="#パラメトリック複合型-1">パラメトリック複合型</a></h3><p>型パラメータは、型名の直後に導入され、中かっこで囲みます:</p><pre><code class="language-julia-repl">julia&gt; struct Point{T}
           x::T
           y::T
       end</code></pre><p>この宣言では、タイプ <code>T</code> の 2 つの 「座標」を保持する新しいパラメトリック型 <code>Point{T}</code> を定義しています。「T」って何だ?と思うかもしれませんが、まあ、これがまさにパラメトリック型のポイントです: どんな型(またはプリミティブ型でも構いませんが、ここでは実際には明らかな型が使われています)でも構いません。<code>Point{Float64}</code> は、<code>Point</code> の定義で <code>T</code> を <a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> に置き換えたものと同等の具象型です。したがって、この一つの宣言文が実質的には、<code>Point{Float64}</code>、<code>Point{AbstractString}</code>、<code>Point{Int64}</code>など、無数の型に対する宣言に相当します。そして、それぞれが具象型として利用することができます:</p><pre><code class="language-julia-repl">julia&gt; Point{Float64}
Point{Float64}

julia&gt; Point{AbstractString}
Point{AbstractString}</code></pre><p><code>Point{Float64}</code>という型は座標が64ビット浮動小数点の値を持つ点であり、<code>Point{AbstractString}</code>という型は「座標」が文字列オブジェクトである「ポイント」です(<a href="../devdocs/ast.html#Strings-1"><code>文字列</code></a> を参照)。</p><p><code>Point</code> (型パラメータ無しの単体) も有効な型オブジェクトで、<code>Point{Float64}</code>、<code>Point{AbstractString}</code>などすべてのインスタンスをサブタイプとして含んでいます:</p><pre><code class="language-julia-repl">julia&gt; Point{Float64} &lt;: Point
true

julia&gt; Point{AbstractString} &lt;: Point
true</code></pre><p>他の型は当然<code>Point</code>のサブタイプではありません:</p><pre><code class="language-julia-repl">julia&gt; Float64 &lt;: Point
false

julia&gt; AbstractString &lt;: Point
false</code></pre><p>異なる <code>T</code> の値がついた具象型<code>Point</code>は決して互いにサブタイプになることはありません:</p><pre><code class="language-julia-repl">julia&gt; Point{Float64} &lt;: Point{Int64}
false

julia&gt; Point{Float64} &lt;: Point{Real}
false</code></pre><p>!!! 警告     この最後のポイントは <em>非常に</em> 重要です: <code>Float64 &lt;: Real</code>は成り立ちますが、<code>Point{Float64} &lt;: Point{Real}</code> は<em>成り立ちません</em></p><p>型理論の述語で言い換えると、Julia の型パラメータは、<a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29">共変 (もしくは反変)</a> ではなく、<em>不変</em> です。これには現実的な理由があります: <code>Point{Float64}</code>のインスタンスは<code>Point{Real}</code>のインスタンスと概念的には似ていますが、2つの型のメモリ上での表現は異なります:</p><ul><li><code>Point{Float64}</code> のインスタンスは、64 ビット値の即時ペアとしてコンパクトかつ効率的に表現できます;</li><li><code>Point{Real}</code> のインスタンスは、<a href="../base/numbers.html#Core.Real"><code>Real</code></a> のインスタンスの任意のペアを保持できる必要があります。 <code>Real</code> のインスタンスであるオブジェクトは任意のサイズと構造を持つことができるため、実際には<code>Point{Real}</code> のインスタンスは、個別に割り当てられた <code>Real</code> オブジェクトへのポインタのペアとして表す必要があります。</li></ul><p><code>Point{Float64}</code> に値を直接格納できることで得られる効率は、配列の場合は非常に大きくなります: <code>Array{Float64}</code> は 64 ビット浮動小数点値の連続したメモリ ブロックとして格納されますが、<code>Array{Real}</code>は、個別に割り当てられた<a href="../base/numbers.html#Core.Real"><code>Real</code></a>オブジェクトへのポインタの配列でなければなりません。抽象型<code>Real</code>に宣言されたオブジェクトの実装は、64ビット浮動小数点数が<a href="https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing">ボックス化</a>されている場合も、任意の大きさの複雑なオブジェクトである場合も許容しなくてはいけません。</p><p><code>Point{Float64}</code> は <code>Point{Real}</code> のサブタイプではないため、次のメソッドは <code>Point{Float64}</code> 型の引数には適用できません:</p><pre><code class="language-julia">function norm(p::Point{Real})
    sqrt(p.x^2 + p.y^2)
end</code></pre><p><code>T</code> が <a href="../base/numbers.html#Core.Real"><code>Real</code></a> のサブタイプである <code>Point{T}</code>のすべての引数を許容するメソッドの正しい定義方法は下記の通りです:</p><pre><code class="language-julia">function norm(p::Point{&lt;:Real})
    sqrt(p.x^2 + p.y^2)
end</code></pre><p>(同等の定義として、<code>function norm(p::Point{T} where T&lt;:Real)</code> や、<code>function norm(p::Point{T}) where T&lt;:Real</code> も可能です; <a href="types.html#UnionAll-Types-1">全合併型</a>を参照。</p><p>後の <a href="methods.html#Methods-1">メソッド</a> で、より多くの例を説明します。</p><p><code>Point</code> オブジェクトはどのように構築されるでしょうか? <a href="constructors.html#man-constructors-1">コンストラクター</a>で詳しく説明しますが、複合型に対して独自のコンストラクタを定義することは可能ですが、特別にコンストラクタの宣言をしない場合にも、デフォルトで新しい複合型オブジェクトを作成する方法が2つあります。1つは型パラメータを明示的に与えるもの、もう1つはオブジェクトコンストラクタへの引数から暗黙裡に推定されるものです。</p><p>型 <code>Point{Float64}</code> は <code>T</code> の代わりに <a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> を使って宣言した<code>Point</code> と同等の具象型であるため、それに応じてコンストラクタとしてそのまま適用できます:</p><pre><code class="language-julia-repl">julia&gt; Point{Float64}(1.0, 2.0)
Point{Float64}(1.0, 2.0)

julia&gt; typeof(ans)
Point{Float64}</code></pre><p>デフォルトのコンストラクタでは、フィールドごとに 引数を指定する必要があります:</p><pre><code class="language-julia-repl">julia&gt; Point{Float64}(1.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64)
[...]

julia&gt; Point{Float64}(1.0,2.0,3.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)
[...]</code></pre><p>パラメトリック型では、デフォルトのコンストラクターは 1 つだけしか生成されません。オーバーライドできないため、このコンストラクターは任意の引数を受け取り、フィールドの型に変換します。</p><p>多くの場合、生成しようとする <code>Point</code> オブジェクトの型を指定することは冗長です。コンストラクター呼び出しの引数の型には既に型情報が隠れているからです。そのため、パラメーター型 <code>T</code> を推論可能で曖昧さがない場合は、<code>Point</code> 自体をコンストラクタとして適用することもできます:</p><pre><code class="language-julia-repl">julia&gt; Point(1.0,2.0)
Point{Float64}(1.0, 2.0)

julia&gt; typeof(ans)
Point{Float64}

julia&gt; Point(1,2)
Point{Int64}(1, 2)

julia&gt; typeof(ans)
Point{Int64}</code></pre><p><code>Point</code> の場合、2 つの引数が同じ型である場合にのみ、<code>T</code> の型は明確に推論されます。そうでない場合、コンストラクタは失敗して <a href="../base/base.html#Core.MethodError"><code>MethodError</code></a>が発生します:</p><pre><code class="language-julia-repl">julia&gt; Point(1,2.5)
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T, !Matched::T) where T at none:2</code></pre><p>このように型が混在するケースを適切に処理するコンストラクター メソッドは定義できますが、後で <a href="constructors.html#man-constructors-1">コンストラクタ</a>に議論は譲ります。</p><h3><a class="nav-anchor" id="パラメトリック抽象型-1" href="#パラメトリック抽象型-1">パラメトリック抽象型</a></h3><p>Parametric abstract type declarations declare a collection of abstract types, in much the same way:</p><pre><code class="language-julia-repl">julia&gt; abstract type Pointy{T} end</code></pre><p>With this declaration, <code>Pointy{T}</code> is a distinct abstract type for each type or integer value of <code>T</code>. As with parametric composite types, each such instance is a subtype of <code>Pointy</code>:</p><pre><code class="language-julia-repl">julia&gt; Pointy{Int64} &lt;: Pointy
true

julia&gt; Pointy{1} &lt;: Pointy
true</code></pre><p>Parametric abstract types are invariant, much as parametric composite types are:</p><pre><code class="language-julia-repl">julia&gt; Pointy{Float64} &lt;: Pointy{Real}
false

julia&gt; Pointy{Real} &lt;: Pointy{Float64}
false</code></pre><p>The notation <code>Pointy{&lt;:Real}</code> can be used to express the Julia analogue of a <em>covariant</em> type, while <code>Pointy{&gt;:Int}</code> the analogue of a <em>contravariant</em> type, but technically these represent <em>sets</em> of types (see <a href="types.html#UnionAll-Types-1">UnionAll Types</a>).</p><pre><code class="language-julia-repl">julia&gt; Pointy{Float64} &lt;: Pointy{&lt;:Real}
true

julia&gt; Pointy{Real} &lt;: Pointy{&gt;:Int}
true</code></pre><p>Much as plain old abstract types serve to create a useful hierarchy of types over concrete types, parametric abstract types serve the same purpose with respect to parametric composite types. We could, for example, have declared <code>Point{T}</code> to be a subtype of <code>Pointy{T}</code> as follows:</p><pre><code class="language-julia-repl">julia&gt; struct Point{T} &lt;: Pointy{T}
           x::T
           y::T
       end</code></pre><p>Given such a declaration, for each choice of <code>T</code>, we have <code>Point{T}</code> as a subtype of <code>Pointy{T}</code>:</p><pre><code class="language-julia-repl">julia&gt; Point{Float64} &lt;: Pointy{Float64}
true

julia&gt; Point{Real} &lt;: Pointy{Real}
true

julia&gt; Point{AbstractString} &lt;: Pointy{AbstractString}
true</code></pre><p>This relationship is also invariant:</p><pre><code class="language-julia-repl">julia&gt; Point{Float64} &lt;: Pointy{Real}
false

julia&gt; Point{Float64} &lt;: Pointy{&lt;:Real}
true</code></pre><p>What purpose do parametric abstract types like <code>Pointy</code> serve? Consider if we create a point-like implementation that only requires a single coordinate because the point is on the diagonal line <em>x = y</em>:</p><pre><code class="language-julia-repl">julia&gt; struct DiagPoint{T} &lt;: Pointy{T}
           x::T
       end</code></pre><p>Now both <code>Point{Float64}</code> and <code>DiagPoint{Float64}</code> are implementations of the <code>Pointy{Float64}</code> abstraction, and similarly for every other possible choice of type <code>T</code>. This allows programming to a common interface shared by all <code>Pointy</code> objects, implemented for both <code>Point</code> and <code>DiagPoint</code>.  This cannot be fully demonstrated, however, until we have introduced methods and dispatch in the next section, <a href="methods.html#Methods-1">Methods</a>.</p><p>There are situations where it may not make sense for type parameters to range freely over all possible types. In such situations, one can constrain the range of <code>T</code> like so:</p><pre><code class="language-julia-repl">julia&gt; abstract type Pointy{T&lt;:Real} end</code></pre><p>With such a declaration, it is acceptable to use any type that is a subtype of <a href="../base/numbers.html#Core.Real"><code>Real</code></a> in place of <code>T</code>, but not types that are not subtypes of <code>Real</code>:</p><pre><code class="language-julia-repl">julia&gt; Pointy{Float64}
Pointy{Float64}

julia&gt; Pointy{Real}
Pointy{Real}

julia&gt; Pointy{AbstractString}
ERROR: TypeError: in Pointy, in T, expected T&lt;:Real, got Type{AbstractString}

julia&gt; Pointy{1}
ERROR: TypeError: in Pointy, in T, expected T&lt;:Real, got Int64</code></pre><p>Type parameters for parametric composite types can be restricted in the same manner:</p><pre><code class="language-julia">struct Point{T&lt;:Real} &lt;: Pointy{T}
    x::T
    y::T
end</code></pre><p>To give a real-world example of how all this parametric type machinery can be useful, here is the actual definition of Julia&#39;s <a href="../base/numbers.html#Base.Rational"><code>Rational</code></a> immutable type (except that we omit the constructor here for simplicity), representing an exact ratio of integers:</p><pre><code class="language-julia">struct Rational{T&lt;:Integer} &lt;: Real
    num::T
    den::T
end</code></pre><p>It only makes sense to take ratios of integer values, so the parameter type <code>T</code> is restricted to being a subtype of <a href="../base/numbers.html#Core.Integer"><code>Integer</code></a>, and a ratio of integers represents a value on the real number line, so any <a href="../base/numbers.html#Base.Rational"><code>Rational</code></a> is an instance of the <a href="../base/numbers.html#Core.Real"><code>Real</code></a> abstraction.</p><h3><a class="nav-anchor" id="Tuple-Types-1" href="#Tuple-Types-1">Tuple Types</a></h3><p>Tuples are an abstraction of the arguments of a function – without the function itself. The salient aspects of a function&#39;s arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. For example, a 2-element tuple type resembles the following immutable type:</p><pre><code class="language-julia">struct Tuple2{A,B}
    a::A
    b::B
end</code></pre><p>However, there are three key differences:</p><ul><li>Tuple types may have any number of parameters.</li><li>Tuple types are <em>covariant</em> in their parameters: <code>Tuple{Int}</code> is a subtype of <code>Tuple{Any}</code>. Therefore <code>Tuple{Any}</code> is considered an abstract type, and tuple types are only concrete if their parameters are.</li><li>Tuples do not have field names; fields are only accessed by index.</li></ul><p>Tuple values are written with parentheses and commas. When a tuple is constructed, an appropriate tuple type is generated on demand:</p><pre><code class="language-julia-repl">julia&gt; typeof((1,&quot;foo&quot;,2.5))
Tuple{Int64,String,Float64}</code></pre><p>Note the implications of covariance:</p><pre><code class="language-julia-repl">julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,Any}
true

julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,Real}
false

julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,}
false</code></pre><p>Intuitively, this corresponds to the type of a function&#39;s arguments being a subtype of the function&#39;s signature (when the signature matches).</p><h3><a class="nav-anchor" id="Vararg-Tuple-Types-1" href="#Vararg-Tuple-Types-1">Vararg Tuple Types</a></h3><p>The last parameter of a tuple type can be the special type <a href="../base/base.html#Core.Vararg"><code>Vararg</code></a>, which denotes any number of trailing elements:</p><pre><code class="language-julia-repl">julia&gt; mytupletype = Tuple{AbstractString,Vararg{Int}}
Tuple{AbstractString,Vararg{Int64,N} where N}

julia&gt; isa((&quot;1&quot;,), mytupletype)
true

julia&gt; isa((&quot;1&quot;,1), mytupletype)
true

julia&gt; isa((&quot;1&quot;,1,2), mytupletype)
true

julia&gt; isa((&quot;1&quot;,1,2,3.0), mytupletype)
false</code></pre><p>Notice that <code>Vararg{T}</code> corresponds to zero or more elements of type <code>T</code>. Vararg tuple types are used to represent the arguments accepted by varargs methods (see <a href="functions.html#Varargs-Functions-1">Varargs Functions</a>).</p><p>The type <code>Vararg{T,N}</code> corresponds to exactly <code>N</code> elements of type <code>T</code>. <code>NTuple{N,T}</code> is a convenient alias for <code>Tuple{Vararg{T,N}}</code>, i.e. a tuple type containing exactly <code>N</code> elements of type <code>T</code>.</p><h3><a class="nav-anchor" id="Named-Tuple-Types-1" href="#Named-Tuple-Types-1">Named Tuple Types</a></h3><p>Named tuples are instances of the <a href="../base/base.html#Core.NamedTuple"><code>NamedTuple</code></a> type, which has two parameters: a tuple of symbols giving the field names, and a tuple type giving the field types.</p><pre><code class="language-julia-repl">julia&gt; typeof((a=1,b=&quot;hello&quot;))
NamedTuple{(:a, :b),Tuple{Int64,String}}</code></pre><p>A <code>NamedTuple</code> type can be used as a constructor, accepting a single tuple argument.  The constructed <code>NamedTuple</code> type can be either a concrete type, with both parameters specified, or a type that specifies only field names:</p><pre><code class="language-julia-repl">julia&gt; NamedTuple{(:a, :b),Tuple{Float32, String}}((1,&quot;&quot;))
(a = 1.0f0, b = &quot;&quot;)

julia&gt; NamedTuple{(:a, :b)}((1,&quot;&quot;))
(a = 1, b = &quot;&quot;)</code></pre><p>If field types are specified, the arguments are converted. Otherwise the types of the arguments are used directly.</p><h3><a class="nav-anchor" id="man-singleton-types-1" href="#man-singleton-types-1">Singleton Types</a></h3><p>There is a special kind of abstract parametric type that must be mentioned here: singleton types.  For each type, <code>T</code>, the &quot;singleton type&quot; <code>Type{T}</code> is an abstract type whose only instance is the object <code>T</code>. Since the definition is a little difficult to parse, let&#39;s look at some examples:</p><pre><code class="language-julia-repl">julia&gt; isa(Float64, Type{Float64})
true

julia&gt; isa(Real, Type{Float64})
false

julia&gt; isa(Real, Type{Real})
true

julia&gt; isa(Float64, Type{Real})
false</code></pre><p>In other words, <a href="../base/base.html#Core.isa"><code>isa(A,Type{B})</code></a> is true if and only if <code>A</code> and <code>B</code> are the same object and that object is a type. Without the parameter, <code>Type</code> is simply an abstract type which has all type objects as its instances, including, of course, singleton types:</p><pre><code class="language-julia-repl">julia&gt; isa(Type{Float64}, Type)
true

julia&gt; isa(Float64, Type)
true

julia&gt; isa(Real, Type)
true</code></pre><p>Any object that is not a type is not an instance of <code>Type</code>:</p><pre><code class="language-julia-repl">julia&gt; isa(1, Type)
false

julia&gt; isa(&quot;foo&quot;, Type)
false</code></pre><p>Until we discuss <a href="methods.html#Parametric-Methods-1">Parametric Methods</a> and <a href="conversion-and-promotion.html#conversion-and-promotion-1">conversions</a>, it is difficult to explain the utility of the singleton type construct, but in short, it allows one to specialize function behavior on specific type <em>values</em>. This is useful for writing methods (especially parametric ones) whose behavior depends on a type that is given as an explicit argument rather than implied by the type of one of its arguments.</p><p>A few popular languages have singleton types, including Haskell, Scala and Ruby. In general usage, the term &quot;singleton type&quot; refers to a type whose only instance is a single value. This meaning applies to Julia&#39;s singleton types, but with that caveat that only type objects have singleton types.</p><h3><a class="nav-anchor" id="Parametric-Primitive-Types-1" href="#Parametric-Primitive-Types-1">Parametric Primitive Types</a></h3><p>Primitive types can also be declared parametrically. For example, pointers are represented as primitive types which would be declared in Julia like this:</p><pre><code class="language-julia"># 32-bit system:
primitive type Ptr{T} 32 end

# 64-bit system:
primitive type Ptr{T} 64 end</code></pre><p>The slightly odd feature of these declarations as compared to typical parametric composite types, is that the type parameter <code>T</code> is not used in the definition of the type itself – it is just an abstract tag, essentially defining an entire family of types with identical structure, differentiated only by their type parameter. Thus, <code>Ptr{Float64}</code> and <code>Ptr{Int64}</code> are distinct types, even though they have identical representations. And of course, all specific pointer types are subtypes of the umbrella <a href="../base/c.html#Core.Ptr"><code>Ptr</code></a> type:</p><pre><code class="language-julia-repl">julia&gt; Ptr{Float64} &lt;: Ptr
true

julia&gt; Ptr{Int64} &lt;: Ptr
true</code></pre><h2><a class="nav-anchor" id="UnionAll-Types-1" href="#UnionAll-Types-1">UnionAll Types</a></h2><p>We have said that a parametric type like <code>Ptr</code> acts as a supertype of all its instances (<code>Ptr{Int64}</code> etc.). How does this work? <code>Ptr</code> itself cannot be a normal data type, since without knowing the type of the referenced data the type clearly cannot be used for memory operations.  The answer is that <code>Ptr</code> (or other parametric types like <code>Array</code>) is a different kind of type called a <a href="../base/base.html#Core.UnionAll"><code>UnionAll</code></a> type. Such a type expresses the <em>iterated union</em> of types for all values of some parameter.</p><p><code>UnionAll</code> types are usually written using the keyword <code>where</code>. For example <code>Ptr</code> could be more accurately written as <code>Ptr{T} where T</code>, meaning all values whose type is <code>Ptr{T}</code> for some value of <code>T</code>. In this context, the parameter <code>T</code> is also often called a &quot;type variable&quot; since it is like a variable that ranges over types.  Each <code>where</code> introduces a single type variable, so these expressions are nested for types with multiple parameters, for example <code>Array{T,N} where N where T</code>.</p><p>The type application syntax <code>A{B,C}</code> requires <code>A</code> to be a <code>UnionAll</code> type, and first substitutes <code>B</code> for the outermost type variable in <code>A</code>.  The result is expected to be another <code>UnionAll</code> type, into which <code>C</code> is then substituted.  So <code>A{B,C}</code> is equivalent to <code>A{B}{C}</code>.  This explains why it is possible to partially instantiate a type, as in <code>Array{Float64}</code>: the first parameter value has been fixed, but the second still ranges over all possible values.  Using explicit <code>where</code> syntax, any subset of parameters can be fixed. For example, the type of all 1-dimensional arrays can be written as <code>Array{T,1} where T</code>.</p><p>Type variables can be restricted with subtype relations. <code>Array{T} where T&lt;:Integer</code> refers to all arrays whose element type is some kind of <a href="../base/numbers.html#Core.Integer"><code>Integer</code></a>. The syntax <code>Array{&lt;:Integer}</code> is a convenient shorthand for <code>Array{T} where T&lt;:Integer</code>. Type variables can have both lower and upper bounds. <code>Array{T} where Int&lt;:T&lt;:Number</code> refers to all arrays of <a href="../base/numbers.html#Core.Number"><code>Number</code></a>s that are able to contain <code>Int</code>s (since <code>T</code> must be at least as big as <code>Int</code>). The syntax <code>where T&gt;:Int</code> also works to specify only the lower bound of a type variable, and <code>Array{&gt;:Int}</code> is equivalent to <code>Array{T} where T&gt;:Int</code>.</p><p>Since <code>where</code> expressions nest, type variable bounds can refer to outer type variables. For example <code>Tuple{T,Array{S}} where S&lt;:AbstractArray{T} where T&lt;:Real</code> refers to 2-tuples whose first element is some <a href="../base/numbers.html#Core.Real"><code>Real</code></a>, and whose second element is an <code>Array</code> of any kind of array whose element type contains the type of the first tuple element.</p><p>The <code>where</code> keyword itself can be nested inside a more complex declaration. For example, consider the two types created by the following declarations:</p><pre><code class="language-julia-repl">julia&gt; const T1 = Array{Array{T,1} where T, 1}
Array{Array{T,1} where T,1}

julia&gt; const T2 = Array{Array{T,1}, 1} where T
Array{Array{T,1},1} where T</code></pre><p>Type <code>T1</code> defines a 1-dimensional array of 1-dimensional arrays; each of the inner arrays consists of objects of the same type, but this type may vary from one inner array to the next. On the other hand, type <code>T2</code> defines a 1-dimensional array of 1-dimensional arrays all of whose inner arrays must have the same type.  Note that <code>T2</code> is an abstract type, e.g., <code>Array{Array{Int,1},1} &lt;: T2</code>, whereas <code>T1</code> is a concrete type. As a consequence, <code>T1</code> can be constructed with a zero-argument constructor <code>a=T1()</code> but <code>T2</code> cannot.</p><p>There is a convenient syntax for naming such types, similar to the short form of function definition syntax:</p><pre><code class="language-julia">Vector{T} = Array{T,1}</code></pre><p>This is equivalent to <code>const Vector = Array{T,1} where T</code>.  Writing <code>Vector{Float64}</code> is equivalent to writing <code>Array{Float64,1}</code>, and the umbrella type <code>Vector</code> has as instances all <code>Array</code> objects where the second parameter – the number of array dimensions – is 1, regardless of what the element type is. In languages where parametric types must always be specified in full, this is not especially helpful, but in Julia, this allows one to write just <code>Vector</code> for the abstract type including all one-dimensional dense arrays of any element type.</p><h2><a class="nav-anchor" id="Type-Aliases-1" href="#Type-Aliases-1">Type Aliases</a></h2><p>Sometimes it is convenient to introduce a new name for an already expressible type.  This can be done with a simple assignment statement.  For example, <code>UInt</code> is aliased to either <a href="../base/numbers.html#Core.UInt32"><code>UInt32</code></a> or <a href="../base/numbers.html#Core.UInt64"><code>UInt64</code></a> as is appropriate for the size of pointers on the system:</p><pre><code class="language-julia-repl"># 32-bit system:
julia&gt; UInt
UInt32

# 64-bit system:
julia&gt; UInt
UInt64</code></pre><p>This is accomplished via the following code in <code>base/boot.jl</code>:</p><pre><code class="language-julia">if Int === Int64
    const UInt = UInt64
else
    const UInt = UInt32
end</code></pre><p>Of course, this depends on what <code>Int</code> is aliased to – but that is predefined to be the correct type – either <a href="../base/numbers.html#Core.Int32"><code>Int32</code></a> or <a href="../base/numbers.html#Core.Int64"><code>Int64</code></a>.</p><p>(Note that unlike <code>Int</code>, <code>Float</code> does not exist as a type alias for a specific sized <a href="../base/numbers.html#Core.AbstractFloat"><code>AbstractFloat</code></a>. Unlike with integer registers, where the size of <code>Int</code> reflects the size of a native pointer on that machine, the floating point register sizes are specified by the IEEE-754 standard.)</p><h2><a class="nav-anchor" id="Operations-on-Types-1" href="#Operations-on-Types-1">Operations on Types</a></h2><p>Since types in Julia are themselves objects, ordinary functions can operate on them. Some functions that are particularly useful for working with or exploring types have already been introduced, such as the <code>&lt;:</code> operator, which indicates whether its left hand operand is a subtype of its right hand operand.</p><p>The <a href="../base/base.html#Core.isa"><code>isa</code></a> function tests if an object is of a given type and returns true or false:</p><pre><code class="language-julia-repl">julia&gt; isa(1, Int)
true

julia&gt; isa(1, AbstractFloat)
false</code></pre><p>The <a href="../base/base.html#Core.typeof"><code>typeof</code></a> function, already used throughout the manual in examples, returns the type of its argument. Since, as noted above, types are objects, they also have types, and we can ask what their types are:</p><pre><code class="language-julia-repl">julia&gt; typeof(Rational{Int})
DataType

julia&gt; typeof(Union{Real,String})
Union</code></pre><p>What if we repeat the process? What is the type of a type of a type? As it happens, types are all composite values and thus all have a type of <code>DataType</code>:</p><pre><code class="language-julia-repl">julia&gt; typeof(DataType)
DataType

julia&gt; typeof(Union)
DataType</code></pre><p><code>DataType</code> is its own type.</p><p>Another operation that applies to some types is <a href="../base/base.html#Base.supertype"><code>supertype</code></a>, which reveals a type&#39;s supertype. Only declared types (<code>DataType</code>) have unambiguous supertypes:</p><pre><code class="language-julia-repl">julia&gt; supertype(Float64)
AbstractFloat

julia&gt; supertype(Number)
Any

julia&gt; supertype(AbstractString)
Any

julia&gt; supertype(Any)
Any</code></pre><p>If you apply <a href="../base/base.html#Base.supertype"><code>supertype</code></a> to other type objects (or non-type objects), a <a href="../base/base.html#Core.MethodError"><code>MethodError</code></a>  is raised:</p><pre><code class="language-julia-repl">julia&gt; supertype(Union{Float64,Int64})
ERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})
Closest candidates are:
  supertype(!Matched::DataType) at operators.jl:42
  supertype(!Matched::UnionAll) at operators.jl:47</code></pre><h2><a class="nav-anchor" id="man-custom-pretty-printing-1" href="#man-custom-pretty-printing-1">Custom pretty-printing</a></h2><p>Often, one wants to customize how instances of a type are displayed.  This is accomplished by overloading the <a href="../base/io-network.html#Base.show-Tuple{Any}"><code>show</code></a> function.  For example, suppose we define a type to represent complex numbers in polar form:</p><pre><code class="language-julia-repl">julia&gt; struct Polar{T&lt;:Real} &lt;: Number
           r::T
           Θ::T
       end

julia&gt; Polar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)
Polar</code></pre><p>Here, we&#39;ve added a custom constructor function so that it can take arguments of different <a href="../base/numbers.html#Core.Real"><code>Real</code></a> types and promote them to a common type (see <a href="constructors.html#man-constructors-1">Constructors</a>  and <a href="conversion-and-promotion.html#conversion-and-promotion-1">Conversion and Promotion</a>).  (Of course, we would have to define lots of other methods, too, to make it act like a <a href="../base/numbers.html#Core.Number"><code>Number</code></a>, e.g. <code>+</code>, <code>*</code>, <code>one</code>, <code>zero</code>, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. <code>Polar{Float64}(3.0,4.0)</code>.</p><p>代わりに <code>3.0 * exp(4.0im)</code> として表示する場合は、特定の出力オブジェクト &#39;io&#39; にオブジェクトを出力する次のメソッドを定義します (ファイル、端末、バッファなどを表します; <a href="networking-and-streams.html#networking-and-streams-1">ネットワークとストリーム</a>を参照してください):</p><pre><code class="language-julia-repl">julia&gt; Base.show(io::IO, z::Polar) = print(io, z.r, &quot; * exp(&quot;, z.Θ, &quot;im)&quot;)</code></pre><p>More fine-grained control over display of <code>Polar</code> objects is possible. In particular, sometimes one wants both a verbose multi-line printing format, used for displaying a single object in the REPL and other interactive environments, and also a more compact single-line format used for <a href="../base/io-network.html#Base.print"><code>print</code></a> or for displaying the object as part of another object (e.g. in an array). Although by default the <code>show(io, z)</code> function is called in both cases, you can define a <em>different</em> multi-line format for displaying an object by overloading a three-argument form of <code>show</code> that takes the <code>text/plain</code> MIME type as its second argument (see <a href="../base/io-network.html#Multimedia-I/O-1">Multimedia I/O</a>), for example:</p><pre><code class="language-julia-repl">julia&gt; Base.show(io::IO, ::MIME&quot;text/plain&quot;, z::Polar{T}) where{T} =
           print(io, &quot;Polar{$T} complex number:\n   &quot;, z)</code></pre><p>(Note that <code>print(..., z)</code> here will call the 2-argument <code>show(io, z)</code> method.) This results in:</p><pre><code class="language-julia-repl">julia&gt; Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia&gt; [Polar(3, 4.0), Polar(4.0,5.3)]
2-element Array{Polar{Float64},1}:
 3.0 * exp(4.0im)
 4.0 * exp(5.3im)</code></pre><p>where the single-line <code>show(io, z)</code> form is still used for an array of <code>Polar</code> values.   Technically, the REPL calls <code>display(z)</code> to display the result of executing a line, which defaults to <code>show(stdout, MIME(&quot;text/plain&quot;), z)</code>, which in turn defaults to <code>show(stdout, z)</code>, but you should <em>not</em> define new <a href="../base/io-network.html#Base.Multimedia.display"><code>display</code></a> methods unless you are defining a new multimedia display handler (see <a href="../base/io-network.html#Multimedia-I/O-1">Multimedia I/O</a>).</p><p>Moreover, you can also define <code>show</code> methods for other MIME types in order to enable richer display (HTML, images, etcetera) of objects in environments that support this (e.g. IJulia).   For example, we can define formatted HTML display of <code>Polar</code> objects, with superscripts and italics, via:</p><pre><code class="language-julia-repl">julia&gt; Base.show(io::IO, ::MIME&quot;text/html&quot;, z::Polar{T}) where {T} =
           println(io, &quot;&lt;code&gt;Polar{$T}&lt;/code&gt; complex number: &quot;,
                   z.r, &quot; &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;&quot;, z.Θ, &quot; &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;&quot;)</code></pre><p>A <code>Polar</code> object will then display automatically using HTML in an environment that supports HTML display, but you can call <code>show</code> manually to get HTML output if you want:</p><pre><code class="language-julia-repl">julia&gt; show(stdout, &quot;text/html&quot;, Polar(3.0,4.0))
&lt;code&gt;Polar{Float64}&lt;/code&gt; complex number: 3.0 &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;4.0 &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;</code></pre><p>An HTML renderer would display this as: <code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup></p><p>As a rule of thumb, the single-line <code>show</code> method should print a valid Julia expression for creating the shown object.  When this <code>show</code> method contains infix operators, such as the multiplication operator (<code>*</code>) in our single-line <code>show</code> method for <code>Polar</code> above, it may not parse correctly when printed as part of another object.  To see this, consider the expression object (see <a href="metaprogramming.html#Program-representation-1">Program representation</a>) which takes the square of a specific instance of our <code>Polar</code> type:</p><pre><code class="language-julia-repl">julia&gt; a = Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia&gt; print(:($a^2))
3.0 * exp(4.0im) ^ 2</code></pre><p>演算子 <code>^</code> の優先順位は <code>*</code> よりも高いため (<a href="mathematical-operations.html#operator-precedence-and-associativity-1">演算子の優先順位と結合則</a>を参照してください)、この出力は <code>(3.0 * exp(4.0im)) ^ 2</code> と等しいはずの式 <code>a ^ 2</code> を忠実に表しません。 この問題を解決するには、出力時に式オブジェクトによって内部的に呼び出される <code>Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)</code>のカスタムメソッドを作成する必要があります:</p><pre><code class="language-julia-repl">julia&gt; function Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)
           if Base.operator_precedence(:*) &lt;= precedence
               print(io, &quot;(&quot;)
               show(io, z)
               print(io, &quot;)&quot;)
           else
               show(io, z)
           end
       end

julia&gt; :($a^2)
:((3.0 * exp(4.0im)) ^ 2)</code></pre><p>The method defined above adds parentheses around the call to <code>show</code> when the precedence of the calling operator is higher than or equal to the precedence of multiplication.  This check allows expressions which parse correctly without the parentheses (such as <code>:($a + 2)</code> and <code>:($a == 2)</code>) to omit them when printing:</p><pre><code class="language-julia-repl">julia&gt; :($a + 2)
:(3.0 * exp(4.0im) + 2)

julia&gt; :($a == 2)
:(3.0 * exp(4.0im) == 2)</code></pre><p>In some cases, it is useful to adjust the behavior of <code>show</code> methods depending on the context. This can be achieved via the <a href="../base/io-network.html#Base.IOContext"><code>IOContext</code></a> type, which allows passing contextual properties together with a wrapped IO stream.  For example, we can build a shorter representation in our <code>show</code> method when the <code>:compact</code> property is set to <code>true</code>, falling back to the long representation if the property is <code>false</code> or absent:</p><pre><code class="language-julia-repl">julia&gt; function Base.show(io::IO, z::Polar)
           if get(io, :compact, false)
               print(io, z.r, &quot;ℯ&quot;, z.Θ, &quot;im&quot;)
           else
               print(io, z.r, &quot; * exp(&quot;, z.Θ, &quot;im)&quot;)
           end
       end</code></pre><p>This new compact representation will be used when the passed IO stream is an <code>IOContext</code> object with the <code>:compact</code> property set. In particular, this is the case when printing arrays with multiple columns (where horizontal space is limited):</p><pre><code class="language-julia-repl">julia&gt; show(IOContext(stdout, :compact=&gt;true), Polar(3, 4.0))
3.0ℯ4.0im

julia&gt; [Polar(3, 4.0) Polar(4.0,5.3)]
1×2 Array{Polar{Float64},2}:
 3.0ℯ4.0im  4.0ℯ5.3im</code></pre><p>See the <a href="../base/io-network.html#Base.IOContext"><code>IOContext</code></a> documentation for a list of common properties which can be used to adjust printing.</p><h2><a class="nav-anchor" id="&quot;Value-types&quot;-1" href="#&quot;Value-types&quot;-1">&quot;値型&quot;</a></h2><p>In Julia, you can&#39;t dispatch on a <em>value</em> such as <code>true</code> or <code>false</code>. However, you can dispatch on parametric types, and Julia allows you to include &quot;plain bits&quot; values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters.  A common example is the dimensionality parameter in <code>Array{T,N}</code>, where <code>T</code> is a type (e.g., <a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>) but <code>N</code> is just an <code>Int</code>.</p><p>You can create your own custom types that take values as parameters, and use them to control dispatch of custom types. By way of illustration of this idea, let&#39;s introduce a parametric type, <code>Val{x}</code>, and a constructor <code>Val(x) = Val{x}()</code>, which serves as a customary way to exploit this technique for cases where you don&#39;t need a more elaborate hierarchy.</p><p><a href="../base/base.html#Base.Val"><code>Val</code></a> is defined as:</p><pre><code class="language-julia-repl">julia&gt; struct Val{x}
       end

julia&gt; Val(x) = Val{x}()
Val</code></pre><p>There is no more to the implementation of <code>Val</code> than this.  Some functions in Julia&#39;s standard library accept <code>Val</code> instances as arguments, and you can also use it to write your own functions.  For example:</p><pre><code class="language-julia-repl">julia&gt; firstlast(::Val{true}) = &quot;First&quot;
firstlast (generic function with 1 method)

julia&gt; firstlast(::Val{false}) = &quot;Last&quot;
firstlast (generic function with 2 methods)

julia&gt; firstlast(Val(true))
&quot;First&quot;

julia&gt; firstlast(Val(false))
&quot;Last&quot;</code></pre><p>For consistency across Julia, the call site should always pass a <code>Val</code><em>instance</em> rather than using a <em>type</em>, i.e., use <code>foo(Val(:bar))</code> rather than <code>foo(Val{:bar})</code>.</p><p>It&#39;s worth noting that it&#39;s extremely easy to mis-use parametric &quot;value&quot; types, including <code>Val</code>; in unfavorable cases, you can easily end up making the performance of your code much <em>worse</em>.  In particular, you would never want to write actual code as illustrated above.  For more information about the proper (and improper) uses of <code>Val</code>, please read the more extensive discussion in <a href="performance-tips.html#man-performance-tips-1">the performance tips</a>.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>ここでいう、&quot;少数&quot; は<code>MAX_UNION_SPLITTING</code>定数で定義され、現在 4 に設定されています。</p></div><footer><hr/><a class="previous" href="variables-and-scoping.html"><span class="direction">Previous</span><span class="title">Scope of Variables</span></a><a class="next" href="methods.html"><span class="direction">Next</span><span class="title">メソッド</span></a></footer></article></body></html>
