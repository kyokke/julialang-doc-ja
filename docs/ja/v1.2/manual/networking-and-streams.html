<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ネットワークとストリーム · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">はじめよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">モジュール</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">メタプログラミング</a></li><li><a class="toctext" href="arrays.html">多次元配列</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li class="current"><a class="toctext" href="networking-and-streams.html">ネットワークとストリーム</a><ul class="internal"><li><a class="toctext" href="#Basic-Stream-I/O-1">Basic Stream I/O</a></li><li><a class="toctext" href="#Text-I/O-1">Text I/O</a></li><li><a class="toctext" href="#IO-Output-Contextual-Properties-1">IO Output Contextual Properties</a></li><li><a class="toctext" href="#Working-with-Files-1">Working with Files</a></li><li><a class="toctext" href="#簡単な-TCP-の例-1">簡単な TCP の例</a></li><li><a class="toctext" href="#IP-アドレスの解決-1">IP アドレスの解決</a></li></ul></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="running-external-programs.html">外部プログラムの実行</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">C, Fortran コードの呼び出し</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Julia の埋め込み</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">パフォーマンス・ティップス</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">スタイルガイド</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">他の言語との注目すべき違い</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">プロファイリング</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">リフレクションとインストロスペクション</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Julia ランタイムの初期化</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li><li><a class="toctext" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="toctext" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">クラッシュ(セグメンテーションフォルト)の報告と分析</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="networking-and-streams.html">ネットワークとストリーム</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/networking-and-streams.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>ネットワークとストリーム</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="networking-and-streams-1" href="#networking-and-streams-1">ネットワークとストリーム</a></h1><p>Julia は、端末、パイプ、TCP ソケットなどのストリーミング I/O オブジェクトを扱う豊富なインターフェイスを提供します。このインターフェイスは、システム レベルでは非同期ですが、プログラマに同期的に提示され、通常は背後にある非同期処理を考える必要はありません。これは、Julia 協調スレッド(<a href="control-flow.html#man-tasks-1">coroutine</a>)機能を多用することによって達成されます。</p><h2><a class="nav-anchor" id="Basic-Stream-I/O-1" href="#Basic-Stream-I/O-1">Basic Stream I/O</a></h2><p>All Julia streams expose at least a <a href="../base/io-network.html#Base.read"><code>read</code></a> and a <a href="../base/io-network.html#Base.write"><code>write</code></a> method, taking the stream as their first argument, e.g.:</p><pre><code class="language-julia-repl">julia&gt; write(stdout, &quot;Hello World&quot;);  # suppress return value 11 with ;
Hello World
julia&gt; read(stdin, Char)

&#39;\n&#39;: ASCII/Unicode U+000a (category Cc: Other, control)</code></pre><p>Note that <a href="../base/io-network.html#Base.write"><code>write</code></a> returns 11, the number of bytes (in <code>&quot;Hello World&quot;</code>) written to <a href="../base/io-network.html#Base.stdout"><code>stdout</code></a>, but this return value is suppressed with the <code>;</code>.</p><p>Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, <a href="../base/io-network.html#Base.write"><code>write</code></a> takes the data to write as its second argument, while <a href="../base/io-network.html#Base.read"><code>read</code></a>  takes the type of the data to be read as the second argument.</p><p>For example, to read a simple byte array, we could do:</p><pre><code class="language-julia-repl">julia&gt; x = zeros(UInt8, 4)
4-element Array{UInt8,1}:
 0x00
 0x00
 0x00
 0x00

julia&gt; read!(stdin, x)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64</code></pre><p>However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:</p><pre><code class="language-julia-repl">julia&gt; read(stdin, 4)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64</code></pre><p>or if we had wanted to read the entire line instead:</p><pre><code class="language-julia-repl">julia&gt; readline(stdin)
abcd
&quot;abcd&quot;</code></pre><p>Note that depending on your terminal settings, your TTY may be line buffered and might thus require an additional enter before the data is sent to Julia.</p><p>To read every line from <a href="../base/io-network.html#Base.stdin"><code>stdin</code></a> you can use <a href="../base/io-network.html#Base.eachline"><code>eachline</code></a>:</p><pre><code class="language-julia">for line in eachline(stdin)
    print(&quot;Found $line&quot;)
end</code></pre><p>or <a href="../base/io-network.html#Base.read"><code>read</code></a> if you wanted to read by character instead:</p><pre><code class="language-julia">while !eof(stdin)
    x = read(stdin, Char)
    println(&quot;Found: $x&quot;)
end</code></pre><h2><a class="nav-anchor" id="Text-I/O-1" href="#Text-I/O-1">Text I/O</a></h2><p>Note that the <a href="../base/io-network.html#Base.write"><code>write</code></a> method mentioned above operates on binary streams. In particular, values do not get converted to any canonical text representation but are written out as is:</p><pre><code class="language-julia-repl">julia&gt; write(stdout, 0x61);  # suppress return value 1 with ;
a</code></pre><p>Note that <code>a</code> is written to <a href="../base/io-network.html#Base.stdout"><code>stdout</code></a> by the <a href="../base/io-network.html#Base.write"><code>write</code></a> function and that the returned value is <code>1</code> (since <code>0x61</code> is one byte).</p><p>For text I/O, use the <a href="../base/io-network.html#Base.print"><code>print</code></a> or <a href="../base/io-network.html#Base.show-Tuple{Any}"><code>show</code></a> methods, depending on your needs (see the documentation for these two methods for a detailed discussion of the difference between them):</p><pre><code class="language-julia-repl">julia&gt; print(stdout, 0x61)
97</code></pre><p>See <a href="types.html#man-custom-pretty-printing-1">Custom pretty-printing</a> for more information on how to implement display methods for custom types.</p><h2><a class="nav-anchor" id="IO-Output-Contextual-Properties-1" href="#IO-Output-Contextual-Properties-1">IO Output Contextual Properties</a></h2><p>Sometimes IO output can benefit from the ability to pass contextual information into show methods. The <a href="../base/io-network.html#Base.IOContext"><code>IOContext</code></a> object provides this framework for associating arbitrary metadata with an IO object. For example, <code>:compact =&gt; true</code> adds a hinting parameter to the IO object that the invoked show method should print a shorter output (if applicable). See the <a href="../base/io-network.html#Base.IOContext"><code>IOContext</code></a> documentation for a list of common properties.</p><h2><a class="nav-anchor" id="Working-with-Files-1" href="#Working-with-Files-1">Working with Files</a></h2><p>Like many other environments, Julia has an <a href="../base/io-network.html#Base.open"><code>open</code></a> function, which takes a filename and returns an <a href="../base/io-network.html#Base.IOStream"><code>IOStream</code></a> object that you can use to read and write things from the file. For example, if we have a file, <code>hello.txt</code>, whose contents are <code>Hello, World!</code>:</p><pre><code class="language-julia-repl">julia&gt; f = open(&quot;hello.txt&quot;)
IOStream(&lt;file hello.txt&gt;)

julia&gt; readlines(f)
1-element Array{String,1}:
 &quot;Hello, World!&quot;</code></pre><p>If you want to write to a file, you can open it with the write (<code>&quot;w&quot;</code>) flag:</p><pre><code class="language-julia-repl">julia&gt; f = open(&quot;hello.txt&quot;,&quot;w&quot;)
IOStream(&lt;file hello.txt&gt;)

julia&gt; write(f,&quot;Hello again.&quot;)
12</code></pre><p>If you examine the contents of <code>hello.txt</code> at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the <code>IOStream</code> must be closed before the write is actually flushed to disk:</p><pre><code class="language-julia-repl">julia&gt; close(f)</code></pre><p>Examining <code>hello.txt</code> again will show its contents have been changed.</p><p>Opening a file, doing something to its contents, and closing it again is a very common pattern.  To make this easier, there exists another invocation of <a href="../base/io-network.html#Base.open"><code>open</code></a> which takes a function as its first argument and filename as its second, opens the file, calls the function with the file as an argument, and then closes it again. For example, given a function:</p><pre><code class="language-julia">function read_and_capitalize(f::IOStream)
    return uppercase(read(f, String))
end</code></pre><p>You can call:</p><pre><code class="language-julia-repl">julia&gt; open(read_and_capitalize, &quot;hello.txt&quot;)
&quot;HELLO AGAIN.&quot;</code></pre><p>to open <code>hello.txt</code>, call <code>read_and_capitalize</code> on it, close <code>hello.txt</code> and return the capitalized contents.</p><p>To avoid even having to define a named function, you can use the <code>do</code> syntax, which creates an anonymous function on the fly:</p><pre><code class="language-julia-repl">julia&gt; open(&quot;hello.txt&quot;) do f
           uppercase(read(f, String))
       end
&quot;HELLO AGAIN.&quot;</code></pre><h2><a class="nav-anchor" id="簡単な-TCP-の例-1" href="#簡単な-TCP-の例-1">簡単な TCP の例</a></h2><p>ここで、TCP ソケットを含む簡単な例に飛び込んで見ましょう。この機能は、<code>Sockets</code> と呼ばれる標準ライブラリ パッケージにあります。 最初に単純なサーバーを作成してみましょう:</p><pre><code class="language-julia-repl">julia&gt; using Sockets

julia&gt; @async begin
           server = listen(2000)
           while true
               sock = accept(server)
               println(&quot;Hello World\n&quot;)
           end
       end
Task (runnable) @0x00007fd31dc11ae0</code></pre><p>Unix ソケット API に精通している人にとって親しみやすいメソッド名ですが、その使用法は生の Unix ソケット API よりもいくらかシンプルです。<a href="../stdlib/Sockets.html#Sockets.listen-Tuple{Any}"><code>listen</code></a> への最初の呼び出しは、この場合、指定されたポート (2000) 上の着信接続を待機するサーバーを作成します。同じ機能を使用して、他のさまざまな種類のサーバーを作成することもできます:</p><pre><code class="language-julia-repl">julia&gt; listen(2000) # Listens on localhost:2000 (IPv4)
Sockets.TCPServer(active)

julia&gt; listen(ip&quot;127.0.0.1&quot;,2000) # Equivalent to the first
Sockets.TCPServer(active)

julia&gt; listen(ip&quot;::1&quot;,2000) # Listens on localhost:2000 (IPv6)
Sockets.TCPServer(active)

julia&gt; listen(IPv4(0),2001) # Listens on port 2001 on all IPv4 interfaces
Sockets.TCPServer(active)

julia&gt; listen(IPv6(0),2001) # Listens on port 2001 on all IPv6 interfaces
Sockets.TCPServer(active)

julia&gt; listen(&quot;testsocket&quot;) # Listens on a UNIX domain socket
Sockets.PipeServer(active)

julia&gt; listen(&quot;\\\\.\\pipe\\testsocket&quot;) # Listens on a Windows named pipe
Sockets.PipeServer(active)</code></pre><p>最後の呼び出しの戻り値の型が異なることに注意してください。これは、このサーバーが TCP ではなく、名前付きパイプ (Windows) または UNIX ドメイン ソケットでリッスンするためです。また、Windows の名前付きパイプ形式は、名前プレフィックス (<code>\\.\pipe\</code>) が <a href="https://docs.microsoft.com/windows/desktop/ipc/pipe-names">ファイルの種類</a> を一意に識別するように特定のパターンである必要があります。TCP と名前付きパイプまたは UNIX ドメイン ソケットの違いはわずかで、<a href="../stdlib/Sockets.html#Sockets.accept"><code>accept</code></a> メソッドと <a href="../stdlib/Sockets.html#Sockets.connect-Tuple{TCPSocket,Integer}"><code>connect</code></a> メソッドに関係しています。<a href="../stdlib/Sockets.html#Sockets.accept"><code>accept</code></a> メソッドは、作成したサーバーに接続をしようとしているクライアントとの接続を受け入れます。<a href="../stdlib/Sockets.html#Sockets.connect-Tuple{TCPSocket,Integer}"><code>connect</code></a> 関数は指定されたメソッドを使ってサーバーに接続します。<a href="../stdlib/Sockets.html#Sockets.connect-Tuple{TCPSocket,Integer}"><code>connect</code></a> 関数は<a href="../stdlib/Sockets.html#Sockets.listen-Tuple{Any}"><code>listen</code></a>と同じ引数を受け取るので、環境(ホスト、現在のカレントディレクトリなど)が同じであると仮定すると、接続を確立するために行ったのと同じ引数を<a href="../stdlib/Sockets.html#Sockets.connect-Tuple{TCPSocket,Integer}"><code>connect</code></a>に渡すことができるはずです。(上記のサーバーを作成した後)それを試してみましょう:</p><pre><code class="language-julia-repl">julia&gt; connect(2000)
TCPSocket(open, 0 bytes waiting)

julia&gt; Hello World</code></pre><p>予想通り&quot;Hello World&quot; が(サーバー側に)プリントされました。それでは、舞台裏で何が起こったのかを実際に分析してみましょう。<a href="../stdlib/Sockets.html#Sockets.connect-Tuple{TCPSocket,Integer}"><code>connect</code></a>を呼ぶと、作成したサーバーに接続します。一方、accept 関数は、新しく作成されたソケットへのサーバー側からの接続を返し、接続が成功したことを示す &quot;Hello World&quot; を出力します。</p><p>Julia の大きな強みは、I/O が実際に非同期的に発生しているにもかかわらず、API が同期的に公開されるので、コールバックを心配したり、サーバーが確実に実行されることを確認したりする必要がなかったことです。<a href="../stdlib/Sockets.html#Sockets.connect-Tuple{TCPSocket,Integer}"><code>connect</code></a>を呼び出すと、現在のタスクは接続が確立されるのを待ち、その後も実行を続行しました。この一時停止では、サーバー タスクが実行を再開し (接続要求が利用可能になったため)、接続を受け入れ、メッセージを印刷し、次のクライアントを待機しました。ReadとWriteは同じように機能します。 これを確認するために次の単純なエコー サーバーを考えてみましょう:</p><pre><code class="language-julia-repl">julia&gt; @async begin
           server = listen(2001)
           while true
               sock = accept(server)
               @async while isopen(sock)
                   write(sock, readline(sock, keep=true))
               end
           end
       end
Task (runnable) @0x00007fd31dc12e60

julia&gt; clientside = connect(2001)
TCPSocket(RawFD(28) open, 0 bytes waiting)

julia&gt; @async while isopen(clientside)
           write(stdout, readline(clientside, keep=true))
       end
Task (runnable) @0x00007fd31dc11870

julia&gt; println(clientside,&quot;Hello World from the Echo Server&quot;)
Hello World from the Echo Server</code></pre><p>他のストリームと同様に、<a href="../base/io-network.html#Base.close"><code>close</code></a>を使用してソケットを切断します:</p><pre><code class="language-julia-repl">julia&gt; close(clientside)</code></pre><h2><a class="nav-anchor" id="IP-アドレスの解決-1" href="#IP-アドレスの解決-1">IP アドレスの解決</a></h2><p><a href="../stdlib/Sockets.html#Sockets.listen-Tuple{Any}"><code>listen</code></a> メソッドと組み合わせて使われる<a href="../stdlib/Sockets.html#Sockets.connect-Tuple{TCPSocket,Integer}"><code>connect</code></a> メソッドの他に<code>connect(host::String,port)</code>の形式のものがあります。これは、<code>host</code>パラメータで指定されたホストに対して、<code>port</code>で指定されたポートを使って接続します。次のように使い方です:</p><pre><code class="language-julia-repl">julia&gt; connect(&quot;google.com&quot;, 80)
TCPSocket(RawFD(30) open, 0 bytes waiting)</code></pre><p>この機能のベースになっているのは<a href="../stdlib/Sockets.html#Sockets.getaddrinfo"><code>getaddrinfo</code></a>で、適切なアドレス解決を行います:</p><pre><code class="language-julia-repl">julia&gt; getaddrinfo(&quot;google.com&quot;)
ip&quot;74.125.226.225&quot;</code></pre><footer><hr/><a class="previous" href="missing.html"><span class="direction">Previous</span><span class="title">Missing Values</span></a><a class="next" href="parallel-computing.html"><span class="direction">Next</span><span class="title">Parallel Computing</span></a></footer></article></body></html>
