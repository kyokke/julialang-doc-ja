<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>算術演算と初等関数 · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">はじめよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li class="current"><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a><ul class="internal"><li><a class="toctext" href="#算術演算子-1">算術演算子</a></li><li><a class="toctext" href="#ビット演算子-1">ビット演算子</a></li><li><a class="toctext" href="#代入演算子-1">代入演算子</a></li><li><a class="toctext" href="#man-dot-operators-1">ベクトル化した&quot;ドット&quot;演算子</a></li><li><a class="toctext" href="#numeric-comparisons-1">数値比較</a></li><li><a class="toctext" href="#operator-precedence-and-associativity-1">演算子の優先順位と結合則</a></li><li><a class="toctext" href="#数値変換-1">数値変換</a></li></ul></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">モジュール</a></li><li><a class="toctext" href="documentation.html">ドキュメンテーション</a></li><li><a class="toctext" href="metaprogramming.html">メタプログラミング</a></li><li><a class="toctext" href="arrays.html">多次元配列</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">ネットワークとストリーム</a></li><li><a class="toctext" href="parallel-computing.html">並列コンピューティング</a></li><li><a class="toctext" href="running-external-programs.html">外部プログラムの実行</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">C, Fortran コードの呼び出し</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Julia の埋め込み</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">プロファイリング</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">パフォーマンス・ティップス</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">スタイルガイド</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">他の言語との注目すべき違い</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">リフレクションとインストロスペクション</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Julia ランタイムの初期化</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">システムイメージのビルド</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li><li><a class="toctext" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="toctext" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">クラッシュ(セグメンテーションフォルト)の報告と分析</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="mathematical-operations.html">算術演算と初等関数</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/mathematical-operations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>算術演算と初等関数</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="mathematical-operations-and-elementary-functions-1" href="#mathematical-operations-and-elementary-functions-1">算術演算と初等関数</a></h1><p>Julia には、すべての数値プリミティブ型に対して基本的な算術演算子とビット演算子を一通り揃えています。また、移植性の高い、効率的な実装の標準的な数学関数も揃えています。</p><h2><a class="nav-anchor" id="算術演算子-1" href="#算術演算子-1">算術演算子</a></h2><p>次の <a href="https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations">算術演算子</a>は、すべてのプリミティブ数値型でサポートされています:</p><table><tr><th style="text-align: left">式</th><th style="text-align: left">名前</th><th style="text-align: left">説明</th></tr><tr><td style="text-align: left"><code>+x</code></td><td style="text-align: left">単項加算</td><td style="text-align: left">恒等演算</td></tr><tr><td style="text-align: left"><code>-x</code></td><td style="text-align: left">単項減算</td><td style="text-align: left">加算の逆元への写像</td></tr><tr><td style="text-align: left"><code>x + y</code></td><td style="text-align: left">二項加算</td><td style="text-align: left">加算を実行</td></tr><tr><td style="text-align: left"><code>x - y</code></td><td style="text-align: left">二項減算</td><td style="text-align: left">減算を実行</td></tr><tr><td style="text-align: left"><code>x * y</code></td><td style="text-align: left">乗算</td><td style="text-align: left">乗算を実行</td></tr><tr><td style="text-align: left"><code>x / y</code></td><td style="text-align: left">除算</td><td style="text-align: left">除算を実行</td></tr><tr><td style="text-align: left"><code>x ÷ y</code></td><td style="text-align: left">整数除算</td><td style="text-align: left">x / y, 整数に切り捨て</td></tr><tr><td style="text-align: left"><code>x \ y</code></td><td style="text-align: left">逆除算</td><td style="text-align: left"><code>y / x</code>と同等</td></tr><tr><td style="text-align: left"><code>x ^ y</code></td><td style="text-align: left">累乗</td><td style="text-align: left"><code>x</code> の <code>y</code>乗</td></tr><tr><td style="text-align: left"><code>x % y</code></td><td style="text-align: left">剰余算</td><td style="text-align: left"><code>rem(x,y)</code>と同等</td></tr></table><p><a href="../base/numbers.html#Core.Bool"><code>Bool</code></a>タイプの否定も同様です:</p><table><tr><th style="text-align: left">式</th><th style="text-align: left">名前</th><th style="text-align: left">説明</th></tr><tr><td style="text-align: left"><code>!x</code></td><td style="text-align: left">否定</td><td style="text-align: left"><code>true</code> と <code>false</code> を逆にする</td></tr></table><p>Julia の昇格システムは、異なる型の引数型が混在した算術演算を自然かつ自動的うまく動作させます。昇格システムの詳細については、<a href="conversion-and-promotion.html#conversion-and-promotion-1">変換と昇格</a>を参照してください。</p><p>算術演算子を使用した簡単な例を次に示します:</p><pre><code class="language-julia-repl">julia&gt; 1 + 2 + 3
6

julia&gt; 1 - 2
-1

julia&gt; 3*2/12
0.5</code></pre><p>(慣習的に周りの他の演算子より先に演算を行う演算では空白を詰めることがよくあります。たとえば、<code>-x + 2</code> と書くのは、最初の <code>x</code> に-1をかけてから<code>2</code> を足すことを反映しています。)</p><h2><a class="nav-anchor" id="ビット演算子-1" href="#ビット演算子-1">ビット演算子</a></h2><p>次の <a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators">ビット演算子</a>は、すべてのプリミティブ整数型でサポートされています:</p><table><tr><th style="text-align: left">式</th><th style="text-align: left">名前</th></tr><tr><td style="text-align: left"><code>~x</code></td><td style="text-align: left">否定(not)</td></tr><tr><td style="text-align: left"><code>x &amp; y</code></td><td style="text-align: left">論理積(and)</td></tr><tr><td style="text-align: left"><code>x | y</code></td><td style="text-align: left">論理和(or)</td></tr><tr><td style="text-align: left"><code>x ⊻ y</code></td><td style="text-align: left">排他的論理和(xor)</td></tr><tr><td style="text-align: left"><code>x &gt;&gt;&gt; y</code></td><td style="text-align: left">右<a href="https://en.wikipedia.org/wiki/Logical_shift">論理シフト</a></td></tr><tr><td style="text-align: left"><code>x &gt;&gt; y</code></td><td style="text-align: left">右<a href="https://en.wikipedia.org/wiki/Arithmetic_shift">算術シフト</a></td></tr><tr><td style="text-align: left"><code>x &lt;&lt; y</code></td><td style="text-align: left">左 論理/算術シフト</td></tr></table><p>ビット演算子を使用例を下記の通りです:</p><pre><code class="language-julia-repl">julia&gt; ~123
-124

julia&gt; 123 &amp; 234
106

julia&gt; 123 | 234
251

julia&gt; 123 ⊻ 234
145

julia&gt; xor(123, 234)
145

julia&gt; ~UInt32(123)
0xffffff84

julia&gt; ~UInt8(123)
0x84</code></pre><h2><a class="nav-anchor" id="代入演算子-1" href="#代入演算子-1">代入演算子</a></h2><p>すべての二項演算子・ビット演算子では、操作の結果を左の演算子に代入するバージョンの演算子が存在します。二項演算子の代入バージョンは、元の演算子の直後に <code>=</code> をつけます。たとえば、<code>x += 3</code> は<code>x = x + 3</code> を書くのと同じです:</p><pre><code class="language-julia-repl">julia&gt; x = 1
1

julia&gt; x += 3
4

julia&gt; x
4</code></pre><p>すべての二項算術演算子とビット演算子の代入バージョンは以下のとおりです:</p><pre><code class="language-none">+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>代入演算子は、左辺側変数に再バインドを行います。結果、変数の方が変わることもあります。</p><pre><code class="language-julia-repl">julia&gt; x = 0x01; typeof(x)
UInt8

julia&gt; x *= 2 # Same as x = x * 2
2

julia&gt; typeof(x)
Int64</code></pre></div></div><h2><a class="nav-anchor" id="man-dot-operators-1" href="#man-dot-operators-1">ベクトル化した&quot;ドット&quot;演算子</a></h2><p><em>全ての</em> <code>^</code> のような二項演算子には、配列の各要素に対して <code>^</code>を実行するドット演算子 <code>.^</code>が自動的に定義されます。たとえば、<code>[1,2,3] ^ 3</code> は定義されていません。非正方の配列の3乗は数学的に意味を成さないからです。しかし、<code>[1,2,3] .^ 3</code> は要素毎の計算として定義され、その結果は<code>[1^3,2^3, 3^3]</code>となります。同様に、<code>!</code> や <code>√</code> のような単項演算子の場合も、演算子を要素的に適用する対応する <code>.√</code> があります。</p><pre><code class="language-julia-repl">julia&gt; [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27</code></pre><p>具体的には、<code>a.^ b</code> は<a href="functions.html#man-vectorized-1">&quot;ドット&quot;呼び出し</a><code>(^).(a,b)</code>として解析されます。これは、<a href="arrays.html#Broadcasting-1">ブロードキャスト</a> 操作を実行します: 配列とスカラー、同一サイズの配列2つ(要素ごとの演算子適用)そして、異なるサイズの配列(例えば、行ベクトルと列ベクトルの積)でさえも組み合わせ利用できます。さらに、すべてのベクトル化された&quot;ドットコール&quot;と同様に、これらの「ドット演算子」は<em>融合的</em>です。たとえば、配列<code>A</code>に対して <code>2 .* A.^2 .+ sin(A)</code> (もしくは、<a href="../base/arrays.html#Base.Broadcast.@__dot__"><code>@</code></a> マクロを使用して<code>@. 2A^2 + sin(A)</code>とも書けますが)を計算する時、<code>A</code>の要素に関するループを<em>1回</em>実行し<code>2a^2 + sin(a)</code> を各要素に対して計算します。特に、<code>f.(g.(x))</code> のような入れ子になったドットコールは融合され、<code>x.+ 3 .* x.^2</code> のような &quot;隣接する&quot; 二項演算子は入れ子になったドットコール <code>(+) .(x, (*).(3,(^).(x, 2)))</code>と等価になります。</p><p>さらに、<code>a.+= b</code> (または <code>@. a += b</code>) のような &quot;ドットのついた&quot; 代入演算子は <code>a= a .+ b</code> として解析され、<code>.=</code> は融合された <em>インプレース</em> 代入となります (<a href="functions.html#man-vectorized-1">ドット構文ドキュメント</a>を参照してください)。</p><p>ドット構文は、ユーザーが定義した演算子にも適用できます。 たとえば、クローネッカー積(<a href="../stdlib/LinearAlgebra.html#Base.kron"><code>kron</code></a>)に便利なイン二項演算構文 <code>A ⊗ B</code>を使うために<code>⊗(A,B) = kron(A,B)</code> を定義した場合 、<code>[A,B] .⊗[C,D]</code> は追加のコーディングなしで <code>[A⊗B, B⊗D]</code> を計算します。</p><p>ドット演算子と数値リテラルの組み合わせがあいまいになる場合があります。 たとえば、<code>1.+x</code> が <code>1. +x</code> と <code>1 .+ x</code>のどちらを意味するかは自明ではありません。したがって、この構文は許可されず、このような場合は演算子の周囲にスペースを使用する必要があります。</p><h2><a class="nav-anchor" id="numeric-comparisons-1" href="#numeric-comparisons-1">数値比較</a></h2><p>すべてのプリミティブ数値型に対して標準的な比較演算子が定義されています:</p><table><tr><th style="text-align: left">演算子</th><th style="text-align: left">名前</th></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.:=="><code>==</code></a></td><td style="text-align: left">等号</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.:!="><code>!=</code></a>, <a href="../base/math.html#Base.:!="><code>≠</code></a></td><td style="text-align: left">inequality</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.:&lt;"><code>&lt;</code></a></td><td style="text-align: left">未満</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.:&lt;="><code>&lt;=</code></a>, <a href="../base/math.html#Base.:&lt;="><code>≤</code></a></td><td style="text-align: left">以下</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.:&gt;"><code>&gt;</code></a></td><td style="text-align: left">より大きい</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.:&gt;="><code>&gt;=</code></a>, <a href="../base/math.html#Base.:&gt;="><code>≥</code></a></td><td style="text-align: left">以上</td></tr></table><p>簡単な例を次に示します:</p><pre><code class="language-julia-repl">julia&gt; 1 == 1
true

julia&gt; 1 == 2
false

julia&gt; 1 != 2
true

julia&gt; 1 == 1.0
true

julia&gt; 1 &lt; 2
true

julia&gt; 1.0 &gt; 3
false

julia&gt; 1 &gt;= 1.0
true

julia&gt; -1 &lt;= 1
true

julia&gt; -1 &lt;= -1
true

julia&gt; -1 &lt;= -2
false

julia&gt; 3 &lt; -0.5
false</code></pre><p>整数は、標準的なビットの比較の方法で比較されます。浮動小数点数は<a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754標準</a>に従って比較されます:</p><ul><li>有限数は通常の方法で順序付けされます。</li><li>正のゼロは負のゼロと等しく、負のゼロより大きくはない。</li><li><code>Inf</code> はそれ自体と等しく、<code>NaN</code> を除く他のすべてよりも大きい。</li><li><code>-Inf</code> はそれ自体に等しく、<code>NaN</code> を除く他のすべての数より小さい。</li><li>「NaN」は、それ自体を含め、何とも等しくなく、大きくも小さくもない。</li></ul><p>最後のポイントは、ひょっとすると驚くべきことであり、したがって注目に値します:</p><pre><code class="language-julia-repl">julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false

julia&gt; NaN &gt; NaN
false</code></pre><p>また、<a href="arrays.html#man-multi-dim-arrays-1">配列</a> では頭痛の種になりえます:</p><pre><code class="language-julia-repl">julia&gt; [1 NaN] == [1 NaN]
false</code></pre><p>Julia では、特殊な値を検査する補助的な関数が提供されており、ハッシュ キーの比較などで役立ちます:</p><table><tr><th style="text-align: left">関数</th><th style="text-align: left">検査内容</th></tr><tr><td style="text-align: left"><a href="../base/base.html#Base.isequal"><code>isequal(x, y)</code></a></td><td style="text-align: left"><code>x</code> と <code>y</code> が等しいか</td></tr><tr><td style="text-align: left"><a href="../base/numbers.html#Base.isfinite"><code>isfinite(x)</code></a></td><td style="text-align: left"><code>x</code> は有限であるか</td></tr><tr><td style="text-align: left"><a href="../base/numbers.html#Base.isinf"><code>isinf(x)</code></a></td><td style="text-align: left"><code>x</code> は無限大であるか</td></tr><tr><td style="text-align: left"><a href="../base/numbers.html#Base.isnan"><code>isnan(x)</code></a></td><td style="text-align: left"><code>x</code> is NaNであるか</td></tr></table><p><a href="../base/base.html#Base.isequal"><code>isequal</code></a> は <code>NaN</code> を互いに等しいと見なします:</p><pre><code class="language-julia-repl">julia&gt; isequal(NaN, NaN)
true

julia&gt; isequal([1 NaN], [1 NaN])
true

julia&gt; isequal(NaN, NaN32)
true</code></pre><p><code>isequal</code> は、符号付きゼロを区別するためにも使用できます:</p><pre><code class="language-julia-repl">julia&gt; -0.0 == 0.0
true

julia&gt; isequal(-0.0, 0.0)
false</code></pre><p>符号付き整数、符号なし整数、および浮動小数点数が混在する比較は、難しい場合があります。Julia が正しい比較を行うために、多くの注意が払われてきました。</p><p>他の型については、<code>isequal</code> はデフォルトで <a href="../base/math.html#Base.:=="><code>==</code></a> を呼び出すので、独自の型の等価性を定義する場合は、<a href="../base/math.html#Base.:=="><code>==</code></a> メソッドを追加するだけで済みます。 さらに、<code>isequal(x,y)</code> が <code>True</code>となる時に <code>hash(x) == hash(y)</code>でもあることを保証したいのであれば、対応する <a href="../base/base.html#Base.hash"><code>hash</code></a> メソッドも定義しなければいけないでしょう。</p><h3><a class="nav-anchor" id="比較の連鎖-1" href="#比較の連鎖-1">比較の連鎖</a></h3><p>ほとんどの言語とは異なり、Julia は比較を任意に連鎖させることができます。(ほとんどの言語と言いましたが、<a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Comparison_operators">なんとPythonは比較の連鎖ができます</a>。)</p><pre><code class="language-julia-repl">julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true</code></pre><p>比較の連鎖は数値計算のコードで大変便利に使えることが多いです。比較の連鎖では、スカラー比較には <code>&amp;&amp;</code> 演算子を使い、配列に対する要素毎の比較には <a href="../base/math.html#Base.:&amp;"><code>&amp;</code></a> 演算子を使います。たとえば、<code>0 .&lt;A.&lt;1</code>は、配列<code>A</code>の要素で0 と 1 の間にある要素に対応する位置の要素がtrueであるような真偽値の配列を返します。</p><p>比較連鎖の振る舞いに注意してください:</p><pre><code class="language-julia-repl">julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; v(1) &lt; v(2) &lt;= v(3)
2
1
3
true

julia&gt; v(1) &gt; v(2) &lt;= v(3)
2
1
false</code></pre><p>真ん中の式は、<code>v(1) &lt; v(2) &amp;&amp; v(2) &lt;= v(3)</code> と書かれてた場合のように2回評価されるのではなく、1回だけ評価されています。ただし、比較連鎖の中での評価の順序は未定義です。(printなどの)副作用のある表現を使用しないことを強くお勧めします。もし副作用が必要な場合は、短絡演算子 <code>&amp;&amp;</code> を明示的に使用する必要があります(参照: <a href="control-flow.html#short-circuit-evaluation-1">短絡評価</a>)。</p><h3><a class="nav-anchor" id="elementary-functions-1" href="#elementary-functions-1">初等関数</a></h3><p>Juliaは一通りの数学関数と算術演算を提供します。これらの算術演算は、その意味をなす限り、整数、浮動小数点数、有理数、複素数など様々な数値クラスに対して定義されています。</p><p>さらに、これらの関数は(他のJulia関数と同様に)、「ベクトル化」した形で配列やその他のコレクションに対して適用することができます。その際には、<a href="functions.html#man-vectorized-1"><code>dot構文</code></a><code>f.(A)</code>を使い、例えば <code>sin.(A)</code>は配列<code>A</code>の各要素に対してsinの値を適用します。</p><h2><a class="nav-anchor" id="operator-precedence-and-associativity-1" href="#operator-precedence-and-associativity-1">演算子の優先順位と結合則</a></h2><p>Julia では、下記の優先順位と結合則で、上から下へと演算子が適用されます:</p><table><tr><th style="text-align: left">種別</th><th style="text-align: left">演算子</th><th style="text-align: left">結合則</th></tr><tr><td style="text-align: left">構文</td><td style="text-align: left">まずは<code>.</code> 次に <code>::</code></td><td style="text-align: left">左</td></tr><tr><td style="text-align: left">累乗</td><td style="text-align: left"><code>^</code></td><td style="text-align: left">右</td></tr><tr><td style="text-align: left">単項演算子</td><td style="text-align: left"><code>+ - √</code></td><td style="text-align: left">右<a href="#footnote-1">[1]</a></td></tr><tr><td style="text-align: left">シフト</td><td style="text-align: left"><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td><td style="text-align: left">左</td></tr><tr><td style="text-align: left">分数</td><td style="text-align: left"><code>//</code></td><td style="text-align: left">左</td></tr><tr><td style="text-align: left">乗算</td><td style="text-align: left"><code>* / % &amp; \ ÷</code></td><td style="text-align: left">左<a href="#footnote-2">[2]</a></td></tr><tr><td style="text-align: left">加算</td><td style="text-align: left"><code>+ - | ⊻</code></td><td style="text-align: left">左<a href="#footnote-2">[2]</a></td></tr><tr><td style="text-align: left">構文</td><td style="text-align: left"><code>: ..</code></td><td style="text-align: left">左</td></tr><tr><td style="text-align: left">構文</td><td style="text-align: left"><code>|&gt;</code></td><td style="text-align: left">左</td></tr><tr><td style="text-align: left">構文</td><td style="text-align: left"><code>&lt;|</code></td><td style="text-align: left">右</td></tr><tr><td style="text-align: left">比較</td><td style="text-align: left"><code>&gt; &lt; &gt;= &lt;= == === != !== &lt;:</code></td><td style="text-align: left">非結合</td></tr><tr><td style="text-align: left">制御</td><td style="text-align: left">まずは <code>&amp;&amp;</code> その次に <code>||</code> そして <code>?</code></td><td style="text-align: left">右</td></tr><tr><td style="text-align: left">対</td><td style="text-align: left"><code>=&gt;</code></td><td style="text-align: left">右</td></tr><tr><td style="text-align: left">代入</td><td style="text-align: left"><code>= += -= *= /= //= \= ^= ÷= %= |= &amp;= ⊻= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code></td><td style="text-align: left">右</td></tr></table><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>単項演算子 <code>+</code> と <code>-</code> には、明示的に括弧をつけて、<code>++</code>などの演算子との曖昧性を排除する必要があります。他の単項演算子の結合は右結合として解析される。例えば、<code>√√-a</code> は <code>√(√(-a))</code>と解釈されます。.</p></div><div class="footnote" id="footnote-2"><a href="#footnote-2"><strong>[2]</strong></a><p>演算子 <code>+</code>, <code>++</code>, <code>*</code> は、非結合的です。つまり <code>a + b + c</code> は <code>+(+(a, b),c)</code>ではなく、<code>+(a, b, c)</code> と解析されます。ただし、　フォールバックメソッドの<code>+(a, b, c, d...)</code> や <code>*(a, b, c, d...)</code> はどちらもデフォルトでは左結合で評価されます。</p></div><p>Julia における <em>全ての</em> 演算子の優先順位の完全なリストは、このファイルの上部を参照してください: <a href="https://github.com/juliaLang/julia/blob/master/src/julia-parser.scm"><code>src/julia-parser.scm</code></a></p><p>また、組み込み関数 <code>Base.operator_precedence</code> を使用して、特定の演算子の数値の優先順位をつきとめることもできます:</p><pre><code class="language-julia-repl">julia&gt; Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 13, 17)

julia&gt; Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)
(0, 1, 1)</code></pre><p>演算子を表すシンボルの結合則も組み込み関数 <code>Base.operator_associaivity</code> を呼び出すことによっても見つけることができます:</p><pre><code class="language-julia-repl">julia&gt; Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)

julia&gt; Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)
(:left, :none, :right)</code></pre><p><code>:sin</code> などのシンボルは <code>0</code> を返します。この値は引数に与えられたシンボルが演算子として無効であることを表しているだけで、優先順位が最も低いということではありません。同様に、このような演算子には結合性は <code>:none</code> が割り当てられます。</p><h2><a class="nav-anchor" id="数値変換-1" href="#数値変換-1">数値変換</a></h2><p>Julia は、3 つの形式の数値変換をサポートしていますが、これらはそれぞれ厳密な変換ができないときの扱いが異なります。</p><ul><li><p><code>T(x)</code> または <code>convert(T,x)</code> は <code>x</code> を型 <code>T</code> の値に変換します。</p><ul><li><code>T</code> が浮動小数点型の場合、結果は最も近い表現可能な値であり、正または負の無限大になる可能性があります。</li><li><code>T</code> が整数型の場合, <code>x</code> が <code>T</code>で表せない場合には<code>InexactError</code> が発生します。.</li></ul></li><li><p><code>x % T</code> は <code>x</code> を整数型 <code>T</code>の、<code>2^n</code> を法として、<code>x</code>と合同な数に変換します。ここで <code>n</code> は <code>T</code>のビット数です。言い換えると、2進数表現を <code>T</code> で表現できるよう切り捨てをしています。</p></li><li><p><a href="mathematical-operations.html#rounding-functions-1">丸め関数</a> はオプションの引数として、型 <code>T</code> をとります。例えば, <code>round(Int,x)</code>は <code>Int(round(x))</code>の略記です。</p></li></ul><p>以下にそれぞれの例を示します。</p><pre><code class="language-julia-repl">julia&gt; Int8(127)
127

julia&gt; Int8(128)
ERROR: InexactError: trunc(Int8, 128)
Stacktrace:
[...]

julia&gt; Int8(127.0)
127

julia&gt; Int8(3.14)
ERROR: InexactError: Int8(3.14)
Stacktrace:
[...]

julia&gt; Int8(128.0)
ERROR: InexactError: Int8(128.0)
Stacktrace:
[...]

julia&gt; 127 % Int8
127

julia&gt; 128 % Int8
-128

julia&gt; round(Int8,127.4)
127

julia&gt; round(Int8,127.6)
ERROR: InexactError: trunc(Int8, 128.0)
Stacktrace:
[...]</code></pre><p>独自の変換と昇格を定義する方法については、<a href="conversion-and-promotion.html#conversion-and-promotion-1">変換と昇格</a>を参照してください。</p><h3><a class="nav-anchor" id="rounding-functions-1" href="#rounding-functions-1">丸め関数</a></h3><table><tr><th style="text-align: left">関数</th><th style="text-align: left">説明</th><th style="text-align: left">戻り値の型</th></tr><tr><td style="text-align: left"><a href="../stdlib/Dates.html#Base.round-Tuple{TimeType,Period,RoundingMode{:NearestTiesUp}}"><code>round(x)</code></a></td><td style="text-align: left"><code>x</code> を最も近い整数に丸める</td><td style="text-align: left"><code>typeof(x)</code></td></tr><tr><td style="text-align: left"><a href="../stdlib/Dates.html#Base.round-Tuple{TimeType,Period,RoundingMode{:NearestTiesUp}}"><code>round(T, x)</code></a></td><td style="text-align: left"><code>x</code> を最も近い整数に丸める</td><td style="text-align: left"><code>T</code></td></tr><tr><td style="text-align: left"><a href="../stdlib/Dates.html#Base.floor-Tuple{TimeType,Period}"><code>floor(x)</code></a></td><td style="text-align: left"><code>x</code> を<code>-Inf</code> の方向に丸める</td><td style="text-align: left"><code>typeof(x)</code></td></tr><tr><td style="text-align: left"><a href="../stdlib/Dates.html#Base.floor-Tuple{TimeType,Period}"><code>floor(T, x)</code></a></td><td style="text-align: left"><code>x</code> を<code>-Inf</code> の方向に丸める</td><td style="text-align: left"><code>T</code></td></tr><tr><td style="text-align: left"><a href="../stdlib/Dates.html#Base.ceil-Tuple{TimeType,Period}"><code>ceil(x)</code></a></td><td style="text-align: left"><code>x</code> を <code>+Inf</code> の方向に丸める</td><td style="text-align: left"><code>typeof(x)</code></td></tr><tr><td style="text-align: left"><a href="../stdlib/Dates.html#Base.ceil-Tuple{TimeType,Period}"><code>ceil(T, x)</code></a></td><td style="text-align: left"><code>x</code> を<code>+Inf</code> の方向に丸める</td><td style="text-align: left"><code>T</code></td></tr><tr><td style="text-align: left"><a href="../stdlib/Dates.html#Base.trunc-Tuple{TimeType,Type{Period}}"><code>trunc(x)</code></a></td><td style="text-align: left"><code>x</code> を ゼロの方向に丸める</td><td style="text-align: left"><code>typeof(x)</code></td></tr><tr><td style="text-align: left"><a href="../stdlib/Dates.html#Base.trunc-Tuple{TimeType,Type{Period}}"><code>trunc(T, x)</code></a></td><td style="text-align: left"><code>x</code> をゼロの方向に丸める</td><td style="text-align: left"><code>T</code></td></tr></table><h3><a class="nav-anchor" id="除算関数-1" href="#除算関数-1">除算関数</a></h3><table><tr><th style="text-align: left">関数</th><th style="text-align: left">説明</th></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.div"><code>div(x,y)</code></a>, <code>x÷y</code></td><td style="text-align: left">切り落とし除算; ゼロ方向に丸めた商</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.fld"><code>fld(x,y)</code></a></td><td style="text-align: left">floor除算; <code>-Inf</code>方向に丸めた商</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.cld"><code>cld(x,y)</code></a></td><td style="text-align: left">ceil除算; <code>+Inf</code>方向に丸めた商</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.rem"><code>rem(x,y)</code></a></td><td style="text-align: left">剰余(remainder); <code>x == div(x,y)*y + rem(x,y)</code>; 符号は <code>x</code> と一致</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.mod"><code>mod(x,y)</code></a></td><td style="text-align: left">剰余(modulus); <code>x == fld(x,y)*y + mod(x,y)</code>; 符号は <code>y</code> と一致</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.mod1"><code>mod1(x,y)</code></a></td><td style="text-align: left">1オフセットをした<code>mod</code>; <code>mod(r, y) == mod(x, y)</code> を満たし <code>y&gt;0</code>の場合 <code>r∈(0,y]</code>、<code>y&lt;0</code> の場合 <code>r∈[y,0)</code> となるような <code>r</code>を返す</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.Math.mod2pi"><code>mod2pi(x)</code></a></td><td style="text-align: left">2pi を法とする剰余;  <code>0 &lt;= mod2pi(x) &lt; 2pi</code></td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.divrem"><code>divrem(x,y)</code></a></td><td style="text-align: left"><code>(div(x,y),rem(x,y))</code>を返す</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.fldmod"><code>fldmod(x,y)</code></a></td><td style="text-align: left"><code>(fld(x,y),mod(x,y))</code>を返す</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.gcd"><code>gcd(x,y...)</code></a></td><td style="text-align: left"><code>x</code>, <code>y</code>,... の正の最大公約数 (greatest positive common divisor)</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.lcm"><code>lcm(x,y...)</code></a></td><td style="text-align: left"><code>x</code>, <code>y</code>,... の正の最小公倍数 (least positive common multiple)</td></tr></table><h3><a class="nav-anchor" id="符号関数と絶対値関数-1" href="#符号関数と絶対値関数-1">符号関数と絶対値関数</a></h3><table><tr><th style="text-align: left">関数</th><th style="text-align: left">説明</th></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.abs"><code>abs(x)</code></a></td><td style="text-align: left"><code>x</code> の絶対値</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.abs2"><code>abs2(x)</code></a></td><td style="text-align: left"><code>x</code> の絶対値の二乗</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.sign"><code>sign(x)</code></a></td><td style="text-align: left"><code>x</code> の符号。 returning -1, 0, +1 のいずれかを返す</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.signbit"><code>signbit(x)</code></a></td><td style="text-align: left">サインビットが立っているかどうか true/false を返す</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.copysign"><code>copysign(x,y)</code></a></td><td style="text-align: left"><code>sign(y) * abs(x)</code> を返す</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.flipsign"><code>flipsign(x,y)</code></a></td><td style="text-align: left"><code>sign(x*y) * abs(x)</code> を返す</td></tr></table><h3><a class="nav-anchor" id="累乗・対数・平方根-1" href="#累乗・対数・平方根-1">累乗・対数・平方根</a></h3><table><tr><th style="text-align: left">関数</th><th style="text-align: left">説明</th></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.sqrt-Tuple{Real}"><code>sqrt(x)</code></a>, <code>√x</code></td><td style="text-align: left"><code>x</code> の平方根</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.Math.cbrt"><code>cbrt(x)</code></a>, <code>∛x</code></td><td style="text-align: left"><code>x</code> の三乗根</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.Math.hypot"><code>hypot(x,y)</code></a></td><td style="text-align: left">直角を挟む2辺の長さが<code>x</code>, <code>y</code> である直角三角形の斜辺の長さ</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.exp-Tuple{Float64}"><code>exp(x)</code></a></td><td style="text-align: left">自然指数関数 の <code>x</code> での値</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.expm1"><code>expm1(x)</code></a></td><td style="text-align: left">ゼロ近傍の<code>x</code> に対する <code>exp(x)-1</code>の正確な値を返す</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.Math.ldexp"><code>ldexp(x,n)</code></a></td><td style="text-align: left">整数値 <code>n</code> に対する <code>x*2^n</code> を効率的に計算する</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.log-Tuple{Number}"><code>log(x)</code></a></td><td style="text-align: left">自然対数の <code>x</code> での値</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.log-Tuple{Number}"><code>log(b,x)</code></a></td><td style="text-align: left">底<code>b</code> の対数の<code>x</code> での値</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.log2"><code>log2(x)</code></a></td><td style="text-align: left">底2 の対数の<code>x</code> での値</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.log10"><code>log10(x)</code></a></td><td style="text-align: left">底10の対数の<code>x</code> での値</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.log1p"><code>log1p(x)</code></a></td><td style="text-align: left">ゼロ近傍の<code>x</code> に対する <code>log(1+x)</code>の正確な値</td></tr><tr><td style="text-align: left"><a href="../base/numbers.html#Base.Math.exponent"><code>exponent(x)</code></a></td><td style="text-align: left">浮動小数点<code>x</code> の 2を基数とする指数部分</td></tr><tr><td style="text-align: left"><a href="../base/numbers.html#Base.Math.significand"><code>significand(x)</code></a></td><td style="text-align: left">浮動小数点 <code>x</code> の 2を基数とする仮数部分</td></tr></table><p><a href="../base/math.html#Base.Math.hypot"><code>hypot</code></a>、<a href="../base/math.html#Base.expm1"><code>expm1</code></a>、および<a href="../base/math.html#Base.log1p"><code>log1p</code></a>のような関数が必要かつ有用である理由概説については、John D. Cook の優れたブログ投稿を参照してください: <a href="https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/">expm1, log1p,erfc</a>、および <a href="https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/">hypot</a>。</p><h3><a class="nav-anchor" id="三角関数と双曲線関数-1" href="#三角関数と双曲線関数-1">三角関数と双曲線関数</a></h3><p>すべての標準的な三角関数と双曲線関数も定義されています:</p><pre><code class="language-none">sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc</code></pre><p>これらはすべて単一引数関数ですが、<a href="../base/math.html#Base.atan-Tuple{Number}"><code>atan</code></a>は2つの引数をとることもでき、そのときは 従来の<a href="https://en.wikipedia.org/wiki/Atan2"><code>atan2</code></a> 関数の振る舞いになります。</p><p>また、<a href="../base/math.html#Base.Math.sinpi"><code>sinpi(x)</code></a>と<a href="../base/math.html#Base.Math.cospi"><code>cospi(x)</code></a>は、それぞれ<a href="../base/math.html#Base.sin-Tuple{Number}"><code>sin(pi*x)</code></a>と<a href="../base/math.html#Base.cos-Tuple{Number}"><code>cos(pi*x)</code></a>のより正確な計算のために提供されます。</p><p>ラジアンの代わりに&quot;度&quot;を使用して三角関数を計算するには、関数の接尾辞を <code>d</code> で囲みます。たとえば、<a href="../base/math.html#Base.Math.sind"><code>sind(x)</code></a>は<code>x</code>が&quot;度&quot;で指定される<code>x</code>のsinを計算します。 &quot;度&quot;を入力に使用した三角関数の完全なリストは次のとおりです:</p><pre><code class="language-none">sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd</code></pre><h3><a class="nav-anchor" id="特殊関数-1" href="#特殊関数-1">特殊関数</a></h3><p>他の多くの特殊関数は、パッケージ<a href="https://github.com/JuliaMath/SpecialFunctions.jl">SpecialFunctions.jl</a>で提供されています。</p><footer><hr/><a class="previous" href="integers-and-floating-point-numbers.html"><span class="direction">Previous</span><span class="title">整数と浮動小数点数</span></a><a class="next" href="complex-and-rational-numbers.html"><span class="direction">Next</span><span class="title">複素数と有理数</span></a></footer></article></body></html>
