<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Proper maintenance and care of multi-threading locks · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/getting-started.html">はじめよう</a></li><li><a class="toctext" href="../manual/variables.html">変数</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="../manual/strings.html">文字列</a></li><li><a class="toctext" href="../manual/functions.html">関数</a></li><li><a class="toctext" href="../manual/control-flow.html">制御フロー</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/types.html">型</a></li><li><a class="toctext" href="../manual/methods.html">メソッド</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/modules.html">モジュール</a></li><li><a class="toctext" href="../manual/documentation.html">ドキュメンテーション</a></li><li><a class="toctext" href="../manual/metaprogramming.html">メタプログラミング</a></li><li><a class="toctext" href="../manual/arrays.html">多次元配列</a></li><li><a class="toctext" href="../manual/missing.html">Missing Values</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">ネットワークとストリーム</a></li><li><a class="toctext" href="../manual/parallel-computing.html">並列コンピューティング</a></li><li><a class="toctext" href="../manual/running-external-programs.html">外部プログラムの実行</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">C, Fortran コードの呼び出し</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="../manual/embedding.html">Julia の埋め込み</a></li><li><a class="toctext" href="../manual/code-loading.html">Code Loading</a></li><li><a class="toctext" href="../manual/profile.html">プロファイリング</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/performance-tips.html">パフォーマンス・ティップス</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="../manual/style-guide.html">スタイルガイド</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">他の言語との注目すべき違い</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/Future.html">Future</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">プロファイリング</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="reflection.html">リフレクションとインストロスペクション</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="init.html">Julia ランタイムの初期化</a></li><li><a class="toctext" href="ast.html">Julia ASTs</a></li><li><a class="toctext" href="types.html">More about types</a></li><li><a class="toctext" href="object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="eval.html">Eval of Julia code</a></li><li><a class="toctext" href="callconv.html">Calling Conventions</a></li><li><a class="toctext" href="compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="functions.html">Julia Functions</a></li><li><a class="toctext" href="cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="subarrays.html">SubArrays</a></li><li><a class="toctext" href="isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="sysimg.html">システムイメージのビルド</a></li><li><a class="toctext" href="llvm.html">Working with LLVM</a></li><li><a class="toctext" href="stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="boundscheck.html">Bounds checking</a></li><li class="current"><a class="toctext" href="locks.html">Proper maintenance and care of multi-threading locks</a><ul class="internal"><li><a class="toctext" href="#Locks-1">Locks</a></li><li><a class="toctext" href="#Broken-Locks-1">Broken Locks</a></li><li><a class="toctext" href="#Shared-Global-Data-Structures-1">Shared Global Data Structures</a></li></ul></li><li><a class="toctext" href="offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="require.html">Module loading</a></li><li><a class="toctext" href="inference.html">Inference</a></li><li><a class="toctext" href="ssair.html">Julia SSA-form IR</a></li><li><a class="toctext" href="gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="backtraces.html">クラッシュ(セグメンテーションフォルト)の報告と分析</a></li><li><a class="toctext" href="debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li>Documentation of Julia&#39;s Internals</li><li><a href="locks.html">Proper maintenance and care of multi-threading locks</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/devdocs/locks.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Proper maintenance and care of multi-threading locks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Proper-maintenance-and-care-of-multi-threading-locks-1" href="#Proper-maintenance-and-care-of-multi-threading-locks-1">Proper maintenance and care of multi-threading locks</a></h1><p>The following strategies are used to ensure that the code is dead-lock free (generally by addressing the 4th Coffman condition: circular wait).</p><blockquote><ol><li>structure code such that only one lock will need to be acquired at a time</li><li>always acquire shared locks in the same order, as given by the table below</li><li>avoid constructs that expect to need unrestricted recursion</li></ol></blockquote><h2><a class="nav-anchor" id="Locks-1" href="#Locks-1">Locks</a></h2><p>Below are all of the locks that exist in the system and the mechanisms for using them that avoid the potential for deadlocks (no Ostrich algorithm allowed here):</p><p>The following are definitely leaf locks (level 1), and must not try to acquire any other lock:</p><blockquote><ul><li><p>safepoint</p><blockquote><p>Note that this lock is acquired implicitly by <code>JL_LOCK</code> and <code>JL_UNLOCK</code>. use the <code>_NOGC</code> variants to avoid that for level 1 locks.</p><p>While holding this lock, the code must not do any allocation or hit any safepoints. Note that there are safepoints when doing allocation, enabling / disabling GC, entering / restoring exception frames, and taking / releasing locks.</p></blockquote></li><li><p>shared_map</p></li><li><p>finalizers</p></li><li><p>pagealloc</p></li><li><p>gc<em>perm</em>lock</p></li><li><p>flisp</p><blockquote><p>flisp itself is already threadsafe, this lock only protects the <code>jl_ast_context_list_t</code> pool</p></blockquote></li></ul></blockquote><p>The following is a leaf lock (level 2), and only acquires level 1 locks (safepoint) internally:</p><blockquote><ul><li>typecache</li></ul></blockquote><p>The following is a level 2 lock:</p><blockquote><ul><li>Module-&gt;lock</li></ul></blockquote><p>The following is a level 3 lock, which can only acquire level 1 or level 2 locks internally:</p><blockquote><ul><li>Method-&gt;writelock</li></ul></blockquote><p>The following is a level 4 lock, which can only recurse to acquire level 1, 2, or 3 locks:</p><blockquote><ul><li>MethodTable-&gt;writelock</li></ul></blockquote><p>No Julia code may be called while holding a lock above this point.</p><p>The following is a level 6 lock, which can only recurse to acquire locks at lower levels:</p><blockquote><ul><li>codegen</li></ul></blockquote><p>The following is an almost root lock (level end-1), meaning only the root look may be held when trying to acquire it:</p><blockquote><ul><li><p>typeinf</p><blockquote><p>this one is perhaps one of the most tricky ones, since type-inference can be invoked from many points</p><p>currently the lock is merged with the codegen lock, since they call each other recursively</p></blockquote></li></ul></blockquote><p>The following lock synchronizes IO operation. Be aware that doing any I/O (for example, printing warning messages or debug information) while holding any other lock listed above may result in pernicious and hard-to-find deadlocks. BE VERY CAREFUL!</p><blockquote><ul><li><p>iolock</p></li><li><p>Individual ThreadSynchronizers locks</p><blockquote><p>this may continue to be held after releasing the iolock, or acquired without it, but be very careful to never attempt to acquire the iolock while holding it</p></blockquote></li></ul></blockquote><p>The following is the root lock, meaning no other lock shall be held when trying to acquire it:</p><blockquote><ul><li><p>toplevel</p><blockquote><p>this should be held while attempting a top-level action (such as making a new type or defining a new method): trying to obtain this lock inside a staged function will cause a deadlock condition!</p><p>additionally, it&#39;s unclear if <em>any</em> code can safely run in parallel with an arbitrary toplevel expression, so it may require all threads to get to a safepoint first</p></blockquote></li></ul></blockquote><h2><a class="nav-anchor" id="Broken-Locks-1" href="#Broken-Locks-1">Broken Locks</a></h2><p>The following locks are broken:</p><ul><li><p>toplevel</p><blockquote><p>doesn&#39;t exist right now</p><p>fix: create it</p></blockquote></li></ul><h2><a class="nav-anchor" id="Shared-Global-Data-Structures-1" href="#Shared-Global-Data-Structures-1">Shared Global Data Structures</a></h2><p>These data structures each need locks due to being shared mutable global state. It is the inverse list for the above lock priority list. This list does not include level 1 leaf resources due to their simplicity.</p><p>MethodTable modifications (def, cache, kwsorter type) : MethodTable-&gt;writelock</p><p>Type declarations : toplevel lock</p><p>Type application : typecache lock</p><p>Global variable tables : Module-&gt;lock</p><p>Module serializer : toplevel lock</p><p>JIT &amp; type-inference : codegen lock</p><p>MethodInstance/CodeInstance updates : Method-&gt;writelock, codegen lock</p><blockquote><ul><li>These are set at construction and immutable:<ul><li>specTypes</li><li>sparam_vals</li><li>def</li></ul></li></ul></blockquote><blockquote><ul><li>These are set by <code>jl_type_infer</code> (while holding codegen lock):<ul><li>cache</li><li>rettype</li><li>inferred</li></ul></li></ul></blockquote><pre><code class="language-none">    * valid ages</code></pre><blockquote><ul><li><code>inInference</code> flag:<ul><li>optimization to quickly avoid recurring into <code>jl_type_infer</code> while it is already running</li><li>actual state (of setting <code>inferred</code>, then <code>fptr</code>) is protected by codegen lock</li></ul></li></ul></blockquote><blockquote><ul><li><p>Function pointers:</p><ul><li>these transition once, from <code>NULL</code> to a value, while the codegen lock is held</li></ul></li><li><p>Code-generator cache (the contents of <code>functionObjectsDecls</code>):</p><ul><li>these can transition multiple times, but only while the codegen lock is held</li><li>it is valid to use old version of this, or block for new versions of this, so races are benign, as long as the code is careful not to reference other data in the method instance (such as <code>rettype</code>) and assume it is coordinated, unless also holding the codegen lock</li></ul></li></ul></blockquote><p>LLVMContext : codegen lock</p><p>Method : Method-&gt;writelock</p><ul><li>roots array (serializer and codegen)</li><li>invoke / specializations / tfunc modifications</li></ul><footer><hr/><a class="previous" href="boundscheck.html"><span class="direction">Previous</span><span class="title">Bounds checking</span></a><a class="next" href="offset-arrays.html"><span class="direction">Next</span><span class="title">Arrays with custom indices</span></a></footer></article></body></html>
