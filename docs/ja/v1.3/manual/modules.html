<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>モジュール · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">はじめよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li class="current"><a class="toctext" href="modules.html">モジュール</a><ul class="internal"><li><a class="toctext" href="#モジュールの使用法のまとめ-1">モジュールの使用法のまとめ</a></li></ul></li><li><a class="toctext" href="documentation.html">ドキュメンテーション</a></li><li><a class="toctext" href="metaprogramming.html">メタプログラミング</a></li><li><a class="toctext" href="arrays.html">多次元配列</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">ネットワークとストリーム</a></li><li><a class="toctext" href="parallel-computing.html">並列コンピューティング</a></li><li><a class="toctext" href="running-external-programs.html">外部プログラムの実行</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">C, Fortran コードの呼び出し</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Julia の埋め込み</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">プロファイリング</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">パフォーマンス・ティップス</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">スタイルガイド</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">他の言語との注目すべき違い</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/Future.html">Future</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">リフレクションとインストロスペクション</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Julia ランタイムの初期化</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">システムイメージのビルド</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li><li><a class="toctext" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="toctext" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">クラッシュ(セグメンテーションフォルト)の報告と分析</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="modules.html">モジュール</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/modules.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>モジュール</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="modules-1" href="#modules-1">モジュール</a></h1><p>Julia のモジュールは独立した変数のワークスペースであり、新しいグローバル スコープを導入します。モジュールは、<code>module Name ... end</code> で構文的に区切られています。 モジュールを使用すると、(グローバル変数として知られる)最上位の定義を行うことができて、かつ、自分のコードと他のユーザーのコードとを一緒に使用する際に名前の競合を心配しなくてすみます。モジュール内では、他のモジュールから参照する名前を (インポートして) 制御し、自分のモジュール内のどの名前を(エクスポートで) パブリックにするかを指定することができます。</p><p>次の例は、モジュールの主な機能を示しています。これは説明用のためのもので、実際に実行するために書かれたコードではありません:</p><pre><code class="language-julia">module MyModule
using Lib

using BigLib: thing1, thing2

import Base.show

export MyType, foo

struct MyType
    x
end

bar(x) = 2x
foo(a::MyType) = bar(a.x) + 1

show(io::IO, a::MyType) = print(io, &quot;MyType $(a.x)&quot;)
end</code></pre><p>表記スタイル上の注意点は、モジュールの本体をインデントしないということでしょう。インデントするとなると、通常はファイル全体がインデントされることになってしまいます。</p><p>このモジュールでは、型 <code>MyType</code> と 2 つの関数を定義されています。関数 <code>foo</code> と型 <code>MyType</code> がエクスポートされ、他のモジュールへのインポートに使用できるようになります。 関数 <code>bar</code> は <code>MyModule</code> 内でのみ使用するプライベートな関数です。</p><p><code>using Lib</code>と宣言することで、必要に応じて <code>Lib</code> というモジュールを使用して名前を解決します。現在のモジュールに定義がないグローバル変数が検出されると、システムは<code>Lib</code> によってエクスポートされた変数の中からその変数を検索し、そこに見つかった場合はインポートします。 つまり、現在のモジュール内でグローバル変数を使うと全て<code>Lib</code> 内の同名の変数定義によって解決されることを意味します。</p><p><code>using BigLib: thing1, thing2</code> とう宣言で、<code>thing1</code> と <code>thing2</code> という識別子が <code>BigLib</code> から現在のスコープに持ち込まれる。もしそれらの名前が、関数を参照するものならば、メソッドの追加は許されません(メソッドを使用するだけで、拡張は許されない)。</p><p><a href="manual/@ref "><code>import</code></a> キーワードは <a href="manual/@ref "><code>using</code></a> と同じ構文をサポートします。<code>using</code>のようにモジュール全体を検索対象に追加することはできません。<code>import</code> を使用してインポートされた関数は新しいメソッドで拡張できるという点で、<code>using</code> とは異なります。</p><p>上記の<code>MyModule</code>では、標準の<a href="manual/@ref "><code>show</code></a>関数にメソッドを追加したかったので、<code>import Base.show</code>と書く必要が有りました。名前が <code>using</code> を介してのみ参照できる関数は拡張できません。</p><p><code>using</code> または <code>import</code> を使用して変数が一度参照されると、その変数と同じ名前を持つ変数を、モジュール内に独自に定義することはできなくなります。インポートされた変数は読み取り専用です。グローバル変数に代入は、常に現在のモジュールが所有する変数に対するものです。そうでなければエラーが発生します。</p><h2><a class="nav-anchor" id="モジュールの使用法のまとめ-1" href="#モジュールの使用法のまとめ-1">モジュールの使用法のまとめ</a></h2><p>モジュールを読み込むには、<code>using</code> と <code>import</code> の2つの主要キーワードが利用できます。両者の違いを理解するには、次の例を考えてください:</p><pre><code class="language-julia">module MyModule

export x, y

x() = &quot;x&quot;
y() = &quot;y&quot;
p() = &quot;p&quot;

end</code></pre><p>このモジュールは、関数 <code>x</code> と 関数 <code>y</code> を(キーワード <code>export</code>を用いて) エクスポートし、それとは別にエクスポートされていない関数 <code>p</code> も定義されています。モジュールとその内部関数を現在のワークスペースにロードするには、いくつかの異なる方法があります:</p><table><tr><th style="text-align: left">インポートするコマンド</th><th style="text-align: left">スコープに導入されるもの</th><th style="text-align: left">メソッド拡張に利用できるもの</th></tr><tr><td style="text-align: left"><code>using MyModule</code></td><td style="text-align: left">All <code>export</code>ed names (<code>x</code> and <code>y</code>), <code>MyModule.x</code>, <code>MyModule.y</code> and <code>MyModule.p</code></td><td style="text-align: left"><code>MyModule.x</code>, <code>MyModule.y</code> and <code>MyModule.p</code></td></tr><tr><td style="text-align: left"><code>using MyModule: x, p</code></td><td style="text-align: left"><code>x</code> and <code>p</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>import MyModule</code></td><td style="text-align: left"><code>MyModule.x</code>, <code>MyModule.y</code> and <code>MyModule.p</code></td><td style="text-align: left"><code>MyModule.x</code>, <code>MyModule.y</code> and <code>MyModule.p</code></td></tr><tr><td style="text-align: left"><code>import MyModule.x, MyModule.p</code></td><td style="text-align: left"><code>x</code> and <code>p</code></td><td style="text-align: left"><code>x</code> and <code>p</code></td></tr><tr><td style="text-align: left"><code>import MyModule: x, p</code></td><td style="text-align: left"><code>x</code> and <code>p</code></td><td style="text-align: left"><code>x</code> and <code>p</code></td></tr></table><h3><a class="nav-anchor" id="モジュールとファイル-1" href="#モジュールとファイル-1">モジュールとファイル</a></h3><p>ファイルとファイル名は、ほとんどモジュールとは無関係です。モジュールはモジュール式にのみ関連付けられています。1 つのモジュールが複数のファイルをまたぐこともできますし、複数のモジュールを同じ1つのファイルに定義することもできます:</p><pre><code class="language-julia">module Foo

include(&quot;file1.jl&quot;)
include(&quot;file2.jl&quot;)

end</code></pre><p>異なるモジュールに同じコードを含めると、mixin のような動作が提供されます。これを使用して、異なる基本定義で同じコードを実行できます。例えば、それを実行することである処理を「安全バージョン」実行してコードを検査することができます:</p><pre><code class="language-julia">module Normal
include(&quot;mycode.jl&quot;)
end

module Testing
include(&quot;safe_operators.jl&quot;)
include(&quot;mycode.jl&quot;)
end</code></pre><h3><a class="nav-anchor" id="標準モジュール-1" href="#標準モジュール-1">標準モジュール</a></h3><p>There are three important standard modules: * <a href="../base/base.html#Core"><code>Core</code></a> contains all functionality &quot;built into&quot; the language.  * <a href="../base/base.html#Base"><code>Base</code></a> contains basic functionality that is useful in almost all cases.  * <a href="../base/base.html#Main"><code>Main</code></a> is the top-level module and the current module, when Julia is started.</p><h3><a class="nav-anchor" id="デフォルトの最上位定義とベアモジュール-1" href="#デフォルトの最上位定義とベアモジュール-1">デフォルトの最上位定義とベアモジュール</a></h3><p><code>using Base</code>に加えて、モジュールには <a href="manual/@ref "><code>eval</code></a>関数と <a href="manual/@ref "><code>include</code></a> 関数の定義も自動的に含まれ、そのモジュールのグローバルスコープ内の式やファイルを評価します。</p><p>これらのデフォルトの定義が不要な場合は、代わりにキーワード <code>baremodule</code> を使用してモジュールを定義できます (注: <code>baremodule</code>キーワードを使っても <code>Core</code> はインポートされます)。<code>baremodule</code> の使用、という観点から、標準的なモジュールの動作を見てみると:</p><pre><code class="language-none">baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
include(p) = Base.include(Mod, p)

...

end</code></pre><h3><a class="nav-anchor" id="相対モジュールパスと絶対モジュールパス-1" href="#相対モジュールパスと絶対モジュールパス-1">相対モジュールパスと絶対モジュールパス</a></h3><p><code>using Foo</code> 文を記述されていると、システムは最上位モジュールの内部テーブルを参照して <code>Foo</code> という名前のモジュールを探します。モジュールが存在しない場合、システムは <code>require(:Foo)</code> を試み、通常はインストールされたパッケージからコードを読み込みます。</p><p>しかし、一部のモジュールにはサブモジュールが含むものがあり、最上位以外の(Mainから直接アクセスできない)モジュールにアクセスする必要がある場合があります。これを行うには 2 つの方法があります。1 つ目は、<code>using Base.Sort</code> などのように絶対パスを使用することです。2 つ目は相対パスを使用する方法で、現在のモジュールや、サブモジュールを含むモジュールから、サブモジュールのインポートを簡単におこなえます:</p><pre><code class="language-none">module Parent

module Utils
...
end

using .Utils

...
end</code></pre><p>ここではモジュール <code>Parent</code> にはサブモジュール <code>Utils</code> が含まれており、<code>Parent</code> のコードは <code>Utils</code> の内容を参照する必要があります。これは、<code>using</code> 対象のパスをピリオドから開始することによって行われます。先頭にさらにもう一つピリオドを追加すると、モジュール階層のレベルが上がります。たとえば、<code>using ..Utils</code>は<code>Parent</code>モジュール自体ではなく、またさらにその上の<code>Parent</code>モジュールを含むモジュール階層で、<code>Utils</code> を探します。</p><p>相対インポート修飾子は<code>using</code> ステートメントと <code>import</code> ステートメントでのみ有効です。</p><h3><a class="nav-anchor" id="名前空間に関する雑記-1" href="#名前空間に関する雑記-1">名前空間に関する雑記</a></h3><p>名前が修飾されている場合 (例: <code>Base.sin</code>) は、エクスポートされていない場合でもアクセスできます。 これは、多くの場合、デバッグ時に便利です。修飾名を関数名として使用してメソッドを追加することもできます。ただし、構文のあいまいさが生じるため、別のモジュールに含まれる関数で、例えば演算子<code>Base.+</code>のように関数名が記号のみで構成されるものにメソッドを追加したいときには、その関数を参照するのに <code>Base.:+</code> を使用してください。演算子が複数文字の場合は、次のように括弧で囲んでください: <code>Base.:(==)</code>.</p><p>インポートおよびエクスポート文の中で、マクロ名は<code>@</code>を付けて<code>import Mod.@mac</code>のように書かれます。他のモジュールのマクロは<code>Mod.@mac</code> または <code>@Mod.mac</code> のようにして呼び出すことができます。</p><p>構文 <code>M.x = y</code> という構文では、別のモジュールのグローバル変数に代入をすることはできません。グローバル変数の代入は常にローカルなモジュールで行われます。</p><p>変数名は、<code>global x</code> のように最上位で宣言することで、変数への代入を行うこと無く、名前を予約することができます。これにより、ロード後に初期化されるグローバル変数名の競合を防ぐことができます。</p><h3><a class="nav-anchor" id="Module-initialization-and-precompilation-1" href="#Module-initialization-and-precompilation-1">モジュールの初期化とプリコンパイル</a></h3><p>大きなモジュールの読み込みには数秒かかることがあります。モジュール内のすべてのステートメントを実行するには、多くの場合、大量のコードをコンパイルする必要があるためです。 Julia は、この時間を短縮するために、モジュールの事前コンパイル済みキャッシュファイルを作成しておいて、この時間を短縮します。</p><p>インクリメンタルプリコンパイルされたモジュールファイルは、<code>import</code> や <code>using</code> が使われてモジュールがロードする際に自動的に作成されます。これにより、初めてインポートしたときに自動的にコンパイルされます。または、手動で <a href="manual/@ref "><code>Base.compilecache(Module Name)</code></a>としてコンパイルさせることもできます。得られたキャッシュファイルは、<code>DEPOT_PATH[1]/compiled/</code> に格納されます。その後、依存関係が変更されるたびに、モジュールは自動的に <code>using</code>または<code>import</code>時に再コンパイルされます。ここでいう依存関係とは、インポートするモジュール、Julia のビルド、include されｒファイル、またはモジュール ファイル内の <a href="manual/@ref "><code>include_dependency(path)</code></a> によって宣言された明示的な依存関係などのことです。</p><p>ファイルの依存関係については、依存関係の変更があったかどうかは、<code>include</code> によって読み込まれたり、<code>include_dependency</code> によって明示的に追加された各ファイルについて、その更新時刻 (mtime) が変わっていないかどうか、あるいは (1秒以下の精度でmtime をコピーできないシステムに対応するために)最も近い秒に切り捨てられた変更時間と等しいかどうかで判断されます。また、<code>require</code> の検索ロジックで選択されたファイルへのパスが、プリコンパイル ファイルを作成したパスと一致するかどうかも考慮されます。また、現在のプロセスが既に読み込んでいる一連の依存関係も考慮されます。実行中のシステムとプリコンパイル キャッシュの間に不整合が生じないように、実行中にファイルが変更されたり削除されても、それらのモジュールを再コンパイルしません。</p><p>モジュールを事前コンパイルするのが安全でないことがわかっている場合 (その理由の一例はこの後に述べますが) 、モジュール ファイル(通常はファイルの上部)に <code>__precompile__(false)</code>を記入してください。 これにより、<code>Base.compilecache</code> がエラーをスローして、<code>using</code> / <code>import</code> が現在のプロセスに直接そのモジュールを読み込み、プリコンパイルとキャッシュをスキップします。 これにより、モジュールが他のプリコンパイル済みモジュールによってインポートされるのを防ぐことができます。</p><p>モジュールのコードを書いているときには、増分共有ライブラリの作成に固有の特定の動作に注意する必要があります。たとえば、外部状態は保持されません。 これに対応するために、<em>実行時</em> に 処理される必要のある初期化ステップと、<em>コンパイル時</em>に処理してもよいステップとを明示的に分離してください。Julia では、モジュールに <code>__init__()</code>関数を定義し、ここに、実行時に処理される必要がある初期化ステップを書くことができます。この関数は(<code>--output-*</code>による)コンパイル中には呼び出されず、 コードが実行されている間に 1 回だけ実行されると想定できます。 もちろん、必要に応じて手動で呼び出すこともできますが、デフォルトでは、この関数が、処理を実行中マシンの計算状態を扱っていると想定できます。ここでいう計算状態とは、プリコンパイルイメージに含まれる必要がない</p><ul><li>むしろ含まれてはいけない ようなモノを表します。この</li></ul><p><code>__init__()</code>関数は、モジュールがプロセスにロードされたあとで、呼ばれます。これは、インクリメンタル コンパイル (<code>-output-incremental=yes</code>) でロードされる場合も該当しますが、フルコンパイルプロセスにロードされる場合は該当しません。</p><p>特に、モジュール内に<code>__init__()</code>関数を定義した場合、(例えば、<code>import</code>、<code>using</code>、<code>require</code>などを用いて)モジュールがロードされた<em>直後</em>、初めての実行時に <code>__init__()</code>関数が呼ばれます。 (つまり、モジュール内のすべての文が実行された後に<code>__init__</code> は 1 回だけ呼び出されます)。モジュールが完全にインポートされた後に呼び出されるため、サブモジュールやその他のインポートされたモジュールの <code>__init__()</code>関数はそれを囲むモジュールの<code>__init__</code>よりも <em>前に</em> 呼び出されます。</p><p><code>__init__</code> の 2 つの典型的な用途は、外部 C ライブラリのランタイム初期化関数を呼び出し、外部ライブラリによって返されるポインターを含むグローバル定数を初期化することです。 たとえば、実行時に <code>foo_init()</code> 初期化関数を呼び出す必要がある C ライブラリ <code>libfoo</code> を呼び出すとします。<code>libfoo</code> で定義された <code>void *foo_data()</code> 関数の戻り値を保持するグローバル定数 <code>foo_data_ptr</code> も定義するとします。この時、ポインタのアドレスは実行するごとに変わるため、<code>foo_data_ptr</code> は(コンパイル時ではなく)実行時に初期化する必要があります。これは、モジュール内に次のような<code>__init__</code>関数を定義すれば、実行できます:</p><pre><code class="language-julia">const foo_data_ptr = Ref{Ptr{Cvoid}}(0)
function __init__()
    ccall((:foo_init, :libfoo), Cvoid, ())
    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())
    nothing
end</code></pre><p><code>__init__</code>のような関数内でグローバルにシンボルを定義することは可能であることに注目してください。これは動的言語を使用する利点の 1 つですが、グローバルスコープで定数とすることで、コンパイラが型を認識し、より最適化されたコードを生成できるようになります。明らかに、モジュール内の他のグローバルも <code>foo_data_ptr</code> に依存するものについては、<code>__init__</code> で初期化する必要があります。</p><p><a href="manual/@ref "><code>ccall</code></a> を使わずに生成されるほとんどの Julia オブジェクトを含む定数は<code>__init__</code> に配置する必要はありません。 そういう定数の定義は、プリコンパイルでき、キャッシュされたモジュールイメージからロードすることができます。これには、配列のようにヒープを割り当てられた複雑なオブジェクトも含まれますが、生のポインター値を返すルーチンは、プリコンパイルがうまく動作するように実行時に呼び出す必要があります(<a href="manual/@ref "><code>Ptr</code></a> オブジェクトは、<a href="manual/@ref "><code>isbits</code></a> オブジェクト内に隠されていない限り、null ポインターに なります)。これには、Julia 関数 <code>cfunction</code> と <a href="manual/@ref "><code>pointer</code></a>の戻り値が含まれます。</p><p>辞書型、集合型、または一般に<code>hash(key)</code>メソッドの出力に何らか依存するものは取り扱いが厄介なケースです。key が数値、文字列、シンボル、範囲、<code>Expr</code>、またはこれらの型の複合型 (配列、タプル、集合、Pairなどを介して) である一般的なケースでは、プリコンパイルしても安全です。 ただし、いくつかのキー型、例えば <code>Function</code>、<code>DataType</code>  そして <code>hash</code>メソッドを定義していない汎用ユーザー定義の型などについは、フォールバック <code>hash</code>メソッドは、(<code>objectid</code> を介する) オブジェクトのメモリ アドレスに依存しており、実行するたびに変更されるかもしれません。これらのキータイプのいずれかを持っている場合、または安全であると確信が持てない場合は、<code>__init__</code> 関数内からこの辞書を初期化できます。あるいは、<a href="manual/@ref "><code>IdDict</code></a>辞書型を使うこともできます。これはコンパイル時に安全に初期化できるように、プリコンパイルによって特殊な処理がされます。</p><p>プリコンパイルを使用する場合は、コンパイル フェーズと実行フェーズの違いを明確に理解しておく必要があります。このモードでは、Julia がコンパイル済みコードを生成するスタンドアロンインタプリタではなく、任意の Julia コードの実行を可能にするコンパイラであることが明らかになることがよくあります。</p><p>その他既知の失敗しがちなシナリオは下記の通りです:</p><ol><li><p>グローバルカウンター(例えば、オブジェクトを一意に識別する)について、次のコードを考えてみましょう:</p><pre><code class="language-julia">mutable struct UniquedById
    myid::Int
    let counter = 0
        UniquedById() = new(counter += 1)
    end
end</code></pre><p>このコードの目的は、すべてのインスタンスに一意の ID を与えるものでしたが、コンパイルの最後にカウンタ値はが記録されます。このあとで、インクリメンタルコンパイルされたモジュールが使われるときはいつも、同じカウンタ値から起動します。</p><p><code>objectid</code> は、メモリポインタをハッシュするものですが、似たような問題があることに注意 ( 下記の <code>Dict</code> 用法参照 ) 。</p><p>もう 1 つの方法は、マクロを使用して <a href="../base/base.html#Base.@__MODULE__"><code>@__MODULE__</code></a> をキャプチャし、現在の &#39;カウンタ&#39; 値を使用して単独で格納することです。ただし、このグローバル状態に依存しないようにコードを再設計するほうがよいかもしれません。</p></li><li><p>連想コレクション (<code>Dict</code> や <code>Set</code> など) は <code>__init__</code>で再ハッシュする必要があります。(将来的には、初期化関数を登録するメカニズムが提供されるかもしれません)。</p></li><li><p>コンパイル時の副作用の影響はは実行時にも残ります。例: 他の Julia モジュールの配列またはその他の変数の内容の変更、ファイルまたはデバイスを開くためにハンドルの保持、他のシステム リソース (メモリを含む) へのポインターの格納。</p></li><li><p>ルックアップパスではなく、直接参照をすることで、別のモジュールからグローバルな状態の「コピー」を意図せず作成してしまうこと。例えば、(グローバルスコープでは):</p><pre><code class="language-julia">#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#
# instead use accessor functions:
getstdout() = Base.stdout #= best option =#
# or move the assignment into the runtime:
__init__() = global mystdout = Base.stdout #= also works =#</code></pre></li></ol><p>コードのプリコンパイル中に可能な処理には様々な制限が課されます。ユーザーが間違った状況を避けるのを支援するためです:</p><ol><li>別のモジュールで副作用を引き起こす<a href="../base/base.html#Base.MainInclude.eval"><code>eval</code></a>の呼び出し。また、インクリメンタルなプリコンパイルのフラグが設定されている時には警告が出力されます。</li><li><code>__init__()</code>が処理開始された後の ローカルスコープからの <code>global const</code> 宣言 (これに対してエラーを発生させようという計画については、issue #12010 を参照)</li><li>モジュールの置き換えは、増分プリコンパイルの実行中にランタイム エラーを引き起こします。</li></ol><p>その他の注意点は次のとおりです:</p><ol><li>ソース ファイル自体に変更が加えられた(<code>Pkg.update</code> 含む)後に 、コードの再読み込み/キャッシュの無効化は実行されません 、<code>Pkg.rm</code> の後にクリーンアップは行われません</li><li>Reshape された配列のメモリ共有動作は、プリコンパイルによって無視されます (各ビューは独自のコピーを取得します)</li><li>コンパイル時と実行時の間にファイルシステムが変更されないことを期待するもの: 例えば、<a href="../base/file.html#Base.@__FILE__"><code>@__FILE__</code></a>/<code>source_path()</code>で実行時にリソースを探すためとか、BinDeps の <code>@checked_lib</code> マクロなど。こういうことは避けられないことがあります。ただし、可能であれば、コンパイル時にリソースをモジュールにコピーしておいて、実行時にそのリソースを探す必要を無くしておくのはよいプラクティスです。</li><li><code>WeakRef</code> オブジェクトとファイナライザは、現在シリアライザーによって適切に処理されていません (これは今後のリリースで修正されます)。</li><li>通常は、シリアライザーを混乱させ、望まぬ結果を導く可能性があるため、<code>Method</code>, <code>MethodInstance</code>, <code>MethodTable</code>, <code>TypeMapLeve</code>, <code>TypeMapEntry</code> そしてこれらのオブジェクトのフィールドなどの、内部メタデータオブジェクトのインスタンスへの参照を補足しないようにすることをお考めします。参照を補足することは必ずしもエラーではありませんが、システムがこれらの一部をコピーし、単一・唯一のインスタンスを作成するようにすればよい話です。</li></ol><p>モジュールの開発中に、インクリメンタルプリコンパイルをオフにすると便利な場合があります。コマンドラインフラグ <code>--compiled-modules={yes|no}</code> を使用すると、モジュールのプリコンパイルのオンとオフを切り替うことができます。Julia が <code>--compiled-modules=no</code> で起動すると、モジュールとモジュールの依存関係を読み込むときに、コンパイル キャッシュ内のシリアル化されたモジュールは無視されます。<code>--compiled-modules=no</code>にしていても<code>Base.compilecache</code> は手動で呼び出すことができます。このコマンド ライン フラグの状態は <code>Pkg.build</code> に渡され、パッケージのインストール、更新、および明示的なビルド時に自動プリコンパイルトリガを無効にします。</p><footer><hr/><a class="previous" href="interfaces.html"><span class="direction">Previous</span><span class="title">Interfaces</span></a><a class="next" href="documentation.html"><span class="direction">Next</span><span class="title">ドキュメンテーション</span></a></footer></article></body></html>
