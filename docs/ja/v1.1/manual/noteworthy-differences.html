<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>他の言語との注目すべき違い · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">はじめよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">モジュール</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">メタプログラミング</a></li><li><a class="toctext" href="arrays.html">多次元配列</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">ネットワークとストリーム</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">C, Fortran コードの呼び出し</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Julia の埋め込み</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">パフォーマンス・ティップス</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">スタイルガイド</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li class="current"><a class="toctext" href="noteworthy-differences.html">他の言語との注目すべき違い</a><ul class="internal"><li><a class="toctext" href="#MATLAB-との注目すべき違い-1">MATLAB との注目すべき違い</a></li><li><a class="toctext" href="#R-との注目すべき違い-1">R との注目すべき違い</a></li><li><a class="toctext" href="#Python-との注目すべき違い-1">Python との注目すべき違い</a></li><li><a class="toctext" href="#Noteworthy-differences-from-C/C-1">Noteworthy differences from C/C++</a></li></ul></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">リフレクションとインストロスペクション</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li><li><a class="toctext" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="toctext" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="noteworthy-differences.html">他の言語との注目すべき違い</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/noteworthy-differences.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>他の言語との注目すべき違い</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="他の言語との注目すべき違い-1" href="#他の言語との注目すべき違い-1">他の言語との注目すべき違い</a></h1><h2><a class="nav-anchor" id="MATLAB-との注目すべき違い-1" href="#MATLAB-との注目すべき違い-1">MATLAB との注目すべき違い</a></h2><p>MATLAB ユーザーはジュリアの構文を親しみやすいと思うかもしれませんが、Juliaは MATLAB クローンではありません。構文や機能の違いは大きいです。MATLAB に慣れているJuliaユーザーがつまずきやすい注目すべき違いは次のとおりです:</p><ul><li>Julia の配列は角かっこで <code>A[i,j]</code>のようにインデックス付けされる。</li><li>Juliaでは、配列は他の変数に代入してもコピーされません。 <code>A = B</code>の後、<code>B</code>の要素を変更すると <code>A</code>も同様に変更されます</li></ul><p>  * Juliaでは、値は関数に渡されてもコピーされません。関数が配列を変更すると、その変更は呼び出し元にも影響を与えます。   * Juliaでは、代入文の中で配列のサイズが自動的に拡張されません。 MATLABでは <code>a(4)= 3.2</code>で<code>a = [0 0 0 3.2]</code>が生成され、その後<code>a(5)= 7</code>とすると<code>a = [0 0 0 3.2 7]</code>と配列のサイズが大きくなります。対して、Juliaで <code>a [5] = 7</code>とすると、<code>a</code>の長さが5より場合、もしくは、この代入式が識別子<code>a</code>を初めて使用する式である場合には、エラーが発生します。Juliaには、<a href="../base/collections.html#Base.push!"><code>push!</code></a>関数や<a href="../base/collections.html#Base.append!"><code>append!</code></a>関数があり、ベクトルのサイズを拡張する手段として、MATLABの <code>a(end + 1)= val</code>よりもはるかに効率的です。   <em>虚数単位 <code>sqrt(-1)</code>は、MATLABでは<code>i</code>や<code>j</code>が用いられますが、Juliaでは<a href="../base/numbers.html#Base.im"><code>im</code></a>と表記します。   </em> Juliaでは、小数点のない数値リテラル( <code>42</code>など)は浮動小数点ではなく整数を作成します。任意の大きな整数リテラルがサポートされています。その結果、<code>2 ^ -1</code>のようないくつかの演算は、「演算結果が整数ではない」というドメインエラーが発生します(詳細については、<a href="faq.html#faq-domain-errors-1">ドメインエラーに関するFAQ</a>を参照)。   * Juliaでは、複数の値が返され、タプルとして割り当てられます。例えば <code>(a,b) = (1,2)</code> や <code>a, b = 1, 2</code> という具合です。MATLABの <code>nargout</code>は、呼び出し側から期待される戻り値の数に基づいて選択的な処理をを行うもので、MATLABではよく使用されますが、Julia では使用できません。代わりに、ユーザーはオプション引数、キーワード引数の機能を使って、似たようなことをできます。   * Juliaは真の1次元配列を持っています。列ベクトルは、サイズが<code>N</code>で、<code>Nx1</code>ではありません。例えば、<a href="../stdlib/Random.html#Base.rand"><code>rand(N)</code></a>は1次元配列を作成します。   * Juliaでは、 <code>[x、y、z]</code>は常に <code>x</code>、<code>y</code>、 <code>z</code>を含む3要素の配列を構築します。      - 最初の( &quot;垂直方向の&quot;)次元で連結するには、<a href="../base/arrays.html#Base.vcat"><code>vcat(x, y, z)</code></a>を使うか、配列の要素をセミコロンで分割します( <code>[x; y; z]</code>)。      - 2番目の( &quot;水平方向の&quot;)次元で連結するには、<a href="../base/arrays.html#Base.hcat"><code>hcat(x, y, z)</code></a>を使うか、配列の要素をスペースで分割します( <code>[x y z]</code>)。      - ブロック行列を構築する(最初の2つの次元で連結する)には、<a href="../base/arrays.html#Base.hvcat"><code>hvcat</code></a>を使うか、スペースとセミコロンを組み合わせます( <code>[a b; c d]</code>)。   * Juliaでは、 <code>a：b</code>と<code>a：b：c</code>は <code>AbstractRange</code>オブジェクトを構成します。 MATLABのように完全なベクトルを作成するには、<a href="../base/collections.html#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a>を使用してください。しかし、一般的には <code>collect</code>を呼び出す必要はありません。 AbstractRangeオブジェクトはほとんどのケースで通常の配列のように振る舞いますが、その値を遅延計算するためより効率的です。完全な配列ではなく特殊化されたオブジェクトを作成するというこのパターンはよく使用されていて、<a href="../base/math.html#Base.range"><code>range</code></a>のような関数や、<code>enumerate</code>や、<code>zip</code> のようなイテレータでも見られます。特殊オブジェクトは、通常の配列のように使用することができます。   * Juliaの関数は、最後の式または <code>return</code>キーワードから戻り値を返します。MATLABのように、関数定義で戻り値の名前を列挙するのではありません。(詳細は<a href="functions.html#the-return-keyword-1">returnキーワード</a>を参照)。   * Juliaスクリプトには関数をいくつでも含めることができ、ファイルがロードされれば、すべての関数定義は外部から見えます。現在の作業ディレクトリの外にあるファイルからも関数定義はロードすることができます。   * Juliaでは、<a href="../base/collections.html#Base.sum"><code>sum</code></a>、<a href="../base/collections.html#Base.prod"><code>prod</code></a>、<a href="../base/math.html#Base.max"><code>max</code></a>のような簡約処理は、<code>sum(A)</code>のように単一の引数で呼び出された場合、全ての要素に対して行われます。たとえ <code>A</code>が2次元以上だったとしても、です。   * Juliaでは、<a href="../stdlib/Random.html#Base.rand"><code>rand()</code></a>のように、ゼロ引数で関数を呼び出すには括弧を使用する必要があります。   * Juliaは、文を終了するのにセミコロンを使用することを推奨していません。（対話式プロンプトでの実行を除き）式の結果が自動出力されませんので（出力を抑制したいのだとしても)コードの行末にセミコロンを使う必要はありません。<a href="../base/io-network.html#Base.println"><code>println</code></a>または<a href="../stdlib/Printf.html#Printf.@printf"><code>@printf</code></a>を使ってプリント出力することができます。   * Juliaでは、 <code>A</code>と<code>B</code>が配列の場合、 <code>A == B</code>のような論理比較演算は真偽値の配列を返しません。(要素ごとの比較結果が欲しい場合には) 代わりに<code>A.== B</code>を使用してください。<a href="../base/math.html#Base.:&lt;"><code>&lt;</code></a>や<a href="../base/math.html#Base.:&gt;"><code>&gt;</code></a>。のような他のブール演算子についても同様です。   * Juliaでは、演算子<a href="../base/math.html#Base.:&amp;"><code>&amp;</code></a>、<a href="../base/math.html#Base.:|"><code>|</code></a>、および<a href="../base/math.html#Base.xor"><code>⊻</code></a>(<a href="../base/math.html#Base.xor"><code>xor</code></a>)で、それぞれMATLABにおける <code>and</code>、<code>or</code>、および <code>xor</code>と等価なビット演算が行われます。演算の優先度は、Pythonのビット演算子に似ています(Cとは異なります)。それらはスカラーまたは要素ごとに操作でき、論理配列と組み合わせることもできますが、操作の順序の違いに注意してください: 括弧が必要な場合があります(例えば、1または2に等しい <code>A</code>の要素を選択するには、<code>(A。== 1)|(A。== 2)</code>を使用します)。   * Juliaでは、接合演算子<code>...</code> を使って<code>xs = [1,2]; f(xs...)</code>のようにして、コレクションの要素を引数として関数に渡すことができます。   * Juliaの<a href="../stdlib/LinearAlgebra.html#LinearAlgebra.svd"><code>svd</code></a>は特異値を密な対角行列ではなくベクトルとして返します。   * Juliaでは、 <code>...</code>はコード行を継続するためには使用されません。代わりに、不完全な式は自動的に、次の行へと解釈が継続します。   * JuliaとMATLABの両方で、対話式セッションでは、変数 <code>ans</code>は最後に発行された式の値に設定されますが、 Juliaでは、MATLABと異なり、Juliaコードが非インタラクティブモードで実行されるときには、 <code>ans</code>は設定されません。   * Juliaの <code>struct</code>は、MATLABの<code>class</code>とは異なり、実行時に動的なフィールドを追加をサポートしません。代わりに、<a href="../base/collections.html#Base.Dict"><code>Dict</code></a>を使ってください。   * Juliaでは各モジュールは独自のグローバルスコープ/名前空間を持ちますが、MATLABでは1つのグローバルスコープしかありません。   * MATLABでは、不要な値を削除するための慣用的な方法は、次のように論理インデックスを使用すること　で、<code>x(x&gt; 3)</code>としたり <code>x(x&gt; 3)= []</code>と<code>x</code>を上書きしたりします。対してJuliaでは、より高次の関数<a href="../base/collections.html#Base.filter"><code>filter</code></a>と<a href="../base/collections.html#Base.filter!"><code>filter!</code></a>が利用できます。MATLABのコードをそのままJuliaに書き換えた<code>x [x.&gt; 3]</code>や <code>x = x [x.&gt; 3]</code> の代わりに、<code>filter(z-&gt; z&gt; 3,x)</code>や、<code>filter!(z-&gt; z&gt; 3,x)</code>と書くことができます。 <a href="../base/collections.html#Base.filter!"><code>filter!</code></a>を使うと一時配列の使用を減らすことができます。   * セル配列のすべての要素を抽出する(つまり「間接参照する」)には、MATLABでは<code>vertcat(A {:})</code>が使われますが、Julia で同様のことを行うには、接合演算子を使って<code>vcat(A ...)</code>と書きます。</p><h2><a class="nav-anchor" id="R-との注目すべき違い-1" href="#R-との注目すべき違い-1">R との注目すべき違い</a></h2><p>One of Julia&#39;s goals is to provide an effective language for data analysis and statistical programming.  For users coming to Julia from R, these are some noteworthy differences:</p><ul><li><p>Julia&#39;s single quotes enclose characters, not strings.</p></li><li><p>Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.</p></li><li><p>In Julia, like Python but unlike R, strings can be created with triple quotes <code>&quot;&quot;&quot; ... &quot;&quot;&quot;</code>. This syntax is convenient for constructing strings that contain line breaks.</p></li><li><p>In Julia, varargs are specified using the splat operator <code>...</code>, which always follows the name of a specific variable, unlike R, for which <code>...</code> can occur in isolation.</p></li><li><p>In Julia, modulus is <code>mod(a, b)</code>, not <code>a %% b</code>. <code>%</code> in Julia is the remainder operator.</p></li><li><p>In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:</p><ul><li>In R, <code>c(1, 2, 3, 4)[c(TRUE, FALSE)]</code> is equivalent to <code>c(1, 3)</code>.</li><li>In R, <code>c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]</code> is equivalent to <code>c(1, 3)</code>.</li><li>In Julia, <code>[1, 2, 3, 4][[true, false]]</code> throws a <a href="../base/base.html#Core.BoundsError"><code>BoundsError</code></a>.</li><li>In Julia, <code>[1, 2, 3, 4][[true, false, true, false]]</code> produces <code>[1, 3]</code>.</li></ul></li><li><p>Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range.  For example, <code>c(1, 2, 3, 4) + c(1, 2)</code> is valid R but the equivalent <code>[1, 2, 3, 4] + [1, 2]</code> will throw an error in Julia.</p></li><li><p>Julia allows an optional trailing comma when that comma does not change the meaning of code. This can cause confusion among R users when indexing into arrays. For example, <code>x[1,]</code> in R would return the first row of a matrix; in Julia, however, the comma is ignored, so <code>x[1,] == x[1]</code>, and will return the first element. To extract a row, be sure to use <code>:</code>, as in <code>x[1,:]</code>.</p></li><li><p>Julia&#39;s <a href="../base/collections.html#Base.map"><code>map</code></a> takes the function first, then its arguments, unlike <code>lapply(&lt;structure&gt;, function, ...)</code> in R. Similarly Julia&#39;s equivalent of <code>apply(X, MARGIN, FUN, ...)</code> in R is <a href="../base/arrays.html#Base.mapslices"><code>mapslices</code></a> where the function is the first argument.</p></li><li><p>Multivariate apply in R, e.g. <code>mapply(choose, 11:13, 1:3)</code>, can be written as <code>broadcast(binomial, 11:13, 1:3)</code> in Julia. Equivalently Julia offers a shorter dot syntax for vectorizing functions <code>binomial.(11:13, 1:3)</code>.</p></li><li><p>Julia uses <code>end</code> to denote the end of conditional blocks, like <code>if</code>, loop blocks, like <code>while</code>/ <code>for</code>, and functions. In lieu of the one-line <code>if ( cond ) statement</code>, Julia allows statements of the form <code>if cond; statement; end</code>, <code>cond &amp;&amp; statement</code> and <code>!cond || statement</code>. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. <code>cond &amp;&amp; (x = value)</code>.</p></li><li><p>In Julia, <code>&lt;-</code>, <code>&lt;&lt;-</code> and <code>-&gt;</code> are not assignment operators.</p></li><li><p>Julia&#39;s <code>-&gt;</code> creates an anonymous function.</p></li><li><p>Julia constructs vectors using brackets. Julia&#39;s <code>[1, 2, 3]</code> is the equivalent of R&#39;s <code>c(1, 2, 3)</code>.</p></li><li><p>Julia&#39;s <a href="../base/strings.html#Base.:*-Tuple{Union{AbstractChar, AbstractString},Vararg{Union{AbstractChar, AbstractString},N} where N}"><code>*</code></a> operator can perform matrix multiplication, unlike in R. If <code>A</code> and <code>B</code> are matrices, then <code>A * B</code> denotes a matrix multiplication in Julia, equivalent to R&#39;s <code>A %*% B</code>. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write <code>A .* B</code> in Julia.</p></li><li><p>Julia performs matrix transposition using the <code>transpose</code> function and conjugated transposition using the <code>&#39;</code> operator or the <code>adjoint</code> function. Julia&#39;s <code>transpose(A)</code> is therefore equivalent to R&#39;s <code>t(A)</code>. Additionally a non-recursive transpose in Julia is provided by the <code>permutedims</code> function.</p></li><li><p>Julia does not require parentheses when writing <code>if</code> statements or <code>for</code>/<code>while</code> loops: use <code>for i in [1, 2, 3]</code> instead of <code>for (i in c(1, 2, 3))</code> and <code>if i == 1</code> instead of <code>if (i == 1)</code>.</p></li><li><p>Julia does not treat the numbers <code>0</code> and <code>1</code> as Booleans. You cannot write <code>if (1)</code> in Julia, because <code>if</code> statements accept only booleans. Instead, you can write <code>if true</code>, <code>if Bool(1)</code>, or <code>if 1==1</code>.</p></li><li><p>Julia does not provide <code>nrow</code> and <code>ncol</code>. Instead, use <code>size(M, 1)</code> for <code>nrow(M)</code> and <code>size(M, 2)</code> for <code>ncol(M)</code>.</p></li><li><p>Julia is careful to distinguish scalars, vectors and matrices.  In R, <code>1</code> and <code>c(1)</code> are the same. In Julia, they cannot be used interchangeably.</p></li><li><p>Julia&#39;s <a href="../stdlib/LinearAlgebra.html#LinearAlgebra.diag"><code>diag</code></a> and <a href="../stdlib/LinearAlgebra.html#LinearAlgebra.diagm"><code>diagm</code></a> are not like R&#39;s.</p></li><li><p>Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write <code>diag(M) = fill(1, n)</code>.</p></li><li><p>Julia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in <a href="https://pkg.julialang.org/">packages</a> under the <a href="https://github.com/JuliaStats">JuliaStats organization</a>. For example:</p><ul><li>Functions pertaining to probability distributions are provided by the <a href="https://github.com/JuliaStats/Distributions.jl">Distributions package</a>.</li><li>The <a href="https://github.com/JuliaData/DataFrames.jl">DataFrames package</a> provides data frames.</li><li>Generalized linear models are provided by the <a href="https://github.com/JuliaStats/GLM.jl">GLM package</a>.</li></ul></li><li><p>Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple or a named tuple: instead of <code>list(a = 1, b = 2)</code>, use <code>(1, 2)</code> or <code>(a=1, b=2)</code>.</p></li><li><p>Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia&#39;s multiple dispatch system means that <code>table(x::TypeA)</code> and <code>table(x::TypeB)</code> act like R&#39;s <code>table.TypeA(x)</code> and <code>table.TypeB(x)</code>.</p></li><li><p>In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</p></li><li><p>In Julia, vectors and matrices are concatenated using <a href="../base/arrays.html#Base.hcat"><code>hcat</code></a>, <a href="../base/arrays.html#Base.vcat"><code>vcat</code></a> and <a href="../base/arrays.html#Base.hvcat"><code>hvcat</code></a>, not <code>c</code>, <code>rbind</code> and <code>cbind</code> like in R.</p></li><li><p>In Julia, a range like <code>a:b</code> is not shorthand for a vector like in R, but is a specialized <code>AbstractRange</code> object that is used for iteration without high memory overhead. To convert a range into a vector, use <a href="../base/collections.html#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a>.</p></li><li><p>Julia&#39;s <a href="../base/math.html#Base.max"><code>max</code></a> and <a href="../base/math.html#Base.min"><code>min</code></a> are the equivalent of <code>pmax</code> and <code>pmin</code> respectively in R, but both arguments need to have the same dimensions.  While <a href="../base/collections.html#Base.maximum"><code>maximum</code></a> and <a href="../base/collections.html#Base.minimum"><code>minimum</code></a> replace <code>max</code> and <code>min</code> in R, there are important differences.</p></li><li><p>Julia&#39;s <a href="../base/collections.html#Base.sum"><code>sum</code></a>, <a href="../base/collections.html#Base.prod"><code>prod</code></a>, <a href="../base/collections.html#Base.maximum"><code>maximum</code></a>, and <a href="../base/collections.html#Base.minimum"><code>minimum</code></a> are different from their counterparts in R. They all accept an optional keyword argument <code>dims</code>, which indicates the dimensions, over which the operation is carried out.  For instance, let <code>A = [1 2; 3 4]</code> in Julia and <code>B &lt;- rbind(c(1,2),c(3,4))</code> be the same matrix in R.  Then <code>sum(A)</code> gives the same result as <code>sum(B)</code>, but <code>sum(A, dims=1)</code> is a row vector containing the sum over each column and <code>sum(A, dims=2)</code> is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate <code>colSums(B)</code> and <code>rowSums(B)</code> functions provide these functionalities. If the <code>dims</code> keyword argument is a vector, then it specifies all the dimensions over which the sum is performed, while retaining the dimensions of the summed array, e.g. <code>sum(A, dims=(1,2)) == hcat(10)</code>. It should be noted that there is no error checking regarding the second argument.</p></li><li><p>Julia has several functions that can mutate their arguments. For example, it has both <a href="../base/sort.html#Base.sort"><code>sort</code></a> and <a href="../base/sort.html#Base.sort!"><code>sort!</code></a>.</p></li><li><p>In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</p></li><li><p>Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.</p></li><li><p>Julia does not support the <code>NULL</code> type. The closest equivalent is <a href="../base/constants.html#Core.nothing"><code>nothing</code></a>, but it behaves like a scalar value rather than like a list. Use <code>x === nothing</code> instead of <code>is.null(x)</code>.</p></li><li><p>In Julia, missing values are represented by the <a href="../base/base.html#Base.missing"><code>missing</code></a> object rather than by <code>NA</code>. Use <a href="../base/base.html#Base.ismissing"><code>ismissing(x)</code></a> (or <code>ismissing.(x)</code> for element-wise operation on vectors) instead of <code>is.na(x)</code>. The <a href="../base/base.html#Base.skipmissing"><code>skipmissing</code></a> function is generally used instead of <code>na.rm=TRUE</code> (though in some particular cases functions take a <code>skipmissing</code> argument).</p></li><li><p>Julia lacks the equivalent of R&#39;s <code>assign</code> or <code>get</code>.</p></li><li><p>In Julia, <code>return</code> does not require parentheses.</p></li><li><p>In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression <code>x[x&gt;3]</code> or in the statement <code>x = x[x&gt;3]</code> to modify <code>x</code> in-place. In contrast, Julia provides the higher order functions <a href="../base/collections.html#Base.filter"><code>filter</code></a> and <a href="../base/collections.html#Base.filter!"><code>filter!</code></a>, allowing users to write <code>filter(z-&gt;z&gt;3, x)</code> and <code>filter!(z-&gt;z&gt;3, x)</code> as alternatives to the corresponding transliterations <code>x[x.&gt;3]</code> and <code>x = x[x.&gt;3]</code>. Using <a href="../base/collections.html#Base.filter!"><code>filter!</code></a> reduces the use of temporary arrays.</p></li></ul><h2><a class="nav-anchor" id="Python-との注目すべき違い-1" href="#Python-との注目すべき違い-1">Python との注目すべき違い</a></h2><ul><li>Julia requires <code>end</code> to end a block. Unlike Python, Julia has no <code>pass</code> keyword.</li><li>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</li><li>Julia&#39;s slice indexing includes the last element, unlike in Python. <code>a[2:3]</code> in Julia is <code>a[1:3]</code> in Python.</li><li>Julia does not support negative indices. In particular, the last element of a list or array is indexed with <code>end</code> in Julia, not <code>-1</code> as in Python.</li><li>Julia&#39;s <code>for</code>, <code>if</code>, <code>while</code>, etc. blocks are terminated by the <code>end</code> keyword. Indentation level is not significant as it is in Python.</li><li>Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.</li><li>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered)  by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see relevant section of <a href="performance-tips.html#man-performance-tips-1">Performance Tips</a>).</li><li>Julia&#39;s updating operators (e.g. <code>+=</code>, <code>-=</code>, ...) are <em>not in-place</em> whereas NumPy&#39;s are. This means <code>A = [1, 1]; B = A; B += [3, 3]</code> doesn&#39;t change values in <code>A</code>, it rather rebinds the name <code>B</code> to the result of the right-hand side <code>B = B + 3</code>, which is a new array. For in-place operation, use <code>B .+= 3</code> (see also <a href="mathematical-operations.html#man-dot-operators-1">dot operators</a>), explicit loops, or <code>InplaceOps.jl</code>.</li><li>Julia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are evaluated only once when the function is defined. For example, the function <code>f(x=rand()) = x</code> returns a new random number every time it is invoked without argument.  On the other hand, the function <code>g(x=[1,2]) = push!(x,3)</code> returns <code>[1,2,3]</code> every time it is called as <code>g()</code>.</li><li>In Julia <code>%</code> is the remainder operator, whereas in Python it is the modulus.</li></ul><h2><a class="nav-anchor" id="Noteworthy-differences-from-C/C-1" href="#Noteworthy-differences-from-C/C-1">Noteworthy differences from C/C++</a></h2><ul><li>Julia arrays are indexed with square brackets, and can have more than one dimension <code>A[i,j]</code>.  This syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. See the Julia documentation for the syntax for array construction (it has changed between versions).</li><li>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</li><li>Julia arrays are not copied when assigned to another variable. After <code>A = B</code>, changing elements of <code>B</code> will modify <code>A</code> as well. Updating operators like <code>+=</code> do not operate in-place, they are equivalent to <code>A = A + B</code> which rebinds the left-hand side to the result of the right-hand side expression.</li><li>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see relevant section of <a href="performance-tips.html#man-performance-tips-1">Performance Tips</a>).</li><li>Julia values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller.</li><li>In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.</li><li>In Julia, literal numbers without a decimal point (such as <code>42</code>) create signed integers, of type <code>Int</code>, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as <code>Int64</code> (if <code>Int</code> is <code>Int32</code>), <code>Int128</code>, or the arbitrarily large <code>BigInt</code> type. There are no numeric literal suffixes, such as <code>L</code>, <code>LL</code>, <code>U</code>, <code>UL</code>, <code>ULL</code> to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with <code>0x</code> like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the <em>length</em> of the literal, including leading 0s. For example, <code>0x0</code> and <code>0x00</code> have type <a href="../base/numbers.html#Core.UInt8"><code>UInt8</code></a>, <code>0x000</code> and <code>0x0000</code> have type <a href="../base/numbers.html#Core.UInt16"><code>UInt16</code></a>, then literals with 5 to 8 hex digits have type <code>UInt32</code>, 9 to 16 hex digits type <code>UInt64</code> and 17 to 32 hex digits type <code>UInt128</code>. This needs to be taken into account when defining hexadecimal masks, for example <code>~0xf == 0xf0</code> is very different from <code>~0x000f == 0xfff0</code>. 64 bit <code>Float64</code> and 32 bit <a href="../base/numbers.html#Core.Float32"><code>Float32</code></a> bit literals are expressed as <code>1.0</code> and <code>1.0f0</code> respectively. Floating point literals are rounded (and not promoted to the <code>BigFloat</code> type) if they can not be exactly represented.  Floating point literals are closer in behavior to C/C++. Octal (prefixed with <code>0o</code>) and binary (prefixed with <code>0b</code>) literals are also treated as unsigned.</li><li>String literals can be delimited with either <code>&quot;</code>  or <code>&quot;&quot;&quot;</code>, <code>&quot;&quot;&quot;</code> delimited literals can contain <code>&quot;</code> characters without quoting it like <code>&quot;\&quot;&quot;</code>. String literals can have values of other variables or expressions interpolated into them, indicated by <code>$variablename</code> or <code>$(expression)</code>, which evaluates the variable name or the expression in the context of the function.</li><li><code>//</code> indicates a <a href="../base/numbers.html#Base.Rational"><code>Rational</code></a> number, and not a single-line comment (which is <code>#</code> in Julia)</li><li><code>#=</code> indicates the start of a multiline comment, and <code>=#</code> ends it.</li><li>Functions in Julia return values from their last expression(s) or the <code>return</code> keyword.  Multiple values can be returned from functions and assigned as tuples, e.g. <code>(a, b) = myfunction()</code> or <code>a, b = myfunction()</code>, instead of having to pass pointers to values as one would have to do in C/C++ (i.e. <code>a = myfunction(&amp;b)</code>.</li><li>Julia does not require the use of semicolons to end statements. The results of expressions are not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to end with semicolons. <a href="../base/io-network.html#Base.println"><code>println</code></a> or <a href="../stdlib/Printf.html#Printf.@printf"><code>@printf</code></a> can be used to print specific output. In the REPL, <code>;</code> can be used to suppress output. <code>;</code> also has a different meaning within <code>[ ]</code>, something to watch out for. <code>;</code> can be used to separate expressions on a single line, but are not strictly necessary in many cases, and are more an aid to readability.</li><li>In Julia, the operator <a href="../base/math.html#Base.xor"><code>⊻</code></a> (<a href="../base/math.html#Base.xor"><code>xor</code></a>) performs the bitwise XOR operation, i.e. <a href="../base/strings.html#Base.:^-Tuple{AbstractString,Integer}"><code>^</code></a> in C/C++.  Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.</li><li>Julia&#39;s <a href="../base/strings.html#Base.:^-Tuple{AbstractString,Integer}"><code>^</code></a> is exponentiation (pow), not bitwise XOR as in C/C++ (use <a href="../base/math.html#Base.xor"><code>⊻</code></a>, or <a href="../base/math.html#Base.xor"><code>xor</code></a>, in Julia)</li><li>Julia has two right-shift operators, <code>&gt;&gt;</code> and <code>&gt;&gt;&gt;</code>.  <code>&gt;&gt;&gt;</code> performs an arithmetic shift, <code>&gt;&gt;</code> always performs a logical shift, unlike C/C++, where the meaning of <code>&gt;&gt;</code> depends on the type of the value being shifted.</li><li>Julia&#39;s <code>-&gt;</code> creates an anonymous function, it does not access a member via a pointer.</li><li>Julia does not require parentheses when writing <code>if</code> statements or <code>for</code>/<code>while</code> loops: use <code>for i in [1, 2, 3]</code> instead of <code>for (int i=1; i &lt;= 3; i++)</code> and <code>if i == 1</code> instead of <code>if (i == 1)</code>.</li><li>Julia does not treat the numbers <code>0</code> and <code>1</code> as Booleans. You cannot write <code>if (1)</code> in Julia, because <code>if</code> statements accept only booleans. Instead, you can write <code>if true</code>, <code>if Bool(1)</code>, or <code>if 1==1</code>.</li><li>Julia uses <code>end</code> to denote the end of conditional blocks, like <code>if</code>, loop blocks, like <code>while</code>/ <code>for</code>, and functions. In lieu of the one-line <code>if ( cond ) statement</code>, Julia allows statements of the form <code>if cond; statement; end</code>, <code>cond &amp;&amp; statement</code> and <code>!cond || statement</code>. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. <code>cond &amp;&amp; (x = value)</code>, because of the operator precedence.</li><li>Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.</li><li>Julia macros operate on parsed expressions, rather than the text of the program, which allows them to perform sophisticated transformations of Julia code. Macro names start with the <code>@</code> character, and have both a function-like syntax, <code>@mymacro(arg1, arg2, arg3)</code>, and a statement-like syntax, <code>@mymacro arg1 arg2 arg3</code>. The forms are interchangeable; the function-like form is particularly useful if the macro appears within another expression, and is often clearest. The statement-like form is often used to annotate blocks, as in the distributed <code>for</code> construct: <code>@distributed for i in 1:n; #= body =#; end</code>. Where the end of the macro construct may be unclear, use the function-like form.</li><li>Julia has an enumeration type, expressed using the macro <code>@enum(name, value1, value2, ...)</code> For example: <code>@enum(Fruit, banana=1, apple, pear)</code></li><li>By convention, functions that modify their arguments have a <code>!</code> at the end of the name, for example <code>push!</code>.</li><li>In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is &quot;virtual&quot; (although it&#39;s more general than that since methods are dispatched on every argument type, not only <code>this</code>, using the most-specific-declaration rule).</li></ul><footer><hr/><a class="previous" href="faq.html"><span class="direction">Previous</span><span class="title">Frequently Asked Questions</span></a><a class="next" href="unicode-input.html"><span class="direction">Next</span><span class="title">Unicode Input</span></a></footer></article></body></html>
