# Japanese translations for po package
# Copyright (C) 2019 Free Software Foundation, Inc.
# This file is distributed under the same license as the po package.
# Kyosuke Matsumoto <kyokke@gmail.com>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: po 4a\n"
"POT-Creation-Date: 2019-12-25 05:01+0000\n"
"PO-Revision-Date: 2020-01-07 11:27+0900\n"
"Last-Translator: Kyosuke Matsumoto <kyokke@gmail.com>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 2.2.4\n"
"X-Poedit-Bookmarks: 1718,4056,681,2676,2799,5446,-1,-1,-1,-1\n"

#. type: Title =
#: ext/julia/doc/src/./NEWS.md:2
#, no-wrap
msgid "Julia v1.3 Release Notes"
msgstr ""

#. type: Title -
#: ext/julia/doc/src/./NEWS.md:5
#, no-wrap
msgid "New language features"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:11
msgid "Support for Unicode 12.1.0 ([#32002](https://github.com/JuliaLang/julia/issues/32002))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:11
msgid "Methods can now be added to an abstract type ([#31916](https://github.com/JuliaLang/julia/issues/31916))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:11
msgid ""
"Support for unicode bold digits and double-struck digits 0 through 9 as valid identifiers ([#32838](https://github.com/JuliaLang/julia/"
"issues/32838))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:11
msgid ""
"Added the syntax `var\"#str#\"` for printing and parsing non-standard variable names ([#32408](https://github.com/JuliaLang/julia/"
"issues/32408))."
msgstr ""

#. type: Title -
#: ext/julia/doc/src/./NEWS.md:13
#, no-wrap
msgid "Language changes"
msgstr ""

#. type: Title -
#: ext/julia/doc/src/./NEWS.md:17
#, no-wrap
msgid "Multi-threading changes"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:29
msgid ""
"New experimental `Threads.@spawn` macro that runs a task on any available thread ([#32600](https://github.com/JuliaLang/julia/issues/32600))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:29
msgid ""
"All system-level I/O operations (e.g. files and sockets) are now thread-safe.  This does not include subtypes of `IO` that are entirely in-"
"memory, such as `IOBuffer`, although it specifically does include `BufferStream`.  ([#32309](https://github.com/JuliaLang/julia/"
"issues/32309), [#32174](https://github.com/JuliaLang/julia/issues/32174), [#31981](https://github.com/JuliaLang/julia/issues/31981), [#32421]"
"(https://github.com/JuliaLang/julia/issues/32421))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:29
msgid ""
"The global random number generator (`GLOBAL_RNG`) is now thread-safe (and thread-local) ([#32407](https://github.com/JuliaLang/julia/"
"issues/32407))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:29
msgid ""
"New `Channel(f::Function, spawn=true)` keyword argument to schedule the created Task on any available thread, matching the behavior of "
"`Threads.@spawn` ([#32872](https://github.com/JuliaLang/julia/issues/32872))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:29
msgid ""
"Simplified the `Channel` constructor, which is now easier to read and more idiomatic julia.  Use of the keyword arguments `csize` and "
"`ctype` is now discouraged ([#30855](https://github.com/JuliaLang/julia/issues/30855), [#32818](https://github.com/JuliaLang/julia/"
"issues/32818))."
msgstr ""

#. type: Title -
#: ext/julia/doc/src/./NEWS.md:31
#, no-wrap
msgid "Build system changes"
msgstr ""

#. type: Title -
#: ext/julia/doc/src/./NEWS.md:35
#, no-wrap
msgid "New library functions"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:45
msgid ""
"`findfirst`, `findlast`, `findnext` and `findprev` now accept a character as first argument to search for that character in a string passed "
"as the second argument ([#31664](https://github.com/JuliaLang/julia/issues/31664))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:45
msgid "New `findall(pattern, string)` method where `pattern` is a string or regex ([#31834](https://github.com/JuliaLang/julia/issues/31834))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:45
msgid "`count(pattern, string)` gives the number of things `findall` would match ([#32849](https://github.com/JuliaLang/julia/issues/32849))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:45
msgid ""
"`istaskfailed` is now documented and exported, like its siblings `istaskdone` and `istaskstarted` ([#32300](https://github.com/JuliaLang/"
"julia/issues/32300))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:45
msgid ""
"`RefArray` and `RefValue` objects now accept index `CartesianIndex()` in `getindex` and `setindex!` ([#32653](https://github.com/JuliaLang/"
"julia/issues/32653))"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:45
msgid ""
"Added `sincosd(x)` to simultaneously compute the sine and cosine of `x`, where `x` is in degrees ([#30134](https://github.com/JuliaLang/"
"julia/issues/30134))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:45
msgid ""
"The function `nonmissingtype`, which removes `Missing` from type unions, is now exported ([#31562](https://github.com/JuliaLang/julia/"
"issues/31562))."
msgstr ""

#. type: Title -
#: ext/julia/doc/src/./NEWS.md:47
#, no-wrap
msgid "Standard library changes"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/./NEWS.md:73
#, no-wrap
msgid ""
"* `Pkg` can now download and install binary artifacts through the `Pkg.Artifacts`\n"
"   submodule and supporting functions. ([#32918](https://github.com/JuliaLang/julia/issues/32918))\n"
"* When `wait` (or `@sync`, or `fetch`) is called on a failing `Task`, the exception is propagated as a\n"
"  `TaskFailedException` wrapping the task.\n"
"  This makes it possible to see the location of the original failure inside the task (as well as the\n"
"  location of the `wait` call, as before) ([#32814](https://github.com/JuliaLang/julia/issues/32814)).\n"
"* `Regex` can now be multiplied (`*`) and exponentiated (`^`), like strings ([#23422](https://github.com/JuliaLang/julia/issues/23422)).\n"
"* `Cmd` interpolation (``` `$(x::Cmd) a b c` ``` where) now propagates `x`'s process flags\n"
"  (environment, flags, working directory, etc) if `x` is the first interpolant and errors\n"
"  otherwise ([#24353](https://github.com/JuliaLang/julia/issues/24353)).\n"
"* Zero-dimensional arrays are now consistently preserved in the return values of mathematical\n"
"  functions that operate on the array(s) as a whole (and are not explicitly broadcasted across their elements).\n"
"  Previously, the functions  `+`, `-`, `*`, `/`, `conj`, `real` and `imag` returned the unwrapped element\n"
"  when operating over zero-dimensional arrays ([#32122](https://github.com/JuliaLang/julia/issues/32122)).\n"
"* `IPAddr` subtypes now behave like scalars when used in broadcasting ([#32133](https://github.com/JuliaLang/julia/issues/32133)).\n"
"* `Pair` is now treated as a scalar for broadcasting ([#32209](https://github.com/JuliaLang/julia/issues/32209)).\n"
"* `clamp` can now handle missing values ([#31066](https://github.com/JuliaLang/julia/issues/31066)).\n"
"* `empty` now accepts a `NamedTuple` ([#32534](https://github.com/JuliaLang/julia/issues/32534)).\n"
"* `mod` now accepts a unit range as the second argument to easily perform offset modular arithmetic to ensure the result is inside the range ([#32628](https://github.com/JuliaLang/julia/issues/32628)).\n"
"* `nothing` can now be `print`ed, and interpolated into strings etc. as the string `\"nothing\"`. It is still not permitted to be interpolated into Cmds (i.e. ``echo `$(nothing)` `` will still error without running anything.) ([#32148](https://github.com/JuliaLang/julia/issues/32148))\n"
"* When `open` is called with a function, command, and keyword argument (e.g. ```open(`ls`, read=true) do f ...```)\n"
"  it now correctly throws a `ProcessFailedException` like other similar calls ([#32193](https://github.com/JuliaLang/julia/issues/32193)).\n"
"* `mktemp` and `mktempdir` now try, by default, to remove temporary paths they create before the process exits ([#32851](https://github.com/JuliaLang/julia/issues/32851)).\n"
"* Added argument `keep` to `unescape_string` ([#27125](https://github.com/JuliaLang/julia/issues/27125)).\n"
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/./NEWS.md:74
#, no-wrap
msgid "Libdl"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:77
msgid "`dlopen()` can now be invoked in `do`-block syntax, similar to `open()`."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/./NEWS.md:78
#, no-wrap
msgid "LinearAlgebra"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:85
msgid ""
"The BLAS submodule no longer exports `dot`, which conflicts with that in LinearAlgebra ([#31838](https://github.com/JuliaLang/julia/"
"issues/31838))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:85
msgid ""
"`diagm` and `spdiagm` now accept optional `m,n` initial arguments to specify a size ([#31654](https://github.com/JuliaLang/julia/"
"issues/31654))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:85
msgid ""
"`Hessenberg` factorizations `H` now support efficient shifted solves `(H+ÂµI) \\ b` and determinants, and use a specialized tridiagonal "
"factorization for Hermitian matrices. There is also a new `UpperHessenberg` matrix type ([#31853](https://github.com/JuliaLang/julia/"
"issues/31853))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:85
msgid ""
"Added keyword argument `alg` to `svd` and `svd!` that allows one to switch between different SVD algorithms ([#31057](https://github.com/"
"JuliaLang/julia/issues/31057))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:85
msgid ""
"Five-argument `mul!(C, A, B, Î±, Î²)` now implements inplace multiplication fused with addition _C = A B Î± + C Î²_ ([#23919](https://github.com/"
"JuliaLang/julia/issues/23919))."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/./NEWS.md:86
#, no-wrap
msgid "SparseArrays"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:93
msgid ""
"`SparseMatrixCSC(m,n,colptr,rowval,nzval)` perform consistency checks for arguments: `colptr` must be properly populated and lengths of "
"`colptr`, `rowval`, and `nzval` must be compatible with `m`, `n`, and `eltype(colptr)`."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:93
msgid "`sparse(I, J, V, m, n)` verifies lengths of `I`, `J`, `V` are equal and compatible with `eltype(I)` and `m`, `n`."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/./NEWS.md:94 ext/julia/doc/src/stdlib/Dates.md:1
#, no-wrap
msgid "Dates"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:97
msgid ""
"`DateTime` and `Time` formatting/parsing now supports 12-hour clocks with AM/PM via `I` and `p` codes, similar to `strftime` ([#32308]"
"(https://github.com/JuliaLang/julia/issues/32308))."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/./NEWS.md:98 ext/julia/doc/src/stdlib/Statistics.md:1
#, no-wrap
msgid "Statistics"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:101
msgid "`mean` now accepts both a function argument and a `dims` keyword ([#31576](https://github.com/JuliaLang/julia/issues/31576))."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/./NEWS.md:102 ext/julia/doc/src/stdlib/Sockets.md:1
#, no-wrap
msgid "Sockets"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:107
msgid "`Sockets.recvfrom` now returns both host and port as an InetAddr ([#32729](https://github.com/JuliaLang/julia/issues/32729))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:107
msgid ""
"Added `InetAddr` constructor from `AbstractString`, representing IP address, and `Integer`, representing port number ([#31459](https://"
"github.com/JuliaLang/julia/issues/31459))."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/./NEWS.md:108
#, no-wrap
msgid "Miscellaneous"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:111
msgid ""
"`foldr` and `mapfoldr` now work on any iterator that supports `Iterators.reverse`, not just arrays ([#31781](https://github.com/JuliaLang/"
"julia/issues/31781))."
msgstr ""

#. type: Title -
#: ext/julia/doc/src/./NEWS.md:113
#, no-wrap
msgid "Deprecated or removed"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:118
msgid ""
"`@spawn expr` from the `Distributed` standard library should be replaced with `@spawnat :any expr` ([#32600](https://github.com/JuliaLang/"
"julia/issues/32600))."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:118
msgid ""
"`Threads.Mutex` and `Threads.RecursiveSpinLock` have been removed; use `ReentrantLock` (preferred) or `Threads.SpinLock` instead ([#32875]"
"(https://github.com/JuliaLang/julia/issues/32875))."
msgstr ""

#. type: Title -
#: ext/julia/doc/src/./NEWS.md:120
#, no-wrap
msgid "External dependencies"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/./NEWS.md:123
msgid "Tooling Improvements"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/./NEWS.md:128
msgid ""
"The `ClangSA.jl` static analysis package has been imported, which makes use of the clang static analyzer to validate GC invariants in "
"Julia's C code. The analysis may be run using `make -C src analyzegc`."
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/./index.md:1 ext/julia/doc/src/./index.md:23 ext/julia/doc/src/manual/getting-started.md:10
#: ext/julia/doc/src/manual/unicode-input.md:18 ext/julia/doc/src/stdlib/REPL.md:10 ext/julia/doc/src/stdlib/Pkg.md:16
#, no-wrap
msgid "@eval"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/./index.md:1
#, no-wrap
msgid ""
"io = IOBuffer()\n"
"release = isempty(VERSION.prerelease)\n"
"v = \"$(VERSION.major).$(VERSION.minor)\"\n"
"!release && (v = v*\"-$(first(VERSION.prerelease))\")\n"
"print(io, \"\"\"\n"
"    # Julia $(v) Documentation\n"
"\n"
"    Welcome to the documentation for Julia $(v).\n"
"\n"
"    \"\"\")\n"
"if !release\n"
"    print(io,\"\"\"\n"
"        !!! warning \"Work in progress!\"\n"
"            This documentation is for an unreleased, in-development, version of Julia.\n"
"        \"\"\")\n"
"end\n"
"import Markdown\n"
"Markdown.parse(String(take!(io)))\n"
msgstr ""
"io = IOBuffer()\n"
"release = isempty(VERSION.prerelease)\n"
"v = \"$(VERSION.major).$(VERSION.minor)\"\n"
"!release && (v = v*\"-$(first(VERSION.prerelease))\")\n"
"print(io, \"\"\"\n"
"    # Julia $(v)  ã®ãã­ã¥ã¡ã³ã\n"
"\n"
"    Julia $(v) ã®ãã­ã¥ã¡ã³ãã¸ããããã\n"
"\n"
"    \"\"\")\n"
"if !release\n"
"    print(io,\"\"\"\n"
"        !!! warning \"Work in progress!\"\n"
"            This documentation is for an unreleased, in-development, version of Julia.\n"
"        \"\"\")\n"
"end\n"
"import Markdown\n"
"Markdown.parse(String(take!(io)))\n"

#. type: Plain text
#: ext/julia/doc/src/./index.md:22
msgid "Please read the [release notes](NEWS.md) to see what has changed since the last release."
msgstr "ååã®ãªãªã¼ã¹ä»¥éã®å¤æ´åå®¹ã«ã¤ãã¦ã¯ã[ãªãªã¼ã¹ãã¼ã](NEWS.md)ããèª­ã¿ãã ããã"

#. type: Plain text
#: ext/julia/doc/src/./index.md:23
#, no-wrap
msgid ""
"release = isempty(VERSION.prerelease)\n"
"file = release ? \"julia-$(VERSION).pdf\" :\n"
"       \"julia-$(VERSION.major).$(VERSION.minor).$(VERSION.patch)-$(first(VERSION.prerelease)).pdf\"\n"
"url = \"https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/$(file)\"\n"
"import Markdown\n"
"Markdown.parse(\"\"\"\n"
"!!! note\n"
"    The documentation is also available in PDF format: [$file]($url).\n"
"\"\"\")\n"
msgstr ""
"release = isempty(VERSION.prerelease)\n"
"file = release ? \"julia-$(VERSION).pdf\" :\n"
"       \"julia-$(VERSION.major).$(VERSION.minor).$(VERSION.patch)-$(first(VERSION.prerelease)).pdf\"\n"
"url = \"https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/$(file)\"\n"
"import Markdown\n"
"Markdown.parse(\"\"\"\n"
"!!! note\n"
"    ãã­ã¥ã¡ã³ãã¯PDFå½¢å¼ã§å©ç¨å¯è½ã§ã: [$file]($url).\n"
"\"\"\")\n"

#. type: Title ###
#: ext/julia/doc/src/./index.md:35
#, no-wrap
msgid "[Introduction](@id man-introduction)"
msgstr "[ã¯ããã«](@id man-introduction)"

#. type: Plain text
#: ext/julia/doc/src/./index.md:45
msgid ""
"Scientific computing has traditionally required the highest performance, yet domain experts have largely moved to slower dynamic languages "
"for daily work. We believe there are many good reasons to prefer dynamic languages for these applications, and we do not expect their use to "
"diminish.  Fortunately, modern language design and compiler techniques make it possible to mostly eliminate the performance trade-off and "
"provide a single environment productive enough for prototyping and efficient enough for deploying performance-intensive applications. The "
"Julia programming language fills this role: it is a flexible dynamic language, appropriate for scientific and numerical computing, with "
"performance comparable to traditional statically-typed languages."
msgstr ""
"ç§å­¦æè¡è¨ç®ã¯ãããã¾ã§ã«æé«ã®ããã©ã¼ãã³ã¹ãæ§è½ãè¦æ±ãã¦ãã¾ãããããã®åéã®å°éå®¶ã¯æ¥ãã®ä»äºã®ããã«éåº¦ã§å£ãåçè¨èªã«ä¸»ã«ç§»è¡ã"
"ã¦ãã¾ãããæãã¯ãããã®ã¢ããªã±ã¼ã·ã§ã³ã§åçè¨èªãå¥½ã¾ããå¤ãã®çç±ãããã¨ä¿¡ãã¦ãã¾ãããåçè¨èªã®ä½¿ç¨ãæ¸å°ããã¨ãæã£ã¦ãã¾ããã"
"å¹¸ããªãã¨ã«ãç¾ä»£ã®è¨èªè¨­è¨ã¨ã³ã³ãã¤ã©æè¡ã«ãããããã©ã¼ãã³ã¹ã®ãã¬ã¼ããªããã»ã¨ãã©è§£æ¶ãããã­ãã¿ã¤ãã³ã°ã«åãçç£æ§ã¨ãããã©ã¼ã"
"ã³ã¹éè¦ã®ã¢ããªã±ã¼ã·ã§ã³ã®ããã­ã¤ã«åãæ¼ç®å¹çã¨ããåä¸ç°å¢ã§æä¾ãããã¨ãå¯è½ã§ããJuliaè¨èªã¯ããã®å½¹å²ãæããã¾ããæè»ãªåçè¨èªã§"
"ãããããã©ã¼ãã³ã¹ã¯å¾æ¥ã®éçåä»ãè¨èªã«å¹æµãç§å­¦çã»æ°å¤çãªè¨ç®ã«é©ãã¦ããã®ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/./index.md:50
msgid ""
"Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find that Julia's performance is "
"unintuitive at first. If you find that something is slow, we highly recommend reading through the [Performance Tips](@ref man-performance-"
"tips) section before trying anything else. Once you understand how Julia works, it's easy to write code that's nearly as fast as C."
msgstr ""
"Juliaã®ã³ã³ãã¤ã©ã¯PythonãRã®ãããªè¨èªã§ä½¿ããã¦ããã¤ã³ã¿ããªã¿ã¨ã¯ç°ãªãã®ã§ãJuliaã®ããã©ã¼ãã³ã¹ã¯æåã¯ç´è¦³çã§ã¯ãªããã¨ããããã¾"
"ãããã­ã°ã©ã ãéãã¨æãããå ´åã¯ãä½ããè©¦ãåã«[ããã©ã¼ãã³ã¹ã»ãã£ããã¹](@ref man-performance-tips)ã»ã¯ã·ã§ã³ãèª­ããã¨ãå¼·ããå§ãã"
"ã¾ããJuliaã®ããã¿ãçè§£ããã°ãCã¨åããããéãã³ã¼ããæ¸ãã®ã¯ç°¡åã§ãã"

#. type: Plain text
#: ext/julia/doc/src/./index.md:61
msgid ""
"Julia features optional typing, multiple dispatch, and good performance, achieved using type inference and [just-in-time (JIT) compilation]"
"(https://en.wikipedia.org/wiki/Just-in-time_compilation), implemented using [LLVM](https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine). "
"It is multi-paradigm, combining features of imperative, functional, and object-oriented programming. Julia provides ease and expressiveness "
"for high-level numerical computing, in the same way as languages such as R, MATLAB, and Python, but also supports general programming. To "
"achieve this, Julia builds upon the lineage of mathematical programming languages, but also borrows much from popular dynamic languages, "
"including [Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language)), [Perl](https://en.wikipedia.org/wiki/"
"Perl_(programming_language)), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [Lua](https://en.wikipedia.org/wiki/"
"Lua_(programming_language)), and [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language))."
msgstr ""
"Juliaã®ç¹å¾´ã«ãçç¥å¯è½ãªåä»ããå¤éãã£ã¹ããã ããã¦é«ããã©ã¼ãã³ã¹ãããã¾ãããããã¯ãåæ¨è«ã¨[ã¸ã£ã¹ãã»ã¤ã³ã»ã¿ã¤ã (JIT)ã³ã³ãã¤ã«]"
"(https://en.wikipedia.org/wiki/Just-in-time_compilation)ã«ãã£ã¦éæããã[LLVM](https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine)ã"
"ä½¿ã£ã¦å®è£ããã¦ãã¾ããJuliaã¯ãã«ããã©ãã¤ã è¨èªã§ãå½ä»¤åãé¢æ°åããªãã¸ã§ã¯ãæåãã­ã°ã©ã ã®ç¹å¾´ãä½µãæã£ã¦ãã¾ããJuliaã¯ãRã»"
"Matlabã»Pythonã¨ãã£ãè¨èªã¨åãããã«ãé«åº¦ãªæ°å¤è¨ç®åãã®ç°¡åã§é«ãè¡¨ç¾åãæä¾ãã¤ã¤ãæ±ç¨çãªãã­ã°ã©ãã³ã°ããµãã¼ããã¾ããããã¯ã"
"Juliaãæ°å­¦çãã­ã°ã©ã è¨èªã®ç³»è­ãè¸ã¾ãã¤ã¤ã[Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language)), [Perl](https://en."
"wikipedia.org/wiki/Perl_(programming_language)), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [Lua](https://en."
"wikipedia.org/wiki/Lua_(programming_language)), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language)) ãªã©äººæ°ã®åçè¨èªããå¤ã"
"ã®ã¢ã¤ãã£ã¢ããã¦ããããã§ãã"

#. type: Plain text
#: ext/julia/doc/src/./index.md:63
msgid "The most significant departures of Julia from typical dynamic languages are:"
msgstr "å¸åçãªåçè¨èªã¨Juliaã¨ã®ä¸»ãªéãã¯:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:71
msgid ""
"The core language imposes very little; Julia Base and the standard library is written in Julia itself, including primitive operations like "
"integer arithmetic"
msgstr "è¨èªã®ã³ã¢é¨åã¯æå°éã®æ©è½ããæä¾ãã¾ãããæ´æ°ã®ååæ¼ç®ã®ãããªåç­æ¼ç®ãå«ãæ¨æºã©ã¤ãã©ãªã¯Juliaèªèº«ã§æ¸ããã¦ãã¾ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:71
msgid "A rich language of types for constructing and describing objects, that can also optionally be used to make type declarations"
msgstr ""
"ãªãã¸ã§ã¯ããä½æãããèª¬æãããããã®ã«ä½¿ããã¨ãã§ãããåã«é¢ããè±å¯ãªæ©è½ãæä¾ãã¾ãããã­ã°ã©ãèªèº«ã§åãå®£è¨ãããã¨ãã§ãã¾ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:71
msgid ""
"The ability to define function behavior across many combinations of argument types via [multiple dispatch](https://en.wikipedia.org/wiki/"
"Multiple_dispatch)"
msgstr ""
"[å¤éãã£ã¹ããã](https://en.wikipedia.org/wiki/Multiple_dispatch)ã«ãã£ã¦ãã¾ãã¾ãªå¼æ°ã®çµã¿åãããã¨ã«é¢æ°ã®æ¯ãèããå®ç¾©ã§ãã¾ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:71
msgid "Automatic generation of efficient, specialized code for different argument types"
msgstr "ããããã®å¼æ°ã®åãã¨ã«æé©åãããã³ã¼ããèªåçæãã¾ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:71
msgid "Good performance, approaching that of statically-compiled languages like C"
msgstr "Cã®ãããªéçã³ã³ãã¤ã«è¨èªã«è¿«ãæ§è½ãå®ç¾ãã¾ã"

#. type: Plain text
#: ext/julia/doc/src/./index.md:79
msgid ""
"Although one sometimes speaks of dynamic languages as being \"typeless\", they are definitely not: every object, whether primitive or user-"
"defined, has a type. The lack of type declarations in most dynamic languages, however, means that one cannot instruct the compiler about the "
"types of values, and often cannot explicitly talk about types at all. In static languages, on the other hand, while one can -- and usually "
"must -- annotate types for the compiler, types exist only at compile time and cannot be manipulated or expressed at run time. In Julia, "
"types are themselves run-time objects, and can also be used to convey information to the compiler."
msgstr ""
"åçè¨èªã¯ãåããªããã¨è¨ããããã¨ãããã¾ããããããªãã¨ã¯ããã¾ãããããªããã£ãã§ããã¦ã¼ã¶ã¼å®ç¾©ã§ãããå¨ã¦ã®ãªãã¸ã§ã¯ãã¯ä½ããã®"
"åãæã¡ã¾ããå¤ãã®åçè¨èªã«ãããåå®£è¨ã®æ¬ è½ã¯ãã³ã³ãã¤ã©ã«å¯¾ãã¦å¤ã®åãä¼ããããªããã¾ãã¯åã«ã¤ãã¦ä½ãè§¦ãããã¨ãã§ããªãã¨ããã"
"ã¨ãæå³ãã¾ããä¸æ¹éçè¨èªã«ããã¦ã¯ãã³ã³ãã¤ã©ã®ããã«åæ³¨éãã¤ãããã¨ãã§ãã¾ãï¼ã»ã¼å¿é ã§ãããï¼ããåã®æå ±ã¯ã³ã³ãã¤ã«æã«ã®ã¿å­"
"å¨ããå®è¡æã«ã¯æä½ãããåå¾ããããããã¨ãã§ãã¾ãããJuliaã§ã¯ãåãã®ãã®ãå®è¡æãªãã¸ã§ã¯ãã¨ãªããåæã«ã³ã³ãã¤ã©ã«å¯¾ãã¦æå ±ãä¼ã"
"ãããã«å©ç¨ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/./index.md:87
msgid ""
"While the casual programmer need not explicitly use types or multiple dispatch, they are the core unifying features of Julia: functions are "
"defined on different combinations of argument types, and applied by dispatching to the most specific matching definition. This model is a "
"good fit for mathematical programming, where it is unnatural for the first argument to \"own\" an operation as in traditional object-"
"oriented dispatch. Operators are just functions with special notation -- to extend addition to new user-defined data types, you define new "
"methods for the `+` function.  Existing code then seamlessly applies to the new data types."
msgstr ""
"ã¡ãã£ã¨ãã­ã°ã©ã ãæ¸ãããã ããªããããããä½¿ãå¿è¦ã®ãªãåãå¤éãã£ã¹ãããã§ããã ãããã®æ¨æ¥ã¯å®ã¯Juliaã®ä¸­æ ¸ãæã£ã¦ãã¾ããé¢æ°ã¯"
"ãã¾ãã¾ãªå¼æ°ã®çµã¿åããã«å¯¾ãã¦å®ç¾©ãããå®è¡æã«ã¯æãå½ã¦ã¯ã¾ãå®ç¾©ãé©ç¨ããã¾ãã ãã®ã¢ãã«ã¯æ°å¤è¨ç®ã«ã¨ã¦ãé©ãã¦ãã¾ããå¾æ¥ã®ãªã"
"ã¸ã§ã¯ãæåãã£ã¹ãããã®ããã«ãç¬¬ä¸å¼æ°ãæ¼ç®å­ããææãããã®ã¯ä¸èªç¶ã§ããããã«å¯¾ãã¦Juliaã®æ¼ç®å­ã¯ï¼ç¹æ®ãªè¨æ³ãæã£ãï¼åãªãé¢æ°ã«"
"éãã¾ããã ã¦ã¼ã¶ã¼ãå®ç¾©ãããã¼ã¿åã«å¯¾ãã¦å ç®å¦çãè¿½å ãããå ´åã¯ã `+`ãé¢æ°ã«å¯¾ãã¦æ°ããªã¡ã½ãããå®ç¾©ãã¾ãã ãããããã¨ã§ãæ¢"
"å­ã®ã³ã¼ããã·ã¼ã ã¬ã¹ã«æ°ããªãã¼ã¿åå¯¾å¿ããããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/./index.md:94
msgid ""
"Partly because of run-time type inference (augmented by optional type annotations), and partly because of a strong focus on performance from "
"the inception of the project, Julia's computational efficiency exceeds that of other dynamic languages, and even rivals that of statically-"
"compiled languages. For large scale numerical problems, speed always has been, continues to be, and probably always will be crucial: the "
"amount of data being processed has easily kept pace with Moore's Law over the past decades."
msgstr ""
"å®è¡æåæ¨è«ï¼ä»»æã®åæ³¨éã§è£ããã¨ãã§ãã¾ãï¼ã«ãã£ã¦ãã¾ããã­ã¸ã§ã¯ãçºè¶³æããã®æ§è½ã«å¯¾ããå¼·ãæ¬²æ±ã«ãã£ã¦ãJuliaã®è¨ç®å¹çã¯ä»ã®åç"
"è¨èªãå§åããéçã³ã³ãã¤ã«è¨èªã¨ç«¶ãã¬ãã«ã«ããã¾ããå¤§è¦æ¨¡ãªæ°å¤è¨ç®åé¡ã§ã¯è¨ç®éåº¦ã¯ããã¾ã§ãããããããå¸¸ã«éå¤§ãªåé¡ã§ããå¦çãã"
"ããã¼ã¿éã¯éå»æ°åå¹´ã«ããã£ã¦ã ã¼ã¢ã®æ³åã«ãããã£ã¦å¢ãç¶ãã¦ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/./index.md:97
msgid ""
"Julia aims to create an unprecedented combination of ease-of-use, power, and efficiency in a single language. In addition to the above, some "
"advantages of Julia over comparable systems include:"
msgstr ""
"Juliaã¯ãæ±ããããã»å¼·åãã»å¹çæ§ã®åä¾ã®ãªãçµã¿åããã1ã¤ã®è¨èªã§å®ç¾ãããã¨ãã¦ãã¾ããããã«å ããJuliaãã¯ä»¥ä¸ã®ãããªé·æãæã¡ã¾"
"ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:109
msgid "Free and open source ([MIT licensed](https://github.com/JuliaLang/julia/blob/master/LICENSE.md))"
msgstr "ããªã¼ãã¤ãªã¼ãã³ã½ã¼ã¹ï¼[MITã©ã¤ã»ã³ã¹](https://github.com/JuliaLang/julia/blob/master/LICENSE.md)ï¼"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:109
msgid "User-defined types are as fast and compact as built-ins"
msgstr "ã³ã³ãã¯ãã§çµã¿è¾¼ã¿åã¨åç­ã®éåº¦ãæã¤ã¦ã¼ã¶ã¼å®ç¾©å"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:109
msgid "No need to vectorize code for performance; devectorized code is fast"
msgstr "æ§è½ã®ããã«ã³ã¼ãããã¯ãã«åããå¿è¦ãããã¾ããããã¯ãã«åããã¦ããªãã³ã¼ããé«éã«åä½ãã¾ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:109
msgid "Designed for parallelism and distributed computation"
msgstr "ä¸¦åã³ã³ãã¥ã¼ãã£ã³ã°ã»åæ£ã³ã³ãã¥ã¼ãã£ã³ã°ãæå³ããè¨­è¨"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:109
msgid "Lightweight \"green\" threading ([coroutines](https://en.wikipedia.org/wiki/Coroutine))"
msgstr "è»½éã§âgreenãªâã¹ã¬ããã·ã¹ãã ([ã³ã«ã¼ãã³]https://en.wikipedia.org/wiki/Coroutine)"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:109
msgid "Unobtrusive yet powerful type system"
msgstr "æ§ãããã¤å¼·åãªåã·ã¹ãã "

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:109
msgid "Elegant and extensible conversions and promotions for numeric and other types"
msgstr "æ°å¤åä»ã®åã®ãã¨ã¬ã¬ã³ãã§æ¡å¼µæ§ã®ããå¤æããã­ã¢ã¼ã·ã§ã³"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:109
msgid ""
"Efficient support for [Unicode](https://en.wikipedia.org/wiki/Unicode), including but not limited to [UTF-8](https://en.wikipedia.org/wiki/"
"UTF-8)"
msgstr ""
"[Unicode](https://en.wikipedia.org/wiki/Unicode) ã®å¹ççãªãµãã¼ãã[UTF-8](https://en.wikipedia.org/wiki/UTF-8) ãå«ã¿ã¾ãããããã«éå®ã"
"ã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:109
msgid "Call C functions directly (no wrappers or special APIs needed)"
msgstr "ã©ããã¼ãç¹å¥ãªAPIãå¿è¦ã¨ããªããCã®é¢æ°ã®ç´æ¥ã®å¼ã³åºã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:109
msgid "Powerful shell-like capabilities for managing other processes"
msgstr "ã·ã§ã«ã®ãããªå¼·åãªãã­ã»ã¹ç®¡ç"

#. type: Bullet: '  * '
#: ext/julia/doc/src/./index.md:109
msgid "Lisp-like macros and other metaprogramming facilities"
msgstr "Lispã©ã¤ã¯ãªãã¯ã­ããã®ä»ã®ã¡ã¿ãã­ã°ã©ãã³ã°æ©æ§"

#. type: Title #
#: ext/julia/doc/src/manual/running-external-programs.md:1
#, no-wrap
msgid "Running External Programs"
msgstr "[å¤é¨ãã­ã°ã©ã ã®å®è¡](@id Running-External-Programs)"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:5
msgid "Julia borrows backtick notation for commands from the shell, Perl, and Ruby. However, in Julia, writing"
msgstr "Julia ã¯ã shell, Perl, Ruby ã¨åãããããã¯ãã£ãã¯ (\"`...`\")è¡¨è¨ãã³ãã³ãå¼ã³åºãã«ä½¿ãã¾ããããã Julia ã§ã¯"

#. type: Code fence info string
#: ext/julia/doc/src/manual/running-external-programs.md:6 ext/julia/doc/src/manual/running-external-programs.md:25
#: ext/julia/doc/src/manual/running-external-programs.md:42 ext/julia/doc/src/manual/running-external-programs.md:52
#: ext/julia/doc/src/manual/running-external-programs.md:65 ext/julia/doc/src/manual/running-external-programs.md:81
#: ext/julia/doc/src/manual/running-external-programs.md:94 ext/julia/doc/src/manual/running-external-programs.md:108
#: ext/julia/doc/src/manual/running-external-programs.md:125 ext/julia/doc/src/manual/running-external-programs.md:138
#: ext/julia/doc/src/manual/running-external-programs.md:152 ext/julia/doc/src/manual/running-external-programs.md:171
#: ext/julia/doc/src/manual/running-external-programs.md:208 ext/julia/doc/src/manual/running-external-programs.md:238
#: ext/julia/doc/src/manual/running-external-programs.md:250 ext/julia/doc/src/manual/running-external-programs.md:287
#: ext/julia/doc/src/manual/methods.md:323 ext/julia/doc/src/manual/methods.md:356 ext/julia/doc/src/manual/methods.md:370
#: ext/julia/doc/src/manual/methods.md:465 ext/julia/doc/src/manual/methods.md:771 ext/julia/doc/src/manual/mathematical-operations.md:39
#: ext/julia/doc/src/manual/mathematical-operations.md:71 ext/julia/doc/src/manual/mathematical-operations.md:101
#: ext/julia/doc/src/manual/mathematical-operations.md:145 ext/julia/doc/src/manual/mathematical-operations.md:195
#: ext/julia/doc/src/manual/mathematical-operations.md:241 ext/julia/doc/src/manual/mathematical-operations.md:257
#: ext/julia/doc/src/manual/mathematical-operations.md:274 ext/julia/doc/src/manual/mathematical-operations.md:287
#: ext/julia/doc/src/manual/mathematical-operations.md:308 ext/julia/doc/src/manual/mathematical-operations.md:320
#: ext/julia/doc/src/manual/mathematical-operations.md:387 ext/julia/doc/src/manual/mathematical-operations.md:397
#: ext/julia/doc/src/manual/mathematical-operations.md:426 ext/julia/doc/src/manual/complex-and-rational-numbers.md:15
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:22 ext/julia/doc/src/manual/complex-and-rational-numbers.md:56
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:90 ext/julia/doc/src/manual/complex-and-rational-numbers.md:119
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:140 ext/julia/doc/src/manual/complex-and-rational-numbers.md:154
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:162 ext/julia/doc/src/manual/complex-and-rational-numbers.md:172
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:185 ext/julia/doc/src/manual/complex-and-rational-numbers.md:193
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:212 ext/julia/doc/src/manual/complex-and-rational-numbers.md:223
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:251 ext/julia/doc/src/manual/complex-and-rational-numbers.md:259
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:268 ext/julia/doc/src/manual/complex-and-rational-numbers.md:281
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:290 ext/julia/doc/src/manual/faq.md:111 ext/julia/doc/src/manual/faq.md:136
#: ext/julia/doc/src/manual/faq.md:209 ext/julia/doc/src/manual/faq.md:235 ext/julia/doc/src/manual/faq.md:262
#: ext/julia/doc/src/manual/faq.md:283 ext/julia/doc/src/manual/faq.md:312 ext/julia/doc/src/manual/faq.md:332
#: ext/julia/doc/src/manual/faq.md:350 ext/julia/doc/src/manual/faq.md:361 ext/julia/doc/src/manual/faq.md:462
#: ext/julia/doc/src/manual/faq.md:770 ext/julia/doc/src/manual/faq.md:783 ext/julia/doc/src/manual/faq.md:794
#: ext/julia/doc/src/manual/functions.md:7 ext/julia/doc/src/manual/functions.md:46 ext/julia/doc/src/manual/functions.md:81
#: ext/julia/doc/src/manual/functions.md:104 ext/julia/doc/src/manual/functions.md:131 ext/julia/doc/src/manual/functions.md:151
#: ext/julia/doc/src/manual/functions.md:163 ext/julia/doc/src/manual/functions.md:195 ext/julia/doc/src/manual/functions.md:213
#: ext/julia/doc/src/manual/functions.md:226 ext/julia/doc/src/manual/functions.md:266 ext/julia/doc/src/manual/functions.md:289
#: ext/julia/doc/src/manual/functions.md:453 ext/julia/doc/src/manual/functions.md:501 ext/julia/doc/src/manual/functions.md:693
#: ext/julia/doc/src/manual/functions.md:702 ext/julia/doc/src/manual/functions.md:715 ext/julia/doc/src/manual/functions.md:722
#: ext/julia/doc/src/manual/functions.md:729 ext/julia/doc/src/manual/functions.md:750 ext/julia/doc/src/manual/functions.md:775
#: ext/julia/doc/src/manual/functions.md:820 ext/julia/doc/src/manual/functions.md:839 ext/julia/doc/src/manual/metaprogramming.md:107
#: ext/julia/doc/src/manual/metaprogramming.md:118 ext/julia/doc/src/manual/metaprogramming.md:137
#: ext/julia/doc/src/manual/metaprogramming.md:154 ext/julia/doc/src/manual/metaprogramming.md:168
#: ext/julia/doc/src/manual/metaprogramming.md:183 ext/julia/doc/src/manual/metaprogramming.md:380
#: ext/julia/doc/src/manual/metaprogramming.md:432 ext/julia/doc/src/manual/metaprogramming.md:449
#: ext/julia/doc/src/manual/metaprogramming.md:602 ext/julia/doc/src/manual/metaprogramming.md:629
#: ext/julia/doc/src/manual/metaprogramming.md:727 ext/julia/doc/src/manual/metaprogramming.md:827
#: ext/julia/doc/src/manual/metaprogramming.md:1227 ext/julia/doc/src/manual/metaprogramming.md:1248
#: ext/julia/doc/src/manual/metaprogramming.md:1319 ext/julia/doc/src/manual/strings.md:53 ext/julia/doc/src/manual/strings.md:63
#: ext/julia/doc/src/manual/strings.md:74 ext/julia/doc/src/manual/strings.md:83 ext/julia/doc/src/manual/strings.md:99
#: ext/julia/doc/src/manual/strings.md:118 ext/julia/doc/src/manual/strings.md:140 ext/julia/doc/src/manual/strings.md:239
#: ext/julia/doc/src/manual/strings.md:535 ext/julia/doc/src/manual/strings.md:547 ext/julia/doc/src/manual/strings.md:561
#: ext/julia/doc/src/manual/strings.md:571 ext/julia/doc/src/manual/strings.md:584 ext/julia/doc/src/manual/strings.md:600
#: ext/julia/doc/src/manual/strings.md:633 ext/julia/doc/src/manual/strings.md:653 ext/julia/doc/src/manual/strings.md:670
#: ext/julia/doc/src/manual/strings.md:683 ext/julia/doc/src/manual/strings.md:698 ext/julia/doc/src/manual/strings.md:716
#: ext/julia/doc/src/manual/strings.md:756 ext/julia/doc/src/manual/strings.md:766 ext/julia/doc/src/manual/strings.md:779
#: ext/julia/doc/src/manual/strings.md:805 ext/julia/doc/src/manual/strings.md:813 ext/julia/doc/src/manual/strings.md:890
#: ext/julia/doc/src/manual/strings.md:906 ext/julia/doc/src/manual/strings.md:913 ext/julia/doc/src/manual/strings.md:954
#: ext/julia/doc/src/manual/strings.md:988 ext/julia/doc/src/manual/strings.md:1029 ext/julia/doc/src/manual/strings.md:1046
#: ext/julia/doc/src/manual/strings.md:1054 ext/julia/doc/src/manual/strings.md:1079 ext/julia/doc/src/manual/strings.md:1161
#: ext/julia/doc/src/manual/parallel-computing.md:263 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:94
#: ext/julia/doc/src/manual/missing.md:19 ext/julia/doc/src/manual/missing.md:45 ext/julia/doc/src/manual/missing.md:67
#: ext/julia/doc/src/manual/missing.md:84 ext/julia/doc/src/manual/missing.md:110 ext/julia/doc/src/manual/missing.md:127
#: ext/julia/doc/src/manual/missing.md:138 ext/julia/doc/src/manual/missing.md:159 ext/julia/doc/src/manual/missing.md:172
#: ext/julia/doc/src/manual/missing.md:196 ext/julia/doc/src/manual/missing.md:207 ext/julia/doc/src/manual/missing.md:222
#: ext/julia/doc/src/manual/missing.md:233 ext/julia/doc/src/manual/missing.md:250 ext/julia/doc/src/manual/missing.md:261
#: ext/julia/doc/src/manual/missing.md:284 ext/julia/doc/src/manual/missing.md:290 ext/julia/doc/src/manual/missing.md:358
#: ext/julia/doc/src/manual/missing.md:371 ext/julia/doc/src/manual/missing.md:381 ext/julia/doc/src/manual/variables-and-scoping.md:65
#: ext/julia/doc/src/manual/variables-and-scoping.md:108 ext/julia/doc/src/manual/variables-and-scoping.md:123
#: ext/julia/doc/src/manual/variables-and-scoping.md:136 ext/julia/doc/src/manual/variables-and-scoping.md:149
#: ext/julia/doc/src/manual/variables-and-scoping.md:162 ext/julia/doc/src/manual/variables-and-scoping.md:183
#: ext/julia/doc/src/manual/variables-and-scoping.md:208 ext/julia/doc/src/manual/variables-and-scoping.md:223
#: ext/julia/doc/src/manual/variables-and-scoping.md:247 ext/julia/doc/src/manual/variables-and-scoping.md:270
#: ext/julia/doc/src/manual/variables-and-scoping.md:297 ext/julia/doc/src/manual/variables-and-scoping.md:319
#: ext/julia/doc/src/manual/variables-and-scoping.md:343 ext/julia/doc/src/manual/variables-and-scoping.md:359
#: ext/julia/doc/src/manual/variables-and-scoping.md:378 ext/julia/doc/src/manual/variables-and-scoping.md:398
#: ext/julia/doc/src/manual/variables-and-scoping.md:418 ext/julia/doc/src/manual/variables-and-scoping.md:449
#: ext/julia/doc/src/manual/variables-and-scoping.md:466 ext/julia/doc/src/manual/variables-and-scoping.md:473
#: ext/julia/doc/src/manual/variables-and-scoping.md:495 ext/julia/doc/src/manual/variables-and-scoping.md:503
#: ext/julia/doc/src/manual/variables-and-scoping.md:512 ext/julia/doc/src/manual/variables-and-scoping.md:541
#: ext/julia/doc/src/manual/variables-and-scoping.md:558 ext/julia/doc/src/manual/variables.md:28 ext/julia/doc/src/manual/variables.md:47
#: ext/julia/doc/src/manual/variables.md:65 ext/julia/doc/src/manual/variables.md:79 ext/julia/doc/src/manual/control-flow.md:25
#: ext/julia/doc/src/manual/control-flow.md:37 ext/julia/doc/src/manual/control-flow.md:46 ext/julia/doc/src/manual/control-flow.md:75
#: ext/julia/doc/src/manual/control-flow.md:106 ext/julia/doc/src/manual/control-flow.md:151 ext/julia/doc/src/manual/control-flow.md:169
#: ext/julia/doc/src/manual/control-flow.md:199 ext/julia/doc/src/manual/control-flow.md:215 ext/julia/doc/src/manual/control-flow.md:235
#: ext/julia/doc/src/manual/control-flow.md:360 ext/julia/doc/src/manual/control-flow.md:368 ext/julia/doc/src/manual/control-flow.md:381
#: ext/julia/doc/src/manual/control-flow.md:403 ext/julia/doc/src/manual/control-flow.md:422 ext/julia/doc/src/manual/control-flow.md:443
#: ext/julia/doc/src/manual/control-flow.md:466 ext/julia/doc/src/manual/control-flow.md:500 ext/julia/doc/src/manual/control-flow.md:520
#: ext/julia/doc/src/manual/control-flow.md:536 ext/julia/doc/src/manual/control-flow.md:593 ext/julia/doc/src/manual/control-flow.md:603
#: ext/julia/doc/src/manual/control-flow.md:630 ext/julia/doc/src/manual/control-flow.md:640 ext/julia/doc/src/manual/control-flow.md:648
#: ext/julia/doc/src/manual/control-flow.md:731 ext/julia/doc/src/manual/control-flow.md:744 ext/julia/doc/src/manual/performance-tips.md:161
#: ext/julia/doc/src/manual/performance-tips.md:178 ext/julia/doc/src/manual/performance-tips.md:623
#: ext/julia/doc/src/manual/performance-tips.md:639 ext/julia/doc/src/manual/performance-tips.md:663
#: ext/julia/doc/src/manual/performance-tips.md:761 ext/julia/doc/src/manual/performance-tips.md:1338
#: ext/julia/doc/src/manual/constructors.md:127 ext/julia/doc/src/manual/constructors.md:140 ext/julia/doc/src/manual/constructors.md:264
#: ext/julia/doc/src/manual/constructors.md:523 ext/julia/doc/src/manual/constructors.md:540
#: ext/julia/doc/src/manual/networking-and-streams.md:94 ext/julia/doc/src/manual/networking-and-streams.md:105
#: ext/julia/doc/src/manual/types.md:71 ext/julia/doc/src/manual/types.md:86 ext/julia/doc/src/manual/types.md:194
#: ext/julia/doc/src/manual/types.md:389 ext/julia/doc/src/manual/types.md:466 ext/julia/doc/src/manual/types.md:485
#: ext/julia/doc/src/manual/types.md:867 ext/julia/doc/src/manual/types.md:874 ext/julia/doc/src/manual/types.md:893
#: ext/julia/doc/src/manual/types.md:921 ext/julia/doc/src/manual/types.md:930 ext/julia/doc/src/manual/types.md:947
#: ext/julia/doc/src/manual/types.md:965 ext/julia/doc/src/manual/types.md:978 ext/julia/doc/src/manual/types.md:1017
#: ext/julia/doc/src/manual/types.md:1067 ext/julia/doc/src/manual/types.md:1139 ext/julia/doc/src/manual/types.md:1151
#: ext/julia/doc/src/manual/types.md:1162 ext/julia/doc/src/manual/types.md:1175 ext/julia/doc/src/manual/arrays.md:81
#: ext/julia/doc/src/manual/arrays.md:110 ext/julia/doc/src/manual/arrays.md:132 ext/julia/doc/src/manual/arrays.md:159
#: ext/julia/doc/src/manual/arrays.md:224 ext/julia/doc/src/manual/arrays.md:240 ext/julia/doc/src/manual/arrays.md:258
#: ext/julia/doc/src/manual/arrays.md:273 ext/julia/doc/src/manual/arrays.md:303 ext/julia/doc/src/manual/arrays.md:353
#: ext/julia/doc/src/manual/arrays.md:381 ext/julia/doc/src/manual/arrays.md:443 ext/julia/doc/src/manual/arrays.md:481
#: ext/julia/doc/src/manual/arrays.md:611 ext/julia/doc/src/manual/arrays.md:710 ext/julia/doc/src/manual/arrays.md:742
#: ext/julia/doc/src/manual/arrays.md:771 ext/julia/doc/src/manual/arrays.md:876 ext/julia/doc/src/manual/conversion-and-promotion.md:56
#: ext/julia/doc/src/manual/conversion-and-promotion.md:89 ext/julia/doc/src/manual/conversion-and-promotion.md:216
#: ext/julia/doc/src/manual/conversion-and-promotion.md:273 ext/julia/doc/src/manual/conversion-and-promotion.md:318
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:51 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:105
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:115 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:156
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:187 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:198
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:226 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:255
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:281 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:294
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:305 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:322
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:332 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:343
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:369 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:409
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:429 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:446
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:469 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:534
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:554 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:580
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:707 ext/julia/doc/src/manual/style-guide.md:365
#: ext/julia/doc/src/manual/style-guide.md:381 ext/julia/doc/src/manual/style-guide.md:400 ext/julia/doc/src/base/sort.md:6
#: ext/julia/doc/src/base/sort.md:16 ext/julia/doc/src/base/sort.md:26 ext/julia/doc/src/stdlib/REPL.md:31 ext/julia/doc/src/stdlib/REPL.md:41
#: ext/julia/doc/src/stdlib/Logging.md:33 ext/julia/doc/src/stdlib/SparseArrays.md:59 ext/julia/doc/src/stdlib/SparseArrays.md:97
#: ext/julia/doc/src/stdlib/SparseArrays.md:160 ext/julia/doc/src/stdlib/SparseArrays.md:178 ext/julia/doc/src/stdlib/LinearAlgebra.md:13
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:36 ext/julia/doc/src/stdlib/LinearAlgebra.md:60 ext/julia/doc/src/stdlib/LinearAlgebra.md:84
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:116 ext/julia/doc/src/stdlib/LinearAlgebra.md:135 ext/julia/doc/src/stdlib/LinearAlgebra.md:254
#: ext/julia/doc/src/stdlib/Test.md:178 ext/julia/doc/src/stdlib/Dates.md:52 ext/julia/doc/src/stdlib/Dates.md:122
#: ext/julia/doc/src/stdlib/Dates.md:136 ext/julia/doc/src/stdlib/Dates.md:156 ext/julia/doc/src/stdlib/Dates.md:396
#: ext/julia/doc/src/stdlib/Dates.md:415 ext/julia/doc/src/stdlib/Dates.md:432 ext/julia/doc/src/stdlib/Dates.md:476
#: ext/julia/doc/src/stdlib/Dates.md:494 ext/julia/doc/src/stdlib/Dates.md:507 ext/julia/doc/src/stdlib/Dates.md:520
#: ext/julia/doc/src/stdlib/Dates.md:556 ext/julia/doc/src/stdlib/Dates.md:591 ext/julia/doc/src/stdlib/Dates.md:620
#: ext/julia/doc/src/stdlib/Dates.md:650 ext/julia/doc/src/stdlib/Dates.md:662 ext/julia/doc/src/devdocs/cartesian.md:61
#: ext/julia/doc/src/devdocs/reflection.md:96 ext/julia/doc/src/devdocs/subarrays.md:148 ext/julia/doc/src/devdocs/subarrays.md:167
#: ext/julia/doc/src/devdocs/types.md:26 ext/julia/doc/src/devdocs/types.md:90 ext/julia/doc/src/devdocs/types.md:119
#: ext/julia/doc/src/devdocs/types.md:158 ext/julia/doc/src/devdocs/types.md:231 ext/julia/doc/src/devdocs/types.md:253
#: ext/julia/doc/src/devdocs/types.md:264 ext/julia/doc/src/devdocs/types.md:275 ext/julia/doc/src/devdocs/types.md:289
#: ext/julia/doc/src/devdocs/inference.md:96
#, no-wrap
msgid "jldoctest"
msgstr "jldoctest"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:6
#, no-wrap
msgid ""
"julia> `echo hello`\n"
"`echo hello`\n"
msgstr ""
"julia> `echo hello`\n"
"`echo hello`\n"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:12
msgid "differs in several aspects from the behavior in various shells, Perl, or Ruby:"
msgstr "ã¨æ¸ãã®ã¯ãããã¤ãã®å´é¢ã§ããããããªshell, Perl, ãããã¯ Ruby ã®æ¯ãèãã¨ã¯ç°ãªãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/running-external-programs.md:22
msgid ""
"Instead of immediately running the command, backticks create a [`Cmd`](@ref) object to represent the command.  You can use this object to "
"connect the command to others via pipes, [`run`](@ref) it, and [`read`](@ref) or [`write`](@ref)  to it."
msgstr ""
"ããã¯ãã£ãã¯ã¯ãããã«ã³ãã³ããå®è¡ããã®ã§ã¯ãªããã³ãã³ããè¡¨ãã[`Cmd`](@ref ) ãªãã¸ã§ã¯ããçæãã¾ãããã®ãªãã¸ã§ã¯ããç¨ãã¦ããã®"
"ã³ãã³ãã¨ä»ã®ã³ãã³ãããã¤ãã§æ¥ç¶ãããããå®è¡ããããèª­ãã ããæ¸ãããã§ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/running-external-programs.md:22
msgid ""
"When the command is run, Julia does not capture its output unless you specifically arrange for it to. Instead, the output of the command by "
"default goes to [`stdout`](@ref) as it would using `libc`'s `system` call."
msgstr ""
"ã³ãã³ããå®è¡ããã¨ãç¹ã«ãã®ããã«æéããªãéãã¯ãJulia ã¯ãã®åºåãè£è¶³ãã¾ãããä»£ããã«ãããã©ã«ãã§ã³ãã³ãã®åºåã¯`libc`ã® "
"`system` ã§ã³ãã³ããå¼ã³åºããä½¿ç¨ããã®ã¨åæ§ã«[`stdout`](@ref)ã«åºåããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/running-external-programs.md:22
msgid ""
"The command is never run with a shell. Instead, Julia parses the command syntax directly, appropriately interpolating variables and "
"splitting on words as the shell would, respecting shell quoting syntax.  The command is run as `julia`'s immediate child process, using "
"`fork` and `exec` calls."
msgstr ""
"ã³ãã³ãã¯ã·ã§ã«ã§å®è¡ããããã¨ã¯ããã¾ãããä»£ããã«ãJulia ã¯ã³ãã³ãæ§æãç´æ¥è§£æããå¤æ°ãé©åã«å±éããã·ã§ã«ã®å¼ç¨ç¬¦æ§æãå°éãã¦ã"
"ã·ã§ã«ã®ããã«åèªãåå²ãã¾ãã ã³ãã³ãã¯ã`fork`ã¨ `exec`ã®å¼ã³åºããä½¿ç¨ãã¦ãJulia ã®ç´æ¥ã®å­ãã­ã»ã¹ã¨ãã¦å®è¡ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:24
msgid "Here's a simple example of running an external program:"
msgstr "å¤é¨ãã­ã°ã©ã ãå®è¡ããç°¡åãªä¾ãæ¬¡ã«ç¤ºãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:25
#, no-wrap
msgid ""
"julia> mycommand = `echo hello`\n"
"`echo hello`\n"
"\n"
"julia> typeof(mycommand)\n"
"Cmd\n"
"\n"
"julia> run(mycommand);\n"
"hello\n"
msgstr ""
"julia> mycommand = `echo hello`\n"
"`echo hello`\n"
"\n"
"julia> typeof(mycommand)\n"
"Cmd\n"
"\n"
"julia> run(mycommand);\n"
"hello\n"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:39
msgid ""
"The `hello` is the output of the `echo` command, sent to [`stdout`](@ref). The run method itself returns `nothing`, and throws an "
"[`ErrorException`](@ref) if the external command fails to run successfully."
msgstr ""
"`hello` ã¯ `echo` ã³ãã³ãã®åºåãã[`stdout`](@ref )ã«éããããã®ã§ããrun ã¡ã½ããããèªä½ã¯ã`nothing`ãè¿ããããå¤é¨ã³ãã³ãããã¾ãå®"
"è¡ãããªãã£ãã¨ãã«ã¯ã[`ErrorException`](@ref)ãæãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:41
msgid "If you want to read the output of the external command, [`read`](@ref) can be used instead:"
msgstr "å¤é¨ã³ãã³ãã®åºåãèª­ã¿åãå ´åã¯ãä»£ããã« [`read`](@ref) ãä½¿ç¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:42
#, no-wrap
msgid ""
"julia> a = read(`echo hello`, String)\n"
"\"hello\\n\"\n"
"\n"
"julia> chomp(a) == \"hello\"\n"
"true\n"
msgstr ""
"julia> a = read(`echo hello`, String)\n"
"\"hello\\n\"\n"
"\n"
"julia> chomp(a) == \"hello\"\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:51
msgid "More generally, you can use [`open`](@ref) to read from or write to an external command."
msgstr "ããä¸è¬çã«ã¯ã[`open`](@ref)ãä½¿ç¨ãã¦ãå¤é¨ã³ãã³ãã®èª­ã¿åãã¾ãã¯æ¸ãè¾¼ã¿ãè¡ããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:52
#, no-wrap
msgid ""
"julia> open(`less`, \"w\", stdout) do io\n"
"           for i = 1:3\n"
"               println(io, i)\n"
"           end\n"
"       end\n"
"1\n"
"2\n"
"3\n"
msgstr ""
"julia> open(`less`, \"w\", stdout) do io\n"
"           for i = 1:3\n"
"               println(io, i)\n"
"           end\n"
"       end\n"
"1\n"
"2\n"
"3\n"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:65
msgid ""
"The program name and the individual arguments in a command can be accessed and iterated over as if the command were an array of strings:"
msgstr "ã³ãã³ãåã®ãã­ã°ã©ã åã¨åãã®å¼æ°ã¯ãã³ãã³ããæå­åã®éåã§ãããã®ããã«ãã¢ã¯ã»ã¹ã»åå¾©å¦çãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:65
#, no-wrap
msgid ""
"julia> collect(`echo \"foo bar\"`)\n"
"2-element Array{String,1}:\n"
" \"echo\"\n"
" \"foo bar\"\n"
"\n"
"julia> `echo \"foo bar\"`[2]\n"
"\"foo bar\"\n"
msgstr ""
"julia> collect(`echo \"foo bar\"`)\n"
"2-element Array{String,1}:\n"
" \"echo\"\n"
" \"foo bar\"\n"
"\n"
"julia> `echo \"foo bar\"`[2]\n"
"\"foo bar\"\n"

#. type: Title ##
#: ext/julia/doc/src/manual/running-external-programs.md:75
#, no-wrap
msgid "[Interpolation](@id command-interpolation)"
msgstr "[å¼å±é](@id command-interpolation)"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:80
msgid ""
"Suppose you want to do something a bit more complicated and use the name of a file in the variable `file` as an argument to a command. You "
"can use `$` for interpolation much as you would in a string literal (see [Strings](@ref)):"
msgstr ""
"ä½ãããå°ãè¤éãªãã¨ãããããå ´åãæ³å®ãã¦ã¿ã¾ããããå¤æ° `file` ã«æ ¼ç´ããããã¡ã¤ã«åãã³ãã³ãå¼æ°ã¨ãã¦ä½¿ãããã¨ãã¾ãããã®ã°ã"
"ããæå­åãªãã©ã«ã§ãã£ãã®ã¨åãããã«`$` ãå¼å±éã«ä½¿ãäºãã§ãã¾ãã( [æå­å](@ref )åç§):"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:81
#, no-wrap
msgid ""
"julia> file = \"/etc/passwd\"\n"
"\"/etc/passwd\"\n"
"\n"
"julia> `sort $file`\n"
"`sort /etc/passwd`\n"
msgstr ""
"julia> file = \"/etc/passwd\"\n"
"\"/etc/passwd\"\n"
"\n"
"julia> `sort $file`\n"
"`sort /etc/passwd`\n"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:93
msgid ""
"A common pitfall when running external programs via a shell is that if a file name contains characters that are special to the shell, they "
"may cause undesirable behavior. Suppose, for example, rather than `/etc/passwd`, we wanted to sort the contents of the file `/Volumes/"
"External HD/data.csv`.  Let's try it:"
msgstr ""
"å¤é¨ã³ãã³ããã·ã§ã«çµç±ã§å®è¡ããã°ããã«ããé¥ãè½ã¨ãç©´ã¯ããã¡ã¤ã«åã ã·ã§ã«ã«ã¨ã£ã¦ç¹å¥ãªæå­ãå«ãå ´åã«ãæã¾ãªãæ¸å°ãããããã¨ã§"
"ããä¾ãã°ã`/etc/passwd` ã§ãªãã`/Volumes/External HD/data.csv` ã®ä¸­èº«ãã½ã¼ããããå ´åãæ³å®ãã¦ã¿ã¾ãããã£ã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:94
#, no-wrap
msgid ""
"julia> file = \"/Volumes/External HD/data.csv\"\n"
"\"/Volumes/External HD/data.csv\"\n"
"\n"
"julia> `sort $file`\n"
"`sort '/Volumes/External HD/data.csv'`\n"
msgstr ""
"julia> file = \"/Volumes/External HD/data.csv\"\n"
"\"/Volumes/External HD/data.csv\"\n"
"\n"
"julia> `sort $file`\n"
"`sort '/Volumes/External HD/data.csv'`\n"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:107
msgid ""
"How did the file name get quoted? Julia knows that `file` is meant to be interpolated as a single argument, so it quotes the word for you. "
"Actually, that is not quite accurate: the value of `file` is never interpreted by a shell, so there's no need for actual quoting; the quotes "
"are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:108
#, no-wrap
msgid ""
"julia> path = \"/Volumes/External HD\"\n"
"\"/Volumes/External HD\"\n"
"\n"
"julia> name = \"data\"\n"
"\"data\"\n"
"\n"
"julia> ext = \"csv\"\n"
"\"csv\"\n"
"\n"
"julia> `sort $path/$name.$ext`\n"
"`sort '/Volumes/External HD/data.csv'`\n"
msgstr ""
"julia> path = \"/Volumes/External HD\"\n"
"\"/Volumes/External HD\"\n"
"\n"
"julia> name = \"data\"\n"
"\"data\"\n"
"\n"
"julia> ext = \"csv\"\n"
"\"csv\"\n"
"\n"
"julia> `sort $path/$name.$ext`\n"
"`sort '/Volumes/External HD/data.csv'`\n"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:124
msgid ""
"As you can see, the space in the `path` variable is appropriately escaped. But what if you *want* to interpolate multiple words? In that "
"case, just use an array (or any other iterable container):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:125
#, no-wrap
msgid ""
"julia> files = [\"/etc/passwd\",\"/Volumes/External HD/data.csv\"]\n"
"2-element Array{String,1}:\n"
" \"/etc/passwd\"\n"
" \"/Volumes/External HD/data.csv\"\n"
"\n"
"julia> `grep foo $files`\n"
"`grep foo /etc/passwd '/Volumes/External HD/data.csv'`\n"
msgstr ""
"julia> files = [\"/etc/passwd\",\"/Volumes/External HD/data.csv\"]\n"
"2-element Array{String,1}:\n"
" \"/etc/passwd\"\n"
" \"/Volumes/External HD/data.csv\"\n"
"\n"
"julia> `grep foo $files`\n"
"`grep foo /etc/passwd '/Volumes/External HD/data.csv'`\n"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:137
msgid "If you interpolate an array as part of a shell word, Julia emulates the shell's `{a,b,c}` argument generation:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:138
#, no-wrap
msgid ""
"julia> names = [\"foo\",\"bar\",\"baz\"]\n"
"3-element Array{String,1}:\n"
" \"foo\"\n"
" \"bar\"\n"
" \"baz\"\n"
"\n"
"julia> `grep xylophone $names.txt`\n"
"`grep xylophone foo.txt bar.txt baz.txt`\n"
msgstr ""
"julia> names = [\"foo\",\"bar\",\"baz\"]\n"
"3-element Array{String,1}:\n"
" \"foo\"\n"
" \"bar\"\n"
" \"baz\"\n"
"\n"
"julia> `grep xylophone $names.txt`\n"
"`grep xylophone foo.txt bar.txt baz.txt`\n"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:151
msgid "Moreover, if you interpolate multiple arrays into the same word, the shell's Cartesian product generation behavior is emulated:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:152
#, no-wrap
msgid ""
"julia> names = [\"foo\",\"bar\",\"baz\"]\n"
"3-element Array{String,1}:\n"
" \"foo\"\n"
" \"bar\"\n"
" \"baz\"\n"
"\n"
"julia> exts = [\"aux\",\"log\"]\n"
"2-element Array{String,1}:\n"
" \"aux\"\n"
" \"log\"\n"
"\n"
"julia> `rm -f $names.$exts`\n"
"`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`\n"
msgstr ""
"julia> names = [\"foo\",\"bar\",\"baz\"]\n"
"3-element Array{String,1}:\n"
" \"foo\"\n"
" \"bar\"\n"
" \"baz\"\n"
"\n"
"julia> exts = [\"aux\",\"log\"]\n"
"2-element Array{String,1}:\n"
" \"aux\"\n"
" \"log\"\n"
"\n"
"julia> `rm -f $names.$exts`\n"
"`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`\n"

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:170
msgid ""
"Since you can interpolate literal arrays, you can use this generative functionality without needing to create temporary array objects first:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:171
#, no-wrap
msgid ""
"julia> `rm -rf $[\"foo\",\"bar\",\"baz\",\"qux\"].$[\"aux\",\"log\",\"pdf\"]`\n"
"`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`\n"
msgstr ""
"julia> `rm -rf $[\"foo\",\"bar\",\"baz\",\"qux\"].$[\"aux\",\"log\",\"pdf\"]`\n"
"`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`\n"

#. type: Title ###
#: ext/julia/doc/src/manual/running-external-programs.md:176 ext/julia/doc/src/manual/metaprogramming.md:147
#, no-wrap
msgid "Quoting"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:180
msgid ""
"Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary to use quotes. Here's a simple example of a "
"Perl one-liner at a shell prompt:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:181
#, no-wrap
msgid ""
"sh$ perl -le '$|=1; for (0..3) { print }'\n"
"0\n"
"1\n"
"2\n"
"3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:193
msgid ""
"The Perl expression needs to be in single quotes for two reasons: so that spaces don't break the expression into multiple shell words, and "
"so that uses of Perl variables like `$|` (yes, that's the name of a variable in Perl), don't cause interpolation. In other instances, you "
"may want to use double quotes so that interpolation *does* occur:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:194
#, no-wrap
msgid ""
"sh$ first=\"A\"\n"
"sh$ second=\"B\"\n"
"sh$ perl -le '$|=1; print for @ARGV' \"1: $first\" \"2: $second\"\n"
"1: A\n"
"2: B\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:207
msgid ""
"In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they "
"will work: the escaping, quoting, and interpolation behaviors are the same as the shell's. The only difference is that the interpolation is "
"integrated and aware of Julia's notion of what is a single string value, and what is a container for multiple values. Let's try the above "
"two examples in Julia:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:208
#, no-wrap
msgid ""
"julia> A = `perl -le '$|=1; for (0..3) { print }'`\n"
"`perl -le '$|=1; for (0..3) { print }'`\n"
"\n"
"julia> run(A);\n"
"0\n"
"1\n"
"2\n"
"3\n"
"\n"
"julia> first = \"A\"; second = \"B\";\n"
"\n"
"julia> B = `perl -le 'print for @ARGV' \"1: $first\" \"2: $second\"`\n"
"`perl -le 'print for @ARGV' '1: A' '2: B'`\n"
"\n"
"julia> run(B);\n"
"1: A\n"
"2: B\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:233
msgid ""
"The results are identical, and Julia's interpolation behavior mimics the shell's with some improvements due to the fact that Julia supports "
"first-class iterable objects while most shells use strings split on spaces for this, which introduces ambiguities. When trying to port shell "
"commands to Julia, try cut and pasting first. Since Julia shows commands to you before running them, you can easily and safely just examine "
"its interpretation without doing any damage."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/running-external-programs.md:234
#, no-wrap
msgid "Pipelines"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:237
#, no-wrap
msgid "Shell metacharacters, such as `|`, `&`, and `>`, need to be quoted (or escaped) inside of Julia's backticks:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:238
#, no-wrap
msgid ""
"julia> run(`echo hello '|' sort`);\n"
"hello | sort\n"
"\n"
"julia> run(`echo hello \\| sort`);\n"
"hello | sort\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:249
msgid ""
"This expression invokes the `echo` command with three words as arguments: `hello`, `|`, and `sort`.  The result is that a single line is "
"printed: `hello | sort`. How, then, does one construct a pipeline? Instead of using `'|'` inside of backticks, one uses [`pipeline`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:250
#, no-wrap
msgid ""
"julia> run(pipeline(`echo hello`, `sort`));\n"
"hello\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:258
msgid ""
"This pipes the output of the `echo` command to the `sort` command. Of course, this isn't terribly interesting since there's only one line to "
"sort, but we can certainly do much more interesting things:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/running-external-programs.md:259 ext/julia/doc/src/manual/methods.md:168 ext/julia/doc/src/manual/methods.md:198
#: ext/julia/doc/src/manual/methods.md:420 ext/julia/doc/src/manual/faq.md:490 ext/julia/doc/src/manual/faq.md:506
#: ext/julia/doc/src/manual/faq.md:541 ext/julia/doc/src/manual/faq.md:584 ext/julia/doc/src/manual/faq.md:602
#: ext/julia/doc/src/manual/faq.md:623 ext/julia/doc/src/manual/faq.md:642 ext/julia/doc/src/manual/metaprogramming.md:401
#: ext/julia/doc/src/manual/strings.md:411 ext/julia/doc/src/manual/strings.md:471 ext/julia/doc/src/manual/strings.md:966
#: ext/julia/doc/src/manual/parallel-computing.md:135 ext/julia/doc/src/manual/parallel-computing.md:145
#: ext/julia/doc/src/manual/parallel-computing.md:165 ext/julia/doc/src/manual/parallel-computing.md:229
#: ext/julia/doc/src/manual/parallel-computing.md:247 ext/julia/doc/src/manual/parallel-computing.md:254
#: ext/julia/doc/src/manual/parallel-computing.md:284 ext/julia/doc/src/manual/parallel-computing.md:293
#: ext/julia/doc/src/manual/parallel-computing.md:317 ext/julia/doc/src/manual/parallel-computing.md:348
#: ext/julia/doc/src/manual/parallel-computing.md:392 ext/julia/doc/src/manual/parallel-computing.md:431
#: ext/julia/doc/src/manual/parallel-computing.md:455 ext/julia/doc/src/manual/parallel-computing.md:585
#: ext/julia/doc/src/manual/parallel-computing.md:596 ext/julia/doc/src/manual/parallel-computing.md:645
#: ext/julia/doc/src/manual/parallel-computing.md:688 ext/julia/doc/src/manual/parallel-computing.md:699
#: ext/julia/doc/src/manual/parallel-computing.md:717 ext/julia/doc/src/manual/parallel-computing.md:747
#: ext/julia/doc/src/manual/parallel-computing.md:780 ext/julia/doc/src/manual/parallel-computing.md:792
#: ext/julia/doc/src/manual/parallel-computing.md:820 ext/julia/doc/src/manual/parallel-computing.md:861
#: ext/julia/doc/src/manual/parallel-computing.md:905 ext/julia/doc/src/manual/parallel-computing.md:992
#: ext/julia/doc/src/manual/parallel-computing.md:1057 ext/julia/doc/src/manual/parallel-computing.md:1157
#: ext/julia/doc/src/manual/parallel-computing.md:1207 ext/julia/doc/src/manual/parallel-computing.md:1272
#: ext/julia/doc/src/manual/parallel-computing.md:1303 ext/julia/doc/src/manual/parallel-computing.md:1341
#: ext/julia/doc/src/manual/parallel-computing.md:1355 ext/julia/doc/src/manual/parallel-computing.md:1367
#: ext/julia/doc/src/manual/parallel-computing.md:1374 ext/julia/doc/src/manual/parallel-computing.md:1380
#: ext/julia/doc/src/manual/parallel-computing.md:1395 ext/julia/doc/src/manual/parallel-computing.md:1408
#: ext/julia/doc/src/manual/parallel-computing.md:1416 ext/julia/doc/src/manual/parallel-computing.md:1759
#: ext/julia/doc/src/manual/parallel-computing.md:1823 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:67
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:82 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:124
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1003 ext/julia/doc/src/manual/variables-and-scoping.md:520
#: ext/julia/doc/src/manual/variables.md:6 ext/julia/doc/src/manual/variables.md:112 ext/julia/doc/src/manual/performance-tips.md:44
#: ext/julia/doc/src/manual/performance-tips.md:50 ext/julia/doc/src/manual/performance-tips.md:828
#: ext/julia/doc/src/manual/performance-tips.md:1006 ext/julia/doc/src/manual/performance-tips.md:1270
#: ext/julia/doc/src/manual/performance-tips.md:1360 ext/julia/doc/src/manual/constructors.md:185 ext/julia/doc/src/manual/constructors.md:250
#: ext/julia/doc/src/manual/stacktraces.md:10 ext/julia/doc/src/manual/stacktraces.md:24 ext/julia/doc/src/manual/stacktraces.md:56
#: ext/julia/doc/src/manual/stacktraces.md:78 ext/julia/doc/src/manual/stacktraces.md:101 ext/julia/doc/src/manual/stacktraces.md:114
#: ext/julia/doc/src/manual/stacktraces.md:143 ext/julia/doc/src/manual/stacktraces.md:163 ext/julia/doc/src/manual/stacktraces.md:202
#: ext/julia/doc/src/manual/stacktraces.md:245 ext/julia/doc/src/manual/stacktraces.md:276 ext/julia/doc/src/manual/stacktraces.md:305
#: ext/julia/doc/src/manual/networking-and-streams.md:14 ext/julia/doc/src/manual/networking-and-streams.md:31
#: ext/julia/doc/src/manual/networking-and-streams.md:51 ext/julia/doc/src/manual/networking-and-streams.md:63
#: ext/julia/doc/src/manual/networking-and-streams.md:127 ext/julia/doc/src/manual/networking-and-streams.md:138
#: ext/julia/doc/src/manual/networking-and-streams.md:150 ext/julia/doc/src/manual/networking-and-streams.md:169
#: ext/julia/doc/src/manual/networking-and-streams.md:180 ext/julia/doc/src/manual/networking-and-streams.md:193
#: ext/julia/doc/src/manual/networking-and-streams.md:211 ext/julia/doc/src/manual/networking-and-streams.md:247
#: ext/julia/doc/src/manual/networking-and-streams.md:267 ext/julia/doc/src/manual/networking-and-streams.md:293
#: ext/julia/doc/src/manual/networking-and-streams.md:303 ext/julia/doc/src/manual/networking-and-streams.md:311
#: ext/julia/doc/src/manual/types.md:1102 ext/julia/doc/src/manual/arrays.md:187 ext/julia/doc/src/manual/arrays.md:232
#: ext/julia/doc/src/manual/arrays.md:833 ext/julia/doc/src/manual/arrays.md:846 ext/julia/doc/src/manual/arrays.md:957
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:62 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:75
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:88 ext/julia/doc/src/manual/profile.md:38
#: ext/julia/doc/src/manual/profile.md:48 ext/julia/doc/src/manual/profile.md:54 ext/julia/doc/src/manual/profile.md:63
#: ext/julia/doc/src/manual/profile.md:130 ext/julia/doc/src/manual/profile.md:154 ext/julia/doc/src/base/sort.md:41
#: ext/julia/doc/src/base/sort.md:69 ext/julia/doc/src/base/sort.md:81 ext/julia/doc/src/base/sort.md:93 ext/julia/doc/src/stdlib/REPL.md:63
#: ext/julia/doc/src/stdlib/REPL.md:104 ext/julia/doc/src/stdlib/REPL.md:226 ext/julia/doc/src/stdlib/REPL.md:237
#: ext/julia/doc/src/stdlib/REPL.md:276 ext/julia/doc/src/stdlib/REPL.md:288 ext/julia/doc/src/stdlib/REPL.md:303
#: ext/julia/doc/src/stdlib/REPL.md:316 ext/julia/doc/src/stdlib/REPL.md:325 ext/julia/doc/src/stdlib/REPL.md:335
#: ext/julia/doc/src/stdlib/Logging.md:207 ext/julia/doc/src/stdlib/Test.md:69 ext/julia/doc/src/stdlib/Test.md:144
#: ext/julia/doc/src/devdocs/reflection.md:123 ext/julia/doc/src/devdocs/types.md:172 ext/julia/doc/src/devdocs/types.md:210
#: ext/julia/doc/src/devdocs/types.md:302 ext/julia/doc/src/devdocs/types.md:464
#, no-wrap
msgid "julia-repl"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:259
#, no-wrap
msgid ""
"julia> run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))\n"
"210\n"
"211\n"
"212\n"
"213\n"
"214\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:273
msgid ""
"This prints the highest five user IDs on a UNIX system. The `cut`, `sort` and `tail` commands are all spawned as immediate children of the "
"current `julia` process, with no intervening shell process. Julia itself does the work to setup pipes and connect file descriptors that is "
"normally done by the shell. Since Julia does this itself, it retains better control and can do some things that shells cannot."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:275
msgid "Julia can run multiple commands in parallel:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/running-external-programs.md:276
#, no-wrap
msgid "jldoctest; filter = r\"(world\\nhello|hello\\nworld)\""
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:276
#, no-wrap
msgid ""
"julia> run(`echo hello` & `echo world`);\n"
"world\n"
"hello\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:286
msgid ""
"The order of the output here is non-deterministic because the two `echo` processes are started nearly simultaneously, and race to make the "
"first write to the [`stdout`](@ref) descriptor they share with each other and the `julia` parent process. Julia lets you pipe the output "
"from both of these processes to another program:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:287
#, no-wrap
msgid ""
"julia> run(pipeline(`echo world` & `echo hello`, `sort`));\n"
"hello\n"
"world\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:296
msgid ""
"In terms of UNIX plumbing, what's happening here is that a single UNIX pipe object is created and written to by both `echo` processes, and "
"the other end of the pipe is read from by the `sort` command."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:299
msgid "IO redirection can be accomplished by passing keyword arguments `stdin`, `stdout`, and `stderr` to the `pipeline` function:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/running-external-programs.md:300 ext/julia/doc/src/manual/running-external-programs.md:315
#: ext/julia/doc/src/manual/methods.md:534 ext/julia/doc/src/manual/methods.md:545 ext/julia/doc/src/manual/methods.md:556
#: ext/julia/doc/src/manual/methods.md:567 ext/julia/doc/src/manual/methods.md:573 ext/julia/doc/src/manual/methods.md:600
#: ext/julia/doc/src/manual/methods.md:611 ext/julia/doc/src/manual/methods.md:628 ext/julia/doc/src/manual/methods.md:667
#: ext/julia/doc/src/manual/methods.md:704 ext/julia/doc/src/manual/methods.md:757 ext/julia/doc/src/manual/methods.md:791
#: ext/julia/doc/src/manual/methods.md:805 ext/julia/doc/src/manual/methods.md:811 ext/julia/doc/src/manual/methods.md:821
#: ext/julia/doc/src/manual/methods.md:883 ext/julia/doc/src/manual/methods.md:897 ext/julia/doc/src/manual/methods.md:904
#: ext/julia/doc/src/manual/methods.md:921 ext/julia/doc/src/manual/methods.md:931 ext/julia/doc/src/manual/methods.md:938
#: ext/julia/doc/src/manual/methods.md:949 ext/julia/doc/src/manual/methods.md:958 ext/julia/doc/src/manual/methods.md:969
#: ext/julia/doc/src/manual/methods.md:976 ext/julia/doc/src/manual/methods.md:994 ext/julia/doc/src/manual/methods.md:1014
#: ext/julia/doc/src/manual/methods.md:1020 ext/julia/doc/src/manual/methods.md:1037 ext/julia/doc/src/manual/methods.md:1051
#: ext/julia/doc/src/manual/methods.md:1060 ext/julia/doc/src/manual/methods.md:1068 ext/julia/doc/src/manual/code-loading.md:83
#: ext/julia/doc/src/manual/code-loading.md:131 ext/julia/doc/src/manual/code-loading.md:152 ext/julia/doc/src/manual/code-loading.md:184
#: ext/julia/doc/src/manual/code-loading.md:274 ext/julia/doc/src/manual/code-loading.md:285 ext/julia/doc/src/manual/code-loading.md:318
#: ext/julia/doc/src/manual/code-loading.md:339 ext/julia/doc/src/manual/faq.md:50 ext/julia/doc/src/manual/faq.md:90
#: ext/julia/doc/src/manual/faq.md:171 ext/julia/doc/src/manual/faq.md:183 ext/julia/doc/src/manual/faq.md:736
#: ext/julia/doc/src/manual/faq.md:858 ext/julia/doc/src/manual/functions.md:71 ext/julia/doc/src/manual/functions.md:241
#: ext/julia/doc/src/manual/functions.md:251 ext/julia/doc/src/manual/functions.md:338 ext/julia/doc/src/manual/functions.md:352
#: ext/julia/doc/src/manual/functions.md:487 ext/julia/doc/src/manual/functions.md:533 ext/julia/doc/src/manual/functions.md:549
#: ext/julia/doc/src/manual/functions.md:557 ext/julia/doc/src/manual/functions.md:570 ext/julia/doc/src/manual/functions.md:595
#: ext/julia/doc/src/manual/functions.md:610 ext/julia/doc/src/manual/functions.md:625 ext/julia/doc/src/manual/functions.md:650
#: ext/julia/doc/src/manual/functions.md:658 ext/julia/doc/src/manual/workflow-tips.md:125 ext/julia/doc/src/manual/metaprogramming.md:489
#: ext/julia/doc/src/manual/metaprogramming.md:577 ext/julia/doc/src/manual/metaprogramming.md:587
#: ext/julia/doc/src/manual/metaprogramming.md:593 ext/julia/doc/src/manual/metaprogramming.md:671
#: ext/julia/doc/src/manual/metaprogramming.md:771 ext/julia/doc/src/manual/metaprogramming.md:799
#: ext/julia/doc/src/manual/metaprogramming.md:813 ext/julia/doc/src/manual/metaprogramming.md:855
#: ext/julia/doc/src/manual/metaprogramming.md:959 ext/julia/doc/src/manual/metaprogramming.md:968
#: ext/julia/doc/src/manual/metaprogramming.md:978 ext/julia/doc/src/manual/metaprogramming.md:997
#: ext/julia/doc/src/manual/metaprogramming.md:1008 ext/julia/doc/src/manual/metaprogramming.md:1017
#: ext/julia/doc/src/manual/metaprogramming.md:1032 ext/julia/doc/src/manual/metaprogramming.md:1069
#: ext/julia/doc/src/manual/metaprogramming.md:1403 ext/julia/doc/src/manual/strings.md:610 ext/julia/doc/src/manual/strings.md:616
#: ext/julia/doc/src/manual/strings.md:623 ext/julia/doc/src/manual/strings.md:790 ext/julia/doc/src/manual/strings.md:1121
#: ext/julia/doc/src/manual/parallel-computing.md:554 ext/julia/doc/src/manual/parallel-computing.md:667
#: ext/julia/doc/src/manual/parallel-computing.md:839 ext/julia/doc/src/manual/parallel-computing.md:892
#: ext/julia/doc/src/manual/parallel-computing.md:932 ext/julia/doc/src/manual/parallel-computing.md:950
#: ext/julia/doc/src/manual/parallel-computing.md:961 ext/julia/doc/src/manual/parallel-computing.md:972
#: ext/julia/doc/src/manual/parallel-computing.md:1257 ext/julia/doc/src/manual/parallel-computing.md:1314
#: ext/julia/doc/src/manual/parallel-computing.md:1330 ext/julia/doc/src/manual/parallel-computing.md:1492
#: ext/julia/doc/src/manual/parallel-computing.md:1505 ext/julia/doc/src/manual/parallel-computing.md:1550
#: ext/julia/doc/src/manual/parallel-computing.md:1623 ext/julia/doc/src/manual/parallel-computing.md:1809
#: ext/julia/doc/src/manual/parallel-computing.md:1860 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:109
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:137 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:264
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:270 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:510
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:531 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:582
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:721 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:734
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:772 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:801
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:838 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:903
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:931 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:957
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:976 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:988
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1068 ext/julia/doc/src/manual/handling-operating-system-variation.md:9
#: ext/julia/doc/src/manual/handling-operating-system-variation.md:27 ext/julia/doc/src/manual/handling-operating-system-variation.md:38
#: ext/julia/doc/src/manual/control-flow.md:61 ext/julia/doc/src/manual/control-flow.md:184 ext/julia/doc/src/manual/control-flow.md:776
#: ext/julia/doc/src/manual/control-flow.md:782 ext/julia/doc/src/manual/control-flow.md:807 ext/julia/doc/src/manual/control-flow.md:912
#: ext/julia/doc/src/manual/documentation.md:11 ext/julia/doc/src/manual/documentation.md:28 ext/julia/doc/src/manual/documentation.md:81
#: ext/julia/doc/src/manual/documentation.md:112 ext/julia/doc/src/manual/documentation.md:148 ext/julia/doc/src/manual/documentation.md:172
#: ext/julia/doc/src/manual/documentation.md:183 ext/julia/doc/src/manual/documentation.md:206 ext/julia/doc/src/manual/documentation.md:224
#: ext/julia/doc/src/manual/documentation.md:270 ext/julia/doc/src/manual/documentation.md:285 ext/julia/doc/src/manual/documentation.md:292
#: ext/julia/doc/src/manual/documentation.md:305 ext/julia/doc/src/manual/documentation.md:321 ext/julia/doc/src/manual/documentation.md:347
#: ext/julia/doc/src/manual/documentation.md:358 ext/julia/doc/src/manual/documentation.md:369 ext/julia/doc/src/manual/documentation.md:384
#: ext/julia/doc/src/manual/documentation.md:393 ext/julia/doc/src/manual/documentation.md:400 ext/julia/doc/src/manual/documentation.md:426
#: ext/julia/doc/src/manual/documentation.md:441 ext/julia/doc/src/manual/documentation.md:456 ext/julia/doc/src/manual/documentation.md:478
#: ext/julia/doc/src/manual/documentation.md:518 ext/julia/doc/src/manual/documentation.md:528 ext/julia/doc/src/manual/documentation.md:536
#: ext/julia/doc/src/manual/documentation.md:549 ext/julia/doc/src/manual/performance-tips.md:17
#: ext/julia/doc/src/manual/performance-tips.md:23 ext/julia/doc/src/manual/performance-tips.md:319
#: ext/julia/doc/src/manual/performance-tips.md:325 ext/julia/doc/src/manual/performance-tips.md:436
#: ext/julia/doc/src/manual/performance-tips.md:460 ext/julia/doc/src/manual/performance-tips.md:477
#: ext/julia/doc/src/manual/performance-tips.md:491 ext/julia/doc/src/manual/performance-tips.md:507
#: ext/julia/doc/src/manual/performance-tips.md:520 ext/julia/doc/src/manual/performance-tips.md:529
#: ext/julia/doc/src/manual/performance-tips.md:540 ext/julia/doc/src/manual/performance-tips.md:683
#: ext/julia/doc/src/manual/performance-tips.md:697 ext/julia/doc/src/manual/performance-tips.md:788
#: ext/julia/doc/src/manual/performance-tips.md:1040 ext/julia/doc/src/manual/performance-tips.md:1046
#: ext/julia/doc/src/manual/performance-tips.md:1054 ext/julia/doc/src/manual/performance-tips.md:1060
#: ext/julia/doc/src/manual/performance-tips.md:1068 ext/julia/doc/src/manual/performance-tips.md:1081
#: ext/julia/doc/src/manual/performance-tips.md:1142 ext/julia/doc/src/manual/performance-tips.md:1188
#: ext/julia/doc/src/manual/performance-tips.md:1292 ext/julia/doc/src/manual/performance-tips.md:1351
#: ext/julia/doc/src/manual/performance-tips.md:1438 ext/julia/doc/src/manual/performance-tips.md:1482
#: ext/julia/doc/src/manual/performance-tips.md:1497 ext/julia/doc/src/manual/networking-and-streams.md:74
#: ext/julia/doc/src/manual/networking-and-streams.md:82 ext/julia/doc/src/manual/networking-and-streams.md:161
#: ext/julia/doc/src/manual/types.md:105 ext/julia/doc/src/manual/types.md:116 ext/julia/doc/src/manual/types.md:171
#: ext/julia/doc/src/manual/types.md:205 ext/julia/doc/src/manual/types.md:220 ext/julia/doc/src/manual/types.md:244
#: ext/julia/doc/src/manual/types.md:619 ext/julia/doc/src/manual/types.md:628 ext/julia/doc/src/manual/types.md:820
#: ext/julia/doc/src/manual/types.md:831 ext/julia/doc/src/manual/types.md:849 ext/julia/doc/src/manual/types.md:1002
#: ext/julia/doc/src/manual/types.md:1083 ext/julia/doc/src/manual/types.md:1114 ext/julia/doc/src/manual/modules.md:12
#: ext/julia/doc/src/manual/modules.md:65 ext/julia/doc/src/manual/modules.md:94 ext/julia/doc/src/manual/modules.md:107
#: ext/julia/doc/src/manual/modules.md:256 ext/julia/doc/src/manual/modules.md:299 ext/julia/doc/src/manual/modules.md:325
#: ext/julia/doc/src/manual/arrays.md:213 ext/julia/doc/src/manual/arrays.md:757 ext/julia/doc/src/manual/arrays.md:794
#: ext/julia/doc/src/manual/conversion-and-promotion.md:167 ext/julia/doc/src/manual/conversion-and-promotion.md:184
#: ext/julia/doc/src/manual/conversion-and-promotion.md:193 ext/julia/doc/src/manual/conversion-and-promotion.md:248
#: ext/julia/doc/src/manual/conversion-and-promotion.md:267 ext/julia/doc/src/manual/conversion-and-promotion.md:294
#: ext/julia/doc/src/manual/conversion-and-promotion.md:302 ext/julia/doc/src/manual/conversion-and-promotion.md:333
#: ext/julia/doc/src/manual/style-guide.md:22 ext/julia/doc/src/manual/style-guide.md:28 ext/julia/doc/src/manual/style-guide.md:45
#: ext/julia/doc/src/manual/style-guide.md:65 ext/julia/doc/src/manual/style-guide.md:75 ext/julia/doc/src/manual/style-guide.md:93
#: ext/julia/doc/src/manual/style-guide.md:104 ext/julia/doc/src/manual/style-guide.md:126 ext/julia/doc/src/manual/style-guide.md:214
#: ext/julia/doc/src/manual/style-guide.md:220 ext/julia/doc/src/manual/style-guide.md:234 ext/julia/doc/src/manual/style-guide.md:240
#: ext/julia/doc/src/manual/style-guide.md:255 ext/julia/doc/src/manual/style-guide.md:283 ext/julia/doc/src/manual/style-guide.md:292
#: ext/julia/doc/src/manual/style-guide.md:306 ext/julia/doc/src/manual/style-guide.md:325 ext/julia/doc/src/manual/profile.md:182
#: ext/julia/doc/src/manual/profile.md:190 ext/julia/doc/src/manual/profile.md:211 ext/julia/doc/src/manual/profile.md:257
#: ext/julia/doc/src/manual/profile.md:273 ext/julia/doc/src/manual/interfaces.md:43 ext/julia/doc/src/manual/interfaces.md:51
#: ext/julia/doc/src/manual/interfaces.md:422 ext/julia/doc/src/manual/interfaces.md:490 ext/julia/doc/src/manual/interfaces.md:514
#: ext/julia/doc/src/manual/interfaces.md:520 ext/julia/doc/src/manual/interfaces.md:631 ext/julia/doc/src/manual/interfaces.md:642
#: ext/julia/doc/src/manual/interfaces.md:650 ext/julia/doc/src/manual/interfaces.md:677 ext/julia/doc/src/manual/interfaces.md:684
#: ext/julia/doc/src/manual/interfaces.md:699 ext/julia/doc/src/manual/interfaces.md:713 ext/julia/doc/src/manual/interfaces.md:724
#: ext/julia/doc/src/base/sort.md:154 ext/julia/doc/src/base/sort.md:182 ext/julia/doc/src/base/collections.md:8
#: ext/julia/doc/src/base/collections.md:16 ext/julia/doc/src/base/simd-types.md:6 ext/julia/doc/src/base/simd-types.md:19
#: ext/julia/doc/src/stdlib/Markdown.md:88 ext/julia/doc/src/stdlib/Markdown.md:146 ext/julia/doc/src/stdlib/Markdown.md:225
#: ext/julia/doc/src/stdlib/Markdown.md:294 ext/julia/doc/src/stdlib/SHA.md:5 ext/julia/doc/src/stdlib/SHA.md:17
#: ext/julia/doc/src/stdlib/Random.md:114 ext/julia/doc/src/stdlib/Random.md:151 ext/julia/doc/src/stdlib/Random.md:255
#: ext/julia/doc/src/stdlib/Random.md:262 ext/julia/doc/src/stdlib/Random.md:270 ext/julia/doc/src/stdlib/Random.md:287
#: ext/julia/doc/src/stdlib/Random.md:311 ext/julia/doc/src/stdlib/Random.md:343 ext/julia/doc/src/stdlib/REPL.md:199
#: ext/julia/doc/src/stdlib/REPL.md:355 ext/julia/doc/src/stdlib/REPL.md:377 ext/julia/doc/src/stdlib/REPL.md:392
#: ext/julia/doc/src/stdlib/REPL.md:405 ext/julia/doc/src/stdlib/REPL.md:422 ext/julia/doc/src/stdlib/REPL.md:455
#: ext/julia/doc/src/stdlib/REPL.md:515 ext/julia/doc/src/stdlib/Logging.md:7 ext/julia/doc/src/stdlib/Logging.md:18
#: ext/julia/doc/src/stdlib/SparseArrays.md:22 ext/julia/doc/src/stdlib/SparseArrays.md:79 ext/julia/doc/src/stdlib/Test.md:245
#: ext/julia/doc/src/stdlib/Test.md:270 ext/julia/doc/src/devdocs/ast.md:32 ext/julia/doc/src/devdocs/ast.md:104
#: ext/julia/doc/src/devdocs/ast.md:143 ext/julia/doc/src/devdocs/ast.md:173 ext/julia/doc/src/devdocs/ast.md:190
#: ext/julia/doc/src/devdocs/require.md:14 ext/julia/doc/src/devdocs/require.md:26 ext/julia/doc/src/devdocs/cartesian.md:10
#: ext/julia/doc/src/devdocs/cartesian.md:18 ext/julia/doc/src/devdocs/cartesian.md:77 ext/julia/doc/src/devdocs/cartesian.md:96
#: ext/julia/doc/src/devdocs/cartesian.md:103 ext/julia/doc/src/devdocs/cartesian.md:112 ext/julia/doc/src/devdocs/cartesian.md:119
#: ext/julia/doc/src/devdocs/offset-arrays.md:17 ext/julia/doc/src/devdocs/offset-arrays.md:42 ext/julia/doc/src/devdocs/offset-arrays.md:83
#: ext/julia/doc/src/devdocs/offset-arrays.md:139 ext/julia/doc/src/devdocs/offset-arrays.md:148 ext/julia/doc/src/devdocs/offset-arrays.md:157
#: ext/julia/doc/src/devdocs/offset-arrays.md:170 ext/julia/doc/src/devdocs/offset-arrays.md:196 ext/julia/doc/src/devdocs/functions.md:55
#: ext/julia/doc/src/devdocs/functions.md:74 ext/julia/doc/src/devdocs/functions.md:82 ext/julia/doc/src/devdocs/functions.md:137
#: ext/julia/doc/src/devdocs/functions.md:147 ext/julia/doc/src/devdocs/functions.md:156 ext/julia/doc/src/devdocs/functions.md:196
#: ext/julia/doc/src/devdocs/functions.md:202 ext/julia/doc/src/devdocs/valgrind.md:19 ext/julia/doc/src/devdocs/boundscheck.md:18
#: ext/julia/doc/src/devdocs/boundscheck.md:30 ext/julia/doc/src/devdocs/boundscheck.md:72 ext/julia/doc/src/devdocs/llvm.md:96
#: ext/julia/doc/src/devdocs/llvm.md:155 ext/julia/doc/src/devdocs/llvm.md:270 ext/julia/doc/src/devdocs/llvm.md:279
#: ext/julia/doc/src/devdocs/subarrays.md:49 ext/julia/doc/src/devdocs/subarrays.md:85 ext/julia/doc/src/devdocs/subarrays.md:113
#: ext/julia/doc/src/devdocs/ssair.md:45 ext/julia/doc/src/devdocs/ssair.md:56 ext/julia/doc/src/devdocs/ssair.md:113
#: ext/julia/doc/src/devdocs/types.md:78 ext/julia/doc/src/devdocs/types.md:129 ext/julia/doc/src/devdocs/types.md:323
#: ext/julia/doc/src/devdocs/types.md:362 ext/julia/doc/src/devdocs/types.md:376 ext/julia/doc/src/devdocs/types.md:386
#: ext/julia/doc/src/devdocs/types.md:394 ext/julia/doc/src/devdocs/types.md:413 ext/julia/doc/src/devdocs/types.md:476
#: ext/julia/doc/src/devdocs/types.md:482 ext/julia/doc/src/devdocs/types.md:503 ext/julia/doc/src/devdocs/meta.md:12
#: ext/julia/doc/src/devdocs/meta.md:20 ext/julia/doc/src/devdocs/meta.md:28 ext/julia/doc/src/devdocs/debuggingtips.md:17
#: ext/julia/doc/src/devdocs/debuggingtips.md:66 ext/julia/doc/src/devdocs/backtraces.md:85 ext/julia/doc/src/devdocs/inference.md:23
#: ext/julia/doc/src/devdocs/inference.md:41
#, no-wrap
msgid "julia"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:300
#, no-wrap
msgid "pipeline(`do_work`, stdout=pipeline(`sort`, \"out.txt\"), stderr=\"errs.txt\")\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/running-external-programs.md:304
#, no-wrap
msgid "Avoiding Deadlock in Pipelines"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:308
msgid ""
"When reading and writing to both ends of a pipeline from a single process, it is important to avoid forcing the kernel to buffer all of the "
"data."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:312
msgid ""
"For example, when reading all of the output from a command, call `read(out, String)`, not `wait(process)`, since the former will actively "
"consume all of the data written by the process, whereas the latter will attempt to store the data in the kernel's buffers while waiting for "
"a reader to be connected."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:314
msgid "Another common solution is to separate the reader and writer of the pipeline into separate [`Task`](@ref)s:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:315
#, no-wrap
msgid ""
"writer = @async write(process, \"data\")\n"
"reader = @async do_compute(read(process, String))\n"
"wait(process)\n"
"fetch(reader)\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/running-external-programs.md:322
#, no-wrap
msgid "Complex Example"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:328
msgid ""
"The combination of a high-level programming language, a first-class command abstraction, and automatic setup of pipes between processes is a "
"powerful one. To give some sense of the complex pipelines that can be created easily, here are some more sophisticated examples, with "
"apologies for the excessive use of Perl one-liners:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/running-external-programs.md:329
#, no-wrap
msgid "jldoctest prefixer; filter = r\"([A-B] [0-5])\""
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:329
#, no-wrap
msgid ""
"julia> prefixer(prefix, sleep) = `perl -nle '$|=1; print \"'$prefix' \", $_; sleep '$sleep';'`;\n"
"\n"
"julia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`, prefixer(\"A\",2) & prefixer(\"B\",2)));\n"
"B 0\n"
"A 1\n"
"B 2\n"
"A 3\n"
"B 4\n"
"A 5\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:348
msgid ""
"This is a classic example of a single producer feeding two concurrent consumers: one `perl` process generates lines with the numbers 0 "
"through 5 on them, while two parallel processes consume that output, one prefixing lines with the letter \"A\", the other with the letter \"B"
"\". Which consumer gets the first line is non-deterministic, but once that race has been won, the lines are consumed alternately by one "
"process and then the other. (Setting `$|=1` in Perl causes each print statement to flush the [`stdout`](@ref) handle, which is necessary for "
"this example to work. Otherwise all the output is buffered and printed to the pipe at once, to be read by just one consumer process.)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:350
msgid "Here is an even more complex multi-stage producer-consumer example:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/running-external-programs.md:351
#, no-wrap
msgid "jldoctest prefixer; filter = r\"[A-B] [X-Z] [0-5]\""
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:351
#, no-wrap
msgid ""
"julia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`,\n"
"           prefixer(\"X\",3) & prefixer(\"Y\",3) & prefixer(\"Z\",3),\n"
"           prefixer(\"A\",2) & prefixer(\"B\",2)));\n"
"A X 0\n"
"B Y 1\n"
"A Z 2\n"
"B X 3\n"
"A Y 4\n"
"B Z 5\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:366
msgid ""
"This example is similar to the previous one, except there are two stages of consumers, and the stages have different latency so they use a "
"different number of parallel workers, to maintain saturated throughput."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/running-external-programs.md:367
msgid "We strongly encourage you to try all these examples to see how they work."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/methods.md:1
#, no-wrap
msgid "Methods"
msgstr "[ã¡ã½ãã](@id Methods)"

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:10
msgid ""
"Recall from [Functions](@ref man-functions) that a function is an object that maps a tuple of arguments to a return value, or throws an "
"exception if no appropriate value can be returned. It is common for the same conceptual function or operation to be implemented quite "
"differently for different types of arguments: adding two integers is very different from adding two floating-point numbers, both of which "
"are distinct from adding an integer to a floating-point number. Despite their implementation differences, these operations all fall under "
"the general concept of \"addition\". Accordingly, in Julia, these behaviors all belong to a single object: the `+` function."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:22
msgid ""
"To facilitate using many different implementations of the same concept smoothly, functions need not be defined all at once, but can rather "
"be defined piecewise by providing specific behaviors for certain combinations of argument types and counts. A definition of one possible "
"behavior for a function is called a *method*. Thus far, we have presented only examples of functions defined with a single method, "
"applicable to all types of arguments. However, the signatures of method definitions can be annotated to indicate the types of arguments in "
"addition to their number, and more than a single method definition may be provided. When a function is applied to a particular tuple of "
"arguments, the most specific method applicable to those arguments is applied. Thus, the overall behavior of a function is a patchwork of the "
"behaviors of its various method definitions.  If the patchwork is well designed, even though the implementations of the methods may be quite "
"different, the outward behavior of the function will appear seamless and consistent."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:36
msgid ""
"The choice of which method to execute when a function is applied is called *dispatch*. Julia allows the dispatch process to choose which of "
"a function's methods to call based on the number of arguments given, and on the types of all of the function's arguments. This is different "
"than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument "
"syntax, and is sometimes implied rather than explicitly written as an argument.  [^1] Using all of a function's arguments to choose which "
"method should be invoked, rather than just the first, is known as [multiple dispatch](https://en.wikipedia.org/wiki/Multiple_dispatch).  "
"Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to \"belong"
"\" to one argument more than any of the others: does the addition operation in `x + y` belong to `x` any more than it does to `y`? The "
"implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, "
"however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:43
#, no-wrap
msgid ""
"[^1]:\n"
"    In C++ or Java, for example, in a method call like `obj.meth(arg1,arg2)`, the object obj \"receives\"\n"
"    the method call and is implicitly passed to the method via the `this` keyword, rather than as\n"
"    an explicit method argument. When the current `this` object is the receiver of a method call,\n"
"    it can be omitted altogether, writing just `meth(arg1,arg2)`, with `this` implied as the receiving\n"
"    object.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/methods.md:44
#, no-wrap
msgid "Defining Methods"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:52
msgid ""
"Until now, we have, in our examples, defined only functions with a single method having unconstrained argument types. Such functions behave "
"just like they would in traditional dynamically typed languages.  Nevertheless, we have used multiple dispatch and methods almost "
"continually without being aware of it: all of Julia's standard functions and operators, like the aforementioned `+` function, have many "
"methods defining their behavior over various possible combinations of argument type and count."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:55
msgid ""
"When defining a function, one can optionally constrain the types of parameters it is applicable to, using the `::` type-assertion operator, "
"introduced in the section on [Composite Types](@ref):"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/methods.md:56 ext/julia/doc/src/manual/methods.md:64 ext/julia/doc/src/manual/methods.md:71
#: ext/julia/doc/src/manual/methods.md:98 ext/julia/doc/src/manual/methods.md:121 ext/julia/doc/src/manual/methods.md:144
#: ext/julia/doc/src/manual/methods.md:160 ext/julia/doc/src/manual/methods.md:183 ext/julia/doc/src/manual/functions.md:17
#: ext/julia/doc/src/manual/functions.md:29 ext/julia/doc/src/manual/functions.md:37
#, no-wrap
msgid "jldoctest fofxy"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:56
#, no-wrap
msgid ""
"julia> f(x::Float64, y::Float64) = 2x + y\n"
"f (generic function with 1 method)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:63
msgid "This function definition applies only to calls where `x` and `y` are both values of type [`Float64`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:64
#, no-wrap
msgid ""
"julia> f(2.0, 3.0)\n"
"7.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:70
msgid "Applying it to any other types of arguments will result in a [`MethodError`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:71
#, no-wrap
msgid ""
"julia> f(2.0, 3)\n"
"ERROR: MethodError: no method matching f(::Float64, ::Int64)\n"
"Closest candidates are:\n"
"  f(::Float64, !Matched::Float64) at none:1\n"
"\n"
"julia> f(Float32(2.0), 3.0)\n"
"ERROR: MethodError: no method matching f(::Float32, ::Float64)\n"
"Closest candidates are:\n"
"  f(!Matched::Float64, ::Float64) at none:1\n"
"\n"
"julia> f(2.0, \"3.0\")\n"
"ERROR: MethodError: no method matching f(::Float64, ::String)\n"
"Closest candidates are:\n"
"  f(::Float64, !Matched::Float64) at none:1\n"
"\n"
"julia> f(\"2.0\", \"3.0\")\n"
"ERROR: MethodError: no method matching f(::String, ::String)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:97
msgid ""
"As you can see, the arguments must be precisely of type [`Float64`](@ref). Other numeric types, such as integers or 32-bit floating-point "
"values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because `Float64` is a concrete type "
"and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type `Float64`. It "
"may often be useful, however, to write more general methods where the declared parameter types are abstract:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:98
#, no-wrap
msgid ""
"julia> f(x::Number, y::Number) = 2x - y\n"
"f (generic function with 2 methods)\n"
"\n"
"julia> f(2.0, 3)\n"
"1.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:110
msgid ""
"This method definition applies to any pair of arguments that are instances of [`Number`](@ref).  They need not be of the same type, so long "
"as they are each numeric values. The problem of handling disparate numeric types is delegated to the arithmetic operations in the expression "
"`2x - y`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:120
msgid ""
"To define a function with multiple methods, one simply defines the function multiple times, with different numbers and types of arguments. "
"The first method definition for a function creates the function object, and subsequent method definitions add new methods to the existing "
"function object.  The most specific method definition matching the number and types of the arguments will be executed when the function is "
"applied. Thus, the two method definitions above, taken together, define the behavior for `f` over all pairs of instances of the abstract "
"type `Number` -- but with a different behavior specific to pairs of [`Float64`](@ref) values. If one of the arguments is a 64-bit float but "
"the other one is not, then the `f(Float64,Float64)` method cannot be called and the more general `f(Number,Number)` method must be used:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:121
#, no-wrap
msgid ""
"julia> f(2.0, 3.0)\n"
"7.0\n"
"\n"
"julia> f(2, 3.0)\n"
"1.0\n"
"\n"
"julia> f(2.0, 3)\n"
"1.0\n"
"\n"
"julia> f(2, 3)\n"
"1\n"
msgstr ""
"julia> f(2.0, 3.0)\n"
"7.0\n"
"\n"
"julia> f(2, 3.0)\n"
"1.0\n"
"\n"
"julia> f(2.0, 3)\n"
"1.0\n"
"\n"
"julia> f(2, 3)\n"
"1\n"

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:140
msgid ""
"The `2x + y` definition is only used in the first case, while the `2x - y` definition is used in the others. No automatic casting or "
"conversion of function arguments is ever performed: all conversion in Julia is non-magical and completely explicit. [Conversion and "
"Promotion](@ref conversion-and-promotion), however, shows how clever application of sufficiently advanced technology can be "
"indistinguishable from magic. [^Clarke61]"
msgstr ""
"`2x + y` ã®å®ç¾©ã¯æåã®ã±ã¼ã¹ã§ã®ã¿ä½¿ç¨ããã`2x - y` ã®å®ç¾©ã¯ä»ã®ã±ã¼ã¹ã§ä½¿ç¨ããã¾ããé¢æ°ã®å¼æ°ã®èªåã­ã£ã¹ããå¤æã¯å®è¡ããã¾ãã: "
"Julia ã®ãã¹ã¦ã®å¤æã«é­è¡ã¯ç¡ããå®å¨ã«æç¤ºçã§ããããããªããã[å¤æã¨ææ ¼](@ref conversion-and-promotion)ã¯ãååé«åº¦ãªæè¡ãå·§å¦ã«å¿ç¨ã"
"ããã¨ã§ãé­æ³ã¨åºå¥ã§ããªããªããã¨ãç¤ºãã¦ãã¾ãã[^Clarke61]"

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:143
msgid ""
"For non-numeric values, and for fewer or more than two arguments, the function `f` remains undefined, and applying it will still result in a "
"[`MethodError`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:144
#, no-wrap
msgid ""
"julia> f(\"foo\", 3)\n"
"ERROR: MethodError: no method matching f(::String, ::Int64)\n"
"Closest candidates are:\n"
"  f(!Matched::Number, ::Number) at none:1\n"
"\n"
"julia> f()\n"
"ERROR: MethodError: no method matching f()\n"
"Closest candidates are:\n"
"  f(!Matched::Float64, !Matched::Float64) at none:1\n"
"  f(!Matched::Number, !Matched::Number) at none:1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:159
msgid "You can easily see which methods exist for a function by entering the function object itself in an interactive session:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:160
#, no-wrap
msgid ""
"julia> f\n"
"f (generic function with 2 methods)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:167
msgid ""
"This output tells us that `f` is a function object with two methods. To find out what the signatures of those methods are, use the "
"[`methods`](@ref) function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:168
#, no-wrap
msgid ""
"julia> methods(f)\n"
"# 2 methods for generic function \"f\":\n"
"[1] f(x::Float64, y::Float64) in Main at none:1\n"
"[2] f(x::Number, y::Number) in Main at none:1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:178
msgid ""
"which shows that `f` has two methods, one taking two `Float64` arguments and one taking arguments of type `Number`. It also indicates the "
"file and line number where the methods were defined: because these methods were defined at the REPL, we get the apparent line number "
"`none:1`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:182
msgid ""
"In the absence of a type declaration with `::`, the type of a method parameter is `Any` by default, meaning that it is unconstrained since "
"all values in Julia are instances of the abstract type `Any`. Thus, we can define a catch-all method for `f` like so:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:183
#, no-wrap
msgid ""
"julia> f(x,y) = println(\"Whoa there, Nelly.\")\n"
"f (generic function with 3 methods)\n"
"\n"
"julia> f(\"foo\", 1)\n"
"Whoa there, Nelly.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:193
msgid ""
"This catch-all is less specific than any other possible method definition for a pair of parameter values, so it will only be called on pairs "
"of arguments to which no other method definition applies."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:197
msgid ""
"Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the "
"Julia language. Core operations typically have dozens of methods:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:198
#, no-wrap
msgid ""
"julia> methods(+)\n"
"# 180 methods for generic function \"+\":\n"
"[1] +(x::Bool, z::Complex{Bool}) in Base at complex.jl:227\n"
"[2] +(x::Bool, y::Bool) in Base at bool.jl:89\n"
"[3] +(x::Bool) in Base at bool.jl:86\n"
"[4] +(x::Bool, y::T) where T<:AbstractFloat in Base at bool.jl:96\n"
"[5] +(x::Bool, z::Complex) in Base at complex.jl:234\n"
"[6] +(a::Float16, b::Float16) in Base at float.jl:373\n"
"[7] +(x::Float32, y::Float32) in Base at float.jl:375\n"
"[8] +(x::Float64, y::Float64) in Base at float.jl:376\n"
"[9] +(z::Complex{Bool}, x::Bool) in Base at complex.jl:228\n"
"[10] +(z::Complex{Bool}, x::Real) in Base at complex.jl:242\n"
"[11] +(x::Char, y::Integer) in Base at char.jl:40\n"
"[12] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:307\n"
"[13] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:392\n"
"[14] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:391\n"
"[15] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:390\n"
"[16] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:361\n"
"[17] +(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:398\n"
"...\n"
"[180] +(a, b, c, xs...) in Base at operators.jl:424\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:225
msgid ""
"Multiple dispatch together with the flexible parametric type system give Julia its ability to abstractly express high-level algorithms "
"decoupled from implementation details, yet generate efficient, specialized code to handle each case at run time."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/methods.md:226
#, no-wrap
msgid "[Method Ambiguities](@id man-ambiguities)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:230
msgid ""
"It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of "
"arguments:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/methods.md:231 ext/julia/doc/src/manual/methods.md:257
#, no-wrap
msgid "jldoctest gofxy"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:231
#, no-wrap
msgid ""
"julia> g(x::Float64, y) = 2x + y\n"
"g (generic function with 1 method)\n"
"\n"
"julia> g(x, y::Float64) = x + 2y\n"
"g (generic function with 2 methods)\n"
"\n"
"julia> g(2.0, 3)\n"
"7.0\n"
"\n"
"julia> g(2, 3.0)\n"
"8.0\n"
"\n"
"julia> g(2.0, 3.0)\n"
"ERROR: MethodError: g(::Float64, ::Float64) is ambiguous. Candidates:\n"
"  g(x::Float64, y) in Main at none:1\n"
"  g(x, y::Float64) in Main at none:1\n"
"Possible fix, define\n"
"  g(::Float64, ::Float64)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:256
msgid ""
"Here the call `g(2.0, 3.0)` could be handled by either the `g(Float64, Any)` or the `g(Any, Float64)` method, and neither is more specific "
"than the other. In such cases, Julia raises a [`MethodError`](@ref)  rather than arbitrarily picking a method. You can avoid method "
"ambiguities by specifying an appropriate method for the intersection case:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:257
#, no-wrap
msgid ""
"julia> g(x::Float64, y::Float64) = 2x + 2y\n"
"g (generic function with 3 methods)\n"
"\n"
"julia> g(2.0, 3)\n"
"7.0\n"
"\n"
"julia> g(2, 3.0)\n"
"8.0\n"
"\n"
"julia> g(2.0, 3.0)\n"
"10.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:273
msgid ""
"It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if transiently, until the more "
"specific method is defined."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:276
msgid ""
"In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further [below](@ref man-"
"method-design-ambiguities)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/methods.md:277
#, no-wrap
msgid "Parametric Methods"
msgstr "[ãã©ã¡ããªãã¯ã¡ã½ãã](@id parametric-methods)"

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:280
msgid "Method definitions can optionally have type parameters qualifying the signature:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/methods.md:281 ext/julia/doc/src/manual/methods.md:294
#, no-wrap
msgid "jldoctest same_typefunc"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:281
#, no-wrap
msgid ""
"julia> same_type(x::T, y::T) where {T} = true\n"
"same_type (generic function with 1 method)\n"
"\n"
"julia> same_type(x,y) = false\n"
"same_type (generic function with 2 methods)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:293
msgid ""
"The first method applies whenever both arguments are of the same concrete type, regardless of what type that is, while the second method "
"acts as a catch-all, covering all other cases. Thus, overall, this defines a boolean function that checks whether its two arguments are of "
"the same type:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:294
#, no-wrap
msgid ""
"julia> same_type(1, 2)\n"
"true\n"
"\n"
"julia> same_type(1, 2.0)\n"
"false\n"
"\n"
"julia> same_type(1.0, 2.0)\n"
"true\n"
"\n"
"julia> same_type(\"foo\", 2.0)\n"
"false\n"
"\n"
"julia> same_type(\"foo\", \"bar\")\n"
"true\n"
"\n"
"julia> same_type(Int32(1), Int64(2))\n"
"false\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:316
msgid "Such definitions correspond to methods whose type signatures are `UnionAll` types (see [UnionAll Types](@ref))."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:322
msgid ""
"This kind of definition of function behavior by dispatch is quite common -- idiomatic, even -- in Julia. Method type parameters are not "
"restricted to being used as the types of arguments: they can be used anywhere a value would be in the signature of the function or body of "
"the function.  Here's an example where the method type parameter `T` is used as the type parameter to the parametric type `Vector{T}` in the "
"method signature:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:323
#, no-wrap
msgid ""
"julia> myappend(v::Vector{T}, x::T) where {T} = [v..., x]\n"
"myappend (generic function with 1 method)\n"
"\n"
"julia> myappend([1,2,3],4)\n"
"4-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
" 4\n"
"\n"
"julia> myappend([1,2,3],2.5)\n"
"ERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)\n"
"Closest candidates are:\n"
"  myappend(::Array{T,1}, !Matched::T) where T at none:1\n"
"\n"
"julia> myappend([1.0,2.0,3.0],4.0)\n"
"4-element Array{Float64,1}:\n"
" 1.0\n"
" 2.0\n"
" 3.0\n"
" 4.0\n"
"\n"
"julia> myappend([1.0,2.0,3.0],4)\n"
"ERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64)\n"
"Closest candidates are:\n"
"  myappend(::Array{T,1}, !Matched::T) where T at none:1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:355
msgid ""
"As you can see, the type of the appended element must match the element type of the vector it is appended to, or else a [`MethodError`]"
"(@ref) is raised. In the following example, the method type parameter `T` is used as the return value:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:356
#, no-wrap
msgid ""
"julia> mytypeof(x::T) where {T} = T\n"
"mytypeof (generic function with 1 method)\n"
"\n"
"julia> mytypeof(1)\n"
"Int64\n"
"\n"
"julia> mytypeof(1.0)\n"
"Float64\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:369
msgid ""
"Just as you can put subtype constraints on type parameters in type declarations (see [Parametric Types](@ref)), you can also constrain type "
"parameters of methods:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:370
#, no-wrap
msgid ""
"julia> same_type_numeric(x::T, y::T) where {T<:Number} = true\n"
"same_type_numeric (generic function with 1 method)\n"
"\n"
"julia> same_type_numeric(x::Number, y::Number) = false\n"
"same_type_numeric (generic function with 2 methods)\n"
"\n"
"julia> same_type_numeric(1, 2)\n"
"true\n"
"\n"
"julia> same_type_numeric(1, 2.0)\n"
"false\n"
"\n"
"julia> same_type_numeric(1.0, 2.0)\n"
"true\n"
"\n"
"julia> same_type_numeric(\"foo\", 2.0)\n"
"ERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)\n"
"Closest candidates are:\n"
"  same_type_numeric(!Matched::T, ::T) where T<:Number at none:1\n"
"  same_type_numeric(!Matched::Number, ::Number) at none:1\n"
"\n"
"julia> same_type_numeric(\"foo\", \"bar\")\n"
"ERROR: MethodError: no method matching same_type_numeric(::String, ::String)\n"
"\n"
"julia> same_type_numeric(Int32(1), Int64(2))\n"
"false\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:401
msgid "The `same_type_numeric` function behaves much like the `same_type` function defined above, but is only defined for pairs of numbers."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:408
#, no-wrap
msgid ""
"Parametric methods allow the same syntax as `where` expressions used to write types\n"
"(see [UnionAll Types](@ref)).\n"
"If there is only a single parameter, the enclosing curly braces (in `where {T}`) can be omitted,\n"
"but are often preferred for clarity.\n"
"Multiple parameters can be separated with commas, e.g. `where {T, S<:Real}`, or written using\n"
"nested `where`, e.g. `where S<:Real where T`.\n"
msgstr ""

#. type: Title -
#: ext/julia/doc/src/manual/methods.md:410
#, no-wrap
msgid "Redefining Methods"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:419
msgid ""
"When redefining a method or adding new methods, it is important to realize that these changes don't take effect immediately.  This is key to "
"Julia's ability to statically infer and compile code to run fast, without the usual JIT tricks and overhead.  Indeed, any new method "
"definition won't be visible to the current runtime environment, including Tasks and Threads (and any previously defined `@generated` "
"functions).  Let's start with an example to see what this means:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:420
#, no-wrap
msgid ""
"julia> function tryeval()\n"
"           @eval newfun() = 1\n"
"           newfun()\n"
"       end\n"
"tryeval (generic function with 1 method)\n"
"\n"
"julia> tryeval()\n"
"ERROR: MethodError: no method matching newfun()\n"
"The applicable method may be too new: running in world age xxxx1, while current world is xxxx2.\n"
"Closest candidates are:\n"
"  newfun() at none:1 (method too new to be called from this world context.)\n"
" in tryeval() at none:1\n"
" ...\n"
"\n"
"julia> newfun()\n"
"1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:445
msgid ""
"In this example, observe that the new definition for `newfun` has been created, but can't be immediately called.  The new global is "
"immediately visible to the `tryeval` function, so you could write `return newfun` (without parentheses).  But neither you, nor any of your "
"callers, nor the functions they call, or etc.  can call this new method definition!"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:448
msgid ""
"But there's an exception: future calls to `newfun` *from the REPL* work as expected, being able to both see and call the new definition of "
"`newfun`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:451
msgid ""
"However, future calls to `tryeval` will continue to see the definition of `newfun` as it was *at the previous statement at the REPL*, and "
"thus before that call to `tryeval`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:453
msgid "You may want to try this for yourself to see how it works."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:461
msgid ""
"The implementation of this behavior is a \"world age counter\".  This monotonically increasing value tracks each method definition "
"operation.  This allows describing \"the set of method definitions visible to a given runtime environment\" as a single number, or \"world "
"age\".  It also allows comparing the methods available in two worlds just by comparing their ordinal value.  In the example above, we see "
"that the \"current world\" (in which the method `newfun` exists), is one greater than the task-local \"runtime world\" that was fixed when "
"the execution of `tryeval` started."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:464
msgid ""
"Sometimes it is necessary to get around this (for example, if you are implementing the above REPL).  Fortunately, there is an easy solution: "
"call the function using [`Base.invokelatest`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:465
#, no-wrap
msgid ""
"julia> function tryeval2()\n"
"           @eval newfun2() = 2\n"
"           Base.invokelatest(newfun2)\n"
"       end\n"
"tryeval2 (generic function with 1 method)\n"
"\n"
"julia> tryeval2()\n"
"2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:478
msgid ""
"Finally, let's take a look at some more complex examples where this rule comes into play.  Define a function `f(x)`, which initially has one "
"method:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/methods.md:479 ext/julia/doc/src/manual/methods.md:486 ext/julia/doc/src/manual/methods.md:495
#: ext/julia/doc/src/manual/methods.md:505
#, no-wrap
msgid "jldoctest redefinemethod"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:479
#, no-wrap
msgid ""
"julia> f(x) = \"original definition\"\n"
"f (generic function with 1 method)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:485
msgid "Start some other operations that use `f(x)`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:486
#, no-wrap
msgid ""
"julia> g(x) = f(x)\n"
"g (generic function with 1 method)\n"
"\n"
"julia> t = @async f(wait()); yield();\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:494
msgid "Now we add some new methods to `f(x)`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:495
#, no-wrap
msgid ""
"julia> f(x::Int) = \"definition for Int\"\n"
"f (generic function with 2 methods)\n"
"\n"
"julia> f(x::Type{Int}) = \"definition for Type{Int}\"\n"
"f (generic function with 3 methods)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:504
msgid "Compare how these results differ:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:505
#, no-wrap
msgid ""
"julia> f(1)\n"
"\"definition for Int\"\n"
"\n"
"julia> g(1)\n"
"\"definition for Int\"\n"
"\n"
"julia> fetch(schedule(t, 1))\n"
"\"original definition\"\n"
"\n"
"julia> t = @async f(wait()); yield();\n"
"\n"
"julia> fetch(schedule(t, 1))\n"
"\"definition for Int\"\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/methods.md:521
#, no-wrap
msgid "Design Patterns with Parametric Methods"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:527
msgid ""
"While complex dispatch logic is not required for performance or usability, sometimes it can be the best way to express some algorithm.  Here "
"are a few common design patterns that come up sometimes when using dispatch in this way."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/methods.md:528
#, no-wrap
msgid "Extracting the type parameter from a super-type"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:533
msgid "Here is the correct code template for returning the element-type `T` of any arbitrary subtype of `AbstractArray`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:534
#, no-wrap
msgid ""
"abstract type AbstractArray{T, N} end\n"
"eltype(::Type{<:AbstractArray{T}}) where {T} = T\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:541
#, no-wrap
msgid ""
"using so-called triangular dispatch.  Note that if `T` is a `UnionAll`\n"
"type, as e.g. `eltype(Array{T} where T <: Integer)`, then `Any` is\n"
"returned (as does the version of `eltype` in `Base`).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:544
msgid "Another way, which used to be the only correct way before the advent of triangular dispatch in Julia v0.6, is:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:545
#, no-wrap
msgid ""
"abstract type AbstractArray{T, N} end\n"
"eltype(::Type{AbstractArray}) = Any\n"
"eltype(::Type{AbstractArray{T}}) where {T} = T\n"
"eltype(::Type{AbstractArray{T, N}}) where {T, N} = T\n"
"eltype(::Type{A}) where {A<:AbstractArray} = eltype(supertype(A))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:556
msgid ""
"Another possibility is the following, which could useful to adapt to cases where the parameter `T` would need to be matched more narrowly:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:556
#, no-wrap
msgid ""
"eltype(::Type{AbstractArray{T, N} where {T<:S, N<:M}}) where {M, S} = Any\n"
"eltype(::Type{AbstractArray{T, N} where {T<:S}}) where {N, S} = Any\n"
"eltype(::Type{AbstractArray{T, N} where {N<:M}}) where {M, T} = T\n"
"eltype(::Type{AbstractArray{T, N}}) where {T, N} = T\n"
"eltype(::Type{A}) where {A <: AbstractArray} = eltype(supertype(A))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:566
msgid "One common mistake is to try and get the element-type by using introspection:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:567
#, no-wrap
msgid "eltype_wrong(::Type{A}) where {A<:AbstractArray} = A.parameters[1]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:572
msgid "However, it is not hard to construct cases where this will fail:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:573
#, no-wrap
msgid "struct BitVector <: AbstractArray{Bool, 1}; end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:579
msgid ""
"Here we have created a type `BitVector` which has no parameters, but where the element-type is still fully specified, with `T` equal to "
"`Bool`!"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/methods.md:581
#, no-wrap
msgid "Building a similar type with a different type parameter"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:591
msgid ""
"When building generic code, there is often a need for constructing a similar object with some change made to the layout of the type, also "
"necessitating a change of the type parameters.  For instance, you might have some sort of abstract array with an arbitrary element type and "
"want to write your computation on it with a specific element type.  We must implement a method for each `AbstractArray{T}` subtype that "
"describes how to compute this type transform.  There is no general transform of one subtype into another subtype with a different "
"parameter.  (Quick review: do you see why this is?)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:599
msgid ""
"The subtypes of `AbstractArray` typically implement two methods to achieve this: A method to convert the input array to a subtype of a "
"specific `AbstractArray{T, N}` abstract type; and a method to make a new uninitialized array with a specific element type.  Sample "
"implementations of these can be found in Julia Base.  Here is a basic example usage of them, guaranteeing that `input` and `output` are of "
"the same type:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:600
#, no-wrap
msgid ""
"input = convert(AbstractArray{Eltype}, input)\n"
"output = similar(input, Eltype)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:610
msgid ""
"As an extension of this, in cases where the algorithm needs a copy of the input array, [`convert`](@ref) is insufficient as the return value "
"may alias the original input.  Combining [`similar`](@ref) (to make the output array) and [`copyto!`](@ref) (to fill it with the input "
"data)  is a generic way to express the requirement for a mutable copy of the input argument:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:611
#, no-wrap
msgid "copy_with_eltype(input, Eltype) = copyto!(similar(input, Eltype), input)\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/methods.md:615
#, no-wrap
msgid "Iterated dispatch"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:620
msgid ""
"In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch into distinct functions.  "
"This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:627
msgid ""
"For example, trying to dispatch on the element-type of an array will often run into ambiguous situations.  Instead, commonly code will "
"dispatch first on the container type, then recurse down to a more specific method based on eltype.  In most cases, the algorithms lend "
"themselves conveniently to this hierarchical approach, while in other cases, this rigor must be resolved manually.  This dispatching "
"branching can be observed, for example, in the logic to sum two matrices:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:628
#, no-wrap
msgid ""
"# First dispatch selects the map algorithm for element-wise summation.\n"
"+(a::Matrix, b::Matrix) = map(+, a, b)\n"
"# Then dispatch handles each element and selects the appropriate\n"
"# common element type for the computation.\n"
"+(a, b) = +(promote(a, b)...)\n"
"# Once the elements have the same type, they can be added.\n"
"# For example, via primitive operations exposed by the processor.\n"
"+(a::Float64, b::Float64) = Core.add(a, b)\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/methods.md:639
#, no-wrap
msgid "Trait-based dispatch"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:650
msgid ""
"A natural extension to the iterated dispatch above is to add a layer to method selection that allows to dispatch on sets of types which are "
"independent from the sets defined by the type hierarchy.  We could construct such a set by writing out a `Union` of the types in question, "
"but then this set would not be extensible as `Union`-types cannot be altered after creation.  However, such an extensible set can be "
"programmed with a design pattern often referred to as a [\"Holy-trait\"](https://github.com/JuliaLang/julia/"
"issues/2345#issuecomment-54537633)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:655
msgid ""
"This pattern is implemented by defining a generic function which computes a different singleton value (or type) for each trait-set to which "
"the function arguments may belong to.  If this function is pure there is no impact on performance compared to normal dispatch."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:666
msgid ""
"The example in the previous section glossed over the implementation details of [`map`](@ref) and [`promote`](@ref), which both operate in "
"terms of these traits.  When iterating over a matrix, such as in the implementation of `map`, one important question is what order to use to "
"traverse the data.  When `AbstractArray` subtypes implement the [`Base.IndexStyle`](@ref) trait, other functions such as `map` can dispatch "
"on this information to pick the best algorithm (see [Abstract Array Interface](@ref man-interface-array)).  This means that each subtype "
"does not need to implement a custom version of `map`, since the generic definitions + trait classes will enable the system to select the "
"fastest version.  Here a toy implementation of `map` illustrating the trait-based dispatch:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:667
#, no-wrap
msgid ""
"map(f, a::AbstractArray, b::AbstractArray) = map(Base.IndexStyle(a, b), f, a, b)\n"
"# generic implementation:\n"
"map(::Base.IndexCartesian, f, a::AbstractArray, b::AbstractArray) = ...\n"
"# linear-indexing implementation (faster)\n"
"map(::Base.IndexLinear, f, a::AbstractArray, b::AbstractArray) = ...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:682
msgid ""
"This trait-based approach is also present in the [`promote`](@ref)  mechanism employed by the scalar `+`.  It uses [`promote_type`](@ref), "
"which returns the optimal common type to compute the operation given the two types of the operands.  This makes it possible to reduce the "
"problem of implementing every function for every pair of possible type arguments, to the much smaller problem of implementing a conversion "
"operation from each type to a common type, plus a table of preferred pair-wise promotion rules."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/methods.md:684
#, no-wrap
msgid "Output-type computation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:688
msgid ""
"The discussion of trait-based promotion provides a transition into our next design pattern: computing the output element type for a matrix "
"operation."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:692
msgid ""
"For implementing primitive operations, such as addition, we use the [`promote_type`](@ref) function to compute the desired output type.  (As "
"before, we saw this at work in the `promote` call in the call to `+`)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:696
msgid ""
"For more complex functions on matrices, it may be necessary to compute the expected return type for a more complex sequence of operations.  "
"This is often performed by the following steps:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/methods.md:701
msgid "Write a small function `op` that expresses the set of operations performed by the kernel of the algorithm."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/methods.md:701
msgid ""
"Compute the element type `R` of the result matrix as `promote_op(op, argument_types...)`, where `argument_types` is computed from `eltype` "
"applied to each input array."
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/manual/methods.md:701
msgid "Build the output matrix as `similar(R, dims)`, where `dims` are the desired dimensions of the output array."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:703
msgid "For a more specific example, a generic square-matrix multiply pseudo-code might look like:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:704
#, no-wrap
msgid ""
"function matmul(a::AbstractMatrix, b::AbstractMatrix)\n"
"    op = (ai, bi) -> ai * bi + ai * bi\n"
"\n"
"    ## this is insufficient because it assumes `one(eltype(a))` is constructable:\n"
"    # R = typeof(op(one(eltype(a)), one(eltype(b))))\n"
"\n"
"    ## this fails because it assumes `a[1]` exists and is representative of all elements of the array\n"
"    # R = typeof(op(a[1], b[1]))\n"
"\n"
"    ## this is incorrect because it assumes that `+` calls `promote_type`\n"
"    ## but this is not true for some types, such as Bool:\n"
"    # R = promote_type(ai, bi)\n"
"\n"
"    # this is wrong, since depending on the return value\n"
"    # of type-inference is very brittle (as well as not being optimizable):\n"
"    # R = Base.return_types(op, (eltype(a), eltype(b)))\n"
"\n"
"    ## but, finally, this works:\n"
"    R = promote_op(op, eltype(a), eltype(b))\n"
"    ## although sometimes it may give a larger type than desired\n"
"    ## it will always give a correct type\n"
"\n"
"    output = similar(b, R, (size(a, 1), size(b, 2)))\n"
"    if size(a, 2) > 0\n"
"        for j in 1:size(b, 2)\n"
"            for i in 1:size(a, 1)\n"
"                ## here we don't use `ab = zero(R)`,\n"
"                ## since `R` might be `Any` and `zero(Any)` is not defined\n"
"                ## we also must declare `ab::R` to make the type of `ab` constant in the loop,\n"
"                ## since it is possible that typeof(a * b) != typeof(a * b + a * b) == R\n"
"                ab::R = a[i, 1] * b[1, j]\n"
"                for k in 2:size(a, 2)\n"
"                    ab += a[i, k] * b[k, j]\n"
"                end\n"
"                output[i, j] = ab\n"
"            end\n"
"        end\n"
"    end\n"
"    return output\n"
"end\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/methods.md:747
#, no-wrap
msgid "Separate convert and kernel logic"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:753
msgid ""
"One way to significantly cut down on compile-times and testing complexity is to isolate the logic for converting to the desired type and the "
"computation.  This lets the compiler specialize and inline the conversion logic independent from the rest of the body of the larger kernel."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:756
msgid ""
"This is a common pattern seen when converting from a larger class of types to the one specific argument type that is actually supported by "
"the algorithm:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:757
#, no-wrap
msgid ""
"complexfunction(arg::Int) = ...\n"
"complexfunction(arg::Any) = complexfunction(convert(Int, arg))\n"
"\n"
"matmul(a::T, b::T) = ...\n"
"matmul(a, b) = matmul(promote(a, b)...)\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/methods.md:765
#, no-wrap
msgid "Parametrically-constrained Varargs methods"
msgstr "[ãã©ã¡ã¼ã¿å¶éä»ãã®å¯å¤å¼æ°ã¡ã½ãã](@id parametrically-constrained-varargs-methods]"

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:770
msgid ""
"Function parameters can also be used to constrain the number of arguments that may be supplied to a \"varargs\" function ([Varargs Functions]"
"(@ref)).  The notation `Vararg{T,N}` is used to indicate such a constraint.  For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:771
#, no-wrap
msgid ""
"julia> bar(a,b,x::Vararg{Any,2}) = (a,b,x)\n"
"bar (generic function with 1 method)\n"
"\n"
"julia> bar(1,2,3)\n"
"ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)\n"
"Closest candidates are:\n"
"  bar(::Any, ::Any, ::Any, !Matched::Any) at none:1\n"
"\n"
"julia> bar(1,2,3,4)\n"
"(1, 2, (3, 4))\n"
"\n"
"julia> bar(1,2,3,4,5)\n"
"ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\n"
"Closest candidates are:\n"
"  bar(::Any, ::Any, ::Any, ::Any) at none:1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:790
msgid "More usefully, it is possible to constrain varargs methods by a parameter. For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:791
#, no-wrap
msgid "function getindex(A::AbstractArray{T,N}, indices::Vararg{Number,N}) where {T,N}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:796
msgid "would be called only when the number of `indices` matches the dimensionality of the array."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:799
msgid ""
"When only the type of supplied arguments needs to be constrained `Vararg{T}` can be equivalently written as `T...`. For instance `f(x::"
"Int...) = x` is a shorthand for `f(x::Vararg{Int}) = x`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/methods.md:800
#, no-wrap
msgid "Note on Optional and keyword Arguments"
msgstr "[ãªãã·ã§ã³å¼æ°ã»ã­ã¼ã¯ã¼ãå¼æ°ã«é¢ããæ³¨è¨](@id note-on-optional-and-keyword-arguments)"

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:804
msgid ""
"As mentioned briefly in [Functions](@ref man-functions), optional arguments are implemented as syntax for multiple method definitions. For "
"example, this definition:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:805
#, no-wrap
msgid "f(a=1,b=2) = a+2b\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:810
msgid "translates to the following three methods:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:811
#, no-wrap
msgid ""
"f(a,b) = a+2b\n"
"f(a) = f(a,2)\n"
"f() = f(1,2)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:820
msgid ""
"This means that calling `f()` is equivalent to calling `f(1,2)`. In this case the result is `5`, because `f(1,2)` invokes the first method "
"of `f` above. However, this need not always be the case.  If you define a fourth method that is more specialized for integers:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:821
#, no-wrap
msgid "f(a::Int,b::Int) = a-2b\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:829
msgid ""
"then the result of both `f()` and `f(1,2)` is `-3`. In other words, optional arguments are tied to a function, not to any specific method of "
"that function. It depends on the types of the optional arguments which method is invoked. When optional arguments are defined in terms of a "
"global variable, the type of the optional argument may even change at run-time."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:833
msgid ""
"Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not participate in method dispatch. "
"Methods are dispatched based only on positional arguments, with keyword arguments processed after the matching method is identified."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/methods.md:834
#, no-wrap
msgid "Function-like objects"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:838
msgid ""
"Methods are associated with types, so it is possible to make any arbitrary Julia object \"callable\" by adding methods to its type. (Such "
"\"callable\" objects are sometimes called \"functors.\")"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:841
msgid "For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function evaluating the polynomial:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/methods.md:842 ext/julia/doc/src/manual/methods.md:862
#, no-wrap
msgid "jldoctest polynomial"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:842
#, no-wrap
msgid ""
"julia> struct Polynomial{R}\n"
"           coeffs::Vector{R}\n"
"       end\n"
"\n"
"julia> function (p::Polynomial)(x)\n"
"           v = p.coeffs[end]\n"
"           for i = (length(p.coeffs)-1):-1:1\n"
"               v = v*x + p.coeffs[i]\n"
"           end\n"
"           return v\n"
"       end\n"
"\n"
"julia> (p::Polynomial)() = p(5)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:861
msgid ""
"Notice that the function is specified by type instead of by name. As with normal functions there is a terse syntax form. In the function "
"body, `p` will refer to the object that was called. A `Polynomial` can be used as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:862
#, no-wrap
msgid ""
"julia> p = Polynomial([1,10,100])\n"
"Polynomial{Int64}([1, 10, 100])\n"
"\n"
"julia> p(3)\n"
"931\n"
"\n"
"julia> p()\n"
"2551\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:875
msgid ""
"This mechanism is also the key to how type constructors and closures (inner functions that refer to their surrounding environment) work in "
"Julia."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/methods.md:876
#, no-wrap
msgid "Empty generic functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:882
msgid ""
"Occasionally it is useful to introduce a generic function without yet adding methods. This can be used to separate interface definitions "
"from implementations. It might also be done for the purpose of documentation or code readability. The syntax for this is an empty `function` "
"block without a tuple of arguments:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:883
#, no-wrap
msgid ""
"function emptyfunc\n"
"end\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/methods.md:888
#, no-wrap
msgid "[Method design and the avoidance of ambiguities](@id man-method-design-ambiguities)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:894
msgid ""
"Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges.  In particular, in "
"more complex method hierarchies it is not uncommon for [ambiguities](@ref man-ambiguities) to arise."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:896
msgid "Above, it was pointed out that one can resolve ambiguities like"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:897
#, no-wrap
msgid ""
"f(x, y::Int) = 1\n"
"f(x::Int, y) = 2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:903
msgid "by defining a method"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:904
#, no-wrap
msgid "f(x::Int, y::Int) = 3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:914
msgid ""
"This is often the right strategy; however, there are circumstances where following this advice blindly can be counterproductive. In "
"particular, the more methods a generic function has, the more possibilities there are for ambiguities. When your method hierarchies get more "
"complicated than this simple example, it can be worth your while to think carefully about alternative strategies."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:916
msgid "Below we discuss particular challenges and some alternative ways to resolve such issues."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/methods.md:917
#, no-wrap
msgid "Tuple and NTuple arguments"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:920
msgid "`Tuple` (and `NTuple`) arguments present special challenges. For example,"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:921
#, no-wrap
msgid ""
"f(x::NTuple{N,Int}) where {N} = 1\n"
"f(x::NTuple{N,Float64}) where {N} = 2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:930
msgid ""
"are ambiguous because of the possibility that `N == 0`: there are no elements to determine whether the `Int` or `Float64` variant should be "
"called. To resolve the ambiguity, one approach is define a method for the empty tuple:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:931
#, no-wrap
msgid "f(x::Tuple{}) = 3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:937
msgid "Alternatively, for all methods but one you can insist that there is at least one element in the tuple:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:938
#, no-wrap
msgid ""
"f(x::NTuple{N,Int}) where {N} = 1           # this is the fallback\n"
"f(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/methods.md:943
#, no-wrap
msgid "[Orthogonalize your design](@id man-methods-orthogonalize)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:948
msgid ""
"When you might be tempted to dispatch on two or more arguments, consider whether a \"wrapper\" function might make for a simpler design. For "
"example, instead of writing multiple variants:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:949
#, no-wrap
msgid ""
"f(x::A, y::A) = ...\n"
"f(x::A, y::B) = ...\n"
"f(x::B, y::A) = ...\n"
"f(x::B, y::B) = ...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:957
msgid "you might consider defining"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:958
#, no-wrap
msgid ""
"f(x::A, y::A) = ...\n"
"f(x, y) = f(g(x), g(y))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:968
msgid ""
"where `g` converts the argument to type `A`. This is a very specific example of the more general principle of [orthogonal design](https://en."
"wikipedia.org/wiki/Orthogonality_(programming)), in which separate concepts are assigned to separate methods. Here, `g` will most likely "
"need a fallback definition"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:969
#, no-wrap
msgid "g(x::A) = x\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:975
msgid "A related strategy exploits `promote` to bring `x` and `y` to a common type:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:976
#, no-wrap
msgid ""
"f(x::T, y::T) where {T} = ...\n"
"f(x, y) = f(promote(x, y)...)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:985
msgid ""
"One risk with this design is the possibility that if there is no suitable promotion method converting `x` and `y` to the same type, the "
"second method will recurse on itself infinitely and trigger a stack overflow."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/methods.md:986
#, no-wrap
msgid "Dispatch on one argument at a time"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:993
msgid ""
"If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all "
"possible variants, then consider introducing a \"name cascade\" where (for example) you dispatch on the first argument and then call an "
"internal method:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:994
#, no-wrap
msgid ""
"f(x::A, y) = _fA(x, y)\n"
"f(x::B, y) = _fB(x, y)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1001
msgid "Then the internal methods `_fA` and `_fB` can dispatch on `y` without concern about ambiguities with each other with respect to `x`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1008
msgid ""
"Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users to further customize the "
"behavior of `f` by defining further specializations of your exported function `f`. Instead, they have to define specializations for your "
"internal methods `_fA` and `_fB`, and this blurs the lines between exported and internal methods."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/methods.md:1009
#, no-wrap
msgid "Abstract containers and element types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1013
msgid "Where possible, try to avoid defining methods that dispatch on specific element types of abstract containers. For example,"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1014
#, no-wrap
msgid "-(A::AbstractArray{T}, b::Date) where {T<:Date}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1019
msgid "generates ambiguities for anyone who defines a method"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1020
#, no-wrap
msgid "-(A::MyArrayType{T}, b::T) where {T}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1030
msgid ""
"The best approach is to avoid defining *either* of these methods: instead, rely on a generic method `-(A::AbstractArray, b)` and make sure "
"this method is implemented with generic calls (like `similar` and `-`) that do the right thing for each container type and element type "
"*separately*. This is just a more complex variant of the advice to [orthogonalize](@ref man-methods-orthogonalize) your methods."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1036
msgid ""
"When this approach is not possible, it may be worth starting a discussion with other developers about resolving the ambiguity; just because "
"one method was defined first does not necessarily mean that it can't be modified or eliminated.  As a last resort, one developer can define "
"the \"band-aid\" method"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1037
#, no-wrap
msgid "-(A::MyArrayType{T}, b::Date) where {T<:Date} = ...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1042
msgid "that resolves the ambiguity by brute force."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/methods.md:1043
#, no-wrap
msgid "Complex method \"cascades\" with default arguments"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1050
msgid ""
"If you are defining a method \"cascade\" that supplies defaults, be careful about dropping any arguments that correspond to potential "
"defaults. For example, suppose you're writing a digital filtering algorithm and you have a method that handles the edges of the signal by "
"applying padding:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1051
#, no-wrap
msgid ""
"function myfilter(A, kernel, ::Replicate)\n"
"    Apadded = replicate_edges(A, size(kernel))\n"
"    myfilter(Apadded, kernel)  # now perform the \"real\" computation\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1059
msgid "This will run afoul of a method that supplies default padding:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1060
#, no-wrap
msgid "myfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by default\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1065
msgid "Together, these two methods generate an infinite recursion with `A` constantly growing bigger."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1067
msgid "The better design would be to define your call hierarchy like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1068
#, no-wrap
msgid ""
"struct NoPad end  # indicate that no padding is desired, or that it's already applied\n"
"\n"
"myfilter(A, kernel) = myfilter(A, kernel, Replicate())  # default boundary conditions\n"
"\n"
"function myfilter(A, kernel, ::Replicate)\n"
"    Apadded = replicate_edges(A, size(kernel))\n"
"    myfilter(Apadded, kernel, NoPad())  # indicate the new boundary conditions\n"
"end\n"
"\n"
"# other padding methods go here\n"
"\n"
"function myfilter(A, kernel, ::NoPad)\n"
"    # Here's the \"real\" implementation of the core computation\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1090
msgid ""
"`NoPad` is supplied in the same argument position as any other kind of padding, so it keeps the dispatch hierarchy well organized and with "
"reduced likelihood of ambiguities. Moreover, it extends the \"public\" `myfilter` interface: a user who wants to control the padding "
"explicitly can call the `NoPad` variant directly."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/methods.md:1091
msgid "[^Clarke61]: Arthur C. Clarke, *Profiles of the Future* (1961): Clarke's Third Law."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/environment-variables.md:1
#, no-wrap
msgid "Environment Variables"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:11
msgid ""
"Julia can be configured with a number of environment variables, set either in the usual way for each operating system, or in a portable way "
"from within Julia.  Supposing that you want to set the environment variable `JULIA_EDITOR` to `vim`, you can type `ENV[\"JULIA_EDITOR\"] = "
"\"vim\"` (for instance, in the REPL) to make this change on a case by case basis, or add the same to the user configuration file `~/.julia/"
"config/startup.jl` in the user's home directory to have a permanent effect. The current value of the same environment variable can be "
"determined by evaluating `ENV[\"JULIA_EDITOR\"]`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:16
msgid ""
"The environment variables that Julia uses generally start with `JULIA`. If [`InteractiveUtils.versioninfo`](@ref) is called with the keyword "
"`verbose=true`, then the output will list defined environment variables relevant for Julia, including those for which `JULIA` appears in the "
"name."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:18 ext/julia/doc/src/manual/environment-variables.md:86
#: ext/julia/doc/src/manual/environment-variables.md:172 ext/julia/doc/src/manual/environment-variables.md:209
#: ext/julia/doc/src/manual/environment-variables.md:292 ext/julia/doc/src/manual/environment-variables.md:303
#: ext/julia/doc/src/manual/environment-variables.md:314 ext/julia/doc/src/manual/environment-variables.md:325
msgid "!!! note"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:24
#, no-wrap
msgid ""
"    Some variables, such as `JULIA_NUM_THREADS` and `JULIA_PROJECT`, need to be set before Julia\n"
"    starts, therefore adding these to `~/.julia/config/startup.jl` is too late in the startup process.\n"
"    In Bash, environment variables can either be set manually by running, e.g.,\n"
"    `export JULIA_NUM_THREADS=4` before starting Julia, or by adding the same command to\n"
"    `~/.bashrc` or `~/.bash_profile` to set the variable each time Bash is started.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/environment-variables.md:25
#, no-wrap
msgid "File locations"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:27
#, no-wrap
msgid "`JULIA_BINDIR`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:32
msgid ""
"The absolute path of the directory containing the Julia executable, which sets the global variable [`Sys.BINDIR`](@ref). If `$JULIA_BINDIR` "
"is not set, then Julia determines the value `Sys.BINDIR` at run-time."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:34
msgid "The executable itself is one of"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:35
#, no-wrap
msgid ""
"$JULIA_BINDIR/julia\n"
"$JULIA_BINDIR/julia-debug\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:41
msgid "by default."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:44
msgid ""
"The global variable `Base.DATAROOTDIR` determines a relative path from `Sys.BINDIR` to the data directory associated with Julia. Then the "
"path"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:45
#, no-wrap
msgid "$JULIA_BINDIR/$DATAROOTDIR/julia/base\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:51
msgid "determines the directory in which Julia initially searches for source files (via `Base.find_source_file()`)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:54
msgid ""
"Likewise, the global variable `Base.SYSCONFDIR` determines a relative path to the configuration file directory. Then Julia searches for a "
"`startup.jl` file at"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:55
#, no-wrap
msgid ""
"$JULIA_BINDIR/$SYSCONFDIR/julia/startup.jl\n"
"$JULIA_BINDIR/../etc/julia/startup.jl\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:61
msgid "by default (via `Base.load_julia_startup()`)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:65
msgid ""
"For example, a Linux installation with a Julia executable located at `/bin/julia`, a `DATAROOTDIR` of `../share`, and a `SYSCONFDIR` of `../"
"etc` will have `JULIA_BINDIR` set to `/bin`, a source-file search path of"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:66
#, no-wrap
msgid "/share/julia/base\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:71
msgid "and a global configuration search path of"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:72
#, no-wrap
msgid "/etc/julia/startup.jl\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:76
#, no-wrap
msgid "`JULIA_PROJECT`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:84
msgid ""
"A directory path that indicates which project should be the initial active project.  Setting this environment variable has the same effect "
"as specifying the `--project` start-up option, but `--project` has higher precedence. If the variable is set to `@.` then Julia tries to "
"find a project directory that contains `Project.toml` or `JuliaProject.toml` file from the current directory and its parents. See also the "
"chapter on [Code Loading](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:89
#, no-wrap
msgid ""
"    `JULIA_PROJECT` must be defined before starting julia; defining it in `startup.jl`\n"
"    is too late in the startup process.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:90
#, no-wrap
msgid "`JULIA_LOAD_PATH`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:95
msgid ""
"The `JULIA_LOAD_PATH` environment variable is used to populate the global Julia [`LOAD_PATH`](@ref) variable, which determines which "
"packages can be loaded via `import` and `using` (see [Code Loading](@ref))."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:101
msgid ""
"Unlike the shell `PATH` variable, empty entries in `JULIA_LOAD_PATH` are expanded to the default value of `LOAD_PATH`, `[\"@\", \"@v#.#\", "
"\"@stdlib\"]` when populating `LOAD_PATH`. This allows easy appending, prepending, etc. of the load path value in shell scripts regardless "
"of whether `JULIA_LOAD_PATH` is already set or not. For example, to prepend the directory `/foo/bar` to `LOAD_PATH` just do"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/environment-variables.md:101 ext/julia/doc/src/manual/environment-variables.md:127
#, no-wrap
msgid "sh"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:101
#, no-wrap
msgid "export JULIA_LOAD_PATH=\"/foo/bar:$JULIA_LOAD_PATH\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:113
msgid ""
"If the `JULIA_LOAD_PATH` environment variable is already set, its old value will be prepended with `/foo/bar`. On the other hand, if "
"`JULIA_LOAD_PATH` is not set, then it will be set to `/foo/bar:` which will expand to a `LOAD_PATH` value of `[\"/foo/bar\", \"@\", \"@v#.#"
"\", \"@stdlib\"]`. If `JULIA_LOAD_PATH` is set to the empty string, it expands to an empty `LOAD_PATH` array. In other words, the empty "
"string is interpreted as a zero-element array, not a one-element array of the empty string.  This behavior was chosen so that it would be "
"possible to set an empty load path via the environment variable. If you want the default load path, either unset the environment variable or "
"if it must have a value, set it to the string `:`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:114
#, no-wrap
msgid "`JULIA_DEPOT_PATH`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:121
msgid ""
"The `JULIA_DEPOT_PATH` environment variable is used to populate the global Julia [`DEPOT_PATH`](@ref) variable, which controls where the "
"package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo "
"clones, cached compiled package images, configuration files, and the default location of the REPL's history file."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:127
msgid ""
"Unlike the shell `PATH` variable but similar to `JULIA_LOAD_PATH`, empty entries in `JULIA_DEPOT_PATH` are expanded to the default value of "
"`DEPOT_PATH`. This allows easy appending, prepending, etc. of the depot path value in shell scripts regardless of whether `JULIA_DEPOT_PATH` "
"is already set or not. For example, to prepend the directory `/foo/bar` to `DEPOT_PATH` just do"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:127
#, no-wrap
msgid "export JULIA_DEPOT_PATH=\"/foo/bar:$JULIA_DEPOT_PATH\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:139
msgid ""
"If the `JULIA_DEPOT_PATH` environment variable is already set, its old value will be prepended with `/foo/bar`. On the other hand, if "
"`JULIA_DEPOT_PATH` is not set, then it will be set to `/foo/bar:` which will have the effect of prepending `/foo/bar` to the default depot "
"path. If `JULIA_DEPOT_PATH` is set to the empty string, it expands to an empty `DEPOT_PATH` array. In other words, the empty string is "
"interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to "
"set an empty depot path via the environment variable. If you want the default depot path, either unset the environment variable or if it "
"must have a value, set it to the string `:`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:140
#, no-wrap
msgid "`JULIA_HISTORY`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:144
msgid ""
"The absolute path `REPL.find_hist_file()` of the REPL's history file. If `$JULIA_HISTORY` is not set, then `REPL.find_hist_file()` defaults "
"to"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:145
#, no-wrap
msgid "$(DEPOT_PATH[1])/logs/repl_history.jl\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:149
#, no-wrap
msgid "`JULIA_PKGRESOLVE_ACCURACY`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:155
msgid ""
"A positive `Int` that determines how much time the max-sum subroutine `MaxSum.maxsum()` of the package dependency resolver will devote to "
"attempting satisfying constraints before giving up: this value is by default `1`, and larger values correspond to larger amounts of time."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:157
msgid "Suppose the value of `$JULIA_PKGRESOLVE_ACCURACY` is `n`. Then"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/environment-variables.md:161
msgid "the number of pre-decimation iterations is `20*n`,"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/environment-variables.md:161
msgid "the number of iterations between decimation steps is `10*n`, and"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/environment-variables.md:161
msgid "at decimation steps, at most one in every `20*n` packages is decimated."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/environment-variables.md:163
#, no-wrap
msgid "External applications"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:165
#, no-wrap
msgid "`JULIA_SHELL`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:170
msgid ""
"The absolute path of the shell with which Julia should execute external commands (via `Base.repl_cmd()`). Defaults to the environment "
"variable `$SHELL`, and falls back to `/bin/sh` if `$SHELL` is unset."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:175
#, no-wrap
msgid ""
"    On Windows, this environment variable is ignored, and external commands are\n"
"    executed directly.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:176
#, no-wrap
msgid "`JULIA_EDITOR`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:180
msgid ""
"The editor returned by `InteractiveUtils.editor()` and used in, e.g., [`InteractiveUtils.edit`](@ref), referring to the command of the "
"preferred editor, for instance `vim`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:185
msgid ""
"`$JULIA_EDITOR` takes precedence over `$VISUAL`, which in turn takes precedence over `$EDITOR`. If none of these environment variables is "
"set, then the editor is taken to be `open` on Windows and OS X, or `/etc/alternatives/editor` if it exists, or `emacs` otherwise."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/environment-variables.md:186
#, no-wrap
msgid "Parallelization"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:188
#, no-wrap
msgid "`JULIA_CPU_THREADS`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:192
msgid "Overrides the global variable [`Base.Sys.CPU_THREADS`](@ref), the number of logical CPU cores available."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:193
#, no-wrap
msgid "`JULIA_WORKER_TIMEOUT`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:198
msgid ""
"A [`Float64`](@ref) that sets the value of `Distributed.worker_timeout()` (default: `60.0`).  This function gives the number of seconds a "
"worker process will wait for a master process to establish a connection before dying."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:199
#, no-wrap
msgid "`JULIA_NUM_THREADS`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:207
msgid ""
"An unsigned 64-bit integer (`uint64_t`) that sets the maximum number of threads available to Julia. If `$JULIA_NUM_THREADS` exceeds the "
"number of available physical CPU cores, then the number of threads is set to the number of cores. If `$JULIA_NUM_THREADS` is not positive or "
"is not set, or if the number of CPU cores cannot be determined through system calls, then the number of threads is set to `1`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:211
#, no-wrap
msgid "    `JULIA_NUM_THREADS` must be defined before starting julia; defining it in `startup.jl` is too late in the startup process.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:212
#, no-wrap
msgid "`JULIA_THREAD_SLEEP_THRESHOLD`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:218
msgid ""
"If set to a string that starts with the case-insensitive substring `\"infinite\"`, then spinning threads never sleep. Otherwise, `"
"$JULIA_THREAD_SLEEP_THRESHOLD` is interpreted as an unsigned 64-bit integer (`uint64_t`) and gives, in nanoseconds, the amount of time after "
"which spinning threads should sleep."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:219
#, no-wrap
msgid "`JULIA_EXCLUSIVE`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:224
msgid ""
"If set to anything besides `0`, then Julia's thread policy is consistent with running on a dedicated machine: the master thread is on proc "
"0, and threads are affinitized. Otherwise, Julia lets the operating system handle thread policy."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/environment-variables.md:225
#, no-wrap
msgid "REPL formatting"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:232
msgid ""
"Environment variables that determine how REPL output should be formatted at the terminal. Generally, these variables should be set to [ANSI "
"terminal escape sequences](http://ascii-table.com/ansi-escape-sequences.php). Julia provides a high-level interface with much of the same "
"functionality; see the section on [The Julia REPL](@ref)."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:233
#, no-wrap
msgid "`JULIA_ERROR_COLOR`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:237
msgid "The formatting `Base.error_color()` (default: light red, `\"\\033[91m\"`) that errors should have at the terminal."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:238
#, no-wrap
msgid "`JULIA_WARN_COLOR`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:242
msgid "The formatting `Base.warn_color()` (default: yellow, `\"\\033[93m\"`) that warnings should have at the terminal."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:243
#, no-wrap
msgid "`JULIA_INFO_COLOR`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:247
msgid "The formatting `Base.info_color()` (default: cyan, `\"\\033[36m\"`) that info should have at the terminal."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:248
#, no-wrap
msgid "`JULIA_INPUT_COLOR`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:252
msgid "The formatting `Base.input_color()` (default: normal, `\"\\033[0m\"`) that input should have at the terminal."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:253
#, no-wrap
msgid "`JULIA_ANSWER_COLOR`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:257
msgid "The formatting `Base.answer_color()` (default: normal, `\"\\033[0m\"`) that output should have at the terminal."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:258
#, no-wrap
msgid "`JULIA_STACKFRAME_LINEINFO_COLOR`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:262
msgid ""
"The formatting `Base.stackframe_lineinfo_color()` (default: bold, `\"\\033[1m\"`)  that line info should have during a stack trace at the "
"terminal."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:263
#, no-wrap
msgid "`JULIA_STACKFRAME_FUNCTION_COLOR`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:267
msgid ""
"The formatting `Base.stackframe_function_color()` (default: bold, `\"\\033[1m\"`)  that function calls should have during a stack trace at "
"the terminal."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/environment-variables.md:268
#, no-wrap
msgid "Debugging and profiling"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:270
#, no-wrap
msgid "`JULIA_GC_ALLOC_POOL`, `JULIA_GC_ALLOC_OTHER`, `JULIA_GC_ALLOC_PRINT`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:276
msgid ""
"If set, these environment variables take strings that optionally start with the character `'r'`, followed by a string interpolation of a "
"colon-separated list of three signed 64-bit integers (`int64_t`). This triple of integers `a:b:c` represents the arithmetic sequence `a`, `a "
"+ b`, `a + 2*b`, ... `c`."
msgstr ""

#. type: Bullet: '*   '
#: ext/julia/doc/src/manual/environment-variables.md:287
msgid ""
"If it's the `n`th time that `jl_gc_pool_alloc()` has been called, and `n` belongs to the arithmetic sequence represented by `"
"$JULIA_GC_ALLOC_POOL`, then garbage collection is forced."
msgstr ""

#. type: Bullet: '*   '
#: ext/julia/doc/src/manual/environment-variables.md:287
msgid ""
"If it's the `n`th time that `maybe_collect()` has been called, and `n` belongs to the arithmetic sequence represented by `"
"$JULIA_GC_ALLOC_OTHER`, then garbage collection is forced."
msgstr ""

#. type: Bullet: '*   '
#: ext/julia/doc/src/manual/environment-variables.md:287
msgid ""
"If it's the `n`th time that `jl_gc_collect()` has been called, and `n` belongs to the arithmetic sequence represented by `"
"$JULIA_GC_ALLOC_PRINT`, then counts for the number of calls to `jl_gc_pool_alloc()` and `maybe_collect()` are printed."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:290
msgid ""
"If the value of the environment variable begins with the character `'r'`, then the interval between garbage collection events is randomized."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:296
#, no-wrap
msgid ""
"    These environment variables only have an effect if Julia was compiled with\n"
"    garbage-collection debugging (that is, if `WITH_GC_DEBUG_ENV` is set to `1`\n"
"    in the build configuration).\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:297
#, no-wrap
msgid "`JULIA_GC_NO_GENERATIONAL`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:301
msgid "If set to anything besides `0`, then the Julia garbage collector never performs \"quick sweeps\" of memory."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:307 ext/julia/doc/src/manual/environment-variables.md:318
#, no-wrap
msgid ""
"    This environment variable only has an effect if Julia was compiled with\n"
"    garbage-collection debugging (that is, if `WITH_GC_DEBUG_ENV` is set to `1`\n"
"    in the build configuration).\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:308
#, no-wrap
msgid "`JULIA_GC_WAIT_FOR_DEBUGGER`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:312
msgid ""
"If set to anything besides `0`, then the Julia garbage collector will wait for a debugger to attach instead of aborting whenever there's a "
"critical error."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:319
#, no-wrap
msgid "`ENABLE_JITPROFILING`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:323
msgid "If set to anything besides `0`, then the compiler will create and register an event listener for just-in-time (JIT) profiling."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:332
#, no-wrap
msgid ""
"    This environment variable only has an effect if Julia was compiled with JIT\n"
"    profiling support, using either\n"
"    * Intel's [VTuneâ¢ Amplifier](https://software.intel.com/en-us/vtune)\n"
"      (`USE_INTEL_JITEVENTS` set to `1` in the build configuration), or\n"
"    * [OProfile](http://oprofile.sourceforge.net/news/) (`USE_OPROFILE_JITEVENTS` set to `1`\n"
"      in the build configuration).\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/environment-variables.md:333
#, no-wrap
msgid "`JULIA_LLVM_ARGS`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/environment-variables.md:336
msgid "Arguments to be passed to the LLVM backend."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/mathematical-operations.md:1
#, no-wrap
msgid "Mathematical Operations and Elementary Functions"
msgstr "[ç®è¡æ¼ç®ã¨åç­é¢æ°](@id mathematical-operations-and-elementary-functions)"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:6
msgid ""
"Julia provides a complete collection of basic arithmetic and bitwise operators across all of its numeric primitive types, as well as "
"providing portable, efficient implementations of a comprehensive collection of standard mathematical functions."
msgstr ""
"Julia ã«ã¯ããã¹ã¦ã®æ°å¤ããªããã£ãåã«å¯¾ãã¦åºæ¬çãªç®è¡æ¼ç®å­ã¨ãããæ¼ç®å­ãä¸éãæãã¦ãã¾ããã¾ããç§»æ¤æ§ã®é«ããå¹ççãªå®è£ã®æ¨æºç"
"ãªæ°å­¦é¢æ°ãæãã¦ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/mathematical-operations.md:7
#, no-wrap
msgid "Arithmetic Operators"
msgstr "ç®è¡æ¼ç®å­"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:11
msgid ""
"The following [arithmetic operators](https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations)  are supported on all primitive numeric "
"types:"
msgstr "æ¬¡ã® [ç®è¡æ¼ç®å­](https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations)ã¯ããã¹ã¦ã®ããªããã£ãæ°å¤åã§ãµãã¼ãããã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:24
#, no-wrap
msgid ""
"| Expression | Name           | Description                            |\n"
"|:---------- |:-------------- |:-------------------------------------- |\n"
"| `+x`       | unary plus     | the identity operation                 |\n"
"| `-x`       | unary minus    | maps values to their additive inverses |\n"
"| `x + y`    | binary plus    | performs addition                      |\n"
"| `x - y`    | binary minus   | performs subtraction                   |\n"
"| `x * y`    | times          | performs multiplication                |\n"
"| `x / y`    | divide         | performs division                      |\n"
"| `x Ã· y`    | integer divide | x / y, truncated to an integer         |\n"
"| `x \\ y`    | inverse divide | equivalent to `y / x`                  |\n"
"| `x ^ y`    | power          | raises `x` to the `y`th power          |\n"
"| `x % y`    | remainder      | equivalent to `rem(x,y)`               |\n"
msgstr ""
"| å¼ | åå           | èª¬æ                            |\n"
"|:---------- |:-------------- |:-------------------------------------- |\n"
"| `+x`       | åé å ç®     | æç­æ¼ç®                 |\n"
"| `-x`       | åé æ¸ç®    | å ç®ã®éåã¸ã®åå |\n"
"| `x + y`    | äºé å ç®    | å ç®ãå®è¡                      |\n"
"| `x - y`    | äºé æ¸ç®   | æ¸ç®ãå®è¡                   |\n"
"| `x * y`    | ä¹ç®          | ä¹ç®ãå®è¡                |\n"
"| `x / y`    | é¤ç®         | é¤ç®ãå®è¡                      |\n"
"| `x Ã· y`    | æ´æ°é¤ç® | x / y, æ´æ°ã«åãæ¨ã¦         |\n"
"| `x \\ y`    | éé¤ç® | `y / x`ã¨åç­                  |\n"
"| `x ^ y`    | ç´¯ä¹          | `x` ã® `y`ä¹          |\n"
"| `x % y`    | å°ä½ç®      | `rem(x,y)`ã¨åç­               |\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:26
msgid "as well as the negation on [`Bool`](@ref) types:"
msgstr "[`Bool`](@ref)ã¿ã¤ãã®å¦å®ãåæ§ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:30
#, no-wrap
msgid ""
"| Expression | Name     | Description                              |\n"
"|:---------- |:-------- |:---------------------------------------- |\n"
"| `!x`       | negation | changes `true` to `false` and vice versa |\n"
msgstr ""
"| å¼| åå     | èª¬æ                              |\n"
"|:---------- |:-------- |:---------------------------------------- |\n"
"| `!x`       | å¦å® | `true` ã¨ `false` ãéã«ãã |\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:32
msgid ""
"A numeric literal placed directly before an identifier or parentheses, e.g. `2x` or `2(x+y)`, is treated as a multiplication, except with "
"higher precedence than other binary operations.  See [Numeric Literal Coefficients](@ref man-numeric-literal-coefficients) for details."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:36
msgid ""
"Julia's promotion system makes arithmetic operations on mixtures of argument types \"just work\" naturally and automatically. See "
"[Conversion and Promotion](@ref conversion-and-promotion) for details of the promotion system."
msgstr ""
"Julia ã®ææ ¼ã·ã¹ãã ã¯ãç°ãªãåã®å¼æ°åãæ··å¨ããç®è¡æ¼ç®ãèªç¶ãã¤èªåçãã¾ãåä½ããã¾ããææ ¼ã·ã¹ãã ã®è©³ç´°ã«ã¤ãã¦ã¯ã[å¤æã¨ææ ¼]"
"(@ref conversion-and-promotion)ãåç§ãã¦ãã ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:38
msgid "Here are some simple examples using arithmetic operators:"
msgstr "ç®è¡æ¼ç®å­ãä½¿ç¨ããç°¡åãªä¾ãæ¬¡ã«ç¤ºãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:39
#, no-wrap
msgid ""
"julia> 1 + 2 + 3\n"
"6\n"
"\n"
"julia> 1 - 2\n"
"-1\n"
"\n"
"julia> 3*2/12\n"
"0.5\n"
msgstr ""
"julia> 1 + 2 + 3\n"
"6\n"
"\n"
"julia> 1 - 2\n"
"-1\n"
"\n"
"julia> 3*2/12\n"
"0.5\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:53
msgid ""
"(By convention, we tend to space operators more tightly if they get applied before other nearby operators. For instance, we would generally "
"write `-x + 2` to reflect that first `x` gets negated, and then `2` is added to that result.)"
msgstr ""
"(æ£ç¿çã«å¨ãã®ä»ã®æ¼ç®å­ããåã«æ¼ç®ãè¡ãæ¼ç®ã§ã¯ç©ºç½ãè©°ãããã¨ãããããã¾ãããã¨ãã°ã`-x + 2` ã¨æ¸ãã®ã¯ãæåã® `x` ã«-1ãããã¦ãã"
"`2` ãè¶³ããã¨ãåæ ãã¦ãã¾ãã)"

#. type: Title ##
#: ext/julia/doc/src/manual/mathematical-operations.md:54
#, no-wrap
msgid "Bitwise Operators"
msgstr "ãããæ¼ç®å­"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:58
msgid ""
"The following [bitwise operators](https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators)  are supported on all primitive integer "
"types:"
msgstr ""
"æ¬¡ã® [ãããæ¼ç®å­](https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators)ã¯ããã¹ã¦ã®ããªããã£ãæ´æ°åã§ãµãã¼ãããã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:68
#, no-wrap
msgid ""
"| Expression | Name                                                                     |\n"
"|:---------- |:------------------------------------------------------------------------ |\n"
"| `~x`       | bitwise not                                                              |\n"
"| `x & y`    | bitwise and                                                              |\n"
"| `x \\| y`   | bitwise or                                                               |\n"
"| `x â» y`    | bitwise xor (exclusive or)                                               |\n"
"| `x >>> y`  | [logical shift](https://en.wikipedia.org/wiki/Logical_shift) right       |\n"
"| `x >> y`   | [arithmetic shift](https://en.wikipedia.org/wiki/Arithmetic_shift) right |\n"
"| `x << y`   | logical/arithmetic shift left                                            |\n"
msgstr ""
"| å¼ | åå                                                                     |\n"
"|:---------- |:------------------------------------------------------------------------ |\n"
"| `~x`       | å¦å®(not)                                                              |\n"
"| `x & y`    | è«çç©(and)                                                              |\n"
"| `x \\| y`   | è«çå(or)                                                               |\n"
"| `x â» y`    | æä»çè«çå(xor)                                               |\n"
"| `x >>> y`  | å³[è«çã·ãã](https://en.wikipedia.org/wiki/Logical_shift)        |\n"
"| `x >> y`   | å³[ç®è¡ã·ãã](https://en.wikipedia.org/wiki/Arithmetic_shift)  |\n"
"| `x << y`   | å·¦ è«ç/ç®è¡ã·ãã                                            |\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:70
msgid "Here are some examples with bitwise operators:"
msgstr "ãããæ¼ç®å­ãä½¿ç¨ä¾ãä¸è¨ã®éãã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:71
#, no-wrap
msgid ""
"julia> ~123\n"
"-124\n"
"\n"
"julia> 123 & 234\n"
"106\n"
"\n"
"julia> 123 | 234\n"
"251\n"
"\n"
"julia> 123 â» 234\n"
"145\n"
"\n"
"julia> xor(123, 234)\n"
"145\n"
"\n"
"julia> ~UInt32(123)\n"
"0xffffff84\n"
"\n"
"julia> ~UInt8(123)\n"
"0x84\n"
msgstr ""
"julia> ~123\n"
"-124\n"
"\n"
"julia> 123 & 234\n"
"106\n"
"\n"
"julia> 123 | 234\n"
"251\n"
"\n"
"julia> 123 â» 234\n"
"145\n"
"\n"
"julia> xor(123, 234)\n"
"145\n"
"\n"
"julia> ~UInt32(123)\n"
"0xffffff84\n"
"\n"
"julia> ~UInt8(123)\n"
"0x84\n"

#. type: Title ##
#: ext/julia/doc/src/manual/mathematical-operations.md:94
#, no-wrap
msgid "Updating operators"
msgstr "ä»£å¥æ¼ç®å­"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:100
msgid ""
"Every binary arithmetic and bitwise operator also has an updating version that assigns the result of the operation back into its left "
"operand. The updating version of the binary operator is formed by placing a `=` immediately after the operator. For example, writing `x += "
"3` is equivalent to writing `x = x + 3`:"
msgstr ""
"ãã¹ã¦ã®äºé æ¼ç®å­ã»ãããæ¼ç®å­ã§ã¯ãæä½ã®çµæãå·¦ã®æ¼ç®å­ã«ä»£å¥ãããã¼ã¸ã§ã³ã®æ¼ç®å­ãå­å¨ãã¾ããäºé æ¼ç®å­ã®ä»£å¥ãã¼ã¸ã§ã³ã¯ãåã®æ¼ç®"
"å­ã®ç´å¾ã« `=` ãã¤ãã¾ãããã¨ãã°ã`x += 3` ã¯`x = x + 3` ãæ¸ãã®ã¨åãã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:101
#, no-wrap
msgid ""
"julia> x = 1\n"
"1\n"
"\n"
"julia> x += 3\n"
"4\n"
"\n"
"julia> x\n"
"4\n"
msgstr ""
"julia> x = 1\n"
"1\n"
"\n"
"julia> x += 3\n"
"4\n"
"\n"
"julia> x\n"
"4\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:113
msgid "The updating versions of all the binary arithmetic and bitwise operators are:"
msgstr "ãã¹ã¦ã®äºé ç®è¡æ¼ç®å­ã¨ãããæ¼ç®å­ã®ä»£å¥ãã¼ã¸ã§ã³ã¯ä»¥ä¸ã®ã¨ããã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:114
#, no-wrap
msgid "+=  -=  *=  /=  \\=  Ã·=  %=  ^=  &=  |=  â»=  >>>=  >>=  <<=\n"
msgstr "+=  -=  *=  /=  \\=  Ã·=  %=  ^=  &=  |=  â»=  >>>=  >>=  <<=\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:121
#, no-wrap
msgid ""
"!!! note\n"
"    An updating operator rebinds the variable on the left-hand side. As a result, the type of the\n"
"    variable may change.\n"
msgstr ""
"!!! note\n"
"    ä»£å¥æ¼ç®å­ã¯ãå·¦è¾ºå´å¤æ°ã«åãã¤ã³ããè¡ãã¾ããçµæãå¤æ°ã®æ¹ãå¤ãããã¨ãããã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:125
#, no-wrap
msgid ""
"    ```jldoctest\n"
"    julia> x = 0x01; typeof(x)\n"
"    UInt8\n"
msgstr ""
"    ```jldoctest\n"
"    julia> x = 0x01; typeof(x)\n"
"    UInt8\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:128
#, no-wrap
msgid ""
"    julia> x *= 2 # Same as x = x * 2\n"
"    2\n"
msgstr ""
"    julia> x *= 2 # Same as x = x * 2\n"
"    2\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:132
#, no-wrap
msgid ""
"    julia> typeof(x)\n"
"    Int64\n"
"    ```\n"
msgstr ""
"    julia> typeof(x)\n"
"    Int64\n"
"    ```\n"

#. type: Title ##
#: ext/julia/doc/src/manual/mathematical-operations.md:133
#, no-wrap
msgid "[Vectorized \"dot\" operators](@id man-dot-operators)"
msgstr "[ãã¯ãã«åãã\"ããã\"æ¼ç®å­](@id man-dot-operators)"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:144
msgid ""
"For *every* binary operation like `^`, there is a corresponding \"dot\" operation `.^` that is *automatically* defined to perform `^` "
"element-by-element on arrays. For example, `[1,2,3] ^ 3` is not defined, since there is no standard mathematical meaning to \"cubing\" a "
"(non-square) array, but `[1,2,3] .^ 3` is defined as computing the elementwise (or \"vectorized\") result `[1^3, 2^3, 3^3]`.  Similarly for "
"unary operators like `!` or `â`, there is a corresponding `.â` that applies the operator elementwise."
msgstr ""
"*å¨ã¦ã®* `^` ã®ãããªäºé æ¼ç®å­ã«ã¯ãéåã®åè¦ç´ ã«å¯¾ãã¦ `^`ãå®è¡ãããããæ¼ç®å­ `.^`ãèªåçã«å®ç¾©ããã¾ãããã¨ãã°ã`[1,2,3] ^ 3` ã¯å®"
"ç¾©ããã¦ãã¾ãããéæ­£æ¹ã®éåã®3ä¹ã¯æ°å­¦çã«æå³ãæããªãããã§ãããããã`[1,2,3] .^ 3` ã¯è¦ç´ æ¯ã®è¨ç®ã¨ãã¦å®ç¾©ããããã®çµæã¯"
"`[1^3,2^3, 3^3]`ã¨ãªãã¾ããåæ§ã«ã`!` ã `â` ã®ãããªåé æ¼ç®å­ã®å ´åããæ¼ç®å­ãè¦ç´ çã«é©ç¨ããå¯¾å¿ãã `.â` ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:145
#, no-wrap
msgid ""
"julia> [1,2,3] .^ 3\n"
"3-element Array{Int64,1}:\n"
"  1\n"
"  8\n"
" 27\n"
msgstr ""
"julia> [1,2,3] .^ 3\n"
"3-element Array{Int64,1}:\n"
"  1\n"
"  8\n"
" 27\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:165
msgid ""
"More specifically, `a .^ b` is parsed as the [\"dot\" call](@ref man-vectorized)  `(^).(a,b)`, which performs a [broadcast](@ref "
"Broadcasting) operation: it can combine arrays and scalars, arrays of the same size (performing the operation elementwise), and even arrays "
"of different shapes (e.g.  combining row and column vectors to produce a matrix). Moreover, like all vectorized \"dot calls,\" these \"dot "
"operators\" are *fusing*. For example, if you compute `2 .* A.^2 .+ sin.(A)` (or equivalently `@. 2A^2 + sin(A)`, using the [`@.`](@ref "
"@__dot__) macro) for an array `A`, it performs a *single* loop over `A`, computing `2a^2 + sin(a)` for each element of `A`. In particular, "
"nested dot calls like `f.(g.(x))` are fused, and \"adjacent\" binary operators like `x .+ 3 .* x.^2` are equivalent to nested dot calls `(+)."
"(x, (*).(3, (^).(x, 2)))`."
msgstr ""
"å·ä½çã«ã¯ã`a.^ b` ã¯[\"ããã\"å¼ã³åºã](@ref man-vectorized)`(^).(a,b)`ã¨ãã¦è§£æããã¾ããããã¯ã[ãã­ã¼ãã­ã£ã¹ã](@ref Broadcasting) "
"æä½ãå®è¡ãã¾ã: éåã¨ã¹ã«ã©ã¼ãåä¸ãµã¤ãºã®éå2ã¤(è¦ç´ ãã¨ã®æ¼ç®å­é©ç¨)ããã¦ãç°ãªããµã¤ãºã®éå(ä¾ãã°ãè¡ãã¯ãã«ã¨åãã¯ãã«ã®ç©)ã§ã"
"ããçµã¿åããå©ç¨ã§ãã¾ããããã«ããã¹ã¦ã®ãã¯ãã«åããã\"ãããã³ã¼ã«\"ã¨åæ§ã«ããããã®ããããæ¼ç®å­ãã¯*èåç*ã§ãããã¨ãã°ãéå"
"`A`ã«å¯¾ãã¦ `2 .* A.^2 .+ sin(A)` (ãããã¯ã[`@`](@ref @__dot__) ãã¯ã­ãä½¿ç¨ãã¦`@. 2A^2 + sin(A)`ã¨ãæ¸ãã¾ãã)ãè¨ç®ããæã`A`ã®è¦ç´ ã«"
"é¢ããã«ã¼ãã*1å*å®è¡ã`2a^2 + sin(a)` ãåè¦ç´ ã«å¯¾ãã¦è¨ç®ãã¾ããç¹ã«ã`f.(g.(x))` ã®ãããªå¥ãå­ã«ãªã£ããããã³ã¼ã«ã¯èåããã`x.+ 3 ."
"* x.^2` ã®ãããª \"é£æ¥ãã\" äºé æ¼ç®å­ã¯å¥ãå­ã«ãªã£ããããã³ã¼ã« `(+) .(x, (*).(3,(^).(x, 2)))`ã¨ç­ä¾¡ã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:169
msgid ""
"Furthermore, \"dotted\" updating operators like `a .+= b` (or `@. a += b`) are parsed as `a .= a .+ b`, where `.=` is a fused *in-place* "
"assignment operation (see the [dot syntax documentation](@ref man-vectorized))."
msgstr ""
"ããã«ã`a.+= b` (ã¾ãã¯ `@. a += b`) ã®ãããª \"ãããã®ã¤ãã\" ä»£å¥æ¼ç®å­ã¯ `a= a .+ b` ã¨ãã¦è§£æããã`.=` ã¯èåããã *ã¤ã³ãã¬ã¼ã¹* "
"ä»£å¥ã¨ãªãã¾ã ([ãããæ§æãã­ã¥ã¡ã³ã](@ref man-vectorized)ãåç§ãã¦ãã ãã)ã"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:174
msgid ""
"Note the dot syntax is also applicable to user-defined operators.  For example, if you define `â(A,B) = kron(A,B)` to give a convenient "
"infix syntax `A â B` for Kronecker products ([`kron`](@ref)), then `[A,B] .â [C,D]` will compute `[AâC, BâD]` with no additional coding."
msgstr ""
"ãããæ§æã¯ãã¦ã¼ã¶ã¼ãå®ç¾©ããæ¼ç®å­ã«ãé©ç¨ã§ãã¾ãã ãã¨ãã°ãã¯ã­ã¼ããã«ã¼ç©([`kron`](@ref))ã«ä¾¿å©ãªã¤ã³äºé æ¼ç®æ§æ `A â B`ãä½¿ããã"
"ã«`â(A,B) = kron(A,B)` ãå®ç¾©ããå ´å ã`[A,B] .â[C,D]` ã¯è¿½å ã®ã³ã¼ãã£ã³ã°ãªãã§ `[AâB, BâD]` ãè¨ç®ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:179
msgid ""
"Combining dot operators with numeric literals can be ambiguous.  For example, it is not clear whether `1.+x` means `1. + x` or `1 .+ x`.  "
"Therefore this syntax is disallowed, and spaces must be used around the operator in such cases."
msgstr ""
"ãããæ¼ç®å­ã¨æ°å¤ãªãã©ã«ã®çµã¿åãããããã¾ãã«ãªãå ´åãããã¾ãã ãã¨ãã°ã`1.+x` ã `1. +x` ã¨ `1 .+ x`ã®ã©ã¡ããæå³ãããã¯èªæã§ã¯"
"ããã¾ããããããã£ã¦ããã®æ§æã¯è¨±å¯ãããããã®ãããªå ´åã¯æ¼ç®å­ã®å¨å²ã«ã¹ãã¼ã¹ãä½¿ç¨ããå¿è¦ãããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/mathematical-operations.md:180
#, no-wrap
msgid "Numeric Comparisons"
msgstr "[æ°å¤æ¯è¼](@id numeric-comparisons)"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:183
msgid "Standard comparison operations are defined for all the primitive numeric types:"
msgstr "ãã¹ã¦ã®ããªããã£ãæ°å¤åã«å¯¾ãã¦æ¨æºçãªæ¯è¼æ¼ç®å­ãå®ç¾©ããã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:192
#, no-wrap
msgid ""
"| Operator                     | Name                     |\n"
"|:---------------------------- |:------------------------ |\n"
"| [`==`](@ref)                 | equality                 |\n"
"| [`!=`](@ref), [`â `](@ref !=) | inequality               |\n"
"| [`<`](@ref)                  | less than                |\n"
"| [`<=`](@ref), [`â¤`](@ref <=) | less than or equal to    |\n"
"| [`>`](@ref)                  | greater than             |\n"
"| [`>=`](@ref), [`â¥`](@ref >=) | greater than or equal to |\n"
msgstr ""
"| æ¼ç®å­                     | åå                     |\n"
"|:---------------------------- |:------------------------ |\n"
"| [`==`](@ref)                 | ç­å·                 |\n"
"| [`!=`](@ref), [`â `](@ref !=) | inequality               |\n"
"| [`<`](@ref)                  | æªæº                |\n"
"| [`<=`](@ref), [`â¤`](@ref <=) | ä»¥ä¸    |\n"
"| [`>`](@ref)                  | ããå¤§ãã             |\n"
"| [`>=`](@ref), [`â¥`](@ref >=) | ä»¥ä¸ |\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:194
msgid "Here are some simple examples:"
msgstr "ç°¡åãªä¾ãæ¬¡ã«ç¤ºãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:195
#, no-wrap
msgid ""
"julia> 1 == 1\n"
"true\n"
"\n"
"julia> 1 == 2\n"
"false\n"
"\n"
"julia> 1 != 2\n"
"true\n"
"\n"
"julia> 1 == 1.0\n"
"true\n"
"\n"
"julia> 1 < 2\n"
"true\n"
"\n"
"julia> 1.0 > 3\n"
"false\n"
"\n"
"julia> 1 >= 1.0\n"
"true\n"
"\n"
"julia> -1 <= 1\n"
"true\n"
"\n"
"julia> -1 <= -1\n"
"true\n"
"\n"
"julia> -1 <= -2\n"
"false\n"
"\n"
"julia> 3 < -0.5\n"
"false\n"
msgstr ""
"julia> 1 == 1\n"
"true\n"
"\n"
"julia> 1 == 2\n"
"false\n"
"\n"
"julia> 1 != 2\n"
"true\n"
"\n"
"julia> 1 == 1.0\n"
"true\n"
"\n"
"julia> 1 < 2\n"
"true\n"
"\n"
"julia> 1.0 > 3\n"
"false\n"
"\n"
"julia> 1 >= 1.0\n"
"true\n"
"\n"
"julia> -1 <= 1\n"
"true\n"
"\n"
"julia> -1 <= -1\n"
"true\n"
"\n"
"julia> -1 <= -2\n"
"false\n"
"\n"
"julia> 3 < -0.5\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:232
msgid ""
"Integers are compared in the standard manner -- by comparison of bits. Floating-point numbers are compared according to the [IEEE 754 "
"standard](https://en.wikipedia.org/wiki/IEEE_754-2008):"
msgstr ""
"æ´æ°ã¯ãæ¨æºçãªãããã®æ¯è¼ã®æ¹æ³ã§æ¯è¼ããã¾ããæµ®åå°æ°ç¹æ°ã¯[IEEE 754æ¨æº](https://en.wikipedia.org/wiki/IEEE_754-2008)ã«å¾ã£ã¦æ¯è¼ããã¾"
"ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/mathematical-operations.md:238
msgid "Finite numbers are ordered in the usual manner."
msgstr "æéæ°ã¯éå¸¸ã®æ¹æ³ã§é åºä»ãããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/mathematical-operations.md:238
msgid "Positive zero is equal but not greater than negative zero."
msgstr "æ­£ã®ã¼ã­ã¯è² ã®ã¼ã­ã¨ç­ãããè² ã®ã¼ã­ããå¤§ããã¯ãªãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/mathematical-operations.md:238
msgid "`Inf` is equal to itself and greater than everything else except `NaN`."
msgstr "`Inf` ã¯ããèªä½ã¨ç­ããã`NaN` ãé¤ãä»ã®ãã¹ã¦ãããå¤§ããã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/mathematical-operations.md:238
msgid "`-Inf` is equal to itself and less then everything else except `NaN`."
msgstr "`-Inf` ã¯ããèªä½ã«ç­ããã`NaN` ãé¤ãä»ã®ãã¹ã¦ã®æ°ããå°ããã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/mathematical-operations.md:238
msgid "`NaN` is not equal to, not less than, and not greater than anything, including itself."
msgstr "ãNaNãã¯ãããèªä½ãå«ããä½ã¨ãç­ãããªããå¤§ãããå°ããããªãã"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:240
msgid "The last point is potentially surprising and thus worth noting:"
msgstr "æå¾ã®ãã¤ã³ãã¯ãã²ãã£ã¨ããã¨é©ãã¹ããã¨ã§ããããããã£ã¦æ³¨ç®ã«å¤ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:241
#, no-wrap
msgid ""
"julia> NaN == NaN\n"
"false\n"
"\n"
"julia> NaN != NaN\n"
"true\n"
"\n"
"julia> NaN < NaN\n"
"false\n"
"\n"
"julia> NaN > NaN\n"
"false\n"
msgstr ""
"julia> NaN == NaN\n"
"false\n"
"\n"
"julia> NaN != NaN\n"
"true\n"
"\n"
"julia> NaN < NaN\n"
"false\n"
"\n"
"julia> NaN > NaN\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:256
msgid "and can cause headaches when working with [arrays](@ref man-multi-dim-arrays):"
msgstr "ã¾ãã[éå](@ref man-multi-dim-arrays) ã¨ä¸ç·ã«ä½¿ãã¨ãã«ã¯ãé ­çã®ç¨®ã«ãªããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:257
#, no-wrap
msgid ""
"julia> [1 NaN] == [1 NaN]\n"
"false\n"
msgstr ""
"julia> [1 NaN] == [1 NaN]\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:264
msgid "Julia provides additional functions to test numbers for special values, which can be useful in situations like hash key comparisons:"
msgstr "Julia ã§ã¯ãç¹æ®ãªå¤ãæ¤æ»ããè£å©çãªé¢æ°ãæä¾ããã¦ãããããã·ã¥ ã­ã¼ã®æ¯è¼ãªã©ã§å½¹ç«ã¡ã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:271
#, no-wrap
msgid ""
"| Function                | Tests if                  |\n"
"|:----------------------- |:------------------------- |\n"
"| [`isequal(x, y)`](@ref) | `x` and `y` are identical |\n"
"| [`isfinite(x)`](@ref)   | `x` is a finite number    |\n"
"| [`isinf(x)`](@ref)      | `x` is infinite           |\n"
"| [`isnan(x)`](@ref)      | `x` is not a number       |\n"
msgstr ""
"| é¢æ°                | æ¤æ»åå®¹                  |\n"
"|:----------------------- |:------------------------- |\n"
"| [`isequal(x, y)`](@ref) | `x` ã¨ `y` ãç­ããã |\n"
"| [`isfinite(x)`](@ref)   | `x` ã¯æéã§ããã    |\n"
"| [`isinf(x)`](@ref)      | `x` ã¯ç¡éå¤§ã§ããã           |\n"
"| [`isnan(x)`](@ref)      | `x` is NaNã§ããã       |\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:273
msgid "[`isequal`](@ref) considers `NaN`s equal to each other:"
msgstr "[`isequal`](@ref) ã¯ `NaN` ãäºãã«ç­ããã¨è¦ãªãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:274
#, no-wrap
msgid ""
"julia> isequal(NaN, NaN)\n"
"true\n"
"\n"
"julia> isequal([1 NaN], [1 NaN])\n"
"true\n"
"\n"
"julia> isequal(NaN, NaN32)\n"
"true\n"
msgstr ""
"julia> isequal(NaN, NaN)\n"
"true\n"
"\n"
"julia> isequal([1 NaN], [1 NaN])\n"
"true\n"
"\n"
"julia> isequal(NaN, NaN32)\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:286
msgid "`isequal` can also be used to distinguish signed zeros:"
msgstr "`isequal` ã¯ãç¬¦å·ä»ãã¼ã­ãåºå¥ããããã«ãä½¿ç¨ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:287
#, no-wrap
msgid ""
"julia> -0.0 == 0.0\n"
"true\n"
"\n"
"julia> isequal(-0.0, 0.0)\n"
"false\n"
msgstr ""
"julia> -0.0 == 0.0\n"
"true\n"
"\n"
"julia> isequal(-0.0, 0.0)\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:297
msgid ""
"Mixed-type comparisons between signed integers, unsigned integers, and floats can be tricky. A great deal of care has been taken to ensure "
"that Julia does them correctly."
msgstr ""
"ç¬¦å·ä»ãæ´æ°ãç¬¦å·ãªãæ´æ°ãããã³æµ®åå°æ°ç¹æ°ãæ··å¨ããæ¯è¼ã¯ãé£ããå ´åãããã¾ããJulia ãæ­£ããæ¯è¼ãè¡ãããã«ãå¤ãã®æ³¨æãæããã¦ã"
"ã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:302
msgid ""
"For other types, `isequal` defaults to calling [`==`](@ref), so if you want to define equality for your own types then you only need to add "
"a [`==`](@ref) method.  If you define your own equality function, you should probably define a corresponding [`hash`](@ref) method to ensure "
"that `isequal(x,y)` implies `hash(x) == hash(y)`."
msgstr ""
"ä»ã®åã«ã¤ãã¦ã¯ã`isequal` ã¯ããã©ã«ãã§ [`==`](@ref) ãå¼ã³åºãã®ã§ãç¬èªã®åã®ç­ä¾¡æ§ãå®ç¾©ããå ´åã¯ã[`==`](@ref) ã¡ã½ãããè¿½å ããã ã"
"ã§æ¸ã¿ã¾ãã ããã«ã`isequal(x,y)` ã `True`ã¨ãªãæã« `hash(x) == hash(y)`ã§ããããã¨ãä¿è¨¼ãããã®ã§ããã°ãå¯¾å¿ãã [`hash`](@ref) ã¡"
"ã½ãããå®ç¾©ããªããã°ãããªãã§ãããã"

#. type: Title ###
#: ext/julia/doc/src/manual/mathematical-operations.md:303
#, no-wrap
msgid "Chaining comparisons"
msgstr "æ¯è¼ã®é£é"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:307
msgid ""
"Unlike most languages, with the [notable exception of Python](https://en.wikipedia.org/wiki/"
"Python_syntax_and_semantics#Comparison_operators), comparisons can be arbitrarily chained:"
msgstr ""
"ã»ã¨ãã©ã®è¨èªã¨ã¯ç°ãªããJulia ã¯æ¯è¼ãä»»æã«é£éããããã¨ãã§ãã¾ãã(ã»ã¨ãã©ã®è¨èªã¨è¨ãã¾ãããã[ãªãã¨Pythonã¯æ¯è¼ã®é£éãã§ãã¾ã]"
"(https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Comparison_operators)ã)"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:308
#, no-wrap
msgid ""
"julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5\n"
"true\n"
msgstr ""
"julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:317
#, no-wrap
msgid ""
"Chaining comparisons is often quite convenient in numerical code. Chained comparisons use the\n"
"`&&` operator for scalar comparisons, and the [`&`](@ref) operator for elementwise comparisons,\n"
"which allows them to work on arrays. For example, `0 .< A .< 1` gives a boolean array whose entries\n"
"are true where the corresponding elements of `A` are between 0 and 1.\n"
msgstr "æ¯è¼ã®é£éã¯æ°å¤è¨ç®ã®ã³ã¼ãã§å¤§å¤ä¾¿å©ã«ä½¿ãããã¨ãå¤ãã§ããæ¯è¼ã®é£éã§ã¯ãã¹ã«ã©ã¼æ¯è¼ã«ã¯ `&&` æ¼ç®å­ãä½¿ããéåã«å¯¾ããè¦ç´ æ¯ã®æ¯è¼ã«ã¯ [`&`](@ref) æ¼ç®å­ãä½¿ãã¾ãããã¨ãã°ã`0 .<A.<1`ã¯ãéå`A`ã®è¦ç´ ã§0 ã¨ 1 ã®éã«ããè¦ç´ ã«å¯¾å¿ããä½ç½®ã®è¦ç´ ãtrueã§ãããããªçå½å¤ã®éåãè¿ãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:319
msgid "Note the evaluation behavior of chained comparisons:"
msgstr "æ¯è¼é£éã®æ¯ãèãã«æ³¨æãã¦ãã ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:320
#, no-wrap
msgid ""
"julia> v(x) = (println(x); x)\n"
"v (generic function with 1 method)\n"
"\n"
"julia> v(1) < v(2) <= v(3)\n"
"2\n"
"1\n"
"3\n"
"true\n"
"\n"
"julia> v(1) > v(2) <= v(3)\n"
"2\n"
"1\n"
"false\n"
msgstr ""
"julia> v(x) = (println(x); x)\n"
"v (generic function with 1 method)\n"
"\n"
"julia> v(1) < v(2) <= v(3)\n"
"2\n"
"1\n"
"3\n"
"true\n"
"\n"
"julia> v(1) > v(2) <= v(3)\n"
"2\n"
"1\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:341
#, no-wrap
msgid ""
"The middle expression is only evaluated once, rather than twice as it would be if the expression\n"
"were written as `v(1) < v(2) && v(2) <= v(3)`. However, the order of evaluations in a chained\n"
"comparison is undefined. It is strongly recommended not to use expressions with side effects (such\n"
"as printing) in chained comparisons. If side effects are required, the short-circuit `&&` operator\n"
"should be used explicitly (see [Short-Circuit Evaluation](@ref)).\n"
msgstr "çãä¸­ã®å¼ã¯ã`v(1) < v(2) && v(2) <= v(3)` ã¨æ¸ããã¦ãå ´åã®ããã«2åè©ä¾¡ãããã®ã§ã¯ãªãã1åã ãè©ä¾¡ããã¦ãã¾ãããã ããæ¯è¼é£éã®ä¸­ã§ã®è©ä¾¡ã®é åºã¯æªå®ç¾©ã§ãã(printãªã©ã®)å¯ä½ç¨ã®ããè¡¨ç¾ãä½¿ç¨ããªããã¨ãå¼·ããå§ããã¾ããããå¯ä½ç¨ãå¿è¦ãªå ´åã¯ãç­çµ¡æ¼ç®å­ `&&` ãæç¤ºçã«ä½¿ç¨ããå¿è¦ãããã¾ã(åç§: [ç­çµ¡è©ä¾¡](@ref short-circuit-evaluation))ã\n"

#. type: Title ###
#: ext/julia/doc/src/manual/mathematical-operations.md:342
#, no-wrap
msgid "Elementary Functions"
msgstr "[åç­é¢æ°](@id elementary-functions)"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:348
msgid ""
"Julia provides a comprehensive collection of mathematical functions and operators. These mathematical operations are defined over as broad a "
"class of numerical values as permit sensible definitions, including integers, floating-point numbers, rationals, and complex numbers, "
"wherever such definitions make sense."
msgstr ""
"Juliaã¯ä¸éãã®æ°å­¦é¢æ°ã¨ç®è¡æ¼ç®ãæä¾ãã¾ãããããã®ç®è¡æ¼ç®ã¯ããã®æå³ããªãéããæ´æ°ãæµ®åå°æ°ç¹æ°ãæçæ°ãè¤ç´ æ°ãªã©æ§ããªæ°å¤ã¯ã©ã¹"
"ã«å¯¾ãã¦å®ç¾©ããã¦ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:352
msgid ""
"Moreover, these functions (like any Julia function) can be applied in \"vectorized\" fashion to arrays and other collections with the [dot "
"syntax](@ref man-vectorized) `f.(A)`, e.g. `sin.(A)` will compute the sine of each element of an array `A`."
msgstr ""
"ããã«ããããã®é¢æ°ã¯(ä»ã®Juliaé¢æ°ã¨åæ§ã«)ãããã¯ãã«åãããå½¢ã§éåããã®ä»ã®ã³ã¬ã¯ã·ã§ã³ã«å¯¾ãã¦é©ç¨ãããã¨ãã§ãã¾ãããã®éã«ã¯ã"
"[`dotæ§æ`](@ref man-vectorized)`f.(A)`ãä½¿ããä¾ãã° `sin.(A)`ã¯éå`A`ã®åè¦ç´ ã«å¯¾ãã¦sinã®å¤ãé©ç¨ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/mathematical-operations.md:353
#, no-wrap
msgid "Operator Precedence and Associativity"
msgstr "[æ¼ç®å­ã®åªåé ä½ã¨çµåå](@id operator-precedence-and-associativity)"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:356
msgid "Julia applies the following order and associativity of operations, from highest precedence to lowest:"
msgstr "Julia ã§ã¯ãä¸è¨ã®åªåé ä½ã¨çµååã§ãä¸ããä¸ã¸ã¨æ¼ç®å­ãé©ç¨ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:373
#, no-wrap
msgid ""
"| Category       | Operators                                                                                         | Associativity              |\n"
"|:-------------- |:------------------------------------------------------------------------------------------------- |:-------------------------- |\n"
"| Syntax         | `.` followed by `::`                                                                              | Left                       |\n"
"| Exponentiation | `^`                                                                                               | Right                      |\n"
"| Unary          | `+ - â`                                                                                           | Right[^1]                  |\n"
"| Bitshifts      | `<< >> >>>`                                                                                       | Left                       |\n"
"| Fractions      | `//`                                                                                              | Left                       |\n"
"| Multiplication | `* / % & \\ Ã·`                                                                                     | Left[^2]                   |\n"
"| Addition       | `+ - \\| â»`                                                                                        | Left[^2]                   |\n"
"| Syntax         | `: ..`                                                                                            | Left                       |\n"
"| Syntax         | `\\|>`                                                                                             | Left                       |\n"
"| Syntax         | `<\\|`                                                                                             | Right                      |\n"
"| Comparisons    | `> < >= <= == === != !== <:`                                                                      | Non-associative            |\n"
"| Control flow   | `&&` followed by `\\|\\|` followed by `?`                                                           | Right                      |\n"
"| Pair           | `=>`                                                                                              | Right                      |\n"
"| Assignments    | `= += -= *= /= //= \\= ^= Ã·= %= \\|= &= â»= <<= >>= >>>=`                                            | Right                      |\n"
msgstr ""
"| ç¨®å¥       | æ¼ç®å­ã                                                                                         | çµåå              |\n"
"|:-------------- |:------------------------------------------------------------------------------------------------- |:-------------------------- |\n"
"| æ§æ         | ã¾ãã¯`.` æ¬¡ã« `::`                                                                              | å·¦                       |\n"
"| ç´¯ä¹ | `^`                                                                                               | å³                      |\n"
"| åé æ¼ç®å­          | `+ - â`                                                                                           | å³[^1]                  |\n"
"| ã·ãã      | `<< >> >>>`                                                                                       | å·¦                       |\n"
"| åæ°      | `//`                                                                                              | å·¦                       |\n"
"| ä¹ç® | `* / % & \\ Ã·`                                                                                     | å·¦[^2]                   |\n"
"| å ç®       | `+ - \\| â»`                                                                                        | å·¦[^2]                   |\n"
"| æ§æ         | `: ..`                                                                                            | å·¦                       |\n"
"| æ§æ         | `\\|>`                                                                                             | å·¦                       |\n"
"| æ§æ         | `<\\|`                                                                                             | å³                      |\n"
"| æ¯è¼    | `> < >= <= == === != !== <:`                                                                      | éçµå            |\n"
"| å¶å¾¡   | ã¾ãã¯ `&&` ãã®æ¬¡ã« `\\|\\|` ããã¦ `?`                                                           | å³                      |\n"
"| å¯¾          | `=>`                                                                                              | å³                      |\n"
"| ä»£å¥    | `= += -= *= /= //= \\= ^= Ã·= %= \\|= &= â»= <<= >>= >>>=`                                            | å³                      |\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:379
#, no-wrap
msgid ""
"[^1]:\n"
"    The unary operators `+` and `-` require explicit parentheses around their argument to disambiguate them from the operator `++`, etc. Other compositions of unary operators are parsed with right-associativity, e. g., `ââ-a` as `â(â(-a))`.\n"
"[^2]:\n"
"    The operators `+`, `++` and `*` are non-associative. `a + b + c` is parsed as `+(a, b, c)` not `+(+(a, b),\n"
"    c)`. However, the fallback methods for `+(a, b, c, d...)` and `*(a, b, c, d...)` both default to left-associative evaluation.\n"
msgstr ""
"[^1]:\n"
"    åé æ¼ç®å­ `+` ã¨ `-` ã«ã¯ãæç¤ºçã«æ¬å¼§ãã¤ãã¦ã`++`ãªã©ã®æ¼ç®å­ã¨ã®ææ§æ§ãæé¤ããå¿è¦ãããã¾ããä»ã®åé æ¼ç®å­ã®çµåã¯å³çµåã¨ãã¦è§£æããããä¾ãã°ã`ââ-a` ã¯ `â(â(-a))`ã¨è§£éããã¾ãã.\n"
"[^2]:\n"
"    æ¼ç®å­ `+`, `++`, `*` ã¯ãéçµåçã§ããã¤ã¾ã `a + b + c` ã¯ `+(+(a, b),c)`ã§ã¯ãªãã`+(a, b, c)` ã¨è§£æããã¾ãããã ããããã©ã¼ã«ããã¯ã¡ã½ããã®`+(a, b, c, d...)` ã `*(a, b, c, d...)` ã¯ã©ã¡ããããã©ã«ãã§ã¯å·¦çµåã§è©ä¾¡ããã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:382
msgid ""
"For a complete list of *every* Julia operator's precedence, see the top of this file: [`src/julia-parser.scm`](https://github.com/JuliaLang/"
"julia/blob/master/src/julia-parser.scm)"
msgstr ""
"Julia ã«ããã *å¨ã¦ã®* æ¼ç®å­ã®åªåé ä½ã®å®å¨ãªãªã¹ãã¯ããã®ãã¡ã¤ã«ã®ä¸é¨ãåç§ãã¦ãã ãã: [`src/julia-parser.scm`](https://github.com/"
"juliaLang/julia/blob/master/src/julia-parser.scm)"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:384
msgid ""
"[Numeric literal coefficients](@ref man-numeric-literal-coefficients), e.g. `2x`, are treated as multiplications with higher precedence than "
"any other binary operation, and also have higher precedence than `^`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:386
msgid ""
"You can also find the numerical precedence for any given operator via the built-in function `Base.operator_precedence`, where higher numbers "
"take precedence:"
msgstr "ã¾ããçµã¿è¾¼ã¿é¢æ° `Base.operator_precedence` ãä½¿ç¨ãã¦ãç¹å®ã®æ¼ç®å­ã®æ°å¤ã®åªåé ä½ãã¤ãã¨ãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:387
#, no-wrap
msgid ""
"julia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)\n"
"(11, 13, 17)\n"
"\n"
"julia> Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)\n"
"(0, 1, 1)\n"
msgstr ""
"julia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)\n"
"(11, 13, 17)\n"
"\n"
"julia> Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)\n"
"(0, 1, 1)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:396
msgid "A symbol representing the operator associativity can also be found by calling the built-in function `Base.operator_associativity`:"
msgstr "æ¼ç®å­ãè¡¨ãã·ã³ãã«ã®çµååãçµã¿è¾¼ã¿é¢æ° `Base.operator_associaivity` ãå¼ã³åºããã¨ã«ãã£ã¦ãè¦ã¤ãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:397
#, no-wrap
msgid ""
"julia> Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)\n"
"(:left, :none, :right)\n"
"\n"
"julia> Base.operator_associativity(:â), Base.operator_associativity(:sin), Base.operator_associativity(:â)\n"
"(:left, :none, :right)\n"
msgstr ""
"julia> Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)\n"
"(:left, :none, :right)\n"
"\n"
"julia> Base.operator_associativity(:â), Base.operator_associativity(:sin), Base.operator_associativity(:â)\n"
"(:left, :none, :right)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:407
msgid ""
"Note that symbols such as `:sin` return precedence `0`. This value represents invalid operators and not operators of lowest precedence. "
"Similarly, such operators are assigned associativity `:none`."
msgstr ""
"`:sin` ãªã©ã®ã·ã³ãã«ã¯ `0` ãè¿ãã¾ãããã®å¤ã¯å¼æ°ã«ä¸ããããã·ã³ãã«ãæ¼ç®å­ã¨ãã¦ç¡å¹ã§ãããã¨ãè¡¨ãã¦ããã ãã§ãåªåé ä½ãæãä½ãã¨"
"ãããã¨ã§ã¯ããã¾ãããåæ§ã«ããã®ãããªæ¼ç®å­ã«ã¯çµåæ§ã¯ `:none` ãå²ãå½ã¦ããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/mathematical-operations.md:408
#, no-wrap
msgid "Numerical Conversions"
msgstr "æ°å¤å¤æ"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:412
msgid "Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions."
msgstr "Julia ã¯ã3 ã¤ã®å½¢å¼ã®æ°å¤å¤æããµãã¼ããã¦ãã¾ããããããã¯ããããå³å¯ãªå¤æãã§ããªãã¨ãã®æ±ããç°ãªãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/mathematical-operations.md:414
msgid "The notation `T(x)` or `convert(T,x)` converts `x` to a value of type `T`."
msgstr "`T(x)` ã¾ãã¯ `convert(T,x)` ã¯ `x` ãå `T` ã®å¤ã«å¤æãã¾ãã"

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/mathematical-operations.md:423
msgid "If `T` is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity."
msgstr "`T` ãæµ®åå°æ°ç¹åã®å ´åãçµæã¯æãè¿ãè¡¨ç¾å¯è½ãªå¤ã§ãããæ­£ã¾ãã¯è² ã®ç¡éå¤§ã«ãªãå¯è½æ§ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:423
#, no-wrap
msgid ""
"      * If `T` is an integer type, an `InexactError` is raised if `x` is not representable by `T`.\n"
"  * `x % T` converts an integer `x` to a value of integer type `T` congruent to `x` modulo `2^n`,\n"
"    where `n` is the number of bits in `T`. In other words, the binary representation is truncated\n"
"    to fit.\n"
"  * The [Rounding functions](@ref) take a type `T` as an optional argument. For example, `round(Int,x)`\n"
"    is a shorthand for `Int(round(x))`.\n"
msgstr ""
"      * `T` ãæ´æ°åã®å ´å, `x` ã `T`ã§è¡¨ããªãå ´åã«ã¯`InexactError` ãçºçãã¾ãã.\n"
"  * `x % T` ã¯ `x` ãæ´æ°å `T`ã®ã`2^n` ãæ³ã¨ãã¦ã`x`ã¨ååãªæ°ã«å¤æãã¾ããããã§ `n` ã¯ `T`ã®ãããæ°ã§ããè¨ãæããã¨ã2é²æ°è¡¨ç¾ã `T` ã§è¡¨ç¾ã§ããããåãæ¨ã¦ããã¦ãã¾ãã\n"
"  * [ä¸¸ãé¢æ°](@ref Rounding-functions-infile) ã¯ãªãã·ã§ã³ã®å¼æ°ã¨ãã¦ãå `T` ãã¨ãã¾ããä¾ãã°, `round(Int,x)`ã¯ `Int(round(x))`ã®ç¥è¨ã§ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:425
msgid "The following examples show the different forms."
msgstr "ä»¥ä¸ã«ããããã®ä¾ãç¤ºãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:426
#, no-wrap
msgid ""
"julia> Int8(127)\n"
"127\n"
"\n"
"julia> Int8(128)\n"
"ERROR: InexactError: trunc(Int8, 128)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> Int8(127.0)\n"
"127\n"
"\n"
"julia> Int8(3.14)\n"
"ERROR: InexactError: Int8(3.14)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> Int8(128.0)\n"
"ERROR: InexactError: Int8(128.0)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> 127 % Int8\n"
"127\n"
"\n"
"julia> 128 % Int8\n"
"-128\n"
"\n"
"julia> round(Int8,127.4)\n"
"127\n"
"\n"
"julia> round(Int8,127.6)\n"
"ERROR: InexactError: trunc(Int8, 128.0)\n"
"Stacktrace:\n"
"[...]\n"
msgstr ""
"julia> Int8(127)\n"
"127\n"
"\n"
"julia> Int8(128)\n"
"ERROR: InexactError: trunc(Int8, 128)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> Int8(127.0)\n"
"127\n"
"\n"
"julia> Int8(3.14)\n"
"ERROR: InexactError: Int8(3.14)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> Int8(128.0)\n"
"ERROR: InexactError: Int8(128.0)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> 127 % Int8\n"
"127\n"
"\n"
"julia> 128 % Int8\n"
"-128\n"
"\n"
"julia> round(Int8,127.4)\n"
"127\n"
"\n"
"julia> round(Int8,127.6)\n"
"ERROR: InexactError: trunc(Int8, 128.0)\n"
"Stacktrace:\n"
"[...]\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:464
msgid "See [Conversion and Promotion](@ref conversion-and-promotion) for how to define your own conversions and promotions."
msgstr "ç¬èªã®å¤æã¨ææ ¼ãå®ç¾©ããæ¹æ³ã«ã¤ãã¦ã¯ã[å¤æã¨ææ ¼](@ref conversion-and-promotion)ãåç§ãã¦ãã ããã"

#. type: Title ###
#: ext/julia/doc/src/manual/mathematical-operations.md:465
#, no-wrap
msgid "Rounding functions"
msgstr "[ä¸¸ãé¢æ°](@id Rounding-functions-infile)"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:477
#, no-wrap
msgid ""
"| Function              | Description                      | Return type |\n"
"|:--------------------- |:-------------------------------- |:----------- |\n"
"| [`round(x)`](@ref)    | round `x` to the nearest integer | `typeof(x)` |\n"
"| [`round(T, x)`](@ref) | round `x` to the nearest integer | `T`         |\n"
"| [`floor(x)`](@ref)    | round `x` towards `-Inf`         | `typeof(x)` |\n"
"| [`floor(T, x)`](@ref) | round `x` towards `-Inf`         | `T`         |\n"
"| [`ceil(x)`](@ref)     | round `x` towards `+Inf`         | `typeof(x)` |\n"
"| [`ceil(T, x)`](@ref)  | round `x` towards `+Inf`         | `T`         |\n"
"| [`trunc(x)`](@ref)    | round `x` towards zero           | `typeof(x)` |\n"
"| [`trunc(T, x)`](@ref) | round `x` towards zero           | `T`         |\n"
msgstr ""
"| é¢æ°              | èª¬æ                      | æ»ãå¤ã®å |\n"
"|:--------------------- |:-------------------------------- |:----------- |\n"
"| [`round(x)`](@ref)    | `x` ãæãè¿ãæ´æ°ã«ä¸¸ãã | `typeof(x)` |\n"
"| [`round(T, x)`](@ref) | `x` ãæãè¿ãæ´æ°ã«ä¸¸ãã | `T`         |\n"
"| [`floor(x)`](@ref)    | `x` ã`-Inf` ã®æ¹åã«ä¸¸ãã         | `typeof(x)` |\n"
"| [`floor(T, x)`](@ref) | `x` ã`-Inf` ã®æ¹åã«ä¸¸ãã         | `T`         |\n"
"| [`ceil(x)`](@ref)     |  `x` ã `+Inf` ã®æ¹åã«ä¸¸ãã         | `typeof(x)` |\n"
"| [`ceil(T, x)`](@ref)  | `x` ã`+Inf` ã®æ¹åã«ä¸¸ãã         | `T`         |\n"
"| [`trunc(x)`](@ref)    | `x` ã ã¼ã­ã®æ¹åã«ä¸¸ãã           | `typeof(x)` |\n"
"| [`trunc(T, x)`](@ref) | `x` ãã¼ã­ã®æ¹åã«ä¸¸ãã           | `T`         |\n"

#. type: Title ###
#: ext/julia/doc/src/manual/mathematical-operations.md:478
#, no-wrap
msgid "Division functions"
msgstr "é¤ç®é¢æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:493
#, no-wrap
msgid ""
"| Function                  | Description                                                                                               |\n"
"|:------------------------- |:--------------------------------------------------------------------------------------------------------- |\n"
"| [`div(x,y)`](@ref), `xÃ·y` | truncated division; quotient rounded towards zero                                                         |\n"
"| [`fld(x,y)`](@ref)        | floored division; quotient rounded towards `-Inf`                                                         |\n"
"| [`cld(x,y)`](@ref)        | ceiling division; quotient rounded towards `+Inf`                                                         |\n"
"| [`rem(x,y)`](@ref)        | remainder; satisfies `x == div(x,y)*y + rem(x,y)`; sign matches `x`                                       |\n"
"| [`mod(x,y)`](@ref)        | modulus; satisfies `x == fld(x,y)*y + mod(x,y)`; sign matches `y`                                         |\n"
"| [`mod1(x,y)`](@ref)       | `mod` with offset 1; returns `râ(0,y]` for `y>0` or `râ[y,0)` for `y<0`, where `mod(r, y) == mod(x, y)`   |\n"
"| [`mod2pi(x)`](@ref)       | modulus with respect to 2pi;  `0 <= mod2pi(x) Â   < 2pi`                                                   |\n"
"| [`divrem(x,y)`](@ref)     | returns `(div(x,y),rem(x,y))`                                                                             |\n"
"| [`fldmod(x,y)`](@ref)     | returns `(fld(x,y),mod(x,y))`                                                                             |\n"
"| [`gcd(x,y...)`](@ref)     | greatest positive common divisor of `x`, `y`,...                                                          |\n"
"| [`lcm(x,y...)`](@ref)     | least positive common multiple of `x`, `y`,...                                                            |\n"
msgstr ""
"| é¢æ°                  | èª¬æ                                                                                               |\n"
"|:------------------------- |:--------------------------------------------------------------------------------------------------------- |\n"
"| [`div(x,y)`](@ref), `xÃ·y` | åãè½ã¨ãé¤ç®; ã¼ã­æ¹åã«ä¸¸ããå                                                         |\n"
"| [`fld(x,y)`](@ref)        | flooré¤ç®; `-Inf`æ¹åã«ä¸¸ããå                                                         |\n"
"| [`cld(x,y)`](@ref)        | ceilé¤ç®; `+Inf`æ¹åã«ä¸¸ããå                                                         |\n"
"| [`rem(x,y)`](@ref)        | å°ä½(remainder); `x == div(x,y)*y + rem(x,y)`; ç¬¦å·ã¯ `x` ã¨ä¸è´                                       |\n"
"| [`mod(x,y)`](@ref)        | å°ä½(modulus); `x == fld(x,y)*y + mod(x,y)`; ç¬¦å·ã¯ `y` ã¨ä¸è´                                         |\n"
"| [`mod1(x,y)`](@ref)       | 1ãªãã»ããããã`mod`; `mod(r, y) == mod(x, y)` ãæºãã `y>0`ã®å ´å `râ(0,y]`ã`y<0` ã®å ´å `râ[y,0)` ã¨ãªããããª `r`ãè¿ã    |\n"
"| [`mod2pi(x)`](@ref)       | 2pi ãæ³ã¨ããå°ä½;  `0 <= mod2pi(x) < 2pi`                                       |\n"
"| [`divrem(x,y)`](@ref)     | `(div(x,y),rem(x,y))`ãè¿ã                                                                      |\n"
"| [`fldmod(x,y)`](@ref)     | `(fld(x,y),mod(x,y))`ãè¿ã                                                                     |\n"
"| [`gcd(x,y...)`](@ref)     | `x`, `y`,... ã®æ­£ã®æå¤§å¬ç´æ° (greatest positive common divisor)          |\n"
"| [`lcm(x,y...)`](@ref)     | `x`, `y`,... ã®æ­£ã®æå°å¬åæ° (least positive common multiple)              |\n"

#. type: Title ###
#: ext/julia/doc/src/manual/mathematical-operations.md:494
#, no-wrap
msgid "Sign and absolute value functions"
msgstr "ç¬¦å·é¢æ°ã¨çµ¶å¯¾å¤é¢æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:504
#, no-wrap
msgid ""
"| Function                | Description                                                |\n"
"|:----------------------- |:---------------------------------------------------------- |\n"
"| [`abs(x)`](@ref)        | a positive value with the magnitude of `x`                 |\n"
"| [`abs2(x)`](@ref)       | the squared magnitude of `x`                               |\n"
"| [`sign(x)`](@ref)       | indicates the sign of `x`, returning -1, 0, or +1          |\n"
"| [`signbit(x)`](@ref)    | indicates whether the sign bit is on (true) or off (false) |\n"
"| [`copysign(x,y)`](@ref) | a value with the magnitude of `x` and the sign of `y`      |\n"
"| [`flipsign(x,y)`](@ref) | a value with the magnitude of `x` and the sign of `x*y`    |\n"
msgstr ""
"| é¢æ°                | èª¬æ                                                |\n"
"|:----------------------- |:---------------------------------------------------------- |\n"
"| [`abs(x)`](@ref)        |  `x` ã®çµ¶å¯¾å¤                |\n"
"| [`abs2(x)`](@ref)       | `x` ã®çµ¶å¯¾å¤ã®äºä¹                               |\n"
"| [`sign(x)`](@ref)       |  `x` ã®ç¬¦å·ã returning -1, 0, +1 ã®ãããããè¿ã          |\n"
"| [`signbit(x)`](@ref)    | ãµã¤ã³ããããç«ã£ã¦ãããã©ãã true/false ãè¿ã |\n"
"| [`copysign(x,y)`](@ref) | `sign(y) * abs(x)` ãè¿ã    |\n"
"| [`flipsign(x,y)`](@ref) | `sign(x*y) * abs(x)` ãè¿ã    |\n"

#. type: Title ###
#: ext/julia/doc/src/manual/mathematical-operations.md:505
#, no-wrap
msgid "Powers, logs and roots"
msgstr "ç´¯ä¹ã»å¯¾æ°ã»å¹³æ¹æ ¹"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:522
#, no-wrap
msgid ""
"| Function                 | Description                                                                |\n"
"|:------------------------ |:-------------------------------------------------------------------------- |\n"
"| [`sqrt(x)`](@ref), `âx`  | square root of `x`                                                         |\n"
"| [`cbrt(x)`](@ref), `âx`  | cube root of `x`                                                           |\n"
"| [`hypot(x,y)`](@ref)     | hypotenuse of right-angled triangle with other sides of length `x` and `y` |\n"
"| [`exp(x)`](@ref)         | natural exponential function at `x`                                        |\n"
"| [`expm1(x)`](@ref)       | accurate `exp(x)-1` for `x` near zero                                      |\n"
"| [`ldexp(x,n)`](@ref)     | `x*2^n` computed efficiently for integer values of `n`                     |\n"
"| [`log(x)`](@ref)         | natural logarithm of `x`                                                   |\n"
"| [`log(b,x)`](@ref)       | base `b` logarithm of `x`                                                  |\n"
"| [`log2(x)`](@ref)        | base 2 logarithm of `x`                                                    |\n"
"| [`log10(x)`](@ref)       | base 10 logarithm of `x`                                                   |\n"
"| [`log1p(x)`](@ref)       | accurate `log(1+x)` for `x` near zero                                      |\n"
"| [`exponent(x)`](@ref)    | binary exponent of `x`                                                     |\n"
"| [`significand(x)`](@ref) | binary significand (a.k.a. mantissa) of a floating-point number `x`        |\n"
msgstr ""
"| é¢æ°                 | èª¬æ                                                                |\n"
"|:------------------------ |:-------------------------------------------------------------------------- |\n"
"| [`sqrt(x)`](@ref), `âx`  | `x` ã®å¹³æ¹æ ¹                                                               |\n"
"| [`cbrt(x)`](@ref), `âx`  | `x` ã®ä¸ä¹æ ¹                                                               |\n"
"| [`hypot(x,y)`](@ref)     | ç´è§ãæã2è¾ºã®é·ãã`x`, `y` ã§ããç´è§ä¸è§å½¢ã®æè¾ºã®é·ã |\n"
"| [`exp(x)`](@ref)         | èªç¶ææ°é¢æ° ã® `x` ã§ã®å¤                                        |\n"
"| [`expm1(x)`](@ref)       | ã¼ã­è¿åã®`x` ã«å¯¾ãã `exp(x)-1`ã®æ­£ç¢ºãªå¤ãè¿ã   |\n"
"| [`ldexp(x,n)`](@ref)     | æ´æ°å¤ `n` ã«å¯¾ãã `x*2^n` ãå¹ççã«è¨ç®ãã    |\n"
"| [`log(x)`](@ref)         | èªç¶å¯¾æ°ã® `x` ã§ã®å¤                                                   |\n"
"| [`log(b,x)`](@ref)       | åº`b` ã®å¯¾æ°ã®`x` ã§ã®å¤                                             |\n"
"| [`log2(x)`](@ref)        | åº2 ã®å¯¾æ°ã®`x` ã§ã®å¤                                              |\n"
"| [`log10(x)`](@ref)       | åº10ã®å¯¾æ°ã®`x` ã§ã®å¤                                            |\n"
"| [`log1p(x)`](@ref)       | ã¼ã­è¿åã®`x` ã«å¯¾ãã `log(1+x)`ã®æ­£ç¢ºãªå¤          |\n"
"| [`exponent(x)`](@ref)    | æµ®åå°æ°ç¹`x` ã® 2ãåºæ°ã¨ããææ°é¨å             |\n"
"| [`significand(x)`](@ref) | æµ®åå°æ°ç¹ `x` ã® 2ãåºæ°ã¨ããä»®æ°é¨å            |\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:526
msgid ""
"For an overview of why functions like [`hypot`](@ref), [`expm1`](@ref), and [`log1p`](@ref)  are necessary and useful, see John D. Cook's "
"excellent pair of blog posts on the subject: [expm1, log1p, erfc](https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-"
"unnecessary/), and [hypot](https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/)."
msgstr ""
"[`hypot`](@ref)ã[`expm1`](@ref)ãããã³[`log1p`](@ref)ã®ãããªé¢æ°ãå¿è¦ãã¤æç¨ã§ããçç±æ¦èª¬ã«ã¤ãã¦ã¯ãJohn D. Cook ã®åªãããã­ã°æç¨¿ã"
"åç§ãã¦ãã ãã: [expm1, log1p,erfc](https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/)ãããã³ "
"[hypot](https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/)ã"

#. type: Title ###
#: ext/julia/doc/src/manual/mathematical-operations.md:527
#, no-wrap
msgid "Trigonometric and hyperbolic functions"
msgstr "ä¸è§é¢æ°ã¨åæ²ç·é¢æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:530
msgid "All the standard trigonometric and hyperbolic functions are also defined:"
msgstr "ãã¹ã¦ã®æ¨æºçãªä¸è§é¢æ°ã¨åæ²ç·é¢æ°ãå®ç¾©ããã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:531
#, no-wrap
msgid ""
"sin    cos    tan    cot    sec    csc\n"
"sinh   cosh   tanh   coth   sech   csch\n"
"asin   acos   atan   acot   asec   acsc\n"
"asinh  acosh  atanh  acoth  asech  acsch\n"
"sinc   cosc\n"
msgstr ""
"sin    cos    tan    cot    sec    csc\n"
"sinh   cosh   tanh   coth   sech   csch\n"
"asin   acos   atan   acot   asec   acsc\n"
"asinh  acosh  atanh  acoth  asech  acsch\n"
"sinc   cosc\n"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:541
msgid ""
"These are all single-argument functions, with [`atan`](@ref) also accepting two arguments corresponding to a traditional [`atan2`](https://"
"en.wikipedia.org/wiki/Atan2) function."
msgstr ""
"ãããã¯ãã¹ã¦åä¸å¼æ°é¢æ°ã§ããã[`atan`](@ref)ã¯2ã¤ã®å¼æ°ãã¨ããã¨ãã§ãããã®ã¨ãã¯ å¾æ¥ã®[`atan2`](https://en.wikipedia.org/wiki/Atan2) "
"é¢æ°ã®æ¯ãèãã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:544
msgid ""
"Additionally, [`sinpi(x)`](@ref) and [`cospi(x)`](@ref) are provided for more accurate computations of [`sin(pi*x)`](@ref) and [`cos(pi*x)`]"
"(@ref) respectively."
msgstr "ã¾ãã[`sinpi(x)`](@ref)ã¨[`cospi(x)`](@ref)ã¯ããããã[`sin(pi*x)`](@ref)ã¨[`cos(pi*x)`](@ref)ã®ããæ­£ç¢ºãªè¨ç®ã®ããã«æä¾ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:548
msgid ""
"In order to compute trigonometric functions with degrees instead of radians, suffix the function with `d`. For example, [`sind(x)`](@ref) "
"computes the sine of `x` where `x` is specified in degrees.  The complete list of trigonometric functions with degree variants is:"
msgstr ""
"ã©ã¸ã¢ã³ã®ä»£ããã«\"åº¦\"ãä½¿ç¨ãã¦ä¸è§é¢æ°ãè¨ç®ããã«ã¯ãé¢æ°ã®æ¥å°¾è¾ã `d` ã§å²ã¿ã¾ãããã¨ãã°ã[`sind(x)`](@ref)ã¯`x`ã\"åº¦\"ã§æå®ããã"
"`x`ã®sinãè¨ç®ãã¾ãã \"åº¦\"ãå¥åã«ä½¿ç¨ããä¸è§é¢æ°ã®å®å¨ãªãªã¹ãã¯æ¬¡ã®ã¨ããã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:549
#, no-wrap
msgid ""
"sind   cosd   tand   cotd   secd   cscd\n"
"asind  acosd  atand  acotd  asecd  acscd\n"
msgstr ""
"sind   cosd   tand   cotd   secd   cscd\n"
"asind  acosd  atand  acotd  asecd  acscd\n"

#. type: Title ###
#: ext/julia/doc/src/manual/mathematical-operations.md:554
#, no-wrap
msgid "Special functions"
msgstr "ç¹æ®é¢æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/mathematical-operations.md:557
msgid ""
"Many other special mathematical functions are provided by the package [SpecialFunctions.jl](https://github.com/JuliaMath/SpecialFunctions."
"jl)."
msgstr "ä»ã®å¤ãã®ç¹æ®é¢æ°ã¯ãããã±ã¼ã¸[SpecialFunctions.jl](https://github.com/JuliaMath/SpecialFunctions.jl)ã§æä¾ããã¦ãã¾ãã"

#. type: Title #
#: ext/julia/doc/src/manual/embedding.md:1
#, no-wrap
msgid "Embedding Julia"
msgstr "[Julia ã®åãè¾¼ã¿](@id embedding-julia)"

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:9
msgid ""
"As we have seen in [Calling C and Fortran Code](@ref), Julia has a simple and efficient way to call functions written in C. But there are "
"situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ "
"project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have "
"some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#)."
msgstr ""
"ãC ã¨ Fortran Code ãå¼ã³åºãã(@ref Calling-C-and-Fortran-Code)ã§è¦ã¦ããããã«ãJulia ã«ã¯ C ã§æ¸ãããé¢æ°ãå¼ã³åºãç°¡åã§å¹ççãªæ¹æ³ã"
"ããã¾ããããããéã®ãã¨ãå¿è¦ãªç¶æ³ãããã§ããã C ã³ã¼ããã Julia é¢æ°ãå¼ã³åºãã¨ãããã¨ã§ããããã¯ãJulia é¢æ°ãC/C++ ã§ãã¹ã¦ãæ¸"
"ãæãããã¨ãªããJulia ã³ã¼ããããå¤§ããª C/C+ãã­ã¸ã§ã¯ãã«çµ±åããããã«ä½¿ç¨ã§ãã¾ããã¸ã¥ãªã¢ã¯ãããå¯è½ã«ããC APIãæã£ã¦ãã¾ããã»ã¨"
"ãã©ãã¹ã¦ã®ãã­ã°ã©ãã³ã°è¨èªã¯Cé¢æ°ãå¼ã³åºãä½ããã®æ¹æ³ãæã£ã¦ããã®ã§ãJulia C APIãä½¿ç¨ãã¦ãããã«è¨èªããªãã¸ãæ§ç¯ãããã¨ãã§ãã¾"
"ã(ä¾ãã°ãPythonãC#ããJuliaãå¼ã³åºããªã©)ã"

#. type: Title ##
#: ext/julia/doc/src/manual/embedding.md:10
#, no-wrap
msgid "High-Level Embedding"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:14
msgid ""
"__Note__: This section covers embedding Julia code in C on Unix-like operating systems. For doing this on Windows, please see the section "
"following this."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:16
msgid "We start with a simple C program that initializes Julia and calls some Julia code:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/embedding.md:17 ext/julia/doc/src/manual/embedding.md:90 ext/julia/doc/src/manual/embedding.md:150
#: ext/julia/doc/src/manual/embedding.md:156 ext/julia/doc/src/manual/embedding.md:194 ext/julia/doc/src/manual/embedding.md:214
#: ext/julia/doc/src/manual/embedding.md:228 ext/julia/doc/src/manual/embedding.md:262 ext/julia/doc/src/manual/embedding.md:278
#: ext/julia/doc/src/manual/embedding.md:291 ext/julia/doc/src/manual/embedding.md:311 ext/julia/doc/src/manual/embedding.md:335
#: ext/julia/doc/src/manual/embedding.md:364 ext/julia/doc/src/manual/embedding.md:373 ext/julia/doc/src/manual/embedding.md:383
#: ext/julia/doc/src/manual/embedding.md:397 ext/julia/doc/src/manual/embedding.md:430 ext/julia/doc/src/manual/embedding.md:438
#: ext/julia/doc/src/manual/embedding.md:449 ext/julia/doc/src/manual/embedding.md:455 ext/julia/doc/src/manual/embedding.md:462
#: ext/julia/doc/src/manual/embedding.md:474 ext/julia/doc/src/manual/embedding.md:487 ext/julia/doc/src/manual/embedding.md:513
#: ext/julia/doc/src/manual/embedding.md:520 ext/julia/doc/src/manual/embedding.md:534 ext/julia/doc/src/manual/embedding.md:542
#: ext/julia/doc/src/manual/embedding.md:549 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:164
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:186 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:500
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:522 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:571
#: ext/julia/doc/src/devdocs/functions.md:36 ext/julia/doc/src/devdocs/functions.md:43 ext/julia/doc/src/devdocs/functions.md:114
#: ext/julia/doc/src/devdocs/stdio.md:7 ext/julia/doc/src/devdocs/stdio.md:15 ext/julia/doc/src/devdocs/stdio.md:26
#: ext/julia/doc/src/devdocs/stdio.md:100 ext/julia/doc/src/devdocs/init.md:42 ext/julia/doc/src/devdocs/init.md:96
#: ext/julia/doc/src/devdocs/llvm.md:126 ext/julia/doc/src/devdocs/gc-sa.md:109 ext/julia/doc/src/devdocs/gc-sa.md:151
#: ext/julia/doc/src/devdocs/gc-sa.md:170 ext/julia/doc/src/devdocs/gc-sa.md:189 ext/julia/doc/src/devdocs/gc-sa.md:212
#: ext/julia/doc/src/devdocs/gc-sa.md:230 ext/julia/doc/src/devdocs/object.md:9 ext/julia/doc/src/devdocs/object.md:16
#: ext/julia/doc/src/devdocs/object.md:26 ext/julia/doc/src/devdocs/object.md:33 ext/julia/doc/src/devdocs/object.md:41
#: ext/julia/doc/src/devdocs/object.md:47 ext/julia/doc/src/devdocs/object.md:64 ext/julia/doc/src/devdocs/object.md:75
#: ext/julia/doc/src/devdocs/object.md:81 ext/julia/doc/src/devdocs/object.md:101 ext/julia/doc/src/devdocs/object.md:108
#: ext/julia/doc/src/devdocs/object.md:116 ext/julia/doc/src/devdocs/object.md:128 ext/julia/doc/src/devdocs/object.md:138
#: ext/julia/doc/src/devdocs/object.md:151 ext/julia/doc/src/devdocs/object.md:157 ext/julia/doc/src/devdocs/object.md:164
#: ext/julia/doc/src/devdocs/object.md:180 ext/julia/doc/src/devdocs/object.md:188
#, no-wrap
msgid "c"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:17
#, no-wrap
msgid ""
"#include <julia.h>\n"
"JULIA_DEFINE_FAST_TLS() // only define this once, in an executable (not in a shared library) if you want fast code.\n"
"\n"
"int main(int argc, char *argv[])\n"
"{\n"
"    /* required: setup the Julia context */\n"
"    jl_init();\n"
"\n"
"    /* run Julia commands */\n"
"    jl_eval_string(\"print(sqrt(2.0))\");\n"
"\n"
"    /* strongly recommended: notify Julia that the\n"
"         program is about to terminate. this allows\n"
"         Julia time to cleanup pending write requests\n"
"         and run all finalizers\n"
"    */\n"
"    jl_atexit_hook(0);\n"
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:42
msgid ""
"In order to build this program you have to put the path to the Julia header into the include path and link against `libjulia`. For instance, "
"when Julia is installed to `$JULIA_DIR`, one can compile the above test program `test.c` with `gcc` using:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:43
#, no-wrap
msgid "gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib test.c -ljulia $JULIA_DIR/lib/julia/libstdc++.so.6\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:49
msgid "Then if the environment variable `JULIA_BINDIR` is set to `$JULIA_DIR/bin`, the output `test` program can be executed."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:53
msgid ""
"Alternatively, look at the `embedding.c` program in the Julia source tree in the `test/embedding/` folder.  The file `ui/repl.c` program is "
"another simple example of how to set `jl_options` options while linking against `libjulia`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:58
msgid ""
"The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling `jl_init`, "
"which tries to automatically determine Julia's install location. If you need to specify a custom location, or specify which system image to "
"load, use `jl_init_with_image` instead."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:60
msgid "The second statement in the test program evaluates a Julia statement using a call to `jl_eval_string`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:63
msgid ""
"Before the program terminates, it is strongly recommended to call `jl_atexit_hook`.  The above example program calls this before returning "
"from `main`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:67
#, no-wrap
msgid ""
"!!! note\n"
"    Currently, dynamically linking with the `libjulia` shared library requires passing the `RTLD_GLOBAL`\n"
"    option. In Python, this looks like:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:74
#, no-wrap
msgid ""
"    ```\n"
"    >>> julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)\n"
"    >>> julia.jl_init.argtypes = []\n"
"    >>> julia.jl_init()\n"
"    250593296\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:79
#, no-wrap
msgid ""
"!!! note\n"
"    If the julia program needs to access symbols from the main executable, it may be necessary to\n"
"    add `-Wl,--export-dynamic` linker flag at compile time on Linux in addition to the ones generated\n"
"    by `julia-config.jl` described below. This is not necessary when compiling a shared library.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/embedding.md:80
#, no-wrap
msgid "Using julia-config to automatically determine build parameters"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:87
msgid ""
"The script `julia-config.jl` was created to aid in determining what build parameters are required by a program that uses embedded Julia.  "
"This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary "
"compiler flags for an embedding program to interact with that distribution.  This script is located in the Julia shared data directory."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/manual/embedding.md:88
#, no-wrap
msgid "Example"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:90
#, no-wrap
msgid ""
"#include <julia.h>\n"
"\n"
"int main(int argc, char *argv[])\n"
"{\n"
"    jl_init();\n"
"    (void)jl_eval_string(\"println(sqrt(2.0))\");\n"
"    jl_atexit_hook(0);\n"
"    return 0;\n"
"}\n"
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/manual/embedding.md:102
#, no-wrap
msgid "On the command line"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:107
msgid ""
"A simple use of this script is from the command line.  Assuming that `julia-config.jl` is located in `/usr/local/julia/share/julia`, it can "
"be invoked on the command line directly and takes any combination of 3 flags:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:108
#, no-wrap
msgid ""
"/usr/local/julia/share/julia/julia-config.jl\n"
"Usage: julia-config [--cflags|--ldflags|--ldlibs]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:116
msgid ""
"If the above example source is saved in the file `embed_example.c`, then the following command will compile it into a running program on "
"Linux and Windows (MSYS2 environment), or if on OS/X, then substitute `clang` for `gcc`.:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:117
#, no-wrap
msgid "/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c\n"
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/manual/embedding.md:121
#, no-wrap
msgid "Use in Makefiles"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:129
msgid ""
"But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well â "
"assuming GNU make because of the use of the **shell** macro expansions.  Additionally, though many times `julia-config.jl` may be found in "
"the directory `/usr/local`, this is not necessarily the case, but Julia can be used to locate `julia-config.jl` too, and the makefile can be "
"used to take advantage of that.  The above example is extended to use a Makefile:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:130
#, no-wrap
msgid ""
"JL_SHARE = $(shell julia -e 'print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, \"julia\"))')\n"
"CFLAGS   += $(shell $(JL_SHARE)/julia-config.jl --cflags)\n"
"CXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)\n"
"LDFLAGS  += $(shell $(JL_SHARE)/julia-config.jl --ldflags)\n"
"LDLIBS   += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)\n"
"\n"
"all: embed_example\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:141
msgid "Now the build command is simply `make`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/embedding.md:142
#, no-wrap
msgid "High-Level Embedding on Windows with Visual Studio"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:146
msgid ""
"If the `JULIA_DIR` environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The `bin` folder "
"under JULIA_DIR should be on the system PATH."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:149
msgid ""
"We start by opening Visual Studio and creating a new Console Application project. To the 'stdafx.h' header file, add the following lines at "
"the end:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:150
#, no-wrap
msgid "#include <julia.h>\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:155
msgid "Then, replace the main() function in the project with this code:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:156
#, no-wrap
msgid ""
"int main(int argc, char *argv[])\n"
"{\n"
"    /* required: setup the Julia context */\n"
"    jl_init();\n"
"\n"
"    /* run Julia commands */\n"
"    jl_eval_string(\"print(sqrt(2.0))\");\n"
"\n"
"    /* strongly recommended: notify Julia that the\n"
"         program is about to terminate. this allows\n"
"         Julia time to cleanup pending write requests\n"
"         and run all finalizers\n"
"    */\n"
"    jl_atexit_hook(0);\n"
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:178
msgid ""
"The next step is to set up the project to find the Julia include files and the libraries. It's important to know whether the Julia "
"installation is 32- or 64-bits. Remove any platform configuration that doesn't correspond to the Julia installation before proceeding."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:183
msgid ""
"Using the project Properties dialog, go to `C/C++` | `General` and add `$(JULIA_DIR)\\include\\julia\\` to the Additional Include "
"Directories property. Then, go to the `Linker` | `General` section and add `$(JULIA_DIR)\\lib` to the Additional Library Directories "
"property. Finally, under `Linker` | `Input`, add `libjulia.dll.a;libopenlibm.dll.a;` to the list of libraries."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:185
msgid "At this point, the project should build and run."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/embedding.md:186
#, no-wrap
msgid "Converting Types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:193
msgid ""
"Real applications will not just need to execute expressions, but also return their values to the host program. `jl_eval_string` returns a "
"`jl_value_t*`, which is a pointer to a heap-allocated Julia object. Storing simple data types like [`Float64`](@ref) in this way is called "
"`boxing`, and extracting the stored primitive data is called `unboxing`. Our improved sample program that calculates the square root of 2 in "
"Julia and reads back the result in C looks as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:194
#, no-wrap
msgid ""
"jl_value_t *ret = jl_eval_string(\"sqrt(2.0)\");\n"
"\n"
"if (jl_typeis(ret, jl_float64_type)) {\n"
"    double ret_unboxed = jl_unbox_float64(ret);\n"
"    printf(\"sqrt(2.0) in C: %e \\n\", ret_unboxed);\n"
"}\n"
"else {\n"
"    printf(\"ERROR: unexpected return type from sqrt(::Float64)\\n\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:211
msgid ""
"In order to check whether `ret` is of a specific Julia type, we can use the `jl_isa`, `jl_typeis`, or `jl_is_...` functions.  By typing "
"`typeof(sqrt(2.0))` into the Julia shell we can see that the return type is [`Float64`](@ref) (`double` in C). To convert the boxed Julia "
"value into a C double the `jl_unbox_float64` function is used in the above code snippet."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:213
msgid "Corresponding `jl_box_...` functions are used to convert the other way:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:214
#, no-wrap
msgid ""
"jl_value_t *a = jl_box_float64(3.0);\n"
"jl_value_t *b = jl_box_float32(3.0f);\n"
"jl_value_t *c = jl_box_int32(3);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:221
msgid "As we will see next, boxing is required to call Julia functions with specific arguments."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/embedding.md:222
#, no-wrap
msgid "Calling Julia Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:227
msgid ""
"While `jl_eval_string` allows C to obtain the result of a Julia expression, it does not allow passing arguments computed in C to Julia. For "
"this you will need to invoke Julia functions directly, using `jl_call`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:228
#, no-wrap
msgid ""
"jl_function_t *func = jl_get_function(jl_base_module, \"sqrt\");\n"
"jl_value_t *argument = jl_box_float64(2.0);\n"
"jl_value_t *ret = jl_call1(func, argument);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:239
msgid ""
"In the first step, a handle to the Julia function `sqrt` is retrieved by calling `jl_get_function`.  The first argument passed to "
"`jl_get_function` is a pointer to the `Base` module in which `sqrt` is defined. Then, the double value is boxed using `jl_box_float64`. "
"Finally, in the last step, the function is called using `jl_call1`. `jl_call0`, `jl_call2`, and `jl_call3` functions also exist, to "
"conveniently handle different numbers of arguments. To pass more arguments, use `jl_call`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:240
#, no-wrap
msgid "jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:246
msgid "Its second argument `args` is an array of `jl_value_t*` arguments and `nargs` is the number of arguments."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/embedding.md:247
#, no-wrap
msgid "Memory Management"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:251
msgid ""
"As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:255
msgid ""
"Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that we are holding a reference to a "
"Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:261
msgid ""
"The GC can only run when Julia objects are allocated. Calls like `jl_box_float64` perform allocation, and allocation might also happen at "
"any point in running Julia code. However, it is generally safe to use pointers in between `jl_...` calls. But in order to make sure that "
"values can survive `jl_...` calls, we have to tell Julia that we hold a reference to a Julia value. This can be done using the `JL_GC_PUSH` "
"macros:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:262
#, no-wrap
msgid ""
"jl_value_t *ret = jl_eval_string(\"sqrt(2.0)\");\n"
"JL_GC_PUSH1(&ret);\n"
"// Do something with ret\n"
"JL_GC_POP();\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:273
msgid ""
"The `JL_GC_POP` call releases the references established by the previous `JL_GC_PUSH`. Note that `JL_GC_PUSH` stores references on the C "
"stack, so it must be exactly paired with a `JL_GC_POP` before the scope is exited. That is, before the function returns, or control flow "
"otherwise leaves the block in which the `JL_GC_PUSH` was invoked."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:277
msgid ""
"Several Julia values can be pushed at once using the `JL_GC_PUSH2` , `JL_GC_PUSH3` , `JL_GC_PUSH4` , `JL_GC_PUSH5` , and `JL_GC_PUSH6` "
"macros. To push an array of Julia values one can use the `JL_GC_PUSHARGS` macro, which can be used as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:278
#, no-wrap
msgid ""
"jl_value_t **args;\n"
"JL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects\n"
"args[0] = some_value;\n"
"args[1] = some_other_value;\n"
"// Do something with args (e.g. call jl_... functions)\n"
"JL_GC_POP();\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:290
msgid ""
"Each scope must have only one call to `JL_GC_PUSH*`. Hence, if all variables cannot be pushed once by a single call to `JL_GC_PUSH*`, or if "
"there are more than 6 variables to be pushed and using an array of arguments is not an option, then one can use inner blocks:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:291
#, no-wrap
msgid ""
"jl_value_t *ret1 = jl_eval_string(\"sqrt(2.0)\");\n"
"JL_GC_PUSH1(&ret1);\n"
"jl_value_t *ret2 = 0;\n"
"{\n"
"    jl_function_t *func = jl_get_function(jl_base_module, \"exp\");\n"
"    ret2 = jl_call1(func, ret1);\n"
"    JL_GC_PUSH1(&ret2);\n"
"    // Do something with ret2.\n"
"    JL_GC_POP();    // This pops ret2.\n"
"}\n"
"JL_GC_POP();    // This pops ret1.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:310
msgid ""
"If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use `JL_GC_PUSH*`. In "
"this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to "
"use a global `IdDict` that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with "
"mutable types."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:311
#, no-wrap
msgid ""
"// This functions shall be executed only once, during the initialization.\n"
"jl_value_t* refs = jl_eval_string(\"refs = IdDict()\");\n"
"jl_function_t* setindex = jl_get_function(jl_base_module, \"setindex!\");\n"
"\n"
"...\n"
"\n"
"// `var` is the variable we want to protect between function calls.\n"
"jl_value_t* var = 0;\n"
"\n"
"...\n"
"\n"
"// `var` is a `Vector{Float64}`, which is mutable.\n"
"var = jl_eval_string(\"[sqrt(2.0); sqrt(4.0); sqrt(6.0)]\");\n"
"\n"
"// To protect `var`, add its reference to `refs`.\n"
"jl_call3(setindex, refs, var, var);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:334
msgid ""
"If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a `RefValue{Any}` before it "
"is pushed to `IdDict`. In this approach, the container has to be created or filled in via C code using, for example, the function "
"`jl_new_struct`. If the container is created by `jl_call*`, then you will need to reload the pointer to be used in C code."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:335
#, no-wrap
msgid ""
"// This functions shall be executed only once, during the initialization.\n"
"jl_value_t* refs = jl_eval_string(\"refs = IdDict()\");\n"
"jl_function_t* setindex = jl_get_function(jl_base_module, \"setindex!\");\n"
"jl_datatype_t* reft = (jl_datatype_t*)jl_eval_string(\"Base.RefValue{Any}\");\n"
"\n"
"...\n"
"\n"
"// `var` is the variable we want to protect between function calls.\n"
"jl_value_t* var = 0;\n"
"\n"
"...\n"
"\n"
"// `var` is a `Float64`, which is immutable.\n"
"var = jl_eval_string(\"sqrt(2.0)\");\n"
"\n"
"// Protect `var` until we add its reference to `refs`.\n"
"JL_GC_PUSH1(&var);\n"
"\n"
"// Wrap `var` in `RefValue{Any}` and push to `refs` to protect it.\n"
"jl_value_t* rvar = jl_new_struct(reft, var);\n"
"JL_GC_POP();\n"
"\n"
"jl_call3(setindex, refs, rvar, rvar);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:363
msgid ""
"The GC can be allowed to deallocate a variable by removing the reference to it from `refs` using the function `delete!`, provided that no "
"other reference to the variable is kept anywhere:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:364
#, no-wrap
msgid ""
"jl_function_t* delete = jl_get_function(jl_base_module, \"delete!\");\n"
"jl_call2(delete, refs, rvar);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:372
msgid ""
"As an alternative for very simple cases, it is possible to just create a global container of type `Vector{Any}` and fetch the elements from "
"that when necessary, or even to create one global variable per pointer using"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:373
#, no-wrap
msgid "jl_set_global(jl_main_module, jl_symbol(\"var\"), var);\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/embedding.md:377
#, no-wrap
msgid "Updating fields of GC-managed objects"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:382
msgid ""
"The garbage collector operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any "
"time a pointer is updated breaking that assumption, it must be signaled to the collector with the `jl_gc_wb` (write barrier) function like "
"so:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:383
#, no-wrap
msgid ""
"jl_value_t *parent = some_old_value, *child = some_young_value;\n"
"((some_specific_type*)parent)->field = child;\n"
"jl_gc_wb(parent, child);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:393
msgid ""
"It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. "
"One notable exception is if the `parent` object was just allocated and garbage collection was not run since then. Remember that most `jl_..."
"` functions can sometimes invoke garbage collection."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:396
msgid "The write barrier is also necessary for arrays of pointers when updating their data directly.  For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:397
#, no-wrap
msgid ""
"jl_array_t *some_array = ...; // e.g. a Vector{Any}\n"
"void **data = (void**)jl_array_data(some_array);\n"
"jl_value_t *some_value = ...;\n"
"data[0] = some_value;\n"
"jl_gc_wb(some_array, some_value);\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/embedding.md:405
#, no-wrap
msgid "Manipulating the Garbage Collector"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:408
msgid "There are some functions to control the GC. In normal use cases, these should not be necessary."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:415
#, no-wrap
msgid ""
"| Function             | Description                                  |\n"
"|:-------------------- |:-------------------------------------------- |\n"
"| `jl_gc_collect()`    | Force a GC run                               |\n"
"| `jl_gc_enable(0)`    | Disable the GC, return previous state as int |\n"
"| `jl_gc_enable(1)`    | Enable the GC,  return previous state as int |\n"
"| `jl_gc_is_enabled()` | Return current state as int                  |\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/embedding.md:416
#, no-wrap
msgid "Working with Arrays"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:419
msgid "Julia and C can share array data without copying. The next example will show how this works."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:422
msgid "Julia arrays are represented in C by the datatype `jl_array_t*`. Basically, `jl_array_t` is a struct that contains:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/embedding.md:426
msgid "Information about the datatype"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/embedding.md:426
msgid "A pointer to the data block"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/embedding.md:426
msgid "Information about the sizes of the array"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:429
msgid "To keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is done by:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:430
#, no-wrap
msgid ""
"jl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);\n"
"jl_array_t* x          = jl_alloc_array_1d(array_type, 10);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:437
msgid "Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:438
#, no-wrap
msgid ""
"double *existingArray = (double*)malloc(sizeof(double)*10);\n"
"jl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:446
msgid ""
"The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call "
"`free` on the data pointer when the array is no longer referenced."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:448
msgid "In order to access the data of x, we can use `jl_array_data`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:449
#, no-wrap
msgid "double *xData = (double*)jl_array_data(x);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:454
msgid "Now we can fill the array:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:455
#, no-wrap
msgid ""
"for(size_t i=0; i<jl_array_len(x); i++)\n"
"    xData[i] = i;\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:461
msgid "Now let us call a Julia function that performs an in-place operation on `x`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:462
#, no-wrap
msgid ""
"jl_function_t *func = jl_get_function(jl_base_module, \"reverse!\");\n"
"jl_call1(func, (jl_value_t*)x);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:468
msgid "By printing the array, one can verify that the elements of `x` are now reversed."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/embedding.md:469
#, no-wrap
msgid "Accessing Returned Arrays"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:473
msgid "If a Julia function returns an array, the return value of `jl_eval_string` and `jl_call` can be cast to a `jl_array_t*`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:474
#, no-wrap
msgid ""
"jl_function_t *func  = jl_get_function(jl_base_module, \"reverse\");\n"
"jl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:481
msgid ""
"Now the content of `y` can be accessed as before using `jl_array_data`. As always, be sure to keep a reference to the array while it is in "
"use."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/embedding.md:482
#, no-wrap
msgid "Multidimensional Arrays"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:486
msgid ""
"Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its "
"properties:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:487
#, no-wrap
msgid ""
"// Create 2D array of float64 type\n"
"jl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);\n"
"jl_array_t *x  = jl_alloc_array_2d(array_type, 10, 5);\n"
"\n"
"// Get array pointer\n"
"double *p = (double*)jl_array_data(x);\n"
"// Get number of dimensions\n"
"int ndims = jl_array_ndims(x);\n"
"// Get the size of the i-th dim\n"
"size_t size0 = jl_array_dim(x,0);\n"
"size_t size1 = jl_array_dim(x,1);\n"
"\n"
"// Fill array with data\n"
"for(size_t i=0; i<size1; i++)\n"
"    for(size_t j=0; j<size0; j++)\n"
"        p[j + size0*i] = i + j;\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:508
msgid ""
"Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling `jl_array_dim`) in order to "
"read as idiomatic C code."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/embedding.md:509
#, no-wrap
msgid "Exceptions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:512
msgid "Julia code can throw exceptions. For example, consider:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:513
#, no-wrap
msgid "jl_eval_string(\"this_function_does_not_exist()\");\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:519
msgid "This call will appear to do nothing. However, it is possible to check whether an exception was thrown:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:520
#, no-wrap
msgid ""
"if (jl_exception_occurred())\n"
"    printf(\"%s \\n\", jl_typeof_str(jl_exception_occurred()));\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:528
msgid ""
"If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into "
"`libjulia` with a function that checks whether an exception was thrown, and then rethrows the exception in the host language."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/embedding.md:529
#, no-wrap
msgid "Throwing Julia Exceptions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:533
msgid ""
"When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions to indicate errors. A typical type "
"check looks like:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:534
#, no-wrap
msgid ""
"if (!jl_typeis(val, jl_float64_type)) {\n"
"    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);\n"
"}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:541
msgid "General exceptions can be raised using the functions:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:542
#, no-wrap
msgid ""
"void jl_error(const char *str);\n"
"void jl_errorf(const char *fmt, ...);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:548
msgid "`jl_error` takes a C string, and `jl_errorf` is called like `printf`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:549
#, no-wrap
msgid "jl_errorf(\"argument x = %d is too large\", x);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/embedding.md:553
msgid "where in this example `x` is assumed to be an integer."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/noteworthy-differences.md:1
#, no-wrap
msgid "Noteworthy Differences from other Languages"
msgstr "ä»ã®è¨èªã¨ã®æ³¨ç®ãã¹ãéã"

#. type: Title ##
#: ext/julia/doc/src/manual/noteworthy-differences.md:3
#, no-wrap
msgid "Noteworthy differences from MATLAB"
msgstr "MATLAB ã¨ã®æ³¨ç®ãã¹ãéã"

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:8
msgid ""
"Although MATLAB users may find Julia's syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. "
"The following are some noteworthy differences that may trip up Julia users accustomed to MATLAB:"
msgstr ""
"MATLAB ã¦ã¼ã¶ã¼ã¯ã¸ã¥ãªã¢ã®æ§æãè¦ªãã¿ãããã¨æãããããã¾ããããJuliaã¯ MATLAB ã¯ã­ã¼ã³ã§ã¯ããã¾ãããæ§æãæ©è½ã®éãã¯å¤§ããã§ãã"
"MATLAB ã«æ£ãã¦ããJuliaã¦ã¼ã¶ã¼ãã¤ã¾ãããããæ³¨ç®ãã¹ãéãã¯æ¬¡ã®ã¨ããã§ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:83
msgid "Julia arrays are indexed with square brackets, `A[i,j]`."
msgstr "Julia ã®éåã¯è§ãã£ãã§ `A[i,j]`ã®ããã«ã¤ã³ããã¯ã¹ä»ããããã"

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:83
#, no-wrap
msgid ""
"  * Julia arrays are not copied when assigned to another variable. After `A = B`, changing elements of `B` will modify `A`\n"
"    as well.\n"
"  * Julia values are not copied when passed to a function. If a function modifies an array, the changes\n"
"    will be visible in the caller.\n"
"  * Julia does not automatically grow arrays in an assignment statement. Whereas in MATLAB `a(4) = 3.2`\n"
"    can create the array `a = [0 0 0 3.2]` and `a(5) = 7` can grow it into `a = [0 0 0 3.2 7]`, the\n"
"    corresponding Julia statement `a[5] = 7` throws an error if the length of `a` is less than 5 or\n"
"    if this statement is the first use of the identifier `a`. Julia has [`push!`](@ref) and [`append!`](@ref),\n"
"    which grow `Vector`s much more efficiently than MATLAB's `a(end+1) = val`.\n"
"  * The imaginary unit `sqrt(-1)` is represented in Julia as [`im`](@ref), not `i` or `j` as in MATLAB.\n"
"  * In Julia, literal numbers without a decimal point (such as `42`) create integers instead of floating\n"
"    point numbers. As a result, some operations can throw\n"
"    a domain error if they expect a float; for example, `julia> a = -1; 2^a` throws a domain error, as the\n"
"    result is not an integer (see [the FAQ entry on domain errors](@ref faq-domain-errors) for details).\n"
"  * In Julia, multiple values are returned and assigned as tuples, e.g. `(a, b) = (1, 2)` or `a, b = 1, 2`.\n"
"    MATLAB's `nargout`, which is often used in MATLAB to do optional work based on the number of returned\n"
"    values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve\n"
"    similar capabilities.\n"
"  * Julia has true one-dimensional arrays. Column vectors are of size `N`, not `Nx1`. For example,\n"
"    [`rand(N)`](@ref) makes a 1-dimensional array.\n"
"  * In Julia, `[x,y,z]` will always construct a 3-element array containing `x`, `y` and `z`.\n"
"    - To concatenate in the first (\"vertical\") dimension use either [`vcat(x,y,z)`](@ref) or separate\n"
"      with semicolons (`[x; y; z]`).\n"
"    - To concatenate in the second (\"horizontal\") dimension use either [`hcat(x,y,z)`](@ref) or separate\n"
"      with spaces (`[x y z]`).\n"
"    - To construct block matrices (concatenating in the first two dimensions), use either [`hvcat`](@ref)\n"
"      or combine spaces and semicolons (`[a b; c d]`).\n"
"  * In Julia, `a:b` and `a:b:c` construct `AbstractRange` objects. To construct a full vector like in MATLAB,\n"
"    use [`collect(a:b)`](@ref). Generally, there is no need to call `collect` though. An `AbstractRange` object will\n"
"    act like a normal array in most cases but is more efficient because it lazily computes its values.\n"
"    This pattern of creating specialized objects instead of full arrays is used frequently, and is\n"
"    also seen in functions such as [`range`](@ref), or with iterators such as `enumerate`, and\n"
"    `zip`. The special objects can mostly be used as if they were normal arrays.\n"
"  * Functions in Julia return values from their last expression or the `return` keyword instead of\n"
"    listing the names of variables to return in the function definition (see [The return Keyword](@ref)\n"
"    for details).\n"
"  * A Julia script may contain any number of functions, and all definitions will be externally visible\n"
"    when the file is loaded. Function definitions can be loaded from files outside the current working\n"
"    directory.\n"
"  * In Julia, reductions such as [`sum`](@ref), [`prod`](@ref), and [`max`](@ref) are performed\n"
"    over every element of an array when called with a single argument, as in `sum(A)`, even if `A`\n"
"    has more than one dimension.\n"
"  * In Julia, parentheses must be used to call a function with zero arguments, like in [`rand()`](@ref).\n"
"  * Julia discourages the use of semicolons to end statements. The results of statements are not\n"
"    automatically printed (except at the interactive prompt), and lines of code do not need to end\n"
"    with semicolons. [`println`](@ref) or [`@printf`](@ref) can be used to print specific output.\n"
"  * In Julia, if `A` and `B` are arrays, logical comparison operations like `A == B` do not return\n"
"    an array of booleans. Instead, use `A .== B`, and similarly for the other boolean operators like\n"
"    [`<`](@ref), [`>`](@ref).\n"
"  * In Julia, the operators [`&`](@ref), [`|`](@ref), and [`â»`](@ref xor) ([`xor`](@ref)) perform the\n"
"    bitwise operations equivalent to `and`, `or`, and `xor` respectively in MATLAB, and have precedence\n"
"    similar to Python's bitwise operators (unlike C). They can operate on scalars or element-wise\n"
"    across arrays and can be used to combine logical arrays, but note the difference in order of operations:\n"
"    parentheses may be required (e.g., to select elements of `A` equal to 1 or 2 use `(A .== 1) .| (A .== 2)`).\n"
"  * In Julia, the elements of a collection can be passed as arguments to a function using the splat\n"
"    operator `...`, as in `xs=[1,2]; f(xs...)`.\n"
"  * Julia's [`svd`](@ref) returns singular values as a vector instead of as a dense diagonal matrix.\n"
"  * In Julia, `...` is not used to continue lines of code. Instead, incomplete expressions automatically\n"
"    continue onto the next line.\n"
"  * In both Julia and MATLAB, the variable `ans` is set to the value of the last expression issued\n"
"    in an interactive session. In Julia, unlike MATLAB, `ans` is not set when Julia code is run in\n"
"    non-interactive mode.\n"
"  * Julia's `struct`s do not support dynamically adding fields at runtime, unlike MATLAB's `class`es.\n"
"    Instead, use a [`Dict`](@ref).\n"
"  * In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global\n"
"    scope.\n"
"  * In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the\n"
"    expression `x(x>3)` or in the statement `x(x>3) = []` to modify `x` in-place. In contrast, Julia\n"
"    provides the higher order functions [`filter`](@ref) and [`filter!`](@ref), allowing users\n"
"    to write `filter(z->z>3, x)` and `filter!(z->z>3, x)` as alternatives to the corresponding transliterations\n"
"    `x[x.>3]` and `x = x[x.>3]`. Using [`filter!`](@ref) reduces the use of temporary arrays.\n"
"  * The analogue of extracting (or \"dereferencing\") all elements of a cell array, e.g. in `vertcat(A{:})`\n"
"    in MATLAB, is written using the splat operator in Julia, e.g. as `vcat(A...)`.\n"
msgstr ""
"  * Juliaã§ã¯ãéåã¯ä»ã®å¤æ°ã«ä»£å¥ãã¦ãã³ãã¼ããã¾ããã `A = B`ã®å¾ã`B`ã®è¦ç´ ãå¤æ´ããã¨ `A`ãåæ§ã«å¤æ´ããã¾ãã\n"
"  * Juliaã§ã¯ãå¤ã¯é¢æ°ã«æ¸¡ããã¦ãã³ãã¼ããã¾ãããé¢æ°ãéåãå¤æ´ããã¨ããã®å¤æ´ã¯å¼ã³åºãåã«ãå½±é¿ãä¸ãã¾ãã\n"
"  * Juliaã§ã¯ãä»£å¥æã®ä¸­ã§éåã®ãµã¤ãºãèªåçã«æ¡å¼µããã¾ããã MATLABã§ã¯ `a(4)= 3.2`ã§`a = [0 0 0 3.2]`ãçæããããã®å¾`a(5)= 7`ã¨ããã¨` a = [0 0 0 3.2 7] `ã¨éåã®ãµã¤ãºãå¤§ãããªãã¾ããå¯¾ãã¦ãJuliaã§ `a [5] = 7`ã¨ããã¨ã`a`ã®é·ãã5ããå ´åããããã¯ããã®ä»£å¥å¼ãè­å¥å­`a`ãåãã¦ä½¿ç¨ããå¼ã§ããå ´åã«ã¯ãã¨ã©ã¼ãçºçãã¾ããJuliaã«ã¯ã[`push!`](@ref)é¢æ°ã[`append!`](@ref)é¢æ°ãããããã¯ãã«ã®ãµã¤ãºãæ¡å¼µããææ®µã¨ãã¦ãMATLABã® `a(end + 1)= val`ãããã¯ããã«å¹ççã§ãã\n"
"  * èæ°åä½ `sqrt(-1)`ã¯ãMATLABã§ã¯`i`ã` j`ãç¨ãããã¾ãããJuliaã§ã¯[`im`](@ref)ã¨è¡¨è¨ãã¾ãã\n"
"  * Juliaã§ã¯ãå°æ°ç¹ã®ãªãæ°å¤ãªãã©ã«( `42`ãªã©)ã¯æµ®åå°æ°ç¹ã§ã¯ãªãæ´æ°ãä½æãã¾ããä»»æã®å¤§ããªæ´æ°ãªãã©ã«ããµãã¼ãããã¦ãã¾ãããã®çµæãä¸é¨ã®æ¼ç®ã§ã¯ ä¾ãã° `julia> a = -1; 2^a` ã®ããã« æµ®åå°æ°ç¹ãæ³å®ãã¦ããå ´åããæ¼ç®çµæãæ´æ°ã§ã¯ãªããã¨ãããã¡ã¤ã³ã¨ã©ã¼ãçºçãã¾ã(è©³ç´°ã«ã¤ãã¦ã¯ã[ãã¡ã¤ã³ã¨ã©ã¼ã«é¢ããFAQ](@ref faq-domain-errors)ãåç§)ã\n"
"  * Juliaã§ã¯ãè¤æ°ã®å¤ãè¿ãããã¿ãã«ã¨ãã¦å²ãå½ã¦ããã¾ããä¾ãã° `(a,b) = (1,2)` ã `a, b = 1, 2` ã¨ããå·åã§ããMATLABã® `nargout`ã¯ãå¼ã³åºãå´ããæå¾ãããæ»ãå¤ã®æ°ã«åºã¥ãã¦é¸æçãªå¦çããè¡ããã®ã§ãMATLABã§ã¯ããä½¿ç¨ããã¾ãããJulia ã§ã¯ä½¿ç¨ã§ãã¾ãããä»£ããã«ãã¦ã¼ã¶ã¼ã¯ãªãã·ã§ã³å¼æ°ãã­ã¼ã¯ã¼ãå¼æ°ã®æ©è½ãä½¿ã£ã¦ãä¼¼ããããªãã¨ãã§ãã¾ãã\n"
"  * Juliaã¯çã®1æ¬¡åéåãæã£ã¦ãã¾ããåãã¯ãã«ã¯ããµã¤ãºã`N`ã§ã`Nx1`ã§ã¯ããã¾ãããä¾ãã°ã[`rand(N)`](@ref)ã¯1æ¬¡åéåãä½æãã¾ãã\n"
"  * Juliaã§ã¯ã `[xãyãz]`ã¯å¸¸ã« `x`ã` y`ã `z`ãå«ã3è¦ç´ ã®éåãæ§ç¯ãã¾ãã\n"
"    - æåã®( \"åç´æ¹åã®\")æ¬¡åã§é£çµããã«ã¯ã[`vcat(x, y, z)`](@ref)ãä½¿ãããéåã®è¦ç´ ãã»ãã³ã­ã³ã§åå²ãã¾ã( `[x; y; z]`)ã\n"
"    - 2çªç®ã®( \"æ°´å¹³æ¹åã®\")æ¬¡åã§é£çµããã«ã¯ã[`hcat(x, y, z)`](@ref)ãä½¿ãããéåã®è¦ç´ ãã¹ãã¼ã¹ã§åå²ãã¾ã( `[x y z]`)ã\n"
"    - ãã­ãã¯è¡åãæ§ç¯ãã(æåã®2ã¤ã®æ¬¡åã§é£çµãã)ã«ã¯ã[`hvcat`](@ref)ãä½¿ãããã¹ãã¼ã¹ã¨ã»ãã³ã­ã³ãçµã¿åããã¾ã( `[a b; c d]`)ã\n"
"  * Juliaã§ã¯ã `aï¼b`ã¨` aï¼bï¼c`ã¯ `AbstractRange`ãªãã¸ã§ã¯ããæ§æãã¾ãã MATLABã®ããã«å®å¨ãªãã¯ãã«ãä½æããã«ã¯ã[`collect(a:b)`](@ref)ãä½¿ç¨ãã¦ãã ãããããããä¸è¬çã«ã¯ `collect`ãå¼ã³åºãå¿è¦ã¯ããã¾ããã AbstractRangeãªãã¸ã§ã¯ãã¯ã»ã¨ãã©ã®ã±ã¼ã¹ã§éå¸¸ã®éåã®ããã«æ¯ãèãã¾ããããã®å¤ãéå»¶è¨ç®ããããããå¹ççã§ããå®å¨ãªéåã§ã¯ãªãç¹æ®åããããªãã¸ã§ã¯ããä½æããã¨ãããã®ãã¿ã¼ã³ã¯ããä½¿ç¨ããã¦ãã¦ã[`range`](@ref)ã®ãããªé¢æ°ãã` enumerate`ãã`zip` ã®ãããªã¤ãã¬ã¼ã¿ã§ãè¦ããã¾ããç¹æ®ãªãã¸ã§ã¯ãã¯ãéå¸¸ã®éåã®ããã«ä½¿ç¨ãããã¨ãã§ãã¾ãã\n"
"  * Juliaã®é¢æ°ã¯ãæå¾ã®å¼ã¾ãã¯ `return`ã­ã¼ã¯ã¼ãããæ»ãå¤ãè¿ãã¾ããMATLABã®ããã«ãé¢æ°å®ç¾©ã§æ»ãå¤ã®ååãåæããã®ã§ã¯ããã¾ããã(è©³ç´°ã¯[returnã­ã¼ã¯ã¼ã](@ref the-return-keyword)ãåç§)ã\n"
"  * Juliaã¹ã¯ãªããã«ã¯é¢æ°ãããã¤ã§ãå«ãããã¨ãã§ãããã¡ã¤ã«ãã­ã¼ããããã°ããã¹ã¦ã®é¢æ°å®ç¾©ã¯å¤é¨ããè¦ãã¾ããç¾å¨ã®ä½æ¥­ãã£ã¬ã¯ããªã®å¤ã«ãããã¡ã¤ã«ãããé¢æ°å®ç¾©ã¯ã­ã¼ããããã¨ãã§ãã¾ãã\n"
"  * Juliaã§ã¯ã[`sum`](@ref)ã[` prod`](@ref)ã[`max`](@ref)ã®ãããªç°¡ç´å¦çã¯ã`sum(A)`ã®ããã«åä¸ã®å¼æ°ã§å¼ã³åºãããå ´åãå¨ã¦ã®è¦ç´ ã«å¯¾ãã¦è¡ããã¾ãããã¨ã `A`ã2æ¬¡åä»¥ä¸ã ã£ãã¨ãã¦ããã§ãã\n"
"  * Juliaã§ã¯ã[`rand()`](@ref)ã®ããã«ãã¼ã­å¼æ°ã§é¢æ°ãå¼ã³åºãã«ã¯æ¬å¼§ãä½¿ç¨ããå¿è¦ãããã¾ãã\n"
"  * Juliaã¯ãæãçµäºããã®ã«ã»ãã³ã­ã³ãä½¿ç¨ãããã¨ãæ¨å¥¨ãã¦ãã¾ãããï¼å¯¾è©±å¼ãã­ã³ããã§ã®å®è¡ãé¤ãï¼å¼ã®çµæãèªååºåããã¾ããã®ã§ï¼åºåãæå¶ãããã®ã ã¨ãã¦ã)ã³ã¼ãã®è¡æ«ã«ã»ãã³ã­ã³ãä½¿ãå¿è¦ã¯ããã¾ããã[`println`](@ref)ã¾ãã¯[`@printf`](@ref)ãä½¿ã£ã¦ããªã³ãåºåãããã¨ãã§ãã¾ãã\n"
"  * Juliaã§ã¯ã `A`ã¨` B`ãéåã®å ´åã `A == B`ã®ãããªè«çæ¯è¼æ¼ç®ã¯çå½å¤ã®éåãè¿ãã¾ããã(è¦ç´ ãã¨ã®æ¯è¼çµæãæ¬²ããå ´åã«ã¯) ä»£ããã«`A.== B`ãä½¿ç¨ãã¦ãã ããã[`<`](@ref)ã[`>`](@ref)ãã®ãããªä»ã®ãã¼ã«æ¼ç®å­ã«ã¤ãã¦ãåæ§ã§ãã\n"
"  * Juliaã§ã¯ãæ¼ç®å­[`&`](@ref)ã[`|`](@ref)ãããã³[`â»`](@ref xor)([`xor`](@ref))ã§ãããããMATLABã«ããã `and`ã` or`ãããã³ `xor`ã¨ç­ä¾¡ãªãããæ¼ç®ãè¡ããã¾ããæ¼ç®ã®åªååº¦ã¯ãPythonã®ãããæ¼ç®å­ã«ä¼¼ã¦ãã¾ã(Cã¨ã¯ç°ãªãã¾ã)ããããã¯ã¹ã«ã©ã¼ã¾ãã¯è¦ç´ ãã¨ã«æä½ã§ããè«çéåã¨çµã¿åããããã¨ãã§ãã¾ãããæä½ã®é åºã®éãã«æ³¨æãã¦ãã ãã: æ¬å¼§ãå¿è¦ãªå ´åãããã¾ã(ä¾ãã°ã1ã¾ãã¯2ã«ç­ãã `A`ã®è¦ç´ ãé¸æããã«ã¯ã`(Aã== 1)|(Aã== 2) `ãä½¿ç¨ãã¾ã)ã\n"
"  * Juliaã§ã¯ãæ¥åæ¼ç®å­` ...` ãä½¿ã£ã¦`xs = [1,2]; f(xs...)`ã®ããã«ãã¦ãã³ã¬ã¯ã·ã§ã³ã®è¦ç´ ãå¼æ°ã¨ãã¦é¢æ°ã«æ¸¡ããã¨ãã§ãã¾ãã\n"
"Â Â * Juliaã®[`svd`](@ref)ã¯ç¹ç°å¤ãå¯ãªå¯¾è§è¡åã§ã¯ãªããã¯ãã«ã¨ãã¦è¿ãã¾ãã\n"
"Â Â * Juliaã§ã¯ã `...`ã¯ã³ã¼ãè¡ãç¶ç¶ããããã«ã¯ä½¿ç¨ããã¾ãããä»£ããã«ãä¸å®å¨ãªå¼ã¯èªåçã«ãæ¬¡ã®è¡ã¸ã¨è§£éãç¶ç¶ãã¾ãã\n"
"  * Juliaã¨MATLABã®ä¸¡æ¹ã§ãå¯¾è©±å¼ã»ãã·ã§ã³ã§ã¯ãå¤æ° `ans`ã¯æå¾ã«çºè¡ãããå¼ã®å¤ã«è¨­å®ããã¾ããã Juliaã§ã¯ãMATLABã¨ç°ãªããJuliaã³ã¼ããéã¤ã³ã¿ã©ã¯ãã£ãã¢ã¼ãã§å®è¡ãããã¨ãã«ã¯ã `ans`ã¯è¨­å®ããã¾ããã\n"
"  * Juliaã® `struct`ã¯ãMATLABã®` class`ã¨ã¯ç°ãªããå®è¡æã«åçãªãã£ã¼ã«ããè¿½å ããµãã¼ããã¾ãããä»£ããã«ã[`Dict`](@ref)ãä½¿ã£ã¦ãã ããã\n"
"  * Juliaã§ã¯åã¢ã¸ã¥ã¼ã«ã¯ç¬èªã®ã°ã­ã¼ãã«ã¹ã³ã¼ã/ååç©ºéãæã¡ã¾ãããMATLABã§ã¯1ã¤ã®ã°ã­ã¼ãã«ã¹ã³ã¼ãããããã¾ããã\n"
"  * MATLABã§ã¯ãä¸è¦ãªå¤ãåé¤ããããã®æ£ç¨çãªæ¹æ³ã¯ãæ¬¡ã®ããã«è«çã¤ã³ããã¯ã¹ãä½¿ç¨ãããã¨ãã§ã`x(x> 3)`ã¨ããã `x(x> 3)= []`ã¨`x`ãä¸æ¸ãããããã¾ããå¯¾ãã¦Juliaã§ã¯ãããé«æ¬¡ã®é¢æ°[`filter`](@ref)ã¨[`filter!`](@ref)ãå©ç¨ã§ãã¾ããMATLABã®ã³ã¼ãããã®ã¾ã¾Juliaã«æ¸ãæãã`x [x.> 3]`ã `x = x [x.> 3]` ã®ä»£ããã«ã`filter(z-> z> 3,x)`ãã`filter!(z-> z> 3,x)`ã¨æ¸ããã¨ãã§ãã¾ãã [`filter!`](@ref)ãä½¿ãã¨ä¸æéåã®ä½¿ç¨ãæ¸ãããã¨ãã§ãã¾ãã\n"
"  * ã»ã«éåã®ãã¹ã¦ã®è¦ç´ ãæ½åºãã(ã¤ã¾ããéæ¥åç§ããã)ã«ã¯ãMATLABã§ã¯`vertcat(A {:})`ãä½¿ããã¾ãããJulia ã§åæ§ã®ãã¨ãè¡ãã«ã¯ãæ¥åæ¼ç®å­ãä½¿ã£ã¦`vcat(A ...)`ã¨æ¸ãã¾ãã\n"

#. type: Title ##
#: ext/julia/doc/src/manual/noteworthy-differences.md:84
#, no-wrap
msgid "Noteworthy differences from R"
msgstr "R ã¨ã®æ³¨ç®ãã¹ãéã"

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:88
msgid ""
"One of Julia's goals is to provide an effective language for data analysis and statistical programming.  For users coming to Julia from R, "
"these are some noteworthy differences:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:99
msgid "Julia's single quotes enclose characters, not strings."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:99
msgid ""
"Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:99
msgid ""
"In Julia, like Python but unlike R, strings can be created with triple quotes `\"\"\" ... \"\"\"`. This syntax is convenient for "
"constructing strings that contain line breaks."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:99
msgid ""
"In Julia, varargs are specified using the splat operator `...`, which always follows the name of a specific variable, unlike R, for which "
"`...` can occur in isolation."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:99
msgid "In Julia, modulus is `mod(a, b)`, not `a %% b`. `%` in Julia is the remainder operator."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:99
msgid ""
"In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length "
"equal to the object being indexed. For example:"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:145
msgid "In R, `c(1, 2, 3, 4)[c(TRUE, FALSE)]` is equivalent to `c(1, 3)`."
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:145
msgid "In R, `c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]` is equivalent to `c(1, 3)`."
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:145
msgid "In Julia, `[1, 2, 3, 4][[true, false]]` throws a [`BoundsError`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:145
#, no-wrap
msgid ""
"      * In Julia, `[1, 2, 3, 4][[true, false, true, false]]` produces `[1, 3]`.\n"
"  * Like many languages, Julia does not always allow operations on vectors of different lengths, unlike\n"
"    R where the vectors only need to share a common index range.  For example, `c(1, 2, 3, 4) + c(1, 2)`\n"
"    is valid R but the equivalent `[1, 2, 3, 4] + [1, 2]` will throw an error in Julia.\n"
"  * Julia allows an optional trailing comma when that comma does not change the meaning of code.\n"
"    This can cause confusion among R users when indexing into arrays. For example, `x[1,]` in R\n"
"    would return the first row of a matrix; in Julia, however, the comma is ignored, so\n"
"    `x[1,] == x[1]`, and will return the first element. To extract a row, be sure to use `:`, as in `x[1,:]`.\n"
"  * Julia's [`map`](@ref) takes the function first, then its arguments, unlike `lapply(<structure>, function, ...)`\n"
"    in R. Similarly Julia's equivalent of `apply(X, MARGIN, FUN, ...)` in R is [`mapslices`](@ref)\n"
"    where the function is the first argument.\n"
"  * Multivariate apply in R, e.g. `mapply(choose, 11:13, 1:3)`, can be written as `broadcast(binomial, 11:13, 1:3)`\n"
"    in Julia. Equivalently Julia offers a shorter dot syntax for vectorizing functions `binomial.(11:13, 1:3)`.\n"
"  * Julia uses `end` to denote the end of conditional blocks, like `if`, loop blocks, like `while`/\n"
"    `for`, and functions. In lieu of the one-line `if ( cond ) statement`, Julia allows statements\n"
"    of the form `if cond; statement; end`, `cond && statement` and `!cond || statement`. Assignment\n"
"    statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. `cond && (x = value)`.\n"
"  * In Julia, `<-`, `<<-` and `->` are not assignment operators.\n"
"  * Julia's `->` creates an anonymous function.\n"
"  * Julia constructs vectors using brackets. Julia's `[1, 2, 3]` is the equivalent of R's `c(1, 2, 3)`.\n"
"  * Julia's [`*`](@ref) operator can perform matrix multiplication, unlike in R. If `A` and `B` are\n"
"    matrices, then `A * B` denotes a matrix multiplication in Julia, equivalent to R's `A %*% B`.\n"
"    In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise\n"
"    multiplication operation, you need to write `A .* B` in Julia.\n"
"  * Julia performs matrix transposition using the `transpose` function and conjugated transposition using\n"
"    the `'` operator or the `adjoint` function. Julia's `transpose(A)` is therefore equivalent to R's `t(A)`.\n"
"    Additionally a non-recursive transpose in Julia is provided by the `permutedims` function.\n"
"  * Julia does not require parentheses when writing `if` statements or `for`/`while` loops: use `for i in [1, 2, 3]`\n"
"    instead of `for (i in c(1, 2, 3))` and `if i == 1` instead of `if (i == 1)`.\n"
"  * Julia does not treat the numbers `0` and `1` as Booleans. You cannot write `if (1)` in Julia,\n"
"    because `if` statements accept only booleans. Instead, you can write `if true`, `if Bool(1)`,\n"
"    or `if 1==1`.\n"
"  * Julia does not provide `nrow` and `ncol`. Instead, use `size(M, 1)` for `nrow(M)` and `size(M, 2)`\n"
"    for `ncol(M)`.\n"
"  * Julia is careful to distinguish scalars, vectors and matrices.  In R, `1` and `c(1)` are the same.\n"
"    In Julia, they cannot be used interchangeably.\n"
"  * Julia's [`diag`](@ref) and [`diagm`](@ref) are not like R's.\n"
"  * Julia cannot assign to the results of function calls on the left hand side of an assignment operation:\n"
"    you cannot write `diag(M) = fill(1, n)`.\n"
"  * Julia discourages populating the main namespace with functions. Most statistical functionality\n"
"    for Julia is found in [packages](https://pkg.julialang.org/) under the [JuliaStats organization](https://github.com/JuliaStats).\n"
"    For example:\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:196
msgid ""
"Functions pertaining to probability distributions are provided by the [Distributions package](https://github.com/JuliaStats/Distributions."
"jl)."
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:196
msgid "The [DataFrames package](https://github.com/JuliaData/DataFrames.jl) provides data frames."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:196
#, no-wrap
msgid ""
"      * Generalized linear models are provided by the [GLM package](https://github.com/JuliaStats/GLM.jl).\n"
"  * Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items,\n"
"    you should typically use a tuple or a named tuple: instead of `list(a = 1, b = 2)`, use `(1, 2)`\n"
"    or `(a=1, b=2)`.\n"
"  * Julia encourages users to write their own types, which are easier to use than S3 or S4 objects\n"
"    in R. Julia's multiple dispatch system means that `table(x::TypeA)` and `table(x::TypeB)` act\n"
"    like R's `table.TypeA(x)` and `table.TypeB(x)`.\n"
"  * In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes\n"
"    will be visible in the caller. This is very different from R and allows new functions to operate\n"
"    on large data structures much more efficiently.\n"
"  * In Julia, vectors and matrices are concatenated using [`hcat`](@ref), [`vcat`](@ref) and\n"
"    [`hvcat`](@ref), not `c`, `rbind` and `cbind` like in R.\n"
"  * In Julia, a range like `a:b` is not shorthand for a vector like in R, but is a specialized `AbstractRange`\n"
"    object that is used for iteration without high memory overhead. To convert a range into a vector, use\n"
"    [`collect(a:b)`](@ref).\n"
"  * Julia's [`max`](@ref) and [`min`](@ref) are the equivalent of `pmax` and `pmin` respectively\n"
"    in R, but both arguments need to have the same dimensions.  While [`maximum`](@ref) and [`minimum`](@ref)\n"
"    replace `max` and `min` in R, there are important differences.\n"
"  * Julia's [`sum`](@ref), [`prod`](@ref), [`maximum`](@ref), and [`minimum`](@ref) are different\n"
"    from their counterparts in R. They all accept an optional keyword argument `dims`, which indicates the\n"
"    dimensions, over which the operation is carried out.  For instance, let `A = [1 2; 3 4]` in Julia\n"
"    and `B <- rbind(c(1,2),c(3,4))` be the same matrix in R.  Then `sum(A)` gives the same result as\n"
"    `sum(B)`, but `sum(A, dims=1)` is a row vector containing the sum over each column and `sum(A, dims=2)`\n"
"    is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate\n"
"    `colSums(B)` and `rowSums(B)` functions provide these functionalities. If the `dims` keyword argument is a\n"
"    vector, then it specifies all the dimensions over which the sum is performed, while retaining the\n"
"    dimensions of the summed array, e.g. `sum(A, dims=(1,2)) == hcat(10)`. It should be noted that there is no\n"
"    error checking regarding the second argument.\n"
"  * Julia has several functions that can mutate their arguments. For example, it has both [`sort`](@ref)\n"
"    and [`sort!`](@ref).\n"
"  * In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing\n"
"    code is often achieved by using devectorized loops.\n"
"  * Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this\n"
"    means that there are very few unquoted expressions or column names.\n"
"  * Julia does not support the `NULL` type. The closest equivalent is [`nothing`](@ref), but it\n"
"    behaves like a scalar value rather than like a list. Use `x === nothing` instead of `is.null(x)`.\n"
"  * In Julia, missing values are represented by the [`missing`](@ref) object rather than by `NA`.\n"
"    Use [`ismissing(x)`](@ref) (or `ismissing.(x)` for element-wise operation on vectors) instead of\n"
"    `is.na(x)`. The [`skipmissing`](@ref) function is generally\n"
"    used instead of `na.rm=TRUE` (though in some particular cases functions take a `skipmissing`\n"
"    argument).\n"
"  * Julia lacks the equivalent of R's `assign` or `get`.\n"
"  * In Julia, `return` does not require parentheses.\n"
"  * In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression\n"
"    `x[x>3]` or in the statement `x = x[x>3]` to modify `x` in-place. In contrast, Julia provides\n"
"    the higher order functions [`filter`](@ref) and [`filter!`](@ref), allowing users to write\n"
"    `filter(z->z>3, x)` and `filter!(z->z>3, x)` as alternatives to the corresponding transliterations\n"
"    `x[x.>3]` and `x = x[x.>3]`. Using [`filter!`](@ref) reduces the use of temporary arrays.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/noteworthy-differences.md:197
#, no-wrap
msgid "Noteworthy differences from Python"
msgstr "Python ã¨ã®æ³¨ç®ãã¹ãéã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:226
msgid "Julia requires `end` to end a block. Unlike Python, Julia has no `pass` keyword."
msgstr "Julia ã¯ãã³ã¼ããã­ãã¯ã®çµããã«`end` ãå¿è¦ã§ããPythonã¨ã¯éã£ã¦ Julia ã«ã¯ `pass` ã­ã¼ã¯ã¼ããããã¾ããã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:226 ext/julia/doc/src/manual/noteworthy-differences.md:311
msgid "In Julia, indexing of arrays, strings, etc. is 1-based not 0-based."
msgstr "Julia ã§ã¯ãéåãæå­åãªã©ã®ã¤ã³ããã¯ã¹ã¯ 0 ããã§ã¯ãªã 1 ããå§ã¾ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:226
msgid "Julia's slice indexing includes the last element, unlike in Python. `a[2:3]` in Julia is `a[1:3]` in Python."
msgstr "Julia ã®ã¹ã©ã¤ã¹ ã¤ã³ããã¯ã¹ä½æã«ã¯ãPython ã¨ã¯ç°ãªããæå¾ã®è¦ç´ ãå«ã¾ãã¦ãã¾ããã¸ã¥ãªã¢ã®`a[2:3]` ã¯ Python ã® `a[1:3]` ã§ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:226
msgid ""
"Julia does not support negative indices. In particular, the last element of a list or array is indexed with `end` in Julia, not `-1` as in "
"Python."
msgstr ""
"Julia ã¯è² ã®ã¤ã³ããã¯ã¹ããµãã¼ããã¦ãã¾ãããç¹ã«ããªã¹ãã¾ãã¯éåã®æå¾ã®è¦ç´ ã¯ãPython ã§ã¯ `-1` ã§ãããJulia ã§ã¯ `end` ã§ã¤ã³ããã¯"
"ã¹ä»ãããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:226
msgid "Julia's `for`, `if`, `while`, etc. blocks are terminated by the `end` keyword. Indentation level is not significant as it is in Python."
msgstr "Julia ã® `for`ã`if`ã`while`ãªã©ã®ãã­ãã¯ã¯ `end` ã­ã¼ã¯ã¼ãã§çµäºãã¾ããã¤ã³ãã³ãã¬ãã«ã¯Pythonã»ã©éè¦ã§ã¯ããã¾ããã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:226
msgid ""
"Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise "
"the input continues. One way to force an expression to continue is to wrap it in parentheses."
msgstr ""
"Julia ã«ã¯è¡ç¶ç¶æ§æãããã¾ãã: è¡æ«ã§ãããã¾ã§ã®å¥åãå®å¨ãªå¼ã§ããå ´åã¯ãå®äºããã¨è¦ãªããã¾ãããããä»¥å¤ã®å ´åã¯ãå¥åãç¶è¡ããã¾"
"ããå¼ãæ¬å¼§ã§ãããã¨(ããã¦è¡åã§æ¬å¼§ãéããªããã°) å¼·å¶çã«æ¬¡ã®è¡ã«ç¶è¡ãããã¨ãã§ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:226
msgid ""
"Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered)  by default. To get optimal performance when "
"looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see relevant section of [Performance Tips](@ref "
"man-performance-tips))."
msgstr ""
"Julia éåã¯åã¡ã¸ã£ã¼ (Fortran ãªã¼ãã¼) ã§ãããNumPy éåã¯ããã©ã«ãã§è¡ã¡ã¸ã£ã¼ (C ãªã¼ãã¼) ã§ããéåãã«ã¼ãããéã«æé©ãªããã©ã¼ã"
"ã³ã¹ãå¾ãã«ã¯ãNumPy ã«å¯¾ãã¦ Julia ã§ã«ã¼ãã®é åºãéã«ããå¿è¦ãããã¾ã ([ããã©ã¼ãã³ã¹ã»ãã£ããã¹](@ref man-performance-tips)ã®é¢é£ã"
"ãç¯ãåç§)ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:226
msgid ""
"Julia's updating operators (e.g. `+=`, `-=`, ...) are *not in-place* whereas NumPy's are. This means `A = [1, 1]; B = A; B += [3, 3]` "
"doesn't change values in `A`, it rather rebinds the name `B` to the result of the right-hand side `B = B + 3`, which is a new array. For in-"
"place operation, use `B .+= 3` (see also [dot operators](@ref man-dot-operators)), explicit loops, or `InplaceOps.jl`."
msgstr ""
"Julia ã®æ´æ°æ¼ç®å­(ä¾:`+=`ã`-=`ã...)ã¯*ã¤ã³ãã¬ã¼ã¹ã§ã¯ããã¾ãã*(NumPy ã®æ´æ°æ¼ç®å­ã¯ ã¤ã³ãã¬ã¼ã¹ã§ãã) ãã©ããããã¨ãã¨ããã¨ã `A "
"= [1, 1]; B = A; B += [3, 3]` ã¯ `A` ã®å¤ãå¤æ´ãããæ°ããéåã§ããå³å´ã® `B = B + 3` ã®çµæã« `B` ã¨ããååãåãã¤ã³ããã¾ããã¤ã³ãã¬ã¼"
"ã¹æä½ã®å ´åã¯ã`B.+= 3`ãä½¿ç¨ãã¦ãã ããã ( [ãããæ¼ç®å­](@ref man-dot-operators)ãç¤ºçãªã«ã¼ããã¾ãã¯ `InplaceOps.jl`ãåç§)"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:226
msgid ""
"Julia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are "
"evaluated only once when the function is defined. For example, the function `f(x=rand()) = x` returns a new random number every time it is "
"invoked without argument.  On the other hand, the function `g(x=[1,2]) = push!(x,3)` returns `[1,2,3]` every time it is called as `g()`."
msgstr ""
"Julia ã¯ãé¢æ°ã®å®ç¾©æã«æ¢å®å¤ã 1 åã ãè©ä¾¡ããã Python ã¨ã¯ç°ãªããã¡ã½ãããå¼ã³åºããããã³ã«é¢æ°å¼æ°ã®æ¢å®å¤ãè©ä¾¡ãã¾ãããã¨ãã°ãé¢"
"æ° `f(x=rand()= x` ã¯ãå¼æ°ãªãã§å¼ã³åºããããã³ã«æ°ããä¹±æ°ãè¿ãã¾ãã ä¸æ¹ãé¢æ° `g(x=[1,2]) = push!(x,3)` ã¯ `g()` ã¨å¼ã°ãããã³ã« "
"`[1,2,3]` ãè¿ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:226
msgid "In Julia `%` is the remainder operator, whereas in Python it is the modulus."
msgstr "Julia ã§ã¯ã`%` ã¯ reminder æ¼ç®å­ã§ãããPython ã§ã¯ã¢ã¸ã¥ã©ã¹ã§ãã(è¨³èæ³¨: reminder ã¯åã«è² ã®æ°ãè¨±ããä¸ã§ã®å°ä½)"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:226
msgid ""
"The commonly used `Int` type corresponds to the machine integer type (`Int32` or `Int64`).  This means it will overflow, such that `2^64 == "
"0`. If you need larger values use another appropriate type, such as `Int128`, [`BigInt`](@ref) or a floating point type like `Float64`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/noteworthy-differences.md:227
#, no-wrap
msgid "Noteworthy differences from C/C++"
msgstr "C/C++ ã¨ã®æ³¨ç®ãã¹ãéã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:311
msgid ""
"Julia arrays are indexed with square brackets, and can have more than one dimension `A[i,j]`.  This syntax is not just syntactic sugar for a "
"reference to a pointer or address as in C/C++. See the Julia documentation for the syntax for array construction (it has changed between "
"versions)."
msgstr ""
"Julia éåã¯è§ãã£ãã§ã¤ã³ããã¯ã¹ä»ããããè¤æ°æ¬¡åã®éåãæ±ãã¾ã `A[i,j]`ã®ããã«ããã®æ§æã¯ãC/C++ ã®ããã«ãã¤ã³ã¿ã¾ãã¯ã¢ãã¬ã¹ã¸ã®å"
"ç§ã®ããã®åãªãç³è¡£æ§æã§ã¯ããã¾ãããéåæ§ç¯ã®æ§æã«ã¤ãã¦ã¯ãJulia ã®ãã­ã¥ã¡ã³ããåç§ãã¦ãã ãã (ãã¼ã¸ã§ã³éã§æ§æãå¤æ´ããã¦ãã¾"
"ã)ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:311
msgid ""
"Julia arrays are not copied when assigned to another variable. After `A = B`, changing elements of `B` will modify `A` as well. Updating "
"operators like `+=` do not operate in-place, they are equivalent to `A = A + B` which rebinds the left-hand side to the result of the right-"
"hand side expression."
msgstr ""
"Julia éåã¯ãå¥ã®å¤æ°ã«å²ãå½ã¦ãããå ´åã¯ã³ãã¼ããã¾ããã`A = B` ã®å¾ã`B` ã®è¦ç´ ãå¤æ´ããã¨ `A` ãå¤æ´ããã¾ãã`+=` ã®ãããªæ´æ°æ¼ç®"
"å­ã¯ãã¤ã³ãã¬ã¼ã¹ã§ã®åä½ã¯ãã¾ããããå·¦è¾ºãå³è¾ºã®å¼ã®çµæã«æãã¤ã³ãããã `A = A + B` ã«ç¸å½ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:311
msgid ""
"Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when "
"looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see relevant section of [Performance Tips](@ref "
"man-performance-tips))."
msgstr ""
"Julia éåã¯åã¡ã¸ã£ã¼ (Fortran ãªã¼ãã¼) ã§ãããC/C++ éåã¯ããã©ã«ãã§è¡ã¡ã¸ã£ã¼ã§ããéåãã«ã¼ãããéã«æé©ãªããã©ã¼ãã³ã¹ãå¾ãã«"
"ã¯ãC/C++ ã«å¯¾ãã¦ Julia ã§ã«ã¼ãã®é åºãéã«ããå¿è¦ãããã¾ã ([ããã©ã¼ãã³ã¹ã»ãã£ããã¹](@ref man-performance-tips)ã®é¢é£ã»ã¯ã·ã§ã³ãå"
"ç§)ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:311
msgid ""
"Julia values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the "
"caller."
msgstr ""
"Julia ã§ã¯ãå¤ã¯ãé¢æ°ã«å²ãå½ã¦ããããæ¸¡ãããããã¦ãã³ãã¼ããã¾ãããé¢æ°ãéåãå¤æ´ããã¨ããã®å¤æ´ã¯å¼ã³åºãåã«ãå½±é¿ãåã¼ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/noteworthy-differences.md:311
msgid "In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program."
msgstr "Julia ã§ã¯ãç©ºç½ã¯ C/C++ ã¨ã¯ç°ãªãéè¦ã§ããJulia ãã­ã°ã©ã ããç©ºç½ãè¿½å /åé¤ããå ´åã¯æ³¨æãå¿è¦ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:311
#, no-wrap
msgid ""
"  * In Julia, literal numbers without a decimal point (such as `42`) create signed integers, of type\n"
"    `Int`, but literals too large to fit in the machine word size will automatically be promoted to\n"
"    a larger size type, such as `Int64` (if `Int` is `Int32`), `Int128`, or the arbitrarily large\n"
"    `BigInt` type. There are no numeric literal suffixes, such as `L`, `LL`, `U`, `UL`, `ULL` to indicate\n"
"    unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals\n"
"    (which start with `0x` like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java\n"
"    and unlike decimal literals in Julia, have a type based on the *length* of the literal, including\n"
"    leading 0s. For example, `0x0` and `0x00` have type [`UInt8`](@ref), `0x000` and `0x0000` have type\n"
"    [`UInt16`](@ref), then literals with 5 to 8 hex digits have type `UInt32`, 9 to 16 hex digits type\n"
"    `UInt64` and 17 to 32 hex digits type `UInt128`. This needs to be taken into account when defining\n"
"    hexadecimal masks, for example `~0xf == 0xf0` is very different from `~0x000f == 0xfff0`. 64 bit `Float64`\n"
"    and 32 bit [`Float32`](@ref) bit literals are expressed as `1.0` and `1.0f0` respectively. Floating point\n"
"    literals are rounded (and not promoted to the `BigFloat` type) if they can not be exactly represented.\n"
"     Floating point literals are closer in behavior to C/C++. Octal (prefixed with `0o`) and binary\n"
"    (prefixed with `0b`) literals are also treated as unsigned.\n"
"  * String literals can be delimited with either `\"`  or `\"\"\"`, `\"\"\"` delimited literals can contain\n"
"    `\"` characters without quoting it like `\"\\\"\"`. String literals can have values of other variables\n"
"    or expressions interpolated into them, indicated by `$variablename` or `$(expression)`, which\n"
"    evaluates the variable name or the expression in the context of the function.\n"
"  * `//` indicates a [`Rational`](@ref) number, and not a single-line comment (which is `#` in Julia)\n"
"  * `#=` indicates the start of a multiline comment, and `=#` ends it.\n"
"  * Functions in Julia return values from their last expression(s) or the `return` keyword.  Multiple\n"
"    values can be returned from functions and assigned as tuples, e.g. `(a, b) = myfunction()` or\n"
"    `a, b = myfunction()`, instead of having to pass pointers to values as one would have to do in\n"
"    C/C++ (i.e. `a = myfunction(&b)`.\n"
"  * Julia does not require the use of semicolons to end statements. The results of expressions are\n"
"    not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code\n"
"    do not need to end with semicolons. [`println`](@ref) or [`@printf`](@ref) can be used to\n"
"    print specific output. In the REPL, `;` can be used to suppress output. `;` also has a different\n"
"    meaning within `[ ]`, something to watch out for. `;` can be used to separate expressions on a\n"
"    single line, but are not strictly necessary in many cases, and are more an aid to readability.\n"
"  * In Julia, the operator [`â»`](@ref xor) ([`xor`](@ref)) performs the bitwise XOR operation, i.e.\n"
"    [`^`](@ref) in C/C++.  Also, the bitwise operators do not have the same precedence as C/++, so\n"
"    parenthesis may be required.\n"
"  * Julia's [`^`](@ref) is exponentiation (pow), not bitwise XOR as in C/C++ (use [`â»`](@ref xor), or\n"
"    [`xor`](@ref), in Julia)\n"
"  * Julia has two right-shift operators, `>>` and `>>>`.  `>>>` performs an arithmetic shift, `>>`\n"
"    always performs a logical shift, unlike C/C++, where the meaning of `>>` depends on the type of\n"
"    the value being shifted.\n"
"  * Julia's `->` creates an anonymous function, it does not access a member via a pointer.\n"
"  * Julia does not require parentheses when writing `if` statements or `for`/`while` loops: use `for i in [1, 2, 3]`\n"
"    instead of `for (int i=1; i <= 3; i++)` and `if i == 1` instead of `if (i == 1)`.\n"
"  * Julia does not treat the numbers `0` and `1` as Booleans. You cannot write `if (1)` in Julia,\n"
"    because `if` statements accept only booleans. Instead, you can write `if true`, `if Bool(1)`,\n"
"    or `if 1==1`.\n"
"  * Julia uses `end` to denote the end of conditional blocks, like `if`, loop blocks, like `while`/\n"
"    `for`, and functions. In lieu of the one-line `if ( cond ) statement`, Julia allows statements\n"
"    of the form `if cond; statement; end`, `cond && statement` and `!cond || statement`. Assignment\n"
"    statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. `cond && (x = value)`,\n"
"    because of the operator precedence.\n"
"  * Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete\n"
"    expression, it is considered done; otherwise the input continues. One way to force an expression\n"
"    to continue is to wrap it in parentheses.\n"
"  * Julia macros operate on parsed expressions, rather than the text of the program, which allows\n"
"    them to perform sophisticated transformations of Julia code. Macro names start with the `@` character,\n"
"    and have both a function-like syntax, `@mymacro(arg1, arg2, arg3)`, and a statement-like syntax,\n"
"    `@mymacro arg1 arg2 arg3`. The forms are interchangeable; the function-like form is particularly\n"
"    useful if the macro appears within another expression, and is often clearest. The statement-like\n"
"    form is often used to annotate blocks, as in the distributed `for` construct: `@distributed for i in 1:n; #= body =#; end`.\n"
"    Where the end of the macro construct may be unclear, use the function-like form.\n"
"  * Julia has an enumeration type, expressed using the macro `@enum(name, value1, value2, ...)`\n"
"    For example: `@enum(Fruit, banana=1, apple, pear)`\n"
"  * By convention, functions that modify their arguments have a `!` at the end of the name, for example\n"
"    `push!`.\n"
"  * In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual,\n"
"    in order to have dynamic dispatch. On the other hand, in Julia every method is \"virtual\" (although\n"
"    it's more general than that since methods are dispatched on every argument type, not only `this`,\n"
"    using the most-specific-declaration rule).\n"
msgstr ""
"  * Juliaã§ã¯ãå°æ°ç¹ã®ãªããªãã©ã«æ°( `42`ãªã©)ã¯ã`Int`åã®ç¬¦å·ä»ãæ´æ°ãä½æãã¾ãããããæ©æ¢°èªã®ãµã¤ãºã«åã¾ããªãã»ã©å¤§ãããªãã©ã«ã¯èªåçã«`Int64`(` Int`ã `Int32`ã®å ´å)ã` Int128`ãã¾ãã¯ä»»æã®å¤§ããã®ããå¤§ããªãµã¤ãºã®åã®BigIntåã«ææ ¼ããã¾ãã`L`ã`LL`ã`U`ã`UL`ã`ULL` ãªã©ã®ãç¬¦å·ãªãããã³/ã¾ãã¯ãç¬¦å·ä»ã ã¨ ç¬¦å·ãªãã®ç©ãªã©ãç¤ºããæ°å¤ãªãã©ã«ã®æ¥å°¾è¾ã¯ããã¾ããã10é²æ°ãªãã©ã«ã¯å¸¸ã«ç¬¦å·ä»ãã16é²æ°ãªãã©ã«(C / C ++ã®ããã« `0x`ã§å§ã¾ã)ã¯ç¬¦å·ãªãã§ããã¾ãã16é²ãªãã©ã«ã¯ã C / C ++ / Javaã®16é²æ°ãªãã©ã«ããJuliaã®10é²æ°ãªãã©ã«ã¨ã¯éãã*ãªãã©ã«ã®é·ã*ã«åºã¥ããåãããã¾ããåé ­ã«0ãè¤æ°ãä»ããã®ãå«ã¿ã¾ããä¾ãã°ã `0x0`ã¨` 0x00`ã¯å [`UInt8`](@ref)ãæã¡ã` 0x000`ã¨ `0x0000`ã¯å [`UInt16`](@ref)ã«ãªãã¾ãã5ãã8æ¡ã®16é²æ°ã®ãªãã©ã«ã¯å`UInt32`ã«ã9ãã16æ¡ã®16é²æ°ãªãã©ã«ã¯å`UInt64`ã«ãããã¦17ãã32æ¡ã®16é²æ°ãªãã©ã«ã¯å` UInt128`ã§ãã16é²æ°ãã¹ã¯ãå®ç¾©ããã¨ãã«ã¯ããã®ãã¨ãèæ®ããå¿è¦ãããã¾ããä¾ãã°`~0xf == 0xf0` ã¯ `~0x000f == 0xfff0`ã¨å¨ãç°ãªãã¾ãã 64ãããã® `Float64`ãã32ãããã® [`Float32`](@ref)ã®ããããªãã©ã«ã¯ãããã`1.0`ã¨ `1.0f0`ã¨ã²ããããã¾ããæµ®åå°æ°ç¹ãªãã©ã«ãæ­£ç¢ºã«è¡¨ç¾ã§ããªãå ´åã¯ãä¸¸ãããã¾ã(`BigFloat`åã«ã¯ææ ¼ããã¾ãã)ãæµ®åå°æ°ç¹ãªãã©ã«ã®åä½ã¯C / C ++ã«è¿ãã§ãã 8é²æ°(æ¥é ­è¾ `0o`)ã¨ãã¤ããª(æ¥é ­è¾ `0b`)ãªãã©ã«ãç¬¦å·ãªãã¨ãã¦æ±ããã¾ãã\n"
"  *æå­åãªãã©ã«ã¯ `\" `ã¾ãã¯`\"\"\"` ã§å²ã£ã¦è¡¨è¨ãããã¨ãã§ãã¾ãã `\"\"\"` ãä½¿ã£ãæå­åãªãã©ã«ã¯ã`\"\\\"\"` ã®ããã«ã¯ãªã¼ããããã¨ãªããæå­ `\"`Â ãåã«å«ããã¨ãã§ãã¾ããæå­åãªãã©ã«ã¯ä»ã®å¤æ°ãå¼ã®å¤ã å±éãã¦ç¨ãããã¨ãã§ãã¾ããããã§ã¯ã`$variablename` ã `$(expression)` ã¨è¨ã£ãå·åã«æ¸ãããå¤æ°åãå¼ããã®æå­åãç¨ããã³ã³ãã­ã¹ãã®ä¸­ã§è©ä¾¡ããã¾ãã\n"
"  * `//`ã¯[`æçæ°`](@ref Rational)ãè¡¨ããåä¸è¡ã®ã³ã¡ã³ãã§ã¯ããã¾ãã (Juliaã®ã³ã¡ã³ãã¯`#`ã§ã)\n"
"  * `#=`ã¯è¤æ°è¡ã³ã¡ã³ãã®å§ã¾ããç¤ºãã `=#`ã¯çµäºãç¤ºãã¾ãã\n"
"  * Juliaã®é¢æ°ã¯æå¾ã®å¼ã¾ãã¯ `return`ã­ã¼ã¯ã¼ãããå¤ãè¿ãã¾ããè¤æ°ã®å¤ãé¢æ°ããè¿ããã¨ãã§ããã¿ãã«ã¨ãã¦å²ãå½ã¦ããã¾ããä¾ãã°ã `(a, b)= myfunction()`ãã`a, b = myfunction()`ã¨ãã£ãå·åã§ããC / C ++ã®ããã«(ããªãã¡ `a=myfunction(&b)`ã¨ãããµãã«)å¤ã¸ã®ãã¤ã³ã¿ãæ¸¡ãå¿è¦ã¯ããã¾ããã\n"
"  * Juliaã§ã¯ãæãçµäºããããã«ã»ãã³ã­ã³ãä½¿ç¨ããå¿è¦ã¯ããã¾ããã(å¯¾è©±åãã­ã³ãããããªãã¡REPLãé¤ã)ãå¼ã®çµæã¯èªåçã«åºåããã¾ããã®ã§ãã³ã¼ãã®è¡æ«ã«ã»ãã³ã­ã³ãã¤ããå¿è¦ã¯ããã¾ãããç¹æ®µããªã³ãåºåãå¿è¦ãªã¨ãã«ã¯ã[`println`](@ref)ã[`@printf`](@ref)ãä½¿ãã¾ããREPLã§ã¯ã `;`ãä½¿ã£ã¦åºåãæå¶ãããã¨ãã§ãã¾ãã`[]`åã§ã¯ `;`ã¯æ³¨ç®ã«å¤ãããå¥ã®æå³ãæã¡ã¾ããåãè¡ã®ä¸­ã§ãè¤æ°ã®å¼ãåºåãã®ã«ä½¿ããã¨ãã§ããã®ã§ãããããããã®æ©è½ã¯ãå¤ãã®å ´åã§å¿ãå¿è¦ã¨ãããã¨ã§ã¯ãªããå¯èª­æ§åä¸ã®ããã«å½¹ç«ã¤ã¨ããæå³åããå¼·ãã§ãã\n"
"  * Juliaã§ã¯ãæ¼ç®å­[`â»`](@ref xor)([`xor`](@ref))ã¯XORãããæ¼ç®ãå®è¡ãã¾ããC / C ++ã§ããã¨ããã®[`^`](@ref)ã«ãããã¾ããã¾ãããããæ¼ç®å­ã¯C / ++ã¨ã¯åªåé ä½ãç°ãªãã®ã§ãæ¬å¼§ãå¿è¦ãªå ´åãããã¾ãã\n"
"  * Juliaã®[`^`](@ref)ã¯ã¹ãä¹(pow)ã§ãããC / C ++ã®å ´åã®ãããªãããæ¼ç®ã®XORã§ã¯ããã¾ãã(Julia ã§ã¯[`â»`](@ref xor)ã¾ãã¯[`xor`](@ref)ãä½¿ã£ã¦ãã ãã)\n"
"  * Juliaã«ã¯2ã¤ã®å³ã·ããæ¼ç®å­ã `>>`ã¨ `>>>`ãããã¾ãã `>>>`ã¯ç®è¡ã·ãããå®è¡ãã¾ãã `>>` ã¯ C / C ++ã¨ã¯ç°ãªããå¸¸ã«è«çã·ãããå®è¡ãã¾ããããã§ã `>>`ã®æå³ã¯ãã·ãããããå¤ã®åã«ãã£ã¦ç°ãªãã¾ãã\n"
"  * Juliaã® `->`ã¯ç¡åé¢æ°ãä½æãããã¤ã³ã¿çµç±ã®ã¡ã³ãã¸ã®ã¢ã¯ã»ã¹ã§ã¯ããã¾ããã\n"
"  * Juliaã¯ `if`ã¹ãã¼ãã¡ã³ãã` for` / `while`ã«ã¼ããæ¸ãã¨ãã«æ¬å¼§ãå¿è¦ã¨ãã¾ãã: `for(int i = 1; i <= 3; i ++)`ã§ã¯ãªã`for i in [1, 2, 3]`ã§ãã`if(i == 1)`ã§ã¯ãªã `if i == 1`ã§ãã\n"
"  * Juliaã¯æ°å­ã®0ã¨1ããã¼ã«å¤ã¨ãã¦æ±ãã¾ããã Juliaã§ã¯ `if(1)`ã¨æ¸ããã¨ã¯ã§ãã¾ããããªããªããifæã¯ãã¼ã«å¤ã ããåãå¥ããããã§ããä»£ããã«ã `if true `ã` if Bool(1) ã`if 1 == 1`ã¨æ¸ããã¨ã¯ã§ãã¾ãã\n"
"  * Juliaã¯ã`if`ãªã©ã®æ¡ä»¶ä»ããã­ãã¯ã®çµãããç¤ºãã®ã« `end`ãä½¿ãã¾ããåæ§ã«ã`while`ã`for`ãªã©ã®ã«ã¼ããã­ãã¯ã®ã®çµããã«ã`end`ãä½¿ãã¾ããã¯ã³ã©ã¤ã³ã§æ¸ã`if ( cond ) statement`ã®ä»£ããã«ãJuliaã§ã¯ã`if cond; statement; end`ããã `cond && statement` ãã `!cond || statement` ã®ããã«æ¸ããã¨ãã§ãã¾ããçµãã2ã¤ã®æ§æã§ãä»£å¥å¼ãæ¸ãå ´åã«ã¯ãæ¬å¼§ã§æç¤ºçã«å²ãå¿è¦ãããã¾ããä¾ãã°ã`cond &&(x = value)`ã¨ãã£ãå·åã§ãããã¯æ¼ç®å­ã®åªåé ä½ã®ããã§ãã\n"
"  * Juliaã«ã¯è¡ç¶ç¶æ§æã¯ããã¾ãããè¡æ«ã§ãããã¾ã§ã®å¥åãå®å¨ãªå¼ã§ããå ´åãå®äºããã¨ã¿ãªããã¾ãããããã§ãªããã°ãå¥åãç¶è¡ããã¾ããå¼ãæ¬å¼§ã§ããããã¨ã§ãå¼·å¶çã«æ¬¡ã®è¡ã«ç¶è¡ãããã¨ãã§ãã¾ãã\n"
"  * Juliaã®ãã¯ã­ã¯ããã­ã°ã©ã ã®ãã­ã¹ãã§ã¯ãªããè§£æãããå¼ãæä½ãã¾ããããã«ãããJuliaã³ã¼ãã®æ´ç·´ãããå¤æãå®è¡ãããã¨ãã§ãã¾ãããã¯ã­åã¯ `@`æå­ã§å§ã¾ãã`mymacro(arg1, arg2,arg3)` ã¨ããå½¢ã®é¢æ°ã®ãããªæ§æã§ãã£ããã`@mymacro arg1 arg2 arg3`ã¨ããå½¢ã®æã®ãããªæ§æãæã¡ã¾ããæ¸å¼ã¯æ¸ãæãå¯è½ã§ããé¢æ°ã®ãããªå½¢å¼ã¯ç¹ã«ãã¯ã­ãå¥ã®å¼ã®ä¸­ã«ããå ´åã«ä¾¿å©ã§ãå¤ãã®å ´åæç¢ºã§ããæã®ãããªå½¢å¼ã¯ããã­ãã¯ã«æ³¨éãä»ããããã«ããä½¿ããã¾ããä¾ãã°ãåæ£å®è¡åã® `for`æ§æã®ããã§ã¯ã`@distributed for i in 1:n; #= body =#;end`ã®ããã«æ¸ãã¾ãããã¯ã­ã®çµãããã¯ã£ããããªãã³ã¼ãã§ã¯ãé¢æ°ã®ãããªå½¢å¼ãä½¿ç¨ãã¦ãã ããã\n"
"  * Juliaã¯åæåãæã¡ã `@enum(name, value1, value2, ...)`ãã¯ã­ãä½¿ã£ã¦è¡¨ç¾ããã¾ããä¾ãã°ã@enum(Fruit, banana = 1, apple, pear)ã®ããã«æ¸ãã¾ãã\n"
"  *æ£ä¾ã«ãããå¼æ°ãå¤æ´ããé¢æ°ã¯ååã®æå¾ã« `!`ãæã¡ã¾ããä¾ãã°ã`push!` ãªã©ã§ãã\n"
"  * C ++ã§ã¯ãããã©ã«ãã§ã¯éçãã£ã¹ããããå©ç¨å¯è½ã§ããã¤ã¾ããåçãªãã£ã¹ããããè¡ãã«ã¯ãé¢æ°ãä»®æ³é¢æ°ã§ããããã«ã¢ããã¼ã·ã§ã³ããå¿è¦ãããã¾ããä¸æ¹ãJuliaã§ã¯ããã¹ã¦ã®ã¡ã½ããã¯ãä»®æ³ãã§ã(ãã ããããä¸è¬çã§ããã¡ã½ããã¯ãæãå·ä½çãªå®£è¨è¦åãä½¿ç¨ãããããªããã£ã¹ãããããthisã ãã§ã¯ãªããã¹ã¦ã®å¼æ°ã®åã«å¯¾ãã¦è¡ãã¾ã)ã\n"

#. type: Title ##
#: ext/julia/doc/src/manual/noteworthy-differences.md:312
#, no-wrap
msgid "Noteworthy differences from Common Lisp"
msgstr "Common Lisp ã¨ã®æ³¨ç®ãã¹ãéã"

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:315
msgid "- Julia uses 1-based indexing for arrays by default, and it can also handle arbitrary [index offsets](@ref man-custom-indices)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:317
msgid "- Functions and variables share the same namespace (âLisp-1â)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:319
msgid ""
"- There is a [`Pair`](@ref) type, but it is not meant to be used as a `COMMON-LISP:CONS`. Various iterable collections can be used "
"interchangeably in most parts of the language (eg splatting, tuples, etc). `Tuple`s are the closest to Common Lisp lists for *short* "
"collections of heterogeneous elements. Use `NamedTuple`s in place of alists. For larger collections of homogeneous types, `Array`s and "
"`Dict`s should be used."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:321
msgid ""
"- The typical Julia workflow for prototyping also uses continuous manipulation of the image, implemented with the [Revise.jl](https://github."
"com/timholy/Revise.jl) package."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:323
msgid "- Bignums are supported, but conversion is not automatic; ordinary integers [overflow](@ref faq-integer-arithmetic)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:325
msgid ""
"- Modules (namespaces) can be hierarchical. [`import`](@ref) and [`using`](@ref) have a dual role: they load the code and make it available "
"in the namespace. `import` for only the module name is possible (roughly equivalent to `ASDF:LOAD-OP`). Slot names don't need to be exported "
"separately. Global variables can't be assigned to from outside the module (except with `eval(mod, :(var = val))` as an escape hatch)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:327
msgid ""
"- Macros start with `@`, and are not as seamlessly integrated into the language as Common Lisp; consequently, macro usage is not as "
"widespread as in the latter. A form of hygiene for [macros](@ref Metaprogramming) is supported by the language. Because of the different "
"surface syntax, there is no equivalent to `COMMON-LISP:&BODY`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:329
msgid ""
"- *All* functions are generic and use multiple dispatch. Argument lists don't have to follow the same template, which leads to a powerful "
"idiom (see [`do`](@ref)). Optional and keyword arguments are handled differently. Method ambiguities are not resolved like in the Common "
"Lisp Object System, necessitating the definition of a more specific method for the intersection."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:331
msgid "- Symbols do not belong to any package, and do not contain any values *per se*. `M.var` evaluates the symbol `var` in the module `M`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/noteworthy-differences.md:332
msgid ""
"- A functional programming style is fully supported by the language, including closures, but isn't always the idiomatic solution for Julia. "
"Some [workarounds](@ref man-performance-captured) may be necessary for performance when modifying captured variables."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:1
#, no-wrap
msgid "Complex and Rational Numbers"
msgstr "[è¤ç´ æ°ã¨æçæ°](@id complex-and-rational-numbers)"

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:7
msgid ""
"Julia includes predefined types for both complex and rational numbers, and supports all the standard [Mathematical Operations and Elementary "
"Functions](@ref) on them. [Conversion and Promotion](@ref conversion-and-promotion) are defined so that operations on any combination of "
"predefined numeric types, whether primitive or composite, behave as expected."
msgstr ""
"Julia ã«ã¯ãè¤ç´ æ°ã¨æçæ°ã®ä¸¡æ¹ãçµè¾¼åã¨ãã¦æã£ã¦ããããããã«ãã¹ã¦ã®æ¨æº [ç®è¡æ¼ç®ã¨åç­é¢æ°](@ref mathematical-operations-and-"
"elementary-functions) ããµãã¼ããã¦ãã¾ãã[å¤æã¨ææ ¼](@ref conversion-and-promotion) ã¯ãããªããã£ãã¾ãã¯è¤ååã®ä»»æã®çµã¿åããã«å¯¾ã"
"ãæä½ãæå¾ã©ããã«åä½ããããã«å®ç¾©ããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:8
#, no-wrap
msgid "Complex Numbers"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:14
msgid ""
"The global constant [`im`](@ref) is bound to the complex number *i*, representing the principal square root of -1. (Using mathematicians' "
"`i` or engineers' `j` for this global constant were rejected since they are such popular index variable names.) Since Julia allows numeric "
"literals to be [juxtaposed with identifiers as coefficients](@ref man-numeric-literal-coefficients), this binding suffices to provide "
"convenient syntax for complex numbers, similar to the traditional mathematical notation:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:15
#, no-wrap
msgid ""
"julia> 1+2im\n"
"1 + 2im\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:21
msgid "You can perform all the standard arithmetic operations with complex numbers:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:22
#, no-wrap
msgid ""
"julia> (1 + 2im)*(2 - 3im)\n"
"8 + 1im\n"
"\n"
"julia> (1 + 2im)/(1 - 2im)\n"
"-0.6 + 0.8im\n"
"\n"
"julia> (1 + 2im) + (1 - 2im)\n"
"2 + 0im\n"
"\n"
"julia> (-3 + 2im) - (5 - 1im)\n"
"-8 + 3im\n"
"\n"
"julia> (-1 + 2im)^2\n"
"-3 - 4im\n"
"\n"
"julia> (-1 + 2im)^2.5\n"
"2.729624464784009 - 6.9606644595719im\n"
"\n"
"julia> (-1 + 2im)^(1 + 1im)\n"
"-0.27910381075826657 + 0.08708053414102428im\n"
"\n"
"julia> 3(2 - 5im)\n"
"6 - 15im\n"
"\n"
"julia> 3(2 - 5im)^2\n"
"-63 - 60im\n"
"\n"
"julia> 3(2 - 5im)^-1.0\n"
"0.20689655172413796 + 0.5172413793103449im\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:55
msgid "The promotion mechanism ensures that combinations of operands of different types just work:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:56
#, no-wrap
msgid ""
"julia> 2(1 - 1im)\n"
"2 - 2im\n"
"\n"
"julia> (2 + 3im) - 1\n"
"1 + 3im\n"
"\n"
"julia> (1 + 2im) + 0.5\n"
"1.5 + 2.0im\n"
"\n"
"julia> (2 + 3im) - 0.5im\n"
"2.0 + 2.5im\n"
"\n"
"julia> 0.75(1 + 2im)\n"
"0.75 + 1.5im\n"
"\n"
"julia> (2 + 3im) / 2\n"
"1.0 + 1.5im\n"
"\n"
"julia> (1 - 3im) / (2 + 2im)\n"
"-0.5 - 1.0im\n"
"\n"
"julia> 2im^2\n"
"-2 + 0im\n"
"\n"
"julia> 1 + 3/4im\n"
"1.0 - 0.75im\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:87
msgid "Note that `3/4im == 3/(4*im) == -(3/4*im)`, since a literal coefficient binds more tightly than division."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:89
msgid "Standard functions to manipulate complex values are provided:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:90
#, no-wrap
msgid ""
"julia> z = 1 + 2im\n"
"1 + 2im\n"
"\n"
"julia> real(1 + 2im) # real part of z\n"
"1\n"
"\n"
"julia> imag(1 + 2im) # imaginary part of z\n"
"2\n"
"\n"
"julia> conj(1 + 2im) # complex conjugate of z\n"
"1 - 2im\n"
"\n"
"julia> abs(1 + 2im) # absolute value of z\n"
"2.23606797749979\n"
"\n"
"julia> abs2(1 + 2im) # squared absolute value\n"
"5\n"
"\n"
"julia> angle(1 + 2im) # phase angle in radians\n"
"1.1071487177940904\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:118
msgid ""
"As usual, the absolute value ([`abs`](@ref)) of a complex number is its distance from zero.  [`abs2`](@ref) gives the square of the absolute "
"value, and is of particular use for complex numbers since it avoids taking a square root. [`angle`](@ref) returns the phase angle in radians "
"(also known as the *argument* or *arg* function). The full gamut of other [Elementary Functions](@ref)  is also defined for complex numbers:"
msgstr ""
"éå¸¸ã©ãããè¤ç´ æ°ã®çµ¶å¯¾å¤([`abs`](@ref)) ã¯ã¼ã­ããã®è·é¢ã§ãã [`abs2`](@ref) ã¯çµ¶å¯¾å¤ã®äºä¹ãä¸ããå¹³æ¹æ ¹è¨ç®ãè¡ãããªãã®ã§è¤ç´ æ°ã«ç¹ã«"
"ä½¿ç¨ããã¾ãã[`angle`](@ref) ã¯ãã©ã¸ã¢ã³ã®ä½ç¸è§åº¦ãè¿ãã¾ã (*argument* ã¾ãã¯ *arg* é¢æ°ã¨ãå¼ã°ãã¾ã)ãä»ã®ä¸éãã®[åç­é¢æ°](@ref "
"elementary-functions)ãè¤ç´ æ°ã«å¯¾ãã¦å®ç¾©ããã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:119
#, no-wrap
msgid ""
"julia> sqrt(1im)\n"
"0.7071067811865476 + 0.7071067811865475im\n"
"\n"
"julia> sqrt(1 + 2im)\n"
"1.272019649514069 + 0.7861513777574233im\n"
"\n"
"julia> cos(1 + 2im)\n"
"2.0327230070196656 - 3.0518977991518im\n"
"\n"
"julia> exp(1 + 2im)\n"
"-1.1312043837568135 + 2.4717266720048188im\n"
"\n"
"julia> sinh(1 + 2im)\n"
"-0.4890562590412937 + 1.4031192506220405im\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:139
msgid ""
"Note that mathematical functions typically return real values when applied to real numbers and complex values when applied to complex "
"numbers. For example, [`sqrt`](@ref) behaves differently when applied to `-1` versus `-1 + 0im` even though `-1 == -1 + 0im`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:140
#, no-wrap
msgid ""
"julia> sqrt(-1)\n"
"ERROR: DomainError with -1.0:\n"
"sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> sqrt(-1 + 0im)\n"
"0.0 + 1.0im\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:153
msgid ""
"The [literal numeric coefficient notation](@ref man-numeric-literal-coefficients) does not work when constructing a complex number from "
"variables. Instead, the multiplication must be explicitly written out:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:154
#, no-wrap
msgid ""
"julia> a = 1; b = 2; a + b*im\n"
"1 + 2im\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:161
msgid ""
"However, this is *not* recommended. Instead, use the more efficient [`complex`](@ref) function to construct a complex value directly from "
"its real and imaginary parts:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:162
#, no-wrap
msgid ""
"julia> a = 1; b = 2; complex(a, b)\n"
"1 + 2im\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:168
msgid "This construction avoids the multiplication and addition operations."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:171
msgid ""
"[`Inf`](@ref) and [`NaN`](@ref) propagate through complex numbers in the real and imaginary parts of a complex number as described in the "
"[Special floating-point values](@ref) section:"
msgstr ""
"[`Inf`](@ref) ããã³ [`NaN`](@ref) ã¯ã[ç¹æ®ãªæµ®åå°æ°ç¹å¤](@ref special-floating-point-values)ã»ã¯ã·ã§ã³ã§èª¬æããã¦ããããã«ãè¤ç´ æ°ã®å®é¨"
"ã¨èé¨ã«ä¼æ­ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:172
#, no-wrap
msgid ""
"julia> 1 + Inf*im\n"
"1.0 + Inf*im\n"
"\n"
"julia> 1 + NaN*im\n"
"1.0 + NaN*im\n"
msgstr ""
"julia> 1 + Inf*im\n"
"1.0 + Inf*im\n"
"\n"
"julia> 1 + NaN*im\n"
"1.0 + NaN*im\n"

#. type: Title ##
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:180
#, no-wrap
msgid "Rational Numbers"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:184
msgid "Julia has a rational number type to represent exact ratios of integers. Rationals are constructed using the [`//`](@ref) operator:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:185
#, no-wrap
msgid ""
"julia> 2//3\n"
"2//3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:192
msgid ""
"If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such that the denominator is non-"
"negative:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:193
#, no-wrap
msgid ""
"julia> 6//9\n"
"2//3\n"
"\n"
"julia> -4//8\n"
"-1//2\n"
"\n"
"julia> 5//-15\n"
"-1//3\n"
"\n"
"julia> -4//-12\n"
"1//3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:211
msgid ""
"This normalized form for a ratio of integers is unique, so equality of rational values can be tested by checking for equality of the "
"numerator and denominator. The standardized numerator and denominator of a rational value can be extracted using the [`numerator`](@ref) and "
"[`denominator`](@ref)  functions:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:212
#, no-wrap
msgid ""
"julia> numerator(2//3)\n"
"2\n"
"\n"
"julia> denominator(2//3)\n"
"3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:222
msgid ""
"Direct comparison of the numerator and denominator is generally not necessary, since the standard arithmetic and comparison operations are "
"defined for rational values:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:223
#, no-wrap
msgid ""
"julia> 2//3 == 6//9\n"
"true\n"
"\n"
"julia> 2//3 == 9//27\n"
"false\n"
"\n"
"julia> 3//7 < 1//2\n"
"true\n"
"\n"
"julia> 3//4 > 2//3\n"
"true\n"
"\n"
"julia> 2//4 + 1//6\n"
"2//3\n"
"\n"
"julia> 5//12 - 1//4\n"
"1//6\n"
"\n"
"julia> 5//8 * 3//12\n"
"5//32\n"
"\n"
"julia> 6//5 / 10//7\n"
"21//25\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:250
msgid "Rationals can easily be converted to floating-point numbers:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:251
#, no-wrap
msgid ""
"julia> float(3//4)\n"
"0.75\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:258
msgid ""
"Conversion from rational to floating-point respects the following identity for any integral values of `a` and `b`, with the exception of the "
"case `a == 0` and `b == 0`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:259
#, no-wrap
msgid ""
"julia> a = 1; b = 2;\n"
"\n"
"julia> isequal(float(a//b), a/b)\n"
"true\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:267
msgid "Constructing infinite rational values is acceptable:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:268
#, no-wrap
msgid ""
"julia> 5//0\n"
"1//0\n"
"\n"
"julia> -3//0\n"
"-1//0\n"
"\n"
"julia> typeof(ans)\n"
"Rational{Int64}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:280
msgid "Trying to construct a [`NaN`](@ref) rational value, however, is invalid:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:281
#, no-wrap
msgid ""
"julia> 0//0\n"
"ERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)\n"
"Stacktrace:\n"
"[...]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:289
msgid "As usual, the promotion system makes interactions with other numeric types effortless:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/complex-and-rational-numbers.md:290
#, no-wrap
msgid ""
"julia> 3//5 + 1\n"
"8//5\n"
"\n"
"julia> 3//5 - 0.5\n"
"0.09999999999999998\n"
"\n"
"julia> 2//7 * (1 + 2im)\n"
"2//7 + 4//7*im\n"
"\n"
"julia> 2//7 * (1.5 + 2im)\n"
"0.42857142857142855 + 0.5714285714285714im\n"
"\n"
"julia> 3//2 / (1 + 2im)\n"
"3//10 - 3//5*im\n"
"\n"
"julia> 1//2 + 2im\n"
"1//2 + 2//1*im\n"
"\n"
"julia> 1 + 2//3im\n"
"1//1 - 2//3*im\n"
"\n"
"julia> 0.5 == 1//2\n"
"true\n"
"\n"
"julia> 0.33 == 1//3\n"
"false\n"
"\n"
"julia> 0.33 < 1//3\n"
"true\n"
"\n"
"julia> 1//3 - 0.33\n"
"0.0033333333333332993\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/code-loading.md:1
#, no-wrap
msgid "Code Loading"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:5
#, no-wrap
msgid ""
"!!! note\n"
"    This chapter covers the technical details of package loading. To install packages, use [`Pkg`](@ref Pkg), Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write `import X` or `using X`, as described in the [Modules documentation](@ref modules).\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/code-loading.md:6
#, no-wrap
msgid "Definitions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:9
msgid "Julia has two mechanisms for loading code:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/code-loading.md:12
msgid ""
"**Code inclusion:** e.g. `include(\"source.jl\")`. Inclusion allows you to split a single program across multiple source files. The "
"expression `include(\"source.jl\")` causes the contents of the file `source.jl` to be evaluated in the global scope of the module where the "
"`include` call occurs. If `include(\"source.jl\")` is called multiple times, `source.jl` is evaluated multiple times. The included path, "
"`source.jl`, is interpreted relative to the file where the `include` call occurs. This makes it simple to relocate a subtree of source "
"files. In the REPL, included paths are interpreted relative to the current working directory, [`pwd()`](@ref)."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/code-loading.md:12
msgid ""
"**Package loading:** e.g. `import X` or `using X`. The import mechanism allows you to load a packageâi.e. an independent, reusable "
"collection of Julia code, wrapped in a moduleâand makes the resulting module available by the name `X` inside of the importing module. If "
"the same `X` package is imported multiple times in the same Julia session, it is only loaded the first timeâon subsequent imports, the "
"importing module gets a reference to the same module. Note though, that `import X` can load different packages in different contexts: `X` "
"can refer to one package named `X` in the main project but potentially to different packages also named `X` in each dependency. More on this "
"below."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:14
msgid ""
"Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is "
"built on top of code inclusion and serves a [different purpose](@ref modules). The rest of this chapter focuses on the behavior and "
"mechanics of package loading."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:16
msgid ""
"A *package* is a source tree with a standard layout providing functionality that can be reused by other Julia projects. A package is loaded "
"by `import X` or `using X` statements. These statements also make the module named `X`âwhich results from loading the package codeâavailable "
"within the module where the import statement occurs. The meaning of `X` in `import X` is context-dependent: which `X` package is loaded "
"depends on what code the statement occurs in. Thus, handling of `import X` happens in two stages: first, it determines **what** package is "
"defined to be `X` in this context; second, it determines **where** that particular `X` package is found."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:18
msgid ""
"These questions are answered by searching through the project environments listed in [`LOAD_PATH`](@ref) for project files (`Project.toml` "
"or `JuliaProject.toml`), manifest files (`Manifest.toml` or `JuliaManifest.toml`), or folders of source files."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/code-loading.md:20
#, no-wrap
msgid "Federation of packages"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:23
msgid ""
"Most of the time, a package is uniquely identifiable simply from its name. However, sometimes a project might encounter a situation where it "
"needs to use two different packages that share the same name. While you might be able fix this by renaming one of the packages, being forced "
"to do so can be highly disruptive in a large, shared code base. Instead, Julia's code loading mechanism allows the same package name to "
"refer to different packages in different components of an application."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:25
msgid ""
"Julia supports federated package management, which means that multiple independent parties can maintain both public and private packages and "
"registries of packages, and that projects can depend on a mix of public and private packages from different registries. Packages from "
"various registries are installed and managed using a common set of tools and workflows. The `Pkg` package manager that ships with Julia lets "
"you install and manage your projects' dependencies. It assists in creating and manipulating project files (which describe what other "
"projects that your project depends on), and manifest files (which snapshot exact versions of your project's complete dependency graph)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:27
msgid ""
"One consequence of federation is that there cannot be a central authority for package naming. Different entities may use the same name to "
"refer to unrelated packages. This possibility is unavoidable since these entities do not coordinate and may not even know about each other. "
"Because of the lack of a central naming authority, a single project may end up depending on different packages that have the same name. "
"Julia's package loading mechanism does not require package names to be globally unique, even within the dependency graph of a single "
"project. Instead, packages are identified by [universally unique identifiers](https://en.wikipedia.org/wiki/Universally_unique_identifier) "
"(UUIDs), which get assigned when each package is created. Usually you won't have to work directly with these somewhat cumbersome 128-bit "
"identifiers since `Pkg` will take care of generating and tracking them for you. However, these UUIDs provide the definitive answer to the "
"question of *\"what package does `X` refer to?\"*"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:29
msgid ""
"Since the decentralized naming problem is somewhat abstract, it may help to walk through a concrete scenario to understand the issue. "
"Suppose you're developing an application called `App`, which uses two packages: `Pub` and `Priv`. `Priv` is a private package that you "
"created, whereas `Pub` is a public package that you use but don't control. When you created `Priv`, there was no public package by the name "
"`Priv`. Subsequently, however, an unrelated package also named `Priv` has been published and become popular. In fact, the `Pub` package has "
"started to use it. Therefore, when you next upgrade `Pub` to get the latest bug fixes and features, `App` will end up depending on two "
"different packages named `Priv`âthrough no action of yours other than upgrading. `App` has a direct dependency on your private `Priv` "
"package, and an indirect dependency, through `Pub`, on the new public `Priv` package. Since these two `Priv` packages are different but are "
"both required for `App` to continue working correctly, the expression `import Priv` must refer to different `Priv` packages depending on "
"whether it occurs in `App`'s code or in `Pub`'s code. To handle this, Julia's package loading mechanism distinguishes the two `Priv` "
"packages by their UUID and picks the correct one based on its context (the module that called `import`). How this distinction works is "
"determined by environments, as explained in the following sections."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/code-loading.md:30
#, no-wrap
msgid "Environments"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:33
msgid ""
"An *environment* determines what `import X` and `using X` mean in various code contexts and what files these statements cause to be loaded. "
"Julia understands two kinds of environments:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/code-loading.md:36
msgid ""
"**A project environment** is a directory with a project file and an optional manifest file, and forms an *explicit environement*. The "
"project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a "
"complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to "
"locate and load the correct version."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/code-loading.md:36
msgid ""
"**A package directory** is a directory containing the source trees of a set of packages as subdirectories, and forms an *implicit "
"environment*. If `X` is a subdirectory of a package directory and `X/src/X.jl` exists, then the package `X` is available in the package "
"directory environment and `X/src/X.jl` is the source file by which it is loaded."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:38
msgid ""
"These can be intermixed to create **a stacked environment**: an ordered set of project environments and package directories, overlaid to "
"make a single composite environment. The precedence and visibility rules then combine to determine which packages are available and where "
"they get loaded from. Julia's load path forms a stacked environment, for example."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:40
msgid "These environment each serve a different purpose:"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/code-loading.md:44
msgid ""
"Project environments provide **reproducibility**. By checking a project environment into version controlâe.g. a git repositoryâalong with "
"the rest of the project's source code, you can reproduce the exact state of the project and all of its dependencies. The manifest file, in "
"particular, captures the exact version of every dependency, identified by a cryptographic hash of its source tree, which makes it possible "
"for `Pkg` to retrieve the correct versions and be sure that you are running the exact code that was recorded for all dependencies."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/code-loading.md:44
msgid ""
"Package directories provide **convenience** when a full carefully-tracked project environment is unnecessary. They are useful when you want "
"to put a set of packages somewhere and be able to directly use them, without needing to create a project environment for them."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/code-loading.md:44
msgid ""
"Stacked environments allow for **adding** tools to the primary environment. You can push an environment of development tools onto the end of "
"the stack to make them available from the REPL and scripts, but not from inside packages."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:46
msgid ""
"At a high-level, each environment conceptually defines three maps: roots, graph and paths. When resolving the meaning of `import X`, the "
"roots and graph maps are used to determine the identity of `X`, while the paths map is used to locate the source code of `X`. The specific "
"roles of the three maps are:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:48
msgid "- **roots:** `name::Symbol` â¶ `uuid::UUID`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:50
#, no-wrap
msgid "   An environment's roots map assigns package names to UUIDs for all the top-level dependencies that the environment makes available to the main project (i.e. the ones that can be loaded in `Main`). When Julia encounters `import X` in the main project, it looks up the identity of `X` as `roots[:X]`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:52
msgid "- **graph:** `context::UUID` â¶ `name::Symbol` â¶ `uuid::UUID`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:54
#, no-wrap
msgid "   An environment's graph is a multilevel map which assigns, for each `context` UUID, a map from names to UUIDs, similar to the roots map but specific to that `context`. When Julia sees `import X` in the code of the package whose UUID is `context`, it looks up the identity of `X` as `graph[context][:X]`. In particular, this means that `import X` can refer to different packages depending on `context`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:56
msgid "- **paths:** `uuid::UUID` Ã `name::Symbol` â¶ `path::String`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:58
#, no-wrap
msgid "   The paths map assigns to each package UUID-name pair, the location of that package's entry-point source file. After the identity of `X` in `import X` has been resolved to a UUID via roots or graph (depending on whether it is loaded from the main project or a dependency), Julia determines what file to load to acquire `X` by looking up `paths[uuid,:X]` in the environment. Including this file should define a module named `X`. Once this package is loaded, any subsequent import resolving to the same `uuid` will create a new binding to the already-loaded package module.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:60
msgid "Each kind of environment defines these three maps differently, as detailed in the following sections."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:63
#, no-wrap
msgid ""
"!!! note\n"
"    For ease of understanding, the examples throughout this chapter show full data structures for roots, graph and paths. However, Julia's package loading code does not explicitly create these. Instead, it lazily computes only as much of each structure as it needs to load a given package.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/code-loading.md:64
#, no-wrap
msgid "Project environments"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:67
msgid ""
"A project environment is determined by a directory containing a project file called `Project.toml`, and optionally a manifest file called "
"`Manifest.toml`. These files may also be called `JuliaProject.toml` and `JuliaManifest.toml`, in which case `Project.toml` and `Manifest."
"toml` are ignored. This allows for coexistence with other tools that might consider files called `Project.toml` and `Manifest.toml` "
"significant. For pure Julia projects, however, the names `Project.toml` and `Manifest.toml` are preferred."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:69
msgid "The roots, graph and paths maps of a project environment are defined as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:71
#, no-wrap
msgid "**The roots map** of the environment is determined by the contents of the project file, specifically, its top-level `name` and `uuid` entries and its `[deps]` section (all optional). Consider the following example project file for the hypothetical application, `App`, as described earlier:\n"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/code-loading.md:72 ext/julia/doc/src/manual/code-loading.md:95
#, no-wrap
msgid "toml"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:72
#, no-wrap
msgid ""
"name = \"App\"\n"
"uuid = \"8f986787-14fe-4607-ba5d-fbff2944afa9\"\n"
"\n"
"[deps]\n"
"Priv = \"ba13f791-ae1d-465a-978b-69c3ad90f72b\"\n"
"Pub  = \"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:82
msgid "This project file implies the following roots map, if it was represented by a Julia dictionary:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:83
#, no-wrap
msgid ""
"roots = Dict(\n"
"    :App  => UUID(\"8f986787-14fe-4607-ba5d-fbff2944afa9\"),\n"
"    :Priv => UUID(\"ba13f791-ae1d-465a-978b-69c3ad90f72b\"),\n"
"    :Pub  => UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"),\n"
")\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:92
msgid ""
"Given this roots map, in `App`'s code the statement `import Priv` will cause Julia to look up `roots[:Priv]`, which yields `ba13f791-"
"ae1d-465a-978b-69c3ad90f72b`, the UUID of the `Priv` package that is to be loaded in that context. This UUID identifies which `Priv` package "
"to load and use when the main application evaluates `import Priv`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:94
#, no-wrap
msgid "**The dependency graph** of a project environment is determined by the contents of the manifest file, if present. If there is no manifest file, graph is empty. A manifest file contains a stanza for each of a project's direct or indirect dependencies. For each dependency, the file lists the package's UUID and a source tree hash or an explicit path to the source code. Consider the following example manifest file for `App`:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:95
#, no-wrap
msgid ""
"[[Priv]] # the private one\n"
"deps = [\"Pub\", \"Zebra\"]\n"
"uuid = \"ba13f791-ae1d-465a-978b-69c3ad90f72b\"\n"
"path = \"deps/Priv\"\n"
"\n"
"[[Priv]] # the public one\n"
"uuid = \"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"\n"
"git-tree-sha1 = \"1bf63d3be994fe83456a03b874b409cfd59a6373\"\n"
"version = \"0.1.5\"\n"
"\n"
"[[Pub]]\n"
"uuid = \"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"\n"
"git-tree-sha1 = \"9ebd50e2b0dd1e110e842df3b433cb5869b0dd38\"\n"
"version = \"2.1.4\"\n"
"\n"
"  [Pub.deps]\n"
"  Priv = \"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"\n"
"  Zebra = \"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"\n"
"\n"
"[[Zebra]]\n"
"uuid = \"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"\n"
"git-tree-sha1 = \"e808e36a5d7173974b90a15a353b564f3494092f\"\n"
"version = \"3.4.2\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:122
msgid "This manifest file describes a possible complete dependency graph for the `App` project:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:127
#, no-wrap
msgid ""
"- There are two different packages named `Priv` that the application uses. It uses a private package, which is a root dependency, and a public one, which is an indirect dependency through `Pub`. These are differentiated by their distinct UUIDs, and they have different deps:\n"
"  * The private `Priv` depends on the `Pub` and `Zebra` packages.\n"
"  * The public `Priv` has no dependencies.\n"
"- The application also depends on the `Pub` package, which in turn depends on the public `Priv ` and the same `Zebra` package that the private `Priv` package depends on.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:130
msgid "This dependency graph represented as a dictionary, looks like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:131
#, no-wrap
msgid ""
"graph = Dict(\n"
"    # Priv â the private one:\n"
"    UUID(\"ba13f791-ae1d-465a-978b-69c3ad90f72b\") => Dict(\n"
"        :Pub   => UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"),\n"
"        :Zebra => UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"),\n"
"    ),\n"
"    # Priv â the public one:\n"
"    UUID(\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\") => Dict(),\n"
"    # Pub:\n"
"    UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\") => Dict(\n"
"        :Priv  => UUID(\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"),\n"
"        :Zebra => UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"),\n"
"    ),\n"
"    # Zebra:\n"
"    UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\") => Dict(),\n"
")\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:151
msgid ""
"Given this dependency `graph`, when Julia sees `import Priv` in the `Pub` packageâwhich has UUID `c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1`âit "
"looks up:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:152
#, no-wrap
msgid "graph[UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\")][:Priv]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:157
msgid ""
"and gets `2d15fe94-a1f7-436c-a4d8-07a9a496e01c`, which indicates that in the context of the `Pub` package, `import Priv` refers to the "
"public `Priv` package, rather than the private one which the app depends on directly. This is how the name `Priv` can refer to different "
"packages in the main project than it does in one of its package's dependencies, which allows for duplicate names in the package ecosystem."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:159
msgid ""
"What happens if `import Zebra` is evaluated in the main `App` code base? Since `Zebra` does not appear in the project file, the import will "
"fail even though `Zebra` *does* appear in the manifest file. Moreover, if `import Zebra` occurs in the public `Priv` packageâthe one with "
"UUID `2d15fe94-a1f7-436c-a4d8-07a9a496e01c`âthen that would also fail since that `Priv` package has no declared dependencies in the manifest "
"file and therefore cannot load any packages. The `Zebra` package can only be loaded by packages for which it appear as an explicit "
"dependency in the manifest file: the `Pub` package and one of the `Priv` packages."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:161
#, no-wrap
msgid "**The paths map** of a project environment is extracted from the manifest file. The path of a package `uuid` named `X` is determined by these rules (in order):\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:168
#, no-wrap
msgid ""
"1. If the project file in the directory matches `uuid` and name `X`, then either:\n"
"  - It has a toplevel `path` entry, then `uuid` will be mapped to that path, interpreted relative to the directory containing the project file.\n"
"  - Otherwise, `uuid` is mapped to  `src/X.jl` relative to the directory containing the project file.\n"
"2. If the above is not the case and the project file has a corresponding manifest file and the manifest contains a stanza matching `uuid` then:\n"
"  - If it has a `path` entry, use that path (relative to the directory containing the manifest file).\n"
"  - If it has a `git-tree-sha1` entry, compute a deterministic hash function of `uuid` and `git-tree-sha1`âcall it `slug`âand look for a directory named `packages/X/$slug` in each directory in the Julia `DEPOT_PATH` global array. Use the first such directory that exists.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:170
msgid ""
"If any of these result in success, the path to the source code entry point will be either that result, the relative path from that result "
"plus `src/X.jl`; otherwise, there is no path mapping for `uuid`. When loading `X`, if no source code path is found, the lookup will fail, "
"and the user may be prompted to install the appropriate package version or to take other corrective action (e.g. declaring `X` as a "
"dependency)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:172
msgid ""
"In the example manifest file above, to find the path of the first `Priv` packageâthe one with UUID `ba13f791-ae1d-465a-978b-69c3ad90f72b`â"
"Julia looks for its stanza in the manifest file, sees that it has a `path` entry, looks at `deps/Priv` relative to the `App` project "
"directoryâlet's suppose the `App` code lives in `/home/me/projects/App`âsees that `/home/me/projects/App/deps/Priv` exists and therefore "
"loads `Priv` from there."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:174
msgid ""
"If, on the other hand, Julia was loading the *other* `Priv` packageâthe one with UUID `2d15fe94-a1f7-436c-a4d8-07a9a496e01c`âit finds its "
"stanza in the manifest, see that it does *not* have a `path` entry, but that it does have a `git-tree-sha1` entry. It then computes the "
"`slug` for this UUID/SHA-1 pair, which is `HDkrT` (the exact details of this computation aren't important, but it is consistent and "
"deterministic). This means that the path to this `Priv` package will be `packages/Priv/HDkrT/src/Priv.jl` in one of the package depots. "
"Suppose the contents of `DEPOT_PATH` is `[\"/home/me/.julia\", \"/usr/local/julia\"]`, then Julia will look at the following paths to see if "
"they exist:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/code-loading.md:177
msgid "`/home/me/.julia/packages/Priv/HDkrT`"
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/code-loading.md:177
msgid "`/usr/local/julia/packages/Priv/HDkrT`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:179
msgid ""
"Julia uses the first of these that exists to try to load the public `Priv` package from the file `packages/Priv/HDKrT/src/Priv.jl` in the "
"depot where it was found."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:183
msgid ""
"Here is a representation of a possible paths map for our example `App` project environment, as provided in the Manifest given above for the "
"dependency graph, after searching the local file system:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:184
#, no-wrap
msgid ""
"paths = Dict(\n"
"    # Priv â the private one:\n"
"    (UUID(\"ba13f791-ae1d-465a-978b-69c3ad90f72b\"), :Priv) =>\n"
"        # relative entry-point inside `App` repo:\n"
"        \"/home/me/projects/App/deps/Priv/src/Priv.jl\",\n"
"    # Priv â the public one:\n"
"    (UUID(\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"), :Priv) =>\n"
"        # package installed in the system depot:\n"
"        \"/usr/local/julia/packages/Priv/HDkr/src/Priv.jl\",\n"
"    # Pub:\n"
"    (UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"), :Pub) =>\n"
"        # package installed in the user depot:\n"
"        \"/home/me/.julia/packages/Pub/oKpw/src/Pub.jl\",\n"
"    # Zebra:\n"
"    (UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"), :Zebra) =>\n"
"        # package installed in the system depot:\n"
"        \"/usr/local/julia/packages/Zebra/me9k/src/Zebra.jl\",\n"
")\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:206
msgid "This example map includes three different kinds of package locations (the first and third are part of the default load path):"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/code-loading.md:210
msgid "The private `Priv` package is \"[vendored](https://stackoverflow.com/a/35109534)\" inside the `App` repository."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/code-loading.md:210
msgid ""
"The public `Priv` and `Zebra` packages are in the system depot, where packages installed and managed by the system administrator live. These "
"are available to all users on the system."
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/manual/code-loading.md:210
msgid ""
"The `Pub` package is in the user depot, where packages installed by the user live. These are only available to the user who installed them."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/code-loading.md:212
#, no-wrap
msgid "Package directories"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:215
msgid ""
"Package directories provide a simpler kind of environment without the ability to handle name collisions. In a package directory, the set of "
"top-level packages is the set of subdirectories that \"look like\" packages. A package `X` is exists in a package directory if the directory "
"contains one of the following \"entry point\" files:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:219
msgid "- `X.jl` - `X/src/X.jl` - `X.jl/src/X.jl`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:221
msgid "Which dependencies a package in a package directory can import depends on whether the package contains a project file:"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/code-loading.md:224
msgid "If it has a project file, it can only import those packages which are identified in the `[deps]` section of the project file."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/code-loading.md:224
msgid ""
"If it does not have a project file, it can import any top-level packageâi.e. the same packages that can be loaded in `Main` or the REPL."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:227
#, no-wrap
msgid ""
"**The roots map** is determined by examining the contents of the package directory to generate a list of all packages that exist.\n"
"Additionally, a UUID will be assigned to each entry as follows: For a given package found inside the folder `X`...\n"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/code-loading.md:231
msgid "If `X/Project.toml` exists and has a `uuid` entry, then `uuid` is that value."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/code-loading.md:231
msgid ""
"If `X/Project.toml` exists and but does *not* have a top-level UUID entry, `uuid` is a dummy UUID generated by hashing the canonical (real) "
"path to `X/Project.toml`."
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/manual/code-loading.md:231
msgid ""
"Otherwise (if `Project.toml` does not exist), then `uuid` is the all-zero [nil UUID](https://en.wikipedia.org/wiki/"
"Universally_unique_identifier#Nil_UUID)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:233
#, no-wrap
msgid "**The dependency graph** of a project directory is determined by the presence and contents of project files in the subdirectory of each package. The rules are:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:236
msgid ""
"- If a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, "
"the same as the main project and REPL.  - If a package subdirectory has a project file, then the graph entry for its UUID is the `[deps]` "
"map of the project file, which is considered to be empty if the section is absent."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:238
msgid "As an example, suppose a package directory has the following structure and content:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:239
#, no-wrap
msgid ""
"Aardvark/\n"
"    src/Aardvark.jl:\n"
"        import Bobcat\n"
"        import Cobra\n"
"\n"
"Bobcat/\n"
"    Project.toml:\n"
"        [deps]\n"
"        Cobra = \"4725e24d-f727-424b-bca0-c4307a3456fa\"\n"
"        Dingo = \"7a7925be-828c-4418-bbeb-bac8dfc843bc\"\n"
"\n"
"    src/Bobcat.jl:\n"
"        import Cobra\n"
"        import Dingo\n"
"\n"
"Cobra/\n"
"    Project.toml:\n"
"        uuid = \"4725e24d-f727-424b-bca0-c4307a3456fa\"\n"
"        [deps]\n"
"        Dingo = \"7a7925be-828c-4418-bbeb-bac8dfc843bc\"\n"
"\n"
"    src/Cobra.jl:\n"
"        import Dingo\n"
"\n"
"Dingo/\n"
"    Project.toml:\n"
"        uuid = \"7a7925be-828c-4418-bbeb-bac8dfc843bc\"\n"
"\n"
"    src/Dingo.jl:\n"
"        # no imports\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:273
msgid "Here is a corresponding roots structure, represented as a dictionary:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:274
#, no-wrap
msgid ""
"roots = Dict(\n"
"    :Aardvark => UUID(\"00000000-0000-0000-0000-000000000000\"), # no project file, nil UUID\n"
"    :Bobcat   => UUID(\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\"), # dummy UUID based on path\n"
"    :Cobra    => UUID(\"4725e24d-f727-424b-bca0-c4307a3456fa\"), # UUID from project file\n"
"    :Dingo    => UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\"), # UUID from project file\n"
")\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:284
msgid "Here is the corresponding graph structure, represented as a dictionary:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:285
#, no-wrap
msgid ""
"graph = Dict(\n"
"    # Bobcat:\n"
"    UUID(\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\") => Dict(\n"
"        :Cobra => UUID(\"4725e24d-f727-424b-bca0-c4307a3456fa\"),\n"
"        :Dingo => UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\"),\n"
"    ),\n"
"    # Cobra:\n"
"    UUID(\"4725e24d-f727-424b-bca0-c4307a3456fa\") => Dict(\n"
"        :Dingo => UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\"),\n"
"    ),\n"
"    # Dingo:\n"
"    UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\") => Dict(),\n"
")\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:302
msgid "A few general rules to note:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/code-loading.md:306
msgid ""
"A package without a project file can depend on any top-level dependency, and since every package in a package directory is available at the "
"top-level, it can import all packages in the environment."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/code-loading.md:306
msgid ""
"A package with a project file cannot depend on one without a project file since packages with project files can only load packages in "
"`graph` and packages without project files do not appear in `graph`."
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/manual/code-loading.md:306
msgid ""
"A package with a project file but no explicit UUID can only be depended on by packages without project files since dummy UUIDs assigned to "
"these packages are strictly internal."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:308
msgid "Observe the following specific instances of these rules in our example:"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/code-loading.md:315
msgid "`Aardvark` can import on any of `Bobcat`, `Cobra` or `Dingo`; it does import `Bobcat` and `Cobra`."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/code-loading.md:315
msgid ""
"`Bobcat` can and does import both `Cobra` and `Dingo`, which both have project files with UUIDs and are declared as dependencies in "
"`Bobcat`'s `[deps]` section."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/code-loading.md:315
msgid "`Bobcat` cannot depend on `Aardvark` since `Aardvark` does not have a project file."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/code-loading.md:315
msgid "`Cobra` can and does import `Dingo`, which has a project file and UUID, and is declared as a dependency in `Cobra`'s `[deps]` section."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/code-loading.md:315
msgid "`Cobra` cannot depend on `Aardvark` or `Bobcat` since neither have real UUIDs."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/code-loading.md:315
msgid "`Dingo` cannot import anything because it has a project file without a `[deps]` section."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:317
#, no-wrap
msgid "**The paths map** in a package directory is simple: it maps subdirectory names to their corresponding entry-point paths. In other words, if the path to our example project directory is `/home/me/animals` then the `paths` map could be represented by this dictionary:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:318
#, no-wrap
msgid ""
"paths = Dict(\n"
"    (UUID(\"00000000-0000-0000-0000-000000000000\"), :Aardvark) =>\n"
"        \"/home/me/AnimalPackages/Aardvark/src/Aardvark.jl\",\n"
"    (UUID(\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\"), :Bobcat) =>\n"
"        \"/home/me/AnimalPackages/Bobcat/src/Bobcat.jl\",\n"
"    (UUID(\"4725e24d-f727-424b-bca0-c4307a3456fa\"), :Cobra) =>\n"
"        \"/home/me/AnimalPackages/Cobra/src/Cobra.jl\",\n"
"    (UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\"), :Dingo) =>\n"
"        \"/home/me/AnimalPackages/Dingo/src/Dingo.jl\",\n"
")\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:332
msgid ""
"Since all packages in a package directory environment are, by definition, subdirectories with the expected entry-point files, their `paths` "
"map entries always have this form."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/code-loading.md:333
#, no-wrap
msgid "Environment stacks"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:336
msgid ""
"The third and final kind of environment is one that combines other environments by overlaying several of them, making the packages in each "
"available in a single composite environment. These composite environments are called *environment stacks*. The Julia `LOAD_PATH` global "
"defines an environment stackâthe environment in which the Julia process operates. If you want your Julia process to have access only to the "
"packages in one project or package directory, make it the only entry in `LOAD_PATH`. It is often quite useful, however, to have access to "
"some of your favorite toolsâstandard libraries, profilers, debuggers, personal utilities, etc.âeven if they are not dependencies of the "
"project you're working on. By adding an environment containing these tools to the load path, you immediately have access to them in top-"
"level code without needing to add them to your project."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:338
msgid ""
"The mechanism for combining the roots, graph and paths data structures of the components of an environment stack is simple: they are merged "
"as dictionaries, favoring earlier entries over later ones in the case of key collisions. In other words, if we have `stack = [envâ, envâ, "
"â¦]` then we have:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:339
#, no-wrap
msgid ""
"roots = reduce(merge, reverse([rootsâ, rootsâ, â¦]))\n"
"graph = reduce(merge, reverse([graphâ, graphâ, â¦]))\n"
"paths = reduce(merge, reverse([pathsâ, pathsâ, â¦]))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:346
msgid ""
"The subscripted `rootsáµ¢`, `grapháµ¢` and `pathsáµ¢` variables correspond to the subscripted environments, `enváµ¢`, contained in `stack`. The "
"`reverse` is present because `merge` favors the last argument rather than first when there are collisions between keys in its argument "
"dictionaries. There are a couple of noteworthy features of this design:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/code-loading.md:349
msgid ""
"The *primary environment*âi.e. the first environment in a stackâis faithfully embedded in a stacked environment. The full dependency graph "
"of the first environment in a stack is guaranteed to be included intact in the stacked environment including the same versions of all "
"dependencies."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/code-loading.md:349
msgid ""
"Packages in non-primary environments can end up using incompatible versions of their dependencies even if their own environments are "
"entirely compatible. This can happen when one of their dependencies is shadowed by a version in an earlier environment in the stack (either "
"by graph or path, or both)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:351
msgid ""
"Since the primary environment is typically the environment of a project you're working on, while environments later in the stack contain "
"additional tools, this is the right trade-off: it's better to break your development tools but keep the project working. When such "
"incompatibilities occur, you'll typically want to upgrade your dev tools to versions that are compatible with the main project."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/code-loading.md:352
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/code-loading.md:354
msgid ""
"Federated package management and precise software reproducibility are difficult but worthy goals in a package system. In combination, these "
"goals lead to a more complex package loading mechanism than most dynamic languages have, but it also yields scalability and reproducibility "
"that is more commonly associated with static languages. Typically, Julia users should be able to use the built-in package manager to manage "
"their projects without needing a precise understanding of these interactions. A call to `Pkg.add(\"X\")` will add to the appropriate project "
"and manifest files, selected via `Pkg.activate(\"Y\")`, so that a future call to `import X` will load `X` without further thought."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/faq.md:1
#, no-wrap
msgid "Frequently Asked Questions"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/faq.md:3
#, no-wrap
msgid "General"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:5
#, no-wrap
msgid "Is Julia named after someone or something?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:8
msgid "No."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:9
#, no-wrap
msgid "Why don't you compile Matlab/Python/R/â¦ code to Julia?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:12
msgid ""
"Since many people are familiar with the syntax of other dynamic languages, and lots of code has already been written in those languages, it "
"is natural to wonder why we didn't just plug a Matlab or Python front-end into a Julia back-end (or âtranspileâ code to Julia) in order to "
"get all the performance benefits of Julia without requiring programmers to learn a new language.  Simple, right?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:14
#, no-wrap
msgid "The basic issue is that there is *nothing special about Julia's compiler*: we use a commonplace compiler (LLVM) with no âsecret sauceâ that other language developers don't know about.  Indeed, Julia's compiler is in many ways much simpler than those of other dynamic languages (e.g. PyPy or LuaJIT).   Julia's performance advantage derives almost entirely from its front-end: its language semantics allow a [well-written Julia program](@ref man-performance-tips) to *give more opportunities to the compiler* to generate efficient code and memory layouts.  If you tried to compile Matlab or Python code to Julia, our compiler would be limited by the semantics of Matlab or Python to producing code no better than that of existing compilers for those languages (and probably worse).  The key role of semantics is also why several existing Python compilers (like Numba and Pythran) only attempt to optimize a small subset of the language (e.g. operations on Numpy arrays and scalars), and for this subset they are already doing at least as well as we could for the same semantics.  The people working on those projects are incredibly smart and have accomplished amazing things, but retrofitting a compiler onto a language that was designed to be interpreted is a very difficult problem.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:16
msgid ""
"Julia's advantage is that good performance is not limited to a small subset of âbuilt-inâ types and operations, and one can write high-level "
"type-generic code that works on arbitrary user-defined types while remaining fast and memory-efficient.  Types in languages like Python "
"simply don't provide enough information to the compiler for similar capabilities, so as soon as you used those languages as a Julia front-"
"end you would be stuck."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:18
msgid ""
"For similar reasons, automated translation to Julia would also typically generate unreadable, slow, non-idiomatic code that would not be a "
"good starting point for a native Julia port from another language."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:20
msgid ""
"On the other hand, language *interoperability* is extremely useful: we want to exploit existing high-quality code in other languages from "
"Julia (and vice versa)! The best way to enable this is not a transpiler, but rather via easy inter-language calling facilities.  We have "
"worked hard on this, from the built-in `ccall` intrinsic (to call C and Fortran libraries) to [JuliaInterop](https://github.com/"
"JuliaInterop) packages that connect Julia to Python, Matlab, C++, and more."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/faq.md:21
#, no-wrap
msgid "Sessions and the REPL"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:23
#, no-wrap
msgid "How do I delete an object in memory?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:27
msgid ""
"Julia does not have an analog of MATLAB's `clear` function; once a name is defined in a Julia session (technically, in module `Main`), it is "
"always present."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:32
#, no-wrap
msgid ""
"If memory usage is your concern, you can always replace objects with ones that consume less memory.\n"
" For example, if `A` is a gigabyte-sized array that you no longer need, you can free the memory\n"
"with `A = nothing`.  The memory will be released the next time the garbage collector runs; you can force\n"
"this to happen with [`gc()`](@ref Base.GC.gc). Moreover, an attempt to use `A` will likely result in an error, because most methods are not defined on type `Nothing`.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:33
#, no-wrap
msgid "How can I modify the declaration of a type in my session?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:37
msgid "Perhaps you've defined a type and then realize you need to add a new field.  If you try this at the REPL, you get the error:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:38
#, no-wrap
msgid "ERROR: invalid redefinition of constant MyType\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:43
msgid "Types in module `Main` cannot be redefined."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:49
#, no-wrap
msgid ""
"While this can be inconvenient when you are developing new code, there's an excellent workaround.\n"
" Modules can be replaced by redefining them, and so if you wrap all your new code inside a module\n"
"you can redefine types and constants.  You can't import the type names into `Main` and then expect\n"
"to be able to redefine them there, but you can use the module name to resolve the scope.  In other\n"
"words, while developing you might use a workflow something like this:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:50
#, no-wrap
msgid ""
"include(\"mynewcode.jl\")              # this defines a module MyModule\n"
"obj1 = MyModule.ObjConstructor(a, b)\n"
"obj2 = MyModule.somefunction(obj1)\n"
"# Got an error. Change something in \"mynewcode.jl\"\n"
"include(\"mynewcode.jl\")              # reload the module\n"
"obj1 = MyModule.ObjConstructor(a, b) # old objects are no longer valid, must reconstruct\n"
"obj2 = MyModule.somefunction(obj1)   # this time it worked!\n"
"obj3 = MyModule.someotherfunction(obj2, c)\n"
"...\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/faq.md:62
#, no-wrap
msgid "[Scripting](@id man-scripting)"
msgstr "[ã¹ã¯ãªããã®ä½æ](@id man-scripting)"

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:64
#, no-wrap
msgid "How do I check if the current file is being run as the main script?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:69
msgid ""
"When a file is run as the main script using `julia file.jl` one might want to activate extra functionality like command line argument "
"handling. A way to determine that a file is run in this fashion is to check if `abspath(PROGRAM_FILE) == @__FILE__` is `true`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:70
#, no-wrap
msgid "How do I catch CTRL-C in a script?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:79
msgid ""
"Running a Julia script using `julia file.jl` does not throw [`InterruptException`](@ref) when you try to terminate it with CTRL-C (SIGINT).  "
"To run a certain code before terminating a Julia script, which may or may not be caused by CTRL-C, use [`atexit`](@ref).  Alternatively, you "
"can use `julia -e 'include(popfirst!(ARGS))' file.jl` to execute a script while being able to catch `InterruptException` in the [`try`]"
"(@ref) block."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:80
#, no-wrap
msgid "How do I pass options to `julia` using `#!/usr/bin/env`?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:89
msgid ""
"Passing options to `julia` in so-called shebang by, e.g., `#!/usr/bin/env julia --startup-file=no` may not work in some platforms such as "
"Linux.  This is because argument parsing in shebang is platform-dependent and not well-specified.  In a Unix-like environment, a reliable "
"way to pass options to `julia` in an executable script would be to start the script as a `bash` script and use `exec` to replace the process "
"to `julia`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:90
#, no-wrap
msgid ""
"#!/bin/bash\n"
"#=\n"
"exec julia --color=yes --startup-file=no -e 'include(popfirst!(ARGS))' \\\n"
"    \"${BASH_SOURCE[0]}\" \"$@\"\n"
"=#\n"
"\n"
"@show ARGS  # put any Julia code here\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:104
msgid ""
"In the example above, the code between `#=` and `=#` is run as a `bash` script.  Julia ignores this part since it is a multi-line comment "
"for Julia.  The Julia code after `=#` is ignored by `bash` since it stops parsing the file once it reaches to the `exec` statement."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/faq.md:105
#, no-wrap
msgid "Functions"
msgstr "[é¢æ°](@id Functions)"

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:107
#, no-wrap
msgid "I passed an argument `x` to a function, modified it inside that function, but on the outside, the variable `x` is still unchanged. Why?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:110
msgid "Suppose you call a function like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:111
#, no-wrap
msgid ""
"julia> x = 10\n"
"10\n"
"\n"
"julia> function change_value!(y)\n"
"           y = 17\n"
"       end\n"
"change_value! (generic function with 1 method)\n"
"\n"
"julia> change_value!(x)\n"
"17\n"
"\n"
"julia> x # x is unchanged!\n"
"10\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:131
msgid ""
"In Julia, the binding of a variable `x` cannot be changed by passing `x` as an argument to a function.  When calling `change_value!(x)` in "
"the above example, `y` is a newly created variable, bound initially to the value of `x`, i.e. `10`; then `y` is rebound to the constant "
"`17`, while the variable `x` of the outer scope is left untouched."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:135
msgid ""
"But here is a thing you should pay attention to: suppose `x` is bound to an object of type `Array` (or any other *mutable* type). From "
"within the function, you cannot \"unbind\" `x` from this Array, but you can change its content. For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:136
#, no-wrap
msgid ""
"julia> x = [1,2,3]\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"julia> function change_array!(A)\n"
"           A[1] = 5\n"
"       end\n"
"change_array! (generic function with 1 method)\n"
"\n"
"julia> change_array!(x)\n"
"5\n"
"\n"
"julia> x\n"
"3-element Array{Int64,1}:\n"
" 5\n"
" 2\n"
" 3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:162
msgid ""
"Here we created a function `change_array!`, that assigns `5` to the first element of the passed array (bound to `x` at the call site, and "
"bound to `A` within the function). Notice that, after the function call, `x` is still bound to the same array, but the content of that array "
"changed: the variables `A` and `x` were distinct bindings referring to the same mutable `Array` object."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:163
#, no-wrap
msgid "Can I use `using` or `import` inside a function?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:168
msgid ""
"No, you are not allowed to have a `using` or `import` statement inside a function.  If you want to import a module but only use its symbols "
"inside a specific function or set of functions, you have two options:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/faq.md:170
msgid "Use `import`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:171
#, no-wrap
msgid ""
"   import Foo\n"
"   function bar(...)\n"
"       # ... refer to Foo symbols via Foo.baz ...\n"
"   end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:182
#, no-wrap
msgid ""
"   This loads the module `Foo` and defines a variable `Foo` that refers to the module, but does not\n"
"   import any of the other symbols from the module into the current namespace.  You refer to the\n"
"   `Foo` symbols by their qualified names `Foo.bar` etc.\n"
"2. Wrap your function in a module:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:183
#, no-wrap
msgid ""
"   module Bar\n"
"   export bar\n"
"   using Foo\n"
"   function bar(...)\n"
"       # ... refer to Foo.baz as simply baz ....\n"
"   end\n"
"   end\n"
"   using Bar\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:195
#, no-wrap
msgid "   This imports all the symbols from `Foo`, but only inside the module `Bar`.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:196
#, no-wrap
msgid "What does the `...` operator do?"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:198
#, no-wrap
msgid "The two uses of the `...` operator: slurping and splatting"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:202
msgid ""
"Many newcomers to Julia find the use of `...` operator confusing. Part of what makes the `...` operator confusing is that it means two "
"different things depending on context."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:203
#, no-wrap
msgid "`...` combines many arguments into one argument in function definitions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:208
msgid ""
"In the context of function definitions, the `...` operator is used to combine many different arguments into a single argument. This use of "
"`...` for combining many different arguments into a single argument is called slurping:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:209
#, no-wrap
msgid ""
"julia> function printargs(args...)\n"
"           println(typeof(args))\n"
"           for (i, arg) in enumerate(args)\n"
"               println(\"Arg #$i = $arg\")\n"
"           end\n"
"       end\n"
"printargs (generic function with 1 method)\n"
"\n"
"julia> printargs(1, 2, 3)\n"
"Tuple{Int64,Int64,Int64}\n"
"Arg #1 = 1\n"
"Arg #2 = 2\n"
"Arg #3 = 3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:227
#, no-wrap
msgid ""
"If Julia were a language that made more liberal use of ASCII characters, the slurping operator\n"
"might have been written as `<-...` instead of `...`.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:228
#, no-wrap
msgid "`...` splits one argument into many different arguments in function calls"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:234
msgid ""
"In contrast to the use of the `...` operator to denote slurping many different arguments into one argument when defining a function, the `..."
"` operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a "
"function call. This use of `...` is called splatting:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:235
#, no-wrap
msgid ""
"julia> function threeargs(a, b, c)\n"
"           println(\"a = $a::$(typeof(a))\")\n"
"           println(\"b = $b::$(typeof(b))\")\n"
"           println(\"c = $c::$(typeof(c))\")\n"
"       end\n"
"threeargs (generic function with 1 method)\n"
"\n"
"julia> x = [1, 2, 3]\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"julia> threeargs(x...)\n"
"a = 1::Int64\n"
"b = 2::Int64\n"
"c = 3::Int64\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:257
#, no-wrap
msgid ""
"If Julia were a language that made more liberal use of ASCII characters, the splatting operator\n"
"might have been written as `...->` instead of `...`.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:258
#, no-wrap
msgid "What is the return value of an assignment?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:261
msgid "The operator `=` always returns the right-hand side, therefore:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:262
#, no-wrap
msgid ""
"julia> function threeint()\n"
"           x::Int = 3.0\n"
"           x # returns variable x\n"
"       end\n"
"threeint (generic function with 1 method)\n"
"\n"
"julia> function threefloat()\n"
"           x::Int = 3.0 # returns 3.0\n"
"       end\n"
"threefloat (generic function with 1 method)\n"
"\n"
"julia> threeint()\n"
"3\n"
"\n"
"julia> threefloat()\n"
"3.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:282
msgid "and similarly:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:283
#, no-wrap
msgid ""
"julia> function threetup()\n"
"           x, y = [3, 3]\n"
"           x, y # returns a tuple\n"
"       end\n"
"threetup (generic function with 1 method)\n"
"\n"
"julia> function threearr()\n"
"           x, y = [3, 3] # returns an array\n"
"       end\n"
"threearr (generic function with 1 method)\n"
"\n"
"julia> threetup()\n"
"(3, 3)\n"
"\n"
"julia> threearr()\n"
"2-element Array{Int64,1}:\n"
" 3\n"
" 3\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/faq.md:304
#, no-wrap
msgid "Types, type declarations, and constructors"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:306
#, no-wrap
msgid "[What does \"type-stable\" mean?](@id man-type-stability)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:311
msgid ""
"It means that the type of the output is predictable from the types of the inputs.  In particular, it means that the type of the output "
"cannot vary depending on the *values* of the inputs. The following code is *not* type-stable:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:312
#, no-wrap
msgid ""
"julia> function unstable(flag::Bool)\n"
"           if flag\n"
"               return 1\n"
"           else\n"
"               return 1.0\n"
"           end\n"
"       end\n"
"unstable (generic function with 1 method)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:327
msgid ""
"It returns either an `Int` or a [`Float64`](@ref) depending on the value of its argument.  Since Julia can't predict the return type of this "
"function at compile-time, any computation that uses it will have to guard against both types possibly occurring, making generation of fast "
"machine code difficult."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:328
#, no-wrap
msgid "[Why does Julia give a `DomainError` for certain seemingly-sensible operations?](@id faq-domain-errors)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:331
msgid "Certain operations make mathematical sense but result in errors:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:332
#, no-wrap
msgid ""
"julia> sqrt(-2.0)\n"
"ERROR: DomainError with -2.0:\n"
"sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n"
"Stacktrace:\n"
"[...]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:346
msgid ""
"This behavior is an inconvenient consequence of the requirement for type-stability.  In the case of [`sqrt`](@ref), most users want "
"`sqrt(2.0)` to give a real number, and would be unhappy if it produced the complex number `1.4142135623730951 + 0.0im`.  One could write the "
"[`sqrt`](@ref)  function to switch to a complex-valued output only when passed a negative number (which is what [`sqrt`](@ref) does in some "
"other languages), but then the result would not be [type-stable](@ref man-type-stability)  and the [`sqrt`](@ref) function would have poor "
"performance."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:349
msgid ""
"In these and other cases, you can get the result you want by choosing an *input type* that conveys your willingness to accept an *output "
"type* in which the result can be represented:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:350
#, no-wrap
msgid ""
"julia> sqrt(-2.0+0im)\n"
"0.0 + 1.4142135623730951im\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:355
#, no-wrap
msgid "[Why does Julia use native machine integer arithmetic?](@id faq-integer-arithmetic)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:360
msgid ""
"Julia uses machine arithmetic for integer computations. This means that the range of `Int` values is bounded and wraps around at either end "
"so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:361
#, no-wrap
msgid ""
"julia> typemax(Int)\n"
"9223372036854775807\n"
"\n"
"julia> ans+1\n"
"-9223372036854775808\n"
"\n"
"julia> -ans\n"
"-9223372036854775808\n"
"\n"
"julia> 2*ans\n"
"0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:378
msgid ""
"Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language "
"to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:388
msgid ""
"One alternative to consider would be to check each integer operation for overflow and promote results to bigger integer types such as "
"[`Int128`](@ref) or [`BigInt`](@ref) in the case of overflow.  Unfortunately, this introduces major overhead on every integer operation "
"(think incrementing a loop counter) â it requires emitting code to perform run-time overflow checks after arithmetic instructions and "
"branches to handle potential overflows. Worse still, this would cause every computation involving integers to be type-unstable. As we "
"mentioned above, [type-stability is crucial](@ref man-type-stability)  for effective generation of efficient code. If you can't count on the "
"results of integer operations being integers, it's impossible to generate fast, simple code the way C and Fortran compilers do."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:406
msgid ""
"A variation on this approach, which avoids the appearance of type instability is to merge the `Int` and [`BigInt`](@ref) types into a single "
"hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this "
"superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same "
"difficulties onto the C code implementing this hybrid integer type. This approach *can* be made to work and can even be made quite fast in "
"many cases, but has several drawbacks.  One problem is that the in-memory representation of integers and arrays of integers no longer match "
"the natural representation used by C, Fortran and other languages with native machine integers.  Thus, to interoperate with those languages, "
"we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of "
"bits, and thus cannot be stored inline in an array with fixed-size slots â large integer values will always require separate heap-allocated "
"storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps â situations where "
"performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer "
"arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations "
"a poor choice for high-performance numerical work."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:410
msgid ""
"An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer "
"value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlabâ¢ does:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:411
#, no-wrap
msgid ""
">> int64(9223372036854775807)\n"
"\n"
"ans =\n"
"\n"
"  9223372036854775807\n"
"\n"
">> int64(9223372036854775807) + 1\n"
"\n"
"ans =\n"
"\n"
"  9223372036854775807\n"
"\n"
">> int64(-9223372036854775808)\n"
"\n"
"ans =\n"
"\n"
" -9223372036854775808\n"
"\n"
">> int64(-9223372036854775808) - 1\n"
"\n"
"ans =\n"
"\n"
" -9223372036854775808\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:446
msgid ""
"At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is "
"and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, "
"however, is deeply problematic.  The first and most obvious issue is that this is not the way machine integer arithmetic works, so "
"implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and "
"replace the result with [`typemin(Int)`](@ref)  or [`typemax(Int)`](@ref) as appropriate. This alone expands each integer operation from a "
"single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse â saturating integer "
"arithmetic isn't associative. Consider this Matlab computation:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:447
#, no-wrap
msgid ""
">> n = int64(2)^62\n"
"4611686018427387904\n"
"\n"
">> n + (n - 1)\n"
"9223372036854775807\n"
"\n"
">> (n + n) - 1\n"
"9223372036854775806\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:461
#, no-wrap
msgid ""
"This makes it hard to write many basic integer algorithms since a lot of common techniques depend\n"
"on the fact that machine addition with overflow *is* associative. Consider finding the midpoint\n"
"between integer values `lo` and `hi` in Julia using the expression `(lo + hi) >>> 1`:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:462
#, no-wrap
msgid ""
"julia> n = 2^62\n"
"4611686018427387904\n"
"\n"
"julia> (n + 2n) >>> 1\n"
"6917529027641081856\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:472
msgid ""
"See? No problem. That's the correct midpoint between 2^62 and 2^63, despite the fact that `n + 2n` is -4611686018427387904. Now try it in "
"Matlab:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:473
#, no-wrap
msgid ""
">> (n + 2*n)/2\n"
"\n"
"ans =\n"
"\n"
"  4611686018427387904\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:483
#, no-wrap
msgid ""
"Oops. Adding a `>>>` operator to Matlab wouldn't help, because saturation that occurs when adding\n"
"`n` and `2n` has already destroyed the information necessary to compute the correct midpoint.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:489
msgid ""
"Not only is lack of associativity unfortunate for programmers who cannot rely it for techniques like this, but it also defeats almost "
"anything compilers might want to do to optimize integer arithmetic. For example, since Julia integers use normal machine integer arithmetic, "
"LLVM is free to aggressively optimize simple little functions like `f(k) = 5k-1`. The machine code for this function is just this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:490
#, no-wrap
msgid ""
"julia> code_native(f, Tuple{Int})\n"
"  .text\n"
"Filename: none\n"
"  pushq %rbp\n"
"  movq  %rsp, %rbp\n"
"Source line: 1\n"
"  leaq  -1(%rdi,%rdi,4), %rax\n"
"  popq  %rbp\n"
"  retq\n"
"  nopl  (%rax,%rax)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:505
msgid ""
"The actual body of the function is a single `leaq` instruction, which computes the integer multiply and add at once. This is even more "
"beneficial when `f` gets inlined into another function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:506
#, no-wrap
msgid ""
"julia> function g(k, n)\n"
"           for i = 1:n\n"
"               k = f(k)\n"
"           end\n"
"           return k\n"
"       end\n"
"g (generic function with 1 methods)\n"
"\n"
"julia> code_native(g, Tuple{Int,Int})\n"
"  .text\n"
"Filename: none\n"
"  pushq %rbp\n"
"  movq  %rsp, %rbp\n"
"Source line: 2\n"
"  testq %rsi, %rsi\n"
"  jle L26\n"
"  nopl  (%rax)\n"
"Source line: 3\n"
"L16:\n"
"  leaq  -1(%rdi,%rdi,4), %rdi\n"
"Source line: 2\n"
"  decq  %rsi\n"
"  jne L16\n"
"Source line: 5\n"
"L26:\n"
"  movq  %rdi, %rax\n"
"  popq  %rbp\n"
"  retq\n"
"  nop\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:540
msgid ""
"Since the call to `f` gets inlined, the loop body ends up being just a single `leaq` instruction.  Next, consider what happens if we make "
"the number of loop iterations fixed:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:541
#, no-wrap
msgid ""
"julia> function g(k)\n"
"           for i = 1:10\n"
"               k = f(k)\n"
"           end\n"
"           return k\n"
"       end\n"
"g (generic function with 2 methods)\n"
"\n"
"julia> code_native(g,(Int,))\n"
"  .text\n"
"Filename: none\n"
"  pushq %rbp\n"
"  movq  %rsp, %rbp\n"
"Source line: 3\n"
"  imulq $9765625, %rdi, %rax    # imm = 0x9502F9\n"
"  addq  $-2441406, %rax         # imm = 0xFFDABF42\n"
"Source line: 5\n"
"  popq  %rbp\n"
"  retq\n"
"  nopw  %cs:(%rax,%rax)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:570
msgid ""
"Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition â "
"neither of which is true of saturating arithmetic â it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic "
"completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different "
"outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple "
"operations into fewer equivalent operations."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:578
msgid ""
"The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when "
"adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this [blog post](http://danluu.com/integer-"
"overflow/), Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a "
"substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, "
"we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:579
#, no-wrap
msgid "What are the possible causes of an `UndefVarError` during remote execution?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:583
msgid ""
"As the error states, an immediate cause of an `UndefVarError` on a remote node is that a binding by that name does not exist. Let us explore "
"some of the possible causes."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:584
#, no-wrap
msgid ""
"julia> module Foo\n"
"           foo() = remotecall_fetch(x->x, 2, \"Hello\")\n"
"       end\n"
"\n"
"julia> Foo.foo()\n"
"ERROR: On worker 2:\n"
"UndefVarError: Foo not defined\n"
"Stacktrace:\n"
"[...]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:598
#, no-wrap
msgid ""
"The closure `x->x` carries a reference to `Foo`, and since `Foo` is unavailable on node 2,\n"
"an `UndefVarError` is thrown.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:601
msgid ""
"Globals under modules other than `Main` are not serialized by value to the remote node. Only a reference is sent.  Functions which create "
"global bindings (except under `Main`) may cause an `UndefVarError` to be thrown later."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:602
#, no-wrap
msgid ""
"julia> @everywhere module Foo\n"
"           function foo()\n"
"               global gvar = \"Hello\"\n"
"               remotecall_fetch(()->gvar, 2)\n"
"           end\n"
"       end\n"
"\n"
"julia> Foo.foo()\n"
"ERROR: On worker 2:\n"
"UndefVarError: gvar not defined\n"
"Stacktrace:\n"
"[...]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:619
msgid ""
"In the above example, `@everywhere module Foo` defined `Foo` on all nodes. However the call to `Foo.foo()` created a new global binding "
"`gvar` on the local node, but this was not found on node 2 resulting in an `UndefVarError` error."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:622
msgid ""
"Note that this does not apply to globals created under module `Main`. Globals under module `Main` are serialized and new bindings created "
"under `Main` on the remote node."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:623
#, no-wrap
msgid ""
"julia> gvar_self = \"Node1\"\n"
"\"Node1\"\n"
"\n"
"julia> remotecall_fetch(()->gvar_self, 2)\n"
"\"Node1\"\n"
"\n"
"julia> remotecall_fetch(varinfo, 2)\n"
"name          size summary\n"
"âââââââââ ââââââââ âââââââ\n"
"Base               Module\n"
"Core               Module\n"
"Main               Module\n"
"gvar_self 13 bytes String\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:641
msgid ""
"This does not apply to `function` or `struct` declarations. However, anonymous functions bound to global variables are serialized as can be "
"seen below."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:642
#, no-wrap
msgid ""
"julia> bar() = 1\n"
"bar (generic function with 1 method)\n"
"\n"
"julia> remotecall_fetch(bar, 2)\n"
"ERROR: On worker 2:\n"
"UndefVarError: #bar not defined\n"
"[...]\n"
"\n"
"julia> anon_bar  = ()->1\n"
"(::#21) (generic function with 1 method)\n"
"\n"
"julia> remotecall_fetch(anon_bar, 2)\n"
"1\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:658
#, no-wrap
msgid "Why does Julia use `*` for string concatenation? Why not `+` or something else?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:664
msgid ""
"The [main argument](@ref man-concatenation) against `+` is that string concatenation is not commutative, while `+` is generally used as a "
"commutative operator. While the Julia community recognizes that other languages use different operators and `*` may be unfamiliar for some "
"users, it communicates certain algebraic properties."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:668
msgid ""
"Note that you can also use `string(...)` to concatenate strings (and other values converted to strings); similarly, `repeat` can be used "
"instead of `^` to repeat strings. The [interpolation syntax](@ref string-interpolation) is also useful for constructing strings."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/faq.md:669
#, no-wrap
msgid "Packages and Modules"
msgstr "ããã±ã¼ã¸ã¨ã¢ã¸ã¥ã¼ã«"

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:671
#, no-wrap
msgid "What is the difference between \"using\" and \"import\"?"
msgstr "`using`ã¨`import` ã®éãã¯ä½ã§ãã?"

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:677
msgid ""
"There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference between `using` and `import` is that "
"with `using` you need to say `function Foo.bar(..` to extend module Foo's function bar with a new method, but with `import Foo.bar`, you "
"only need to say `function bar(...` and it automatically extends module Foo's function bar."
msgstr ""
"éãã¯1ã¤ããããã¾ããããè¡¨é¢çã«(æ§æçã«)ã¯ãã®éãã¯ããäºç´°ãªãã®ã«è¦ããããããã¾ããã`using` ã¨ `import` ã®éãã¯ã`using` ã§ã¯ã¢"
"ã¸ã¥ã¼ã« Foo ã®é¢æ° barã æ°ããã¡ã½ããã§æ¡å¼µããã¨ãã«ã¯ã`function Foo.bar(..`ã¨æ¸ãå¿è¦ãããã¾ãã`import Foo.bar`ãä½¿ã£ãã¨ãã«ã¯"
"`function bar(...` ã¨æ¸ãã ãã§ã¢ã¸ã¥ã¼ã« Foo ã®é¢æ° barãèªåçã«æ¡å¼µããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:685
msgid ""
"The reason this is important enough to have been given separate syntax is that you don't want to accidentally extend a function that you "
"didn't know existed, because that could easily cause a bug. This is most likely to happen with a method that takes a common type like a "
"string or integer, because both you and the other module could define a method to handle such a common type. If you use `import`, then "
"you'll replace the other module's implementation of `bar(s::AbstractString)` with your new implementation, which could easily do something "
"completely different (and break all/many future usages of the other functions in module Foo that depend on calling bar)."
msgstr ""
"ãããã£ã¦å¥ãã®æ§æãä¸ããããã»ã©ã«éè¦ãªçç±ã¯ãå­å¨ãç¥ããªã£ãé¢æ°ãèª¤ã£ã¦æ¡å¼µãã¦ãã¾ãã¨ããããã°ã®æ¸©åºã¨ãªã£ã¦ãã¾ãã®ã§ããããã£"
"ããã¨ãé¿ããããã¨ãããã¨ã§ããããã¯ãæå­åãæ´æ°ã®ãããªå±éã®åãåãåãã¡ã½ããã§çºçããå¯è½æ§ãæãé«ãã§ãã`import` ãä½¿ç¨ããå ´"
"åã¯ãä»ã®ã¢ã¸ã¥ã¼ã«ã® `bar(s:AbstractString)` ã®å®è£ãæ°ããå®è£ã«ç½®ãæãããã¨ã«ãªãã¾ãããã®å®è£ã¯ ãã¨ãç°¡åã«ç½®ãæãåã¨å¨ãç°ãªãæ¯"
"ãèããããããã¨ãã§ãã¾ã(ãããããããã¨ã«ãã£ã¦ãé¢æ° bar ã®å¼ã³åºãã«ä¾å­ãã¦ããã¢ã¸ã¥ã¼ã« Fooã§å®ç¾©ãããå¥ã®é¢æ°ç¾¤ãå°æ¥çã«ä½¿ãé"
"ã«å¤§ãã«åé¡ã«ãªãã§ããã)"

#. type: Title ##
#: ext/julia/doc/src/manual/faq.md:686
#, no-wrap
msgid "Nothingness and missing values"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:688
#, no-wrap
msgid "[How does \"null\", \"nothingness\" or \"missingness\" work in Julia?](@id faq-nothing)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:694
msgid ""
"Unlike many languages (for example, C and Java), Julia objects cannot be \"null\" by default.  When a reference (variable, object field, or "
"array element) is uninitialized, accessing it will immediately throw an error. This situation can be detected using the [`isdefined`](@ref) "
"or [`isassigned`](@ref Base.isassigned) functions."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:700
msgid ""
"Some functions are used only for their side effects, and do not need to return a value. In these cases, the convention is to return the "
"value `nothing`, which is just a singleton object of type `Nothing`. This is an ordinary type with no fields; there is nothing special about "
"it except for this convention, and that the REPL does not print anything for it. Some language constructs that would not otherwise have a "
"value also yield `nothing`, for example `if false; end`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:710
msgid ""
"For situations where a value `x` of type `T` exists only sometimes, the `Union{T, Nothing}` type can be used for function arguments, object "
"fields and array element types as the equivalent of [`Nullable`, `Option` or `Maybe`](https://en.wikipedia.org/wiki/Nullable_type)  in other "
"languages. If the value itself can be `nothing` (notably, when `T` is `Any`), the `Union{Some{T}, Nothing}` type is more appropriate since "
"`x == nothing` then indicates the absence of a value, and `x == Some(nothing)` indicates the presence of a value equal to `nothing`. The "
"[`something`](@ref) function allows unwrapping `Some` objects and using a default value instead of `nothing` arguments. Note that the "
"compiler is able to generate efficient code when working with `Union{T, Nothing}` arguments or fields."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:713
msgid ""
"To represent missing data in the statistical sense (`NA` in R or `NULL` in SQL), use the [`missing`](@ref) object. See the [`Missing Values`]"
"(@ref missing) section for more details."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:716
msgid ""
"The empty tuple (`()`) is another form of nothingness. But, it should not really be thought of as nothing but rather a tuple of zero values."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:719
msgid ""
"The empty (or \"bottom\") type, written as `Union{}` (an empty union type), is a type with no values and no subtypes (except itself). You "
"will generally not need to use this type."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/faq.md:720
#, no-wrap
msgid "Memory"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:722
#, no-wrap
msgid "Why does `x += y` allocate memory when `x` and `y` are arrays?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:727
msgid ""
"In Julia, `x += y` gets replaced during parsing by `x = x + y`. For arrays, this has the consequence that, rather than storing the result in "
"the same location in memory as `x`, it allocates a new array to store the result."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:733
msgid ""
"While this behavior might surprise some, the choice is deliberate. The main reason is the presence of immutable objects within Julia, which "
"cannot change their value once created.  Indeed, a number is an immutable object; the statements `x = 5; x += 1` do not modify the meaning "
"of `5`, they modify the value bound to `x`. For an immutable, the only way to change the value is to reassign it."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:735
msgid "To amplify a bit further, consider the following function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:736
#, no-wrap
msgid ""
"function power_by_squaring(x, n::Int)\n"
"    ispow2(n) || error(\"This implementation only works for powers of 2\")\n"
"    while n >= 2\n"
"        x *= x\n"
"        n >>= 1\n"
"    end\n"
"    x\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:750
#, no-wrap
msgid ""
"After a call like `x = 5; y = power_by_squaring(x, 4)`, you would get the expected result: `x == 5 && y == 625`.\n"
" However, now suppose that `*=`, when used with matrices, instead mutated the left hand side.\n"
" There would be two problems:\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/faq.md:757
msgid ""
"For general square matrices, `A = A*B` cannot be implemented without temporary storage: `A[1,1]` gets computed and stored on the left hand "
"side before you're done using it on the right hand side."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/faq.md:757
msgid ""
"Suppose you were willing to allocate a temporary for the computation (which would eliminate most of the point of making `*=` work in-place); "
"if you took advantage of the mutability of `x`, then this function would behave differently for mutable vs. immutable inputs. In particular, "
"for immutable `x`, after the call you'd have (in general) `y != x`, but for mutable `x` you'd have `y == x`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:761
msgid ""
"Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means "
"(e.g., using explicit loops), operators like `+=` and `*=` work by rebinding new values."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/faq.md:762
#, no-wrap
msgid "[Asynchronous IO and concurrent synchronous writes](@id faq-async-io)"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:764
#, no-wrap
msgid "Why do concurrent writes to the same stream result in inter-mixed output?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:767
msgid "While the streaming I/O API is synchronous, the underlying implementation is fully asynchronous."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:769
msgid "Consider the printed output from the following:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:770
#, no-wrap
msgid ""
"julia> @sync for i in 1:3\n"
"           @async write(stdout, string(i), \" Foo \", \" Bar \")\n"
"       end\n"
"123 Foo  Foo  Foo  Bar  Bar  Bar\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:779
msgid ""
"This is happening because, while the `write` call is synchronous, the writing of each argument yields to other tasks while waiting for that "
"part of the I/O to complete."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:782
msgid "`print` and `println` \"lock\" the stream during a call. Consequently changing `write` to `println` in the above example results in:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:783
#, no-wrap
msgid ""
"julia> @sync for i in 1:3\n"
"           @async println(stdout, string(i), \" Foo \", \" Bar \")\n"
"       end\n"
"1 Foo  Bar\n"
"2 Foo  Bar\n"
"3 Foo  Bar\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:793
msgid "You can lock your writes with a `ReentrantLock` like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:794
#, no-wrap
msgid ""
"julia> l = ReentrantLock();\n"
"\n"
"julia> @sync for i in 1:3\n"
"           @async begin\n"
"               lock(l)\n"
"               try\n"
"                   write(stdout, string(i), \" Foo \", \" Bar \")\n"
"               finally\n"
"                   unlock(l)\n"
"               end\n"
"           end\n"
"       end\n"
"1 Foo  Bar 2 Foo  Bar 3 Foo  Bar\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/faq.md:810
#, no-wrap
msgid "Arrays"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:812
#, no-wrap
msgid "What are the differences between zero-dimensional arrays and scalars?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:819
msgid ""
"Zero-dimensional arrays are arrays of the form `Array{T,0}`. They behave similar to scalars, but there are important differences. They "
"deserve a special mention because they are a special case which makes logical sense given the generic definition of arrays, but might be a "
"bit unintuitive at first. The following line defines a zero-dimensional array:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:820
#, no-wrap
msgid ""
"julia> A = zeros()\n"
"0-dimensional Array{Float64,0}:\n"
"0.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:831
msgid ""
"In this example, `A` is a mutable container that contains one element, which can be set by `A[] = 1.0` and retrieved with `A[]`. All zero-"
"dimensional arrays have the same size (`size(A) == ()`), and length (`length(A) == 1`). In particular, zero-dimensional arrays are not "
"empty. If you find this unintuitive, here are some ideas that might help to understand Julia's definition."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/faq.md:842
msgid ""
"Zero-dimensional arrays are the \"point\" to vector's \"line\" and matrix's \"plane\". Just as a line has no area (but still represents a "
"set of things), a point has no length or any dimensions at all (but still represents a thing)."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/faq.md:842
msgid ""
"We define `prod(())` to be 1, and the total number of elements in an array is the product of the size. The size of a zero-dimensional array "
"is `()`, and therefore its length is `1`."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/faq.md:842
msgid ""
"Zero-dimensional arrays don't natively have any dimensions into which you index -- theyâre just `A[]`. We can apply the same \"trailing one"
"\" rule for them as for all other array dimensionalities, so you can indeed index them as `A[1]`, `A[1,1]`, etc; see [Omitted and extra "
"indices](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:853
msgid ""
"It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even though they are iterable "
"and define things like `length`, `getindex`, *e.g.* `1[] == 1`). In particular, if `x = 0.0` is defined as a scalar, it is an error to "
"attempt to change its value via `x[] = 1.0`. A scalar `x` can be converted into a zero-dimensional array containing it via `fill(x)`, and "
"conversely, a zero-dimensional array `a` can be converted to the contained scalar via `a[]`. Another difference is that a scalar can "
"participate in linear algebra operations such as `2 * rand(2,2)`, but the analogous operation with a zero-dimensional array `fill(2) * "
"rand(2,2)` is an error."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:854
#, no-wrap
msgid "Why are my Julia benchmarks for linear algebra operations different from other languages?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:857
msgid "You may find that simple benchmarks of linear algebra building blocks like"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:858
#, no-wrap
msgid ""
"using BenchmarkTools\n"
"A = randn(1000, 1000)\n"
"B = randn(1000, 1000)\n"
"@btime $A \\ $B\n"
"@btime $A * $B\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:867
msgid "can be different when compared to other languages like Matlab or R."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:869
msgid "Since operations like this are very thin wrappers over the relevant BLAS functions, the reason for the discrepancy is very likely to be"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/faq.md:871
msgid "the BLAS library each language is using,"
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/faq.md:873
msgid "the number of concurrent threads."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:875
msgid "Julia compiles and uses its own copy of OpenBLAS, with threads currently capped at `8` (or the number of your cores)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:877
msgid ""
"Modifying OpenBLAS settings or compiling Julia with a different BLAS library, eg [Intel MKL](https://software.intel.com/en-us/mkl), may "
"provide performance improvements. You can use [MKL.jl](https://github.com/JuliaComputing/MKL.jl), a package that makes Julia's linear "
"algebra use Intel MKL BLAS and LAPACK instead of OpenBLAS, or search the discussion forum for suggestions on how to set this up manually. "
"Note that Intel MKL cannot be bundled with Julia, as it is not open source."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/faq.md:878
#, no-wrap
msgid "Julia Releases"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/faq.md:880
#, no-wrap
msgid "Do I want to use the Stable, LTS, or nightly version of Julia?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:888
msgid ""
"The Stable version of Julia is the latest released version of Julia, this is the version most people will want to run.  It has the latest "
"features, including improved performance.  The Stable version of Julia is versioned according to [SemVer](https://semver.org/) as v1.x.y.  A "
"new minor release of Julia corresponding to a new Stable version is made approximately every 4-5 months after a few weeks of testing as a "
"release candidate.  Unlike the LTS version the a Stable version will not normally recieve bugfixes after another Stable version of Julia has "
"been released.  However, upgrading to the next Stable release will always be possible as each release of Julia v1.x will continue to run "
"code written for earlier versions."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:895
msgid ""
"You may prefer the LTS (Long Term Support) version of Julia if you are looking for a very stable code base.  The current LTS version of "
"Julia is versioned according to SemVer as v1.0.x; this branch will continue to recieve bugfixes until a new LTS branch is chosen, at which "
"point the v1.0.x series will no longer recieved regular bug fixes and all but the most conservative users will be advised to upgrade to the "
"new LTS version series.  As a package developer, you may prefer to develop for the LTS version, to maximize the number of users who can use "
"your package.  As per SemVer, code written for v1.0 will continue to work for all future LTS and Stable versions.  In general, even if "
"targetting the LTS, one can develop and run code in the latest Stable version, to take advantage of the improved performance; so long as one "
"avoids using new features (such as added library functions or new methods)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:901
msgid ""
"You may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language, and don't mind if the "
"version available today occasionally doesn't actually work.  As the name implies, releases to the nightly version are made roughly every "
"night (depending on build infrastructure stability).  In general nightly released are fairly safe to useâyour code will not catch on fire.  "
"However, they may be occasional regressions and or issues that will not be found until more thorough pre-release testing.  You may wish to "
"test against the nightly version to ensure that such regressions that affect your use case are caught before a release is made."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:904
msgid ""
"Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at "
"the command line, or interested in learning.  If this describes you, you may also be interested in reading our [guidelines for contributing]"
"(https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/faq.md:906
msgid ""
"Links to each of these download types can be found on the download page at [https://julialang.org/downloads/](https://julialang.org/"
"downloads/).  Note that not all versions of Julia are available for all platforms."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/functions.md:1
#, no-wrap
msgid "[Functions](@id man-functions)"
msgstr "[é¢æ°](@id man-functions)"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:6
msgid ""
"In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical "
"functions, in the sense that functions can alter and be affected by the global state of the program. The basic syntax for defining functions "
"in Julia is:"
msgstr ""
"Julia ã§ã¯ãé¢æ°ã¯å¼æ°å¤ã®ã¿ãã«ãåãåã£ã¦ãæ»ãå¤ãè¿ããªãã¸ã§ã¯ãã§ããJulia é¢æ°ã¯ãã°ã­ã¼ãã«å¤æ°ã®ç¶æãå¤ããããã°ã­ã¼ãã«å¤æ°ã®ç¶"
"æã«å½±é¿ãåãããããã¨ããç¹ã§ãç´ç²ãªæ°å­¦é¢æ°ã§ã¯ããã¾ãããé¢æ°ãå®ç¾©ããåºæ¬çãªæ§æã¯æ¬¡ã®ã¨ããã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:7
#, no-wrap
msgid ""
"julia> function f(x,y)\n"
"           x + y\n"
"       end\n"
"f (generic function with 1 method)\n"
msgstr ""
"julia> function f(x,y)\n"
"           x + y\n"
"       end\n"
"f (generic function with 1 method)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:16
msgid ""
"There is a second, more terse syntax for defining a function in Julia. The traditional function declaration syntax demonstrated above is "
"equivalent to the following compact \"assignment form\":"
msgstr ""
"ãã£ã¨ç°¡æ½ã«é¢æ°ãå®ç¾©ããç¬¬äºã®æ§æãããã¾ããä¸è¨ã«ç¤ºããå¾æ¥ã®é¢æ°å®£è¨æ§æã¨æ¬¡ã®ãããªã³ã³ãã¯ããªä»£å¥æ¹å¼ã¯åç­ã®é¢æ°å®ç¾©ãè¡ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:17
#, no-wrap
msgid ""
"julia> f(x,y) = x + y\n"
"f (generic function with 1 method)\n"
msgstr ""
"julia> f(x,y) = x + y\n"
"f (generic function with 1 method)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:26
msgid ""
"In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see [Compound "
"Expressions](@ref man-compound-expressions)). Short, simple function definitions are common in Julia. The short function syntax is "
"accordingly quite idiomatic, considerably reducing both typing and visual noise."
msgstr ""
"ä»£å¥æ¹å¼ã§ã¯ãé¢æ°ã®æ¬ä½ã¯åä¸ã®å¼ã§ããå¿è¦ãããã¾ãããè¤åå¼ãæå®ã§ãã¾ã ([è¤åå¼](@ref man-compound-expressions)ãåç§)ãç­ãã¦åç´ãª"
"é¢æ°å®ç¾©ã¯ãJulia ã§ããä½¿ããã¾ãããã®æ§æã¯éå¸¸ã«æ£ç¨çã§ãããã³ã¼ãã£ã³ã°æã®ã¿ã¤ãéã¨è¦è¦çãªãã¤ãºã®ä¸¡æ¹ãå¤§å¹ã«åæ¸ãã¦ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:28
msgid "A function is called using the traditional parenthesis syntax:"
msgstr "é¢æ°ã¯ãå¾æ¥ã®æ¬å¼§æ§æãä½¿ç¨ãã¦å¼ã³åºããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:29
#, no-wrap
msgid ""
"julia> f(2,3)\n"
"5\n"
msgstr ""
"julia> f(2,3)\n"
"5\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:36
msgid "Without parentheses, the expression `f` refers to the function object, and can be passed around like any value:"
msgstr "æ¬å¼§ãä½¿ç¨ããªãå ´åãå¼ `f` ã¯é¢æ°ãªãã¸ã§ã¯ããåç§ããä»»æã®å¤ã¨åæ§ã«å¤æ°ã«æ¸¡ããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:37
#, no-wrap
msgid ""
"julia> g = f;\n"
"\n"
"julia> g(2,3)\n"
"5\n"
msgstr ""
"julia> g = f;\n"
"\n"
"julia> g(2,3)\n"
"5\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:45
msgid "As with variables, Unicode can also be used for function names:"
msgstr "å¤æ°ã¨åæ§ã«ãé¢æ°åã«ãUnicode ãä½¿ç¨ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:46
#, no-wrap
msgid ""
"julia> â(x,y) = x + y\n"
"â (generic function with 1 method)\n"
"\n"
"julia> â(2, 3)\n"
"5\n"
msgstr ""
"julia> â(x,y) = x + y\n"
"â (generic function with 1 method)\n"
"\n"
"julia> â(2, 3)\n"
"5\n"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:54
#, no-wrap
msgid "Argument Passing Behavior"
msgstr "å¼æ°æ¸¡ãã®æ¯ãèã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:62
msgid ""
"Julia function arguments follow a convention sometimes called \"pass-by-sharing\", which means that values are not copied when they are "
"passed to functions. Function arguments themselves act as new variable *bindings* (new locations that can refer to values), but the values "
"they refer to are identical to the passed values. Modifications to mutable values (such as `Array`s) made within a function will be visible "
"to the caller. This is the same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages."
msgstr ""
"Julia é¢æ°ã®å¼æ°ã¯ã\"å±ææ¸¡ã\" ã¨å¼ã°ããæ£ä¾ã«å¾ãã¾ããé¢æ°ã«æ¸¡ããå¼æ°ã¯ã³ãã¼ããã¾ãããé¢æ°å¼æ°ãã®ãã®ã¯ãæ°ããå¤æ° *ãã¤ã³ãã£ã³ã°"
"* (å¤ãåç§ã§ããæ°ããå ´æ) ã¨ãã¦æ¯ãèãã¾ãããåç§ããå¤ã¯æ¸¡ãããå¤ã¨åä¸ã®ãã®ã§ãããã¥ã¼ã¿ãã«(å¤æ´å¯è½)ãªå¤(éåãªã©)ã«å¯¾ãã¦ãé¢æ°"
"åã§è¡ãããå¤æ´ã¯å¼ã³åºãå´ãããè¦ãã¾ããããã¯ãSchemeãã»ã¨ãã©ã®Lisp ãPythonãRubyãPerlãã®ä»ã®åçè¨èªã§è¦ãããåä½ã¨åãã§ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:63
#, no-wrap
msgid "The `return` Keyword"
msgstr "[`return` ã­ã¼ã¯ã¼ã](@id the-return-keyword)"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:70
msgid ""
"The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the "
"function definition. In the example function, `f`, from the previous section this is the value of the expression `x + y`. As in C and most "
"other imperative or functional languages, the `return` keyword causes a function to return immediately, providing an expression whose value "
"is returned:"
msgstr ""
"é¢æ°ã®æ»ãå¤ã¯ãæå¾ã«è©ä¾¡ãããå¼ã®å¤ã§ãããããã©ã«ãã§ã¯é¢æ°å®ç¾©ã®æ¬ä½ã®æå¾ã®å¼ã§ããåç¯ã§æãã é¢æ° `f`ã®ä¾ã§ã¯å¼ `x + y` ãããã«å½"
"ããã¾ããC ãä»ã®ã»ã¨ãã©ã®å½ä»¤åè¨èªãé¢æ°åè¨èªã®å¤§é¨åã¯ãã`return` ã­ã¼ã¯ã¼ãã«ãã£ã¦ãé¢æ°ã®å®è¡ãå³æã«çµäºããæå®ãããå¼ãæ»ãå¤ã¨"
"ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:71
#, no-wrap
msgid ""
"function g(x,y)\n"
"    return x * y\n"
"    x + y\n"
"end\n"
msgstr ""
"function g(x,y)\n"
"    return x * y\n"
"    x + y\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:80
msgid "Since function definitions can be entered into interactive sessions, it is easy to compare these definitions:"
msgstr "é¢æ°å®ç¾©ã¯å¯¾è©±åã»ãã·ã§ã³ã§å¥åã§ããããããããã®å®ç¾©ãç°¡åã«æ¯è¼ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:81
#, no-wrap
msgid ""
"julia> f(x,y) = x + y\n"
"f (generic function with 1 method)\n"
"\n"
"julia> function g(x,y)\n"
"           return x * y\n"
"           x + y\n"
"       end\n"
"g (generic function with 1 method)\n"
"\n"
"julia> f(2,3)\n"
"5\n"
"\n"
"julia> g(2,3)\n"
"6\n"
msgstr ""
"julia> f(x,y) = x + y\n"
"f (generic function with 1 method)\n"
"\n"
"julia> function g(x,y)\n"
"           return x * y\n"
"           x + y\n"
"       end\n"
"g (generic function with 1 method)\n"
"\n"
"julia> f(2,3)\n"
"5\n"
"\n"
"julia> g(2,3)\n"
"6\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:103
msgid ""
"Of course, in a purely linear function body like `g`, the usage of `return` is pointless since the expression `x + y` is never evaluated and "
"we could simply make `x * y` the last expression in the function and omit the `return`. In conjunction with other control flow, however, "
"`return` is of real use. Here, for example, is a function that computes the hypotenuse length of a right triangle with sides of length `x` "
"and `y`, avoiding overflow:"
msgstr ""
"ãã¡ãããç´ç²ãªç·å½¢é¢æ° `g`ã§ã¯ã`return` ãã¤ããæå³ã¯ããã¾ããã`x + y` ã¨ããå¼ã¯è©ä¾¡ããããåã«`x * y` ãé¢æ°ã®æå¾ã®å¼ã«ããã° "
"`return` ãçç¥ã§ããããã§ãããã ããä»ã®å¶å¾¡ãã­ã¼ã¨çµã¿åããå ´åã`return` ã¯å®ç¨çã§ãããã¨ãã°ããªã¼ãã¼ãã­ã¼ãåé¿ããªãã `x` ã¨ "
"`y` ã®è¾ºãæã¤ç´è§ä¸è§å½¢ã®æè¾ºã®é·ããè¨ç®ããé¢æ°ã¯ä¸è¨ã®ããã«ãªãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:104
#, no-wrap
msgid ""
"julia> function hypot(x,y)\n"
"           x = abs(x)\n"
"           y = abs(y)\n"
"           if x > y\n"
"               r = y/x\n"
"               return x*sqrt(1+r*r)\n"
"           end\n"
"           if y == 0\n"
"               return zero(x)\n"
"           end\n"
"           r = x/y\n"
"           return y*sqrt(1+r*r)\n"
"       end\n"
"hypot (generic function with 1 method)\n"
"\n"
"julia> hypot(3, 4)\n"
"5.0\n"
msgstr ""
"julia> function hypot(x,y)\n"
"           x = abs(x)\n"
"           y = abs(y)\n"
"           if x > y\n"
"               r = y/x\n"
"               return x*sqrt(1+r*r)\n"
"           end\n"
"           if y == 0\n"
"               return zero(x)\n"
"           end\n"
"           r = x/y\n"
"           return y*sqrt(1+r*r)\n"
"       end\n"
"hypot (generic function with 1 method)\n"
"\n"
"julia> hypot(3, 4)\n"
"5.0\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:127
msgid ""
"There are three possible points of return from this function, returning the values of three different expressions, depending on the values "
"of `x` and `y`. The `return` on the last line could be omitted since it is the last expression."
msgstr ""
"ãã®é¢æ°ãããå¼ã³åºãå´ã«æ»ããã¤ã³ãã¯ 3 ç®æããã`x` ã¨ `y` ã®å¤ã«å¿ãã¦ 3 ã¤ã®ç°ãªãå¼ã®å¤ãè¿ãã¾ããæå¾ã®è¡ã® `return` ã¯æå¾ã®å¼ã§ã"
"ãããçç¥ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:130
msgid ""
"A return type can also be specified in the function declaration using the `::` operator. This converts the return value to the specified "
"type."
msgstr "æ»ãå¤ã®åã¯ã`::` æ¼ç®å­ãä½¿ç¨ãã¦é¢æ°å®£è¨ã§æå®ãããã¨ãã§ãã¾ããããã«ãããæ»ãå¤ãæå®ãããåã«å¤æããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:131
#, no-wrap
msgid ""
"julia> function g(x, y)::Int8\n"
"           return x * y\n"
"       end;\n"
"\n"
"julia> typeof(g(1, 2))\n"
"Int8\n"
msgstr ""
"julia> function g(x, y)::Int8\n"
"           return x * y\n"
"       end;\n"
"\n"
"julia> typeof(g(1, 2))\n"
"Int8\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:142
msgid ""
"This function will always return an `Int8` regardless of the types of `x` and `y`.  See [Type Declarations](@ref) for more on return types."
msgstr ""
"ãã®é¢æ°ã¯ã`x` ã¨ `y` ã®åã«é¢ä¿ãªããå¸¸ã« `Int8` ãè¿ãã¾ãã æ»ãå¤ã®åã®è©³ç´°ã«ã¤ãã¦ã¯ã[åå®£è¨](@ref type-declarations)ãåç§ãã¦ãã ã"
"ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:143
#, no-wrap
msgid "Operators Are Functions"
msgstr "æ¼ç®å­ã¯é¢æ°ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:150
msgid ""
"In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics "
"like `&&` and `||`. These operators cannot be functions since [Short-Circuit Evaluation](@ref) requires that their operands are not "
"evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any "
"other function:"
msgstr ""
"Julia ã§ã¯ãã»ã¨ãã©ã®æ¼ç®å­ã¯ç¹æ®ãªæ§æããµãã¼ãããé¢æ°ã«ããã¾ããã(ä¾å¤ã¯ã`&&` ã `||`ã§ãã[ç­çµ¡è©ä¾¡](@ref short-circuit-evaluation)"
"ã¯ãæ¼ç®å­ã®è©ä¾¡ãè¡ãããåã«ã¯ããªãã©ã³ããè©ä¾¡ããã¦ããªããã¨ãè¦æ±ããããã¯é¢æ°ã®æ¯ãèãã¨ã¯ç°ãªãã¾ã) ãããã£ã¦ãä»ã®é¢æ°ã¨åæ§"
"ã«ãæ¬å¼§ä»ãå¼æ°ãªã¹ããä½¿ç¨ãã¦æ¼ç®å­ãé©ç¨ãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:151
#, no-wrap
msgid ""
"julia> 1 + 2 + 3\n"
"6\n"
"\n"
"julia> +(1,2,3)\n"
"6\n"
msgstr ""
"julia> 1 + 2 + 3\n"
"6\n"
"\n"
"julia> +(1,2,3)\n"
"6\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:162
msgid ""
"The infix form is exactly equivalent to the function application form -- in fact the former is parsed to produce the function call "
"internally. This also means that you can assign and pass around operators such as [`+`](@ref) and [`*`](@ref) just like you would with other "
"function values:"
msgstr ""
"ä¸è¨ã³ã¼ãã«ãããï¼ã¤ç®ã®ä¾ã®äºé æ¼ç®å½¢å¼ã¯ãï¼ã¤ç®ã®ä¾ã®é¢æ°é©ç¨å½¢å¼ã¨å¨ãåç­ã§ããå®ã¯ãåèã¯åé¨ã§é¢æ°å¼ã³åºããè¡ã£ã¦ããã®ã§ãããã"
"ã¯ã¾ããä»ã®é¢æ°ã¨åæ§ã«[`+`](@ref)ã[`*`](@ref)]ãªã©ã®æ¼ç®å­ã¯ãä»£å¥ãåãæ¸¡ããå¯è½ã ã¨ãããã¨ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:163
#, no-wrap
msgid ""
"julia> f = +;\n"
"\n"
"julia> f(1,2,3)\n"
"6\n"
msgstr ""
"julia> f = +;\n"
"\n"
"julia> f(1,2,3)\n"
"6\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:171
msgid "Under the name `f`, the function does not support infix notation, however."
msgstr "ãã ãã`f` ã¨ããååã§ã¯ããã®é¢æ°ã¯äºé æ¼ç®å½¢å¼ãå©ç¨ã§ãã¾ããã"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:172
#, no-wrap
msgid "Operators With Special Names"
msgstr "ç¹æ®ãªååã®æ¼ç®å­"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:175
msgid "A few special expressions correspond to calls to functions with non-obvious names. These are:"
msgstr "éå¸¸ã®ç¨æ³ã§ã¯è¦ãç®ããã¯ããããªãååã§é¢æ°å¼ã³åºãã§ããç¹æ®ãªå¼ãããã¤ãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:186
#, no-wrap
msgid ""
"| Expression        | Calls                   |\n"
"|:----------------- |:----------------------- |\n"
"| `[A B C ...]`     | [`hcat`](@ref)          |\n"
"| `[A; B; C; ...]`  | [`vcat`](@ref)          |\n"
"| `[A B; C D; ...]` | [`hvcat`](@ref)         |\n"
"| `A'`              | [`adjoint`](@ref)       |\n"
"| `A[i]`            | [`getindex`](@ref)      |\n"
"| `A[i] = x`        | [`setindex!`](@ref)     |\n"
"| `A.n`             | [`getproperty`](@ref Base.getproperty) |\n"
"| `A.n = x`         | [`setproperty!`](@ref Base.setproperty!) |\n"
msgstr ""
"| å¼        | å¼ã³åºãå                   |\n"
"|:----------------- |:----------------------- |\n"
"| `[A B C ...]`     | [`hcat`](@ref)          |\n"
"| `[A; B; C; ...]`  | [`vcat`](@ref)          |\n"
"| `[A B; C D; ...]` | [`hvcat`](@ref)         |\n"
"| `A'`              | [`adjoint`](@ref)       |\n"
"| `A[i]`            | [`getindex`](@ref)      |\n"
"| `A[i] = x`        | [`setindex!`](@ref)     |\n"
"| `A.n`             | [`getproperty`](@ref Base.getproperty) |\n"
"| `A.n = x`         | [`setproperty!`](@ref Base.setproperty!) |\n"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:187
#, no-wrap
msgid "[Anonymous Functions](@id man-anonymous-functions)"
msgstr "[ç¡åé¢æ°](@id man-anonymous-functions)"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:194
msgid ""
"Functions in Julia are [first-class objects](https://en.wikipedia.org/wiki/First-class_citizen): they can be assigned to variables, and "
"called using the standard function call syntax from the variable they have been assigned to. They can be used as arguments, and they can be "
"returned as values. They can also be created anonymously, without being given a name, using either of these syntaxes:"
msgstr ""
"Julia ã§ã¯ é¢æ°ã¯[ãã¡ã¼ã¹ãã¯ã©ã¹ã®ãªãã¸ã§ã¯ã](https://en.wikipedia.org/wiki/First-class_citizen)ã§ãã:å¤æ°ã«ä»£å¥ãã§ããä»£å¥ãããå¤æ°ã"
"ãæ¨æºçãªé¢æ°å¼ã³åºãæ§æãä½¿ã£ã¦é¢æ°ãå¼ã³åºããã¨ãã§ãã¾ãããããã¯é¢æ°ã®å¼æ°ã¨ãã¦ããæ»ãå¤ã¨ãã¦ãä½¿ããã¨ãã§ãã¾ããã¾ãã ä¸è¨ã®æ§"
"æã®ãããããä½¿ç¨ãã¦ãååãä»ããä½æãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:195
#, no-wrap
msgid ""
"julia> x -> x^2 + 2x - 1\n"
"#1 (generic function with 1 method)\n"
"\n"
"julia> function (x)\n"
"           x^2 + 2x - 1\n"
"       end\n"
"#3 (generic function with 1 method)\n"
msgstr ""
"julia> x -> x^2 + 2x - 1\n"
"#1 (generic function with 1 method)\n"
"\n"
"julia> function (x)\n"
"           x^2 + 2x - 1\n"
"       end\n"
"#3 (generic function with 1 method)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:208
msgid ""
"This creates a function taking one argument `x` and returning the value of the polynomial `x^2 + 2x - 1` at that value. Notice that the "
"result is a generic function, but with a compiler-generated name based on consecutive numbering."
msgstr ""
"ããã«ãããå¼æ° `x` ãåãåã£ã¦ããã®å¤ãç¨ãã¦è¨ç®ãããå¤é å¼ `x^2 + 2x - 1`ã®å¤ãè¿ãé¢æ°ãä½æããã¾ããããã§çæãããé¢æ°ã¯ãæ±åé¢"
"æ°ã§ãããã³ã³ãã¤ã©ã§çæããéãçªå·ã«åºã¥ããååãæã¤ç¹ã«æ³¨æãã¦ãã ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:212
msgid ""
"The primary use for anonymous functions is passing them to functions which take other functions as arguments. A classic example is [`map`]"
"(@ref), which applies a function to each value of an array and returns a new array containing the resulting values:"
msgstr ""
"ç¡åé¢æ°ã®ä¸»ãªç¨éã¯ãä»ã®é¢æ°ãå¼æ°ã«åãé¢æ°ã«æ¸¡ããã¨ã§ããå¸åçãªä¾ã¯[`map`(@ref)]ã§ãéåã®åå¤ã«å¯¾ãã¦é¢æ°ãé©ç¨ãããã®çµæãæ°ããé"
"åã¨ãã¦è¿ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:213
#, no-wrap
msgid ""
"julia> map(round, [1.2,3.5,1.7])\n"
"3-element Array{Float64,1}:\n"
" 1.0\n"
" 4.0\n"
" 2.0\n"
msgstr ""
"julia> map(round, [1.2,3.5,1.7])\n"
"3-element Array{Float64,1}:\n"
" 1.0\n"
" 4.0\n"
" 2.0\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:225
msgid ""
"This is fine if a named function effecting the transform already exists to pass as the first argument to [`map`](@ref). Often, however, a "
"ready-to-use, named function does not exist. In these situations, the anonymous function construct allows easy creation of a single-use "
"function object without needing a name:"
msgstr ""
"ãããå¤æãè¡ãååä»ãã®é¢æ°ããã£ã¦ã[`map`](@ref)é¢æ°ã®ç¬¬ä¸å¼æ°ã«æ¸¡ããã®ã§ããã°ãåé¡ã¯æãã¾ãããããããå¤ãã®å ´åãããã«ä½¿ç¨ã§ãã"
"ååä»ãé¢æ°ã¯å­å¨ãã¾ããããã®ãããªç¶æ³ã§ã¯ãç¡åé¢æ°nã®æ©è½ãä½¿ãã°ããã®æéãã®ãååãå¿è¦ã¨ããªãé¢æ°ãªãã¸ã§ã¯ããç°¡åã«çæãããã¨"
"ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:226
#, no-wrap
msgid ""
"julia> map(x -> x^2 + 2x - 1, [1,3,-1])\n"
"3-element Array{Int64,1}:\n"
"  2\n"
" 14\n"
" -2\n"
msgstr ""
"julia> map(x -> x^2 + 2x - 1, [1,3,-1])\n"
"3-element Array{Int64,1}:\n"
"  2\n"
" 14\n"
" -2\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:238
#, no-wrap
msgid ""
"An anonymous function accepting multiple arguments can be written using the syntax `(x,y,z)->2x+y-z`.\n"
"A zero-argument anonymous function is written as `()->3`. The idea of a function with no arguments\n"
"may seem strange, but is useful for \"delaying\" a computation. In this usage, a block of code is\n"
"wrapped in a zero-argument function, which is later invoked by calling it as `f`.\n"
msgstr "è¤æ°ã®å¼æ°ãåãã¨ãç¡åé¢æ°ã¯ã`(x,y,z)->2x+y-z`ã®ãããªæ§æãä½¿ç¨ãã¦è¨è¿°ã§ãã¾ããã¼ã­å¼æ°ã®å¿åé¢æ°ã¯ `()->3` ã®ããã«æ¸ããã¾ããå¼æ°ã®ãªãé¢æ°ã®èãã¯å¥å¦ã«è¦ããããããã¾ããããè¨ç®ããéããããããã«å½¹ç«ã¡ã¾ãããã®ä½¿ç¨æ³ã§ã¯ãã³ã¼ããã­ãã¯ãå¾ã§ã¼ã­å¼æ°é¢æ°ã§å²ã£ã¦ãããå¾ã§`f` ã®ããã«å¼ãã§å®è¡ãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:240
msgid "As an example, consider this call to [`get`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:241
#, no-wrap
msgid ""
"get(dict, key) do\n"
"    # default value calculated here\n"
"    time()\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:250
msgid "The code above is equivalent to calling `get` with an anonymous function containing the code enclosed between `do` and `end`, like so:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:251
#, no-wrap
msgid "get(()->time(), dict, key)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:257
msgid ""
"The call to [`time`](@ref) is delayed by wrapping it in a 0-argument anonymous function that is called only when the requested key is absent "
"from `dict`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:258
#, no-wrap
msgid "Tuples"
msgstr "ã¿ãã«"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:265
msgid ""
"Julia has a built-in data structure called a *tuple* that is closely related to function arguments and return values.  A tuple is a fixed-"
"length container that can hold any values, but cannot be modified (it is *immutable*).  Tuples are constructed with commas and parentheses, "
"and can be accessed via indexing:"
msgstr ""
"Julia ã«ã¯ãé¢æ°å¼æ°ã¨æ»ãå¤ã«å¯æ¥ã«é¢é£ãã *tuple* ã¨å¼ã°ããçµã¿è¾¼ã¿ã®ãã¼ã¿æ§é ãããã¾ãã ã¿ãã«ã¯ãä»»æã®å¤ãä¿æã§ããåºå®é·ã®ã³ã³ã"
"ãã¼ã§ããããã®ä¸­èº«ãå¤æ´ãããã¨ã¯ã§ãã¾ãã (*immutable*)ã ã¿ãã«ã¯ã«ã³ãã¨æ¬å¼§ã§æ§æãããã¤ã³ããã¯ã¹ã¤ãã£ã¦ã¢ã¯ã»ã¹ãããã¨ãã§ãã¾"
"ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:266
#, no-wrap
msgid ""
"julia> (1, 1+1)\n"
"(1, 2)\n"
"\n"
"julia> (1,)\n"
"(1,)\n"
"\n"
"julia> x = (0.0, \"hello\", 6*7)\n"
"(0.0, \"hello\", 42)\n"
"\n"
"julia> x[2]\n"
"\"hello\"\n"
msgstr ""
"julia> (1, 1+1)\n"
"(1, 2)\n"
"\n"
"julia> (1,)\n"
"(1,)\n"
"\n"
"julia> x = (0.0, \"hello\", 6*7)\n"
"(0.0, \"hello\", 42)\n"
"\n"
"julia> x[2]\n"
"\"hello\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:283
msgid ""
"Notice that a length-1 tuple must be written with a comma, `(1,)`, since `(1)` would just be a parenthesized value.  `()` represents the "
"empty (length-0) tuple."
msgstr ""
"é·ã 1 ã®ã¿ãã«ã¯å¾ãã«ã«ã³ããä»ãã¦ã`(1,)`ã¨ãããã¨ã«æ³¨æãã¦ãã ããã`(1)` ã¯æ¬å¼§ä»ãã®å¤ã«ãããªããã(ã¿ãã«ã§ãããã¨ãç¤ºãããã«ã¯"
"ã«ã³ããå¿è¦)ã§ãã `()` ã¯ç©ºã® (é·ã-0) ã¿ãã«ãè¡¨ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:284
#, no-wrap
msgid "Named Tuples"
msgstr "ååä»ãã¿ãã«"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:288
msgid "The components of tuples can optionally be named, in which case a *named tuple* is constructed:"
msgstr "ã¿ãã«ã®åè¦ç´ ã«ã¯ãªãã·ã§ã³ã§ååãã¤ãããã¨ãã§ãã¾ãããã®ã°ããã*ååä»ãã¿ãã«*ãçæããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:289
#, no-wrap
msgid ""
"julia> x = (a=1, b=1+1)\n"
"(a = 1, b = 2)\n"
"\n"
"julia> x.a\n"
"1\n"
msgstr ""
"julia> x = (a=1, b=1+1)\n"
"(a = 1, b = 2)\n"
"\n"
"julia> x.a\n"
"1\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:299
msgid "Named tuples are very similar to tuples, except that fields can additionally be accessed by name using dot syntax (`x.a`)."
msgstr "ååä»ãã¿ãã«ã¯ã¿ãã«ã«éå¸¸ã«ããä¼¼ã¦ãã¾ããããã®ãã£ã¼ã«ãã«å¯¾ãã¦ããããæ§æ (`x.a`) ãä½¿ç¨ãã¦ååã§ã¢ã¯ã»ã¹ã§ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:300
#, no-wrap
msgid "Multiple Return Values"
msgstr "è¤æ°ã®æ»ãå¤"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:306
msgid ""
"In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples can be created and destructured without "
"needing parentheses, thereby providing an illusion that multiple values are being returned, rather than a single tuple value. For example, "
"the following function returns a pair of values:"
msgstr ""
"Julia ã§ã¯ãè¤æ°ã®å¤ããã¤ã¿ãã«ãè¿ããã¨ã§ãæ¬ä¼¼çã«è¤æ°ã®å¤ãè¿ããã¨ãã§ãã¾ãããã ããã¿ãã«ã¯æ¬å¼§ãä½¿ããªãã¦ãä½æããã³åå²ã§ããã"
"ããã³ã¼ãä¸ãåä¸ã®ã¿ãã«å¤ã§ã¯ãªãè¤æ°ã®å¤ãè¿ããã¦ãããããªé¯è¦ãä¸ãã¾ãããã¨ãã°ãæ¬¡ã®é¢æ°ã¯ãå¤ã®ãã¢ãè¿ãã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/functions.md:307 ext/julia/doc/src/manual/functions.md:317 ext/julia/doc/src/manual/functions.md:325
#, no-wrap
msgid "jldoctest foofunc"
msgstr "jldoctest foofunc"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:307
#, no-wrap
msgid ""
"julia> function foo(a,b)\n"
"           a+b, a*b\n"
"       end\n"
"foo (generic function with 1 method)\n"
msgstr ""
"julia> function foo(a,b)\n"
"           a+b, a*b\n"
"       end\n"
"foo (generic function with 1 method)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:316
msgid "If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:"
msgstr "æ»ãå¤ãã©ã®å¤æ°ã«ãä»£å¥ããã«ãå¯¾è©±åã»ãã·ã§ã³ã§å¼ã³åºãã¨ã¿ãã«ãè¿ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:317
#, no-wrap
msgid ""
"julia> foo(2,3)\n"
"(5, 6)\n"
msgstr ""
"julia> foo(2,3)\n"
"(5, 6)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:324
msgid ""
"A typical usage of such a pair of return values, however, extracts each value into a variable.  Julia supports simple tuple \"destructuring"
"\" that facilitates this:"
msgstr ""
"ãã ãããã®ããã«æ»ãå¤ãçµã¿ã«ãã¦è¿ãç¨æ³ãããä½¿ãã®ã¯ãããããã®å¤ãåãåºãã¦å¤æ°ã«ä»£å¥ããå ´åã§ããããJulia ã§ã¯ããããå®¹æã«ãã"
"åç´ãªã¿ãã«ã®åå²ããµãã¼ããã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:325
#, no-wrap
msgid ""
"julia> x, y = foo(2,3)\n"
"(5, 6)\n"
"\n"
"julia> x\n"
"5\n"
"\n"
"julia> y\n"
"6\n"
msgstr ""
"julia> x, y = foo(2,3)\n"
"(5, 6)\n"
"\n"
"julia> x\n"
"5\n"
"\n"
"julia> y\n"
"6\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:337
msgid "You can also return multiple values via an explicit usage of the `return` keyword:"
msgstr "`return` ã­ã¼ã¯ã¼ããæç¤ºçã«ä½¿ç¨ãã¦è¤æ°ã®å¤ãè¿ããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:338
#, no-wrap
msgid ""
"function foo(a,b)\n"
"    return a+b, a*b\n"
"end\n"
msgstr ""
"function foo(a,b)\n"
"    return a+b, a*b\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:345
msgid "This has the exact same effect as the previous definition of `foo`."
msgstr "ããã¯æ¢åºã® `foo` ã®å®ç¾©ã¨åç­ã®å¹æãããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:346
#, no-wrap
msgid "Argument destructuring"
msgstr "å¼æ°ã®åå²"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:351
msgid ""
"The destructuring feature can also be used within a function argument.  If a function argument name is written as a tuple (e.g. `(x, y)`) "
"instead of just a symbol, then an assignment `(x, y) = argument` will be inserted for you:"
msgstr ""
"å¼æ°ã®åå²æ©è½ã¯ãé¢æ°å¼æ°ã®ä¸­ã§ãä½¿ç¨ã§ãã¾ãã é¢æ°å¼æ°åãåãªãè¨å·ã§ã¯ãªãã¿ãã« (ä¾: `(x, y)`)  ã®ããã«æ¸ããã¦ããå ´åãä»£å¥é¢æ° "
"`(x, y) = å¼æ°` ãæ¿å¥ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:352
#, no-wrap
msgid ""
"julia> minmax(x, y) = (y < x) ? (y, x) : (x, y)\n"
"\n"
"julia> range((min, max)) = max - min\n"
"\n"
"julia> range(minmax(10, 2))\n"
"8\n"
msgstr ""
"julia> minmax(x, y) = (y < x) ? (y, x) : (x, y)\n"
"\n"
"julia> range((min, max)) = max - min\n"
"\n"
"julia> range(minmax(10, 2))\n"
"8\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:364
msgid ""
"Notice the extra set of parentheses in the definition of `range`.  Without those, `range` would be a two-argument function, and this example "
"would not work."
msgstr "`range` ã®å®ç¾©ã§ä½è¨ãªæ¬å¼§ãããã®ã«æ³¨ç®ãã¦ãã ãããããããªããã°ã`range` ã¯ 2 å¼æ°é¢æ°ã«ãªãããã®ä¾ã§ã¯æ©è½ãã¾ããã"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:365
#, no-wrap
msgid "Varargs Functions"
msgstr "[å¯å¤å¼æ°é¢æ°](@id Varargs-Functions)"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:370
msgid ""
"It is often convenient to be able to write functions taking an arbitrary number of arguments.  Such functions are traditionally known as "
"\"varargs\" functions, which is short for \"variable number of arguments\". You can define a varargs function by following the last argument "
"with an ellipsis:"
msgstr ""
"ä»»æã®åæ°ã®å¼æ°ãåãé¢æ°ãè¨è¿°ã§ããã¨ä¾¿å©ãªãã¨ãããããã¾ãã ãã®ãããªé¢æ°ã¯ãä¼çµ±çã«\"varargs\"é¢æ°ã¨ãã¦ç¥ããã¦ãããããã¯"
"\"variable number of arguments\" (å¤æ°æ°ã®å¼æ°) ã®ç¥ã§ããvarargs é¢æ°ãå®ç¾©ããã«ã¯ãæå¾ã®å¼æ°ã®å¾ã«ãçç¥è¨å·ãã¤ããã¨å®ç¾©ã§ãã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/functions.md:371 ext/julia/doc/src/manual/functions.md:380 ext/julia/doc/src/manual/functions.md:403
#: ext/julia/doc/src/manual/functions.md:414 ext/julia/doc/src/manual/functions.md:430
#, no-wrap
msgid "jldoctest barfunc"
msgstr "jldoctest barfunc"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:371
#, no-wrap
msgid ""
"julia> bar(a,b,x...) = (a,b,x)\n"
"bar (generic function with 1 method)\n"
msgstr ""
"julia> bar(a,b,x...) = (a,b,x)\n"
"bar (generic function with 1 method)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:379
msgid ""
"The variables `a` and `b` are bound to the first two argument values as usual, and the variable `x` is bound to an iterable collection of "
"the zero or more values passed to `bar` after its first two arguments:"
msgstr ""
"å¤æ° `a` ã¨ `b` ã¯éå¸¸ã©ããæåã® 2 ã¤ã®å¼æ°ã®å¤ã«ãã¤ã³ããããå¤æ° `x` ã¯æåã® 2 ã¤ã®å¼æ°ã®å¾ã« `bar` ã«æ¸¡ããã 0 åä»¥ä¸ã®å¤ã®ã¤ãã©ãã«"
"ãªã³ã¬ã¯ã·ã§ã³ã«ãã¤ã³ãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:380
#, no-wrap
msgid ""
"julia> bar(1,2)\n"
"(1, 2, ())\n"
"\n"
"julia> bar(1,2,3)\n"
"(1, 2, (3,))\n"
"\n"
"julia> bar(1, 2, 3, 4)\n"
"(1, 2, (3, 4))\n"
"\n"
"julia> bar(1,2,3,4,5,6)\n"
"(1, 2, (3, 4, 5, 6))\n"
msgstr ""
"julia> bar(1,2)\n"
"(1, 2, ())\n"
"\n"
"julia> bar(1,2,3)\n"
"(1, 2, (3,))\n"
"\n"
"julia> bar(1, 2, 3, 4)\n"
"(1, 2, (3, 4))\n"
"\n"
"julia> bar(1,2,3,4,5,6)\n"
"(1, 2, (3, 4, 5, 6))\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:395
msgid "In all these cases, `x` is bound to a tuple of the trailing values passed to `bar`."
msgstr "ãããã®å ´åãã`x` ã¯ `bar` ã«æ¸¡ãããå¾ç¶ã®å¤ãããªãã¿ãã«ã«ãã¤ã³ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:398
msgid ""
"It is possible to constrain the number of values passed as a variable argument; this will be discussed later in [Parametrically-constrained "
"Varargs methods](@ref)."
msgstr ""
"å¯å¤å¼æ°ã¨ãã¦æ¸¡ãããå¤ã®æ°ãå¶éãããã¨ãå¯è½ã§ããããã«ã¤ãã¦ã¯ãå¾ã§[ãã©ã¡ã¼ã¿å¶éä»ãã®å¯å¤å¼æ°ã¡ã½ãã](@ref parametrically-"
"constrained-varargs-methods]ã§èª¬æãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:402
msgid ""
"On the flip side, it is often handy to \"splat\" the values contained in an iterable collection into a function call as individual "
"arguments. To do this, one also uses `...` but in the function call instead:"
msgstr ""
"ã¾ããå¤ãã®å ´åãã¤ãã©ãã« ã³ã¬ã¯ã·ã§ã³ã«å«ã¾ããå¤ã¨é¢æ°å¼ã³åºãã«åå¥ã®å¼æ°ã¨ã \"æ¥å\" ããã¨ä¾¿å©ã§ãããããè¡ãã«ã¯ãé¢æ°å¼ã³åºãã§ "
"`...` ãä½¿ç¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:403
#, no-wrap
msgid ""
"julia> x = (3, 4)\n"
"(3, 4)\n"
"\n"
"julia> bar(1,2,x...)\n"
"(1, 2, (3, 4))\n"
msgstr ""
"julia> x = (3, 4)\n"
"(3, 4)\n"
"\n"
"julia> bar(1,2,x...)\n"
"(1, 2, (3, 4))\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:413
msgid ""
"In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments go. This need not be the "
"case, however:"
msgstr "ãã®å ´åã¯ãã¿ãã«ã®å¤ãå¯å¤å¼æ°å¼ã³åºãã«æ¥åããã¦ãã¾ãããå¼æ°ã®æ°ãã¿ãã«ã®è¦ç´ æ°ã¨ç­ããã®ã§ãæ¥åããå¿è¦ã¯ããã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:414
#, no-wrap
msgid ""
"julia> x = (2, 3, 4)\n"
"(2, 3, 4)\n"
"\n"
"julia> bar(1,x...)\n"
"(1, 2, (3, 4))\n"
"\n"
"julia> x = (1, 2, 3, 4)\n"
"(1, 2, 3, 4)\n"
"\n"
"julia> bar(x...)\n"
"(1, 2, (3, 4))\n"
msgstr ""
"julia> x = (2, 3, 4)\n"
"(2, 3, 4)\n"
"\n"
"julia> bar(1,x...)\n"
"(1, 2, (3, 4))\n"
"\n"
"julia> x = (1, 2, 3, 4)\n"
"(1, 2, 3, 4)\n"
"\n"
"julia> bar(x...)\n"
"(1, 2, (3, 4))\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:429
msgid "Furthermore, the iterable object splatted into a function call need not be a tuple:"
msgstr "ããã«ãé¢æ°å¼ã³åºãã¨æ¥åããã¤ãã©ãã«ãªãã¸ã§ã¯ãã¯ã¿ãã«ã§ããå¿è¦ãããã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:430
#, no-wrap
msgid ""
"julia> x = [3,4]\n"
"2-element Array{Int64,1}:\n"
" 3\n"
" 4\n"
"\n"
"julia> bar(1,2,x...)\n"
"(1, 2, (3, 4))\n"
"\n"
"julia> x = [1,2,3,4]\n"
"4-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
" 4\n"
"\n"
"julia> bar(x...)\n"
"(1, 2, (3, 4))\n"
msgstr ""
"julia> x = [3,4]\n"
"2-element Array{Int64,1}:\n"
" 3\n"
" 4\n"
"\n"
"julia> bar(1,2,x...)\n"
"(1, 2, (3, 4))\n"
"\n"
"julia> x = [1,2,3,4]\n"
"4-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
" 4\n"
"\n"
"julia> bar(x...)\n"
"(1, 2, (3, 4))\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:452
msgid "Also, the function that arguments are splatted into need not be a varargs function (although it often is):"
msgstr "ã¾ããå¼æ°ãæ¥åããé¢æ°ã¯ãå¯å¤å¼æ°ã§ãªãã¦ãæ§ãã¾ãã(å¯å¤å¼æ°ã§ãããã¨ã®æ¹ãå¤ãã§ãã):"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:453
#, no-wrap
msgid ""
"julia> baz(a,b) = a + b;\n"
"\n"
"julia> args = [1,2]\n"
"2-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
"\n"
"julia> baz(args...)\n"
"3\n"
"\n"
"julia> args = [1,2,3]\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"julia> baz(args...)\n"
"ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)\n"
"Closest candidates are:\n"
"  baz(::Any, ::Any) at none:1\n"
msgstr ""
"julia> baz(a,b) = a + b;\n"
"\n"
"julia> args = [1,2]\n"
"2-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
"\n"
"julia> baz(args...)\n"
"3\n"
"\n"
"julia> args = [1,2,3]\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"julia> baz(args...)\n"
"ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)\n"
"Closest candidates are:\n"
"  baz(::Any, ::Any) at none:1\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:478
msgid ""
"As you can see, if the wrong number of elements are in the splatted container, then the function call will fail, just as it would if too "
"many arguments were given explicitly."
msgstr "ãã®éããæ¥åããã³ã³ããã®è¦ç´ æ°ãé©åã§ãªãå ´åãé¢æ°å¼ã³åºãã¯å¤±æãã¾ããæç¤ºçã«ä¸ããå¼æ°ãå¤ãå ´åã¨åãã§ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:479
#, no-wrap
msgid "Optional Arguments"
msgstr "ãªãã·ã§ã³å¼æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:486
msgid ""
"In many cases, function arguments have sensible default values and therefore might not need to be passed explicitly in every call. For "
"example, the function [`Date(y, [m, d])`](@ref)  from `Dates` module constructs a `Date` type for a given year `y`, month `m` and day `d`.  "
"However, `m` and `d` arguments are optional and their default value is `1`.  This behavior can be expressed concisely as:"
msgstr ""
"å¤ãã®å ´åãé¢æ°å¼æ°ã«ã¯é©åãªããã©ã«ãå¤ãããããããã¹ã¦ã®å¼ã³åºãã§æç¤ºçã«æ¸¡ãå¿è¦ã¯ãªãããããã¾ããããã¨ãã°ã `Dates`ã¢ã¸ã¥ã¼ã«ã®"
"[`Date(y, [m, d])`](@ref) é¢æ°ã¯ãç¹å®ã®`y`å¹´`m`æ`d`æ¥ã® `Date` åãæ§æãã¾ããã`m` ã¨ `d` å¼æ°ã¯çç¥å¯è½ã§ãããã©ã«ãå¤ã¯ `1`ã§ãã ãã®"
"åä½ã¯ãæ¬¡ã®ããã«ç°¡æ½ã«è¡¨ããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:487
#, no-wrap
msgid ""
"function Date(y::Int64, m::Int64=1, d::Int64=1)\n"
"    err = validargs(Date, y, m, d)\n"
"    err === nothing || throw(err)\n"
"    return Date(UTD(totaldays(y, m, d)))\n"
"end\n"
msgstr ""
"function Date(y::Int64, m::Int64=1, d::Int64=1)\n"
"    err = validargs(Date, y, m, d)\n"
"    err === nothing || throw(err)\n"
"    return Date(UTD(totaldays(y, m, d)))\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:497
msgid "Observe, that this definition calls another method of `Date` function that takes one argument of `UTInstant{Day}` type."
msgstr "è¦ã¦ã®éãããã®å®ç¾©ã¯ã`UTInstant{Day}` åã® 1 ã¤ã®å¼æ°ãåãåã `Date` é¢æ°ã®å¥ã®ã¡ã½ãããå¼ã³åºãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:500
msgid ""
"With this definition, the function can be called with either one, two or three arguments, and `1` is automatically passed when any of the "
"arguments is not specified:"
msgstr "ãã®å®ç¾©ã«ãã£ã¦ï¼é¢æ°ã¯ 1 ã¤ã2 ã¤ãã¾ãã¯ 3 ã¤ã®å¼æ°ã§å¼ã³åºãããå¼æ°ã®ãããããæå®ããã¦ããªãå ´åã«ã¯ `1` ãèªåçã«æ¸¡ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:501
#, no-wrap
msgid ""
"julia> using Dates\n"
"\n"
"julia> Date(2000, 12, 12)\n"
"2000-12-12\n"
"\n"
"julia> Date(2000, 12)\n"
"2000-12-01\n"
"\n"
"julia> Date(2000)\n"
"2000-01-01\n"
msgstr ""
"julia> using Dates\n"
"\n"
"julia> Date(2000, 12, 12)\n"
"2000-12-12\n"
"\n"
"julia> Date(2000, 12)\n"
"2000-12-01\n"
"\n"
"julia> Date(2000)\n"
"2000-01-01\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:517
msgid ""
"Optional arguments are actually just a convenient syntax for writing multiple method definitions with different numbers of arguments (see "
"[Note on Optional and keyword Arguments](@ref)).  This can be checked for our `Date` function example by calling `methods` function."
msgstr ""
"ãªãã·ã§ã³å¼æ°ã¯ãå®éã«ã¯ãç°ãªãæ°ã®å¼æ°ãæã¤è¤æ°ã®ã¡ã½ããå®ç¾©ãè¨è¿°ããããã®ä¾¿å©ãªæ§æã§ã ([ãªãã·ã§ã³å¼æ°ã»ã­ã¼ã¯ã¼ãå¼æ°ã«é¢ããæ³¨"
"è¨](@ref note-on-optional-and-keyword-arguments)ãåç§)ã ããã¯`methods`é¢æ°ãå¼ã³åºããã¨ã«ãã£ã¦ãä¾ã«æãã`Date`é¢æ°ã®ä¾ããã§ãã¯ããã"
"ã¨ãã§ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:518
#, no-wrap
msgid "Keyword Arguments"
msgstr "ã­ã¼ã¯ã¼ãå¼æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:523
msgid ""
"Some functions need a large number of arguments, or have a large number of behaviors. Remembering how to call such functions can be "
"difficult. Keyword arguments can make these complex interfaces easier to use and extend by allowing arguments to be identified by name "
"instead of only by position."
msgstr ""
"é¢æ°ã®ä¸­ã«ã¯ãå¼æ°ã®æ°ãå¤ããã®ãå¤æ°ã®æåãæã¤ãã®ãããããã®ãããªé¢æ°ã®å¼ã³åºãæ¹æ³ãè¦ãã¦ããã®ã¯é£ãããã¨ãããã¾ããã­ã¼ã¯ã¼ãå¼"
"æ°ãä½¿ç¨ããã¨ãå¼æ°ãä½ç½®ã ãã§ã¯ãªãååã§è­å¥ã§ããããã«ãªãã®ã§ããããã®è¤éãªã¤ã³ã¿ã¼ãã§ã¤ã¹ãä½¿ããããããæ¡å¼µãå®¹æã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:530
msgid ""
"For example, consider a function `plot` that plots a line. This function might have many options, for controlling line style, width, color, "
"and so on. If it accepts keyword arguments, a possible call might look like `plot(x, y, width=2)`, where we have chosen to specify only line "
"width. Notice that this serves two purposes. The call is easier to read, since we can label an argument with its meaning. It also becomes "
"possible to pass any subset of a large number of arguments, in any order."
msgstr ""
"ãã¨ãã°ãç·ããã­ããããé¢æ° `plot` ãèãã¦ã¿ã¾ãããããã®é¢æ°ã«ã¯ãç·ã®ã¹ã¿ã¤ã«ãå¹ãè²ãªã©ãå¶å¾¡ããããã®å¤ãã®ãªãã·ã§ã³ãããã¾ãã"
"ã­ã¼ã¯ã¼ãå¼æ°ãåãå¥ããå ´åãå¯è½ãªå¼ã³åºãã¯ `plot(x, y, width=2)` ã®ããã«ãªããç·ã®å¤ªãã®ã¿ãæå®ãããã¨ãã§ãã¾ããã­ã¼ã¯ã¼ãå¼æ°ã«ã¯"
"2 ã¤ã®ç®çããããã¨ã«æ³¨æãã¦ä¸ãããå¼æ°ã«æå³ãä»ãããã¨ãã§ãããããé¢æ°ã³ã¼ã«ã®å¯èª­æ§ãä¸ããã¾ããã¾ããå¤æ°ã®å¼æ°ã®ä»»æã®é¨åéåã"
"ä»»æã®é åºã§æ¸¡ããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:532
msgid "Functions with keyword arguments are defined using a semicolon in the signature:"
msgstr "ã­ã¼ã¯ã¼ãå¼æ°ãæã¤é¢æ°ã¯ãã·ã°ããã£åã®ã»ãã³ã­ã³ãä½¿ç¨ãã¦å®ç¾©ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:533
#, no-wrap
msgid ""
"function plot(x, y; style=\"solid\", width=1, color=\"black\")\n"
"    ###\n"
"end\n"
msgstr ""
"function plot(x, y; style=\"solid\", width=1, color=\"black\")\n"
"    ###\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:542
msgid ""
"When the function is called, the semicolon is optional: one can either call `plot(x, y, width=2)` or `plot(x, y; width=2)`, but the former "
"style is more common. An explicit semicolon is required only for passing varargs or computed keywords as described below."
msgstr ""
"é¢æ°ãå¼ã³åºãæã«ãã»ãã³ã­ã³ã¯çç¥å¯è½ã§ã: å¼ã³åºãæ¹ã¯ã`plot(x, y, width=2)` ã¾ãã¯ `plot(x, y; width=2)`ã§ãããåèga\n"
"ããä¸è¬çã§ããä»¥ä¸ã«èª¬æããããã« varargs ã¾ãã¯è¨ç®æ¸ã¿ã®ã­ã¼ã¯ã¼ããæ¸¡ãå ´åã«ã¯ãæç¤ºçãªã»ãã³ã­ã³ãå¿è¦ã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:546
msgid ""
"Keyword argument default values are evaluated only when necessary (when a corresponding keyword argument is not passed), and in left-to-"
"right order. Therefore default expressions may refer to prior keyword arguments."
msgstr ""
"ã­ã¼ã¯ã¼ãå¼æ°ã®ããã©ã«ãå¤ã¯ãå¿è¦ãªå ´å (å¯¾å¿ããå¤ãæ¸¡ãããã«)ãå¿è¦ã«ãªã£ãã¨ãã ããå·¦ããå³ã®é çªã§è©ä¾¡ããã¾ãããããã£ã¦ãããã©ã«"
"ãã®å¼ã¯è©ä¾¡æ¸ã¿ã®ã­ã¼ã¯ã¼ãå¼æ°ãåç§ãã¦ãæ§ãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:548
msgid "The types of keyword arguments can be made explicit as follows:"
msgstr "ã­ã¼ã¯ã¼ãå¼æ°ã®åã¯ãæ¬¡ã®ããã«æç¤ºçã«æå®ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:549
#, no-wrap
msgid ""
"function f(;x::Int=1)\n"
"    ###\n"
"end\n"
msgstr ""
"function f(;x::Int=1)\n"
"    ###\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:556
msgid "Extra keyword arguments can be collected using `...`, as in varargs functions:"
msgstr "è¿½å ã®ã­ã¼ã¯ã¼ãå¼æ°ã¯varargs é¢æ°ã®ããã« `...` ãä½¿ç¨ãã¦åéã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:557
#, no-wrap
msgid ""
"function f(x; y=0, kwargs...)\n"
"    ###\n"
"end\n"
msgstr ""
"function f(x; y=0, kwargs...)\n"
"    ###\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:566
msgid ""
"Inside `f`, `kwargs` will be a key-value iterator over a named tuple. Named tuples (as well as dictionaries with keys of `Symbol`) can be "
"passed as keyword arguments using a semicolon in a call, e.g. `f(x, z=1; kwargs...)`."
msgstr ""
"ä¾ã®é¢æ°`f` ã®åé¨ã§ã¯ã`kwargs` ã¯ååä»ãã¿ãã«ä¸ã§ã®key-value ã¤ãã¬ã¼ã¿ã¨ãã¦å¦çããã¾ããååä»ãã¿ãã«ã¯ã(`Symbol`ãã­ã¼ã«æã¤è¾æ¸ã¨"
"åãæ§ã«) ã­ã¼ã¯ã¼ãå¼æ°ã¨ãã¦é¢æ°ã«ããããã¨ãã§ãã¦ãå¼ã³åºæã«ã¯ã»ãã³ã­ã³ãä½¿ãã¾ãã(ä¾: `f(xã z=1; kwargs...)`)"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:570
msgid ""
"If a keyword argument is not assigned a default value in the method definition, then it is *required*: an [`UndefKeywordError`](@ref) "
"exception will be thrown if the caller does not assign it a value:"
msgstr ""
"ã­ã¼ã¯ã¼ãå¼æ°ãã¡ã½ããå®ç¾©ã«ããã©ã«ãå¤ãå²ãå½ã¦ããã¦ããªãå ´åããã®å¼æ°ã¯*å¿é *ã¨ãããã¨ã«ãªãã¾ããå¼ã³åºãåã§å¤ãå²ãå½ã¦ãªãã"
"ã°ã[`UndefKeywordError`](@ref) ä¾å¤ãã¹ã­ã¼ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:570
#, no-wrap
msgid ""
"function f(x; y)\n"
"    ###\n"
"end\n"
"f(3, y=5) # ok, y is assigned\n"
"f(3)      # throws UndefKeywordError(:y)\n"
msgstr ""
"function f(x; y)\n"
"    ###\n"
"end\n"
"f(3, y=5) # ok, y is assigned\n"
"f(3)      # throws UndefKeywordError(:y)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:581
#, no-wrap
msgid ""
"One can also pass `key => value` expressions after a semicolon. For example, `plot(x, y; :width => 2)`\n"
"is equivalent to `plot(x, y, width=2)`. This is useful in situations where the keyword name is computed\n"
"at runtime.\n"
msgstr "ã»ãã³ã­ã³ã®å¾ã« `key => value`ã®å½¢å¼ã§æ¸¡ããã¨ãã§ãã¾ãããã¨ãã°ã`plot(x, y; :width => 2)`ã¯`plot(x, y, width=2)`ã¨åç­ã§ããããã¯ãå®è¡æã«ãã­ã¼ã¯ã¼ãåãè¨ç®ãããå ´åã«ä¾¿å©ã§ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:588
msgid ""
"The nature of keyword arguments makes it possible to specify the same argument more than once.  For example, in the call `plot(x, y; "
"options..., width=2)` it is possible that the `options` structure also contains a value for `width`. In such a case the rightmost occurrence "
"takes precedence; in this example, `width` is certain to have the value `2`. However, explicitly specifying the same keyword argument "
"multiple times, for example `plot(x, y, width=2, width=3)`, is not allowed and results in a syntax error."
msgstr ""
"ã­ã¼ã¯ã¼ãå¼æ°ã®æ§è³ªä¸ãåãå¼æ°ãè¤æ°åæå®ãããã¨ãå¯è½ã§ãã ãã¨ãã°ã`plot(x, y; options..., width=2)` ã¨ããå¼ã³åºãã§ã¯ã`options` æ§"
"é ä½ã«ã `width` ã®å¤ãå«ã¾ãã¦ããå¯è½æ§ãããã¾ãããã®ãããªå ´åãä¸çªå³ã§å¥åãããå¤ãåªåããã¾ãããã®ä¾ã§ã¯ã`width` å¿ã`2`ã«ãªãã¾"
"ãããã ãã`plot(x,y, width=2, width=3)`ã®ããã«ã­ã¼ã¯ã¼ãå¼æ°ãè¤æ°åæç¤ºçã«æå®ãããã¨ã¯è¨±å¯ããããæ§æã¨ã©ã¼ãçºçãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:589
#, no-wrap
msgid "Evaluation Scope of Default Values"
msgstr "ããã©ã«ãå¤ã®è©ä¾¡ã¹ã³ã¼ã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:594
msgid ""
"When optional and keyword argument default expressions are evaluated, only *previous* arguments are in scope.  For example, given this "
"definition:"
msgstr "ãªãã·ã§ã³å¼æ°ã¨ã­ã¼ã¯ã¼ãå¼æ°ã®ããã©ã«ãã®å¼ãè©ä¾¡ãããæãã¹ã³ã¼ãã«å¥ãã®ã¯ã*æ¢åºã®* å¼æ°ã®ã¿ã§ãã ãã¨ãã°ãæ¬¡ã®é¢æ°å®ç¾©ã§ã¯:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:595
#, no-wrap
msgid ""
"function f(x, a=b, b=1)\n"
"    ###\n"
"end\n"
msgstr ""
"function f(x, a=b, b=1)\n"
"    ###\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:602
msgid "the `b` in `a=b` refers to a `b` in an outer scope, not the subsequent argument `b`."
msgstr "`a=b` ã® `b` ã¯ãå¾ç¶ã®å¼æ° `b` ã§ã¯ãªããå¤å´ã®ã¹ã³ã¼ãåã® `b` ãæãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:603
#, no-wrap
msgid "Do-Block Syntax for Function Arguments"
msgstr "é¢æ°å¼æ°ã®å¯¾ããDoã®ãã­ãã¯æ§æ"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:609
msgid ""
"Passing functions as arguments to other functions is a powerful technique, but the syntax for it is not always convenient. Such calls are "
"especially awkward to write when the function argument requires multiple lines. As an example, consider calling [`map`](@ref) on a function "
"with several cases:"
msgstr ""
"é¢æ°ãä»ã®é¢æ°ã«å¼æ°ã¨ãã¦æ¸¡ããã¨ã¯å¼·åãªææ³ã§ããããã®æ§æã¯å¿ãããæè»½ã§ã¯ããã¾ãããé¢æ°å¼æ°ãè¤æ°è¡ãå¿è¦ã¨ããå ´åããã®ãããªå¼ã³"
"åºãã¯ç¹ã«æ±ãã«ããã§ãããã¨ãã°ãããã¤ãã®ã±ã¼ã¹ãæã¤é¢æ°ã§ [`map`](@ref) ãå¼ã³åºãã¨ããã¨:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:610
#, no-wrap
msgid ""
"map(x->begin\n"
"           if x < 0 && iseven(x)\n"
"               return 0\n"
"           elseif x == 0\n"
"               return 1\n"
"           else\n"
"               return x\n"
"           end\n"
"       end,\n"
"    [A, B, C])\n"
msgstr ""
"map(x->begin\n"
"           if x < 0 && iseven(x)\n"
"               return 0\n"
"           elseif x == 0\n"
"               return 1\n"
"           else\n"
"               return x\n"
"           end\n"
"       end,\n"
"    [A, B, C])\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:624
msgid "Julia provides a reserved word `do` for rewriting this code more clearly:"
msgstr "Julia ã¯ããã®ã³ã¼ããããæç¢ºã«æ¸ãç´ãããã®äºç´èª `do` ãæä¾ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:625
#, no-wrap
msgid ""
"map([A, B, C]) do x\n"
"    if x < 0 && iseven(x)\n"
"        return 0\n"
"    elseif x == 0\n"
"        return 1\n"
"    else\n"
"        return x\n"
"    end\n"
"end\n"
msgstr ""
"map([A, B, C]) do x\n"
"    if x < 0 && iseven(x)\n"
"        return 0\n"
"    elseif x == 0\n"
"        return 1\n"
"    else\n"
"        return x\n"
"    end\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:640
#, no-wrap
msgid ""
"The `do x` syntax creates an anonymous function with argument `x` and passes it as the first argument\n"
"to [`map`](@ref). Similarly, `do a,b` would create a two-argument anonymous function, and a\n"
"plain `do` would declare that what follows is an anonymous function of the form `() -> ...`.\n"
msgstr "`do x` æ§æã¯å¼æ° `x` ãæã¤ç¡åé¢æ°ãä½æãããã®é¢æ°ã [`map`](@ref)ã¸æåã®å¼æ°ã¨ãã¦æ¸¡ãã¾ããåæ§ã«ã`do a,b` ã¯ 2 å¼æ°ã®ç¡åé¢æ°ãä½æããåã« `do` ã¨æ¸ãã°ãå¼æ°ã®ç¡ã `() -> ...` ã¨ããå½¢ã®ç¡åé¢æ°ã§ãããã¨ãå®£è¨ã«ãªãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:644
msgid ""
"How these arguments are initialized depends on the \"outer\" function; here, [`map`](@ref) will sequentially set `x` to `A`, `B`, `C`, "
"calling the anonymous function on each, just as would happen in the syntax `map(func, [A, B, C])`."
msgstr ""
"ãããã®å¼æ°ãã©ã®ããã«åæåããããã¯ãå¤å´ã® é¢æ°ã«ãã£ã¦ç°ãªãã¾ããããã§ã[`map`](@ref)ã¯ãæ§æ `map(func,[A,B,C])`ã¨ããæã¨åæ§ã«`x`"
"ã`A`ã`B`ã`C`ã«é çªã«è¨­å®ãããã®é½åº¦ç¡åé¢æ°ãå¼ã³åºããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:649
msgid ""
"This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks. There are many "
"possible uses quite different from [`map`](@ref), such as managing system state. For example, there is a version of [`open`](@ref) that runs "
"code ensuring that the opened file is eventually closed:"
msgstr ""
"ãã®æ§æãä½¿ç¨ããã¨ãé¢æ°å¼ã³åºãã¯éå¸¸ã®ã³ã¼ã ãã­ãã¯ã®ããã«è¦ãããããç°¡åã«ãå¹æçã«è¨èªãæ¡å¼µãããããªãã¾ããã·ã¹ãã ç¶æã®ç®¡çãª"
"ã©ã[`map`](@ref)ã¨ã¯å¤§ããç°ãªãç¨éãå¤ãèãããã¾ãã§ãããããã¨ãã°ãéããããã¡ã¤ã«ãæçµçã«éãããããã¨ãç¢ºèªããããã« [`open`]"
"(@ref) ã«æãå ãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:650
#, no-wrap
msgid ""
"open(\"outfile\", \"w\") do io\n"
"    write(io, data)\n"
"end\n"
msgstr ""
"open(\"outfile\", \"w\") do io\n"
"    write(io, data)\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:657
msgid "This is accomplished by the following definition:"
msgstr "æ¬¡ã®æ§ã«å®ç¾©ãããã°ããã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:658
#, no-wrap
msgid ""
"function open(f::Function, args...)\n"
"    io = open(args...)\n"
"    try\n"
"        f(io)\n"
"    finally\n"
"        close(io)\n"
"    end\n"
"end\n"
msgstr ""
"function open(f::Function, args...)\n"
"    io = open(args...)\n"
"    try\n"
"        f(io)\n"
"    finally\n"
"        close(io)\n"
"    end\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:673
msgid ""
"Here, [`open`](@ref) first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in "
"the `do ... end` block. After your function exits, [`open`](@ref)  will make sure that the stream is properly closed, regardless of whether "
"your function exited normally or threw an exception. (The `try/finally` construct will be described in [Control Flow](@ref).)"
msgstr ""
"ããã§ã[`open`](@ref) ã¯ãã¾ãæ¸ãè¾¼ã¿ç¨ã®ãã¡ã¤ã«ãéããåºåã¹ããªã¼ã ã `do...end` ãã­ãã¯ã§å®ç¾©ãããç¡åé¢æ°ã«æ¸¡ãã¾ããé¢æ°ãçµäºãã"
"å¾ã[`open`](@ref) ã¯ã¹ããªã¼ã ãé©åã«éãããããã©ãããç¢ºèªãã¾ãã ããã¯ãç¡åé¢æ°ãæ­£å¸¸ã«çµäºããã®ããä¾å¤ãæãããããã«é¢ãããã"
"ã§ãã(`try/finally` ã«ã¤ãã¦ã¯[å¶å¾¡ãã­ã¼](@ref Control-Flow)ã§èª¬æãã¾ã)"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:676
msgid ""
"With the `do` block syntax, it helps to check the documentation or implementation to know how the arguments of the user function are "
"initialized."
msgstr ""
"`do` ãã­ãã¯æ§æãä½¿ç¨ããã¨ããã­ã¥ã¡ã³ãã¾ãã¯å®è£ããã§ãã¯ãã¦ãã¦ã¼ã¶ã¼é¢æ°ã®å¼æ°ãã©ã®ããã«åæåãããããçè§£ããã®å©ãã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:681
msgid ""
"A `do` block, like any other inner function, can \"capture\" variables from its enclosing scope. For example, the variable `data` in the "
"above example of `open...do` is captured from the outer scope. Captured variables can create performance challenges as discussed in "
"[performance tips](@ref man-performance-tips)."
msgstr ""
"`do` ãã­ãã¯ã¯ãä»ã®åé¨é¢æ°ã¨åæ§ã«ãåãå²ãã¹ã³ã¼ãã®å¤æ°ãè£è¶³ãããã¨ãã§ãã¾ãããã¨ãã°ãä¸è¨ã®ä¾ã® `open...do`ã§å¤æ°`data`ãå¤å´ã®ã¹"
"ã³ã¼ãããè£è¶³ãã¦ãã¾ããã­ã£ããã£ããã¾ããã­ã£ããã£ããã¨ã[ããã©ã¼ãã³ã¹ã»ãã£ããã¹](@ref man-performance-tips)ã§èª¬æããããã«ãã"
"ãã©ã¼ãã³ã¹ä¸ã®å°é£ãçããå¯è½æ§ãããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:682
#, no-wrap
msgid "Function composition and piping"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:685
msgid "Functions in Julia can be combined by composing or piping (chaining) them together."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:688
msgid ""
"Function composition is when you combine functions together and apply the resulting composition to arguments.  You use the function "
"composition operator (`â`) to compose the functions, so `(f â g)(args...)` is the same as `f(g(args...))`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:690
#, no-wrap
msgid "You can type the composition operator at the REPL and suitably-configured editors using `\\circ<tab>`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:692
msgid "For example, the `sqrt` and `+` functions can be composed like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:693
#, no-wrap
msgid ""
"julia> (sqrt â +)(3, 6)\n"
"3.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:699
msgid "This adds the numbers first, then finds the square root of the result."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:701
msgid "The next example composes three functions and maps the result over an array of strings:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:702
#, no-wrap
msgid ""
"julia> map(first â reverse â uppercase, split(\"you can compose functions like this\"))\n"
"6-element Array{Char,1}:\n"
" 'U'\n"
" 'N'\n"
" 'E'\n"
" 'S'\n"
" 'E'\n"
" 'S'\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:714
msgid ""
"Function chaining (sometimes called \"piping\" or \"using a pipe\" to send data to a subsequent function) is when you apply a function to "
"the previous function's output:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:715
#, no-wrap
msgid ""
"julia> 1:10 |> sum |> sqrt\n"
"7.416198487095663\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:721
msgid "Here, the total produced by `sum` is passed to the `sqrt` function. The equivalent composition would be:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:722
#, no-wrap
msgid ""
"julia> (sqrt â sum)(1:10)\n"
"7.416198487095663\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:728
#, no-wrap
msgid "The pipe operator can also be used with broadcasting, as `.|>`, to provide a useful combination of the chaining/piping and dot vectorization syntax (described next).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:729
#, no-wrap
msgid ""
"julia> [\"a\", \"list\", \"of\", \"strings\"] .|> [uppercase, reverse, titlecase, length]\n"
"4-element Array{Any,1}:\n"
"  \"A\"\n"
"  \"tsil\"\n"
"  \"Of\"\n"
" 7\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:738
#, no-wrap
msgid "[Dot Syntax for Vectorizing Functions](@id man-vectorized)"
msgstr "[é¢æ°ããã¯ãã«åããDotæ§æ](@id man-vectorized)"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:749
msgid ""
"In technical-computing languages, it is common to have \"vectorized\" versions of functions, which simply apply a given function `f(x)` to "
"each element of an array `A` to yield a new array via `f(A)`. This kind of syntax is convenient for data processing, but in other languages "
"vectorization is also often required for performance: if loops are slow, the \"vectorized\" version of a function can call fast library code "
"written in a low-level language. In Julia, vectorized functions are *not* required for performance, and indeed it is often beneficial to "
"write your own loops (see [Performance Tips](@ref man-performance-tips)), but they can still be convenient. Therefore, *any* Julia function "
"`f` can be applied elementwise to any array (or other collection) with the syntax `f.(A)`.  For example, `sin` can be applied to all "
"elements in the vector `A` like so:"
msgstr ""
"æè¡è¨ç®åãã®ãã­ã°ã©ãã³ã°è¨èªã§ã¯ãé¢æ°ã®ããã¯ãã«åããã¼ã¸ã§ã³ããããã¨ãä¸è¬çã§ããããã¯æä¸ã®é¢æ° `f(x)` ãéå `A` ã®åè¦ç´ ã«é©ç¨"
"ãããã®ã§ã`f(A)` ã¨æ¸ãæ°ããéåãçæãã¾ãããã®ç¨®ã®æ§æã¯ãã¼ã¿å¦çã«ä¾¿å©ã§ãããä»ã®è¨èªã§ã¯ãããã©ã¼ãã³ã¹ãå¾ãããã«ãå¿è¦ã«ãªãã"
"ã¨ãããã¾ãããããã«ã¼ãå¦çãéããã°ãããã¯ãã«åããã¼ã¸ã§ã³ã®é¢æ°ãããä½æ°´æºãªè¨èªã§æ¸ãããéãã©ã¤ãã©ãªã¼ã³ã¼ããå¼ã¶ã®ã§ãã"
"Julia ã§ã¯ããã¯ã¿ã¼åãããé¢æ°ã¯ããã©ã¼ãã³ã¹ã«å¿è¦ãªã®*ã§ã¯ããã¾ãã*ãå®éã«èªåã§ã«ã¼ããæ¸ããæ¹ããããã¨ãããã¾ã ([ããã©ã¼ãã³"
"ã¹ã»ãã£ããã¹](@ref man-performance-tips)åç§)ããããã§ãããã¯ãã«åãã§ããã®ã¯ä¾¿å©ã§ãããã®ãããªå©ä¾¿æ§ã®ããã*ãã¹ã¦ã®* Julia é¢æ° "
"`f` ã¯ã`f.(A)` ã¨ããæ§æã§ä»»æã®éå (ã¾ãã¯ãã®ä»ã®ã³ã¬ã¯ã·ã§ã³) ã«è¦ç´ æ¯ã«é¢æ°ãé©ç¨ã§ãã¾ãã ãã¨ãã°ããã¯ãã« `A` ã®ãã¹ã¦ã®è¦ç´ ã« "
"`sin` ãä»¥ä¸ã®ããã«é©ç¨ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:750
#, no-wrap
msgid ""
"julia> A = [1.0, 2.0, 3.0]\n"
"3-element Array{Float64,1}:\n"
" 1.0\n"
" 2.0\n"
" 3.0\n"
"\n"
"julia> sin.(A)\n"
"3-element Array{Float64,1}:\n"
" 0.8414709848078965\n"
" 0.9092974268256817\n"
" 0.1411200080598672\n"
msgstr ""
"julia> A = [1.0, 2.0, 3.0]\n"
"3-element Array{Float64,1}:\n"
" 1.0\n"
" 2.0\n"
" 3.0\n"
"\n"
"julia> sin.(A)\n"
"3-element Array{Float64,1}:\n"
" 0.8414709848078965\n"
" 0.9092974268256817\n"
" 0.1411200080598672\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:767
msgid ""
"Of course, you can omit the dot if you write a specialized \"vector\" method of `f`, e.g. via `f(A::AbstractArray) = map(f, A)`, and this is "
"just as efficient as `f.(A)`. But that approach requires you to decide in advance which functions you want to vectorize."
msgstr ""
"ãã¡ããã`f`ã®ç¹æ®ãªããã¯ãã«ãçã¡ã½ãããä¾ãã°`f(A:AbstractArray)= map(f,A)`ãèªä½ãã¦ä½¿ç¨ããã°ããããçç¥ãããã¨ãã§ããæ¼ç®å¹çãå"
"ãã«ãªãã¾ãããããããã®æ¹æ³ã§ã¯ãã©ã®é¢æ°ããã¯ãã«åãããã®ãäºåã«æ±ºãã¦ããå¿è¦ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:774
msgid ""
"More generally, `f.(args...)` is actually equivalent to `broadcast(f, args...)`, which allows you to operate on multiple arrays (even of "
"different shapes), or a mix of arrays and scalars (see [Broadcasting](@ref)). For example, if you have `f(x,y) = 3x + 4y`, then `f.(pi,A)` "
"will return a new array consisting of `f(pi,a)` for each `a` in `A`, and `f.(vector1,vector2)` will return a new vector consisting of "
"`f(vector1[i],vector2[i])` for each index `i` (throwing an exception if the vectors have different length)."
msgstr ""
"ããä¸è¬çã«ã¯ã`f.(args...)` ã¯å®éã«ã¯ `broadcast(f, args...)` ã«ç¸å½ãã¾ããããã¯ãè¤æ°ã®ã¢ã¬ã¤(ç°ãªãå½¢ç¶ã§ãã£ã¦ããã)ãã¾ãã¯éåã¨ã¹"
"ã«ã©ã¼ã®çµã¿åãããæä½ãããã®ã§ãã([ãã­ã¼ãã­ã£ã¹ã](@ref Broadcasting)ãåç§)ããã¨ãã°ã`f(x,y) = 3x + 4y` ãå®ç¾©ããå ´åã`f.(pi,A)` "
"ã¯ `A` ã®åè¦ç´  `a` ã«å¯¾ãã `f(pi,a)` ãããªãæ°ããéåãè¿ãã`f.(vector1,vector2)`ã®å ´åã¯åã¤ã³ããã¯ã¹ `f(vector1[i]ãvector2)`ãããªã"
"æ°ãããã¯ãã«ãè¿ãã¾ã(ãã¯ãã«ã®é·ããç°ãªãã¨ãã«ã¯ä¾å¤ãæãã¾ã)"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:775
#, no-wrap
msgid ""
"julia> f(x,y) = 3x + 4y;\n"
"\n"
"julia> A = [1.0, 2.0, 3.0];\n"
"\n"
"julia> B = [4.0, 5.0, 6.0];\n"
"\n"
"julia> f.(pi, A)\n"
"3-element Array{Float64,1}:\n"
" 13.42477796076938\n"
" 17.42477796076938\n"
" 21.42477796076938\n"
"\n"
"julia> f.(A, B)\n"
"3-element Array{Float64,1}:\n"
" 19.0\n"
" 26.0\n"
" 33.0\n"
msgstr ""
"julia> f(x,y) = 3x + 4y;\n"
"\n"
"julia> A = [1.0, 2.0, 3.0];\n"
"\n"
"julia> B = [4.0, 5.0, 6.0];\n"
"\n"
"julia> f.(pi, A)\n"
"3-element Array{Float64,1}:\n"
" 13.42477796076938\n"
" 17.42477796076938\n"
" 21.42477796076938\n"
"\n"
"julia> f.(A, B)\n"
"3-element Array{Float64,1}:\n"
" 19.0\n"
" 26.0\n"
" 33.0\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:804
#, no-wrap
msgid ""
"Moreover, *nested* `f.(args...)` calls are *fused* into a single `broadcast` loop. For example,\n"
"`sin.(cos.(X))` is equivalent to `broadcast(x -> sin(cos(x)), X)`, similar to `[sin(cos(x)) for x in X]`:\n"
"there is only a single loop over `X`, and a single array is allocated for the result. [In contrast,\n"
"`sin(cos(X))` in a typical \"vectorized\" language would first allocate one temporary array for\n"
"`tmp=cos(X)`, and then compute `sin(tmp)` in a separate loop, allocating a second array.] This\n"
"loop fusion is not a compiler optimization that may or may not occur, it is a *syntactic guarantee*\n"
"whenever nested `f.(args...)` calls are encountered. Technically, the fusion stops as soon as\n"
"a \"non-dot\" function call is encountered; for example, in `sin.(sort(cos.(X)))` the `sin` and `cos`\n"
"loops cannot be merged because of the intervening `sort` function.\n"
msgstr ""
"ããã«ã*ãã¹ããã* `f.(args...)` ã®å¼åºã¯ãåä¸ã®ãã­ã¼ãã­ã£ã¹ãã®ã«ã¼ãã«*èåãã*ã¾ããä¾ãã°ã`sin.(cos.(X))`ã¯ã`broadcast(x->sin(cos(x)), X)` ã¨ç­ä¾¡ã§ã`[sin(cos(x)) for x in X]` ã«ä¼¼ã¦ãã¾ããããã¯éå`X`ã«å¯¾ããä¸éã®ã«ã¼ãã«ãªã£ã¦ãããè¨ç®çµæã®éåãä¸ã¤ã ãã¢ã­ã±ã¼ããã¾ãã[å¯¾è±¡çã«ãéå¸¸ã®ãã¯ãã«åããè¨èªã§ã¯ã`sin(cos(X))` ã¨ããã¨ãã¾ãã¯ããã«`tmp=cos(X)`ã«å¯¾ãã¦ãã³ãã©ãªã®éåã®ããã«ã¡ã¢ãªãã¢ã­ã±ã¼ããããã®å¾ã`sin(tmp)`ãå¥ã®ã«ã¼ãã§è¨ç®ãçµæãæ ¼ç´ããç¬¬äºã®éåãçæãã¾ãã] Julia ã§ã®ãã®ã«ã¼ãèåã¯ãèµ·ããå ´åãèµ·ãããªãå ´åããããããªãã³ã³ãã¤ã«ã®æé©åã§ã¯ãªãããã¹ããã\n"
"`f(args...)` å¼åºãããæã«*æ§æçã«ä¿è¨¼ããã¦ãããã®*ã§ããæè¡çã«ã¯ããã®èåã¯ããããããä½¿ããªãé¢æ°å¼ã³åºããã«åºä¼ãã¨ç´ã¡ã«ã¹ããããã¾ããä¾ãã°ã`sin(sort(cos(X)))` ã§ã¯ã`sin` ã¨ `cos`ã®ã«ã¼ãã¯`sort`é¢æ°ãæãã§ãããããèåããã¾ããã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:814
msgid ""
"Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is *pre-allocated*, so that repeated "
"calls do not allocate new arrays over and over again for the results (see [Pre-allocating outputs](@ref)). A convenient syntax for this is "
"`X .= ...`, which is equivalent to `broadcast!(identity, X, ...)` except that, as above, the `broadcast!` loop is fused with any nested \"dot"
"\" calls. For example, `X .= sin.(Y)` is equivalent to `broadcast!(sin, X, Y)`, overwriting `X` with `sin.(Y)` in-place. If the left-hand "
"side is an array-indexing expression, e.g. `X[2:end] .= sin.(Y)`, then it translates to `broadcast!` on a `view`, e.g.  `broadcast!(sin, "
"view(X, 2:lastindex(X)), Y)`, so that the left-hand side is updated in-place."
msgstr ""
"æå¾ã«ãæ¼ç®å¹çãæå¤§ã¨ãªãã®ã¯ãéå¸¸ããã¯ãã«åããæä½ã®åºåéåã *äºåã«ç¢ºä¿ããã¦*ãããé¢æ°ãä½åº¦ãå¼ã³åºãåº¦ã«ãæ°ããåºåç¨ã®éåã"
"ã¢ã­ã±ã¼ãããªãã¦ãããã¨ãã§ãã([åºåã®äºåå²å½](@ref Pre-allocating-outputs) åç§)ããããè¡ãããã®ä¾¿å©ãªæ§æãã`X .= ...` ã§ãããã"
"ã¯ `broadcast!(identity, X, ...)`ã¨ç­ä¾¡ã§ããã`broadcast!` ã«ã¼ãã¯ã©ããªã«ãã¹ãããã\"dot\" å¼ã³åºãã¨ãèåãããç¹ã ãç°ãªãã¾ãããã¨"
"ãã°ã`X .= sin` ã¯ã`broadcast!(sin, X, Y)` ã¨ç­ä¾¡ã§ã`X`ã`sin(Y)`ã§ä¸æ¸ããã¾ããå·¦è¾ºãéåã¤ã³ããã¯ã¹å¼ã§ããå ´åãä¾ãã°`X[2:end] .= "
"sin.(Y)`ã¯ã`view`ã«å¯¾ãã`broadcast!` ã«å¤æããã¾ããä¾ãã°ã `broadcast!(sin, view(X, 2:lastindex(X))ãY)` ã§ãå·¦è¾ºãã¤ã³ãã¬ã¼ã¹ã§æ´æ°ã"
"ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:819
msgid ""
"Since adding dots to many operations and function calls in an expression can be tedious and lead to code that is difficult to read, the "
"macro [`@.`](@ref @__dot__) is provided to convert *every* function call, operation, and assignment in an expression into the \"dotted\" "
"version."
msgstr ""
"ããããã®æ¼ç®å­ãé¢æ°ã®å¼ã³åºãã«ããããã¤ããã¨å¼ãé·ã£ãããããªããå¯èª­æ§ãä½ä¸ããããã [`@.`](@ref @__dot__)ãã¯ã­ãæä¾ããã¦ãã¾"
"ãããããä½¿ãã¨ãè¡åã®*å¨ã¦ã®*é¢æ°ãã³ã ããæ¼ç®å­ãä»£å¥ãããããä»ãããã¼ã¸ã§ã³ã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:820
#, no-wrap
msgid ""
"julia> Y = [1.0, 2.0, 3.0, 4.0];\n"
"\n"
"julia> X = similar(Y); # pre-allocate output array\n"
"\n"
"julia> @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))\n"
"4-element Array{Float64,1}:\n"
"  0.5143952585235492\n"
" -0.4042391538522658\n"
" -0.8360218615377305\n"
" -0.6080830096407656\n"
msgstr ""
"julia> Y = [1.0, 2.0, 3.0, 4.0];\n"
"\n"
"julia> X = similar(Y); # pre-allocate output array\n"
"\n"
"julia> @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))\n"
"4-element Array{Float64,1}:\n"
"  0.5143952585235492\n"
" -0.4042391538522658\n"
" -0.8360218615377305\n"
" -0.6080830096407656\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:837
#, no-wrap
msgid ""
"Binary (or unary) operators like `.+` are handled with the same mechanism:\n"
"they are equivalent to `broadcast` calls and are fused with other nested \"dot\" calls.\n"
" `X .+= Y` etcetera is equivalent to `X .= X .+ Y` and results in a fused in-place assignment;\n"
" see also [dot operators](@ref man-dot-operators).\n"
msgstr "`.+`ã®ãããªäºé  (ãããã¯åé )æ¼ç®å­ã¯ãåãä»çµã¿ã§æ±ããã¾ããããã¯ `broadcast`å¼åºã¨åç­ã§ãä»ã®ãã¹ããããããããå¼ã³åºãã¨èåãã¾ãã`X .+= Y` ã¯ `X .= X .+ Y` ã¨åç­ã§ãèåããä¸æ¸ãä»£å¥ãè¡ãã¾ãã [ãããæ¼ç®å­](@ref man-dot-operators)ãåç§ã®ãã¨ ã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:839
#, no-wrap
msgid "You can also combine dot operations with function chaining using [`|>`](@ref), as in this example:\n"
msgstr "æ¬¡ã®ä¾ã®ããã«ã[`|>`](@ref)ãä½¿ç¨ãã¦ãããæä½ã¨é¢æ°ã®é£éãçµã¿åããããã¨ãã§ãã¾ã:\n"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:839
#, no-wrap
msgid ""
"julia> [1:5;] .|> [x->x^2, inv, x->2*x, -, isodd]\n"
"5-element Array{Real,1}:\n"
"    1\n"
"    0.5\n"
"    6\n"
"   -4\n"
" true\n"
msgstr ""
"julia> [1:5;] .|> [x->x^2, inv, x->2*x, -, isodd]\n"
"5-element Array{Real,1}:\n"
"    1\n"
"    0.5\n"
"    6\n"
"   -4\n"
" true\n"

#. type: Title ##
#: ext/julia/doc/src/manual/functions.md:849
#, no-wrap
msgid "Further Reading"
msgstr "åèæç®"

#. type: Plain text
#: ext/julia/doc/src/manual/functions.md:855
msgid ""
"We should mention here that this is far from a complete picture of defining functions. Julia has a sophisticated type system and allows "
"multiple dispatch on argument types. None of the examples given here provide any type annotations on their arguments, meaning that they are "
"applicable to all types of arguments. The type system is described in [Types](@ref man-types) and defining a function in terms of methods "
"chosen by multiple dispatch on run-time argument types is described in [Methods](@ref)."
msgstr ""
"æ¬ç¯ã®èª¬æã¯ãé¢æ°å®ç¾©ã®å®å¨ãªå¨ä½åããã¯ã»ã©é ãã¨ãããã¨ãè¨ãã­ã°ãªãã¾ãããJulia ã¯æ´ç·´ãããåã·ã¹ãã ãæã¡ãå¼æ°åã«å¯¾ãã¦å¤éãã£"
"ã¹ãããå©ç¨å¯è½ã§ããæ¬ç¯ã§ç¤ºããä¾ã¯ãããããå¼æ°ã«å¯¾ããåã¢ããã¼ã·ã§ã³ãã¤ãã¦ãããããã¹ã¦ã®åã®å¼æ°ã«é©ç¨ã§ãã¾ããåã·ã¹ãã ã«ã¤ã"
"ã¦ã¯[å](@ref man-types)ã»ã¯ã·ã§ã³ã§èª¬æããã¦ãã¾ããå®è¡æå¼æ°ã®åã«ããå¤éãã£ã¹ããããè¡ããããã§é¸æãããã¡ã½ããã«é¢ãã¦é¢æ°ãå®ç¾©"
"ããæ¹æ³ã«ã¤ãã¦ã¯[ã¡ã½ãã](@ref Methods)ã§èª¬æããã¦ãã¾ãã"

#. type: Title #
#: ext/julia/doc/src/manual/workflow-tips.md:1
#, no-wrap
msgid "[Workflow Tips](@id man-workflow-tips)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:4
msgid "Here are some tips for working with Julia efficiently."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/workflow-tips.md:5
#, no-wrap
msgid "REPL-based workflow"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:10
msgid ""
"As already elaborated in [The Julia REPL](@ref), Julia's REPL provides rich functionality that facilitates an efficient interactive "
"workflow. Here are some tips that might further enhance your experience at the command line."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/workflow-tips.md:11
#, no-wrap
msgid "A basic editor/REPL workflow"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:15
msgid ""
"The most basic Julia workflows involve using a text editor in conjunction with the `julia` command line. A common pattern includes the "
"following elements:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/workflow-tips.md:18
msgid "**Put code under development in a temporary module.** Create a file, say `Tmp.jl`, and include within it"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:22
#, no-wrap
msgid ""
"    ```julia\n"
"    module Tmp\n"
"    export say_hello\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:24
#, no-wrap
msgid "    say_hello() = println(\"Hello!\")\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:26
#, no-wrap
msgid "    # your other definitions here\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:30
#, no-wrap
msgid ""
"    end\n"
"    ```\n"
"  * **Put your test code in another file.** Create another file, say `tst.jl`, which looks like\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:35
#, no-wrap
msgid ""
"    ```julia\n"
"    include(\"Tmp.jl\")\n"
"    import .Tmp\n"
"    # using .Tmp # we can use `using` to bring the exported symbols in `Tmp` into our namespace\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:38
#, no-wrap
msgid ""
"    Tmp.say_hello()\n"
"    # say_hello()\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:41
#, no-wrap
msgid ""
"    # your other test code here\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:44
#, no-wrap
msgid ""
"    and includes tests for the contents of `Tmp`.\n"
"    Alternatively, you can wrap the contents of your test file in a module, as\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:50
#, no-wrap
msgid ""
"    ```julia\n"
"    module Tst\n"
"        include(\"Tmp.jl\")\n"
"        import .Tmp\n"
"        #using .Tmp\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:53
#, no-wrap
msgid ""
"        Tmp.say_hello()\n"
"        # say_hello()\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:57
#, no-wrap
msgid ""
"        # your other test code here\n"
"    end\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:60
#, no-wrap
msgid ""
"    The advantage is that your testing code is now contained in a module and does not use the global scope in `Main` for\n"
"    definitions, which is a bit more tidy.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/workflow-tips.md:62
msgid "`include` the `tst.jl` file in the Julia REPL with `include(\"tst.jl\")`."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/workflow-tips.md:64
msgid ""
"**Lather. Rinse. Repeat.** Explore ideas at the `julia` command prompt. Save good ideas in `tst.jl`. To execute `tst.jl` after it has been "
"changed, just `include` it again."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/workflow-tips.md:65
#, no-wrap
msgid "Browser-based workflow"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:69
msgid ""
"It is also possible to interact with a Julia REPL in the browser via [IJulia](https://github.com/JuliaLang/IJulia.jl).  See the package home "
"for details."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/workflow-tips.md:70
#, no-wrap
msgid "Revise-based workflows"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:82
msgid ""
"Whether you're at the REPL or in IJulia, you can typically improve your development experience with [Revise](https://github.com/timholy/"
"Revise.jl).  It is common to configure Revise to start whenever julia is started, as per the instructions in the [Revise documentation]"
"(https://timholy.github.io/Revise.jl/stable/).  Once configured, Revise will track changes to files in any loaded modules, and to any files "
"loaded in to the REPL with `includet` (but not with plain `include`); you can then edit the files and the changes take effect without "
"restarting your julia session.  A standard workflow is similar to the REPL-based workflow above, with the following modifications:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/workflow-tips.md:85
msgid ""
"Put your code in a module somewhere on your load path. There are several options for achieving this, of which two recommended choices are:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:88
#, no-wrap
msgid ""
"   a. For long-term projects, use\n"
"      [PkgTemplates](https://github.com/invenia/PkgTemplates.jl):\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:97
#, no-wrap
msgid ""
"      ```julia\n"
"      using PkgTemplates\n"
"      t = Template()\n"
"      generate(\"MyPkg\", t)\n"
"      ```\n"
"      This will create a blank package, `\"MyPkg\"`, in your `.julia/dev` directory.\n"
"      Note that PkgTemplates allows you to control many different options\n"
"      through its `Template` constructor.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:100
#, no-wrap
msgid ""
"      In step 2 below, edit `MyPkg/src/MyPkg.jl` to change the source code, and\n"
"      `MyPkg/test/runtests.jl` for the tests.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:103
#, no-wrap
msgid ""
"   b. For \"throw-away\" projects, you can avoid any need for cleanup\n"
"      by doing your work in your temporary directory (e.g., `/tmp`).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:105
#, no-wrap
msgid "      Navigate to your temporary directory and launch Julia, then do the following:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:112
#, no-wrap
msgid ""
"      ```julia\n"
"      pkg> generate MyPkg              # type ] to enter pkg mode\n"
"      julia> push!(LOAD_PATH, pwd())   # hit backspace to exit pkg mode\n"
"      ```\n"
"      If you restart your Julia session you'll have to re-issue that command\n"
"      modifying `LOAD_PATH`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:115
#, no-wrap
msgid ""
"      In step 2 below, edit `MyPkg/src/MyPkg.jl` to change the source code, and create any\n"
"      test file of your choosing.\n"
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/workflow-tips.md:117
msgid "Develop your package"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:121
#, no-wrap
msgid ""
"   *Before* loading any code, make sure you're running Revise: say\n"
"   `using Revise` or follow its documentation on configuring it to run\n"
"   automatically.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:124
#, no-wrap
msgid ""
"   Then navigate to the directory containing your test file (here\n"
"   assumed to be `\"runtests.jl\"`) and do the following:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:125
#, no-wrap
msgid ""
"   julia> using MyPkg\n"
"\n"
"   julia> include(\"runtests.jl\")\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/workflow-tips.md:134
#, no-wrap
msgid ""
"   You can iteratively modify the code in MyPkg in your editor and re-run the\n"
"   tests with `include(\"runtests.jl\")`.  You generally should not need to restart\n"
"   your Julia session to see the changes take effect (subject to a few limitations,\n"
"   see https://timholy.github.io/Revise.jl/stable/limitations/).\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/metaprogramming.md:1
#, no-wrap
msgid "Metaprogramming"
msgstr "[ã¡ã¿ãã­ã°ã©ãã³ã°](@id Metaprogramming)"

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:13
msgid ""
"The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data "
"structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is "
"possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also "
"allows true Lisp-style macros operating at the level of [abstract syntax trees](https://en.wikipedia.org/wiki/Abstract_syntax_tree).  In "
"contrast, preprocessor \"macro\" systems, like that of C and C++, perform textual manipulation and substitution before any actual parsing or "
"interpretation occurs. Because all data types and code in Julia are represented by Julia data structures, powerful [reflection](https://en."
"wikipedia.org/wiki/Reflection_%28computer_programming%29)  capabilities are available to explore the internals of a program and its types "
"just like any other data."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/metaprogramming.md:14
#, no-wrap
msgid "Program representation"
msgstr "[ãã­ã°ã©ã ã®è¡¨ç¾](@id Program-representation)"

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:17
msgid "Every Julia program starts life as a string:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:18 ext/julia/doc/src/manual/metaprogramming.md:28 ext/julia/doc/src/manual/metaprogramming.md:41
#: ext/julia/doc/src/manual/metaprogramming.md:48 ext/julia/doc/src/manual/metaprogramming.md:58 ext/julia/doc/src/manual/metaprogramming.md:65
#: ext/julia/doc/src/manual/metaprogramming.md:75
#, no-wrap
msgid "jldoctest prog"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:18
#, no-wrap
msgid ""
"julia> prog = \"1 + 1\"\n"
"\"1 + 1\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:24
#, no-wrap
msgid "**What happens next?**\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:27
msgid ""
"The next step is to [parse](https://en.wikipedia.org/wiki/Parsing#Computer_languages) each string into an object called an expression, "
"represented by the Julia type [`Expr`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:28
#, no-wrap
msgid ""
"julia> ex1 = Meta.parse(prog)\n"
":(1 + 1)\n"
"\n"
"julia> typeof(ex1)\n"
"Expr\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:37
msgid "`Expr` objects contain two parts:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/metaprogramming.md:40
msgid ""
"a [`Symbol`](@ref) identifying the kind of expression. A symbol is an [interned string](https://en.wikipedia.org/wiki/String_interning)  "
"identifier (more discussion below)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:41
#, no-wrap
msgid ""
"julia> ex1.head\n"
":call\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/metaprogramming.md:47
msgid "the expression arguments, which may be symbols, other expressions, or literal values:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:48
#, no-wrap
msgid ""
"julia> ex1.args\n"
"3-element Array{Any,1}:\n"
"  :+\n"
" 1\n"
" 1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:57
msgid "Expressions may also be constructed directly in [prefix notation](https://en.wikipedia.org/wiki/Polish_notation):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:58
#, no-wrap
msgid ""
"julia> ex2 = Expr(:call, :+, 1, 1)\n"
":(1 + 1)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:64
msgid "The two expressions constructed above â by parsing and by direct construction â are equivalent:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:65
#, no-wrap
msgid ""
"julia> ex1 == ex2\n"
"true\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:72
#, no-wrap
msgid ""
"**The key point here is that Julia code is internally represented as a data structure that is accessible\n"
"from the language itself.**\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:74
msgid "The [`dump`](@ref) function provides indented and annotated display of `Expr` objects:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:75
#, no-wrap
msgid ""
"julia> dump(ex2)\n"
"Expr\n"
"  head: Symbol call\n"
"  args: Array{Any}((3,))\n"
"    1: Symbol +\n"
"    2: Int64 1\n"
"    3: Int64 1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:86
msgid "`Expr` objects may also be nested:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:87 ext/julia/doc/src/manual/metaprogramming.md:96
#, no-wrap
msgid "jldoctest ex3"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:87
#, no-wrap
msgid ""
"julia> ex3 = Meta.parse(\"(4 + 4) / 2\")\n"
":((4 + 4) / 2)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:95
msgid ""
"Another way to view expressions is with `Meta.show_sexpr`, which displays the [S-expression](https://en.wikipedia.org/wiki/S-expression)  "
"form of a given `Expr`, which may look very familiar to users of Lisp. Here's an example illustrating the display on a nested `Expr`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:96
#, no-wrap
msgid ""
"julia> Meta.show_sexpr(ex3)\n"
"(:call, :/, (:call, :+, 4, 4), 2)\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:101
#, no-wrap
msgid "Symbols"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:106
msgid ""
"The `:` character has two syntactic purposes in Julia. The first form creates a [`Symbol`](@ref), an [interned string](https://en.wikipedia."
"org/wiki/String_interning) used as one building-block of expressions:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:107
#, no-wrap
msgid ""
"julia> :foo\n"
":foo\n"
"\n"
"julia> typeof(ans)\n"
"Symbol\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:117
msgid ""
"The [`Symbol`](@ref) constructor takes any number of arguments and creates a new symbol by concatenating their string representations "
"together:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:118
#, no-wrap
msgid ""
"julia> :foo == Symbol(\"foo\")\n"
"true\n"
"\n"
"julia> Symbol(\"func\",10)\n"
":func10\n"
"\n"
"julia> Symbol(:var,'_',\"sym\")\n"
":var_sym\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:131
msgid "Note that to use `:` syntax, the symbol's name must be a valid identifier.  Otherwise the `Symbol(str)` constructor must be used."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:134
msgid ""
"In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced "
"with the value bound to that symbol in the appropriate [scope](@ref scope-of-variables)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:136
msgid "Sometimes extra parentheses around the argument to `:` are needed to avoid ambiguity in parsing:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:137
#, no-wrap
msgid ""
"julia> :(:)\n"
":(:)\n"
"\n"
"julia> :(::)\n"
":(::)\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/metaprogramming.md:145
#, no-wrap
msgid "Expressions and evaluation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:153
msgid ""
"The second syntactic purpose of the `:` character is to create expression objects without using the explicit [`Expr`](@ref) constructor. "
"This is referred to as *quoting*. The `:` character, followed by paired parentheses around a single statement of Julia code, produces an "
"`Expr` object based on the enclosed code. Here is example of the short form used to quote an arithmetic expression:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:154
#, no-wrap
msgid ""
"julia> ex = :(a+b*c+1)\n"
":(a + b * c + 1)\n"
"\n"
"julia> typeof(ex)\n"
"Expr\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:164
msgid "(to view the structure of this expression, try `ex.head` and `ex.args`, or use [`dump`](@ref)  as above or [`Meta.@dump`](@ref))"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:167
msgid "Note that equivalent expressions may be constructed using [`Meta.parse`](@ref) or the direct `Expr` form:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:168
#, no-wrap
msgid ""
"julia>      :(a + b*c + 1)       ==\n"
"       Meta.parse(\"a + b*c + 1\") ==\n"
"       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)\n"
"true\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:179
msgid ""
"Expressions provided by the parser generally only have symbols, other expressions, and literal values as their args, whereas expressions "
"constructed by Julia code can have arbitrary run-time values without literal forms as args. In this specific example, `+` and `a` are "
"symbols, `*(b,c)` is a subexpression, and `1` is a literal 64-bit signed integer."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:182
msgid "There is a second syntactic form of quoting for multiple expressions: blocks of code enclosed in `quote ... end`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:183
#, no-wrap
msgid ""
"julia> ex = quote\n"
"           x = 1\n"
"           y = 2\n"
"           x + y\n"
"       end\n"
"quote\n"
"    #= none:2 =#\n"
"    x = 1\n"
"    #= none:3 =#\n"
"    y = 2\n"
"    #= none:4 =#\n"
"    x + y\n"
"end\n"
"\n"
"julia> typeof(ex)\n"
"Expr\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:202
#, no-wrap
msgid "Interpolation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:207
msgid ""
"Direct construction of [`Expr`](@ref) objects with value arguments is powerful, but `Expr` constructors can be tedious compared to \"normal"
"\" Julia syntax. As an alternative, Julia allows *interpolation* of literals or expressions into quoted expressions. Interpolation is "
"indicated by a prefix `$`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:209
msgid "In this example, the value of variable `a` is interpolated:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:210 ext/julia/doc/src/manual/metaprogramming.md:219
#: ext/julia/doc/src/manual/metaprogramming.md:226 ext/julia/doc/src/manual/metaprogramming.md:245
#: ext/julia/doc/src/manual/metaprogramming.md:258 ext/julia/doc/src/manual/metaprogramming.md:276
#: ext/julia/doc/src/manual/metaprogramming.md:288 ext/julia/doc/src/manual/metaprogramming.md:302
#: ext/julia/doc/src/manual/metaprogramming.md:318 ext/julia/doc/src/manual/metaprogramming.md:335
#: ext/julia/doc/src/manual/metaprogramming.md:343 ext/julia/doc/src/manual/metaprogramming.md:356
#, no-wrap
msgid "jldoctest interp1"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:210
#, no-wrap
msgid ""
"julia> a = 1;\n"
"\n"
"julia> ex = :($a + b)\n"
":(1 + b)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:218
msgid "Interpolating into an unquoted expression is not supported and will cause a compile-time error:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:219
#, no-wrap
msgid ""
"julia> $a + b\n"
"ERROR: syntax: \"$\" expression outside quote\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:225
msgid "In this example, the tuple `(1,2,3)` is interpolated as an expression into a conditional test:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:226
#, no-wrap
msgid ""
"julia> ex = :(a in $:((1,2,3)) )\n"
":(a in (1, 2, 3))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:234
msgid ""
"The use of `$` for expression interpolation is intentionally reminiscent of [string interpolation](@ref string-interpolation)  and [command "
"interpolation](@ref command-interpolation). Expression interpolation allows convenient, readable programmatic construction of complex Julia "
"expressions."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:235
#, no-wrap
msgid "Splatting interpolation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:244
msgid ""
"Notice that the `$` interpolation syntax allows inserting only a single expression into an enclosing expression.  Occasionally, you have an "
"array of expressions and need them all to become arguments of the surrounding expression.  This can be done with the syntax `$(xs...)`.  For "
"example, the following code generates a function call where the number of arguments is determined programmatically:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:245
#, no-wrap
msgid ""
"julia> args = [:x, :y, :z];\n"
"\n"
"julia> :(f(1, $(args...)))\n"
":(f(1, x, y, z))\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:252
#, no-wrap
msgid "Nested quote"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:257
msgid ""
"Naturally, it is possible for quote expressions to contain other quote expressions.  Understanding how interpolation works in these cases "
"can be a bit tricky.  Consider this example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:258
#, no-wrap
msgid ""
"julia> x = :(1 + 2);\n"
"\n"
"julia> e = quote quote $x end end\n"
"quote\n"
"    #= none:1 =#\n"
"    $(Expr(:quote, quote\n"
"    #= none:1 =#\n"
"    $(Expr(:$, :x))\n"
"end))\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:275
msgid ""
"Notice that the result contains `Expr(:$, :x)`, which means that `x` has not been evaluated yet.  In other words, the `$` expression "
"\"belongs to\" the inner quote expression, and so its argument is only evaluated when the inner quote expression is:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:276
#, no-wrap
msgid ""
"julia> eval(e)\n"
"quote\n"
"    #= none:1 =#\n"
"    1 + 2\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:287
msgid ""
"However, the outer `quote` expression is able to interpolate values inside the `$` in the inner quote.  This is done with multiple `$`s:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:288
#, no-wrap
msgid ""
"julia> e = quote quote $$x end end\n"
"quote\n"
"    #= none:1 =#\n"
"    $(Expr(:quote, quote\n"
"    #= none:1 =#\n"
"    $(Expr(:$, :(1 + 2)))\n"
"end))\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:301
msgid "Notice that `:(1 + 2)` now appears in the result instead of the symbol `:x`.  Evaluating this expression yields an interpolated `3`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:302
#, no-wrap
msgid ""
"julia> eval(e)\n"
"quote\n"
"    #= none:1 =#\n"
"    3\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:313
msgid ""
"The intuition behind this behavior is that `x` is evaluated once for each `$`: one `$` works similarly to `eval(:x)`, giving `x`'s value, "
"while two `$`s do the equivalent of `eval(eval(:x))`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:314
#, no-wrap
msgid "[QuoteNode](@id man-quote-node)"
msgstr "[QuoteNode](@id man-quote-node)"

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:317
msgid "The usual representation of a `quote` form in an AST is an [`Expr`](@ref) with head `:quote`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:318
#, no-wrap
msgid ""
"julia> dump(Meta.parse(\":(1+2)\"))\n"
"Expr\n"
"  head: Symbol quote\n"
"  args: Array{Any}((1,))\n"
"    1: Expr\n"
"      head: Symbol call\n"
"      args: Array{Any}((3,))\n"
"        1: Symbol +\n"
"        2: Int64 1\n"
"        3: Int64 2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:335
msgid ""
"As we have seen, such expressions support interpolation with `$`.  However, in some situations it is necessary to quote code *without* "
"performing interpolation.  This kind of quoting does not yet have syntax, but is represented internally as an object of type `QuoteNode`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:335
#, no-wrap
msgid ""
"julia> eval(Meta.quot(Expr(:$, :(1+2))))\n"
"3\n"
"\n"
"julia> eval(QuoteNode(Expr(:$, :(1+2))))\n"
":($(Expr(:$, :(1 + 2))))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:343
msgid "The parser yields `QuoteNode`s for simple quoted items like symbols:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:343
#, no-wrap
msgid ""
"julia> dump(Meta.parse(\":x\"))\n"
"QuoteNode\n"
"  value: Symbol x\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:350
msgid "`QuoteNode` can also be used for certain advanced metaprogramming tasks."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:351
#, no-wrap
msgid "Evaluating expressions"
msgstr "å¼ã®è©ä¾¡"

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:355
msgid "Given an expression object, one can cause Julia to evaluate (execute) it at global scope using [`eval`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:356
#, no-wrap
msgid ""
"julia> :(1 + 2)\n"
":(1 + 2)\n"
"\n"
"julia> eval(ans)\n"
"3\n"
"\n"
"julia> ex = :(a + b)\n"
":(a + b)\n"
"\n"
"julia> eval(ex)\n"
"ERROR: UndefVarError: b not defined\n"
"[...]\n"
"\n"
"julia> a = 1; b = 2;\n"
"\n"
"julia> eval(ex)\n"
"3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:379
msgid ""
"Every [module](@ref modules) has its own [`eval`](@ref) function that evaluates expressions in its global scope. Expressions passed to "
"[`eval`](@ref) are not limited to returning values -- they can also have side-effects that alter the state of the enclosing module's "
"environment:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:380
#, no-wrap
msgid ""
"julia> ex = :(x = 1)\n"
":(x = 1)\n"
"\n"
"julia> x\n"
"ERROR: UndefVarError: x not defined\n"
"\n"
"julia> eval(ex)\n"
"1\n"
"\n"
"julia> x\n"
"1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:396
msgid "Here, the evaluation of an expression object causes a value to be assigned to the global variable `x`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:400
msgid ""
"Since expressions are just `Expr` objects which can be constructed programmatically and then evaluated, it is possible to dynamically "
"generate arbitrary code which can then be run using [`eval`](@ref).  Here is a simple example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:401
#, no-wrap
msgid ""
"julia> a = 1;\n"
"\n"
"julia> ex = Expr(:call, :+, a, :b)\n"
":(1 + b)\n"
"\n"
"julia> a = 0; b = 2;\n"
"\n"
"julia> eval(ex)\n"
"3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:415
msgid ""
"The value of `a` is used to construct the expression `ex` which applies the `+` function to the value 1 and the variable `b`. Note the "
"important distinction between the way `a` and `b` are used:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/metaprogramming.md:423
msgid ""
"The value of the *variable* `a` at expression construction time is used as an immediate value in the expression. Thus, the value of `a` when "
"the expression is evaluated no longer matters: the value in the expression is already `1`, independent of whatever the value of `a` might be."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/metaprogramming.md:423
msgid ""
"On the other hand, the *symbol* `:b` is used in the expression construction, so the value of the variable `b` at that time is irrelevant -- "
"`:b` is just a symbol and the variable `b` need not even be defined. At expression evaluation time, however, the value of the symbol `:b` is "
"resolved by looking up the value of the variable `b`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:424
#, no-wrap
msgid "Functions on `Expr`essions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:431
msgid ""
"As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have "
"already seen one example of a function returning [`Expr`](@ref)  objects: the [`parse`](@ref) function, which takes a string of Julia code "
"and returns the corresponding `Expr`. A function can also take one or more `Expr` objects as arguments, and return another `Expr`. Here is a "
"simple, motivating example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:432
#, no-wrap
msgid ""
"julia> function math_expr(op, op1, op2)\n"
"           expr = Expr(:call, op, op1, op2)\n"
"           return expr\n"
"       end\n"
"math_expr (generic function with 1 method)\n"
"\n"
"julia>  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))\n"
":(1 + 4 * 5)\n"
"\n"
"julia> eval(ex)\n"
"21\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:448
msgid "As another example, here is a function that doubles any numeric argument, but leaves expressions alone:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:449
#, no-wrap
msgid ""
"julia> function make_expr2(op, opr1, opr2)\n"
"           opr1f, opr2f = map(x -> isa(x, Number) ? 2*x : x, (opr1, opr2))\n"
"           retexpr = Expr(:call, op, opr1f, opr2f)\n"
"           return retexpr\n"
"       end\n"
"make_expr2 (generic function with 1 method)\n"
"\n"
"julia> make_expr2(:+, 1, 2)\n"
":(2 + 4)\n"
"\n"
"julia> ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))\n"
":(2 + 5 * 8)\n"
"\n"
"julia> eval(ex)\n"
"42\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/metaprogramming.md:467
#, no-wrap
msgid "[Macros](@id man-macros)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:473
msgid ""
"Macros provide a method to include generated code in the final body of a program. A macro maps a tuple of arguments to a returned "
"*expression*, and the resulting expression is compiled directly rather than requiring a runtime [`eval`](@ref) call. Macro arguments may "
"include expressions, literal values, and symbols."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:474
#, no-wrap
msgid "Basics"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:477
msgid "Here is an extraordinarily simple macro:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:478 ext/julia/doc/src/manual/metaprogramming.md:496
#, no-wrap
msgid "jldoctest sayhello"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:478
#, no-wrap
msgid ""
"julia> macro sayhello()\n"
"           return :( println(\"Hello, world!\") )\n"
"       end\n"
"@sayhello (macro with 1 method)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:488
msgid ""
"Macros have a dedicated character in Julia's syntax: the `@` (at-sign), followed by the unique name declared in a `macro NAME ... end` "
"block. In this example, the compiler will replace all instances of `@sayhello` with:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:489
#, no-wrap
msgid ":( println(\"Hello, world!\") )\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:495
msgid "When `@sayhello` is entered in the REPL, the expression executes immediately, thus we only see the evaluation result:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:496
#, no-wrap
msgid ""
"julia> @sayhello()\n"
"Hello, world!\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:502
msgid "Now, consider a slightly more complex macro:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:503 ext/julia/doc/src/manual/metaprogramming.md:513
#: ext/julia/doc/src/manual/metaprogramming.md:534
#, no-wrap
msgid "jldoctest sayhello2"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:503
#, no-wrap
msgid ""
"julia> macro sayhello(name)\n"
"           return :( println(\"Hello, \", $name) )\n"
"       end\n"
"@sayhello (macro with 1 method)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:512
msgid ""
"This macro takes one argument: `name`. When `@sayhello` is encountered, the quoted expression is *expanded* to interpolate the value of the "
"argument into the final expression:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:513
#, no-wrap
msgid ""
"julia> @sayhello(\"human\")\n"
"Hello, human\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:520
msgid ""
"We can view the quoted return expression using the function [`macroexpand`](@ref) (**important note:** this is an extremely useful tool for "
"debugging macros):"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:521
#, no-wrap
msgid "julia-repl sayhello2"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:521
#, no-wrap
msgid ""
"julia> ex = macroexpand(Main, :(@sayhello(\"human\")) )\n"
":(Main.println(\"Hello, \", \"human\"))\n"
"\n"
"julia> typeof(ex)\n"
"Expr\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:530
msgid "We can see that the `\"human\"` literal has been interpolated into the expression."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:532
msgid "There also exists a macro [`@macroexpand`](@ref) that is perhaps a bit more convenient than the `macroexpand` function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:534
#, no-wrap
msgid ""
"julia> @macroexpand @sayhello \"human\"\n"
":(println(\"Hello, \", \"human\"))\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:539
#, no-wrap
msgid "Hold up: why macros?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:543
#, no-wrap
msgid ""
"We have already seen a function `f(::Expr...) -> Expr` in a previous section. In fact, [`macroexpand`](@ref)\n"
"is also such a function. So, why do macros exist?\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:547
msgid ""
"Macros are necessary because they execute when code is parsed, therefore, macros allow the programmer to generate and include fragments of "
"customized code *before* the full program is run. To illustrate the difference, consider the following example:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:548 ext/julia/doc/src/manual/metaprogramming.md:562
#, no-wrap
msgid "julia-repl whymacros"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:548
#, no-wrap
msgid ""
"julia> macro twostep(arg)\n"
"           println(\"I execute at parse time. The argument is: \", arg)\n"
"           return :(println(\"I execute at runtime. The argument is: \", $arg))\n"
"       end\n"
"@twostep (macro with 1 method)\n"
"\n"
"julia> ex = macroexpand(Main, :(@twostep :(1, 2, 3)) );\n"
"I execute at parse time. The argument is: $(Expr(:quote, :((1, 2, 3))))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:561
msgid ""
"The first call to [`println`](@ref) is executed when [`macroexpand`](@ref) is called. The resulting expression contains *only* the second "
"`println`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:562
#, no-wrap
msgid ""
"julia> typeof(ex)\n"
"Expr\n"
"\n"
"julia> ex\n"
":(println(\"I execute at runtime. The argument is: \", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))\n"
"\n"
"julia> eval(ex)\n"
"I execute at runtime. The argument is: (1, 2, 3)\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:573
#, no-wrap
msgid "Macro invocation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:576
msgid "Macros are invoked with the following general syntax:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:577
#, no-wrap
msgid ""
"@name expr1 expr2 ...\n"
"@name(expr1, expr2, ...)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:586
msgid ""
"Note the distinguishing `@` before the macro name and the lack of commas between the argument expressions in the first form, and the lack of "
"whitespace after `@name` in the second form. The two styles should not be mixed. For example, the following syntax is different from the "
"examples above; it passes the tuple `(expr1, expr2, ...)` as one argument to the macro:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:587
#, no-wrap
msgid "@name (expr1, expr2, ...)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:592
msgid ""
"An alternative way to invoke a macro over an array literal (or comprehension) is to juxtapose both without using parentheses. In this case, "
"the array will be the only expression fed to the macro. The following syntax is equivalent (and different from `@name [a b] * v`):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:593
#, no-wrap
msgid ""
"@name[a b] * v\n"
"@name([a b]) * v\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:601
msgid ""
"It is important to emphasize that macros receive their arguments as expressions, literals, or symbols. One way to explore macro arguments is "
"to call the [`show`](@ref) function within the macro body:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:602
#, no-wrap
msgid ""
"julia> macro showarg(x)\n"
"           show(x)\n"
"           # ... remainder of macro, returning an expression\n"
"       end\n"
"@showarg (macro with 1 method)\n"
"\n"
"julia> @showarg(a)\n"
":a\n"
"\n"
"julia> @showarg(1+1)\n"
":(1 + 1)\n"
"\n"
"julia> @showarg(println(\"Yo!\"))\n"
":(println(\"Yo!\"))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:620
msgid "In addition to the given argument list, every macro is passed extra arguments named `__source__` and `__module__`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:626
msgid ""
"The argument `__source__` provides information (in the form of a `LineNumberNode` object) about the parser location of the `@` sign from the "
"macro invocation.  This allows macros to include better error diagnostic information, and is commonly used by logging, string-parser macros, "
"and docs, for example, as well as to implement the [`@__LINE__`](@ref), [`@__FILE__`](@ref), and [`@__DIR__`](@ref) macros."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:628
msgid "The location information can be accessed by referencing `__source__.line` and `__source__.file`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:629
#, no-wrap
msgid ""
"julia> macro __LOCATION__(); return QuoteNode(__source__); end\n"
"@__LOCATION__ (macro with 1 method)\n"
"\n"
"julia> dump(\n"
"            @__LOCATION__(\n"
"       ))\n"
"LineNumberNode\n"
"  line: Int64 2\n"
"  file: Symbol none\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:646
msgid ""
"The argument `__module__` provides information (in the form of a `Module` object)  about the expansion context of the macro invocation.  "
"This allows macros to look up contextual information, such as existing bindings, or to insert the value as an extra argument to a runtime "
"function call doing self-reflection in the current module."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:648
#, no-wrap
msgid "Building an advanced macro"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:651
msgid "Here is a simplified definition of Julia's [`@assert`](@ref) macro:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:652 ext/julia/doc/src/manual/metaprogramming.md:661
#, no-wrap
msgid "jldoctest building"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:652
#, no-wrap
msgid ""
"julia> macro assert(ex)\n"
"           return :( $ex ? nothing : throw(AssertionError($(string(ex)))) )\n"
"       end\n"
"@assert (macro with 1 method)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:660
msgid "This macro can be used like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:661
#, no-wrap
msgid ""
"julia> @assert 1 == 1.0\n"
"\n"
"julia> @assert 1 == 0\n"
"ERROR: AssertionError: 1 == 0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:670
msgid "In place of the written syntax, the macro call is expanded at parse time to its returned result.  This is equivalent to writing:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:671
#, no-wrap
msgid ""
"1 == 1.0 ? nothing : throw(AssertionError(\"1 == 1.0\"))\n"
"1 == 0 ? nothing : throw(AssertionError(\"1 == 0\"))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:684
msgid ""
"That is, in the first call, the expression `:(1 == 1.0)` is spliced into the test condition slot, while the value of `string(:(1 == 1.0))` "
"is spliced into the assertion message slot. The entire expression, thus constructed, is placed into the syntax tree where the `@assert` "
"macro call occurs.  Then at execution time, if the test expression evaluates to true, then [`nothing`](@ref) is returned, whereas if the "
"test is false, an error is raised indicating the asserted expression that was false.  Notice that it would not be possible to write this as "
"a function, since only the *value* of the condition is available and it would be impossible to display the expression that computed it in "
"the error message."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:689
msgid ""
"The actual definition of `@assert` in Julia Base is more complicated. It allows the user to optionally specify their own error message, "
"instead of just printing the failed expression.  Just like in functions with a variable number of arguments ([Varargs Functions](@ref)), "
"this is specified with an ellipses following the last argument:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:690
#, no-wrap
msgid "jldoctest assert2"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:690
#, no-wrap
msgid ""
"julia> macro assert(ex, msgs...)\n"
"           msg_body = isempty(msgs) ? ex : msgs[1]\n"
"           msg = string(msg_body)\n"
"           return :($ex ? nothing : throw(AssertionError($msg)))\n"
"       end\n"
"@assert (macro with 1 method)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:704
msgid ""
"Now `@assert` has two modes of operation, depending upon the number of arguments it receives! If there's only one argument, the tuple of "
"expressions captured by `msgs` will be empty and it will behave the same as the simpler definition above. But now if the user specifies a "
"second argument, it is printed in the message body instead of the failing expression. You can inspect the result of a macro expansion with "
"the aptly named [`@macroexpand`](@ref) macro:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:705
#, no-wrap
msgid "julia-repl assert2"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:705
#, no-wrap
msgid ""
"julia> @macroexpand @assert a == b\n"
":(if Main.a == Main.b\n"
"        Main.nothing\n"
"    else\n"
"        Main.throw(Main.AssertionError(\"a == b\"))\n"
"    end)\n"
"\n"
"julia> @macroexpand @assert a==b \"a should equal b!\"\n"
":(if Main.a == Main.b\n"
"        Main.nothing\n"
"    else\n"
"        Main.throw(Main.AssertionError(\"a should equal b!\"))\n"
"    end)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:726
msgid ""
"There is yet another case that the actual `@assert` macro handles: what if, in addition to printing \"a should equal b,\" we wanted to print "
"their values? One might naively try to use string interpolation in the custom message, e.g., `@assert a==b \"a ($a) should equal b ($b)!\"`, "
"but this won't work as expected with the above macro. Can you see why? Recall from [string interpolation](@ref string-interpolation) that an "
"interpolated string is rewritten to a call to [`string`](@ref). Compare:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:727
#, no-wrap
msgid ""
"julia> typeof(:(\"a should equal b\"))\n"
"String\n"
"\n"
"julia> typeof(:(\"a ($a) should equal b ($b)!\"))\n"
"Expr\n"
"\n"
"julia> dump(:(\"a ($a) should equal b ($b)!\"))\n"
"Expr\n"
"  head: Symbol string\n"
"  args: Array{Any}((5,))\n"
"    1: String \"a (\"\n"
"    2: Symbol a\n"
"    3: String \") should equal b (\"\n"
"    4: Symbol b\n"
"    5: String \")!\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:749
msgid ""
"So now instead of getting a plain string in `msg_body`, the macro is receiving a full expression that will need to be evaluated in order to "
"display as expected. This can be spliced directly into the returned expression as an argument to the [`string`](@ref) call; see [`error.jl`]"
"(https://github.com/JuliaLang/julia/blob/master/base/error.jl)  for the complete implementation."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:752
msgid ""
"The `@assert` macro makes great use of splicing into quoted expressions to simplify the manipulation of expressions inside the macro body."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:753
#, no-wrap
msgid "Hygiene"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:765
msgid ""
"An issue that arises in more complex macros is that of [hygiene](https://en.wikipedia.org/wiki/Hygienic_macro).  In short, macros must "
"ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding "
"code they expand into. Conversely, the expressions that are passed into a macro as arguments are often *expected* to evaluate in the context "
"of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be "
"called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct "
"module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the "
"returned expression. All the other variables (such as `msg` in `@assert` above) follow the [normal scoping block behavior](@ref scope-of-"
"variables)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:770
msgid ""
"To demonstrate these issues, let us consider writing a `@time` macro that takes an expression as its argument, records the time, evaluates "
"the expression, records the time again, prints the difference between the before and after times, and then has the value of the expression "
"as its final value. The macro might look like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:771
#, no-wrap
msgid ""
"macro time(ex)\n"
"    return quote\n"
"        local t0 = time()\n"
"        local val = $ex\n"
"        local t1 = time()\n"
"        println(\"elapsed time: \", t1-t0, \" seconds\")\n"
"        val\n"
"    end\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:788
msgid ""
"Here, we want `t0`, `t1`, and `val` to be private temporary variables, and we want `time` to refer to the [`time`](@ref) function in Julia "
"Base, not to any `time` variable the user might have (the same applies to `println`). Imagine the problems that could occur if the user "
"expression `ex` also contained assignments to a variable called `t0`, or defined its own `time` variable. We might get errors, or "
"mysteriously incorrect behavior."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:796
msgid ""
"Julia's macro expander solves these problems in the following way. First, variables within a macro result are classified as either local or "
"global. A variable is considered local if it is assigned to (and not declared global), declared local, or used as a function argument name. "
"Otherwise, it is considered global. Local variables are then renamed to be unique (using the [`gensym`](@ref)  function, which generates new "
"symbols), and global variables are resolved within the macro definition environment. Therefore both of the above concerns are handled; the "
"macro's locals will not conflict with any user variables, and `time` and `println` will refer to the Julia Base definitions."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:798
msgid "One problem remains however. Consider the following use of this macro:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:799
#, no-wrap
msgid ""
"module MyModule\n"
"import Base.@time\n"
"\n"
"time() = ... # compute something\n"
"\n"
"@time time()\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:812
msgid ""
"Here the user expression `ex` is a call to `time`, but not the same `time` function that the macro uses. It clearly refers to `MyModule."
"time`. Therefore we must arrange for the code in `ex` to be resolved in the macro call environment. This is done by \"escaping\" the "
"expression with [`esc`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:813
#, no-wrap
msgid ""
"macro time(ex)\n"
"    ...\n"
"    local val = $(esc(ex))\n"
"    ...\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:823
msgid ""
"An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be "
"resolved in the macro call environment."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:826
msgid ""
"This escaping mechanism can be used to \"violate\" hygiene when necessary, in order to introduce or manipulate user variables. For example, "
"the following macro sets `x` to zero in the call environment:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:827
#, no-wrap
msgid ""
"julia> macro zerox()\n"
"           return esc(:(x = 0))\n"
"       end\n"
"@zerox (macro with 1 method)\n"
"\n"
"julia> function foo()\n"
"           x = 1\n"
"           @zerox\n"
"           return x # is zero\n"
"       end\n"
"foo (generic function with 1 method)\n"
"\n"
"julia> foo()\n"
"0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:845
msgid "This kind of manipulation of variables should be used judiciously, but is occasionally quite handy."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:852
#, no-wrap
msgid ""
"Getting the hygiene rules correct can be a formidable challenge.\n"
"Before using a macro, you might want to consider whether a function closure\n"
"would be sufficient. Another useful strategy is to defer as much work as possible to runtime.\n"
"For example, many macros simply wrap their arguments in a `QuoteNode` or other similar [`Expr`](@ref).\n"
"Some examples of this include `@task body` which simply returns `schedule(Task(() -> $body))`,\n"
"and `@eval expr`, which simply returns `eval(QuoteNode(expr))`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:854
msgid "To demonstrate, we might rewrite the `@time` example above as:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:855
#, no-wrap
msgid ""
"macro time(expr)\n"
"    return :(timeit(() -> $(esc(expr))))\n"
"end\n"
"function timeit(f)\n"
"    t0 = time()\n"
"    val = f()\n"
"    t1 = time()\n"
"    println(\"elapsed time: \", t1-t0, \" seconds\")\n"
"    return val\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:871
msgid ""
"However, we don't do this for a good reason: wrapping the `expr` in a new scope block (the anonymous function)  also slightly changes the "
"meaning of the expression (the scope of any variables in it), while we want `@time` to be usable with minimum impact on the wrapped code."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:872
#, no-wrap
msgid "Macros and dispatch"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:875
msgid "Macros, just like Julia functions, are generic. This means they can also have multiple method definitions, thanks to multiple dispatch:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:875 ext/julia/doc/src/manual/metaprogramming.md:897
#, no-wrap
msgid "jldoctest macromethods"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:875
#, no-wrap
msgid ""
"julia> macro m end\n"
"@m (macro with 0 methods)\n"
"\n"
"julia> macro m(args...)\n"
"           println(\"$(length(args)) arguments\")\n"
"       end\n"
"@m (macro with 1 method)\n"
"\n"
"julia> macro m(x,y)\n"
"           println(\"Two arguments\")\n"
"       end\n"
"@m (macro with 2 methods)\n"
"\n"
"julia> @m \"asd\"\n"
"1 arguments\n"
"\n"
"julia> @m 1 2\n"
"Two arguments\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:897
msgid ""
"However one should keep in mind, that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST "
"evaluates to at runtime:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:897
#, no-wrap
msgid ""
"julia> macro m(::Int)\n"
"           println(\"An Integer\")\n"
"       end\n"
"@m (macro with 3 methods)\n"
"\n"
"julia> @m 2\n"
"An Integer\n"
"\n"
"julia> x = 2\n"
"2\n"
"\n"
"julia> @m x\n"
"1 arguments\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/metaprogramming.md:913
#, no-wrap
msgid "Code Generation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:920
msgid ""
"When a significant amount of repetitive boilerplate code is required, it is common to generate it programmatically to avoid redundancy. In "
"most languages, this requires an extra build step, and a separate program to generate the repetitive code. In Julia, expression "
"interpolation and [`eval`](@ref) allow such code generation to take place in the normal course of program execution.  For example, consider "
"the following custom type"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:921 ext/julia/doc/src/manual/metaprogramming.md:932
#: ext/julia/doc/src/manual/metaprogramming.md:944
#, no-wrap
msgid "jldoctest mynumber-codegen"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:921
#, no-wrap
msgid ""
"struct MyNumber\n"
"    x::Float64\n"
"end\n"
"# output\n"
"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:931
msgid "for which we want to add a number of methods to. We can do this programmatically in the following loop:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:932
#, no-wrap
msgid ""
"for op = (:sin, :cos, :tan, :log, :exp)\n"
"    eval(quote\n"
"        Base.$op(a::MyNumber) = MyNumber($op(a.x))\n"
"    end)\n"
"end\n"
"# output\n"
"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:943
msgid "and we can now use those functions with our custom type:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:944
#, no-wrap
msgid ""
"julia> x = MyNumber(Ï)\n"
"MyNumber(3.141592653589793)\n"
"\n"
"julia> sin(x)\n"
"MyNumber(1.2246467991473532e-16)\n"
"\n"
"julia> cos(x)\n"
"MyNumber(-1.0)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:958
msgid ""
"In this manner, Julia acts as its own [preprocessor](https://en.wikipedia.org/wiki/Preprocessor), and allows code generation from inside the "
"language. The above code could be written slightly more tersely using the `:` prefix quoting form:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:959
#, no-wrap
msgid ""
"for op = (:sin, :cos, :tan, :log, :exp)\n"
"    eval(:(Base.$op(a::MyNumber) = MyNumber($op(a.x))))\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:967
msgid ""
"This sort of in-language code generation, however, using the `eval(quote(...))` pattern, is common enough that Julia comes with a macro to "
"abbreviate this pattern:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:968
#, no-wrap
msgid ""
"for op = (:sin, :cos, :tan, :log, :exp)\n"
"    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:977
msgid ""
"The [`@eval`](@ref) macro rewrites this call to be precisely equivalent to the above longer versions.  For longer blocks of generated code, "
"the expression argument given to [`@eval`](@ref) can be a block:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:978
#, no-wrap
msgid ""
"@eval begin\n"
"    # multiple lines\n"
"end\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/metaprogramming.md:984
#, no-wrap
msgid "Non-Standard String Literals"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:988
msgid ""
"Recall from [Strings](@ref non-standard-string-literals) that string literals prefixed by an identifier are called non-standard string "
"literals, and can have different semantics than un-prefixed string literals. For example:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/metaprogramming.md:991
msgid "`r\"^\\s*(?:#|$)\"` produces a regular expression object rather than a string"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/metaprogramming.md:991
msgid "`b\"DATA\\xff\\u2200\"` is a byte array literal for `[68,65,84,65,255,226,136,128]`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:996
msgid ""
"Perhaps surprisingly, these behaviors are not hard-coded into the Julia parser or compiler. Instead, they are custom behaviors provided by a "
"general mechanism that anyone can use: prefixed string literals are parsed as calls to specially-named macros. For example, the regular "
"expression macro is just the following:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:997
#, no-wrap
msgid ""
"macro r_str(p)\n"
"    Regex(p)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1007
msgid ""
"That's all. This macro says that the literal contents of the string literal `r\"^\\s*(?:#|$)\"` should be passed to the `@r_str` macro and "
"the result of that expansion should be placed in the syntax tree where the string literal occurs. In other words, the expression `r\"^\\s*(?:"
"#|$)\"` is equivalent to placing the following object directly into the syntax tree:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1008
#, no-wrap
msgid "Regex(\"^\\\\s*(?:#|\\$)\")\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1016
msgid ""
"Not only is the string literal form shorter and far more convenient, but it is also more efficient: since the regular expression is compiled "
"and the `Regex` object is actually created *when the code is compiled*, the compilation occurs only once, rather than every time the code is "
"executed. Consider if the regular expression occurs in a loop:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1017
#, no-wrap
msgid ""
"for line = lines\n"
"    m = match(r\"^\\s*(?:#|$)\", line)\n"
"    if m === nothing\n"
"        # non-comment\n"
"    else\n"
"        # comment\n"
"    end\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1031
msgid ""
"Since the regular expression `r\"^\\s*(?:#|$)\"` is compiled and inserted into the syntax tree when this code is parsed, the expression is "
"only compiled once instead of each time the loop is executed.  In order to accomplish this without macros, one would have to write this loop "
"like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1032
#, no-wrap
msgid ""
"re = Regex(\"^\\\\s*(?:#|\\$)\")\n"
"for line = lines\n"
"    m = match(re, line)\n"
"    if m === nothing\n"
"        # non-comment\n"
"    else\n"
"        # comment\n"
"    end\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1053
msgid ""
"Moreover, if the compiler could not determine that the regex object was constant over all loops, certain optimizations might not be "
"possible, making this version still less efficient than the more convenient literal form above. Of course, there are still situations where "
"the non-literal form is more convenient: if one needs to interpolate a variable into the regular expression, one must take this more verbose "
"approach; in cases where the regular expression pattern itself is dynamic, potentially changing upon each loop iteration, a new regular "
"expression object must be constructed on each iteration. In the vast majority of use cases, however, regular expressions are not constructed "
"based on run-time data. In this majority of cases, the ability to write regular expressions as compile-time values is invaluable."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1059
msgid ""
"Like non-standard string literals, non-standard command literals exist using a prefixed variant of the command literal syntax. The command "
"literal ```custom`literal` ``` is parsed as `@custom_cmd \"literal\"`.  Julia itself does not contain any non-standard command literals, but "
"packages can make use of this syntax. Aside from the different syntax and the `_cmd` suffix instead of the `_str` suffix, non-standard "
"command literals behave exactly like non-standard string literals."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1064
msgid ""
"In the event that two modules provide non-standard string or command literals with the same name, it is possible to qualify the string or "
"command literal with a module name. For instance, if both `Foo` and `Bar` provide non-standard string literal `@x_str`, then one can write "
"`Foo.x\"literal\"` or `Bar.x\"literal\"` to disambiguate between the two."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1068
msgid ""
"The mechanism for user-defined string literals is deeply, profoundly powerful. Not only are Julia's non-standard literals implemented using "
"it, but also the command literal syntax (``` `echo \"Hello, $person\"` ```)  is implemented with the following innocuous-looking macro:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1069
#, no-wrap
msgid ""
"macro cmd(str)\n"
"    :(cmd_gen($(shell_parse(str)[1])))\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1079
msgid ""
"Of course, a large amount of complexity is hidden in the functions used in this macro definition, but they are just functions, written "
"entirely in Julia. You can read their source and see precisely what they do -- and all they do is construct expression objects to be "
"inserted into your program's syntax tree."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/metaprogramming.md:1080
#, no-wrap
msgid "Generated functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1088
msgid ""
"A very special macro is [`@generated`](@ref), which allows you to define so-called *generated functions*.  These have the capability to "
"generate specialized code depending on the types of their arguments with more flexibility and/or less code than what can be achieved with "
"multiple dispatch. While macros work with expressions at parse time and cannot access the types of their inputs, a generated function gets "
"expanded at a time when the types of the arguments are known, but the function is not yet compiled."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1095
msgid ""
"Instead of performing some calculation or action, a generated function declaration returns a quoted expression which then forms the body for "
"the method corresponding to the types of the arguments.  When a generated function is called, the expression it returns is compiled and then "
"run.  To make this efficient, the result is usually cached. And to make this inferable, only a limited subset of the language is usable. "
"Thus, generated functions provide a flexible way to move work from run time to compile time, at the expense of greater restrictions on "
"allowed constructs."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1097
msgid "When defining generated functions, there are five main differences to ordinary functions:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/metaprogramming.md:1112
msgid ""
"You annotate the function declaration with the `@generated` macro. This adds some information to the AST that lets the compiler know that "
"this is a generated function."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/metaprogramming.md:1112
msgid "In the body of the generated function you only have access to the *types* of the arguments â not their values."
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/manual/metaprogramming.md:1112
msgid "Instead of calculating something or performing some action, you return a *quoted expression* which, when evaluated, does what you want."
msgstr ""

#. type: Bullet: '4. '
#: ext/julia/doc/src/manual/metaprogramming.md:1112
msgid ""
"Generated functions are only permitted to call functions that were defined *before* the definition of the generated function. (Failure to "
"follow this my result on getting `MethodErrors` referring to functions from a future world-age.)"
msgstr ""

#. type: Bullet: '5. '
#: ext/julia/doc/src/manual/metaprogramming.md:1112
msgid ""
"Generated functions must not *mutate* or *observe* any non-constant global state (including, for example, IO, locks, non-local dictionaries, "
"or using [`hasmethod`](@ref)).  This means they can only read global constants, and cannot have any side effects.  In other words, they must "
"be completely pure.  Due to an implementation limitation, this also means that they currently cannot define a closure or generator."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1114
msgid "It's easiest to illustrate this with an example. We can declare a generated function `foo` as"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:1115 ext/julia/doc/src/manual/metaprogramming.md:1129
#: ext/julia/doc/src/manual/metaprogramming.md:1149
#, no-wrap
msgid "jldoctest generated"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1115
#, no-wrap
msgid ""
"julia> @generated function foo(x)\n"
"           Core.println(x)\n"
"           return :(x * x)\n"
"       end\n"
"foo (generic function with 1 method)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1125
msgid "Note that the body returns a quoted expression, namely `:(x * x)`, rather than just the value of `x * x`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1128
msgid ""
"From the caller's perspective, this is identical to a regular function; in fact, you don't have to know whether you're calling a regular or "
"generated function. Let's see how `foo` behaves:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1129
#, no-wrap
msgid ""
"julia> x = foo(2); # note: output is from println() statement in the body\n"
"Int64\n"
"\n"
"julia> x           # now we print x\n"
"4\n"
"\n"
"julia> y = foo(\"bar\");\n"
"String\n"
"\n"
"julia> y\n"
"\"barbar\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1146
msgid ""
"So, we see that in the body of the generated function, `x` is the *type* of the passed argument, and the value returned by the generated "
"function, is the result of evaluating the quoted expression we returned from the definition, now with the *value* of `x`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1148
msgid "What happens if we evaluate `foo` again with a type that we have already used?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1149
#, no-wrap
msgid ""
"julia> foo(4)\n"
"16\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1159
msgid ""
"Note that there is no printout of [`Int64`](@ref). We can see that the body of the generated function was only executed once here, for the "
"specific set of argument types, and the result was cached.  After that, for this example, the expression returned from the generated "
"function on the first invocation was re-used as the method body. However, the actual caching behavior is an implementation-defined "
"performance optimization, so it is invalid to depend too closely on this behavior."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1166
msgid ""
"The number of times a generated function is generated *might* be only once, but it *might* also be more often, or appear to not happen at "
"all. As a consequence, you should *never* write a generated function with side effects - when, and how often, the side effects occur is "
"undefined. (This is true for macros too - and just like for macros, the use of [`eval`](@ref) in a generated function is a sign that you're "
"doing something the wrong way.) However, unlike macros, the runtime system cannot correctly handle a call to [`eval`](@ref), so it is "
"disallowed."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1172
msgid ""
"It is also important to see how `@generated` functions interact with method redefinition.  Following the principle that a correct "
"`@generated` function must not observe any mutable state or cause any mutation of global state, we see the following behavior.  Observe that "
"the generated function *cannot* call any method that was not defined prior to the *definition* of the generated function itself."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1174
msgid "Initially `f(x)` has one definition"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:1175 ext/julia/doc/src/manual/metaprogramming.md:1181
#: ext/julia/doc/src/manual/metaprogramming.md:1191 ext/julia/doc/src/manual/metaprogramming.md:1199
#: ext/julia/doc/src/manual/metaprogramming.md:1215
#, no-wrap
msgid "jldoctest redefinition"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1175
#, no-wrap
msgid "julia> f(x) = \"original definition\";\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1180
msgid "Define other operations that use `f(x)`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1181
#, no-wrap
msgid ""
"julia> g(x) = f(x);\n"
"\n"
"julia> @generated gen1(x) = f(x);\n"
"\n"
"julia> @generated gen2(x) = :(f(x));\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1190
msgid "We now add some new definitions for `f(x)`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1191
#, no-wrap
msgid ""
"julia> f(x::Int) = \"definition for Int\";\n"
"\n"
"julia> f(x::Type{Int}) = \"definition for Type{Int}\";\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1198
msgid "and compare how these results differ:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1199
#, no-wrap
msgid ""
"julia> f(1)\n"
"\"definition for Int\"\n"
"\n"
"julia> g(1)\n"
"\"definition for Int\"\n"
"\n"
"julia> gen1(1)\n"
"\"original definition\"\n"
"\n"
"julia> gen2(1)\n"
"\"definition for Int\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1214
msgid "Each method of a generated function has its own view of defined functions:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1215
#, no-wrap
msgid ""
"julia> @generated gen1(x::Real) = f(x);\n"
"\n"
"julia> gen1(1)\n"
"\"definition for Type{Int}\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1226
msgid ""
"The example generated function `foo` above did not do anything a normal function `foo(x) = x * x` could not do (except printing the type on "
"the first invocation, and incurring higher overhead).  However, the power of a generated function lies in its ability to compute different "
"quoted expressions depending on the types passed to it:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1227
#, no-wrap
msgid ""
"julia> @generated function bar(x)\n"
"           if x <: Integer\n"
"               return :(x ^ 2)\n"
"           else\n"
"               return :(x)\n"
"           end\n"
"       end\n"
"bar (generic function with 1 method)\n"
"\n"
"julia> bar(4)\n"
"16\n"
"\n"
"julia> bar(\"baz\")\n"
"\"baz\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1245
msgid "(although of course this contrived example would be more easily implemented using multiple dispatch...)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1247
msgid "Abusing this will corrupt the runtime system and cause undefined behavior:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1248
#, no-wrap
msgid ""
"julia> @generated function baz(x)\n"
"           if rand() < .9\n"
"               return :(x^2)\n"
"           else\n"
"               return :(\"boo!\")\n"
"           end\n"
"       end\n"
"baz (generic function with 1 method)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1261
msgid "Since the body of the generated function is non-deterministic, its behavior, *and the behavior of all subsequent code* is undefined."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1263
#, no-wrap
msgid "*Don't copy these examples!*\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1266
msgid ""
"These examples are hopefully helpful to illustrate how generated functions work, both in the definition end and at the call site; however, "
"*don't copy them*, for the following reasons:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/metaprogramming.md:1272
msgid ""
"the `foo` function has side-effects (the call to `Core.println`), and it is undefined exactly when, how often or how many times these side-"
"effects will occur"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/metaprogramming.md:1272
msgid ""
"the `bar` function solves a problem that is better solved with multiple dispatch - defining `bar(x) = x` and `bar(x::Integer) = x ^ 2` will "
"do the same thing, but it is both simpler and faster."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/metaprogramming.md:1272
msgid "the `baz` function is pathological"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1278
msgid ""
"Note that the set of operations that should not be attempted in a generated function is unbounded, and the runtime system can currently only "
"detect a subset of the invalid operations. There are many other operations that will simply corrupt the runtime system without notification, "
"usually in subtle ways not obviously connected to the bad definition. Because the function generator is run during inference, it must "
"respect all of the limitations of that code."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1280
msgid "Some operations that should not be attempted include:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/metaprogramming.md:1284
msgid "Caching of native pointers."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/metaprogramming.md:1284
msgid "Interacting with the contents or methods of `Core.Compiler` in any way."
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/manual/metaprogramming.md:1284
msgid "Observing any mutable state."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1292
#, no-wrap
msgid ""
"     * Inference on the generated function may be run at *any* time, including while your code is attempting\n"
"       to observe or mutate this state.\n"
"4. Taking any locks: C code you call out to may use locks internally, (for example, it is not problematic\n"
"   to call `malloc`, even though most implementations require locks internally) but don't attempt\n"
"   to hold or acquire any while executing Julia code.\n"
"5. Calling any function that is defined after the body of the generated function. This condition\n"
"   is relaxed for incrementally-loaded precompiled modules to allow calling any function in the module.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1295
msgid ""
"Alright, now that we have a better understanding of how generated functions work, let's use them to build some more advanced (and valid) "
"functionality..."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:1296
#, no-wrap
msgid "An advanced example"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1302
msgid ""
"Julia's base library has a an internal `sub2ind` function to calculate a linear index into an n-dimensional array, based on a set of n "
"multilinear indices - in other words, to calculate the index `i` that can be used to index into an array `A` using `A[i]`, instead of `A[x,y,"
"z,...]`. One possible implementation is the following:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:1303
#, no-wrap
msgid "jldoctest sub2ind"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1303
#, no-wrap
msgid ""
"julia> function sub2ind_loop(dims::NTuple{N}, I::Integer...) where N\n"
"           ind = I[N] - 1\n"
"           for i = N-1:-1:1\n"
"               ind = I[i]-1 + dims[i]*ind\n"
"           end\n"
"           return ind + 1\n"
"       end\n"
"sub2ind_loop (generic function with 1 method)\n"
"\n"
"julia> sub2ind_loop((3, 5), 1, 2)\n"
"4\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1318
msgid "The same thing can be done using recursion:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1319
#, no-wrap
msgid ""
"julia> sub2ind_rec(dims::Tuple{}) = 1;\n"
"\n"
"julia> sub2ind_rec(dims::Tuple{}, i1::Integer, I::Integer...) =\n"
"           i1 == 1 ? sub2ind_rec(dims, I...) : throw(BoundsError());\n"
"\n"
"julia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer) = i1;\n"
"\n"
"julia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer, I::Integer...) =\n"
"           i1 + dims[1] * (sub2ind_rec(Base.tail(dims), I...) - 1);\n"
"\n"
"julia> sub2ind_rec((3, 5), 1, 2)\n"
"4\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1336
msgid ""
"Both these implementations, although different, do essentially the same thing: a runtime loop over the dimensions of the array, collecting "
"the offset in each dimension into the final index."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1341
msgid ""
"However, all the information we need for the loop is embedded in the type information of the arguments.  Thus, we can utilize generated "
"functions to move the iteration to compile-time; in compiler parlance, we use generated functions to manually unroll the loop. The body "
"becomes almost identical, but instead of calculating the linear index, we build up an *expression* that calculates the index:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:1342
#, no-wrap
msgid "jldoctest sub2ind_gen"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1342
#, no-wrap
msgid ""
"julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\n"
"           ex = :(I[$N] - 1)\n"
"           for i = (N - 1):-1:1\n"
"               ex = :(I[$i] - 1 + dims[$i] * $ex)\n"
"           end\n"
"           return :($ex + 1)\n"
"       end\n"
"sub2ind_gen (generic function with 1 method)\n"
"\n"
"julia> sub2ind_gen((3, 5), 1, 2)\n"
"4\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1357
#, no-wrap
msgid "**What code will this generate?**\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1359
msgid "An easy way to find out is to extract the body into another (regular) function:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/metaprogramming.md:1360 ext/julia/doc/src/manual/metaprogramming.md:1379
#, no-wrap
msgid "jldoctest sub2ind_gen2"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1360
#, no-wrap
msgid ""
"julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\n"
"           return sub2ind_gen_impl(dims, I...)\n"
"       end\n"
"sub2ind_gen (generic function with 1 method)\n"
"\n"
"julia> function sub2ind_gen_impl(dims::Type{T}, I...) where T <: NTuple{N,Any} where N\n"
"           length(I) == N || return :(error(\"partial indexing is unsupported\"))\n"
"           ex = :(I[$N] - 1)\n"
"           for i = (N - 1):-1:1\n"
"               ex = :(I[$i] - 1 + dims[$i] * $ex)\n"
"           end\n"
"           return :($ex + 1)\n"
"       end\n"
"sub2ind_gen_impl (generic function with 1 method)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1378
msgid "We can now execute `sub2ind_gen_impl` and examine the expression it returns:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1379
#, no-wrap
msgid ""
"julia> sub2ind_gen_impl(Tuple{Int,Int}, Int, Int)\n"
":(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1389
msgid ""
"So, the method body that will be used here doesn't include a loop at all - just indexing into the two tuples, multiplication and addition/"
"subtraction. All the looping is performed compile-time, and we avoid looping during execution entirely. Thus, we only loop *once per type*, "
"in this case once per `N` (except in edge cases where the function is generated more than once - see disclaimer above)."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/metaprogramming.md:1390
#, no-wrap
msgid "Optionally-generated functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1398
msgid ""
"Generated functions can achieve high efficiency at run time, but come with a compile time cost: a new function body must be generated for "
"every combination of concrete argument types.  Typically, Julia is able to compile \"generic\" versions of functions that will work for any "
"arguments, but with generated functions this is impossible.  This means that programs making heavy use of generated functions might be "
"impossible to statically compile."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1402
msgid ""
"To solve this problem, the language provides syntax for writing normal, non-generated alternative implementations of generated functions.  "
"Applied to the `sub2ind` example above, it would look like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1403
#, no-wrap
msgid ""
"function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\n"
"    if N != length(I)\n"
"        throw(ArgumentError(\"Number of dimensions must match number of indices.\"))\n"
"    end\n"
"    if @generated\n"
"        ex = :(I[$N] - 1)\n"
"        for i = (N - 1):-1:1\n"
"            ex = :(I[$i] - 1 + dims[$i] * $ex)\n"
"        end\n"
"        return :($ex + 1)\n"
"    else\n"
"        ind = I[N] - 1\n"
"        for i = (N - 1):-1:1\n"
"            ind = I[i] - 1 + dims[i]*ind\n"
"        end\n"
"        return ind + 1\n"
"    end\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1430
msgid ""
"Internally, this code creates two implementations of the function: a generated one where the first block in `if @generated` is used, and a "
"normal one where the `else` block is used.  Inside the `then` part of the `if @generated` block, code has the same semantics as other "
"generated functions: argument names refer to types, and the code should return an expression.  Multiple `if @generated` blocks may occur, in "
"which case the generated implementation uses all of the `then` blocks and the alternate implementation uses all of the `else` blocks."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1436
msgid ""
"Notice that we added an error check to the top of the function.  This code will be common to both versions, and is run-time code in both "
"versions (it will be quoted and returned as an expression from the generated version).  That means that the values and types of local "
"variables are not available at code generation time --- the code-generation code can only see the types of arguments."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/metaprogramming.md:1444
msgid ""
"In this style of definition, the code generation feature is essentially an optional optimization.  The compiler will use it if convenient, "
"but otherwise may choose to use the normal implementation instead.  This style is preferred, since it allows the compiler to make more "
"decisions and compile programs in more ways, and since normal code is more readable than code-generating code.  However, which "
"implementation is used depends on compiler implementation details, so it is essential for the two implementations to behave identically."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/strings.md:1
#, no-wrap
msgid "[Strings](@id man-strings)"
msgstr "[æå­å](@id man-strings)"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:20
msgid ""
"Strings are finite sequences of characters. Of course, the real trouble comes when one asks what a character is. The characters that English "
"speakers are familiar with are the letters `A`, `B`, `C`, etc., together with numerals and common punctuation symbols. These characters are "
"standardized together with a mapping to integer values between 0 and 127 by the [ASCII](https://en.wikipedia.org/wiki/ASCII)  standard. "
"There are, of course, many other characters used in non-English languages, including variants of the ASCII characters with accents and other "
"modifications, related scripts such as Cyrillic and Greek, and scripts completely unrelated to ASCII and English, including Arabic, Chinese, "
"Hebrew, Hindi, Japanese, and Korean. The [Unicode](https://en.wikipedia.org/wiki/Unicode) standard tackles the complexities of what exactly "
"a character is, and is generally accepted as the definitive standard addressing this problem. Depending on your needs, you can either ignore "
"these complexities entirely and just pretend that only ASCII characters exist, or you can write code that can handle any of the characters "
"or encodings that one may encounter when handling non-ASCII text. Julia makes dealing with plain ASCII text simple and efficient, and "
"handling Unicode is as simple and efficient as possible. In particular, you can write C-style string code to process ASCII strings, and they "
"will work as expected, both in terms of performance and semantics. If such code encounters non-ASCII text, it will gracefully fail with a "
"clear error message, rather than silently introducing corrupt results. When this happens, modifying the code to handle non-ASCII data is "
"straightforward."
msgstr ""
"æå­åã¯ãæå­ã®æéåã§ãããããæå­ã¨ã¯ä½ã§ããããã¨åãã¦ã¿ãã¨åé¡ã¯è¤éã§ãããã¨ã«æ°ã¥ãã¾ããè±èªãè©±ãäººã«ã¨ã£ã¦ããç¥ãæå­ã¨ã¯ã"
"æå­`A`ã`B`ã`C`ç­ã¨æ°å­ãä¸è¬çãªå¥èª­ç¹ã§ãããããã®æå­ã¨0ãã127ã¾ã§ã®æ´æ°å¤ã¨ã®ãããã³ã°ã¯[ASCII](https://en.wikipedia.org/wiki/ASCII)"
"æ¨æºã«ãã£ã¦æ¨æºåããã¦ãã¾ãããã¡ãããæå­ã«ã¯ãè±èªä»¥å¤ã§ä½¿ãããæ°ãã®æå­ãå«ã¾ããããã§ããã¢ã¯ã»ã³ãããã®ä»ã®å¤æ´ãå ããå¤å½¢ASCII"
"æå­ãã­ãªã«æå­ãã®ãªã·ã£èªãªã©ã®é¢é£ã¹ã¯ãªãããASCIIãè±èªã¨ã¯å¨ãé¢ä¿ã®ãªãè¨èªä½ç³»ã§ãããã¢ã©ãã¢èªãä¸­å½èªãããã©ã¤èªããã³ãã£ã¼èªã"
"æ¥æ¬èªãéå½èªãªã©ã§ãã[Unicode](https://en.wikipedia.org/wiki/Unicode)æ¨æºã¯ãæå­ãæ­£ç¢ºã«ä½ã§ãããã®è¤éãã«åãçµã¿ããã®åé¡ã«å¯¾å¦ãã"
"æ±ºå®çãªæ¨æºã¨ãã¦åºãåãå¥ãããã¦ãã¾ãããã¼ãºã«å¿ãã¦ããããã®è¤éããå®å¨ã«ç¡è¦ãã¦ãASCII æå­ã®ã¿ãå­å¨ãããµããããããASCII ä»¥å¤"
"ã®ãã­ã¹ããå¦çããã¨ãã«çºçããå¯è½æ§ã®ããæå­ã¾ãã¯ã¨ã³ã³ã¼ãã£ã³ã°ãæ±ãã³ã¼ããè¨è¿°ã§ãã¾ããJulia ã¯ãã¬ã¼ã³ãª ASCII ãã­ã¹ããã·ã³ã"
"ã«ãã¤å¹ççã«å¦çããUnicode ã®å¦çãå¯è½ãªéãã·ã³ãã«ã§å¹ççã«å¦çãã¾ããç¹ã«ãASCII æå­åãå¦çããã¨ãã«ã¯ãC ã¹ã¿ã¤ã«ã®æå­åã³ã¼ã"
"ãè¨è¿°ã§ããããã©ã¼ãã³ã¹ã¨ã»ãã³ãã£ã¯ã¹ã®ä¸¡æ¹ã§æå¾ã©ããã«åä½ãã¾ãããã®ãããªã³ã¼ãã§ ASCII ä»¥å¤ã®ãã­ã¹ããæ¤åºãããå ´åã¯ãééã£ã"
"çµæããã è¿ãã®ã§ã¯ãªãæç¢ºãªã¨ã©ã¼ ã¡ãã»ã¼ã¸ã§æ­£å¸¸ã«å¤±æãã¾ãããã®å ´åãASCII ä»¥å¤ã®ãã¼ã¿ãå¦çããããã«ã³ã¼ããå¤æ´ããã®ã¯ç°¡åã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:22
msgid "There are a few noteworthy high-level features about Julia's strings:"
msgstr "Juliaã«ã¯ãæå­åã«é¢ä¿ããããã¤ãã®æ³¨ç®ãã¹ãé«åº¦ãªæ©è½ãããã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:42
msgid ""
"The built-in concrete type used for strings (and string literals) in Julia is [`String`](@ref).  This supports the full range of [Unicode]"
"(https://en.wikipedia.org/wiki/Unicode) characters via the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) encoding. (A [`transcode`](@ref) "
"function is provided to convert to/from other Unicode encodings.)"
msgstr ""
"ã¸ã¥ãªã¢ã®æå­å (ããã³æå­åãªãã©ã«) ã«ä½¿ç¨ãããçµã¿è¾¼ã¿ã®å·ä½çãªåã¯ [`String`](@ref)ã§ãã ããã¯[UTF-8](https://en.wikipedia.org/"
"wiki/UTF-8)ã¨ã³ã³ã¼ãã£ã³ã°ã«ãã[Unicode](https://en.wikipedia.org/wiki/UTF-8)ã®å¨ç¯å²ããµãã¼ããã¦ãã¾ãã(ä»ã® Unicode ã¨ã³ã³ã¼ãã£ã³ã°ã¨"
"ã®éã§å¤æããããã«[`transcode`](@ref) é¢æ°ãæä¾ããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:42
msgid ""
"All string types are subtypes of the abstract type `AbstractString`, and external packages define additional `AbstractString` subtypes (e.g. "
"for other encodings).  If you define a function expecting a string argument, you should declare the type as `AbstractString` in order to "
"accept any string type."
msgstr ""
"ãã¹ã¦ã®æå­ååã¯æ½è±¡å `AbstractString`ã®ãµãã¿ã¤ãã§ãããå¤é¨ããã±ã¼ã¸ã¯è¿½å ã® `AbstractString` ãµãã¿ã¤ããå®ç¾©ãã¾ã (ä¾ãã°ä»ã®ã¨ã³"
"ã³ã¼ãã£ã³ã°ç¨ãªã©ã«)ã æå­åå¼æ°ãå¿è¦ã¨ããé¢æ°ãå®ç¾©ããå ´åã¯ãä»»æã®æå­ååãåãå¥ããããã«ãåã `AbstractString` ã¨ãã¦å®£è¨ããå¿"
"è¦ãããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:42
msgid ""
"Like C and Java, but unlike most dynamic languages, Julia has a first-class type for representing a single character, called [`AbstractChar`]"
"(@ref). The built-in [`Char`](@ref) subtype of `AbstractChar` is a 32-bit primitive type that can represent any Unicode character (and which "
"is based on the UTF-8 encoding)."
msgstr ""
"C ã Java ã¨åæ§ã«ãããã¦ã»ã¨ãã©ã®åçè¨èªã¨ã¯ç°ãªããJulia ã«ã¯[`AbstractChar`](@ref)ã¨å¼ã°ããåä¸ã®æå­ãè¡¨ããã¡ã¼ã¹ãã¯ã©ã¹ã®åããã"
"ã¾ãã`AbstractChar` ã®çµã¿è¾¼ã¿ã® [`Char`](@ref) ãµãã¿ã¤ãã¯ãä»»æã® Unicode æå­ãè¡¨ããã¨ãã§ãã 32 ããã ããªããã£ãåã§ã (UTF-8 ã¨ã³"
"ã³ã¼ãã£ã³ã°ã«åºã¥ãã¦ãã¾ã)ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:42
msgid ""
"As in Java, strings are immutable: the value of an `AbstractString` object cannot be changed.  To construct a different string value, you "
"construct a new string from parts of other strings."
msgstr ""
"Java ã¨åæ§ã«ãæå­åã¯ä¸å¤(ã¤ãã¥ã¼ã¿ãã«)ã§ããã`AbstractString` ãªãã¸ã§ã¯ãã®å¤ã¯å¤æ´ã§ãã¾ããã å¥ã®æå­åå¤ãä½æããã«ã¯ãä»ã®æå­å"
"ã®ä¸é¨ããæ°ããæå­åãä½æãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:42
msgid ""
"Conceptually, a string is a *partial function* from indices to characters: for some index values, no character value is returned, and "
"instead an exception is thrown. This allows for efficient indexing into strings by the byte index of an encoded representation rather than "
"by a character index, which cannot be implemented both efficiently and simply for variable-width encodings of Unicode strings."
msgstr ""
"æ¦å¿µçã«ã¯ãæå­åã¯ã¤ã³ããã¯ã¹ããæå­ã¸ã® *é¨åé¢æ°* ã§ããããã«ãããæå­ã¤ã³ããã¯ã¹ã§ã¯ãªããã¨ã³ã³ã¼ããããè¡¨ç¾ã®ãã¤ã ã¤ã³ããã¯ã¹"
"ã«ãã£ã¦æå­åã«å¹ççã«ã¤ã³ããã¯ã¹ãä½æã§ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/strings.md:43
#, no-wrap
msgid "[Characters](@id man-characters)"
msgstr "[æå­](@id man-characters)"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:52
msgid ""
"A `Char` value represents a single character: it is just a 32-bit primitive type with a special literal representation and appropriate "
"arithmetic behaviors, and which can be converted to a numeric value representing a [Unicode code point](https://en.wikipedia.org/wiki/"
"Code_point).  (Julia packages may define other subtypes of `AbstractChar`, e.g. to optimize operations for other [text encodings](https://en."
"wikipedia.org/wiki/Character_encoding).) Here is how `Char` values are input and shown:"
msgstr ""
"`Char`åã®å¤ã¯åä¸ã®æå­ãè¡¨ãã¾ã: ããã¯ãç¹å¥ãªãªãã©ã«è¡¨ç¾ã¨é©åãªç®è¡åä½ãæã¤ 32 ãããããªããã£ãåã§ããã[Unicode ã³ã¼ããã¤ã³ã]"
"(https://en.wikipedia.org/wiki/Code_point)ãè¡¨ãæ°å¤ã«å¤æã§ãã¾ãã (Juliaããã±ã¼ã¸ã¯`AbstractChar`ã®ä»ã®ãµãã¿ã¤ããå®ç¾©ãããã¨ãã§ãã¾"
"ããä¾ãã° ä»ã®[ãã­ã¹ãã¨ã³ã³ã¼ãã£ã³ã°](https://en.wikipedia.org/wiki/Character_encoding)ã®æä½ã®æé©åãªã©ã®ããã«) `Char` å¤ã®å¥åæ¹æ³ã"
"æ¬¡ã«ç¤ºãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:53
#, no-wrap
msgid ""
"julia> 'x'\n"
"'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n"
"\n"
"julia> typeof(ans)\n"
"Char\n"
msgstr ""
"julia> 'x'\n"
"'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n"
"\n"
"julia> typeof(ans)\n"
"Char\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:62
msgid "You can easily convert a `Char` to its integer value, i.e. code point:"
msgstr "`Char` ãæ´æ°å¤(ã³ã¼ã ãã¤ã³ã)ã«ç°¡åã«å¤æã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:63
#, no-wrap
msgid ""
"julia> Int('x')\n"
"120\n"
"\n"
"julia> typeof(ans)\n"
"Int64\n"
msgstr ""
"julia> Int('x')\n"
"120\n"
"\n"
"julia> typeof(ans)\n"
"Int64\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:73
msgid ""
"On 32-bit architectures, [`typeof(ans)`](@ref) will be [`Int32`](@ref). You can convert an integer value back to a `Char` just as easily:"
msgstr "32 ããã ã¢ã¼ã­ãã¯ãã£ã§ã¯ã[`typeof(ans)`](@ref) ã¯ [`Int32`](@ref)ã«ãªãã¾ããæ´æ°å¤ã `Char` ã«ç°¡åã«å¤æã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:74
#, no-wrap
msgid ""
"julia> Char(120)\n"
"'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n"
msgstr ""
"julia> Char(120)\n"
"'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:82
msgid ""
"Not all integer values are valid Unicode code points, but for performance, the `Char` conversion does not check that every character value "
"is valid. If you want to check that each converted value is a valid code point, use the [`isvalid`](@ref) function:"
msgstr ""
"ãã¹ã¦ã®æ´æ°å¤ãæå¹ãª Unicode ã³ã¼ã ãã¤ã³ãã§ããã¨ã¯è¨ãã¾ããããããã©ã¼ãã³ã¹åä¸ã®ããã`Char` å¤æã§ã¯ããã¹ã¦ã®å¼æ°ãæå¹ãªã³ã¼ãã"
"ã¤ã³ãã§ãããã®ç¢ºèªã¯è¡ãã¾ãããå¤æãããåå¤ãæå¹ãªã³ã¼ã ãã¤ã³ãã§ãããç¢ºèªããå ´åã¯ã[`isvalid`](@ref) é¢æ°ãä½¿ç¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:83
#, no-wrap
msgid ""
"julia> Char(0x110000)\n"
"'\\U110000': Unicode U+110000 (category In: Invalid, too high)\n"
"\n"
"julia> isvalid(Char, 0x110000)\n"
"false\n"
msgstr ""
"julia> Char(0x110000)\n"
"'\\U110000': Unicode U+110000 (category In: Invalid, too high)\n"
"\n"
"julia> isvalid(Char, 0x110000)\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:94
msgid ""
"As of this writing, the valid Unicode code points are `U+00` through `U+d7ff` and `U+e000` through `U+10ffff`. These have not all been "
"assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be "
"valid Unicode characters."
msgstr ""
"ç¾æç¹ã§ã¯ãæå¹ãª Unicode ã³ã¼ã ãã¤ã³ãã¯ `U+00` ãã `U+d7ff` ã¨ `U+e000` ãã `U+10ffff` ã§ãããããã¯ãã¹ã¦ã¾ã ããããããæå³ãå²ã"
"å½ã¦ããã¦ããªãããã¢ããªã±ã¼ã·ã§ã³ã«ãã£ã¦å¿ãããè§£éã§ããããã§ã¯ããã¾ãããããããã®å¤ã¯ãã¹ã¦æå¹ãª Unicode æå­ã¨è¦ãªããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:98
msgid ""
"You can input any Unicode character in single quotes using `\\u` followed by up to four hexadecimal digits or `\\U` followed by up to eight "
"hexadecimal digits (the longest valid value only requires six):"
msgstr ""
"åä¸å¼ç¨ç¬¦ã®ä¸­ã§ã`\\u` ãä½¿ç¨ãã¦ãã®å¾ã«16é²æ°ã§æå¤§ 4æ¡ãã¾ãã¯ `\\U` ã®å¾ã«16é²æ°ã§æå¤§ 8 æ¡(æé·æå¹å¤ã¯ 6 æ¡)ã§ãä»»æã®Unicode æå­ãå¥"
"åã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:99
#, no-wrap
msgid ""
"julia> '\\u0'\n"
"'\\0': ASCII/Unicode U+0000 (category Cc: Other, control)\n"
"\n"
"julia> '\\u78'\n"
"'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n"
"\n"
"julia> '\\u2200'\n"
"'â': Unicode U+2200 (category Sm: Symbol, math)\n"
"\n"
"julia> '\\U10ffff'\n"
"'\\U10ffff': Unicode U+10ffff (category Cn: Other, not assigned)\n"
msgstr ""
"julia> '\\u0'\n"
"'\\0': ASCII/Unicode U+0000 (category Cc: Other, control)\n"
"\n"
"julia> '\\u78'\n"
"'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n"
"\n"
"julia> '\\u2200'\n"
"'â': Unicode U+2200 (category Sm: Symbol, math)\n"
"\n"
"julia> '\\U10ffff'\n"
"'\\U10ffff': Unicode U+10ffff (category Cn: Other, not assigned)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:117
msgid ""
"Julia uses your system's locale and language settings to determine which characters can be printed as-is and which must be output using the "
"generic, escaped `\\u` or `\\U` input forms. In addition to these Unicode escape forms, all of [C's traditional escaped input forms](https://"
"en.wikipedia.org/wiki/C_syntax#Backslash_escapes)  can also be used:"
msgstr ""
"Julia ã¯ãã·ã¹ãã ã®ã­ã±ã¼ã«ã¨è¨èªã®è¨­å®ãä½¿ç¨ãã¦ãã©ã®æå­ããã®ã¾ã¾æ¯éãªãåºåã§ããããã©ã®æå­ãã`\\u` ã `\\U` ãä½¿ã£ãä¸è¬ç³»ã§åºåã"
"ãå¿è¦ãããããå¤æ­ãã¾ãããããã® Unicode ã¨ã¹ã±ã¼ãå½¢å¼ã«å ãã¦ã[Cè¨èªã®ã¨ã¹ã±ã¼ãå½¢å¼](https://en.wikipedia.org/wiki/"
"C_syntax#Backslash_escapes) ããã¹ã¦ä½¿ç¨ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:118
#, no-wrap
msgid ""
"julia> Int('\\0')\n"
"0\n"
"\n"
"julia> Int('\\t')\n"
"9\n"
"\n"
"julia> Int('\\n')\n"
"10\n"
"\n"
"julia> Int('\\e')\n"
"27\n"
"\n"
"julia> Int('\\x7f')\n"
"127\n"
"\n"
"julia> Int('\\177')\n"
"127\n"
msgstr ""
"julia> Int('\\0')\n"
"0\n"
"\n"
"julia> Int('\\t')\n"
"9\n"
"\n"
"julia> Int('\\n')\n"
"10\n"
"\n"
"julia> Int('\\e')\n"
"27\n"
"\n"
"julia> Int('\\x7f')\n"
"127\n"
"\n"
"julia> Int('\\177')\n"
"127\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:139
msgid "You can do comparisons and a limited amount of arithmetic with `Char` values:"
msgstr "`Char`å¤ã§ã¯ãããã¤ãã®éå®ãããç®è¡æ¼ç®ã¨æ¯è¼æ¼ç®ãè¡ããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:140
#, no-wrap
msgid ""
"julia> 'A' < 'a'\n"
"true\n"
"\n"
"julia> 'A' <= 'a' <= 'Z'\n"
"false\n"
"\n"
"julia> 'A' <= 'X' <= 'Z'\n"
"true\n"
"\n"
"julia> 'x' - 'a'\n"
"23\n"
"\n"
"julia> 'A' + 1\n"
"'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n"
msgstr ""
"julia> 'A' < 'a'\n"
"true\n"
"\n"
"julia> 'A' <= 'a' <= 'Z'\n"
"false\n"
"\n"
"julia> 'A' <= 'X' <= 'Z'\n"
"true\n"
"\n"
"julia> 'x' - 'a'\n"
"23\n"
"\n"
"julia> 'A' + 1\n"
"'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n"

#. type: Title ##
#: ext/julia/doc/src/manual/strings.md:157
#, no-wrap
msgid "String Basics"
msgstr "æå­åã®åºç¤"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:160
msgid "String literals are delimited by double quotes or triple double quotes:"
msgstr "æå­åãªãã©ã«ã¯ãäºéå¼ç¨ç¬¦ã¾ãã¯ä¸éå¼ç¨ç¬¦ã§åºåããã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/strings.md:161 ext/julia/doc/src/manual/strings.md:171 ext/julia/doc/src/manual/strings.md:193
#: ext/julia/doc/src/manual/strings.md:203 ext/julia/doc/src/manual/strings.md:217 ext/julia/doc/src/manual/strings.md:224
#, no-wrap
msgid "jldoctest helloworldstring"
msgstr "jldoctest helloworldstring"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:161
#, no-wrap
msgid ""
"julia> str = \"Hello, world.\\n\"\n"
"\"Hello, world.\\n\"\n"
"\n"
"julia> \"\"\"Contains \"quote\" characters\"\"\"\n"
"\"Contains \\\"quote\\\" characters\"\n"
msgstr ""
"julia> str = \"Hello, world.\\n\"\n"
"\"Hello, world.\\n\"\n"
"\n"
"julia> \"\"\"Contains \"quote\" characters\"\"\"\n"
"\"Contains \\\"quote\\\" characters\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:170
msgid "If you want to extract a character from a string, you index into it:"
msgstr "æå­åããæå­ãæ½åºããå ´åã¯ããã®æå­åã«ã¤ã³ããã¯ã¹ãä½¿ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:171
#, no-wrap
msgid ""
"julia> str[1]\n"
"'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n"
"\n"
"julia> str[6]\n"
"',': ASCII/Unicode U+002c (category Po: Punctuation, other)\n"
"\n"
"julia> str[end]\n"
"'\\n': ASCII/Unicode U+000a (category Cc: Other, control)\n"
msgstr ""
"julia> str[1]\n"
"'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n"
"\n"
"julia> str[6]\n"
"',': ASCII/Unicode U+002c (category Po: Punctuation, other)\n"
"\n"
"julia> str[end]\n"
"'\\n': ASCII/Unicode U+000a (category Cc: Other, control)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:189
msgid ""
"Many Julia objects, including strings, can be indexed with integers. The index of the first element (the first character of a string) is "
"returned by [`firstindex(str)`](@ref), and the index of the last element (character)  with [`lastindex(str)`](@ref). The keyword `end` can "
"be used inside an indexing operation as shorthand for the last index along the given dimension.  String indexing, like most indexing in "
"Julia, is 1-based: `firstindex` always returns `1` for any `AbstractString`.  As we will see below, however, `lastindex(str)` is *not* in "
"general the same as `length(str)` for a string, because some Unicode characters can occupy multiple \"code units\"."
msgstr ""
"æå­åãå«ãå¤ãã® Julia ãªãã¸ã§ã¯ãã¯ãæ´æ°ã§ã¤ã³ããã¯ã¹ã¥ããã§ãã¾ããæåã®è¦ç´ (æå­åã®æåã®æå­)ã®ã¤ã³ããã¯ã¹ã¯ [`firstindex(str)`]"
"(@ref)ã§ãæå¾ã®è¦ç´ (æå­)ã®ã¤ã³ããã¯ã¹ã¯ [`lastindex(str)`](@ref)ã§åå¾ã§ãã¾ããã­ã¼ã¯ã¼ã `end` ã¯ãã¤ã³ããã¯ã¹æä½æã«ãæå®ãããæ¬¡å"
"ã®æå¾ã®ã¤ã³ããã¯ã¹ãç¤ºãç­ç¸®å½¢ã¨ãã¦ä½¿ç¨ã§ãã¾ãã æå­åã®ã¤ã³ãã¯ã¹ä»ã¯ãJulia ã®ã»ã¨ãã©ã®ã¤ã³ããã¯ã¹ã¥ãã¨åæ§ã«ã 1 ããå§ã¾ãã¾ã: "
"ã©ããª`AbsdtractString`åã«å¯¾ãã¦ãã`firstindex` ã¯ãã¤ã `1` ãè¿ãã¾ãã\n"
"(å¾ã§ç¤ºãã¾ãããããããªããã`lastindex(str)`ã¯ `length(str)`ã¨ã¯ä¸è¬çã«åãã§ã¯ *ããã¾ãã*ãä¸é¨ã®ã¦ãã³ã¼ãæå­ã¯ãè¤æ°ã®ç¬¦å·åä½ãå°"
"æãããã¨ãããããã§ã)"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:192
msgid "You can perform arithmetic and other operations with [`end`](@ref), just like a normal value:"
msgstr "éå¸¸ã®å¤ã¨åæ§ã«ã[`end`](@ref)ã«å¯¾ãã¦ç®è¡æ¼ç®ããã®ä»ã®æ¼ç®ãå®è¡ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:193
#, no-wrap
msgid ""
"julia> str[end-1]\n"
"'.': ASCII/Unicode U+002e (category Po: Punctuation, other)\n"
"\n"
"julia> str[endÃ·2]\n"
"' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n"
msgstr ""
"julia> str[end-1]\n"
"'.': ASCII/Unicode U+002e (category Po: Punctuation, other)\n"
"\n"
"julia> str[endÃ·2]\n"
"' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:202
msgid "Using an index less than 1 or greater than `end` raises an error:"
msgstr "1ããå°ããã¤ã³ããã¯ã¹ãã`end` ããå¤§ããã¤ã³ããã¯ã¹ãä½¿ãã¨ã¨ã©ã¼ãçºçãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:203
#, no-wrap
msgid ""
"julia> str[0]\n"
"ERROR: BoundsError: attempt to access String\n"
"  at index [0]\n"
"[...]\n"
"\n"
"julia> str[end+1]\n"
"ERROR: BoundsError: attempt to access String\n"
"  at index [15]\n"
"[...]\n"
msgstr ""
"julia> str[0]\n"
"ERROR: BoundsError: attempt to access String\n"
"  at index [0]\n"
"[...]\n"
"\n"
"julia> str[end+1]\n"
"ERROR: BoundsError: attempt to access String\n"
"  at index [15]\n"
"[...]\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:216
msgid "You can also extract a substring using range indexing:"
msgstr "ç¯å²ã¤ã³ããã¯ã¹ãä½¿ç¨ãã¦é¨åæå­åãæ½åºãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:217
#, no-wrap
msgid ""
"julia> str[4:9]\n"
"\"lo, wo\"\n"
msgstr ""
"julia> str[4:9]\n"
"\"lo, wo\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:223
msgid "Notice that the expressions `str[k]` and `str[k:k]` do not give the same result:"
msgstr "`str[k]` ã¨ `str[k:k]` ã¯åãçµæãä¸ããªããã¨ã«æ³¨æãã¦ãã ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:224
#, no-wrap
msgid ""
"julia> str[6]\n"
"',': ASCII/Unicode U+002c (category Po: Punctuation, other)\n"
"\n"
"julia> str[6:6]\n"
"\",\"\n"
msgstr ""
"julia> str[6]\n"
"',': ASCII/Unicode U+002c (category Po: Punctuation, other)\n"
"\n"
"julia> str[6:6]\n"
"\",\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:234
msgid ""
"The former is a single character value of type `Char`, while the latter is a string value that happens to contain only a single character. "
"In Julia these are very different things."
msgstr "åèã¯`Char`åã®åä¸ã®æå­å¤ã§ãå¾èã¯ 1 æå­ã ããå«ãæå­åå¤ã§ããJulia ã§ã¯ãããã¯å¨ãç°ãªããã®ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:238
msgid ""
"Range indexing makes a copy of the selected part of the original string.  Alternatively, it is possible to create a view into a string using "
"the type [`SubString`](@ref), for example:"
msgstr ""
"ç¯å²ã¤ã³ããã¯ã¹ã«ããéåã®åç§ã¯åã®æå­åã®é¸æé¨åã®ã³ãã¼ãä½æãã¾ãã ã¾ãã¯ãå [`SubString`](@ref) ãä½¿ç¨ãã¦ãæå­åã«å¯¾ãããã¥ã¼"
"ãä½æãããã¨ãã§ãã¾ããä¾ãã°:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:239
#, no-wrap
msgid ""
"julia> str = \"long string\"\n"
"\"long string\"\n"
"\n"
"julia> substr = SubString(str, 1, 4)\n"
"\"long\"\n"
"\n"
"julia> typeof(substr)\n"
"SubString{String}\n"
msgstr ""
"julia> str = \"long string\"\n"
"\"long string\"\n"
"\n"
"julia> substr = SubString(str, 1, 4)\n"
"\"long\"\n"
"\n"
"julia> typeof(substr)\n"
"SubString{String}\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:252
msgid "Several standard functions like [`chop`](@ref), [`chomp`](@ref) or [`strip`](@ref)  return a [`SubString`](@ref)."
msgstr "[`chop`](@ref), [`chomp`](@ref) ã [`strip`](@ref) ã®ãããª ããã¤ãã®æ¨æºçãªé¢æ°ã¯æ»ãå¤ã¨ãã¦ [`SubString`](@ref)ãè¿ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/strings.md:253
#, no-wrap
msgid "Unicode and UTF-8"
msgstr "Unicodeã¨UTF-8"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:258
msgid ""
"Julia fully supports Unicode characters and strings. As [discussed above](@ref man-characters), in character literals, Unicode code points "
"can be represented using Unicode `\\u` and `\\U` escape sequences, as well as all the standard C escape sequences. These can likewise be "
"used to write string literals:"
msgstr ""
"Julia ã¯Unicode æå­ã¨ Unicode æå­åãå®å¨ã«ãµãã¼ããã¦ãã¾ãã[åè¿°](@ref man-characters)ã®ããã«ãæå­ãªãã©ã«ã§ã¯ããã¹ã¦ã®æ¨æº C ã¨ã¹"
"ã±ã¼ã ã·ã¼ã±ã³ã¹ã¨åæ§ã«ãUnicode `\\u` ,`\\U` ã¨ã¹ã±ã¼ã ã·ã¼ã±ã³ã¹ãä½¿ã£ã¦Unicode ã®ç¬¦å·ä½ç½®ãè¡¨ç¾ãããã¨ãã§ãã¾ãããã¹ã¦ã®æ¨æº C ã¨ã¹"
"ã±ã¼ã ã·ã¼ã±ã³ã¹ãä½¿ç¨ãã¦è¡¨ããã¨ãã§ãã¾ãããããã¯æå­åãªãã©ã«ã®æ¸ãè¾¼ã¿ã§ãåæ§ã§ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/strings.md:259 ext/julia/doc/src/manual/strings.md:276 ext/julia/doc/src/manual/strings.md:300
#: ext/julia/doc/src/manual/strings.md:320 ext/julia/doc/src/manual/strings.md:340 ext/julia/doc/src/manual/strings.md:361
#: ext/julia/doc/src/manual/strings.md:378
#, no-wrap
msgid "jldoctest unicodestring"
msgstr "jldoctest unicodestring"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:259
#, no-wrap
msgid ""
"julia> s = \"\\u2200 x \\u2203 y\"\n"
"\"â x â y\"\n"
msgstr ""
"julia> s = \"\\u2200 x \\u2203 y\"\n"
"\"â x â y\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:270
msgid ""
"Whether these Unicode characters are displayed as escapes or shown as special characters depends on your terminal's locale settings and its "
"support for Unicode. String literals are encoded using the UTF-8 encoding. UTF-8 is a variable-width encoding, meaning that not all "
"characters are encoded in the same number of bytes (\"code units\"). In UTF-8, ASCII characters â i.e. those with code points less than 0x80 "
"(128) -- are encoded as they are in ASCII, using a single byte, while code points 0x80 and above are encoded using multiple bytes â up to "
"four per character."
msgstr ""
"ããã Unicode æå­ãã¨ã¹ã±ã¼ãããã¦è¡¨ç¤ºãããããç¹æ®æå­ã¨ãã¦è¡¨ç¤ºããããã¯ãã¿ã¼ããã«ã®ã­ã±ã¼ã«è¨­å®ã¨ Unicode ã¸ã®å¯¾å¿ç¶æ³ã«ãã£ã¦ç°ãª"
"ãã¾ããæå­åãªãã©ã«ã¯ãUTF-8 ã§ã¨ã³ã³ã¼ãããã¾ããUTF-8 ã¯å¯å¤é·ã¨ã³ã³ã¼ãã£ã³ã°ã§ããããã¹ã¦ã®æå­ãåããã¤ãæ°ã§ã¨ã³ã³ã¼ãããããã"
"ã§ã¯ããã¾ãããUTF-8 ã§ã¯ãASCII æå­ (ã³ã¼ã ãã¤ã³ãã 0x80 (128) æªæºã®æå­ã¯ãASCIIã®å ´åã¨åæ§ã«1 ãã¤ãã§ã¨ã³ã³ã¼ãããã¾ããã³ã¼ã ã"
"ã¤ã³ã 0x80 ä»¥ä¸ã¯è¤æ°ã®ãã¤ã(1 å­ãããæå¤§ 4æå­ã¾ã§)ãä½¿ç¨ãã¦ã¨ã³ã³ã¼ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:275
msgid ""
"String indices in Julia refer to code units (= bytes for UTF-8), the fixed-width building blocks that are used to encode arbitrary "
"characters (code points). This means that not every index into a `String` is necessarily a valid index for a character. If you index into a "
"string at such an invalid byte index, an error is thrown:"
msgstr ""
"Juliaã«ãããæå­åã®ã¤ã³ããã¯ã¹ä»ã¯ãç¬¦å·åä½(=UTF-8ã®ãã¤ã)ãåç§ãã¾ããããã¯ãåºå®é·ã®æ§æè¦ç´ ã§ãä»»æã®æå­(ã³ã¼ããã¤ã³ã)ãã¨ã³ã³ã¼"
"ãããã®ã«ä½¿ããã¾ããã¤ã¾ããUTF-8 æå­åã«å¥ããã¹ã¦ã®ãã¤ãã¤ã³ããã¯ã¹ãå¿ãããæå­ã®æå¹ãªã¤ã³ããã¯ã¹ã§ããã¨ã¯éãã¾ããããã®ãããª"
"ç¡å¹ãªãã¤ã ã¤ã³ããã¯ã¹ã§æå­åã«ã¤ã³ããã¯ã¹ãä½æããã¨ãã¨ã©ã¼ãã¹ã­ã¼ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:276
#, no-wrap
msgid ""
"julia> s[1]\n"
"'â': Unicode U+2200 (category Sm: Symbol, math)\n"
"\n"
"julia> s[2]\n"
"ERROR: StringIndexError(\"â x â y\", 2)\n"
"[...]\n"
"\n"
"julia> s[3]\n"
"ERROR: StringIndexError(\"â x â y\", 3)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> s[4]\n"
"' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n"
msgstr ""
"julia> s[1]\n"
"'â': Unicode U+2200 (category Sm: Symbol, math)\n"
"\n"
"julia> s[2]\n"
"ERROR: StringIndexError(\"â x â y\", 2)\n"
"[...]\n"
"\n"
"julia> s[3]\n"
"ERROR: StringIndexError(\"â x â y\", 3)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> s[4]\n"
"' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:296
msgid ""
"In this case, the character `â` is a three-byte character, so the indices 2 and 3 are invalid and the next character's index is 4; this next "
"valid index can be computed by [`nextind(s,1)`](@ref), and the next index after that by `nextind(s,4)` and so on."
msgstr ""
"ãã®å ´åãæå­ `â`ã¯ 3 ãã¤ãæå­ãªã®ã§ãã¤ã³ããã¯ã¹ 2 ã¨ 3 ã¯ç¡å¹ã§ãæ¬¡ã®æå­ã®ã¤ã³ããã¯ã¹ã¯ 4 ã§ããããã¯[`nextind(s,1)`](@ref)ã§è¨ç®ã§"
"ããããã«ãã®æ¬¡ã®æå­ã®ã¤ã³ããã¯ã¹ã¯`nextind(s,4)`ã¨ç¶ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:299
msgid ""
"Since `end` is always the last valid index into a collection, `end-1` references an invalid byte index if the second-to-last character is "
"multibyte."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:300
#, no-wrap
msgid ""
"julia> s[end-1]\n"
"' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n"
"\n"
"julia> s[end-2]\n"
"ERROR: StringIndexError(\"â x â y\", 9)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> s[prevind(s, end, 2)]\n"
"'â': Unicode U+2203 (category Sm: Symbol, math)\n"
msgstr ""
"julia> s[end-1]\n"
"' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n"
"\n"
"julia> s[end-2]\n"
"ERROR: StringIndexError(\"â x â y\", 9)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> s[prevind(s, end, 2)]\n"
"'â': Unicode U+2203 (category Sm: Symbol, math)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:317
msgid ""
"The first case works, because the last character `y` and the space are one-byte characters, whereas `end-2` indexes into the middle of the "
"`â` multibyte representation. The correct way for this case is using `prevind(s, lastindex(s), 2)` or, if you're using that value to index "
"into `s` you can write `s[prevind(s, end, 2)]` and `end` expands to `lastindex(s)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:319
msgid "Extraction of a substring using range indexing also expects valid byte indices or an error is thrown:"
msgstr ""
"é¨åæå­åãåãåºãç¯å²ã¤ã³ããã¯ã¹ã§ããæå¹ãªãã¤ã ã¤ã³ããã¯ã¹ãä¸ãããããã¨ãæ³å®ããã¦ããããããæºããããªãå ´åã¯ã¨ã©ã¼ãã¹ã­ã¼ã"
"ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:320
#, no-wrap
msgid ""
"julia> s[1:1]\n"
"\"â\"\n"
"\n"
"julia> s[1:2]\n"
"ERROR: StringIndexError(\"â x â y\", 2)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> s[1:4]\n"
"\"â \"\n"
msgstr ""
"julia> s[1:1]\n"
"\"â\"\n"
"\n"
"julia> s[1:2]\n"
"ERROR: StringIndexError(\"â x â y\", 2)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> s[1:4]\n"
"\"â \"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:339
#, no-wrap
msgid ""
"Because of variable-length encodings, the number of characters in a string (given by [`length(s)`](@ref))\n"
"is not always the same as the last index. If you iterate through the indices 1 through [`lastindex(s)`](@ref)\n"
"and index into `s`, the sequence of characters returned when errors aren't thrown is the sequence\n"
"of characters comprising the string `s`. Thus we have the identity that `length(s) <= lastindex(s)`,\n"
"since each character in a string must have its own index. The following is an inefficient and\n"
"verbose way to iterate through the characters of `s`:\n"
msgstr ""
"å¯å¤é·ã¨ã³ã³ã¼ãã£ã³ã°ã®ãããæå­ååã®æå­æ° ([`length(s)`](@ref))ã¯ãæå¾ã®ã¤ã³ããã¯ã¹ã¨å¸¸ã«åãã§ããã¨ã¯éãã¾ãããã¤ã³ããã¯ã¹ 1 ãã [`lastindex(s)`] (@ref) ã«è³ãã¾ã§ãæå­å`s`ã¸ã®ã¤ã³ããã¯ã¹å¼ã³åºããç¹°ãè¿ãã¨\n"
"é©æ­£ãªã¤ã³ããã¯ã¹ã§ã¯ã`s` ãæ§æããä¸é£ã®æå­ãè¿ãããããä»¥å¤ã§ã¯ã¨ã©ã¼ãæãããã¾ãããããã£ã¦ãæå­ååã®ããããã®æå­ã¯åºæã®ã¤ã³ããã¯ã¹ãæã£ã¦ããããããã¤ãã¤ã³ããã¯ã¹ã¨æå­åã®åæå­ãåä¸è¦ããå¯¾å¿é¢ä¿ `length(s)<= lastindex(s)`ãå¾ãããããã§ããä»¥ä¸ã¯éå¹çãã¤åé·ã§ã¯ããã¾ãããæå­å `s` ã«å¯¾ããåå¾©ãè¡ãæ¹æ³ã§ã:\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:340
#, no-wrap
msgid ""
"julia> for i = firstindex(s):lastindex(s)\n"
"           try\n"
"               println(s[i])\n"
"           catch\n"
"               # ignore the index error\n"
"           end\n"
"       end\n"
"â\n"
"\n"
"x\n"
"\n"
"â\n"
"\n"
"y\n"
msgstr ""
"julia> for i = firstindex(s):lastindex(s)\n"
"           try\n"
"               println(s[i])\n"
"           catch\n"
"               # ignore the index error\n"
"           end\n"
"       end\n"
"â\n"
"\n"
"x\n"
"\n"
"â\n"
"\n"
"y\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:360
msgid ""
"The blank lines actually have spaces on them. Fortunately, the above awkward idiom is unnecessary for iterating through the characters in a "
"string, since you can just use the string as an iterable object, no exception handling required:"
msgstr ""
"ç©ºç½è¡ã«ã¯å®éã«ã¯ç©ºç½æå­ãããã¾ããå¹¸ããªãã¨ã«ãæå­ååã®æå­ãåå¾©å¦çããå ´åã¯ãæå­åãåå¾©å¯è½ãªãã¸ã§ã¯ãã¨ãã¦ä½¿ç¨ã§ããã®ã§ãä¾"
"å¤å¦çã¯å¿è¦ãªããä¸è¨ã®åä»ãªã¤ãã£ãªã ã¯ä¸è¦ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:361
#, no-wrap
msgid ""
"julia> for c in s\n"
"           println(c)\n"
"       end\n"
"â\n"
"\n"
"x\n"
"\n"
"â\n"
"\n"
"y\n"
msgstr ""
"julia> for c in s\n"
"           println(c)\n"
"       end\n"
"â\n"
"\n"
"x\n"
"\n"
"â\n"
"\n"
"y\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:377
msgid ""
"If you need to obtain valid indices for a string, you can use the [`nextind`](@ref) and [`prevind`](@ref) functions to increment/decrement "
"to the next/previous valid index, as mentioned above.  You can also use the [`eachindex`](@ref) function to iterate over the valid character "
"indices:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:378
#, no-wrap
msgid ""
"julia> collect(eachindex(s))\n"
"7-element Array{Int64,1}:\n"
"  1\n"
"  4\n"
"  5\n"
"  6\n"
"  7\n"
" 10\n"
" 11\n"
msgstr ""
"julia> collect(eachindex(s))\n"
"7-element Array{Int64,1}:\n"
"  1\n"
"  4\n"
"  5\n"
"  6\n"
"  7\n"
" 10\n"
" 11\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:393
msgid ""
"To access the raw code units (bytes for UTF-8) of the encoding, you can use the [`codeunit(s,i)`](@ref)  function, where the index `i` runs "
"consecutively from `1` to [`ncodeunits(s)`](@ref).  The [`codeunits(s)`](@ref)  function returns an `AbstractVector{UInt8}` wrapper that "
"lets you access these raw codeunits (bytes) as an array."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:399
msgid ""
"Strings in Julia can contain invalid UTF-8 code unit sequences. This convention allows to treat any byte sequence as a `String`. In such "
"situations a rule is that when parsing a sequence of code units from left to right characters are formed by the longest sequence of 8-bit "
"code units that matches the start of one of the following bit patterns (each `x` can be `0` or `1`):"
msgstr ""
"Julia ã®æå­åã«ã¯ãç¡å¹ãªUTF-8ã³ã¼ãåä½ã·ã¼ã±ã³ã¹ãå«ãããã¨ãã§ãã¾ãããã®ä»çµã¿ã«ãã£ã¦ãä»»æã®ãã¤ã ã·ã¼ã±ã³ã¹ã `String` ã¨ãã¦æ±ã"
"ãã¨ãã§ãã¾ãããã®ãããªç¶æ³ã§ã¯ãå·¦ããå³ã®æå­ã¾ã§ã®ã³ã¼ãåä½ã®ã·ã¼ã±ã³ã¹ãè§£æããå ´åãæå­åã¯ãæ¬¡ã®ããããã®ããã ãã¿ã¼ã³ã®åé ­ã«"
"ä¸è´ããæãé·ã8 ããã ã³ã¼ãåä½ã®ã·ã¼ã±ã³ã¹ãã£ã¦å½¢æããã¾ã (å `x` ã¯ `0` ã¾ãã¯ `1` ã«ãªãã¾ã)ã:"

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/strings.md:406
msgid "`0xxxxxxx`;"
msgstr "`0xxxxxxx`;"

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/strings.md:406
msgid "`110xxxxx` `10xxxxxx`;"
msgstr "`110xxxxx` `10xxxxxx`;"

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/strings.md:406
msgid "`1110xxxx` `10xxxxxx` `10xxxxxx`;"
msgstr "`1110xxxx` `10xxxxxx` `10xxxxxx`;"

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/strings.md:406
msgid "`11110xxx` `10xxxxxx` `10xxxxxx` `10xxxxxx`;"
msgstr "`11110xxx` `10xxxxxx` `10xxxxxx` `10xxxxxx`;"

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/strings.md:406
msgid "`10xxxxxx`;"
msgstr "`10xxxxxx`;"

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/strings.md:406
msgid "`11111xxx`."
msgstr "`11111xxx`."

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:410
msgid ""
"In particular this means that overlong and too-high code unit sequences and prefixes thereof are treated as a single invalid character "
"rather than multiple invalid characters.  This rule may be best explained with an example:"
msgstr ""
"ç¹ã«ãããã¯ãåé·ã ã£ãããå¤ãå¤§ããããã³ã¼ããããã®æ¥é ­è¾ããè¤æ°ã®ä¸æ­£æå­ã§ã¯ãªããåä¸ã®ä¸æ­£æå­ã¨ãã¦æ±ããããã¨ãæå³ãã¾ãã å®ä¾"
"ã§èª¬æããã»ããããçè§£ã§ããã§ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:411
#, no-wrap
msgid ""
"julia> s = \"\\xc0\\xa0\\xe2\\x88\\xe2|\"\n"
"\"\\xc0\\xa0\\xe2\\x88\\xe2|\"\n"
"\n"
"julia> foreach(display, s)\n"
"'\\xc0\\xa0': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)\n"
"'\\xe2\\x88': Malformed UTF-8 (category Ma: Malformed, bad data)\n"
"'\\xe2': Malformed UTF-8 (category Ma: Malformed, bad data)\n"
"'|': ASCII/Unicode U+007c (category Sm: Symbol, math)\n"
"\n"
"julia> isvalid.(collect(s))\n"
"4-element BitArray{1}:\n"
" 0\n"
" 0\n"
" 0\n"
" 1\n"
"\n"
"julia> s2 = \"\\xf7\\xbf\\xbf\\xbf\"\n"
"\"\\U1fffff\"\n"
"\n"
"julia> foreach(display, s2)\n"
"'\\U1fffff': Unicode U+1fffff (category In: Invalid, too high)\n"
msgstr ""
"julia> s = \"\\xc0\\xa0\\xe2\\x88\\xe2|\"\n"
"\"\\xc0\\xa0\\xe2\\x88\\xe2|\"\n"
"\n"
"julia> foreach(display, s)\n"
"'\\xc0\\xa0': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)\n"
"'\\xe2\\x88': Malformed UTF-8 (category Ma: Malformed, bad data)\n"
"'\\xe2': Malformed UTF-8 (category Ma: Malformed, bad data)\n"
"'|': ASCII/Unicode U+007c (category Sm: Symbol, math)\n"
"\n"
"julia> isvalid.(collect(s))\n"
"4-element BitArray{1}:\n"
" 0\n"
" 0\n"
" 0\n"
" 1\n"
"\n"
"julia> s2 = \"\\xf7\\xbf\\xbf\\xbf\"\n"
"\"\\U1fffff\"\n"
"\n"
"julia> foreach(display, s2)\n"
"'\\U1fffff': Unicode U+1fffff (category In: Invalid, too high)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:442
msgid ""
"We can see that the first two code units in the string `s` form an overlong encoding of space character. It is invalid, but is accepted in a "
"string as a single character.  The next two code units form a valid start of a three-byte UTF-8 sequence. However, the fifth code unit `"
"\\xe2` is not its valid continuation. Therefore code units 3 and 4 are also interpreted as malformed characters in this string. Similarly "
"code unit 5 forms a malformed character because `|` is not a valid continuation to it. Finally the string `s2` contains one too high code "
"point."
msgstr ""
"æå­å`s`ã®ã¯ããã®ï¼ã¤ã®ç¬¦å·åä½ã¯ãç©ºç½æå­ã®åé·ãªã¨ã³ã³ã¼ãã£ã³ã°ã§ããããã¯ç¡å¹ãªãã®ã§ãããæå­åã®ä¸­ã§ã¯1ãã¤ãæå­ã¨ãã¦åãå¥ãã"
"ãã¾ãããã®æ¬¡ï¼ï¼ï¼ï¼çªã)ã®ç¬¦å·åä½ã¯ã3ãã¤ãã®UTFF-8æå­ã®å§ã¾ãã¨ãã¦æå¹ã§ããã5ã¤ãã®ç¬¦å·åä½`\\xe2`ã¯ãã®ç¶ãã¨ãã¦ç¡å¹ã§ãããã"
"ãã£ã¦ï¼ï¼ï¼çªãã®ç¬¦å·åä½ãæå­åã®ä¸é¨ã¨ãã¦ä¸æ­£ãªå½¢å¼ã¨ãããã¨ã«ãªãã¾ãã5ã¤ãã®ç¬¦å·åä½ã®ç¶ãã«`|`ããããã¨ã¯ãªãæå¹ã§ãªãã®ã§ã5çªç®"
"ã®ç¬¦å·åä½ãä¸æ­£ãªå½¢å¼ã§ããæå¾ã«ãæå­å`s2`ã¯ãç¬¦å·ä½ç½®ãå¤§ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:450
msgid ""
"Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages.  For example, the [LegacyStrings.jl]"
"(https://github.com/JuliaStrings/LegacyStrings.jl) package implements `UTF16String` and `UTF32String` types. Additional discussion of other "
"encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 "
"encoding issues, see the section below on [byte array literals](@ref man-byte-array-literals).  The [`transcode`](@ref) function is provided "
"to convert data between the various UTF-xx encodings, primarily for working with external data and libraries."
msgstr ""
"Julia ã¯ããã©ã«ãã§ UTF-8 ã¨ã³ã³ã¼ãã£ã³ã°ãä½¿ç¨ãã¾ãããããã±ã¼ã¸ãå ãã¦ããã®ä»ã«æ°ããã¨ã³ã³ã¼ãã£ã³ã°ã®ãµãã¼ããè¿½å ãããã¨ãã§ãã¾"
"ãã ãã¨ãã°ã[`LegacyStrings.jl`](https://github.com/JuliaStrings/LegacyStrings.jl)ããã±ã¼ã¸ã¯`UTF16String` ã¨ `UTF32String` åãå®è£ãã¾"
"ããä»ã®ã¨ã³ã³ã¼ãã£ã³ã°ã¨ãã®ãµãã¼ãã®å®è£æ¹æ³ã«ã¤ãã¦ã¯ãå½é¢ã¯ãã®ãã­ã¥ã¡ã³ãã§ã¯èª¬æãã¾ãããUTF-8 ã¨ã³ã³ã¼ãã£ã³ã°ã®åé¡ã®è©³ç´°ã«ã¤ã"
"ã¦ã¯ãä»¥ä¸ã®[ãã¤ãéåãªãã©ã«](@ref man-byte-array-literals)ã®ã»ã¯ã·ã§ã³ãåç§ãã¦ãã ããã [`transcode`](@ref)é¢æ°ã¯ãä¸»ã«å¤é¨ãã¼ã¿ãã©"
"ã¤ãã©ãªãæä½ããããã«ããã¾ãã¾ãªUTF-xxã¨ã³ã³ã¼ãã£ã³ã°éã§ãã¼ã¿ãå¤æããããã«æä¾ããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/strings.md:451
#, no-wrap
msgid "[Concatenation](@id man-concatenation)"
msgstr "[é£çµ](@id man-concatenation)"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:454
msgid "One of the most common and useful string operations is concatenation:"
msgstr "æãä¸è¬çã§æç¨ãªæå­åæä½ã® 1 ã¤ã¯ãé£çµã§ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/strings.md:455 ext/julia/doc/src/manual/strings.md:496 ext/julia/doc/src/manual/strings.md:524
#, no-wrap
msgid "jldoctest stringconcat"
msgstr "jldoctest stringconcat"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:455
#, no-wrap
msgid ""
"julia> greet = \"Hello\"\n"
"\"Hello\"\n"
"\n"
"julia> whom = \"world\"\n"
"\"world\"\n"
"\n"
"julia> string(greet, \", \", whom, \".\\n\")\n"
"\"Hello, world.\\n\"\n"
msgstr ""
"julia> greet = \"Hello\"\n"
"\"Hello\"\n"
"\n"
"julia> whom = \"world\"\n"
"\"world\"\n"
"\n"
"julia> string(greet, \", \", whom, \".\\n\")\n"
"\"Hello, world.\\n\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:470
msgid ""
"It's important to be aware of potentially dangerous situations such as concatenation of invalid UTF-8 strings.  The resulting string may "
"contain different characters than the input strings, and its number of characters may be lower than sum of numbers of characters of the "
"concatenated strings, e.g.:"
msgstr ""
"ç¡å¹ãª UTF-8 æå­åãé£çµããå ´åãªã©èµ·ããããæ½å¨çãªå±éºã«æ³¨æãã¯ãããã¨ã¯éè¦ã§ãã é£çµå¾ã®æå­åã«ã¯ãå¥åæå­åã¨ã¯ç°ãªãæå­ãå«ã¾"
"ãã¦ããå ´åãããããã®æå­æ°ã¯é£çµæå­åã®æå­æ°ã®åè¨ãããå°ãããªãå ´åãããã¾ããä¾ãã°:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:471
#, no-wrap
msgid ""
"julia> a, b = \"\\xe2\\x88\", \"\\x80\"\n"
"(\"\\xe2\\x88\", \"\\x80\")\n"
"\n"
"julia> c = a*b\n"
"\"â\"\n"
"\n"
"julia> collect.([a, b, c])\n"
"3-element Array{Array{Char,1},1}:\n"
" ['\\xe2\\x88']\n"
" ['\\x80']\n"
" ['â']\n"
"\n"
"julia> length.([a, b, c])\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 1\n"
" 1\n"
msgstr ""
"julia> a, b = \"\\xe2\\x88\", \"\\x80\"\n"
"(\"\\xe2\\x88\", \"\\x80\")\n"
"\n"
"julia> c = a*b\n"
"\"â\"\n"
"\n"
"julia> collect.([a, b, c])\n"
"3-element Array{Array{Char,1},1}:\n"
" ['\\xe2\\x88']\n"
" ['\\x80']\n"
" ['â']\n"
"\n"
"julia> length.([a, b, c])\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 1\n"
" 1\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:493
msgid ""
"This situation can happen only for invalid UTF-8 strings. For valid UTF-8 strings concatenation preserves all characters in strings and "
"additivity of string lengths."
msgstr ""
"ãã®ãããªãã¨ãèµ·ããã®ã¯ãç¡å¹ãª UTF-8 æå­åã®ã¨ãã ãã§ããæå¹ãª UTF-8 æå­åã®é£çµã§ã¯ãæå­ååã®ãã¹ã¦ã®æå­ããæå­åã®æå­æ°ã®åè¨"
"ãä¿æããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:495
msgid "Julia also provides [`*`](@ref) for string concatenation:"
msgstr "ã¸ã¥ãªã¢ã¯ãæå­åé£çµã« [`*`](@ref) ãä½¿ããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:496
#, no-wrap
msgid ""
"julia> greet * \", \" * whom * \".\\n\"\n"
"\"Hello, world.\\n\"\n"
msgstr ""
"julia> greet * \", \" * whom * \".\\n\"\n"
"\"Hello, world.\\n\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:503
msgid ""
"While `*` may seem like a surprising choice to users of languages that provide `+` for string concatenation, this use of `*` has precedent "
"in mathematics, particularly in abstract algebra."
msgstr ""
"æå­åé£çµã« `+` ãä½¿ãè¨èªã®ã¦ã¼ã¶ã¼ã«ã¨ã£ã¦ãããã¯é©ãã¹ãé¸æè¢ã®ããã«æããããããã¾ãããããã® `*` ã®ä½¿ç¨ã¯ãç¹ã«æ½è±¡ä»£æ°ã§ã®åä¾ã"
"ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:511
msgid ""
"In mathematics, `+` usually denotes a *commutative* operation, where the order of the operands does not matter. An example of this is matrix "
"addition, where `A + B == B + A` for any matrices `A` and `B` that have the same shape. In contrast, `*` typically denotes a "
"*noncommutative* operation, where the order of the operands *does* matter. An example of this is matrix multiplication, where in general `A "
"* B != B * A`. As with matrix multiplication, string concatenation is noncommutative: `greet * whom != whom * greet`. As such, `*` is a more "
"natural choice for an infix string concatenation operator, consistent with common mathematical use."
msgstr ""
"æ°å­¦ã§ã¯ã`+` ã¯éå¸¸ã*å¯æ*æ¼ç®ãç¤ºããããã§ã¯ããªãã©ã³ãé åºã¯é¢ä¿ããã¾ãããããã«å¯¾å¿ããä¾ã¯ãè¡åã®è¶³ãç®ã§ãåãå½¢ç¶ãæã¤è¡å `A` "
"ã¨ `B`ã«å¯¾ãã¦ `A + B = B + A` ãæãç«ã¡ã¾ããå¯¾ç§çã«ã`*` ã¯éå¸¸ã*éå¯æ*æ¼ç®ãç¤ºããããã§ã¯ããªãã©ã³ãã®é åºãéè¦ã§ããããã«å¯¾å¿ãã"
"ä¾ã¯è¡åã®ä¹ç®ã§ãä¸è¬çã«ã¯ `A * B != B * A` ã§ããè¡åä¹ç®ã¨åæ§ã«ãæå­åé£çµã¯éå¯æã§ã: `æ¨æ¶ * èª°ã *èª°ã * æ¨æ¶ãã`ãã®ããã`*` "
"ã¯ãä¸è¬çãªæ°å­¦ã§ã®ä½¿ç¨ä¾ã¨ãä¸è´ããæå­åé£çµã®äºé æ¼ç®å­ã¨ãã¦ãããèªç¶ãªé¸æã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:517
msgid ""
"More precisely, the set of all finite-length strings *S* together with the string concatenation operator `*` forms a [free monoid](https://"
"en.wikipedia.org/wiki/Free_monoid) (*S*, `*`). The identity element of this set is the empty string, `\"\"`. Whenever a free monoid is not "
"commutative, the operation is typically represented as `\\cdot`, `*`, or a similar symbol, rather than `+`, which as stated usually implies "
"commutativity."
msgstr ""
"ããæ­£ç¢ºã«ã¯ããã¹ã¦ã®æéé·æå­å *S* ã¨æå­åé£çµæ¼ç®å­ `*` ã¯ [èªç±ã¢ãã¤ã](https://en.wikipedia.org/wiki/Free_monoid)(*S*ã`*`)ãå½¢æã"
"ã¾ãããã®ã»ããã® åä½åã¯ç©ºæå­å `\"\"` ã§ããèªç±ã¢ãã¤ããéå¯æã®ã¨ãã¯ãã¤ã§ããæ¼ç®å­ã®è¡¨è¨ã«ã¯`\\cdot`ã`*`ãã¾ãã¯ãããã¨åæ§ã«é"
"å¯æã®æ¼ç®ã«å¯¾å¿ããè¨å·ãç¨ãã¾ããéå¸¸ã¯å¯æã§ãã`+`ã¯ä½¿ããã¾ããã"

#. type: Title ##
#: ext/julia/doc/src/manual/strings.md:518
#, no-wrap
msgid "[Interpolation](@id string-interpolation)"
msgstr "[æå­åå±é](@id string-interpolation)"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:523
msgid ""
"Constructing strings using concatenation can become a bit cumbersome, however. To reduce the need for these verbose calls to [`string`]"
"(@ref) or repeated multiplications, Julia allows interpolation into string literals using `$`, as in Perl:"
msgstr ""
"é£çµãä½¿ç¨ãã¦æå­åãæ§ç¯ãããã¨ã¯å°ãé¢åãªå ´åãããã¾ãã[`string`](@ref)é¢æ°ã®åé·ãªå¼ã³åºãããä¹ç®ãä½åº¦ãè¡ããã¨ãå¿è¦ã«ãªãæ©ä¼ã"
"æ¸ãããããJulia ã¯ Perl ã®ããã« `$` ãä½¿ç¨ãã¦æå­åãªãã©ã«ã®å±éãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:524
#, no-wrap
msgid ""
"julia> \"$greet, $whom.\\n\"\n"
"\"Hello, world.\\n\"\n"
msgstr ""
"julia> \"$greet, $whom.\\n\"\n"
"\"Hello, world.\\n\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:531
msgid ""
"This is more readable and convenient and equivalent to the above string concatenation -- the system rewrites this apparent single string "
"literal into the call `string(greet, \", \", whom, \".\\n\")`."
msgstr ""
"ããã¯ãèª­ã¿ãããä¾¿å©ã§ãä¸è¨ã®æå­åé£çµã¨ç­ä¾¡ã§ããã·ã¹ãã ã¯ãã®è¦ããä¸åä¸ãªæå­åãªãã©ã«ã `string(greet, \",\",whom, \"\\n\")` ã®å¼"
"ã³åºãã«æ¸ãæãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:534
msgid ""
"The shortest complete expression after the `$` is taken as the expression whose value is to be interpolated into the string. Thus, you can "
"interpolate any expression into a string using parentheses:"
msgstr "`$` ã«ç¶ãæç­ã®å®å¨ãªå¼ããå¤ãæå­åã«å±éããå¯¾è±¡ã«ãªãã¾ãããã£ããä½¿ç¨ããã°ä»»æã®å¼ãæå­åå±éã®å¯¾è±¡ã«ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:535
#, no-wrap
msgid ""
"julia> \"1 + 2 = $(1 + 2)\"\n"
"\"1 + 2 = 3\"\n"
msgstr ""
"julia> \"1 + 2 = $(1 + 2)\"\n"
"\"1 + 2 = 3\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:543
msgid ""
"Both concatenation and string interpolation call [`string`](@ref) to convert objects into string form. However, `string` actually just "
"returns the output of [`print`](@ref), so new types should add methods to [`print`](@ref) or [`show`](@ref) instead of `string`."
msgstr ""
"é£çµã¨æå­åå±éã¯ããªãã¸ã§ã¯ããæå­åå½¢å¼ã«å¤æããããã«[`string`](@ref)ãå¼ã³åºãã¾ãã`string` ã¯åã« [`print`](@ref ) ã®åºåãè¿ãã ã"
"ã§ãããæ°ããåãå®ç¾©ããã¨ãã«ã¯ã`string` ã§ã¯ãªãã[`print`](@ref ) ã [`show`](@ref )ã«ã¡ã½ãããè¿½å ããªããã°ãªãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:546
msgid "Most non-`AbstractString` objects are converted to strings closely corresponding to how they are entered as literal expressions:"
msgstr ""
"`AbstractString` ã§ã¯ãªããªãã¸ã§ã¯ãã¯ãå¤§ä½ã®å ´å ãã®ãªãã¸ã§ã¯ãããªãã©ã«å¼ã¨ãã¦å¥åãããã¨ãã®æ¸ãæ¹ã«è¿ãæå­åã«å¤æããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:547
#, no-wrap
msgid ""
"julia> v = [1,2,3]\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"julia> \"v: $v\"\n"
"\"v: [1, 2, 3]\"\n"
msgstr ""
"julia> v = [1,2,3]\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"julia> \"v: $v\"\n"
"\"v: [1, 2, 3]\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:560
msgid ""
"[`string`](@ref) is the identity for `AbstractString` and `AbstractChar` values, so these are interpolated into strings as themselves, "
"unquoted and unescaped:"
msgstr ""
"[`string`](@ref) ã¯ `AbstractString` ããã³ `AbstractChar` ã«å¯¾ãã¦ã¯ãæç­ååçã«åãã®ã§ãå¼ç¨ç¬¦ãåãå»ããã¨ã¹ã±ã¼ããå¦çãããæå­åã«"
"å±éããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:561
#, no-wrap
msgid ""
"julia> c = 'x'\n"
"'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n"
"\n"
"julia> \"hi, $c\"\n"
"\"hi, x\"\n"
msgstr ""
"julia> c = 'x'\n"
"'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n"
"\n"
"julia> \"hi, $c\"\n"
"\"hi, x\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:570
msgid "To include a literal `$` in a string literal, escape it with a backslash:"
msgstr "æå­åãªãã©ã«ã« `$` ãå«ããã«ã¯ãããã¯ã¹ã©ãã·ã¥ã§ã¨ã¹ã±ã¼ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:571
#, no-wrap
msgid ""
"julia> print(\"I have \\$100 in my account.\\n\")\n"
"I have $100 in my account.\n"
msgstr ""
"julia> print(\"I have \\$100 in my account.\\n\")\n"
"I have $100 in my account.\n"

#. type: Title ##
#: ext/julia/doc/src/manual/strings.md:576
#, no-wrap
msgid "Triple-Quoted String Literals"
msgstr "ä¸éå¼ç¨ç¬¦æå­åãªãã©ã«"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:580
msgid ""
"When strings are created using triple-quotes (`\"\"\"...\"\"\"`) they have some special behavior that can be useful for creating longer "
"blocks of text."
msgstr "æå­åãä¸éå¼ç¨ç¬¦ (`\"\"\"...\"\"\"`) ãä½¿ç¨ãã¦ä½æããã¨ãé·ããã­ã¹ã ãã­ãã¯ãä½æããã®ã«å½¹ç«ã¤ç¹æ®ãªæåããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:583
msgid ""
"First, triple-quoted strings are also dedented to the level of the least-indented line.  This is useful for defining strings within code "
"that is indented. For example:"
msgstr ""
"ã¾ããä¸éå¼ç¨ç¬¦ã§å²ã¾ããæå­åããæãã¤ã³ãã³ãã®å°ãªãè¡ã¾ã§ããã³ãããã¾ãã ããã¯ãã¤ã³ãã³ããããã³ã¼ãåã§æå­åãå®ç¾©ããå ´åã«ä¾¿"
"å©ã§ããä¾ãã°ï¼"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:584
#, no-wrap
msgid ""
"julia> str = \"\"\"\n"
"           Hello,\n"
"           world.\n"
"         \"\"\"\n"
"\"  Hello,\\n  world.\\n\"\n"
msgstr ""
"julia> str = \"\"\"\n"
"           Hello,\n"
"           world.\n"
"         \"\"\"\n"
"\"  Hello,\\n  world.\\n\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:593
msgid "In this case the final (empty) line before the closing `\"\"\"` sets the indentation level."
msgstr "ãã®å ´åãæå­åçµäºæã® `\"\"\"` ã®æåã®(ç©º)è¡ãåºæºã¤ã³ãã³ãã¬ãã«ã¨ãã¦è¨­å®ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:600
msgid ""
"The dedentation level is determined as the longest common starting sequence of spaces or tabs in all lines, excluding the line following the "
"opening `\"\"\"` and lines containing only spaces or tabs (the line containing the closing `\"\"\"` is always included).  Then for all "
"lines, excluding the text following the opening `\"\"\"`, the common starting sequence is removed (including lines containing only spaces "
"and tabs if they start with this sequence), e.g.:"
msgstr ""
"ããã³ãã®ã¬ãã«ã¯ãæå­åãªãã©ã«ä¸­ã®å¨è¡ãå±éã«æã¤ã¹ãã¼ã¹ãã¿ãã®æé·å¹ã§æ±ºã¾ãã¾ãããã ããæå­åéå§è¡ã`\"\"\"` ã®å¾ãã¹ãã¼ã¹ã¾ãã¯"
"ã¿ãããæããªãå ´åãæå­åéå§è¡ãé¤ããå¨ã¦ã®è¡(ã¡ãªã¿ã«ãæå­åçµäºã®`\"\"\"`ãå«ãè¡ã¯å¸¸ã«å«ã¾ãã¾ã)ã«ããã¦å¤æ­ããã¾ããããã¦ãæå­"
"åéå§è¡ã® `\"\"\"`ã®å¾ã®ãã­ã¹ããé¤ããã¹ã¦ã®è¡ (ã¹ãã¼ã¹ã¨ã¿ãã®ã¿ãå«ãè¡ãå«ã) ãããä¸è¿°ã®å±éã®éå§ã·ã¼ã±ã³ã¹ãåé¤ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:600
#, no-wrap
msgid ""
"julia> \"\"\"    This\n"
"         is\n"
"           a test\"\"\"\n"
"\"    This\\nis\\n  a test\"\n"
msgstr ""
"julia> \"\"\"    This\n"
"         is\n"
"           a test\"\"\"\n"
"\"    This\\nis\\n  a test\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:609
msgid "Next, if the opening `\"\"\"` is followed by a newline, the newline is stripped from the resulting string."
msgstr "æ¬¡ã«ãæå­åéå§ã® `\"\"\"`ã®ããå¾ã®æ¹è¡ã¯ãçµæã®æå­åããåé¤ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:610
#, no-wrap
msgid "\"\"\"hello\"\"\"\n"
msgstr "\"\"\"hello\"\"\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:615
msgid "is equivalent to"
msgstr "ã¨"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:616
#, no-wrap
msgid ""
"\"\"\"\n"
"hello\"\"\"\n"
msgstr ""
"\"\"\"\n"
"hello\"\"\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:622
msgid "but"
msgstr "ã¯ãç­ä¾¡ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:623
#, no-wrap
msgid ""
"\"\"\"\n"
"\n"
"hello\"\"\"\n"
msgstr ""
"\"\"\"\n"
"\n"
"hello\"\"\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:630
msgid "will contain a literal newline at the beginning."
msgstr "ã¯ãæå­åã®ã¯ããã«æ¹è¡ãªãã©ã«ãå«ã¿ã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:632
msgid "Stripping of the newline is performed after the dedentation. For example:"
msgstr "æ¹è¡åé¤ã¯ãããã³ãã®å¾ã«å®è¡ããã¾ããä¾ãã°:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:633
#, no-wrap
msgid ""
"julia> \"\"\"\n"
"         Hello,\n"
"         world.\"\"\"\n"
"\"Hello,\\nworld.\"\n"
msgstr ""
"julia> \"\"\"\n"
"         Hello,\n"
"         world.\"\"\"\n"
"\"Hello,\\nworld.\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:641
msgid "Trailing whitespace is left unaltered."
msgstr "æ«å°¾ã®ç©ºç½ã¯å¤æ´ããã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:643
msgid "Triple-quoted string literals can contain `\"` symbols without escaping."
msgstr "ä¸éå¼ç¨ç¬¦ã§å²ã¾ããæå­åãªãã©ã«ã«ã¯ãã¨ã¹ã±ã¼ãããã« `\"` è¨å·ãå«ãããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:648
msgid ""
"Note that line breaks in literal strings, whether single- or triple-quoted, result in a newline (LF) character `\\n` in the string, even if "
"your editor uses a carriage return `\\r` (CR) or CRLF combination to end lines. To include a CR in a string, use an explicit escape `\\r`; "
"for example, you can enter the literal string `\"a CRLF line ending\\r\\n\"`."
msgstr ""
"æ³¨æãã¹ããªã®ã¯ãæå­ååã«æ¹è¡ (LF) æå­ `\\n` ã«ãªãã¨ãããã¨ã§ããåä¸å¼ç¨ç¬¦ã¨ä¸ éå¼ç¨ç¬¦ã®ã©ã¡ããä½¿ç¨ããå ´åã§ããã¨ãã£ã¿ã¼ãæ¹è¡ `"
"\\r` (CR) ãã CRLF ãä½¿ç¨ãã¦è¡ãçµäºããå ´åã§ãããã®åä½ã¯å¤ããã¾ãããCR ãæå­åã«å«ããã«ã¯ãæç¤ºçãªã¨ã¹ã±ã¼ã `\\r` ãä½¿ç¨ãã¾ãã"
"ãã¨ãã°ããªãã©ã«æå­å `\"CRLF è¡æ«\\r\\n\"`ã¨ãããããªæå­åãªãã©ã«ãå¥åã§ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/strings.md:649
#, no-wrap
msgid "Common Operations"
msgstr "ããããæå­åæä½"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:652
msgid "You can lexicographically compare strings using the standard comparison operators:"
msgstr "æå­åãè¾æ¸çã«æ¯è¼ããã«ã¯ãæ¨æºã®æ¯è¼æ¼ç®å­ãä½¿ç¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:653
#, no-wrap
msgid ""
"julia> \"abracadabra\" < \"xylophone\"\n"
"true\n"
"\n"
"julia> \"abracadabra\" == \"xylophone\"\n"
"false\n"
"\n"
"julia> \"Hello, world.\" != \"Goodbye, world.\"\n"
"true\n"
"\n"
"julia> \"1 + 2 = 3\" == \"1 + 2 = $(1 + 2)\"\n"
"true\n"
msgstr ""
"julia> \"abracadabra\" < \"xylophone\"\n"
"true\n"
"\n"
"julia> \"abracadabra\" == \"xylophone\"\n"
"false\n"
"\n"
"julia> \"Hello, world.\" != \"Goodbye, world.\"\n"
"true\n"
"\n"
"julia> \"1 + 2 = 3\" == \"1 + 2 = $(1 + 2)\"\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:669
msgid "You can search for the index of a particular character using the [`findfirst`](@ref) and [`findlast`](@ref) functions:"
msgstr "ç¹å®ã®æå­ã®ã¤ã³ããã¯ã¹ãæ¤ç´¢ããã¨ãã«ã¯ã[`findfirst`](@ref)ããã³[`findlast`](@ref)é¢æ°ãä½¿ç¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:670
#, no-wrap
msgid ""
"julia> findfirst(isequal('o'), \"xylophone\")\n"
"4\n"
"\n"
"julia> findlast(isequal('o'), \"xylophone\")\n"
"7\n"
"\n"
"julia> findfirst(isequal('z'), \"xylophone\")\n"
msgstr ""
"julia> findfirst(isequal('o'), \"xylophone\")\n"
"4\n"
"\n"
"julia> findlast(isequal('o'), \"xylophone\")\n"
"7\n"
"\n"
"julia> findfirst(isequal('z'), \"xylophone\")\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:682
msgid "You can start the search for a character at a given offset by using the functions [`findnext`](@ref) and [`findprev`](@ref):"
msgstr "ç¹å®ã®ãªãã»ããã§æå­ã®æ¤ç´¢ãéå§ããã«ã¯ãé¢æ° [`findnext`](@ref)ã¨[`findprev`](@ref)ãä½¿ç¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:683
#, no-wrap
msgid ""
"julia> findnext(isequal('o'), \"xylophone\", 1)\n"
"4\n"
"\n"
"julia> findnext(isequal('o'), \"xylophone\", 5)\n"
"7\n"
"\n"
"julia> findprev(isequal('o'), \"xylophone\", 5)\n"
"4\n"
"\n"
"julia> findnext(isequal('o'), \"xylophone\", 8)\n"
msgstr ""
"julia> findnext(isequal('o'), \"xylophone\", 1)\n"
"4\n"
"\n"
"julia> findnext(isequal('o'), \"xylophone\", 5)\n"
"7\n"
"\n"
"julia> findprev(isequal('o'), \"xylophone\", 5)\n"
"4\n"
"\n"
"julia> findnext(isequal('o'), \"xylophone\", 8)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:697
msgid "You can use the [`occursin`](@ref) function to check if a substring is found within a string:"
msgstr "æå­ååä¸­ã«ç¹å®ã®é¨åæå­åã®ãããã©ããç¢ºèªããã«ã¯ã[`occursin`](@ref) é¢æ°ãä½¿ç¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:698
#, no-wrap
msgid ""
"julia> occursin(\"world\", \"Hello, world.\")\n"
"true\n"
"\n"
"julia> occursin(\"o\", \"Xylophon\")\n"
"true\n"
"\n"
"julia> occursin(\"a\", \"Xylophon\")\n"
"false\n"
"\n"
"julia> occursin('o', \"Xylophon\")\n"
"true\n"
msgstr ""
"julia> occursin(\"world\", \"Hello, world.\")\n"
"true\n"
"\n"
"julia> occursin(\"o\", \"Xylophon\")\n"
"true\n"
"\n"
"julia> occursin(\"a\", \"Xylophon\")\n"
"false\n"
"\n"
"julia> occursin('o', \"Xylophon\")\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:713
msgid "The last example shows that [`occursin`](@ref) can also look for a character literal."
msgstr "æå¾ã®ä¾ã¯ã[`occursin`](@ref)ãæå­ãªãã©ã«ãæ¢ããã¨ãã§ãããã¨ããä¾ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:715
msgid "Two other handy string functions are [`repeat`](@ref) and [`join`](@ref):"
msgstr "[`repeat`](@ref)ã¨[`join`](@ref)ã¯ã¾ãå¥ã®ä¾¿å©ãªæå­åé¢æ°ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:716
#, no-wrap
msgid ""
"julia> repeat(\".:Z:.\", 10)\n"
"\".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.\"\n"
"\n"
"julia> join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\n"
"\"apples, bananas and pineapples\"\n"
msgstr ""
"julia> repeat(\".:Z:.\", 10)\n"
"\".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.\"\n"
"\n"
"julia> join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\n"
"\"apples, bananas and pineapples\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:725
msgid "Some other useful functions include:"
msgstr "ãã®ä»ã®ä¾¿å©ãªæ©è½ã«ã¯ãæ¬¡ã®ãããªãã®ãããã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:735
msgid ""
"[`firstindex(str)`](@ref) gives the minimal (byte) index that can be used to index into `str` (always 1 for strings, not necessarily true "
"for other containers)."
msgstr ""
"[`firstindex(str)`](@ref) ã¯ã`str` ã®æå° (ãã¤ã) ã¤ã³ããã¯ã¹ãå¾ããã¾ã (æå­åã®å ´åã¯å¸¸ã« 1 ã§ãããä»ã®ã³ã³ããã§ã¯å¿ãããå½ã¦ã¯ã¾ã"
"ã¾ãã)ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:735
msgid "[`lastindex(str)`](@ref) gives the maximal (byte) index that can be used to index into `str`."
msgstr "[`lastindex(str)`](@ref) ã¯`str` ã®æå¤§ã®(ãã¤ã)ã¤ã³ããã¯ã¹ãå¾ããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:735
msgid "[`length(str)`](@ref) the number of characters in `str`."
msgstr "[`length(str)`](@ref) `str` ã®æå­æ°ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:735
msgid "[`length(str, i, j)`](@ref) the number of valid character indices in `str` from `i` to `j`."
msgstr "[`length(str, i, j)`](@ref) ã¯ `str` ã®ã¤ã³ããã¯ã¹ `i` ãã `j`ã¾ã§ã®éã«ãããæå¹ãªæå­ã¤ã³ããã¯ã¹ã®æ°ãå¾ããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:735
msgid "[`ncodeunits(str)`](@ref) number of [code units](https://en.wikipedia.org/wiki/Character_encoding#Terminology) in a string."
msgstr "[`ncodeunits(str)`](@ref) æå­åä¸­ã®[ç¬¦å·åä½](https://en.wikipedia.org/wiki/Character_encoding#Terminology)ã®æ° ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:735
msgid "[`codeunit(str, i)`](@ref) gives the code unit value in the string `str` at index `i`."
msgstr "[`codeunit(str, i)`](@ref) ã¯ `str` ã®ã¤ã³ããã¯ã¹ `i` ã®ç¬¦å·åä½ã®å¤ãå¾ããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:735
msgid "[`thisind(str, i)`](@ref) given an arbitrary index into a string find the first index of the character into which the index points."
msgstr ""
"[`thisind(str, i)`](@ref) ã¯ ä»»æã®ãã¤ãã¤ã³ããã¯ã¹ `i` ã«å¯¾ãã¦ããã®ã¤ã³ããã¯ã¹ãæããã¤ããã¼ã¿ãå±ããæå­ã®æåã®ã¤ã³ããã¯ã¹ãå¾ã"
"ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:735
msgid "[`nextind(str, i, n=1)`](@ref) find the start of the `n`th character starting after index `i`."
msgstr "[`nextind(str, i, n=1)`](@ref) ã§ã¤ã³ããã¯ã¹`i` ããå¾ãã«æ°ãã¦ã`n`åãã®æå­ã®æåã®ã¤ã³ããã¯ã¹ãå¾ããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:735
msgid "[`prevind(str, i, n=1)`](@ref) find the start of the `n`th character starting before index `i`."
msgstr "[`prevind(str, i, n=1)`](@ref) ã§ã¤ã³ããã¯ã¹`i` ããåã«æ°ãã¦ã`n`åãã®æå­ã®æåã®ã¤ã³ããã¯ã¹ãå¾ããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/strings.md:736
#, no-wrap
msgid "[Non-Standard String Literals](@id non-standard-string-literals)"
msgstr "[éæ¨æºæå­åãªãã©ã«](@id non-standard-string-literals)"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:745
msgid ""
"There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not "
"quite what is needed. For these kinds of situations, Julia provides [non-standard string literals](@ref). A non-standard string literal "
"looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and doesn't behave quite like a normal "
"string literal.  Regular expressions, byte array literals and version number literals, as described below, are some examples of non-standard "
"string literals. Other examples are given in the [Metaprogramming](@ref) section."
msgstr ""
"æå­åãä½æããããä½¿ç¨ããããã©ããæ¨æºçãªæå­åæ§æã®æ¯ãèããããã®æå¿è¦ã¨ããã¦ãããã®ã¨ã¯éããã¨ããç¶æ³ãããã§ãããããã®ãã"
"ãªç¶æ³ã®ããã«ãJulia ã¯ [éæ¨æºæå­åãªãã©ã«] (@ref non-standard-string-literals)ãæä¾ãã¦ãã¾ããéæ¨æºã®æå­åãªãã©ã«ã¯ãéå¸¸ã®äºéå¼ç¨"
"ç¬¦ã§å²ã¾ããæå­åãªãã©ã«ã®ããã«è¦ãã¾ããããªãã©ã«ã®åã«è­å¥å­ãã¤ãããã¦ãã¦ãéå¸¸ã®æå­åãªãã©ã«ã¨ã¯ç°ãªãåä½ããã¾ããæ­£è¦è¡¨ç¾ãã"
"ã¤ãéåãªãã©ã«ãããã³ãã¼ã¸ã§ã³çªå·ãªãã©ã«ã¯ãä»¥ä¸ã«èª¬æããããã«ãéæ¨æºæå­åãªãã©ã«ã®ä¾ã§ãããã®ä»ã®ä¾ã¯[ã¡ã¿ãã­ã°ã©ãã³ã°](@ref "
"Metaprogramming)ã»ã¯ã·ã§ã³ã§ç¤ºããã¦ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/strings.md:746
#, no-wrap
msgid "Regular Expressions"
msgstr "æ­£è¦è¡¨ç¾"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:755
msgid ""
"Julia has Perl-compatible regular expressions (regexes), as provided by the [PCRE](http://www.pcre.org/)  library (a description of the "
"syntax can be found [here](http://www.pcre.org/current/doc/html/pcre2syntax.html)). Regular expressions are related to strings in two ways: "
"the obvious connection is that regular expressions are used to find regular patterns in strings; the other connection is that regular "
"expressions are themselves input as strings, which are parsed into a state machine that can be used to efficiently search for patterns in "
"strings. In Julia, regular expressions are input using non-standard string literals prefixed with various identifiers beginning with `r`. "
"The most basic regular expression literal without any options turned on just uses `r\"...\"`:"
msgstr ""
"Julia ã«ã¯ Perl äºæã®æ­£è¦è¡¨ç¾ (æ­£è¦è¡¨ç¾) ãããã[PCRE] (http://www.pcre.org/) ã©ã¤ãã©ãªã«ãã£ã¦æä¾ããã¾ãã(æ§æã«é¢ããèª¬æã¯ã[ãã]"
"(http://www.pcre.org/current/doc/html/pcre2syntax.html)ãåç§)æ­£è¦è¡¨ç¾ã¯ 2 ã¤ã®ç¹ã§æå­åã«é¢é£ãã¦ãã¾ã: æãããªé¢é£ã¯ãæ­£è¦è¡¨ç¾ãæå­åå"
"ã®è¦åçãªãã¿ã¼ã³ãè¦ã¤ããããã«ä½¿ç¨ãããã¨ãããã¨ã§ãããã 1 ã¤ã¯ãæ­£è¦è¡¨ç¾èªä½ãæå­åã¨ãã¦å¥åãããæå­ååã®ãã¿ã¼ã³ãå¹ççã«æ¤ç´¢"
"ããããã®ã¹ãã¼ã ãã·ã³ã¨ãã¦è§£æããããã¨ã§ããJulia ã§ã¯ãæ­£è¦è¡¨ç¾ã¯ `r` ã§å§ã¾ããã¾ãã¾ãªè­å¥å­ãæ¥é ­è¾ã«æã¤éæ¨æºæå­åãªãã©ã«ãä½¿"
"ç¨ãã¦å¥åããã¾ãããªãã·ã§ã³ãæå¹ã«ãã¦ããªãæãåºæ¬çãªæ­£è¦è¡¨ç¾ãªãã©ã«ã¯ã`r\"...\"`ã¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:756
#, no-wrap
msgid ""
"julia> r\"^\\s*(?:#|$)\"\n"
"r\"^\\s*(?:#|$)\"\n"
"\n"
"julia> typeof(ans)\n"
"Regex\n"
msgstr ""
"julia> r\"^\\s*(?:#|$)\"\n"
"r\"^\\s*(?:#|$)\"\n"
"\n"
"julia> typeof(ans)\n"
"Regex\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:765
msgid "To check if a regex matches a string, use [`occursin`](@ref):"
msgstr "æå­åã®ä¸­ã«æ­£è¦è¡¨ç¾ãã¨ããããããã¿ã¼ã³ãããããç¢ºèªããã«ã¯ã[`occursin`](@ref) ãä½¿ç¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:766
#, no-wrap
msgid ""
"julia> occursin(r\"^\\s*(?:#|$)\", \"not a comment\")\n"
"false\n"
"\n"
"julia> occursin(r\"^\\s*(?:#|$)\", \"# a comment\")\n"
"true\n"
msgstr ""
"julia> occursin(r\"^\\s*(?:#|$)\", \"not a comment\")\n"
"false\n"
"\n"
"julia> occursin(r\"^\\s*(?:#|$)\", \"# a comment\")\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:778
msgid ""
"As one can see here, [`occursin`](@ref) simply returns true or false, indicating whether a match for the given regex occurs in the string. "
"Commonly, however, one wants to know not just whether a string matched, but also *how* it matched. To capture this information about a "
"match, use the [`match`](@ref) function instead:"
msgstr ""
"ããã§ãããããã«ã[`occursin`](@ref)ã¯åã« true ã¾ãã¯ false ãè¿ããæå®ãããæ­£è¦è¡¨ç¾ã«ããããããã¿ã¼ã³ãæå­ååã«ãããã©ãããç¤ºãã¾"
"ããããããä¸è¬çã«ã¯ãããããã¦ãããã©ããã ãã§ãªãã*ã©ã®ããã«* ããããã¦ãããã©ãããç¥ãããã§ãããããã®ããã«ã¯ãä»£ããã« "
"[`match`](@ref) é¢æ°ãä½¿ç¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:779
#, no-wrap
msgid ""
"julia> match(r\"^\\s*(?:#|$)\", \"not a comment\")\n"
"\n"
"julia> match(r\"^\\s*(?:#|$)\", \"# a comment\")\n"
"RegexMatch(\"#\")\n"
msgstr ""
"julia> match(r\"^\\s*(?:#|$)\", \"not a comment\")\n"
"\n"
"julia> match(r\"^\\s*(?:#|$)\", \"# a comment\")\n"
"RegexMatch(\"#\")\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:789
msgid ""
"If the regular expression does not match the given string, [`match`](@ref) returns [`nothing`](@ref)  -- a special value that does not print "
"anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:"
msgstr ""
"æ­£è¦è¡¨ç¾ãæå®ãããæå­åã«ãããããªãå ´åã[`match`](@ref) ã¯ [`nothing`](@ref) ãè¿ãã¾ããããã¯å¯¾è©±åãã­ã³ããã§ä½ãåºåããããªãç¹å¥"
"ãªå¤ã§ããåºåããããªãä»¥å¤ã¯ãå®å¨ã«æ­£å¸¸ãªå¤ã§ããããã­ã°ã©ã ã§ãã¹ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:790
#, no-wrap
msgid ""
"m = match(r\"^\\s*(?:#|$)\", line)\n"
"if m === nothing\n"
"    println(\"not a comment\")\n"
"else\n"
"    println(\"blank or comment\")\n"
"end\n"
msgstr ""
"m = match(r\"^\\s*(?:#|$)\", line)\n"
"if m === nothing\n"
"    println(\"not a comment\")\n"
"else\n"
"    println(\"blank or comment\")\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:804
msgid ""
"If a regular expression does match, the value returned by [`match`](@ref) is a `RegexMatch` object. These objects record how the expression "
"matches, including the substring that the pattern matches and any captured substrings, if there are any. This example only captures the "
"portion of the substring that matches, but perhaps we want to capture any non-blank text after the comment character. We could do the "
"following:"
msgstr ""
"æ­£è¦è¡¨ç¾ããããããå ´åã[`match`](@ref) ã«ãã£ã¦è¿ãããå¤ã¯ `RegexMatch`ãªãã¸ã§ã¯ãã§ãããã®ãªãã¸ã§ã¯ãã¯ãã©ã®æ§ã«ãã®å¼ããããããã"
"ãè¨é²ãã¾ããä¾ãã°ããã¿ã¼ã³ã¨ä¸è´ããé¨åæå­åå¨ä½ãããã¿ã¼ã³ãæ§æããè¦ç´ ã¨ä¸è´ãã(ãããä»å¾ãè£è¶³ãã¨ããã¾ã)é¨åæå­åã®æå ±ãªã©"
"ã§ãããã®ä¾ã§ã¯ãé¨åæå­åãè£è¶³ããã ãã§ãããã³ã¡ã³ãã®å¾ã®ãç©ºç½ä»¥å¤ã®æå­åãè£è¶³ãããã§ãããããã®å ´åã¯ãä»¥ä¸ã®ããã«ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:805
#, no-wrap
msgid ""
"julia> m = match(r\"^\\s*(?:#\\s*(.*?)\\s*$|$)\", \"# a comment \")\n"
"RegexMatch(\"# a comment \", 1=\"a comment\")\n"
msgstr ""
"julia> m = match(r\"^\\s*(?:#\\s*(.*?)\\s*$|$)\", \"# a comment \")\n"
"RegexMatch(\"# a comment \", 1=\"a comment\")\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:812
msgid "When calling [`match`](@ref), you have the option to specify an index at which to start the search. For example:"
msgstr "[`match`](@ref)ãå¼ã³åºãã¨ãã«ã¯ãæ¤ç´¢ãéå§ä½ç½®ãã¤ã³ããã¯ã¹ã§æå®ãããã¨ãã§ãã¾ããä¾ãã°:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:813
#, no-wrap
msgid ""
"julia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",1)\n"
"RegexMatch(\"1\")\n"
"\n"
"julia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",6)\n"
"RegexMatch(\"2\")\n"
"\n"
"julia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",11)\n"
"RegexMatch(\"3\")\n"
msgstr ""
"julia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",1)\n"
"RegexMatch(\"1\")\n"
"\n"
"julia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",6)\n"
"RegexMatch(\"2\")\n"
"\n"
"julia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",11)\n"
"RegexMatch(\"3\")\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:825
msgid "You can extract the following info from a `RegexMatch` object:"
msgstr "`RegexMatch` ãªãã¸ã§ã¯ãããã¯ä»¥ä¸ã®æå ±ãæ½åºã§ãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:830
msgid "the entire substring matched: `m.match`"
msgstr "ãããããé¨åæå­åã®å¨ä½: `m.match`"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:830
msgid "the captured substrings as an array of strings: `m.captures`"
msgstr "æå­åã®éåã¨ãã¦è£è¶³ãããé¨åæå­å: `m.captures`"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:830
msgid "the offset at which the whole match begins: `m.offset`"
msgstr "æåã®ãããéå§ä½ç½®ã§ãããªãã»ããã¤ã³ããã¯ã¹: `m.offset`"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:830
msgid "the offsets of the captured substrings as a vector: `m.offsets`"
msgstr "è£è¶³ãããé¨åæå­åããããã«å¯¾ãããªãã»ããå¤ããã¯ãã«ã®å½¢å¼ã§ : `m.offsets`"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:834
msgid ""
"For when a capture doesn't match, instead of a substring, `m.captures` contains `nothing` in that position, and `m.offsets` has a zero "
"offset (recall that indices in Julia are 1-based, so a zero offset into a string is invalid). Here is a pair of somewhat contrived examples:"
msgstr ""
"æ­£è¦è¡¨ç¾ãã¿ã¼ã³ã®åè¦ç´ ã®ãã¡ãé¨åæå­åã¨ãã¦è£è¶³ããããã®ããªãå ´åããã®è£è¶³ãããªãã£ããã¿ã¼ã³è¦ç´ ã«å¯¾å¿ããä½ç½®ã§ã`m.captures` ã¯"
"`nothing` ãã`m.offsets` ã¯ ãªãã»ãã0 ãè¦ç´ ã«æã¡ã¾ãã(Julia ã®ã¤ã³ããã¯ã¹ã¯ 1 ããå§ã¾ã£ã¦ããã®ã§ãæå­åã¸ã®ã¼ã­ ãªãã»ããã¯ç¡å¹ã§"
"ã)ãããå·¥å¤«ãããä¾ãæ¬¡ã«ç¤ºãã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/strings.md:835 ext/julia/doc/src/manual/strings.md:882
#, no-wrap
msgid "jldoctest acdmatch"
msgstr "jldoctest acdmatch"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:835
#, no-wrap
msgid ""
"julia> m = match(r\"(a|b)(c)?(d)\", \"acd\")\n"
"RegexMatch(\"acd\", 1=\"a\", 2=\"c\", 3=\"d\")\n"
"\n"
"julia> m.match\n"
"\"acd\"\n"
"\n"
"julia> m.captures\n"
"3-element Array{Union{Nothing, SubString{String}},1}:\n"
" \"a\"\n"
" \"c\"\n"
" \"d\"\n"
"\n"
"julia> m.offset\n"
"1\n"
"\n"
"julia> m.offsets\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"julia> m = match(r\"(a|b)(c)?(d)\", \"ad\")\n"
"RegexMatch(\"ad\", 1=\"a\", 2=nothing, 3=\"d\")\n"
"\n"
"julia> m.match\n"
"\"ad\"\n"
"\n"
"julia> m.captures\n"
"3-element Array{Union{Nothing, SubString{String}},1}:\n"
" \"a\"\n"
" nothing\n"
" \"d\"\n"
"\n"
"julia> m.offset\n"
"1\n"
"\n"
"julia> m.offsets\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 0\n"
" 2\n"
msgstr ""
"julia> m = match(r\"(a|b)(c)?(d)\", \"acd\")\n"
"RegexMatch(\"acd\", 1=\"a\", 2=\"c\", 3=\"d\")\n"
"\n"
"julia> m.match\n"
"\"acd\"\n"
"\n"
"julia> m.captures\n"
"3-element Array{Union{Nothing, SubString{String}},1}:\n"
" \"a\"\n"
" \"c\"\n"
" \"d\"\n"
"\n"
"julia> m.offset\n"
"1\n"
"\n"
"julia> m.offsets\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"julia> m = match(r\"(a|b)(c)?(d)\", \"ad\")\n"
"RegexMatch(\"ad\", 1=\"a\", 2=nothing, 3=\"d\")\n"
"\n"
"julia> m.match\n"
"\"ad\"\n"
"\n"
"julia> m.captures\n"
"3-element Array{Union{Nothing, SubString{String}},1}:\n"
" \"a\"\n"
" nothing\n"
" \"d\"\n"
"\n"
"julia> m.offset\n"
"1\n"
"\n"
"julia> m.offsets\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 0\n"
" 2\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:881
msgid "It is convenient to have captures returned as an array so that one can use destructuring syntax to bind them to local variables:"
msgstr "è£è¶³ãããã®ä¸ã¤ä¸ã¤ãã°ããã¦ã­ã¼ã«ã«å¤æ°ã«æç¸ã§ãããããéåã¨ãã¦è¿ããã¨ä¾¿å©ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:882
#, no-wrap
msgid ""
"julia> first, second, third = m.captures; first\n"
"\"a\"\n"
msgstr ""
"julia> first, second, third = m.captures; first\n"
"\"a\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:889
msgid "Captures can also be accessed by indexing the `RegexMatch` object with the number or name of the capture group:"
msgstr "è£è¶³ãããã®ã¯ã`RegexMatch` ãªãã¸ã§ã¯ãã®è£è¶³ããã°ã«ã¼ããæ°å­ãååã§ã¤ã³ããã¯ã¹ã¥ããã¦åãåºããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:890
#, no-wrap
msgid ""
"julia> m=match(r\"(?<hour>\\d+):(?<minute>\\d+)\",\"12:45\")\n"
"RegexMatch(\"12:45\", hour=\"12\", minute=\"45\")\n"
"\n"
"julia> m[:minute]\n"
"\"45\"\n"
"\n"
"julia> m[2]\n"
"\"45\"\n"
msgstr ""
"julia> m=match(r\"(?<hour>\\d+):(?<minute>\\d+)\",\"12:45\")\n"
"RegexMatch(\"12:45\", hour=\"12\", minute=\"45\")\n"
"\n"
"julia> m[:minute]\n"
"\"45\"\n"
"\n"
"julia> m[2]\n"
"\"45\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:905
#, no-wrap
msgid ""
"Captures can be referenced in a substitution string when using [`replace`](@ref) by using `\\n`\n"
"to refer to the nth capture group and prefixing the substitution string with `s`. Capture group\n"
"0 refers to the entire match object. Named capture groups can be referenced in the substitution\n"
"with `\\g<groupname>`. For example:\n"
msgstr "[`replace`](@ref) ãä½¿ç¨ãã¦æå­åç½®æãè¡ãå ´åã«ããã­ã£ããã£ã¯åç§ãããã¨ãã§ãã¾ããnçªç®ã®è£è¶³ã°ã«ã¼ãã¯`\\n`ã§åç§ã§ãã¾ããç½®ææå­åã«ã¯ `s`ãæ¥é ­è¾ã¨ãã¦ä»ãã¾ãã0çªç®ã®è£è¶³ã°ã«ã¼ãã¯ä¸è´ãããªãã¸ã§ã¯ãå¨ä½ãåç§ããã®ã«ä½¿ãã¾ããååä»ãããè£è¶³ã°ã«ã¼ãã¯ã`g<groupname>`ã®å½¢å¼ã§ç½®æã®ä¸­ã§åç§ã§ãã¾ããä¾ãã°:\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:906
#, no-wrap
msgid ""
"julia> replace(\"first second\", r\"(\\w+) (?<agroup>\\w+)\" => s\"\\g<agroup> \\1\")\n"
"\"second first\"\n"
msgstr ""
"julia> replace(\"first second\", r\"(\\w+) (?<agroup>\\w+)\" => s\"\\g<agroup> \\1\")\n"
"\"second first\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:912
#, no-wrap
msgid "Numbered capture groups can also be referenced as `\\g<n>` for disambiguation, as in:\n"
msgstr "ææ§ããé¿ããçºã«ãçªå·ä»ãããè£è¶³ã°ã«ã¼ãã`g<n>`ã§ãåç§ãããã¨ãã§ãã¾ã:\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:913
#, no-wrap
msgid ""
"julia> replace(\"a\", r\".\" => s\"\\g<0>1\")\n"
"\"a1\"\n"
msgstr ""
"julia> replace(\"a\", r\".\" => s\"\\g<0>1\")\n"
"\"a1\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:921
msgid ""
"You can modify the behavior of regular expressions by some combination of the flags `i`, `m`, `s`, and `x` after the closing double quote "
"mark. These flags have the same meaning as they do in Perl, as explained in this excerpt from the [perlre manpage](http://perldoc.perl.org/"
"perlre.html#Modifiers):"
msgstr ""
"æ­£è¦è¡¨ç¾ã®åä½ã¯ãéããå´ã®äºéå¼ç¨ç¬¦ã®å¾ã«ãã©ã° `i`ã`m`ã`s`ãããã³ `x` ã®çµã¿åãããä»ãã¦å¤æ´ã§ãã¾ãããããã®ãã©ã°ã¯ãPerlã®æå³ã¨"
"åãã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:922
#, no-wrap
msgid ""
"i   Do case-insensitive pattern matching.\n"
"\n"
"    If locale matching rules are in effect, the case map is taken\n"
"    from the current locale for code points less than 255, and\n"
"    from Unicode rules for larger code points. However, matches\n"
"    that would cross the Unicode rules/non-Unicode rules boundary\n"
"    (ords 255/256) will not succeed.\n"
"\n"
"m   Treat string as multiple lines.  That is, change \"^\" and \"$\"\n"
"    from matching the start or end of the string to matching the\n"
"    start or end of any line anywhere within the string.\n"
"\n"
"s   Treat string as single line.  That is, change \".\" to match any\n"
"    character whatsoever, even a newline, which normally it would\n"
"    not match.\n"
"\n"
"    Used together, as r\"\"ms, they let the \".\" match any character\n"
"    whatsoever, while still allowing \"^\" and \"$\" to match,\n"
"    respectively, just after and just before newlines within the\n"
"    string.\n"
"\n"
"x   Tells the regular expression parser to ignore most whitespace\n"
"    that is neither backslashed nor within a character class. You\n"
"    can use this to break up your regular expression into\n"
"    (slightly) more readable parts. The '#' character is also\n"
"    treated as a metacharacter introducing a comment, just as in\n"
"    ordinary code.\n"
msgstr ""
"i   å¤§æå­ã¨å°æå­ãåºå¥ããªãã§ãã¿ã¼ã³ããããè¡ãã¾ãã\n"
"\n"
"    ã­ã±ã¼ã«ãããã³ã°ãæå¹ãªå ´åãç¬¦å·ä½ç½® 255ä»¥ä¸ã«å¯¾ãã¦ã¯ãç¾å¨ã®ã­ã±ã¼ã«ããã255ããå¤§ããªç¬¦å·ä½ç½®ã«å¯¾ãã¦ã¯ãã¦ãã³ã¼ãã®ã«ã¼ã«ããã±ã¼ã¹ããããä½æããã¾ãã\n"
"ãã ã ã¦ãã³ã¼ãã«ã¼ã«ã¨ãéã¦ãã³ã¼ãã«ã¼ã«ã®å¢çãã¾ãã(ç¬¦å·ä½ç½®ã 255ä»¥ä¸ã¨ 256ä»¥ä¸) å ´åã®ãããã¯å¤±æããã§ãããã\n"
"\n"
"m   æå­åãè¤æ°è¡ã¨ã¿ãªãã¾ããã¤ã¾ãã\"^\" ã¨ \"$\" ã®è§£éã æå­åã®éå§ã¨çµäºã¨ãããããã®ã§ã¯ãªããæå­ååã®ã©ã®è¡ã®éå§ã»çµäºã¨ãããããããããªåä½ã«ãªãã¾ãã\n"
"\n"
"s   æå­åã1è¡ã¨ã¿ãªãã¾ããã¤ã¾ãã \".\" ããã©ããªæå­ã¨ããããããããã«ãªãã¾ããããããã¨ããæ¹è¡ã®ããã«éå¸¸ãããããªãæå­ã ã£ãã¨ãã¦ãã§ãã\n"
"\n"
"    as r\"\"ms, ã¨ããããã«ãmã¨sãä¸ç·ã«ä½¿ãããã¨ã\".\" ã¯ã©ããªæå­ã¨ããããããªããã\"^\" ã¨\"$\" ã¯ãããããæ¹è¡ã®åå¾ã¨ãããããããã«ãªãã¾ãã\n"
"\n"
"x   æ­£è¦è¡¨ç¾ãã¼ãµã«ãããã¯ã¹ã©ãã·ã¥ä»ããããæå­åã¯ã©ã¹åã®ç©ºç½ãé¤ããã»ã¨ãã©ã®ç©ºç½ãç¡è¦ããããæç¤ºãã¾ããããã«ãã£ã¦ãæ­£è¦è¡¨ç¾ãé¨åæ¯ã«åãã¦(å°ãã ã)è¦ããããããã¨ãã§ãã¾ãã'#' ãã³ã¡ã³ããå°å¥ããã¡ã¿æå­ã¨ãã¦æ±ããã¾ããä¸è¬çãªã³ã¼ãã¨åæ§ã§ãã­ã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:953
msgid "For example, the following regex has all three flags turned on:"
msgstr "ãã¨ãã°ãæ¬¡ã®æ­£è¦è¡¨ç¾ã§ã¯ã3 ã¤ã®ãã©ã°ããã¹ã¦ãªã³ã«ãªã£ã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:954
#, no-wrap
msgid ""
"julia> r\"a+.*b+.*?d$\"ism\n"
"r\"a+.*b+.*?d$\"ims\n"
"\n"
"julia> match(r\"a+.*b+.*?d$\"ism, \"Goodbye,\\nOh, angry,\\nBad world\\n\")\n"
"RegexMatch(\"angry,\\nBad world\")\n"
msgstr ""
"julia> r\"a+.*b+.*?d$\"ism\n"
"r\"a+.*b+.*?d$\"ims\n"
"\n"
"julia> match(r\"a+.*b+.*?d$\"ism, \"Goodbye,\\nOh, angry,\\nBad world\\n\")\n"
"RegexMatch(\"angry,\\nBad world\")\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:965
msgid ""
"The `r\"...\"` literal is constructed without interpolation and unescaping (except for quotation mark `\"` which still has to be escaped). "
"Here is an example showing the difference from standard string literals:"
msgstr ""
"`r\"...\"` ãªãã©ã«ã¯ãå±éã¨ã¨ã¹ã±ã¼ãå¦çãè¡ãã¾ããã (ã¨ã¹ã±ã¼ãããå¿è¦ãããã¾ã å¼ç¨ç¬¦ `\"'` ã¯é¤ãã¾ã)ãä»¥ä¸ã¯ãæ¨æºã®æå­åãªãã©"
"ã«ã¨ã®éããç¤ºãä¾ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:966
#, no-wrap
msgid ""
"julia> x = 10\n"
"10\n"
"\n"
"julia> r\"$x\"\n"
"r\"$x\"\n"
"\n"
"julia> \"$x\"\n"
"\"10\"\n"
"\n"
"julia> r\"\\x\"\n"
"r\"\\x\"\n"
"\n"
"julia> \"\\x\"\n"
"ERROR: syntax: invalid escape sequence\n"
msgstr ""
"julia> x = 10\n"
"10\n"
"\n"
"julia> r\"$x\"\n"
"r\"$x\"\n"
"\n"
"julia> \"$x\"\n"
"\"10\"\n"
"\n"
"julia> r\"\\x\"\n"
"r\"\\x\"\n"
"\n"
"julia> \"\\x\"\n"
"ERROR: syntax: invalid escape sequence\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:985
msgid ""
"Triple-quoted regex strings, of the form `r\"\"\"...\"\"\"`, are also supported (and may be convenient for regular expressions containing "
"quotation marks or newlines)."
msgstr ""
"`r\"\"\"...\"\"\"`ã§æ¸ãããä¸éå¼ç¨ç¬¦ã§å²ã¾ããæ­£è¦è¡¨ç¾æå­åããµãã¼ãããã¦ãã¾ã (å¼ç¨ç¬¦ãæ¹è¡ãå«ãæ­£è¦è¡¨ç¾ã®å ´åã«ä¾¿å©ãªå ´åãããã¾"
"ã)ã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:987
msgid ""
"The `Regex()` constructor may be used to create a valid regex string programmatically.  This permits using the contents of string variables "
"and other string operations when constructing the regex string. Any of the regex codes above can be used within the single string argument "
"to `Regex()`. Here are some examples:"
msgstr ""
"`Regex()` ã³ã³ã¹ãã©ã¯ã¿ã¼ãä½¿ç¨ãã¦ããã­ã°ã©ã ã§æå¹ãªæ­£è¦è¡¨ç¾æå­åãä½æã§ãã¾ãã ããã«ãããæ­£è¦è¡¨ç¾æå­åãæ§ç¯ããã¨ãã«ãæå­åå¤æ°"
"ããã®ä»ã®æå­åæä½ã®çµæãä½¿ç¨ã§ãã¾ããããã¾ã§ã«è¦ã¦ããæ­£è¦è¡¨ç¾ã¯ãããããåä¸ã®æå­åå¼æ°ã§ `Regex()` ã«ä½¿ç¨ã§ãã¾ããããã¤ãã®ä¾ãæ¬¡"
"ã«ç¤ºãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:988
#, no-wrap
msgid ""
"julia> using Dates\n"
"\n"
"julia> d = Date(1962,7,10)\n"
"1962-07-10\n"
"\n"
"julia> regex_d = Regex(\"Day \" * string(day(d)))\n"
"r\"Day 10\"\n"
"\n"
"julia> match(regex_d, \"It happened on Day 10\")\n"
"RegexMatch(\"Day 10\")\n"
"\n"
"julia> name = \"Jon\"\n"
"\"Jon\"\n"
"\n"
"julia> regex_name = Regex(\"[\\\"( ]$name[\\\") ]\")  # interpolate value of name\n"
"r\"[\\\"( ]Jon[\\\") ]\"\n"
"\n"
"julia> match(regex_name,\" Jon \")\n"
"RegexMatch(\" Jon \")\n"
"\n"
"julia> match(regex_name,\"[Jon]\") === nothing\n"
"true\n"
msgstr ""
"julia> using Dates\n"
"\n"
"julia> d = Date(1962,7,10)\n"
"1962-07-10\n"
"\n"
"julia> regex_d = Regex(\"Day \" * string(day(d)))\n"
"r\"Day 10\"\n"
"\n"
"julia> match(regex_d, \"It happened on Day 10\")\n"
"RegexMatch(\"Day 10\")\n"
"\n"
"julia> name = \"Jon\"\n"
"\"Jon\"\n"
"\n"
"julia> regex_name = Regex(\"[\\\"( ]$name[\\\") ]\")  # interpolate value of name\n"
"r\"[\\\"( ]Jon[\\\") ]\"\n"
"\n"
"julia> match(regex_name,\" Jon \")\n"
"RegexMatch(\" Jon \")\n"
"\n"
"julia> match(regex_name,\"[Jon]\") === nothing\n"
"true\n"

#. type: Title ##
#: ext/julia/doc/src/manual/strings.md:1013
#, no-wrap
msgid "[Byte Array Literals](@id man-byte-array-literals)"
msgstr "[ãã¤ãéåãªãã©ã«](@id man-byte-array-literals)"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1019
msgid ""
"Another useful non-standard string literal is the byte-array string literal: `b\"...\"`. This form lets you use string notation to express "
"read only literal byte arrays -- i.e. arrays of [`UInt8`](@ref) values. The type of those objects is `CodeUnits{UInt8, String}`.  The rules "
"for byte array literals are the following:"
msgstr ""
"ãã 1 ã¤ã®ä¾¿å©ãªéæ¨æºæå­åãªãã©ã«ã¯ããã¤ãéåæå­åãªãã©ã«ã§ãã`b\"...\"` ã®ããã«æ¸ãã¾ãããã®å½¢å¼ã§ã¯ãèª­ã¿åãå°ç¨ã®ãªãã©ã«ãã¤"
"ãéåãã¤ã¾ã[`UInt8`](@ref) å¤ã®éåãè¡¨ãã®ã«ãæå­åè¡¨è¨ãä½¿ç¨ãããã¨ãã§ãã¾ãããããã®ãªãã¸ã§ã¯ãã®åã¯`CodeUnits{UInt8, String}`ã§"
"ãã ãã¤ãéåãªãã©ã«ã®è¦åã¯æ¬¡ã®ã¨ããã§ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:1023
msgid "ASCII characters and ASCII escapes produce a single byte."
msgstr "ASCII æå­ã¨ ASCII ã¨ã¹ã±ã¼ãã¯ã1 ãã¤ããçæãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:1023
msgid "`\\x` and octal escape sequences produce the *byte* corresponding to the escape value."
msgstr "`\\x` ããã³8é²ã¨ãã¦ã¨ã¹ã±ã¼ãããæå­ã¯ãã¨ã¹ã±ã¼ãå¤ã«å¯¾å¿ãã *ãã¤ã* ãçæãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/strings.md:1023
msgid "Unicode escape sequences produce a sequence of bytes encoding that code point in UTF-8."
msgstr "Unicode ã¨ã¹ã±ã¼ãåã¯ã¯ãUTF-8 ã®ç¬¦å·ä½ç½®ãã¨ã³ã³ã¼ããããã¤ãåãçæãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1028
msgid ""
"There is some overlap between these rules since the behavior of `\\x` and octal escapes less than 0x80 (128) are covered by both of the "
"first two rules, but here these rules agree. Together, these rules allow one to easily use ASCII characters, arbitrary byte values, and "
"UTF-8 sequences to produce arrays of bytes. Here is an example using all three:"
msgstr ""
"`\\x` ã¨ 0x80 (128) æªæºã®8é²ã¨ã¹ã±ã¼ãã®åä½ã¯æåã® 2 ã¤ã®ã«ã¼ã«ã®ä¸¡æ¹ã§ã«ãã¼ãããã®ã§ãã«ã¼ã«ã®éã«ã¯éãªãããããã¨ããã¾ãããããã"
"ã®è¦åã®éã«çç¾ã¯ããã¾ããããããã®è¦åãçµã¿åããããã¨ã§ãASCII æå­ãä»»æã®ãã¤ãå¤ãããã³ UTF-8 ã·ã¼ã±ã³ã¹ãç°¡åã«ä½¿ç¨ãã¦ãã¤ãã®é"
"åãçæã§ãã¾ãã3 ã¤ãã¹ã¦ãä½¿ç¨ããä¾ãæ¬¡ã«ç¤ºãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1029
#, no-wrap
msgid ""
"julia> b\"DATA\\xff\\u2200\"\n"
"8-element Base.CodeUnits{UInt8,String}:\n"
" 0x44\n"
" 0x41\n"
" 0x54\n"
" 0x41\n"
" 0xff\n"
" 0xe2\n"
" 0x88\n"
" 0x80\n"
msgstr ""
"julia> b\"DATA\\xff\\u2200\"\n"
"8-element Base.CodeUnits{UInt8,String}:\n"
" 0x44\n"
" 0x41\n"
" 0x54\n"
" 0x41\n"
" 0xff\n"
" 0xe2\n"
" 0x88\n"
" 0x80\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1045
msgid ""
"The ASCII string \"DATA\" corresponds to the bytes 68, 65, 84, 65. `\\xff` produces the single byte 255.  The Unicode escape `\\u2200` is "
"encoded in UTF-8 as the three bytes 226, 136, 128. Note that the resulting byte array does not correspond to a valid UTF-8 string:"
msgstr ""
"ASCII æå­å \"DATA\" ã¯ããã¤ã 68ã65ã84ã65 ã«å¯¾å¿ãã¾ãã`\\xff` ã¯åä¸ãã¤ã 255 ãçæãã¾ãã Unicode ã¨ã¹ã±ã¼ã `\\u2200` ã¯ UTF-8 "
"ã§ 3 ãã¤ã 226ã136ã128 ã¨ãã¦ã¨ã³ã³ã¼ãããã¾ããçµæã®ãã¤ãéåã¯ãæå¹ãª UTF-8 æå­åã«å¯¾å¿ããªããã¨ã«æ³¨æãã¦ãã ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1046
#, no-wrap
msgid ""
"julia> isvalid(\"DATA\\xff\\u2200\")\n"
"false\n"
msgstr ""
"julia> isvalid(\"DATA\\xff\\u2200\")\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1053
msgid ""
"As it was mentioned `CodeUnits{UInt8,String}` type behaves like read only array of `UInt8` and if you need a standard vector you can convert "
"it using `Vector{UInt8}`:"
msgstr ""
"åè¿°ã®ããã«ã`CodeUnits{UInt8,String}`åã®æ¯ãèãã¯èª­ã¿åãå°ç¨ã®`UInt8`éåã§ãããããæ¨æºçãªãã¯ãã«ã®æ¯ãèããå¿è¦ãªãã°ã"
"`Vector{UInt8}`ãä½¿ã£ã¦å¤æãã¦ãã ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1054
#, no-wrap
msgid ""
"julia> x = b\"123\"\n"
"3-element Base.CodeUnits{UInt8,String}:\n"
" 0x31\n"
" 0x32\n"
" 0x33\n"
"\n"
"julia> x[1]\n"
"0x31\n"
"\n"
"julia> x[1] = 0x32\n"
"ERROR: setindex! not defined for Base.CodeUnits{UInt8,String}\n"
"[...]\n"
"\n"
"julia> Vector{UInt8}(x)\n"
"3-element Array{UInt8,1}:\n"
" 0x31\n"
" 0x32\n"
" 0x33\n"
msgstr ""
"julia> x = b\"123\"\n"
"3-element Base.CodeUnits{UInt8,String}:\n"
" 0x31\n"
" 0x32\n"
" 0x33\n"
"\n"
"julia> x[1]\n"
"0x31\n"
"\n"
"julia> x[1] = 0x32\n"
"ERROR: setindex! not defined for Base.CodeUnits{UInt8,String}\n"
"[...]\n"
"\n"
"julia> Vector{UInt8}(x)\n"
"3-element Array{UInt8,1}:\n"
" 0x31\n"
" 0x32\n"
" 0x33\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1078
msgid ""
"Also observe the significant distinction between `\\xff` and `\\uff`: the former escape sequence encodes the *byte 255*, whereas the latter "
"escape sequence represents the *code point 255*, which is encoded as two bytes in UTF-8:"
msgstr ""
"ã¾ãã`\\xff` ã¨ `\\uff` ã«ã¯éå¤§ãªéããããã¾ã: åèã®ã¨ã¹ã±ã¼ã ã·ã¼ã±ã³ã¹ã¯ *ãã¤ã 255*ãã¨ã³ã³ã¼ããã¾ãããå¾èã®ã¨ã¹ã±ã¼ã ã·ã¼ã±ã³"
"ã¹ã¯*ç¬¦å·ä½ç½® 255* ãè¡¨ããUTF-8 ã§ã¯ 2 ãã¤ãã¨ãã¦ã¨ã³ã³ã¼ãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1079
#, no-wrap
msgid ""
"julia> b\"\\xff\"\n"
"1-element Base.CodeUnits{UInt8,String}:\n"
" 0xff\n"
"\n"
"julia> b\"\\uff\"\n"
"2-element Base.CodeUnits{UInt8,String}:\n"
" 0xc3\n"
" 0xbf\n"
msgstr ""
"julia> b\"\\xff\"\n"
"1-element Base.CodeUnits{UInt8,String}:\n"
" 0xff\n"
"\n"
"julia> b\"\\uff\"\n"
"2-element Base.CodeUnits{UInt8,String}:\n"
" 0xc3\n"
" 0xbf\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1091
msgid "Character literals use the same behavior."
msgstr "æå­ãªãã©ã«ãåãåä½ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1098
msgid ""
"For code points less than `\\u80`, it happens that the UTF-8 encoding of each code point is just the single byte produced by the "
"corresponding `\\x` escape, so the distinction can safely be ignored. For the escapes `\\x80` through `\\xff` as compared to `\\u80` through "
"`\\uff`, however, there is a major difference: the former escapes all encode single bytes, which -- unless followed by very specific "
"continuation bytes -- do not form valid UTF-8 data, whereas the latter escapes all represent Unicode code points with two-byte encodings."
msgstr ""
"ç¬¦å·ä½ç½®ã`\\u80` ããå°ããå ´åã¯ãåç¬¦å·ä½ç½®ã§ã® UTF-8 ã¨ã³ã³ã¼ãã£ã³ã°ã¯ãå¯¾å¿ãã `\\x` ã¨ã¹ã±ã¼ãã«ãã£ã¦çæãããåä¸ãã¤ãã«ããã¾ã"
"ãããã®éããç¡è¦ãã¦ãåé¡ããã¾ããããã ããã¨ã¹ã±ã¼ã `\\x80` ãã `\\xff` ã¾ã§ãã`\\u80`ãã`\\uff`ã¾ã§ã¨æ¯è¼ããã¨å¤§ããªéããããã¾"
"ã: åèã¯ãã¹ã¦åä¸ãã¤ãã«ã¨ã³ã³ã¼ãããã¾ãããããä¸é¨ã®ãã¤ãåãé¤ãã¦ç¡å¹ãªUTF-8ãã¼ã¿ã«ãªãã¾ããå¾èã¯ãã¹ã¦Unicodeã®ç¬¦å·ä½ç½®ãè¡¨ç¾"
"ãã2 ãã¤ãã¨ã³ã³ã¼ãã£ã³ã°ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1104
msgid ""
"If this is all extremely confusing, try reading [\"The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About "
"Unicode and Character Sets\"](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-"
"must-know-about-unicode-and-character-sets-no-excuses/).  It's an excellent introduction to Unicode and UTF-8, and may help alleviate some "
"confusion regarding the matter."
msgstr ""
"ãã ãã®ãã¨ã«å¤§å¤æ··ä¹±ãã¦ãããããªãã°ã [\"The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode "
"and Character Sets\"](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-"
"know-about-unicode-and-character-sets-no-excuses/)ãèª­ãã§ã¿ã¦ãã ãããUnicodeã¨UTF-8ã«é¢ããåªããå¥éè¨äºãªã®ã§ãæ··ä¹±ãè»½æ¸ããå©ãã«ãªã"
"ã§ãããã"

#. type: Title ##
#: ext/julia/doc/src/manual/strings.md:1105
#, no-wrap
msgid "[Version Number Literals](@id man-version-number-literals)"
msgstr "[ãã¼ã¸ã§ã³çªå·ãªãã©ã«](@id man-version-number-literals)"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1116
msgid ""
"Version numbers can easily be expressed with non-standard string literals of the form [`v\"...\"`](@ref @v_str).  Version number literals "
"create [`VersionNumber`](@ref) objects which follow the specifications of [semantic versioning](https://semver.org/), and therefore are "
"composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric annotations. For example, `v\"0.2.1-"
"rc1+win64\"` is broken into major version `0`, minor version `2`, patch version `1`, pre-release `rc1` and build `win64`. When entering a "
"version literal, everything except the major version number is optional, therefore e.g.  `v\"0.2\"` is equivalent to `v\"0.2.0\"` (with "
"empty pre-release/build annotations), `v\"2\"` is equivalent to `v\"2.0.0\"`, and so on."
msgstr ""
"ãã¼ã¸ã§ã³çªå·ã¯ã[`v\"...\"`](@ref @v_str)ã¨ãå½¢å¼ã®éæ¨æºæå­åãªãã©ã«ã§ç°¡åã«è¡¨ç¾ã§ãã¾ãã ãã¼ã¸ã§ã³çªå·ãªãã©ã«ã¯[`VersionNumber`]"
"(@ref)ãªãã¸ã§ã¯ããä½æãã¾ããããã¯ã[ã»ãã³ãã£ãã¯ã»ãã¼ã¸ã§ãã³ã°](https://semver.org/)ã®ä»æ§ã«å¾ã£ã¦ãã¡ã¸ã£ã¼ããã¤ãã¼ããããã®æ°å¤"
"ã§æ§æããããã®å¾ããã¬ãªãªã¼ã¹ã¨ãã«ãã®è±æ°å­ã«ããæ³¨éãç¶ãã¾ãããã¨ãã°ã`v\"0.2.1-rc1+win64`ã¯ã¡ã¸ã£ã¼ãã¼ã¸ã§ã³`0`ããã¤ãã¼ãã¼ã¸ã§"
"ã³`2`ãããããã¼ã¸ã§ã³`1`ããã¬ãªãªã¼ã¹`rc1`ããã«ã`win64`ã«åå²ããã¾ãããã¼ã¸ã§ã³ãªãã©ã«ãå¥åããå ´åãã¡ã¸ã£ã¼ãã¼ã¸ã§ã³çªå·ä»¥å¤ã®ã"
"ã¹ã¦ããªãã·ã§ã³ã§ãã ãv\"0.2\"ãã¯ãvã0.2.0\"(ç©ºã®ãã¬ãªãªã¼ã¹/ãã«ãã¢éä»ã)ã\"v\"2\"``ã¯\"v\"2.0.0\"ã¨åç­ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1120
msgid ""
"`VersionNumber` objects are mostly useful to easily and correctly compare two (or more) versions.  For example, the constant [`VERSION`]"
"(@ref) holds Julia version number as a `VersionNumber` object, and therefore one can define some version-specific behavior using simple "
"statements as:"
msgstr ""
"`VersionNumber` ãªãã¸ã§ã¯ãã¯ã2 ã¤ä»¥ä¸ã®ãã¼ã¸ã§ã³ãç°¡åãã¤æ­£ç¢ºã«æ¯è¼ããã®ã«å½¹ç«ã¡ã¾ãã ãã¨ãã°ãå®æ° [`VERSION`](@ref) ã¯ Julia ãã¼"
"ã¸ã§ã³çªå·ã `VersionNumber` ãªãã¸ã§ã¯ãã¨ãã¦ä¿æãããããåç´ãªã¹ãã¼ãã¡ã³ããä½¿ç¨ãã¦ãã¼ã¸ã§ã³åºæã®åä½ãæ¬¡ã®ããã«å®ç¾©ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1121
#, no-wrap
msgid ""
"if v\"0.2\" <= VERSION < v\"0.3-\"\n"
"    # do something specific to 0.2 release series\n"
"end\n"
msgstr ""
"if v\"0.2\" <= VERSION < v\"0.3-\"\n"
"    # do something specific to 0.2 release series\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1133
#, no-wrap
msgid ""
"Note that in the above example the non-standard version number `v\"0.3-\"` is used, with a trailing\n"
"`-`: this notation is a Julia extension of the standard, and it's used to indicate a version which\n"
"is lower than any `0.3` release, including all of its pre-releases. So in the above example the\n"
"code would only run with stable `0.2` versions, and exclude such versions as `v\"0.3.0-rc1\"`. In\n"
"order to also allow for unstable (i.e. pre-release) `0.2` versions, the lower bound check should\n"
"be modified like this: `v\"0.2-\" <= VERSION`.\n"
msgstr "ä¸è¨ã®ä¾ã§ã¯ãéæ¨æºãã¼ã¸ã§ã³çªå· `v\"0.3-\"ãä½¿ç¨ãããæ«å°¾ã«`-`ãä½¿ããã¦ããã®ã«æ³¨æãã¦ãã ãã: ãã®è¡¨è¨æ³Juliaã«ããæ¨æºã®æ¡å¼µã§ããã®ãã¼ã¸ã§ã³ãå¨ã¦ã®ãã¬ãªãªã¼ã¹ãå«ã¿ã`0.3`ã®ãªãªã¼ã¹ãããã¼ã¸ã§ã³ãä½ããã¨ãç¤ºãã¾ãããããã£ã¦ãä¸è¨ã®ã³ã¼ãä¾ã®æå³ã¯ã`if` ã§å²ã¾ããã³ã¼ãããå®å®çã® `0.2` ã®ã¿ã§å®è¡å¯è½ã§ã`v\"0.3.0-rc1` ãªã©ã®ãã¼ã¸ã§ã³ã§ã¯å®è¡ãããªãã¨ãããã¨ã«ãªãã¾ããã¾ããä¸å®å®ãª(ããªãã¡ãã¬ãªãªã¼ã¹ã®)`0.2`ãã¼ã¸ã§ã³ãè¨±å¯ããã«ã¯ãä¸éãã§ããæ¬¡ã®ããã«å¤æ´ãã¦ãã ãã: `v\"0.2-\" <= VERSION`ã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1138
#, no-wrap
msgid ""
"Another non-standard version specification extension allows one to use a trailing `+` to express\n"
"an upper limit on build versions, e.g.  `VERSION > v\"0.2-rc1+\"` can be used to mean any version\n"
"above `0.2-rc1` and any of its builds: it will return `false` for version `v\"0.2-rc1+win64\"` and\n"
"`true` for `v\"0.2-rc2\"`.\n"
msgstr "å¥ã®éæ¨æºã®ãã¼ã¸ã§ã³ä»æ§æ¡å¼µæ©è½ã¨ãã¦ãæ«å°¾ã« `+`ãã¤ãã¦ãã«ããã¼ã¸ã§ã³ã®ä¸é(ä¾ãã°)ãè¡¨ããã¨ãã§ãã¾ããä¾ãã°ã `VERSION > v\"0.2-rc1+\"`ã¯ã`0.2-rc1`ä»¥ä¸ã®ä»»æã®ãã¼ã¸ã§ã³ãè¡¨ãã®ã§ãä¾ãã° `v\"0.2-rc1+win64\"`ã«å¯¾ãã¦ã¯ `false` ãè¿ãã`v\"0.2-rc2\"`ã«å¯¾ãã¦`true`ãè¿ãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1143
msgid ""
"It is good practice to use such special versions in comparisons (particularly, the trailing `-` should always be used on upper bounds unless "
"there's a good reason not to), but they must not be used as the actual version number of anything, as they are invalid in the semantic "
"versioning scheme."
msgstr ""
"ãã®ãããªç¹å¥ãªãã¼ã¸ã§ã³ãä½¿ã£ãæ¯è¼ã¯éå¸¸ã«å®è·µçã§ã(ç¹ã«ãå¾ç¶ã® `-` ã¯ãæ­£å½ãªçç±ããªãéãå¸¸ã«ä¸éã§ä½¿ç¨ããå¿è¦ãããã¾ã)ããã»ãã³"
"ãã£ãã¯ ãã¼ã¸ã§ãã³ã°ã®æ¹å¼ã¨ãã¦ã¯ç¡å¹ãªãã®ãªã®ã§ãå®éã®ãã¼ã¸ã§ã³çªå·ã¨ãã¦ä½¿ç¨ãã¦ã¯ãªãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1146
msgid ""
"Besides being used for the [`VERSION`](@ref) constant, `VersionNumber` objects are widely used in the `Pkg` module, to specify packages "
"versions and their dependencies."
msgstr ""
"[`VERSION`](@ref) å®æ°ã«ä½¿ãä»¥å¤ã«ã`VersionNumber` ãªãã¸ã§ã¯ãã¯`Pkg` ã§ããã±ã¼ã¸ã®ãã¼ã¸ã§ã³ã¨ãã®ä¾å­é¢ä¿ãæå®ããã®ã«åºãä½¿ããã¦ãã¾"
"ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/strings.md:1147
#, no-wrap
msgid "[Raw String Literals](@id man-raw-string-literals)"
msgstr "[çæå­åãªãã©ã«](@id man-raw-string-literals)"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1155
msgid ""
"Raw strings without interpolation or unescaping can be expressed with non-standard string literals of the form `raw\"...\"`. Raw string "
"literals create ordinary `String` objects which contain the enclosed contents exactly as entered with no interpolation or unescaping. This "
"is useful for strings which contain code or markup in other languages which use `$` or `\\` as special characters."
msgstr ""
"å¼å±éãã¨ã¹ã±ã¼ãå¦çã®ãªãçæå­åã¯ã`raw\"...'`' ã¨ããå½¢å¼ã®éæ¨æºæå­åãªãã©ã«ã§è¡¨ç¾ã§ãã¾ããçæå­åãªãã©ã«ã¯ãå¼ç¨ç¬¦ã®ä¸­èº«ãå¼å±é"
"ãã¨ã¹ã±ã¼ãå¦çãããã¨ãªããã®ã¾ã¾å«ãã éå¸¸ã®`String`ãªãã¸ã§ã¯ããä½æãã¾ããããã¯ã`$` ã¾ãã¯ `\\` ãç¹æ®æå­ã¨ãã¦ä½¿ç¨ããä»è¨èªã®"
"ã³ã¼ãã¾ãã¯ãã¼ã¯ã¢ããè¨èªãå«ãæå­åã«ä¾¿å©ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1160
msgid ""
"The exception is that quotation marks still must be escaped, e.g. `raw\"\\\"\"` is equivalent to `\"\\\"\"`.  To make it possible to express "
"all strings, backslashes then also must be escaped, but only when appearing right before a quote character:"
msgstr ""
"ä¾å¤ã¯ãå¼ç¨ç¬¦ãã¨ã¹ã±ã¼ãããå¿è¦ãããå ´åã§ããä¾ãã°`raw\"\\\"\"` ã¯`\"\\\"\"`ã¨åç­ã§ãã ãã¹ã¦ã®æå­åãè¡¨ç¾ãããã¨ããã¨ãå¼ç¨ç¬¦æå­"
"ã®ç´åã«è¡¨ç¤ºãããå ´åã ãã§ãããããã¯ã¹ã©ãã·ã¥ãã¨ã¹ã±ã¼ãããå¿è¦ãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1161
#, no-wrap
msgid ""
"julia> println(raw\"\\\\ \\\\\\\"\")\n"
"\\\\ \\\"\n"
msgstr ""
"julia> println(raw\"\\\\ \\\\\\\"\")\n"
"\\\\ \\\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/strings.md:1169
msgid ""
"Notice that the first two backslashes appear verbatim in the output, since they do not precede a quote character.  However, the next "
"backslash character escapes the backslash that follows it, and the last backslash escapes a quote, since these backslashes appear before a "
"quote."
msgstr ""
"æåã® 2 ã¤ã®ããã¯ã¹ã©ãã·ã¥ã¯ãå¼ç¨ç¬¦æå­ã®åã«ãªãããããã®ã¾ã¾åºåããããã¨ã«æ³¨æãã¦ãã ããã ãã ããæ¬¡ã®ããã¯ã¹ã©ãã·ã¥ã¯ããã®å¾"
"ã«ç¶ãããã¯ã¹ã©ãã·ã¥ãã¨ã¹ã±ã¼ãããæå¾ã®ããã¯ã¹ã©ãã·ã¥ã¯å¼ç¨ç¬¦ã®åã«è¡¨ç¤ºãããã®ã§ãå¼ç¨ç¬¦ãã¨ã¹ã±ã¼ããã¾ãã"

#. type: Title #
#: ext/julia/doc/src/manual/parallel-computing.md:1
#, no-wrap
msgid "Parallel Computing"
msgstr "[ä¸¦åã³ã³ãã¥ã¼ãã£ã³ã°](@id Parallel-Computing)"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:5
msgid ""
"For newcomers to multi-threading and parallel computing it can be useful to first appreciate the different levels of parallelism offered by "
"Julia. We can divide them in three main categories :"
msgstr ""
"ãã«ãã¹ã¬ããã³ã³ãã¥ã¼ãã£ã³ã°ã¨ä¸¦åã³ã³ãã¥ã¼ãã£ã³ã°ã®åå¿èã«ã¨ã£ã¦ã¯ãJulia ãæä¾ããä¸¦åå¦çã®ãã¾ãã¾ãªã¬ãã«ãæåã«çè§£ããã¨ä¾¿å©"
"ã§ããJulia ã®ä¸¦åå¦çã¯3ã¤ã®ä¸»è¦ãªã«ãã´ãªã«åé¡ãããã¨ãã§ãã¾ã:"

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/parallel-computing.md:9
msgid "Julia Coroutines (Green Threading)"
msgstr "Julia ã³ã«ã¼ãã³(ã°ãªã¼ã³ã¹ã¬ãã)"

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/parallel-computing.md:9
msgid "Multi-Threading"
msgstr "ãã«ãã¹ã¬ãã"

#. type: Title #
#: ext/julia/doc/src/manual/parallel-computing.md:9 ext/julia/doc/src/manual/parallel-computing.md:507
#, no-wrap
msgid "Multi-Core or Distributed Processing"
msgstr "ãã«ãã³ã¢å¦çã¾ãã¯åæ£å¦ç"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:14
msgid ""
"We will first consider Julia [Tasks (aka Coroutines)](@ref man-tasks) and other modules that rely on the Julia runtime library, that allow "
"us to suspend and resume computations with full control of inter-`Tasks` communication without having to manually interface with the "
"operating system's scheduler.  Julia also supports communication between `Tasks` through operations like [`wait`](@ref) and [`fetch`]"
"(@ref).  Communication and data synchronization is managed through [`Channel`](@ref)s, which are the conduits that provide inter-`Tasks` "
"communication."
msgstr ""
"ã¾ããJulia \n"
"[ã¿ã¹ã¯(å¥å ã³ã«ã¼ãã³)](@ref man-tasks)\n"
" ã¨Juliaã©ã³ã¿ã¤ã ã©ã¤ãã©ãªã«ä¾å­ããä»ã®ã¢ã¸ã¥ã¼ã«ãæ¤è¨ããç´æ¥OSã®ã¹ã±ã¸ã¥ã¼ã©ã¨ããã¨ãããããã¨ãªããã¿ã¹ã¯éã®éä¿¡ãå®å¨ã«å¶å¾¡ãã¦è¨"
"ç®ãä¸­æ­ããã³åéã§ããããã«ãã¾ãã ã¾ããJulia ã¯[`wait`](@ref)ã [`fetch`](@ref) ãªã©ã®æä½ãéããã¿ã¹ã¯ééä¿¡ããµãã¼ããã¦ãã¾ããé"
"ä¿¡ã¨ãã¼ã¿ã®åæã¯ãã¿ã¹ã¯ééä¿¡ãæä¾ããå°ç®¡ã§ãã [`Channel`](@ref)s ãä»ãã¦ç®¡çããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:23
msgid ""
"Julia also supports [experimental multi-threading](@ref man-multithreading), where execution is forked and an anonymous function is run "
"across all threads.  Known as the fork-join approach, parallel threads execute independently, and must ultimately be joined in Julia's main "
"thread to allow serial execution to continue.  Multi-threading is supported using the [`Base.Threads`](@ref lib-multithreading) module that "
"is still considered experimental, as Julia is not yet fully thread-safe. In particular segfaults seem to occur during I/O operations and "
"task switching.  As an up-to-date reference, keep an eye on [the issue tracker](https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is"
"%3Aissue+label%3Amultithreading).  Multi-Threading should only be used if you take into consideration global variables, locks and atomics, "
"all of which are explained later."
msgstr ""
"Julia ã¯\n"
"[å®é¨çãªãã«ãã¹ã¬ãã](@ref man-multithreading)\n"
"ããµãã¼ããã¦ãã¾ããå®é¨çãªãã«ãã¹ã¬ããã§ã¯å¦çã®å®è¡ããã©ã¼ã¯ãããç¡åé¢æ°ããã¹ã¦ã®ã¹ã¬ããã§å®è¡ããã¾ãã ãã©ã¼ã¯çµåã¢ãã­ã¼ãã¨"
"å¼ã°ãããã®ã§ãä¸¦è¡ã¹ã¬ããã¯ç¬ç«ãã¦å®è¡ããã¾ãããæçµçã«ã¯éæ¬¡å®è¡ãç¶è¡ã§ããããã«Julia ã®ã¡ã¤ã³ ã¹ã¬ããã«çµåããå¿è¦ãããã¾ãã "
"ãã«ãã¹ã¬ããã¯ã\n"
"[`Base.Threads`](@ref lib-multithreading) \n"
"ã¢ã¸ã¥ã¼ã«ã§ãµãã¼ãããã¦ãã¾ãããJulia ãã¾ã å®å¨ã«ã¹ã¬ããã»ã¼ãã§ã¯ãªããå®é¨æ®µéã®ãã®ã§ããç¹ã«ãI/O æä½ããã³ã¿ã¹ã¯ã®åãæ¿ãä¸­ã«ã»"
"ã°ã¡ã³ãã¼ã·ã§ã³ãã©ã¼ã«ããçºçããå¯è½æ§ãããã¾ããææ°æå ±ãå¾ãã«ã¯ \n"
"[Issue tracker](https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading) \n"
"ãåç§ãã¦ãã ããããã«ãã¹ã¬ãããä½¿ãã«ã¯ãã°ã­ã¼ãã«å¤æ°ãã­ãã¯ãããã³ã¢ãããã¯ãèæ®ããªãã¦ã¯ãªãã¾ãããä»¥ä¸ã§ãããã«ã¤ãã¦èª¬æã"
"ã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:27
msgid ""
"In the end we will present Julia's approach to distributed and parallel computing. With scientific computing in mind, Julia natively "
"implements interfaces to distribute a process across multiple cores or machines.  Also we will mention useful external packages for "
"distributed programming like `MPI.jl` and `DistributedArrays.jl`."
msgstr ""
"æå¾ã«ãåæ£ã³ã³ãã¥ã¼ãã£ã³ã°ã¨ä¸¦åã³ã³ãã¥ã¼ãã£ã³ã°ã«å¯¾ãã Julia ã®ã¢ãã­ã¼ããç´¹ä»ãã¾ããç§å­¦çè¨ç®ã§ã®å©ç¨ãå¿µé ­ã«ãJulia ã¯ãã¤ãã£ã"
"ã«ã¤ã³ã¿ã¼ãã§ã¤ã¹ãå®è£ãã¦ãããè¤æ°ã®ã³ã¢ã¾ãã¯ãã·ã³ã«ãã­ã»ã¹ãåæ£ãã¾ãã ã¾ãã`MPI.jl`ã`DistributedArrays.jl`ãªã©ã®åæ£ãã­ã°ã©ãã³"
"ã°ã«å½¹ç«ã¤å¤é¨ããã±ã¼ã¸ã«ã¤ãã¦ãè¨åãã¾ãã"

#. type: Title #
#: ext/julia/doc/src/manual/parallel-computing.md:28
#, no-wrap
msgid "Coroutines"
msgstr "ã³ã«ã¼ãã³"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:38
msgid ""
"Julia's parallel programming platform uses [Tasks (aka Coroutines)](@ref man-tasks) to switch among multiple computations.  To express an "
"order of execution between lightweight threads communication primitives are necessary.  Julia offers `Channel(func::Function, ctype=Any, "
"csize=0, taskref=nothing)` that creates a new task from `func`, binds it to a new channel of type `ctype` and size `csize` and schedule the "
"task.  `Channels` can serve as a way to communicate between tasks, as `Channel{T}(sz::Int)` creates a buffered channel of type `T` and size "
"`sz`.  Whenever code performs a communication operation like [`fetch`](@ref) or [`wait`](@ref), the current task is suspended and a "
"scheduler picks another task to run.  A task is restarted when the event it is waiting for completes."
msgstr ""
"Julia ã®ä¸¦åãã­ã°ã©ãã³ã° ãã©ãããã©ã¼ã ã§ã¯ã\n"
"[ã¿ã¹ã¯ (å¥å Coroutines)](@ref man-tasks) \n"
"ãä½¿ç¨ãã¦è¤æ°ã®è¨ç®ãåãæ¿ãã¾ãã è»½éã¹ã¬ããéã§å®è¡é åºãæå®ããã«ã¯ãéä¿¡ããªããã£ããå¿è¦ã§ãã Julia ã«ã¯\n"
"`Channel(func::Function, ctype=Any, csize=0, taskref=nothing)`\n"
"ã¨ããé¢æ°ãããã¾ãã`func`ããæ°ããã¿ã¹ã¯ãä½æããå`ctype`ã¨ãµã¤ãº`csize`ã®æ°ãããã£ãã«ã«ã¿ã¹ã¯ããã¤ã³ãã»ã¹ã±ã¸ã¥ã¼ã«ãã¾ãã "
"`Channels` ã¯ã¿ã¹ã¯éã®éä¿¡æ¹æ³ã¨ãã¦æ©è½ãããã®ã§ã`Channel{T}(sz:Int)` ãå `T` ã¨ãµã¤ãº `sz` ã®ãããã¡ãªã³ã°ãã£ãã«ãä½æããããã«ãã¾"
"ããã³ã¼ãã [`fetch`](@ref) ã [`wait`](@ref) ãªã©ã®éä¿¡æä½ãå®è¡ãããã³ã«ãç¾å¨ã®ã¿ã¹ã¯ã¯ä¸­æ­ãããã¹ã±ã¸ã¥ã¼ã©ã¯å®è¡ããå¥ã®ã¿ã¹ã¯ãé¸æ"
"ãã¾ãã ã¿ã¹ã¯ã¯ãå¾æ©ä¸­ã®ã¤ãã³ããå®äºããã¨ã¾ãç¶ãã®å¦çãéå§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:44
msgid ""
"For many problems, it is not necessary to think about tasks directly. However, they can be used to wait for multiple events at the same "
"time, which provides for *dynamic scheduling*. In dynamic scheduling, a program decides what to compute or where to compute it based on when "
"other jobs finish. This is needed for unpredictable or unbalanced workloads, where we want to assign more work to processes only when they "
"finish their current tasks."
msgstr ""
"å¤ãã®åé¡ã§ã¯ãã¿ã¹ã¯ã®ãã¨ãç´æ¥èããå¿è¦ã¯ããã¾ããããã ããã¿ã¹ã¯ã¯ãåæã«å¦çãããè¤æ°ã®ã¤ãã³ããå¾æ©ããã®ã«ä½¿ç¨ã§ããããã*åç"
"ã¹ã±ã¸ã¥ã¼ãªã³ã°*ãè¡ããã¨ãã§ãã¾ããåçã¹ã±ã¸ã¥ã¼ãªã³ã°ã§ã¯ããã­ã°ã©ã ã¯ãä»ã®ã¸ã§ãããã¤çµäºãããã«åºã¥ãã¦ãä½ãè¨ç®ããããã¾ãã¯ã©"
"ãã§è¨ç®ããããæ±ºå®ãã¾ããããã¯ãäºæ¸¬ä¸è½ãªã¯ã¼ã¯ã­ã¼ããä¸åè¡¡ãªã¯ã¼ã¯ã­ã¼ãã«å¿è¦ã§ããããããç¶æ³ã§ã¯ããã­ã»ã¹ãç¾å¨ã®ã¿ã¹ã¯ãå®äºã"
"ãæã ããæã«ãªã£ããã­ã»ã¹ã«ããå¤ãã®ã¿ã¹ã¯ãå²ãå½ã¦ããã¨ãããããªãã¨ããããããªãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:45
#, no-wrap
msgid "Channels"
msgstr "[ãã£ã³ãã«](@id Channels)"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:50
msgid ""
"The section on [`Task`](@ref)s in [Control Flow](@ref) discussed the execution of multiple functions in a co-operative manner. [`Channel`]"
"(@ref)s can be quite useful to pass data between running tasks, particularly those involving I/O operations."
msgstr ""
"[å¶å¾¡ãã­ã¼](@id Control-Flow)ã®ãã¼ã¸ã® \n"
"[ã¿ã¹ã¯](@ref man-tasks) \n"
"ã»ã¯ã·ã§ã³ã§ã¯ãåèª¿çã«åä½ããè¤æ°ã®é¢æ°ã®å®è¡ã«ã¤ãã¦è­°è«ãã¾ããã[`Channel`](@ref)ã¯ãå®è¡ä¸­ã®ã¿ã¹ã¯ãç¹ã« I/O æä½ãå«ãã¿ã¹ã¯éã§ãã¼"
"ã¿ãæ¸¡ãã®ã«éå¸¸ã«å½¹ç«ã¡ã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:55
msgid ""
"Examples of operations involving I/O include reading/writing to files, accessing web services, executing external programs, etc. In all "
"these cases, overall execution time can be improved if other tasks can be run while a file is being read, or while waiting for an external "
"service/program to complete."
msgstr ""
"I/O ã«é¢é£ããæä½ã®ä¾ã¨ãã¦ã¯ããã¡ã¤ã«ã®èª­ã¿åã/æ¸ãè¾¼ã¿ãWeb ãµã¼ãã¹ã¸ã®ã¢ã¯ã»ã¹ãå¤é¨ãã­ã°ã©ã ã®å®è¡ãªã©ãããã¾ãããããã®å ´åãã"
"ãã¡ã¤ã«ã®èª­ã¿åãä¸­ãã¾ãã¯å¤é¨ãµã¼ãã¹/ãã­ã°ã©ã ã®å®äºãå¾æ©ãã¦ããéã«ä»ã®ã¿ã¹ã¯ãå®è¡ã§ããå ´åã¯ãå¨ä½çãªå®è¡æéãæ¹åã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:57
msgid "A channel can be visualized as a pipe, i.e., it has a write end and a read end :"
msgstr "ãã£ãã«ã¯ãã¤ãã¨ã¿ãªããã¨ãã§ãã¾ããã¤ã¾ãããã£ã³ãã«ã¯ \"write end\" ã¨ \"read end\"ãæã¡ã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:62
msgid "Multiple writers in different tasks can write to the same channel concurrently via [`put!`](@ref)  calls."
msgstr "ç°ãªãã¿ã¹ã¯ã®è¤æ°ã®Writer ãã[`put!`](@ref) é¢æ°ã®å¼ã³åºãçµç±ã§åããã£ãã«ã«åæã«æ¸ãè¾¼ã¿ã§ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:62
msgid "Multiple readers in different tasks can read data concurrently via [`take!`](@ref) calls."
msgstr "ç°ãªãã¿ã¹ã¯ã®è¤æ°ã®Reader ã¯ã[`take!`](@ref)å¼ã³åºããä»ãã¦åæã«ãã¼ã¿ãèª­ã¿åããã¨ãã§ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:62
msgid "As an example:"
msgstr "ä¾:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:67
#, no-wrap
msgid ""
"    ```julia\n"
"    # Given Channels c1 and c2,\n"
"    c1 = Channel(32)\n"
"    c2 = Channel(32)\n"
msgstr ""
"    ```julia\n"
"    # Given Channels c1 and c2,\n"
"    c1 = Channel(32)\n"
"    c2 = Channel(32)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:77
#, no-wrap
msgid ""
"    # and a function `foo` which reads items from c1, processes the item read\n"
"    # and writes a result to c2,\n"
"    function foo()\n"
"        while true\n"
"            data = take!(c1)\n"
"            [...]               # process data\n"
"            put!(c2, result)    # write out result\n"
"        end\n"
"    end\n"
msgstr ""
"    # and a function `foo` which reads items from c1, processes the item read\n"
"    # and writes a result to c2,\n"
"    function foo()\n"
"        while true\n"
"            data = take!(c1)\n"
"            [...]               # process data\n"
"            put!(c2, result)    # write out result\n"
"        end\n"
"    end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:95
#, no-wrap
msgid ""
"    # we can schedule `n` instances of `foo` to be active concurrently.\n"
"    for _ in 1:n\n"
"        @async foo()\n"
"    end\n"
"    ```\n"
"  * Channels are created via the `Channel{T}(sz)` constructor. The channel will only hold objects\n"
"    of type `T`. If the type is not specified, the channel can hold objects of any type. `sz` refers\n"
"    to the maximum number of elements that can be held in the channel at any time. For example, `Channel(32)`\n"
"    creates a channel that can hold a maximum of 32 objects of any type. A `Channel{MyType}(64)` can\n"
"    hold up to 64 objects of `MyType` at any time.\n"
"  * If a [`Channel`](@ref) is empty, readers (on a [`take!`](@ref) call) will block until data is available.\n"
"  * If a [`Channel`](@ref) is full, writers (on a [`put!`](@ref) call) will block until space becomes available.\n"
"  * [`isready`](@ref) tests for the presence of any object in the channel, while [`wait`](@ref)\n"
"    waits for an object to become available.\n"
"  * A [`Channel`](@ref) is in an open state initially. This means that it can be read from and written to\n"
"    freely via [`take!`](@ref) and [`put!`](@ref) calls. [`close`](@ref) closes a [`Channel`](@ref).\n"
"    On a closed [`Channel`](@ref), [`put!`](@ref) will fail. For example:\n"
msgstr ""
"    # we can schedule `n` instances of `foo` to be active concurrently.\n"
"    for _ in 1:n\n"
"        @async foo()\n"
"    end\n"
"    ```\n"
"  * ãã£ã³ãã«ã¯ã`Channel{T}(sz)` ã³ã³ã¹ãã©ã¯ã¿ã§çæããã¾ãããã£ã³ãã«ã¯ãåTã®ãªãã¸ã§ã¯ãã®ã¿ãä¿æãã¾ãã\n"
"    åãæå®ãããªãã£ãå ´åã¯ããã£ã³ãã«ã¯ãã©ããªåãä¿æãããã¨ãã§ãã¾ãã\n"
"    `sz` ã¯ããã£ã³ãã«ã§ãã¤ã§ãä¿æã§ããæå¤§è¦ç´ æ°ã§ããä¾ãã°ã`Channel(32)` ã§çæãããã®ã¯ãä»»æã®åã®ãªãã¸ã§ã¯ããæå¤§32åä¿æã§ãããã£ã³ãã«ãçæãã¾ãã \n"
"     `Channel{MyType}(64)` ã¯ã`MyType`ã®ãªãã¸ã§ã¯ãã 64åã¾ã§ããã¤ã§ãä¿æã§ãã¾ãã\n"
"  * [`Channel`](@ref) ãç©ºã§ããã°ãreaderã¯( [`take!`](@ref) é¢æ°ãããã§ã)ãã¼ã¿ãå©ç¨å¯è½ã«ãªãã¾ã§ãã­ãã¯ããã¾ãã\n"
"  * [`Channel`](@ref) ããã£ã±ãã®å ´å writerã¯ã([`put!`](@ref) ãèª­ãã§ã) ãã¼ã¿ãæ¸ãã¹ãã¼ã¹ãã§ããã¾ã§ãã­ãã¯ããã¾ãã\n"
"  * [`isready`](@ref) ã¯ããã£ã³ãã«åã®ä»»æã®ãªãã¸ã§ã¯ãã®æç¡ã«ã¤ãã¦ãã§ãã¯ããé¢æ°ã§ã [`wait`](@ref) é¢æ°ã¯ãªãã¸ã§ã¯ããå©ç¨å¯è½ã«ãªãã¾ã§å¾æ©ããããã®é¢æ°ã§ãã\n"
"  * [`Channel`](@ref) ã¯ãæåã¯ãªã¼ãã³ã®ç¶æã§ããã¤ã¾ãã[`take!`](@ref) é¢æ°ãã [`put!`](@ref) é¢æ°çµç±ã§ãèªç±ã«èª­ã¿æ¸ãã§ããç¶æã§ã[`close`](@ref) ã§ããã£ã³ãã«ãã¯ã­ã¼ãºã§ãã¾ãã\n"
"    ã¯ã­ã¼ãºããããã£ã³ãã«ã§ã¯ã[`put!`](@ref) ã¯å¤±æãã¾ããä¾ãã°:\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:98
#, no-wrap
msgid ""
"    ```julia-repl\n"
"    julia> c = Channel(2);\n"
msgstr ""
"    ```julia-repl\n"
"    julia> c = Channel(2);\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:101
#, no-wrap
msgid ""
"    julia> put!(c, 1) # `put!` on an open channel succeeds\n"
"    1\n"
msgstr ""
"    julia> put!(c, 1) # `put!` on an open channel succeeds\n"
"    1\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:103
#, no-wrap
msgid "    julia> close(c);\n"
msgstr "    julia> close(c);\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:109
#, no-wrap
msgid ""
"    julia> put!(c, 2) # `put!` on a closed channel throws an exception.\n"
"    ERROR: InvalidStateException(\"Channel is closed.\",:closed)\n"
"    Stacktrace:\n"
"    [...]\n"
"    ```\n"
msgstr ""
"    julia> put!(c, 2) # `put!` on a closed channel throws an exception.\n"
"    ERROR: InvalidStateException(\"Channel is closed.\",:closed)\n"
"    Stacktrace:\n"
"    [...]\n"
"    ```\n"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:112
msgid ""
"[`take!`](@ref) and [`fetch`](@ref) (which retrieves but does not remove the value) on a closed channel successfully return any existing "
"values until it is emptied. Continuing the above example:"
msgstr ""
"ã¯ã­ã¼ãºããããã£ã³ãã«ã¸ã®ã[`take!`](@ref) ã¨ [`fetch`](@ref) (å¤ãåå¾ã¯ãã¦ããåé¤ãã¾ãã)ã¯ããã£ã³ãã«ãç©ºã«ãªãã¾ã§ããã£ã³ãã«ã«å­"
"å¨ããå¤ãæ­£å¸¸ã«è¿ãã¾ããä¸ã®ä¾ãç¶ããã¨:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:116
#, no-wrap
msgid ""
"    ```julia-repl\n"
"    julia> fetch(c) # Any number of `fetch` calls succeed.\n"
"    1\n"
msgstr ""
"    ```julia-repl\n"
"    julia> fetch(c) # Any number of `fetch` calls succeed.\n"
"    1\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:119
#, no-wrap
msgid ""
"    julia> fetch(c)\n"
"    1\n"
msgstr ""
"    julia> fetch(c)\n"
"    1\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:122
#, no-wrap
msgid ""
"    julia> take!(c) # The first `take!` removes the value.\n"
"    1\n"
msgstr ""
"    julia> take!(c) # The first `take!` removes the value.\n"
"    1\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:128
#, no-wrap
msgid ""
"    julia> take!(c) # No more data available on a closed channel.\n"
"    ERROR: InvalidStateException(\"Channel is closed.\",:closed)\n"
"    Stacktrace:\n"
"    [...]\n"
"    ```\n"
msgstr ""
"    julia> take!(c) # No more data available on a closed channel.\n"
"    ERROR: InvalidStateException(\"Channel is closed.\",:closed)\n"
"    Stacktrace:\n"
"    [...]\n"
"    ```\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:132
msgid ""
"A `Channel` can be used as an iterable object in a `for` loop, in which case the loop runs as long as the `Channel` has data or is open. The "
"loop variable takes on all values added to the `Channel`. The `for` loop is terminated once the `Channel` is closed and emptied."
msgstr ""
"ãã£ã³ãã«ã¯ã`for`ã«ã¼ããªãã®ã¤ãã©ãã«ãªãã¸ã§ã¯ãã¨ãã¦ä½¿ããã¨ãã§ãããã£ã³ãã«ããã¼ã¿ãæã¤ãããªã¼ãã³ããã¦ããç¶æã§ããéããã«ã¼"
"ããåãã¾ããã«ã¼ãå¤æ°ã¯ãã£ã³ãã«ã«è¿½å ãããå¨ã¦ã®å¤ãå¼ãåãã¾ãã`for`ã«ã¼ããçµäºãããã®ã¯ããã£ã³ãã«ãéãããããã¼ã¿ãç©ºã«ãªã£ã"
"ã¨ãã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:134
msgid "For example, the following would cause the `for` loop to wait for more data:"
msgstr "ãã¨ãã°ãæ¬¡ã®å ´åã`for` ã«ã¼ãã¯(è¨³æ³¨: ãã£ã³ãã«ãéãããã¦ããªããã) ãããªããã¼ã¿ãå¾æ©ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:135
#, no-wrap
msgid ""
"julia> c = Channel{Int}(10);\n"
"\n"
"julia> foreach(i->put!(c, i), 1:3) # add a few entries\n"
"\n"
"julia> data = [i for i in c]\n"
msgstr ""
"julia> c = Channel{Int}(10);\n"
"\n"
"julia> foreach(i->put!(c, i), 1:3) # add a few entries\n"
"\n"
"julia> data = [i for i in c]\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:144
msgid "while this will return after reading all data:"
msgstr "å¯¾ãã¦ããã¡ãã¯ããã£ã³ãã«åã®å¨ã¦ã®ãã¼ã¿ãèª­ãã ããªã¿ã¼ã³ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:145
#, no-wrap
msgid ""
"julia> c = Channel{Int}(10);\n"
"\n"
"julia> foreach(i->put!(c, i), 1:3); # add a few entries\n"
"\n"
"julia> close(c);                    # `for` loops can exit\n"
"\n"
"julia> data = [i for i in c]\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
msgstr ""
"julia> c = Channel{Int}(10);\n"
"\n"
"julia> foreach(i->put!(c, i), 1:3); # add a few entries\n"
"\n"
"julia> close(c);                    # `for` loops can exit\n"
"\n"
"julia> data = [i for i in c]\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:164
msgid ""
"Consider a simple example using channels for inter-task communication. We start 4 tasks to process data from a single `jobs` channel. Jobs, "
"identified by an id (`job_id`), are written to the channel.  Each task in this simulation reads a `job_id`, waits for a random amount of "
"time and writes back a tuple of `job_id` and the simulated time to the results channel. Finally all the `results` are printed out."
msgstr ""
"ã¿ã¹ã¯ééä¿¡ã«ãã£ãã«ãä½¿ç¨ããç°¡åãªä¾ãèãã¦ã¿ã¾ããããç§ãã¡ã¯ãåä¸ã®`jobs`ãã£ãã«ãããã¼ã¿ãå¦çãã4ã¤ã®ã¿ã¹ã¯ãéå§ãã¾ããID "
"(`job_id`) ã«ãã£ã¦è­å¥ãããã¸ã§ãã¯ããã£ãã«ã«æ¸ãè¾¼ã¾ãã¾ãã ãã®ã·ãã¥ã¬ã¼ã·ã§ã³ã®åã¿ã¹ã¯ã¯`job_id`ãèª­ã¿åããã©ã³ãã ãªæéãã¦ã§ã¤"
"ããã¦ããã`job_id` ã®ã¿ãã«ã¨ã·ãã¥ã¬ã¼ããããæéã®é·ãã çµæãã£ãã«ã«æ¸ãæ»ãã¾ããæå¾ã«ããã¹ã¦ã®`results` ãå°å·ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:165
#, no-wrap
msgid ""
"julia> const jobs = Channel{Int}(32);\n"
"\n"
"julia> const results = Channel{Tuple}(32);\n"
"\n"
"julia> function do_work()\n"
"           for job_id in jobs\n"
"               exec_time = rand()\n"
"               sleep(exec_time)                # simulates elapsed time doing actual work\n"
"                                               # typically performed externally.\n"
"               put!(results, (job_id, exec_time))\n"
"           end\n"
"       end;\n"
"\n"
"julia> function make_jobs(n)\n"
"           for i in 1:n\n"
"               put!(jobs, i)\n"
"           end\n"
"       end;\n"
"\n"
"julia> n = 12;\n"
"\n"
"julia> @async make_jobs(n); # feed the jobs channel with \"n\" jobs\n"
"\n"
"julia> for i in 1:4 # start 4 tasks to process requests in parallel\n"
"           @async do_work()\n"
"       end\n"
"\n"
"julia> @elapsed while n > 0 # print out results\n"
"           job_id, exec_time = take!(results)\n"
"           println(\"$job_id finished in $(round(exec_time; digits=2)) seconds\")\n"
"           global n = n - 1\n"
"       end\n"
"4 finished in 0.22 seconds\n"
"3 finished in 0.45 seconds\n"
"1 finished in 0.5 seconds\n"
"7 finished in 0.14 seconds\n"
"2 finished in 0.78 seconds\n"
"5 finished in 0.9 seconds\n"
"9 finished in 0.36 seconds\n"
"6 finished in 0.87 seconds\n"
"8 finished in 0.79 seconds\n"
"10 finished in 0.64 seconds\n"
"12 finished in 0.5 seconds\n"
"11 finished in 0.97 seconds\n"
"0.029772311\n"
msgstr ""
"julia> const jobs = Channel{Int}(32);\n"
"\n"
"julia> const results = Channel{Tuple}(32);\n"
"\n"
"julia> function do_work()\n"
"           for job_id in jobs\n"
"               exec_time = rand()\n"
"               sleep(exec_time)                # simulates elapsed time doing actual work\n"
"                                               # typically performed externally.\n"
"               put!(results, (job_id, exec_time))\n"
"           end\n"
"       end;\n"
"\n"
"julia> function make_jobs(n)\n"
"           for i in 1:n\n"
"               put!(jobs, i)\n"
"           end\n"
"       end;\n"
"\n"
"julia> n = 12;\n"
"\n"
"julia> @async make_jobs(n); # feed the jobs channel with \"n\" jobs\n"
"\n"
"julia> for i in 1:4 # start 4 tasks to process requests in parallel\n"
"           @async do_work()\n"
"       end\n"
"\n"
"julia> @elapsed while n > 0 # print out results\n"
"           job_id, exec_time = take!(results)\n"
"           println(\"$job_id finished in $(round(exec_time; digits=2)) seconds\")\n"
"           global n = n - 1\n"
"       end\n"
"4 finished in 0.22 seconds\n"
"3 finished in 0.45 seconds\n"
"1 finished in 0.5 seconds\n"
"7 finished in 0.14 seconds\n"
"2 finished in 0.78 seconds\n"
"5 finished in 0.9 seconds\n"
"9 finished in 0.36 seconds\n"
"6 finished in 0.87 seconds\n"
"8 finished in 0.79 seconds\n"
"10 finished in 0.64 seconds\n"
"12 finished in 0.5 seconds\n"
"11 finished in 0.97 seconds\n"
"0.029772311\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:218
msgid ""
"The current version of Julia multiplexes all tasks onto a single OS thread. Thus, while tasks involving I/O operations benefit from parallel "
"execution, compute bound tasks are effectively executed sequentially on a single OS thread. Future versions of Julia may support scheduling "
"of tasks on multiple threads, in which case compute bound tasks will see benefits of parallel execution too."
msgstr ""
"ç¾å¨ã®ãã¼ã¸ã§ã³ã® Julia ã¯ããã¹ã¦ã®ã¿ã¹ã¯ãåä¸ã® OS ã¹ã¬ããã«å¤éåãã¾ãããããã£ã¦ãI/O æä½ãå«ãã¿ã¹ã¯ã¯ä¸¦åå®è¡ã®æ©æµãåãã¾ããã"
"ãã¤ã³ããããã¿ã¹ã¯ã¯åä¸ã® OS ã¹ã¬ããã§å¹æçã«é çªã«å®è¡ããã¾ããJulia ã®å°æ¥ã®ãã¼ã¸ã§ã³ã§ã¯ãè¤æ°ã®ã¹ã¬ããã§ã®ã¿ã¹ã¯ã®ã¹ã±ã¸ã¥ã¼ãªã³"
"ã°ããµãã¼ããããããããã¾ããã"

#. type: Title #
#: ext/julia/doc/src/manual/parallel-computing.md:219
#, no-wrap
msgid "[Multi-Threading (Experimental)](@id man-multithreading)"
msgstr "[ãã«ãã¹ã¬ãã(å®é¨çå®è£)](@id man-multithreading)"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:223
msgid ""
"In addition to tasks Julia forwards natively supports multi-threading.  Note that this section is experimental and the interfaces may change "
"in the future."
msgstr ""
"ã¿ã¹ã¯ã«å ãã¦ãJulia ã¯ãã«ãã¹ã¬ããããã¤ãã£ãã«ãµãã¼ããã¾ãã ãã®ã»ã¯ã·ã§ã³ã¯å®é¨çãªãã®ã§ãããã¤ã³ã¿ã¼ãã§ã¤ã¹ã¯å°æ¥å¤æ´ãããå¯è½"
"æ§ããããã¨ã«æ³¨æãã¦ãã ããã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:224
#, no-wrap
msgid "Setup"
msgstr "ã»ããã¢ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:228
msgid "By default, Julia starts up with a single thread of execution. This can be verified by using the command [`Threads.nthreads()`](@ref):"
msgstr "ããã©ã«ãã§ã¯ãJulia ã¯åä¸ã®å®è¡ã¹ã¬ããã§èµ·åãã¾ããããã¯ãã³ãã³ã [`Threads.nthreads()`](@ref) ãä½¿ç¨ãã¦ç¢ºèªã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:229
#, no-wrap
msgid ""
"julia> Threads.nthreads()\n"
"1\n"
msgstr ""
"julia> Threads.nthreads()\n"
"1\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:236
msgid ""
"The number of threads Julia starts up with is controlled by an environment variable called `JULIA_NUM_THREADS`.  Now, let's start up Julia "
"with 4 threads:"
msgstr ""
"Julia ãéå§ããã¹ã¬ããã®æ°ã¯ã`JULIA_NUM_THREADS` ã¨ããç°å¢å¤æ°ã«ãã£ã¦å¶å¾¡ããã¾ãã ãã¦ã4ã¤ã®ã¹ã¬ããã§ã¸ã¥ãªã¢ãèµ·åãã¦ã¿ã¾ããã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/parallel-computing.md:237
#, no-wrap
msgid "bash"
msgstr "bash"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:237
#, no-wrap
msgid "export JULIA_NUM_THREADS=4\n"
msgstr "export JULIA_NUM_THREADS=4\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:244
msgid ""
"(The above command works on bourne shells on Linux and OSX. Note that if you're using a C shell on these platforms, you should use the "
"keyword `set` instead of `export`. If you're on Windows, start up the command line in the location of `julia.exe` and use `set` instead of "
"`export`.)"
msgstr ""
"(ä¸è¨ã®ã³ãã³ãã¯ãLinux ããã³ OSX ä¸ã®ãã¼ã³ã·ã§ã«ã§åä½ãã¾ãããããã®ãã©ãããã©ã¼ã ã§ C ã·ã§ã«ãä½¿ç¨ãã¦ããå ´åã¯ã`export`ã®ä»£ãã"
"ã« `set` ã¨ããã­ã¼ã¯ã¼ããä½¿ç¨ããå¿è¦ãããã¾ããWindows ãä½¿ç¨ãã¦ããå ´åã¯ã`julia.exe` ã®å ´æã§ã³ãã³ã ã©ã¤ã³ãèµ·åãã`export` ã®ä»£ã"
"ãã« `set` ãä½¿ç¨ãã¾ãã)"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:246
msgid "Let's verify there are 4 threads at our disposal."
msgstr "4ã¤ã®ã¹ã¬ããããããã¨ãç¢ºèªãã¦ã¿ã¾ãããã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:247
#, no-wrap
msgid ""
"julia> Threads.nthreads()\n"
"4\n"
msgstr ""
"julia> Threads.nthreads()\n"
"4\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:253
msgid "But we are currently on the master thread. To check, we use the function [`Threads.threadid`](@ref)"
msgstr "ããããç¾å¨ã¯ãã¹ã¿ã¼ã¹ã¬ããã«å¥ã£ã¦ãã¾ããç¢ºèªããã«ã¯ãé¢æ° [`Threads.threadid`](@ref)ãä½¿ç¨ãã¾ã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:254
#, no-wrap
msgid ""
"julia> Threads.threadid()\n"
"1\n"
msgstr ""
"julia> Threads.threadid()\n"
"1\n"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:259
#, no-wrap
msgid "The `@threads` Macro"
msgstr "The `@threads` ãã¯ã­"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:262
msgid "Let's work a simple example using our native threads. Let us create an array of zeros:"
msgstr "ãã¤ãã£ãã¹ã¬ãããä½¿ç¨ãã¦ç°¡åãªä¾ãè¦ã¦ã¿ã¾ããããã¼ã­ã®éåãä½æãã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:263
#, no-wrap
msgid ""
"julia> a = zeros(10)\n"
"10-element Array{Float64,1}:\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
msgstr ""
"julia> a = zeros(10)\n"
"10-element Array{Float64,1}:\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"
" 0.0\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:280
msgid "Let us operate on this array simultaneously using 4 threads. We'll have each thread write its thread ID into each location."
msgstr "4ã¤ã®ã¹ã¬ãããä½¿ç¨ãã¦ããã®éåãåæã«æä½ãã¦ã¿ã¾ããããåã¹ã¬ããã§åè¦ç´ ã«ã¹ã¬ãã ID ãæ¸ãè¾¼ã¿ã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:283
msgid ""
"Julia supports parallel loops using the [`Threads.@threads`](@ref) macro. This macro is affixed in front of a `for` loop to indicate to "
"Julia that the loop is a multi-threaded region:"
msgstr ""
"Julia ã¯ [`Threads.@threads`](@ref) ãã¯ã­ãä½¿ç¨ããä¸¦åã«ã¼ãããµãã¼ããã¦ãã¾ãããã®ãã¯ã­ã`for` ã«ã¼ãã®åã«è¿½å ããã¨ãã«ã¼ãããã«ã"
"ã¹ã¬ããã§å®è¡ãã¹ãé åã§ãããã¨ã Julia ã«æç¤ºã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:284
#, no-wrap
msgid ""
"julia> Threads.@threads for i = 1:10\n"
"           a[i] = Threads.threadid()\n"
"       end\n"
msgstr ""
"julia> Threads.@threads for i = 1:10\n"
"           a[i] = Threads.threadid()\n"
"       end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:292
msgid "The iteration space is split amongst the threads, after which each thread writes its thread ID to its assigned locations:"
msgstr "ã¤ãã¬ã¼ã·ã§ã³ã¹ãã¼ã¹ã¯ã¹ã¬ããéã§åå²ããããã®å¾ãåã¹ã¬ããã¯å²ãå½ã¦ãããå ´æã«ã¹ã¬ãã ID ãæ¸ãè¾¼ã¿ã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:293
#, no-wrap
msgid ""
"julia> a\n"
"10-element Array{Float64,1}:\n"
" 1.0\n"
" 1.0\n"
" 1.0\n"
" 2.0\n"
" 2.0\n"
" 2.0\n"
" 3.0\n"
" 3.0\n"
" 4.0\n"
" 4.0\n"
msgstr ""
"julia> a\n"
"10-element Array{Float64,1}:\n"
" 1.0\n"
" 1.0\n"
" 1.0\n"
" 2.0\n"
" 2.0\n"
" 2.0\n"
" 3.0\n"
" 3.0\n"
" 4.0\n"
" 4.0\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:309
msgid "Note that [`Threads.@threads`](@ref) does not have an optional reduction parameter like [`@distributed`](@ref)."
msgstr "[`Threads.@threads`](@ref)ã«ã¯ã[`@distributed`](@ref)ã®ãããªãªãã·ã§ã³ã®ç¸®å°ãã©ã¡ã¼ã¿ã¼ããªããã¨ã«æ³¨æãã¦ãã ããã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:310
#, no-wrap
msgid "Atomic Operations"
msgstr "ã¢ãããã¯æä½"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:316
msgid ""
"Julia supports accessing and modifying values *atomically*, that is, in a thread-safe way to avoid [race conditions](https://en.wikipedia."
"org/wiki/Race_condition). A value (which must be of a primitive type) can be wrapped as [`Threads.Atomic`](@ref) to indicate it must be "
"accessed in this way.  Here we can see an example:"
msgstr ""
"Julia ã¯ã*ã¢ãããã¯ãª*ãã¤ã¾ãã[ç«¶åç¶æ](https://en.wikipedia.org/wiki/Race_condition)ãé¿ããããã®ã¹ã¬ããã»ã¼ããªæ¹æ³ã§ãå¤ã®ã¢ã¯ã»ã¹"
"ã¨å¤æ´ããµãã¼ããã¦ãã¾ã ãã¢ãããã¯ã«ã¢ã¯ã»ã¹ããå¿è¦ããããã¨ãç¤ºãå¤ (ããªããã£ãåã§ããå¿è¦ãããã¾ã) ã [`Threads.Atomic`](@ref) "
"ã¨ãã¦ã©ããã§ãã¾ãã ä¾ãè¦ã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:317
#, no-wrap
msgid ""
"julia> i = Threads.Atomic{Int}(0);\n"
"\n"
"julia> ids = zeros(4);\n"
"\n"
"julia> old_is = zeros(4);\n"
"\n"
"julia> Threads.@threads for id in 1:4\n"
"           old_is[id] = Threads.atomic_add!(i, id)\n"
"           ids[id] = id\n"
"       end\n"
"\n"
"julia> old_is\n"
"4-element Array{Float64,1}:\n"
" 0.0\n"
" 1.0\n"
" 7.0\n"
" 3.0\n"
"\n"
"julia> ids\n"
"4-element Array{Float64,1}:\n"
" 1.0\n"
" 2.0\n"
" 3.0\n"
" 4.0\n"
msgstr ""
"julia> i = Threads.Atomic{Int}(0);\n"
"\n"
"julia> ids = zeros(4);\n"
"\n"
"julia> old_is = zeros(4);\n"
"\n"
"julia> Threads.@threads for id in 1:4\n"
"           old_is[id] = Threads.atomic_add!(i, id)\n"
"           ids[id] = id\n"
"       end\n"
"\n"
"julia> old_is\n"
"4-element Array{Float64,1}:\n"
" 0.0\n"
" 1.0\n"
" 7.0\n"
" 3.0\n"
"\n"
"julia> ids\n"
"4-element Array{Float64,1}:\n"
" 1.0\n"
" 2.0\n"
" 3.0\n"
" 4.0\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:347
msgid ""
"Had we tried to do the addition without the atomic tag, we might have gotten the wrong answer due to a race condition. An example of what "
"would happen if we didn't avoid the race:"
msgstr ""
"ã¢ãããã¯ã¿ã°ãªãã§å ç®ãè©¦ãã¨ãç«¶åã«ãã£ã¦ééã£ãç­ããå¾ãããããããã¾ãããç«¶åãé¿ããªãã£ãå ´åã«ã©ããªããã®ä¾ã¯ä¸è¨ã®éãã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:348
#, no-wrap
msgid ""
"julia> using Base.Threads\n"
"\n"
"julia> nthreads()\n"
"4\n"
"\n"
"julia> acc = Ref(0)\n"
"Base.RefValue{Int64}(0)\n"
"\n"
"julia> @threads for i in 1:1000\n"
"          acc[] += 1\n"
"       end\n"
"\n"
"julia> acc[]\n"
"926\n"
"\n"
"julia> acc = Atomic{Int64}(0)\n"
"Atomic{Int64}(0)\n"
"\n"
"julia> @threads for i in 1:1000\n"
"          atomic_add!(acc, 1)\n"
"       end\n"
"\n"
"julia> acc[]\n"
"1000\n"
msgstr ""
"julia> using Base.Threads\n"
"\n"
"julia> nthreads()\n"
"4\n"
"\n"
"julia> acc = Ref(0)\n"
"Base.RefValue{Int64}(0)\n"
"\n"
"julia> @threads for i in 1:1000\n"
"          acc[] += 1\n"
"       end\n"
"\n"
"julia> acc[]\n"
"926\n"
"\n"
"julia> acc = Atomic{Int64}(0)\n"
"Atomic{Int64}(0)\n"
"\n"
"julia> @threads for i in 1:1000\n"
"          atomic_add!(acc, 1)\n"
"       end\n"
"\n"
"julia> acc[]\n"
"1000\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:380
#, no-wrap
msgid ""
"!!! note\n"
"    Not *all* primitive types can be wrapped in an `Atomic` tag. Supported types\n"
"    are `Int8`, `Int16`, `Int32`, `Int64`, `Int128`, `UInt8`, `UInt16`, `UInt32`,\n"
"    `UInt64`, `UInt128`, `Float16`, `Float32`, and `Float64`. Additionally,\n"
"    `Int128` and `UInt128` are not supported on AAarch32 and ppc64le.\n"
msgstr ""
"!!!ã¡ã¢\n"
"    *ãã¹ã¦ã®*ããªããã£ãåã `Atomic` ã¿ã°ã§ã©ããã§ããããã§ã¯ããã¾ããã\n"
"    ãµãã¼ãããã¦ããåã¯`Int8`ã`Int16`ã`Int32`ã`Int64`ã`Int128`ã`UInt8`ã`UInt16`ã`UInt32`ã`UInt64`ã`UInt128`ã`Float16`ã`Float32`ãããã³`Float64`ã§ãã\n"
"    ããã« `Int128` ããã³ `UInt128` ã¯ AAarch32 ããã³ ppc64le ã§ã¯ãµãã¼ãããã¦ãã¾ããã\n"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:381
#, no-wrap
msgid "Side effects and mutable function arguments"
msgstr "å¯ä½ç¨ã¨å¤æ´å¯è½ãªé¢æ°å¼æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:391
msgid ""
"When using multi-threading we have to be careful when using functions that are not [pure](https://en.wikipedia.org/wiki/Pure_function) as we "
"might get a wrong answer.  For instance functions that have their [name ending with `!`](https://docs.julialang.org/en/latest/manual/style-"
"guide/#Append-!-to-names-of-functions-that-modify-their-arguments-1)  by convention modify their arguments and thus are not pure. However, "
"there are functions that have side effects and their name does not end with `!`. For instance [`findfirst(regex, str)`](@ref) mutates its "
"`regex` argument or [`rand()`](@ref) changes `Base.GLOBAL_RNG` :"
msgstr ""
"ãã«ãã¹ã¬ãããä½¿ç¨æã[ç´ç²](https://en.wikipedia.org/wiki/Pure_function) ã§ãªãé¢æ°ãä½¿ãå ´åã«ã¯ãééã£ãç­ããå¾ãããå¯è½æ§ãããã®"
"ã§ãæ³¨æãå¿è¦ã§ããä¾ãã°ã [ååã`!`ã§çµãã](https://docs.julialang.org/en/latest/manual/style-guide/#Append-!-to-names-of-functions-"
"that-modify-their-arguments-1)é¢æ°ã¯ãæ£ç¿çã«å¼æ°ã«æå®ãããå¤ãæ¸ãæãããããç´ç²ãªé¢æ°ã§ã¯ããã¾ãããããããå¯ä½ç¨ãæã¤ã«ãé¢ãã"
"ãããã®ååã`!`ã§çµãããªãé¢æ°ãããã¾ããä¾ãã°ã [`findfirst(regex, str)`](@ref) ã¯ãå¼æ° `regex`ãå¤æ´ãã¾ããã[`rand()`](@ref) ã¯ã"
"`Base.GLOBAL_RNG`ãå¤æ´ãã¾ã :"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:392
#, no-wrap
msgid ""
"julia> using Base.Threads\n"
"\n"
"julia> nthreads()\n"
"4\n"
"\n"
"julia> function f()\n"
"           s = repeat([\"123\", \"213\", \"231\"], outer=1000)\n"
"           x = similar(s, Int)\n"
"           rx = r\"1\"\n"
"           @threads for i in 1:3000\n"
"               x[i] = findfirst(rx, s[i]).start\n"
"           end\n"
"           count(v -> v == 1, x)\n"
"       end\n"
"f (generic function with 1 method)\n"
"\n"
"julia> f() # the correct result is 1000\n"
"1017\n"
"\n"
"julia> function g()\n"
"           a = zeros(1000)\n"
"           @threads for i in 1:1000\n"
"               a[i] = rand()\n"
"           end\n"
"           length(unique(a))\n"
"       end\n"
"g (generic function with 1 method)\n"
"\n"
"julia> Random.seed!(1); g() # the result for a single thread is 1000\n"
"781\n"
msgstr ""
"julia> using Base.Threads\n"
"\n"
"julia> nthreads()\n"
"4\n"
"\n"
"julia> function f()\n"
"           s = repeat([\"123\", \"213\", \"231\"], outer=1000)\n"
"           x = similar(s, Int)\n"
"           rx = r\"1\"\n"
"           @threads for i in 1:3000\n"
"               x[i] = findfirst(rx, s[i]).start\n"
"           end\n"
"           count(v -> v == 1, x)\n"
"       end\n"
"f (generic function with 1 method)\n"
"\n"
"julia> f() # the correct result is 1000\n"
"1017\n"
"\n"
"julia> function g()\n"
"           a = zeros(1000)\n"
"           @threads for i in 1:1000\n"
"               a[i] = rand()\n"
"           end\n"
"           length(unique(a))\n"
"       end\n"
"g (generic function with 1 method)\n"
"\n"
"julia> Random.seed!(1); g() # the result for a single thread is 1000\n"
"781\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:427
msgid ""
"In such cases one should redesign the code to avoid the possibility of a race condition or use [synchronization primitives](https://docs."
"julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1)."
msgstr ""
"ãã®ãããªå ´åã¯ãç«¶åç¶æã«é¥ãã®å¯è½æ§ãé¿ããããã«ã³ã¼ããåè¨­è¨ãããã[åæããªããã£ã](https://docs.julialang.org/en/latest/base/"
"multi-threading/#Synchronization-Primitives-1)ãä½¿ã£ã¦ãã ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:430
msgid "For example in order to fix `findfirst` example above one needs to have a separate copy of `rx` variable for each thread:"
msgstr "ãã¨ãã°ãä¸è¨ã® `findfirst` ã®ä¾ãè§£æ±ºããã«ã¯ãã¹ã¬ãããã¨ã«å¤æ°`rx`ãå¥ãã«ã³ãã¼ãã¦ä½¿ãå¿è¦ãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:431
#, no-wrap
msgid ""
"julia> function f_fix()\n"
"             s = repeat([\"123\", \"213\", \"231\"], outer=1000)\n"
"             x = similar(s, Int)\n"
"             rx = [Regex(\"1\") for i in 1:nthreads()]\n"
"             @threads for i in 1:3000\n"
"                 x[i] = findfirst(rx[threadid()], s[i]).start\n"
"             end\n"
"             count(v -> v == 1, x)\n"
"         end\n"
"f_fix (generic function with 1 method)\n"
"\n"
"julia> f_fix()\n"
"1000\n"
msgstr ""
"julia> function f_fix()\n"
"             s = repeat([\"123\", \"213\", \"231\"], outer=1000)\n"
"             x = similar(s, Int)\n"
"             rx = [Regex(\"1\") for i in 1:nthreads()]\n"
"             @threads for i in 1:3000\n"
"                 x[i] = findfirst(rx[threadid()], s[i]).start\n"
"             end\n"
"             count(v -> v == 1, x)\n"
"         end\n"
"f_fix (generic function with 1 method)\n"
"\n"
"julia> f_fix()\n"
"1000\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:449
msgid ""
"We now use `Regex(\"1\")` instead of `r\"1\"` to make sure that Julia creates separate instances of `Regex` object for each entry of `rx` "
"vector."
msgstr ""
"`r\"1\"`ã®ä»£ããã«`Regex(\"1\")`ãä½¿ã£ã¦ Julia ã `rx`ãã¯ãã«ã®ããããã®ã¨ã³ããªã«å¯¾ãã¦ãå¥ãã®`Regex`ãªãã¸ã§ã¯ããçæããããã«ãã¦ãã¾"
"ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:453
msgid ""
"The case of `rand` is a bit more complex as we have to ensure that each thread uses non-overlapping pseudorandom number sequences. This can "
"be simply ensured by using `Future.randjump` function:"
msgstr ""
"`rand`ã®ä¾ã«ã¤ãã¦ã¯ãããå°ãè¤éã§ããåã¹ã¬ãããéè¤ããªãæ¬ä¼¼ä¹±æ°ã·ã¼ã±ã³ã¹ãä½¿ç¨ããããã«ããå¿è¦ãããããã§ããããã¯ãåã« `Future."
"randjump` é¢æ°ãä½¿ç¨ãã¦ä¿è¨¼ãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:455
#, no-wrap
msgid ""
"julia> using Random; import Future\n"
"\n"
"julia> function g_fix(r)\n"
"           a = zeros(1000)\n"
"           @threads for i in 1:1000\n"
"               a[i] = rand(r[threadid()])\n"
"           end\n"
"           length(unique(a))\n"
"       end\n"
"g_fix (generic function with 1 method)\n"
"\n"
"julia>  r = let m = MersenneTwister(1)\n"
"                [m; accumulate(Future.randjump, fill(big(10)^20, nthreads()-1), init=m)]\n"
"            end;\n"
"\n"
"julia> g_fix(r)\n"
"1000\n"
msgstr ""
"julia> using Random; import Future\n"
"\n"
"julia> function g_fix(r)\n"
"           a = zeros(1000)\n"
"           @threads for i in 1:1000\n"
"               a[i] = rand(r[threadid()])\n"
"           end\n"
"           length(unique(a))\n"
"       end\n"
"g_fix (generic function with 1 method)\n"
"\n"
"julia>  r = let m = MersenneTwister(1)\n"
"                [m; accumulate(Future.randjump, fill(big(10)^20, nthreads()-1), init=m)]\n"
"            end;\n"
"\n"
"julia> g_fix(r)\n"
"1000\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:477
msgid ""
"We pass the `r` vector to `g_fix` as generating several RGNs is an expensive operation so we do not want to repeat it every time we run the "
"function."
msgstr ""
"`r`ãã¯ãã«ã`g_fix`ã«æ¸¡ãã¦ããã®ã¯ãè¤æ°ã® RGN ãçæããã®ãã³ã¹ãã®ãããå¦çã§ããããã§ãé¢æ°ãå®è¡ãããã³ã«RGNã®çæãç¹°ãè¿ãå¿è¦ã¯"
"ããã¾ããã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:478
#, no-wrap
msgid "@threadcall (Experimental)"
msgstr "@threadcall(å®é¨çãªå®è£)"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:485
msgid ""
"All I/O tasks, timers, REPL commands, etc are multiplexed onto a single OS thread via an event loop. A patched version of libuv ([http://"
"docs.libuv.org/en/v1.x/](http://docs.libuv.org/en/v1.x/))  provides this functionality. Yield points provide for co-operatively scheduling "
"multiple tasks onto the same OS thread. I/O tasks and timers yield implicitly while waiting for the event to occur. Calling [`yield`](@ref) "
"explicitly allows for other tasks to be scheduled."
msgstr ""
"Julia ã§ã¯ããã¹ã¦ã® I/O ã¿ã¹ã¯ãã¿ã¤ãã¼ãREPL ã³ãã³ããªã©ã¯ãã¤ãã³ã ã«ã¼ããä»ãã¦ 1 ã¤ã® OS ã¹ã¬ããã«å¤éåããã¦ãã¾ããããã¯ã"
"libuv ([http://docs.libuv.org/en/v1.x/])ã®ããããã¼ã¸ã§ã³ã§æä¾ãã¦ããæ©è½ã§ãã\"yield\" ã¯ãè¤æ°ã®ã¿ã¹ã¯ãåã OS ã¹ã¬ããã«åæã«ã¹ã±"
"ã¸ã¥ã¼ãªã³ã°ããããã®æ©è½ãæä¾ãã¾ããI/O ã¿ã¹ã¯ã¨ã¿ã¤ãã¼ã¯ã¤ãã³ããçºçããã®ãå¾æ©ãã¦ããéã«æé»çã«çæããã¾ãã[`yield`](@ref)ãå¼"
"ã³åºãã¨ã(è¨³èè¨»: ç¾å¨å¦çãã¦ããã¿ã¹ã¯ãä¸­æ­¢ãããã®ã§) ä»ã®ã¿ã¹ã¯ãã¹ã±ã¸ã¥ã¼ã«ãããããã«æç¤ºçã«è¨±å¯ãä¸ãããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:490
msgid ""
"Thus, a task executing a [`ccall`](@ref) effectively prevents the Julia scheduler from executing any other tasks till the call returns. This "
"is true for all calls into external libraries. Exceptions are calls into custom C code that call back into Julia (which may then yield) or C "
"code that calls `jl_yield()` (C equivalent of [`yield`](@ref))."
msgstr ""
"ãããã£ã¦ã[`ccall`](@ref)ãå®è¡ããã¿ã¹ã¯ã¯ãå¼ã³åºãããå¶å¾¡ãæ»ãã¾ã§ Julia ã¹ã±ã¸ã¥ã¼ã©ãä»ã®ã¿ã¹ã¯ãå®è¡ããã®ãå¹æçã«é²ãã¾ãããã"
"ã¯ãå¤é¨ã©ã¤ãã©ãªã¸ã®ãã¹ã¦ã®å¼ã³åºãã«å½ã¦ã¯ã¾ãã¾ããä¾å¤ã¯ãéã«Julia ãå¼ã³åºãã«ã¹ã¿ã  C ã³ã¼ããå¼ã³åºãå ´å (ãã®å¾ããã¨ãã yield "
"ããå¯è½æ§ãããã¾ã) ã¾ãã¯ `jl_yield()`(ããã¯[`yield`](@ref) ã®Cãã¼ã¸ã§ã³ã§ã) ãå¼ã³åºãCã³ã¼ãããå¼ã³åºãå ´åã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:494
msgid ""
"Note that while Julia code runs on a single thread (by default), libraries used by Julia may launch their own internal threads. For example, "
"the BLAS library may start as many threads as there are cores on a machine."
msgstr ""
"Julia ã³ã¼ãã¯(æ¢å®ã§ã¯) åä¸ã®ã¹ã¬ãã ã§å®è¡ããã¾ãããJulia ãä½¿ç¨ããã©ã¤ãã©ãªã¯ç¬èªã®åé¨ã¹ã¬ãããèµ·åããå ´åããããã¨ã«æ³¨æãã¦ã"
"ã ããããã¨ãã°ãBLAS ã©ã¤ãã©ãªã¯ããã·ã³ä¸ã®ã³ã¢ã¨åãæ°ã®ã¹ã¬ãããéå§ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:502
msgid ""
"The [`@threadcall`](@ref) macro addresses scenarios where we do not want a [`ccall`](@ref) to block the main Julia event loop. It schedules "
"a C function for execution in a separate thread. A threadpool with a default size of 4 is used for this. The size of the threadpool is "
"controlled via environment variable `UV_THREADPOOL_SIZE`. While waiting for a free thread, and during function execution once a thread is "
"available, the requesting task (on the main Julia event loop) yields to other tasks. Note that `@threadcall` does not return till the "
"execution is complete. From a user point of view, it is therefore a blocking call like other Julia APIs."
msgstr ""
"[`@threadcall`](@ref) ãã¯ã­ã¯ã [`ccall`](@ref)ããJuliaã®ã¡ã¤ã³ã¤ãã³ãã«ã¼ãããã­ãã¯ãã¦æ¬²ãããªãæã«ä½¿ããã¨ãã§ãã¾ããå¥ã®ã¹ã¬ããã§"
"å®è¡ãã C é¢æ°ãã¹ã±ã¸ã¥ã¼ã«ãã¾ããããã«ã¯ãããã©ã«ãã»ãµã¤ãºã 4 ã®ã¹ã¬ããã»ãã¼ã«ãä½¿ç¨ããã¾ããã¹ã¬ãããã¼ã«ã®ãµã¤ãºã¯ãç°å¢å¤æ° "
"`UV_THREADPOOL_SIZE`  ã§è¨­å®ã§ãã¾ããã¹ã¬ãããç©ºãã®ãå¾æ©ãã¦ããéãããã³ã¹ã¬ãããä½¿ç¨å¯è½ã«ãªã£ã¦é¢æ°ãå®è¡ããã¦ããéã«ã(ã¡ã¤ã³ "
"Julia ã¤ãã³ã ã«ã¼ãä¸ã§)Cé¢æ°ã®ã³ã¼ã«ãè¦æ±ããã¿ã¹ã¯ã¯ä»ã®ã¿ã¹ã¯ã«yield ãã¾ãã`@threadcall`ãä½¿ãã¨ããã®å®è¡å®äºã¾ã§å¶å¾¡ãæ»ããªããã¨"
"ã«æ³¨æãã¦ãã ãããããã£ã¦ãã¦ã¼ã¶ã¼ã®è¦³ç¹ããè¦ãã¨ãä»ã® Julia API ã¨åæ§ã«ãã­ãã­ã³ã°å¼ã³åºããè¡ããã¾ãããã«è¦ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:504
msgid "It is very important that the called function does not call back into Julia, as it will segfault."
msgstr "éå¸¸ã«éè¦ãªãã¨ã§ãããå¼ã³åºãããé¢æ°ãã»ã°ã¡ã³ãã¼ã·ã§ã³ãã©ã«ãã«ãªã£ã¦ããJulia ã«ã³ã¼ã«ããã¯ãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:506
msgid "`@threadcall` may be removed/changed in future versions of Julia."
msgstr "`@threadcall`ã¯ãJulia å°æ¥ã®ãã¼ã¸ã§ã³ã§åé¤/å¤æ´ãããå¯è½æ§ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:511
msgid ""
"An implementation of distributed memory parallel computing is provided by module `Distributed` as part of the standard library shipped with "
"Julia."
msgstr "Julia ä»å±ã®æ¨æºã©ã¤ãã©ãªã®ä¸é¨ã§ãããã¢ã¸ã¥ã¼ã« 'Distributed' ãç¨ãã¦ãåæ£ã¡ã¢ãªä¸¦åå¦çãå®è£ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:522
msgid ""
"Most modern computers possess more than one CPU, and several computers can be combined together in a cluster. Harnessing the power of these "
"multiple CPUs allows many computations to be completed more quickly. There are two major factors that influence performance: the speed of "
"the CPUs themselves, and the speed of their access to memory. In a cluster, it's fairly obvious that a given CPU will have fastest access to "
"the RAM within the same computer (node). Perhaps more surprisingly, similar issues are relevant on a typical multicore laptop, due to "
"differences in the speed of main memory and the [cache](https://www.akkadia.org/drepper/cpumemory.pdf). Consequently, a good multiprocessing "
"environment should allow control over the \"ownership\" of a chunk of memory by a particular CPU.  Julia provides a multiprocessing "
"environment based on message passing to allow programs to run on multiple processes in separate memory domains at once."
msgstr ""
"ç¾ä»£ã®ã³ã³ãã¥ã¼ã¿ã®å¤ãã¯è¤æ°ã® CPU ãæ­è¼ãã¦ãããè¤æ°ã®ã³ã³ãã¥ã¼ã¿ãã¯ã©ã¹ã¿åã§çµã¿åããããã¨ãã§ãã¾ãããããã®è¤æ°ã® CPU ã®ãã¯ã¼"
"ãå©ç¨ãããã¨ã§ãå¤ãã®è¨ç®ãããè¿éã«å®äºã§ãã¾ããããã©ã¼ãã³ã¹ã«å½±é¿ãä¸ããä¸»ãªè¦å ã«ã¯ãCPU èªä½ã®éåº¦ã¨ã¡ã¢ãªã¸ã®ã¢ã¯ã»ã¹éåº¦ã® 2 ã¤"
"ãããã¾ããã¯ã©ã¹ã¿ã§ã¯ããã CPU ãæéã§ã¢ã¯ã»ã¹ã§ããã®ã¯ãCPUã¨åãã³ã³ãã¥ã¼ã¿(ãã¼ã)åã®RAMã§ãããã¨ã¯æããã§ããããé©ãã¹ããã¨"
"ã«ãå¸åçãªãã«ãã³ã¢ã©ãããããã§ããã¡ã¤ã³ã¡ã¢ãªã¨[ã­ã£ãã·ã¥](https://www.akkadia.org/drepper/cpumemory.pdf)ã®éåº¦ã®éãã«ãã£ã¦åæ§ã®å"
"é¡ãèµ·ãã¦ãã¾ãããããã£ã¦ãåªãããã«ããã­ã»ãã·ã³ã°ç°å¢ã§ã¯ãç¹å®ã® CPU ã«ããã¡ã¢ãªãã£ã³ã¯ã®ãæææ¨©ããå¶å¾¡ã§ããå¿è¦ãããã¾ãã "
"Julia ã¯ãã¡ãã»ã¼ã¸ã»ããã·ã³ã°ã«åºã¥ããã«ããã­ã»ãã·ã³ã°ç°å¢ãæä¾ãããã­ã°ã©ã ãå¥ãã®ã¡ã¢ãªã»ãã¡ã¤ã³åã®è¤æ°ã®ãã­ã»ã¹ã§ä¸åº¦ã«å®è¡ã§"
"ããããã«ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:528
msgid ""
"Julia's implementation of message passing is different from other environments such as MPI [^1].  Communication in Julia is generally \"one-"
"sided\", meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations "
"typically do not look like \"message send\" and \"message receive\" but rather resemble higher-level operations like calls to user functions."
msgstr ""
"Julia ã®ã¡ãã»ã¼ã¸ããã·ã³ã°ã®å®è£ã¯ãMPI [^1] ãªã©ã®ä»ã®ç°å¢ã¨ã¯ç°ãªãã¾ãã Julia ã®éä¿¡ã¯ä¸è¬ã«\"ä¸æ¹å\" ã§ãããã­ã°ã©ããæç¤ºçã«ç®¡çã"
"ãå¿è¦ãããã®ã¯ã2 ã¤ã®ãã­ã»ã¹ã®ãã¡ã1 ã¤ã®ãã­ã»ã¹ã®ã¿ã§ããããã«éå¸¸ããããã®æä½ã¯è¦ããä¸ã\"ã¡ãã»ã¼ã¸éä¿¡\" ã \"ã¡ãã»ã¼ã¸åä¿¡\" "
"ã®ãããªå½¢ã§ãªããã¦ã¼ã¶ã¼é¢æ°ã®å¼ã³åºãã®ãããªé«ã¬ãã«ã®æä½ã«ä¼¼ãå½¢ã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:533
msgid ""
"Distributed programming in Julia is built on two primitives: *remote references* and *remote calls*.  A remote reference is an object that "
"can be used from any process to refer to an object stored on a particular process. A remote call is a request by one process to call a "
"certain function on certain arguments on another (possibly the same) process."
msgstr ""
"Julia ã®åæ£ãã­ã°ã©ãã³ã°ã¯ã*ãªã¢ã¼ãåç§* ã¨ *ãªã¢ã¼ãå¼ã³åºã*ã® 2 ã¤ã®ããªããã£ãã«åºã¥ãã¦æ§ç¯ããã¦ãã¾ãã ãªã¢ã¼ãåç§ã¯ãä»»æã®ã"
"ã­ã»ã¹ããç¹å®ã®ãã­ã»ã¹ã«æ ¼ç´ããã¦ãããªãã¸ã§ã¯ããåç§ããããã«ä½¿ç¨ã§ãããªãã¸ã§ã¯ãã§ãããªã¢ã¼ãå¼ã³åºãã¨ã¯ããããã­ã»ã¹ãå¥ã® (ã"
"ãããåã) ãã­ã»ã¹ã®ç¹å®ã®å¼æ°ã«å¯¾ãã¦ç¹å®ã®é¢æ°ãå¼ã³åºããªã¯ã¨ã¹ãã®ãã¨ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:535
msgid "Remote references come in two flavors: [`Future`](@ref Distributed.Future) and [`RemoteChannel`](@ref)."
msgstr "ãªã¢ã¼ãåç§ã«ã¯ã[`Future`](@ref Distributed.Future)ã¨[`RemoteChannel`](@ref)ã®2ã¤ã®ãã¬ã¼ãã¼ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:540
msgid ""
"A remote call returns a [`Future`](@ref Distributed.Future) to its result. Remote calls return immediately; the process that made the call "
"proceeds to its next operation while the remote call happens somewhere else.  You can wait for a remote call to finish by calling [`wait`]"
"(@ref) on the returned [`Future`](@ref Distributed.Future), and you can obtain the full value of the result using [`fetch`](@ref)."
msgstr ""
"ãªã¢ã¼ãå¼ã³åºããè¡ãã¨ã[`Future`](@ref Distributed.Future)ãæ»ãå¤ã¨ãã¦å¾ãããããã«ããã­ã»ã¹ã®å¶å¾¡ã¯ãå¼ã³åºãå´ã«ç´ã¡ã«è¿ããã¾ã; ã"
"ãªãã¡ãå¼ã³åºããè¡ã£ããã­ã»ã¹ã¯ããªã¢ã¼ãå¼ã³åºããå¥ã®å ´æã§è¡ãããéãæ¬¡ã®æä½ã«é²ã¿ã¾ãããªã¢ã¼ãå¼ã³åºãããè¿ããã [`Future`](@ref "
"Distributed.Future) ã«å¯¾ãã [`wait`](@ref) é¢æ°ãå¼ã³åºããã¨ã§ãå¼ã³åºãããã­ã»ã¹ãçµäºããã®ãå¾ã¤ãã¨ãã§ãã¾ããã¾ãã[`fetch`](@ref)ã"
"ä½¿ã£ã¦å¼ã³åºãããã­ã»ã¹ã®çµæå¨ã¦ã®å¤ãåå¾ãããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:543
msgid ""
"On the other hand, [`RemoteChannel`](@ref) s are rewritable. For example, multiple processes can co-ordinate their processing by referencing "
"the same remote `Channel`."
msgstr ""
"ä¸æ¹ã[`RemoteChannel`](@ref)ã¯æ¸ãæãå¯è½ã§ãããã¨ãã°ãè¤æ°ã®ãã­ã»ã¹ãåããªã¢ã¼ãã® 'Channel' ãåç§ãã¦å¦çãèª¿æ´ãããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:548
msgid ""
"Each process has an associated identifier. The process providing the interactive Julia prompt always has an `id` equal to 1. The processes "
"used by default for parallel operations are referred to as \"workers\". When there is only one process, process 1 is considered a worker. "
"Otherwise, workers are considered to be all processes other than process 1."
msgstr ""
"åãã­ã»ã¹ã«ã¯ãè­å¥å­ãé¢é£ä»ãããã¾ããã¤ã³ã¿ã©ã¯ãã£ããªJulia ãã­ã³ãããæä¾ãããã­ã»ã¹ã¯ãå¸¸ã«1ã«ç­ãã`id`ãæã£ã¦ãã¾ããä¸¦åå¦çã«"
"ããã©ã«ãã§ä½¿ç¨ããããã­ã»ã¹ã¯ã\"ã¯ã¼ã«ã¼\" ã¨å¼ã°ãã¾ãããã­ã»ã¹ã 1 ã¤ãããªãå ´åããã­ã»ã¹ 1 ã¯ã¯ã¼ã«ã¼ã¨è¦ãªããã¾ããããä»¥å¤ã®å ´"
"åãã¯ã¼ã«ã¼ã¯ãã­ã»ã¹ 1 ä»¥å¤ã®ãã¹ã¦ã®ãã­ã»ã¹ã¨è¦ãªããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:552
msgid ""
"Let's try this out. Starting with `julia -p n` provides `n` worker processes on the local machine.  Generally it makes sense for `n` to "
"equal the number of CPU threads (logical cores) on the machine. Note that the `-p` argument implicitly loads module `Distributed`."
msgstr ""
"ããã§ã¯ãã£ã¦ã¿ã¾ãããã`julia -p n` ã¨ `julia`ãèµ·åãããã¨ã§ãã­ã¼ã«ã«ãã·ã³ä¸ã®`n`åã®ã¯ã¼ã«ã¼ãã­ã»ã¹ãä½¿ããã¨ãã§ãã¾ããä¸è¬"
"ã«ã'n' ããã·ã³ä¸ã® CPU ã¹ã¬ãã (è«çã³ã¢) ã®æ°ã¨ç­ããããã®ãçã«ããªã£ã¦ããã§ãããããªãã·ã§ã³å¼æ° `-p` ã¯ `Distributed` ã¢ã¸ã¥ã¼ã«ã"
"æé»çã«èª­ã¿è¾¼ããã¨ã«æ³¨æãã¦ãã ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:554
#, no-wrap
msgid ""
"$ ./julia -p 2\n"
"\n"
"julia> r = remotecall(rand, 2, 2, 2)\n"
"Future(2, 1, 4, nothing)\n"
"\n"
"julia> s = @spawnat 2 1 .+ fetch(r)\n"
"Future(2, 1, 5, nothing)\n"
"\n"
"julia> fetch(s)\n"
"2Ã2 Array{Float64,2}:\n"
" 1.18526  1.50912\n"
" 1.16296  1.60607\n"
msgstr ""
"$ ./julia -p 2\n"
"\n"
"julia> r = remotecall(rand, 2, 2, 2)\n"
"Future(2, 1, 4, nothing)\n"
"\n"
"julia> s = @spawnat 2 1 .+ fetch(r)\n"
"Future(2, 1, 5, nothing)\n"
"\n"
"julia> fetch(s)\n"
"2Ã2 Array{Float64,2}:\n"
" 1.18526  1.50912\n"
" 1.16296  1.60607\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:574
msgid ""
"The first argument to [`remotecall`](@ref) is the function to call. Most parallel programming in Julia does not reference specific processes "
"or the number of processes available, but [`remotecall`](@ref)  is considered a low-level interface providing finer control. The second "
"argument to [`remotecall`](@ref)  is the `id` of the process that will do the work, and the remaining arguments will be passed to the "
"function being called."
msgstr ""
"[`remotecall`](@ref)ã®æåã®å¼æ°ã¯ããªã¢ã¼ãã§å¼ã³åºãé¢æ°ã§ããJulia ã®ã»ã¨ãã©ã®ä¸¦åãã­ã°ã©ãã³ã°ã§ã¯ãç¹å®ã®ãã­ã»ã¹ãä½¿ç¨å¯è½ãªãã­ã»ã¹"
"ã®æ°ã¯åç§ããã¾ãããã[`remotecall`](@ref)ã¯ãç´°ããå¶å¾¡ãæä¾ããä½ã¬ãã«ã®ã¤ã³ã¿ã¼ãã§ã¤ã¹ã§ã2çªç®ã®å¼æ°ã§ãä½æ¥­ãè¡ããã­ã»ã¹ã®`id`ãæ"
"å®ã§ãã¾ããæ®ãã®å¼æ°ã¯å¼ã³åºãããé¢æ°ã«æ¸¡ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:579
msgid ""
"As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. "
"The result of both calculations is available in the two futures, `r` and `s`. The [`@spawnat`](@ref) macro evaluates the expression in the "
"second argument on the process specified by the first argument."
msgstr ""
"ãè¦§ã®éããæåã®è¡ã§ã¯ãã­ã»ã¹ 2 ã« 2â2 ã®ã©ã³ãã è¡åãä½æããããä¾é ¼ãã2 è¡ç®ã§ã¯ 1 ãè¿½å ããããã«ä¾é ¼ãã¾ãããä¸¡æ¹ã®è¨ç®ã®çµæã¯ã"
"`r` ã¨ `s` ã® 2 ã¤ã®`future`ã§ä½¿ç¨ã§ãã¾ãã[`@spawnat`](@ref) ãã¯ã­ã¯ãç¬¬ä¸å¼æ°ã§æå®ããããã­ã»ã¹id ã§ãç¬¬äºå¼æ°ã§æå®ãããå¼ãè©ä¾¡ãã¾"
"ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:584
msgid ""
"Occasionally you might want a remotely-computed value immediately. This typically happens when you read from a remote object to obtain data "
"needed by the next local operation. The function [`remotecall_fetch`](@ref) exists for this purpose. It is equivalent to "
"`fetch(remotecall(...))` but is more efficient."
msgstr ""
"å ´åã«ãã£ã¦ã¯ããªã¢ã¼ãã§è¨ç®ãããå¤ãããã«å¿è¦ã«ãªãå ´åãããã¾ããå¸åä¾ã¯ãæ¬¡ã®ã­ã¼ã«ã«æä½ã§ãªã¢ã¼ãã®å¦ççµæãå¿è¦ã«ãªãããªã¢ã¼ã "
"ãªãã¸ã§ã¯ãããå¤ãèª­ã¿åãå¿è¦ããããã¨ããå ´åã§ãããããæã«ã¯ã[`remotecall_fetch`](@ref) ãä½¿ãã¾ããããã¯ `fetch(remotecall(...))`"
"ã¨ããã®ã¨åç­ã§ãããããå¹ççã§ã(è¨³èè¨»: å¹ççã¨ããã®ã¯ã¿ã¤ãéãæ¸ãã¨ããæå³ã§? ããã¨ãä½è¨ãªãªãã¸ã§ã¯ããã§ããªããã¨ãããªã½ã¼ã¹"
"çãªæå³ã§? )ã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:585
#, no-wrap
msgid ""
"julia> remotecall_fetch(getindex, 2, r, 1, 1)\n"
"0.18526337335308085\n"
msgstr ""
"julia> remotecall_fetch(getindex, 2, r, 1, 1)\n"
"0.18526337335308085\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:592
msgid ""
"Remember that [`getindex(r,1,1)`](@ref) is [equivalent](@ref man-array-indexing) to `r[1,1]`, so this call fetches the first element of the "
"future `r`."
msgstr "[`getindex(r,1,1)`](@ref) ã¯ã`r[1,1]`ã¨ç­ãããã¨ãè¦ãã¦ç½®ãã¦ãã ããããã®å¼ã³åºãã¯futureã®`r`ã®æåã®è¦ç´ ããã£ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:595
msgid "To make things easier, the symbol `:any` can be passed to [`@spawnat`], which picks where to do the operation for you:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:596
#, no-wrap
msgid ""
"julia> r = @spawnat :any rand(2,2)\n"
"Future(2, 1, 4, nothing)\n"
"\n"
"julia> s = @spawnat :any 1 .+ fetch(r)\n"
"Future(3, 1, 5, nothing)\n"
"\n"
"julia> fetch(s)\n"
"2Ã2 Array{Float64,2}:\n"
" 1.38854  1.9098\n"
" 1.20939  1.57158\n"
msgstr ""
"julia> r = @spawnat :any rand(2,2)\n"
"Future(2, 1, 4, nothing)\n"
"\n"
"julia> s = @spawnat :any 1 .+ fetch(r)\n"
"Future(3, 1, 5, nothing)\n"
"\n"
"julia> fetch(s)\n"
"2Ã2 Array{Float64,2}:\n"
" 1.38854  1.9098\n"
" 1.20939  1.57158\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:613
msgid ""
"Note that we used `1 .+ fetch(r)` instead of `1 .+ r`. This is because we do not know where the code will run, so in general a [`fetch`]"
"(@ref) might be required to move `r` to the process doing the addition. In this case, [`@spawnat`](@ref) is smart enough to perform the "
"computation on the process that owns `r`, so the [`fetch`](@ref) will be a no-op (no work is done)."
msgstr ""
"`1 .+ r`ã§ã¯ãªãã\n"
"`1 .+ fetch(r)`ãä½¿ã£ãã¨ããã«æ³¨æãã¦ãã ããã\n"
"ããã¯ãã³ã¼ããã©ãã§å®è¡ããããããããªããããä¸è¬çã«ãå ç®ãè¡ããã­ã»ã¹ã« `r` ãç§»åããããã« [`fetch`](@ref) ãå¿è¦ã«ãªãå ´åããã"
"ã¾ãããã®å ´åã[`@spawnat`](@ref)ã¯`r`ãææãããã­ã»ã¹ã§è¨ç®ãå®è¡ããã®ã«ååã«ã¹ãã¼ããªæ¹æ³ã«ãªã£ã¦ãã¦ã[`fetch`](@ref)ã¯no-op(ä½æ¥­ã¯"
"è¡ãããªã)ãã¨ã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:616
msgid ""
"(It is worth noting that [`@spawnat`](@ref) is not built-in but defined in Julia as a [macro](@ref man-macros).  It is possible to define "
"your own such constructs.)"
msgstr ""
"( [`@spawnat`](@ref) ã¯çµã¿è¾¼ã¿é¢æ°ã§ã¯ãªããJulia ã§ [ãã¯ã­](@ref man-macros) ã¨ãã¦å®ç¾©ããã¦ãããã¨æ³¨ç®ããä¾¡å¤ãããã¾ãããã®ãããªä»"
"çµã¿ãèªåã§ç¬èªã«å®ç¾©ãããã¨ã¯å¯è½ã§ãã)"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:620
msgid ""
"An important thing to remember is that, once fetched, a [`Future`](@ref Distributed.Future) will cache its value locally. Further [`fetch`]"
"(@ref) calls do not entail a network hop. Once all referencing [`Future`](@ref Distributed.Future)s have fetched, the remote stored value is "
"deleted."
msgstr ""
"è¦ãã¦ããã¹ãéè¦ãªãã¨ã¯ãä¸åº¦çµæããã§ãããããã¨ã[`Future`](@ref Distributed.Future) ã¯ãã®å¤ãã­ã¼ã«ã«ã«ã­ã£ãã·ã¥ããã¨ãããã¨ã§"
"ããããã«[`fetch`](@ref) å¼ã³åºãã¯ããããã¯ã¼ã¯ããããä¼´ãã¾ãããä¸åº¦ã[`Future`](@ref Distributed.Future)s ã®ãã¹ã¦ã®åç§ãåå¾ããã"
"ã¨ããªã¢ã¼ãã«ä¿å­ãããå¤ã¯åé¤ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:637
msgid ""
"[`@async`](@ref) is similar to [`@spawnat`](@ref), but only runs tasks on the local process. We use it to create a \"feeder\" task for each "
"process. Each task picks the next index that needs to be computed, then waits for its process to finish, then repeats until we run out of "
"indices. Note that the feeder tasks do not begin to execute until the main task reaches the end of the [`@sync`](@ref)  block, at which "
"point it surrenders control and waits for all the local tasks to complete before returning from the function.  As for v0.7 and beyond, the "
"feeder tasks are able to share state via `nextidx` because they all run on the same process.  Even if `Tasks` are scheduled cooperatively, "
"locking may still be required in some contexts, as in [asynchronous I/O](@ref faq-async-io).  This means context switches only occur at well-"
"defined points: in this case, when [`remotecall_fetch`](@ref) is called. This is the current state of implementation and it may change for "
"future Julia versions, as it is intended to make it possible to run up to N `Tasks` on M `Process`, aka [M:N Threading](https://en.wikipedia."
"org/wiki/Thread_(computing)#Models). Then a lock acquiring\\releasing model for `nextidx` will be needed, as it is not safe to let multiple "
"processes read-write a resource at the same time."
msgstr ""
"[`@spawnat`](@ref)ã«ä¼¼ããã®ã«ã[`@async`](@ref)ãããã¾ããã[`@async`](@ref) ã§ã¿ã¹ã¯ãå®è¡ã§ããã®ã¯ã­ã¼ã«ã«ãã­ã»ã¹ã®ã¿ã§ãã[`@async`]"
"(@ref) ãä½¿ãã¨ãã¿ã¹ã¯æ¯ã«ãã£ã¼ãã¼ã¿ã¹ã¯ãçæããã¾ããããããã®ã¿ã¹ã¯ã¯ãè¨ç®ããå¿è¦ãããã¤ã³ããã¯ã¹ãé¸æãããã®ãã­ã»ã¹ãçµäºãã"
"ã®ãå¾ã¤ãã¨ãããã¨ããã¤ã³ããã¯ã¹ããªããªãã¾ã§ç¹°ãè¿ãã¾ãããã£ã¼ãã¼ ã¿ã¹ã¯ã¯ãã¡ã¤ã³ã¿ã¹ã¯ã [`@sync`](@ref) ãã­ãã¯ã®æå¾ã«éããã¾"
"ã§å®è¡ãéå§ããããã®æç¹ã§å¶å¾¡ãæ¾æ£ãããé¢æ°ããæ»ãåã«ãã¹ã¦ã®ã­ã¼ã«ã« ã¿ã¹ã¯ãå®äºããã®ãå¾ã¤ãã¨ã«æ³¨æãã¦ãã ããã Julia ã® v0.7 "
"ä»¥éã§ã¯ããã£ã¼ãã¼ ã¿ã¹ã¯ã¯ãã¹ã¦åããã­ã»ã¹ã§å®è¡ãããããã`nextidx`ãä»ãã¦åã¿ã¹ã¯ã®ç¶æãå±æã§ãã¾ãã ã¿ã¹ã¯ãåèª¿çã«ã¹ã±ã¸ã¥ã¼ã«"
"ããã¦ããå ´åã§ãã[éåæ I/O](@ref faq-async-io)ã®ããã«ãã­ãã¯ãå¿è¦ãªå ´åãããã¾ãã ã¤ã¾ããã³ã³ãã­ã¹ãã¹ã¤ããã¯ã"
"[`remotecall_fetch`](@ref)ãå¼ã³åºãããã¨ãã«ãæç¢ºã«å®ç¾©ããããã¤ã³ãã§ã®ã¿çºçãã¾ã: ããã¯ç¾å¨ã®å®è£ã®ç¶æã§ãããå°æ¥çã«ã¯å¤æ´ããã"
"ããããã¾ããããç¾å¨ã¯ã`M`åã®ãã­ã»ã¹ã«å¯¾ãã¦`N`åã®ã¿ã¹ã¯ãå®è¡ãããã¨ãå¯è½ãªããã«å®è£ããã¦ãã¾ãããããå¥å[M:Nã¹ã¬ãã](https://"
"en.wikipedia.org/wiki/Thread_(computing)#Models)ã¨è¨ãã¾ããã­ãã¯ã®åå¾/ãªãªã¼ã¹ã¢ãã«ã`nextidx` ã«å¯¾ãã¦ç¨ããå¿è¦ãããã¾ããè¤æ°ã®ãã­ã»"
"ã¹ããåæã«ãªã½ã¼ã¹ãèª­ã¿æ¸ãã§ããã®ã¯å±éºãªããã§ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:640
#, no-wrap
msgid "[Code Availability and Loading Packages](@id code-availability)"
msgstr "[ã³ã¼ãã®å¯ç¨æ§ã¨ããã±ã¼ã¸ã®èª­ã¿è¾¼ã¿](@id code-availability)"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:644
msgid "Your code must be available on any process that runs it. For example, type the following into the Julia prompt:"
msgstr ""
"ä½ãã³ã¼ããå®è¡ãããªãã°ãå®è¡ãã­ã»ã¹ãããã®ã³ã¼ããå©ç¨å¯è½ã§ãªããã°ãªãã¾ãããä¾ãã°ãJulia ã®ãã­ã³ããã«æ¬¡ã®ããã«å¥åãã¦ã¿ã¾ãã"
"ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:645
#, no-wrap
msgid ""
"julia> function rand2(dims...)\n"
"           return 2*rand(dims...)\n"
"       end\n"
"\n"
"julia> rand2(2,2)\n"
"2Ã2 Array{Float64,2}:\n"
" 0.153756  0.368514\n"
" 1.15119   0.918912\n"
"\n"
"julia> fetch(@spawnat :any rand2(2,2))\n"
"ERROR: RemoteException(2, CapturedException(UndefVarError(Symbol(\"#rand2\"))\n"
"Stacktrace:\n"
"[...]\n"
msgstr ""
"julia> function rand2(dims...)\n"
"           return 2*rand(dims...)\n"
"       end\n"
"\n"
"julia> rand2(2,2)\n"
"2Ã2 Array{Float64,2}:\n"
" 0.153756  0.368514\n"
" 1.15119   0.918912\n"
"\n"
"julia> fetch(@spawnat :any rand2(2,2))\n"
"ERROR: RemoteException(2, CapturedException(UndefVarError(Symbol(\"#rand2\"))\n"
"Stacktrace:\n"
"[...]\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:662
msgid "Process 1 knew about the function `rand2`, but process 2 did not."
msgstr "ãã­ã»ã¹1ã¯ `rand2`é¢æ°ãç¥ã£ã¦ãã¾ãããããã­ã»ã¹2ã¯ç¥ãã¾ããã§ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:666
msgid ""
"Most commonly you'll be loading code from files or packages, and you have a considerable amount of flexibility in controlling which "
"processes load code. Consider a file, `DummyModule.jl`, containing the following code:"
msgstr ""
"å¤§æµã®å ´åã¯ãã³ã¼ãããã¡ã¤ã«ãããã±ã¼ã¸ããã­ã¼ããããã¨ã§ãããªãã¯ããªãæè»ã«ãã­ã»ã¹ãã­ã¼ãããã³ã¼ããå¶å¾¡ãããã¨ãã§ãã¾ããä¸è¨"
"ã®ã³ã¼ããå«ãã`DummyModule.jl` ã¨ãããã¡ã¤ã«ãèãã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:667
#, no-wrap
msgid ""
"module DummyModule\n"
"\n"
"export MyType, f\n"
"\n"
"mutable struct MyType\n"
"    a::Int\n"
"end\n"
"\n"
"f(x) = x^2+1\n"
"\n"
"println(\"loaded\")\n"
"\n"
"end\n"
msgstr ""
"module DummyModule\n"
"\n"
"export MyType, f\n"
"\n"
"mutable struct MyType\n"
"    a::Int\n"
"end\n"
"\n"
"f(x) = x^2+1\n"
"\n"
"println(\"loaded\")\n"
"\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:687
msgid ""
"In order to refer to `MyType` across all processes, `DummyModule.jl` needs to be loaded on every process.  Calling `include(\"DummyModule.jl"
"\")` loads it only on a single process.  To load it on every process, use the [`@everywhere`](@ref) macro (starting Julia with `julia -p 2`):"
msgstr ""
"ãã¹ã¦ã®ãã­ã»ã¹ã§ `MyType` ãåç§ããã«ã¯ããã¹ã¦ã®ãã­ã»ã¹ã« `DummyModule.jl` ãã­ã¼ãããå¿è¦ãããã¾ãã `include(\"DummyModule.jl\")`ã"
"å¼ã³åºãã¨ãåä¸ã®ãã­ã»ã¹ã§ã®ã¿ãã³ã¼ããèª­ã¿è¾¼ã¾ãã¾ãããã¹ã¦ã®ãã­ã»ã¹ã«ã­ã¼ãããã«ã¯ã[`@everywhere`](@ref)ãã¯ã­ãä½¿ç¨ãã¾ã(Juliaã "
"`julia -p 2` ã§éå§ãã¦):"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:688
#, no-wrap
msgid ""
"julia> @everywhere include(\"DummyModule.jl\")\n"
"loaded\n"
"      From worker 3:    loaded\n"
"      From worker 2:    loaded\n"
msgstr ""
"julia> @everywhere include(\"DummyModule.jl\")\n"
"loaded\n"
"      From worker 3:    loaded\n"
"      From worker 2:    loaded\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:698
msgid ""
"As usual, this does not bring `DummyModule` into scope on any of the process, which requires `using` or `import`.  Moreover, when "
"`DummyModule` is brought into scope on one process, it is not on any other:"
msgstr ""
"ãã¤ã(ã·ã³ã°ã«ã³ã¢ã®ã±ã¼ã¹)ã¨åæ§ã«ãä¸è¨ã¯ã`DummyModule` ãå¨ã¦ã®ãã­ã»ã¹ã§ã¹ã³ã¼ãåã«æã¡è¾¼ããã®ã§ããã¾ããã`using` ã `import` ãã"
"ãå¿è¦ãããã¾ããããã«ããããã­ã»ã¹ã§ `DummyModule`ãã¹ã³ã¼ãã«å¥ã£ãããã¨è¨ã£ã¦ãä»ã®ãã­ã»ã¹ã®ã¹ã³ã¼ãã« `DummyModule`ã¯ããã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:699
#, no-wrap
msgid ""
"julia> using .DummyModule\n"
"\n"
"julia> MyType(7)\n"
"MyType(7)\n"
"\n"
"julia> fetch(@spawnat 2 MyType(7))\n"
"ERROR: On worker 2:\n"
"UndefVarError: MyType not defined\n"
"â®\n"
"\n"
"julia> fetch(@spawnat 2 DummyModule.MyType(7))\n"
"MyType(7)\n"
msgstr ""
"julia> using .DummyModule\n"
"\n"
"julia> MyType(7)\n"
"MyType(7)\n"
"\n"
"julia> fetch(@spawnat 2 MyType(7))\n"
"ERROR: On worker 2:\n"
"UndefVarError: MyType not defined\n"
"â®\n"
"\n"
"julia> fetch(@spawnat 2 DummyModule.MyType(7))\n"
"MyType(7)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:716
msgid "However, it's still possible, for instance, to send a `MyType` to a process which has loaded `DummyModule` even if it's not in scope:"
msgstr "ãã ãã`DummyModule` ãã¹ã³ã¼ãã«ãªãã¦ããã­ã¼ãããã¦ããã°ããã®ãã­ã»ã¹ã«å¯¾ãã¦ãä¾ãã°ã`MyType` ãéä¿¡ãããã¨ã¯å¯è½ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:717
#, no-wrap
msgid ""
"julia> put!(RemoteChannel(2), MyType(7))\n"
"RemoteChannel{Channel{Any}}(2, 1, 13)\n"
msgstr ""
"julia> put!(RemoteChannel(2), MyType(7))\n"
"RemoteChannel{Channel{Any}}(2, 1, 13)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:724
msgid ""
"A file can also be preloaded on multiple processes at startup with the `-L` flag, and a driver script can be used to drive the computation:"
msgstr ""
"ã¾ãããã¡ã¤ã«ã¯ãJulia èµ·åæã«ã`-L`ãã©ã°ãªãã·ã§ã³ã§è¤æ°ãã­ã»ã¹ã«ããªã­ã¼ãã§ããå®è¡å¯¾è±¡ã®\"driver.jl\" ã¹ã¯ãªããã è¨ç®ãé§åãããã¨"
"ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:725
#, no-wrap
msgid "julia -p <n> -L file1.jl -L file2.jl driver.jl\n"
msgstr "julia -p <n> -L file1.jl -L file2.jl driver.jl\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:731
msgid ""
"The Julia process running the driver script in the example above has an `id` equal to 1, just like a process providing an interactive prompt."
msgstr "ä¸è¨ã®ä¾ã§ããã©ã¤ãã¹ã¯ãªãããå®è¡ãã¦ãã Julia ãã­ã»ã¹ã¯ãå¯¾è©±åãã­ã³ãããæä¾ãããã­ã³ããã¨åæ§ã«ãã­ã»ã¹`id` 1ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:735
msgid ""
"Finally, if `DummyModule.jl` is not a standalone file but a package, then `using DummyModule` will _load_ `DummyModule.jl` on all processes, "
"but only bring it into scope on the process where `using` was called."
msgstr ""
"æå¾ã«ãããã`DummyModule.jl`ããã¹ã¿ã³ãã¢ã­ã³ã®ãã¡ã¤ã«ã§ã¯ãªãããã±ã¼ã¸ã ã£ãå ´å\n"
"`using DummyModule`ã¨ããã¨ã`DummyModule.jl`ã®ã³ã¼ãã¯å¨ã¦ã®ãã­ã»ã¹ã§ _ã­ã¼ã_ ããã¾ããã`DummyModule`ãã¹ã³ã¼ãã«ã¯ããã®ã¯ã`using`ãå®"
"è¡ããããã­ã»ã¹ã ãã«ãªãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:736
#, no-wrap
msgid "Starting and managing worker processes"
msgstr "ã¯ã¼ã«ã¼ ãã­ã»ã¹ã®éå§ã¨ç®¡ç"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:739
msgid "The base Julia installation has in-built support for two types of clusters:"
msgstr "Julia ãã¤ã³ã¹ãã¼ã«ããã¨ãä»¥ä¸2ç¨®é¡ã®ã¯ã©ã¹ã¿ããµãã¼ãããæ©è½ãå«ã¾ãã¦ãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:743
msgid "A local cluster specified with the `-p` option as shown above."
msgstr "ä¸è¿°ã® `-p` ãªãã·ã§ã³ã§æå®ããã­ã¼ã«ã«ã¯ã©ã¹ã¿ (ãã¼ãåãã«ãã³ã¢)ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:743
msgid ""
"A cluster spanning machines using the `--machine-file` option. This uses a passwordless `ssh` login to start Julia worker processes (from "
"the same path as the current host) on the specified machines."
msgstr ""
"`--machine-file` ãªãã·ã§ã³ãã¤ãã£ãè¤æ°è¨ç®æ©ãã¾ããã¯ã©ã¹ã¿ãããã¯ãã¹ã¯ã¼ãç¡ãã®`ssh` ã­ã°ã¤ã³ãä½¿ã£ã¦ãç¾å¨ã®ãã¹ãã¨åãçµè·¯ã§ãæå®"
"ãããè¨ç®æ©ã®Julia ã®ã¯ã¼ã«ã¼ãã­ã»ã¹ãèµ·åãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:746
msgid ""
"Functions [`addprocs`](@ref), [`rmprocs`](@ref), [`workers`](@ref), and others are available as a programmatic means of adding, removing and "
"querying the processes in a cluster."
msgstr ""
"[`addprocs`](@ref), [`rmprocs`](@ref), [`workers`](@ref)ãªã©ã®é¢æ°ã§ãã¯ã©ã¹ã¿åã®ãã­ã»ã¹ãè¿½å ã»åé¤ã»åãåãããããã­ã°ã©ãã³ã°ææ®µãæ"
"ä¾ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:747
#, no-wrap
msgid ""
"julia> using Distributed\n"
"\n"
"julia> addprocs(2)\n"
"2-element Array{Int64,1}:\n"
" 2\n"
" 3\n"
msgstr ""
"julia> using Distributed\n"
"\n"
"julia> addprocs(2)\n"
"2-element Array{Int64,1}:\n"
" 2\n"
" 3\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:758
msgid ""
"Module `Distributed` must be explicitly loaded on the master process before invoking [`addprocs`](@ref).  It is automatically made available "
"on the worker processes."
msgstr ""
"`Distributed` ã¢ã¸ã¥ã¼ã«ã¯ã[`addprocs`](@ref)ãå¼ã³åºãåã«ããã¹ã¿ã¼ã¨ãªããã­ã»ã¹ã«æç¤ºçã«ã­ã¼ãããå¿è¦ãããã¾ãã ã¯ã¼ã«ã¼ ãã­ã»ã¹ã§"
"èªåçã«ä½¿ç¨å¯è½ã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:762
msgid ""
"Note that workers do not run a `~/.julia/config/startup.jl` startup script, nor do they synchronize their global state (such as global "
"variables, new method definitions, and loaded modules) with any of the other running processes."
msgstr ""
"ã¯ã¼ã«ã¼ã¯ `~/.julia/config/startup.jl`ã®èµ·åã¹ã¯ãªãããå®è¡ãããã°ã­ã¼ãã«ç¶æ (ã°ã­ã¼ãã«å¤æ°ãæ°ããã¡ã½ããå®ç¾©ãèª­ã¿è¾¼ã¾ããã¢ã¸ã¥ã¼ã«"
"ãªã©) ãä»ã®å®è¡ä¸­ãã­ã»ã¹ã¨åæãããªããã¨ã«æ³¨æãå¿è¦ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:765
msgid ""
"Other types of clusters can be supported by writing your own custom `ClusterManager`, as described below in the [ClusterManagers](@ref) "
"section."
msgstr ""
"ä»ã®ã¿ã¤ãã®ã¯ã©ã¹ã¿ã¼ã¯ã[`ClusterManager`](@ref) ã»ã¯ã·ã§ã³ã§èª¬æããããã«ãç¬èªã®`ClusterManager` ãè¨è¿°ãããã¨ã«ãã£ã¦ãµãã¼ãã§ãã¾"
"ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:766
#, no-wrap
msgid "Data Movement"
msgstr "ãã¼ã¿ã®ç§»å"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:772
msgid ""
"Sending messages and moving data constitute most of the overhead in a distributed program. Reducing the number of messages and the amount of "
"data sent is critical to achieving performance and scalability.  To this end, it is important to understand the data movement performed by "
"Julia's various distributed programming constructs."
msgstr ""
"ã¡ãã»ã¼ã¸ã®éä¿¡ã¨ãã¼ã¿ã®ç§»åã¯ãåæ£ãã­ã°ã©ã ã®ãªã¼ãã¼ãããã®å¤§é¨åãå ãã¦ãã¾ããããã©ã¼ãã³ã¹ã¨ã¹ã±ã¼ã©ããªãã£ãå®ç¾ããã«ã¯ãã¡ã"
"ã»ã¼ã¸ã®æ°ã¨éä¿¡ããããã¼ã¿éãæ¸ãããã¨ãéè¦ã§ãã ãã®ããã«ã¯ãJulia ã®ãã¾ãã¾ãªåæ£ãã­ã°ã©ãã³ã°ã³ã³ã¹ãã©ã¯ãã«ãã£ã¦å®è¡ããããã¼"
"ã¿ç§»åãçè§£ãããã¨ãéè¦ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:777
msgid ""
"[`fetch`](@ref) can be considered an explicit data movement operation, since it directly asks that an object be moved to the local machine. "
"[`@spawnat`](@ref) (and a few related constructs)  also moves data, but this is not as obvious, hence it can be called an implicit data "
"movement operation. Consider these two approaches to constructing and squaring a random matrix:"
msgstr ""
"[`fetch`](@ref)ã¯ããªãã¸ã§ã¯ããã­ã¼ã«ã« ãã·ã³ã«ç§»åãããã¨ãç´æ¥è¦æ±ãããããæç¤ºçãªãã¼ã¿ç§»åæä½ã¨è¦ãªããã¨ãã§ãã¾ãã[`@spawnat`]"
"(@ref)(ããã³ããã¤ãã®é¢é£ããæ§æè¦ç´ ) ããã¼ã¿ãç§»åãã¾ãããããã¯æç¤ºçã§ãªããããæé»çãªãã¼ã¿ç§»åæä½ã¨å¼ã¶ãã¨ãã§ãã¾ããã©ã³ãã "
"è¡åãæ§ç¯ããã³äºä¹ããæ¹æ³ãä»¥ä¸ã®2ã¤èãã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:779
msgid "Method 1:"
msgstr "æ¹æ³ 1:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:780
#, no-wrap
msgid ""
"julia> A = rand(1000,1000);\n"
"\n"
"julia> Bref = @spawnat :any A^2;\n"
"\n"
"[...]\n"
"\n"
"julia> fetch(Bref);\n"
msgstr ""
"julia> A = rand(1000,1000);\n"
"\n"
"julia> Bref = @spawnat :any A^2;\n"
"\n"
"[...]\n"
"\n"
"julia> fetch(Bref);\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:791
msgid "Method 2:"
msgstr "æ¹æ³ 2:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:792
#, no-wrap
msgid ""
"julia> Bref = @spawnat :any rand(1000,1000)^2;\n"
"\n"
"[...]\n"
"\n"
"julia> fetch(Bref);\n"
msgstr ""
"julia> Bref = @spawnat :any rand(1000,1000)^2;\n"
"\n"
"[...]\n"
"\n"
"julia> fetch(Bref);\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:804
msgid ""
"The difference seems trivial, but in fact is quite significant due to the behavior of [`@spawnat`](@ref).  In the first method, a random "
"matrix is constructed locally, then sent to another process where it is squared. In the second method, a random matrix is both constructed "
"and squared on another process. Therefore the second method sends much less data than the first."
msgstr ""
"éãã¯äºç´°ã«è¦ãã¾ãããå®éã«ã¯[`@spawnat`](@ref) ã®åä½ãèããã¨éå¸¸ã«éè¦ãªéãã§ãã æåã®æ¹æ³ã§ã¯ãã©ã³ãã è¡åãã­ã¼ã«ã«ã§æ§ç¯ããã"
"ãã®å¾ãå¥ã®ãã­ã»ã¹éä¿¡ããã¦ãããã§2ä¹ããã¾ãã2 çªç®ã®æ¹æ³ã§ã¯ãã©ã³ãã è¡åãå¥ã®ãã­ã»ã¹ã§æ§ç¯ãããå¾äºä¹ããã¾ãããããã£ã¦ã2 çªç®"
"ã®ã¡ã½ããã®ãã¼ã¿éä¿¡éã¯ãæåã®ã¡ã½ããã§ã®éä¿¡éããã¯ããã«å°ãªãã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:813
msgid ""
"In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might "
"require more thought and likely some measurement. For example, if the first process needs matrix `A` then the first method might be better. "
"Or, if computing `A` is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the "
"current process has very little to do between the [`@spawnat`](@ref)  and `fetch(Bref)`, it might be better to eliminate the parallelism "
"altogether. Or imagine `rand(1000,1000)` is replaced with a more expensive operation. Then it might make sense to add another [`@spawnat`]"
"(@ref)  statement just for this step."
msgstr ""
"ãã®Toy example ã§ã¯ãããã2ã¤ã®æ¹æ³ãåºå¥ããé¸æããã®ã¯ç°¡åã§ããããããå®éã®ãã­ã°ã©ã ã§ãã¼ã¿ã®ç§»åãè¨­è¨ããã«ã¯ãããå¤ãã®ãã¨ãè"
"æ®ããããããã¯ãªãããã®æ¸¬å®ãå¿è¦ã«ãªãå ´åãããã¾ãããã¨ãã°ãæåã®ãã­ã»ã¹ã«è¡å `A` ãå¿è¦ãªå ´åã¯ãæåã®ã¡ã½ããã®æ¹ãé©ãã¦ããå¯"
"è½æ§ãããã¾ããã¾ãã¯ã`A` ã®è¨ç®ãé«ä¾¡ã§ãç¾å¨ã®ãã­ã»ã¹(ã­ã¼ã«ã«ã®ãã­ã»ã¹)ã ãã§ãããè¨ç®ããã¦ããã®ãªãã°ãå¥ã®ãã­ã»ã¹ã¸ã®ãã¼ã¿è»¢é"
"ã¯é¿ããããªãããããã¾ãããã¾ãã¯ãç¾å¨ã®ãã­ã»ã¹ã§ [`@spawnat`](@ref) ã¨ `fetch(Bref)` ã®éã§è¡ããã¨ã¯ã»ã¨ãã©ãªãå ´åã¯ãä¸¦åå¦çãå®å¨"
"ã«æé¤ããæ¹ãè¯ãããããã¾ãããã¾ãã¯ã`rand(1000,1000)`ãããé«ä¾¡ãªæä½ã«ç½®ãæããããã¨æ³åãã¦ã¿ã¦ãã ãããæ¬¡ã«ããã®æé ã«"
"[`@spawnat`](@ref) ã¹ãã¼ãã¡ã³ããè¿½å ããã®ãçã«ããªã£ã¦ããå ´åãããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:814
#, no-wrap
msgid "Global variables"
msgstr "ã°ã­ã¼ãã«å¤æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:819
msgid ""
"Expressions executed remotely via `@spawnat`, or closures specified for remote execution using `remotecall` may refer to global variables. "
"Global bindings under module `Main` are treated a little differently compared to global bindings in other modules. Consider the following "
"code snippet:"
msgstr ""
"`@spawnat`ãä»ãã¦ãªã¢ã¼ãã§å®è¡ãããå¼ãã¾ãã¯ `remotecall` ãä½¿ç¨ãã¦ãªã¢ã¼ãå®è¡ç¨ã«æå®ãããã¯ã­ã¼ã¸ã£ã¯ãã°ã­ã¼ãã«å¤æ°ãåç§ã§ãã¾"
"ããã¢ã¸ã¥ã¼ã« `Main` ã®ã°ã­ã¼ãã« ãã¤ã³ãã£ã³ã°ã¯ãä»ã®ã¢ã¸ã¥ã¼ã«ã®ã°ã­ã¼ãã« ãã¤ã³ãã£ã³ã°ã¨ã¯å°ãç°ãªãæ¹æ³ã§æ±ããã¾ããæ¬¡ã®ã³ã¼ã ã¹ã"
"ãããã«ã¤ãã¦èãã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:820
#, no-wrap
msgid ""
"A = rand(10,10)\n"
"remotecall_fetch(()->sum(A), 2)\n"
msgstr ""
"A = rand(10,10)\n"
"remotecall_fetch(()->sum(A), 2)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:830
#, no-wrap
msgid ""
"In this case [`sum`](@ref) MUST be defined in the remote process.\n"
"Note that `A` is a global variable defined in the local workspace. Worker 2 does not have a variable called\n"
"`A` under `Main`. The act of shipping the closure `()->sum(A)` to worker 2 results in `Main.A` being defined\n"
"on 2. `Main.A` continues to exist on worker 2 even after the call `remotecall_fetch` returns. Remote calls\n"
"with embedded global references (under `Main` module only) manage globals as follows:\n"
msgstr ""
"ãã®å ´åã[`sum`](@ref) ã¯ãªã¢ã¼ã ãã­ã»ã¹ã§å®ç¾©ããå¿è¦ãããã¾ãã\n"
"`A` ã¯ãã­ã¼ã«ã« ã¯ã¼ã¯ã¹ãã¼ã¹ã§å®ç¾©ãããã°ã­ã¼ãã«å¤æ°ã§ãããã¨ã«æ³¨æãã¦ãã ãããã¯ã¼ã«ã¼ãã­ã»ã¹ 2 ã¯ã`Main`ã®ä¸ã§å¼ã³åºãããå¤æ°`A`ãææãã¦ãã¾ãããã¯ã­ã¼ã¸ã£ã¼ `()->sum(A)` ãã¯ã¼ã«ã¼ãã­ã»ã¹2 ã«éãããçµæã¨ãã¦ã`Main.A` ãã¯ã¼ã«ãã­ã»ã¹2ã«å®ç¾©ããã¾ãã\n"
"`remotecall_fetch` ããå¶å¾¡ãã­ã¼ã«ã«ã«æ»ã£ããã¨ãã`main.A` ã¯ã¯ã¼ã«ã¼ãã­ã»ã¹ 2 ã«å­å¨ãç¶ãã¾ãã\n"
"åãè¾¼ã¿ã°ã­ã¼ãã«åç§ (`Main`ã¢ã¸ã¥ã¼ã«ã®ã¿) ãä¼´ãããªã¢ã¼ãå¼ã³åºãã¯ãã°ã­ã¼ãã«å¤æ°ãä¸è¨ã®ããã«ç®¡çãã¾ã:\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:832
msgid "- New global bindings are created on destination workers if they are referenced as part of a remote call."
msgstr ""
"- æ°ããã°ã­ã¼ãã«ãã¤ã³ãã£ã³ã°ããªã¢ã¼ãå¼ã³åºãã®ä¸é¨ã¨ãã¦åç§ããã¦ããå ´åã«ã¯ããã®ã°ã­ã¼ãã«ãã¤ã³ãã£ã³ã°ã¯ãã¯ã¼ã«ã¼ä¸ã«ä½æããã¾"
"ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:834
msgid "- Global constants are declared as constants on remote nodes too."
msgstr "- ã°ã­ã¼ãã«å®æ°ã¯ããªã¢ã¼ã ãã¼ãã§ãå®æ°ã¨ãã¦å®£è¨ããã¾ãã"

#. type: Bullet: '- '
#: ext/julia/doc/src/manual/parallel-computing.md:838
msgid ""
"Globals are re-sent to a destination worker only in the context of a remote call, and then only if its value has changed. Also, the cluster "
"does not synchronize global bindings across nodes.  For example:"
msgstr ""
"ã°ã­ã¼ãã«ã¯ãã¯ã¼ã«ã¼ãã­ã»ã¹ã«åéä¿¡ãããã®ã¯ããªã¢ã¼ãå¼ã³åºãã®ã³ã³ãã­ã¹ãã§ãããã«ãã®å¤ãå¤æ´ãããå ´åã«ã®ã¿ã§ããã¾ããã¯ã©ã¹ã¿ã¼"
"ã¯ãã¼ãéã§ã°ã­ã¼ãã« ãã¤ã³ãã£ã³ã°ãåæãã¾ããã ä¾ãã°ï¼"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:839
#, no-wrap
msgid ""
"  A = rand(10,10)\n"
"  remotecall_fetch(()->sum(A), 2) # worker 2\n"
"  A = rand(10,10)\n"
"  remotecall_fetch(()->sum(A), 3) # worker 3\n"
"  A = nothing\n"
msgstr ""
"  A = rand(10,10)\n"
"  remotecall_fetch(()->sum(A), 2) # worker 2\n"
"  A = rand(10,10)\n"
"  remotecall_fetch(()->sum(A), 3) # worker 3\n"
"  A = nothing\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:849
#, no-wrap
msgid ""
"  Executing the above snippet results in `Main.A` on worker 2 having a different value from\n"
"  `Main.A` on worker 3, while the value of `Main.A` on node 1 is set to `nothing`.\n"
msgstr "  ä¸è¨ã®ã¹ãããããå®è¡ããã¨ããã¼ã 1 ã® `Main.A` ã®å¤ã¯ \"nothing\" ã«è¨­å®ããã¦ããã®ã§ãããã¯ã¼ã«ã¼ 2ã®`Main.A`ã¯ãã¯ã¼ã«ã¼3ã®ããã¨ç°ãªãå¤ãæã¡ã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:855
msgid ""
"As you may have realized, while memory associated with globals may be collected when they are reassigned on the master, no such action is "
"taken on the workers as the bindings continue to be valid.  [`clear!`](@ref) can be used to manually reassign specific globals on remote "
"nodes to `nothing` once they are no longer required. This will release any memory associated with them as part of a regular garbage "
"collection cycle."
msgstr ""
"ããã§ãåããã®ããã«ãã°ã­ã¼ãã«ã«é¢é£ä»ããããã¡ã¢ãªã¯ãã¹ã¿ã¼ã§å¥ã®å¤ãä»£å¥ãããã¨ãã«ã«åéãããå¯è½æ§ãããã¾ãããã¯ã¼ã«ã¼ã§ã¯ãã®"
"ãããªã¢ã¯ã·ã§ã³ã¯å®è¡ããã¾ããããã¤ã³ãã£ã³ã°ãå¼ãç¶ãæå¹ã ããã§ãã [`clear!`](@ref) ãä½¿ç¨ããã¨ããªã¢ã¼ããã¼ãä¸ã®ç¹å®ã®ã°ã­ã¼ãã«"
"ããä¸è¦ã«ãªã£ãã¨ãã«æåã§ `nothing`ãåä»£å¥ã§ãã¾ããããã«ãããéå¸¸ã®ã¬ãã¼ã¸ ã³ã¬ã¯ã·ã§ã³ ãµã¤ã¯ã«ã®ä¸é¨ã¨ãã¦ããããã«é¢é£ä»ãããã¦"
"ãããã¹ã¦ã®ã¡ã¢ãªãè§£æ¾ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:858
msgid ""
"Thus programs should be careful referencing globals in remote calls. In fact, it is preferable to avoid them altogether if possible. If you "
"must reference globals, consider using `let` blocks to localize global variables."
msgstr ""
"ãããã£ã¦ããã­ã°ã©ã ã§ã¯ãªã¢ã¼ãå¼ã³åºãã§ã®ã°ã­ã¼ãã«åç§ãããæã¯ãæ³¨æãå¿è¦ã§ããå®éã«ã¯ãå¯è½ã§ããã°ãªã¢ã¼ãã§ã®ã°ã­ã¼ãã«åç§ã¯å®"
"å¨ã«é¿ããã®ãå¥½ã¾ããã§ããã°ã­ã¼ãã«ãåç§ããå¿è¦ãããå ´åã¯ã`let` ãã­ãã¯ãä½¿ç¨ãã¦ã°ã­ã¼ãã«å¤æ°ãã­ã¼ã«ã©ã¤ãºãããã¨ãæ¤è¨ãã¦ãã "
"ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:860 ext/julia/doc/src/manual/performance-tips.md:349
msgid "For example:"
msgstr "ä¾ãã°:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:861
#, no-wrap
msgid ""
"julia> A = rand(10,10);\n"
"\n"
"julia> remotecall_fetch(()->A, 2);\n"
"\n"
"julia> B = rand(10,10);\n"
"\n"
"julia> let B = B\n"
"           remotecall_fetch(()->B, 2)\n"
"       end;\n"
"\n"
"julia> @fetchfrom 2 InteractiveUtils.varinfo()\n"
"name           size summary\n"
"âââââââââ âââââââââ ââââââââââââââââââââââ\n"
"A         800 bytes 10Ã10 Array{Float64,2}\n"
"Base                Module\n"
"Core                Module\n"
"Main                Module\n"
msgstr ""
"julia> A = rand(10,10);\n"
"\n"
"julia> remotecall_fetch(()->A, 2);\n"
"\n"
"julia> B = rand(10,10);\n"
"\n"
"julia> let B = B\n"
"           remotecall_fetch(()->B, 2)\n"
"       end;\n"
"\n"
"julia> @fetchfrom 2 InteractiveUtils.varinfo()\n"
"name           size summary\n"
"âââââââââ âââââââââ ââââââââââââââââââââââ\n"
"A         800 bytes 10Ã10 Array{Float64,2}\n"
"Base                Module\n"
"Core                Module\n"
"Main                Module\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:883
msgid ""
"As can be seen, global variable `A` is defined on worker 2, but `B` is captured as a local variable and hence a binding for `B` does not "
"exist on worker 2."
msgstr ""
"ããã§ãããããã«ãã°ã­ã¼ãã«å¤æ° `A` ã¯ãã¯ã¼ã«ã¼2ã§å®ç¾©ããã¦ãã¾ããã`B`ã¯ã­ã¼ã«ã«å¤æ°ã¨ãã¦è£è¶³ããããããã¯ã¼ã«ã¼2ã§ã¯ `B`ã®ãã¤ã³"
"ãã£ã³ã°ã¯å­å¨ãã¾ããã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:885
#, no-wrap
msgid "Parallel Map and Loops"
msgstr "ä¸¦è¡ãããã¨ä¸¦è¡ã«ã¼ã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:891
msgid ""
"Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple "
"processes can handle independent simulation trials simultaneously. We can use [`@spawnat`](@ref) to flip coins on two processes. First, "
"write the following function in `count_heads.jl`:"
msgstr ""
"å¹¸ãã«ããä¾¿å©ãªä¸¦åè¨ç®ã®å¤ãã¯ããã¼ã¿ã®ç§»åãå¿è¦ã¨ãã¾ãããä¸è¬çãªä¾ã¯ãè¤æ°ã®ãã­ã»ã¹ãç¬ç«ããã·ãã¥ã¬ã¼ã·ã§ã³è©¦è¡ãåæã«å¦çã§ãã"
"ã¢ã³ãã«ã«ã­ã·ãã¥ã¬ã¼ã·ã§ã³ã§ãã2ã¤ã®ãã­ã»ã¹ã§ã³ã¤ã³ãåè»¢ãããããã«[`@spawnat`](@ref)ãä½¿ç¨ãããã¨ãã§ãã¾ããã¾ãã`count_heads.jl` "
"ã«æ¬¡ã®é¢æ°ãæ¸ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:892
#, no-wrap
msgid ""
"function count_heads(n)\n"
"    c::Int = 0\n"
"    for i = 1:n\n"
"        c += rand(Bool)\n"
"    end\n"
"    c\n"
"end\n"
msgstr ""
"function count_heads(n)\n"
"    c::Int = 0\n"
"    for i = 1:n\n"
"        c += rand(Bool)\n"
"    end\n"
"    c\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:904
msgid ""
"The function `count_heads` simply adds together `n` random bits. Here is how we can perform some trials on two machines, and add together "
"the results:"
msgstr ""
"é¢æ° `count_heads` ã¯åã« `n` åã®ã©ã³ãã ãããã®åãã¨ãã¾ãã2 å°ã®ãã·ã³ã§è©¦è¡ãå®è¡ããããããã®çµæã®åãã¨ãæ¹æ³ãæ¬¡ã«èª¬æãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:905
#, no-wrap
msgid ""
"julia> @everywhere include_string(Main, $(read(\"count_heads.jl\", String)), \"count_heads.jl\")\n"
"\n"
"julia> a = @spawnat :any count_heads(100000000)\n"
"Future(2, 1, 6, nothing)\n"
"\n"
"julia> b = @spawnat :any count_heads(100000000)\n"
"Future(3, 1, 7, nothing)\n"
"\n"
"julia> fetch(a)+fetch(b)\n"
"100001564\n"
msgstr ""
"julia> @everywhere include_string(Main, $(read(\"count_heads.jl\", String)), \"count_heads.jl\")\n"
"\n"
"julia> a = @spawnat :any count_heads(100000000)\n"
"Future(2, 1, 6, nothing)\n"
"\n"
"julia> b = @spawnat :any count_heads(100000000)\n"
"Future(3, 1, 7, nothing)\n"
"\n"
"julia> fetch(a)+fetch(b)\n"
"100001564\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:926
msgid ""
"This example demonstrates a powerful and often-used parallel programming pattern. Many iterations run independently over several processes, "
"and then their results are combined using some function.  The combination process is called a *reduction*, since it is generally tensor-rank-"
"reducing: a vector of numbers is reduced to a single number, or a matrix is reduced to a single row or column, etc. In code, this typically "
"looks like the pattern `x = f(x,v[i])`, where `x` is the accumulator, `f` is the reduction function, and the `v[i]` are the elements being "
"reduced. It is desirable for `f` to be associative, so that it does not matter what order the operations are performed in."
msgstr ""
"ãã®ä¾ã§ç¤ºããã¦ããã®ã¯ããä¸¦åãã­ã°ã©ãã³ã°ã«ããããå¼·åãã¤é »åºã®ãã¿ã¼ã³ã§ããå¤ãã®ã¤ãã¬ã¼ã·ã§ã³ã¯è¤æ°ã®ãã­ã»ã¹ã§ç¬ç«ã«å®è¡ãããã"
"ã®çµæã¯ä½ããã®é¢æ°ãä½¿ç¨ãã¦çµ±åããã¾ãããã®çµ±åã®ãã­ã»ã¹ã¯*reduce*ã¨å¼ã°ãã¾ãããã®å¦çã¯ãä¸è¬çã«ãã³ã½ã«ã©ã³ã¯ä½æ¸ã§ãæ°å¤ãã¯ãã«"
"ãåä¸ã®æ°å¤ã«æ¸å°ããã¨ããè¡åãåä¸ã®è¡ã¾ãã¯åãªã©ã«æ¸ãããããããªå¦çã ããã§ããã³ã¼ãã§ã¯ãéå¸¸ã`x`ãã¢ã­ã¥ã ã¬ã¼ã¿ã`f`ãreduceé¢"
"æ°ã`v[i]` ãåæ¸ãããè¦ç´ ã§ãããã¿ã¼ã³ã§ã `x= f(x,v[i])`ã®ãããªã³ã¼ãã«ãªãã¾ãã`f` ã¯ãæä½ãå®è¡ãããé åºã«é¢ä¿ãªããã¤ã¾ãçµåå¾ã"
"æºãããã¨ãæã¾ããã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:931
msgid ""
"Notice that our use of this pattern with `count_heads` can be generalized. We used two explicit [`@spawnat`](@ref) statements, which limits "
"the parallelism to two processes. To run on any number of processes, we can use a *parallel for loop*, running in distributed memory, which "
"can be written in Julia using [`@distributed`](@ref) like this:"
msgstr ""
"`count_heads` ãä½¿ç¨ãããã®ãã¿ã¼ã³ã®ä½¿ç¨ã¯ä¸è¬åã§ãããã¨ã«æ³¨æãã¦ãã ããã2 ã¤ã®æç¤ºçãª [`@spawnat`](@ref) ã¹ãã¼ãã¡ã³ããä½¿ç¨ãã¦ã"
"ä¸¦åå¦çã 2 ã¤ã®ãã­ã»ã¹ã«å¶éãã¾ãããä»»æã®æ°ã®ãã­ã»ã¹ã§å®è¡ããã«ã¯ãåæ£ã¡ã¢ãªã§å®è¡ããã \n"
"*parallel for loop*\n"
"ããæ¬¡ã®ããã« [`@distributed`](@ref) ãä½¿ã£ã¦æ¸ããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:932
#, no-wrap
msgid ""
"nheads = @distributed (+) for i = 1:200000000\n"
"    Int(rand(Bool))\n"
"end\n"
msgstr ""
"nheads = @distributed (+) for i = 1:200000000\n"
"    Int(rand(Bool))\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:942
msgid ""
"This construct implements the pattern of assigning iterations to multiple processes, and combining them with a specified reduction (in this "
"case `(+)`). The result of each iteration is taken as the value of the last expression inside the loop. The whole parallel loop expression "
"itself evaluates to the final answer."
msgstr ""
"ãã®ã³ã³ã¹ãã©ã¯ãã¯ãç¹°ãè¿ãå¦çãè¤æ°ã®ãã­ã»ã¹ã«è¨ç®ããã¦ããã®çµæããæå®ããã reduce å¦ç(ãã®å ´åã¯ `(+)`)ãä½¿ã£ã¦çµ±åãã\n"
"å®è£ãã¿ã¼ã³ãå®ç¾ãã¦ãã¾ããååå¾©ã®çµæã¨ãã¦ã«ã¼ãåã®æå¾ã®å¼ã®å¤ãåãåããã¾ããä¸¦åã«ã¼ãå¼å¨ä½ããæçµçãªè¨ç®çµæã¨ãã¦è©ä¾¡ããã¾"
"ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:947
msgid ""
"Note that although parallel for loops look like serial for loops, their behavior is dramatically different. In particular, the iterations do "
"not happen in a specified order, and writes to variables or arrays will not be globally visible since iterations run on different processes. "
"Any variables used inside the parallel loop will be copied and broadcast to each process."
msgstr ""
"ä¸¦è¡å¦çã® for ã«ã¼ãã¯ãéæ¬¡å¦çã® for ã«ã¼ãã¨ä¼¼ã¦ããããã«ã¿ãã¾ããããã®åä½ã¯å¤§ããç°ãªããã¨ã«æ³¨æãå¿è¦ã§ããç¹ã«ãåå¾©ã¯æå®ããã"
"é åºã§è¡ãããªããã¨ãåå¾©ãç°ãªããã­ã»ã¹ã§å®è¡ãããã®ã§ãå¤æ°ã¾ãã¯éåã¸ã®æ¸ãè¾¼ã¿ã¯ã°ã­ã¼ãã«ããã¯è¦ããªããã¨ç­ã«æ³¨æãã¾ããããä¸¦å"
"ã«ã¼ãåã§ä½¿ç¨ãããå¤æ°ãã¹ã¦ã¯ãåãã­ã»ã¹ã«ã³ãã¼ããããã­ã¼ãã­ã£ã¹ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:949
msgid "For example, the following code will not work as intended:"
msgstr "ãã¨ãã°ãæ¬¡ã®ã³ã¼ãã¯æå³ããã¨ããã«æ©è½ãã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:950
#, no-wrap
msgid ""
"a = zeros(100000)\n"
"@distributed for i = 1:100000\n"
"    a[i] = i\n"
"end\n"
msgstr ""
"a = zeros(100000)\n"
"@distributed for i = 1:100000\n"
"    a[i] = i\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:960
msgid ""
"This code will not initialize all of `a`, since each process will have a separate copy of it.  Parallel for loops like these must be "
"avoided. Fortunately, [Shared Arrays](@ref man-shared-arrays) can be used to get around this limitation:"
msgstr ""
"ãã®ã³ã¼ãã¯ã`a` ã®å¨ã¦ã®è¦ç´ ãåæåã§ãã¾ãããåãã­ã»ã¹ã«ã¯åå¥ã®ã³ãã¼ãããããã§ãããã®ãããªä¸¦è¡ for ã«ã¼ãã¯é¿ããªããã°ããã¾ã"
"ããããããã\n"
"[Shared Array](@ref man-shared-arrays) \n"
"ãä½¿ç¨ãã¦ããã®å¶éãåé¿ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:961
#, no-wrap
msgid ""
"using SharedArrays\n"
"\n"
"a = SharedArray{Float64}(10)\n"
"@distributed for i = 1:10\n"
"    a[i] = i\n"
"end\n"
msgstr ""
"using SharedArrays\n"
"\n"
"a = SharedArray{Float64}(10)\n"
"@distributed for i = 1:10\n"
"    a[i] = i\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:971
msgid "Using \"outside\" variables in parallel loops is perfectly reasonable if the variables are read-only:"
msgstr "ä¸¦åã«ã¼ãã«ããã \"å¤é¨\" å¤æ°ã®ä½¿ç¨ã¯ãå¤æ°ãèª­ã¿åãå°ç¨ã®å ´åã«å¨ãåé¡æãã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:972
#, no-wrap
msgid ""
"a = randn(1000)\n"
"@distributed (+) for i = 1:100000\n"
"    f(a[rand(1:end)])\n"
"end\n"
msgstr ""
"a = randn(1000)\n"
"@distributed (+) for i = 1:100000\n"
"    f(a[rand(1:end)])\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:980
msgid "Here each iteration applies `f` to a randomly-chosen sample from a vector `a` shared by all processes."
msgstr "ããã§ã¯ãååå¾©ã¯ããã¹ã¦ã®ãã­ã»ã¹ã§å±æããããã¯ãã« `a` ããã©ã³ãã ã«é¸æããããµã³ãã«ã« `f` ãé©ç¨ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:986
msgid ""
"As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes asynchronously, i.e. it spawns "
"independent tasks on all available workers and returns an array of [`Future`](@ref Distributed.Future) immediately without waiting for "
"completion. The caller can wait for the [`Future`](@ref Distributed.Future) completions at a later point by calling [`fetch`](@ref) on them, "
"or wait for completion at the end of the loop by prefixing it with [`@sync`](@ref), like `@sync @distributed for`."
msgstr ""
"ãè¦§ã®éããreduce æ¼ç®å­ã¯å¿è¦ãªãå ´åã¯çç¥ã§ãã¾ãããã®å ´åãã«ã¼ãã¯éåæçã«å®è¡ãããã¤ã¾ãä½¿ç¨å¯è½ãªãã¹ã¦ã®ã¯ã¼ã«ã¼ã«å¯¾ãã¦ç¬ç«ãã"
"ã¿ã¹ã¯ãçæãããå®äºãå¾ããã«ããã« [`Future`](@ref Distributed.Future) ã®éåãè¿ãã¾ããå¼ã³åºãåã¯ã[`fetch`](@ref) ãå¼ã³åºãã¦ "
"[`Future`](@ref Distributed.Future)ã®å®äºãå¾ã§å¾ã¤ãã¨ãã§ãã¾ããã[`@sync`](@ref) ãã¤ãã¦ãã¤ã¾ãã\n"
"`@sync @distributed for`\n"
"ã«ã¼ããä½¿ã£ã¦ãã«ã¼ãã®æå¾ã§å®äºãå¾ã¤ãã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:991
msgid ""
"In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some range (or, more generally, to "
"all elements in some collection). This is another useful operation called *parallel map*, implemented in Julia as the [`pmap`](@ref) "
"function. For example, we could compute the singular values of several large random matrices in parallel as follows:"
msgstr ""
"å ´åã«ãã£ã¦ã¯ãreduce æ¼ç®å­ã¯å¿è¦ãªããããç¯å²ã®ãã¹ã¦ã®æ´æ° (ã¾ãã¯ä¸è¬çã«ã¯ãä¸é¨ã®ã³ã¬ã¯ã·ã§ã³åã®ãã¹ã¦ã®è¦ç´ ) ã«é¢æ°ãé©ç¨ããã ãã¨"
"ãããã¨ãããã§ããããããã¯ã*ãã©ã¬ã« ããã*ã¨å¼ã°ããä¾¿å©ãªå¦çã§ãJulia ã§ã¯[`pmap`](@ref) é¢æ°ã¨ãã¦å®è£ããã¦ãã¾ãããã¨ãã°ãè¤æ°"
"ã®å¤§ããªã©ã³ãã è¡åã®ç¹ç°å¤ãæ¬¡ã®ããã«ä¸¦åã«è¨ç®ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:992
#, no-wrap
msgid ""
"julia> M = Matrix{Float64}[rand(1000,1000) for i = 1:10];\n"
"\n"
"julia> pmap(svdvals, M);\n"
msgstr ""
"julia> M = Matrix{Float64}[rand(1000,1000) for i = 1:10];\n"
"\n"
"julia> pmap(svdvals, M);\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1003
msgid ""
"Julia's [`pmap`](@ref) is designed for the case where each function call does a large amount of work. In contrast, `@distributed for` can "
"handle situations where each iteration is tiny, perhaps merely summing two numbers. Only worker processes are used by both [`pmap`](@ref) "
"and `@distributed for` for the parallel computation. In case of `@distributed for`, the final reduction is done on the calling process."
msgstr ""
"Julia ã®[`pmap`](@ref)ã¯ã1åã®é¢æ°å¼ã³åºãã®ãªãã§å¤§éã®å¦çãè¡ãå ´åãæ³å®ãã¦è¨­è¨ããã¦ãã¾ããå¯¾ãã¦ã`@distributed for` ã¯ãååå¾©ãå°"
"ãããããããåã« 2 ã¤ã®æ°å¤ãåè¨ããã ãã®ãããªç¶æ³ãå¦çã§ãã¾ããä¸¦åè¨ç®ã«ã¯[`pmap`](@ref)ã¨`@distributed for` ã®ä¸¡æ¹ã§ã¯ã¼ã«ã¼ ãã­ã»"
"ã¹ã®ã¿ãä½¿ç¨ããã¾ãã`@distributed`ã®å ´åãæçµçãªreduceå¦çã¯å¼ã³åºããã­ã»ã¹ã§è¡ããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:1004
#, no-wrap
msgid "Remote References and AbstractChannels"
msgstr "ãªã¢ã¼ãåç§ã¨æ½è±¡ãã£ãã«"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1007
msgid "Remote references always refer to an implementation of an `AbstractChannel`."
msgstr "ãªã¢ã¼ãåç§ã¯å¸¸ã«`AbstractChannel`ã®å®è£ãæãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1012
msgid ""
"A concrete implementation of an `AbstractChannel` (like `Channel`), is required to implement [`put!`](@ref), [`take!`](@ref), [`fetch`]"
"(@ref), [`isready`](@ref) and [`wait`](@ref).  The remote object referred to by a [`Future`](@ref Distributed.Future) is stored in a "
"`Channel{Any}(1)`, i.e., a `Channel` of size 1 capable of holding objects of `Any` type."
msgstr ""
"`æ½è±¡ãã£ã³ãã«`(ããã£ãã«ããªã©)ã®å·ä½çãªå®è£ã¯ã[`put!`](@ref)ã[`take!`](@ref)ã[`fetch`](@ref)ã[`isready`](@ref) ã[`wait`](@ref) ãã¤"
"ã³ã¹ãã¼ã«ããã®ã«å¿è¦ã§ãã\n"
" [`Future`](@ref Distributed.Future)\n"
"ãåç§ãããªã¢ã¼ããªãã¸ã§ã¯ãã¯ã\n"
"`Channel{Any}(1)` ããªãã¡ ãµã¤ãº1ã§`Any`åãä¿æãããã£ã³ãã«ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1015
msgid ""
"[`RemoteChannel`](@ref), which is rewritable, can point to any type and size of channels, or any other implementation of an "
"`AbstractChannel`."
msgstr ""
"[`RemoteChannel`](@ref)ã¯ãåæ¸ãè¾¼ã¿å¯è½ã§ããããã£ãã«ã®ä»»æã®ã¿ã¤ãã¨ãµã¤ãºãã¾ãã¯`AbstractChannel`ã®ä»ã®å®è£ãæããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1019
msgid ""
"The constructor `RemoteChannel(f::Function, pid)()` allows us to construct references to channels holding more than one value of a specific "
"type. `f` is a function executed on `pid` and it must return an `AbstractChannel`."
msgstr ""
"ã³ã³ã¹ãã©ã¯ã¿ `RemoteChannel(f::Function,pid)()` ãä½¿ç¨ããã¨ãç¹å®ã®åã®è¤æ°ã®å¤ãä¿æãããã£ãã«ã¸ã®åç§ãæ§ç¯ã§ãã¾ãã`f` ã¯ `pid` ã§å®"
"è¡ãããé¢æ°ã§ããã`AbstractChannel` ãè¿ãå¿è¦ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1022
#, no-wrap
msgid ""
"For example, `RemoteChannel(()->Channel{Int}(10), pid)`, will return a reference to a channel\n"
"of type `Int` and size 10. The channel exists on worker `pid`.\n"
msgstr ""
"ãã¨ãã°ã`RemoteChannel(()->Channel{Int}(10), pid)` ã¯ã`Int`åã§ãµã¤ãºã10ã®ãã£ãã«ã¸ã®åç§ãè¿ãã¾ãã\n"
"ãã£ãã«ã¯ã¯ã¼ã«ã¼ `pid` ã«å­å¨ãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1025
msgid ""
"Methods [`put!`](@ref), [`take!`](@ref), [`fetch`](@ref), [`isready`](@ref) and [`wait`](@ref)  on a [`RemoteChannel`](@ref) are proxied "
"onto the backing store on the remote process."
msgstr ""
"[`RemoteChannel`](@ref)ä¸ã®ã¡ã½ãã [`put!`](@ref), [`take!`](@ref), [`fetch`](@ref), [`isready`](@ref) and [`wait`](@ref) ã¯ãªã¢ã¼ããã­ã»ã¹"
"ã®ããã­ã³ã°ã¹ãã¢ã«ãã­ã­ã·ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1030
msgid ""
"[`RemoteChannel`](@ref) can thus be used to refer to user implemented `AbstractChannel` objects.  A simple example of this is provided in "
"`dictchannel.jl` in the [Examples repository](https://github.com/JuliaAttic/Examples), which uses a dictionary as its remote store."
msgstr ""
"ãã£ã¦ã[`RemoteChannel`](@ref) ã¯ã¦ã¼ã¶ã¼ãå®è£ãã `AbstractChannel` ãªãã¸ã§ã¯ããåç§ããã®ã«ä½¿ããã¨ãã§ãã¾ããããã®ã·ã³ãã«ãªä¾ã¯"
"[Examples repository](https://github.com/JuliaAttic/Examples)ã®`dictchannel.jl`ã«è¦ããã¨ãã§ãã¾ããããã¯è¾æ¸ããªã¢ã¼ãã¹ãã¢ã¨ãã¦è¾æ¸ãä½¿"
"ããããªä¾ã§ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:1032
#, no-wrap
msgid "Channels and RemoteChannels"
msgstr "ãã£ãã«ã¨ãªã¢ã¼ããã£ãã«"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1048
msgid ""
"A [`Channel`](@ref) is local to a process. Worker 2 cannot directly refer to a [`Channel`](@ref) on worker 3 and vice-versa. A "
"[`RemoteChannel`](@ref), however, can put and take values across workers."
msgstr ""
"[`Channel`](@ref)ã¯ããã­ã»ã¹ã«å¯¾ãã¦ã­ã¼ã«ã«ãªãã®ã§ããã¯ã¼ã«ã¼2ã¯ãã¯ã¼ã«ã¼3ã® [`Channel`](@ref)ãç´æ¥åç§ãããã¨ã¯ã§ãã¾ããããã ãã"
"[`RemoteChannel`](@ref)ã¯ãã¯ã¼ã«ã¼ãã¾ããã§å¤ã®`put/take`ãè¡ããã¨ãã§ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1048
msgid "A [`RemoteChannel`](@ref) can be thought of as a *handle* to a [`Channel`](@ref)."
msgstr "[`RemoteChannel`](@ref) ã¯ã[`Channel`](@ref)ã«å¯¾ãã *ãã³ãã«* ã¨èãããã¨ãã§ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1048
msgid ""
"The process id, `pid`, associated with a [`RemoteChannel`](@ref) identifies the process where the backing store, i.e., the backing "
"[`Channel`](@ref) exists."
msgstr ""
"[`RemoteChannel`](@ref)ã«é¢é£ä»ãããããã­ã»ã¹ID `pid` ã¯ãããã­ã³ã°ã¹ãã¢ãããªãã¡ \"backing [`Channel`](@ref)\" ãå­å¨ãããã­ã»ã¹ãè­å¥"
"ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1048
msgid ""
"Any process with a reference to a [`RemoteChannel`](@ref) can put and take items from the channel.  Data is automatically sent to (or "
"retrieved from) the process a [`RemoteChannel`](@ref) is associated with."
msgstr ""
"[`RemoteChannel`](@ref)ãåç§ãããã­ã»ã¹ã¯ã[`RemoteChannel`](@ref)ãããå¤ã® `put/take` ãè¡ããã¨ãã§ãã¾ãã ãã¼ã¿ã¯[`RemoteChannel`]"
"(@ref)ãé¢é£ä»ãããã¦ãããã­ã»ã¹ã«èªåçã«éä¿¡(ã¾ãã¯åå¾)ããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1048
msgid ""
"Serializing a [`Channel`](@ref) also serializes any data present in the channel. Deserializing it therefore effectively makes a copy of the "
"original object."
msgstr ""
"[`Channel`](@ref)ãã·ãªã¢ã«åããã¨ããã£ãã«ã«å­å¨ãããã¼ã¿ãã·ãªã¢ã«åããã¾ãããããã£ã¦ãéã·ãªã¢ã«åããã¨ãåã®ãªãã¸ã§ã¯ãã®ã³ãã¼ã"
"å¹æçã«ä½æã§ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1048
msgid ""
"On the other hand, serializing a [`RemoteChannel`](@ref) only involves the serialization of an identifier that identifies the location and "
"instance of [`Channel`](@ref) referred to by the handle. A deserialized [`RemoteChannel`](@ref) object (on any worker), therefore also "
"points to the same backing store as the original."
msgstr ""
"ä¸æ¹ã[`RemoteChannel`](@ref)ã®ã·ãªã¢ã«åã«ã¯ããã³ãã«ã«ãã£ã¦åç§ããã[`Channel`](@ref)ã®å ´æã¨ã¤ã³ã¹ã¿ã³ã¹ãè­å¥ããè­å¥å­ã®ã·ãªã¢ã«åã®"
"ã¿ãå«ã¾ãã¾ããä»»æã®ã¯ã¼ã«ã¼ä¸ã® éã·ãªã¢ã«åããã [`RemoteChannel`](@ref) ãªãã¸ã§ã¯ãã¯ãåã®ããã­ã³ã° ã¹ãã¢ã¨åãããã­ã³ã° ã¹ãã¢ã"
"æãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1051
msgid "The channels example from above can be modified for interprocess communication, as shown below."
msgstr "ä¸è¨ã®ãã£ãã«ä¾ã¯ãä»¥ä¸ã«ç¤ºãããã«ããã­ã»ã¹ééä¿¡ç¨ã«å¤æ´ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1056
msgid ""
"We start 4 workers to process a single `jobs` remote channel. Jobs, identified by an id (`job_id`), are written to the channel. Each "
"remotely executing task in this simulation reads a `job_id`, waits for a random amount of time and writes back a tuple of `job_id`, time "
"taken and its own `pid` to the results channel. Finally all the `results` are printed out on the master process."
msgstr ""
"ããã§ã¯ãã¸ã§ããæ ¼ç´ãã åä¸ã®ãªã¢ã¼ããã£ãã«ãå¦çããããã«4ã¤ã®ã¯ã¼ã«ã¼ãç«ã¡ä¸ãã¾ããID (`job_id`) ã«ãã£ã¦è­å¥ãããã¸ã§ãã¯ããã£"
"ãã«ã«æ¸ãè¾¼ã¾ãã¾ãããã®ã·ãã¥ã¬ã¼ã·ã§ã³ã§ãªã¢ã¼ãã§å®è¡ãã¦ããåã¿ã¹ã¯ã¯ `job_id`ãèª­ã¿åããã©ã³ãã ãªæéã ãå¾æ©ãã`job_id`ã®ã¿ãã«ã"
"æéãããã³ç¬èªã®`pid`ã \"results\" ãã£ãã«ã«æ¸ãæ»ãã¾ããæå¾ã«ããã¹ã¦ã®çµæããã¹ã¿ã¼ãã­ã»ã¹ã«ããªã³ãåºåããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1057
#, no-wrap
msgid ""
"julia> addprocs(4); # add worker processes\n"
"\n"
"julia> const jobs = RemoteChannel(()->Channel{Int}(32));\n"
"\n"
"julia> const results = RemoteChannel(()->Channel{Tuple}(32));\n"
"\n"
"julia> @everywhere function do_work(jobs, results) # define work function everywhere\n"
"           while true\n"
"               job_id = take!(jobs)\n"
"               exec_time = rand()\n"
"               sleep(exec_time) # simulates elapsed time doing actual work\n"
"               put!(results, (job_id, exec_time, myid()))\n"
"           end\n"
"       end\n"
"\n"
"julia> function make_jobs(n)\n"
"           for i in 1:n\n"
"               put!(jobs, i)\n"
"           end\n"
"       end;\n"
"\n"
"julia> n = 12;\n"
"\n"
"julia> @async make_jobs(n); # feed the jobs channel with \"n\" jobs\n"
"\n"
"julia> for p in workers() # start tasks on the workers to process requests in parallel\n"
"           remote_do(do_work, p, jobs, results)\n"
"       end\n"
"\n"
"julia> @elapsed while n > 0 # print out results\n"
"           job_id, exec_time, where = take!(results)\n"
"           println(\"$job_id finished in $(round(exec_time; digits=2)) seconds on worker $where\")\n"
"           global n = n - 1\n"
"       end\n"
"1 finished in 0.18 seconds on worker 4\n"
"2 finished in 0.26 seconds on worker 5\n"
"6 finished in 0.12 seconds on worker 4\n"
"7 finished in 0.18 seconds on worker 4\n"
"5 finished in 0.35 seconds on worker 5\n"
"4 finished in 0.68 seconds on worker 2\n"
"3 finished in 0.73 seconds on worker 3\n"
"11 finished in 0.01 seconds on worker 3\n"
"12 finished in 0.02 seconds on worker 3\n"
"9 finished in 0.26 seconds on worker 5\n"
"8 finished in 0.57 seconds on worker 4\n"
"10 finished in 0.58 seconds on worker 2\n"
"0.055971741\n"
msgstr ""
"julia> addprocs(4); # add worker processes\n"
"\n"
"julia> const jobs = RemoteChannel(()->Channel{Int}(32));\n"
"\n"
"julia> const results = RemoteChannel(()->Channel{Tuple}(32));\n"
"\n"
"julia> @everywhere function do_work(jobs, results) # define work function everywhere\n"
"           while true\n"
"               job_id = take!(jobs)\n"
"               exec_time = rand()\n"
"               sleep(exec_time) # simulates elapsed time doing actual work\n"
"               put!(results, (job_id, exec_time, myid()))\n"
"           end\n"
"       end\n"
"\n"
"julia> function make_jobs(n)\n"
"           for i in 1:n\n"
"               put!(jobs, i)\n"
"           end\n"
"       end;\n"
"\n"
"julia> n = 12;\n"
"\n"
"julia> @async make_jobs(n); # feed the jobs channel with \"n\" jobs\n"
"\n"
"julia> for p in workers() # start tasks on the workers to process requests in parallel\n"
"           remote_do(do_work, p, jobs, results)\n"
"       end\n"
"\n"
"julia> @elapsed while n > 0 # print out results\n"
"           job_id, exec_time, where = take!(results)\n"
"           println(\"$job_id finished in $(round(exec_time; digits=2)) seconds on worker $where\")\n"
"           global n = n - 1\n"
"       end\n"
"1 finished in 0.18 seconds on worker 4\n"
"2 finished in 0.26 seconds on worker 5\n"
"6 finished in 0.12 seconds on worker 4\n"
"7 finished in 0.18 seconds on worker 4\n"
"5 finished in 0.35 seconds on worker 5\n"
"4 finished in 0.68 seconds on worker 2\n"
"3 finished in 0.73 seconds on worker 3\n"
"11 finished in 0.01 seconds on worker 3\n"
"12 finished in 0.02 seconds on worker 3\n"
"9 finished in 0.26 seconds on worker 5\n"
"8 finished in 0.57 seconds on worker 4\n"
"10 finished in 0.58 seconds on worker 2\n"
"0.055971741\n"

#. type: Title ###
#: ext/julia/doc/src/manual/parallel-computing.md:1107
#, no-wrap
msgid "Remote References and Distributed Garbage Collection"
msgstr "ãªã¢ã¼ãåç§ã¨åæ£ã¬ãã¼ã¸ ã³ã¬ã¯ã·ã§ã³"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1111
msgid "Objects referred to by remote references can be freed only when *all* held references in the cluster are deleted."
msgstr "ãªã¢ã¼ãåç§ã§åç§ããããªãã¸ã§ã¯ãã¯ãã¯ã©ã¹ã¿ã¼åã«ä¿æããã¦ãã*å¨ã¦ã®* åç§ãåé¤ãããå ´åã«ã®ã¿è§£æ¾ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1119
msgid ""
"The node where the value is stored keeps track of which of the workers have a reference to it.  Every time a [`RemoteChannel`](@ref) or a "
"(unfetched) [`Future`](@ref Distributed.Future) is serialized to a worker, the node pointed to by the reference is notified. And every time "
"a [`RemoteChannel`](@ref) or a (unfetched) [`Future`](@ref Distributed.Future) is garbage collected locally, the node owning the value is "
"again notified. This is implemented in an internal cluster aware serializer. Remote references are only valid in the context of a running "
"cluster. Serializing and deserializing references to and from regular `IO` objects is not supported."
msgstr ""
"å¤ãæ ¼ç´ããã¦ãããã¼ãã¯ãã©ã®ã¯ã¼ã«ã¼ããã®å¤ãåç§ãã¦ããããè¿½è·¡ãã¾ãã [`RemoteChannel`](@ref)ã¾ãã¯(ãã§ããããã¦ããªã)[`Future`]"
"(@ref Distributed.Future)ãã¯ã¼ã«ã¼ã«ã·ãªã¢ã«åããããã³ã«ãåç§ã«ãã£ã¦æãç¤ºããããã¼ããéç¥ããã¾ããã¾ãã[`RemoteChannel`](@ref)ã¾ã"
"ã¯(ãã§ããããã¦ããªã)[`Future`](@ref Distributed.Future)ãã­ã¼ã«ã«ã«åéããããã³ã«ãå¤ãææãããã¼ããååº¦éç¥ããã¾ããããã¯ãåé¨ã¯"
"ã©ã¹ã¿ã¼å¯¾å¿ã·ãªã¢ã©ã¤ã¶ã¼ã§å®è£ããã¾ãããªã¢ã¼ãåç§ã¯ãå®è¡ä¸­ã®ã¯ã©ã¹ã¿ã¼ã®ã³ã³ãã­ã¹ãã§ã®ã¿æå¹ã§ããéå¸¸ã® `IO`ãªãã¸ã§ã¯ãããã®åç§ã"
"éå¸¸ã® `IO`ãªãã¸ã§ã¯ãã¸ã®åç§ã®ã·ãªã¢ã«åã¨éã·ãªã¢ã«åã¯ãµãã¼ãããã¦ãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1123
msgid ""
"The notifications are done via sending of \"tracking\" messages--an \"add reference\" message when a reference is serialized to a different "
"process and a \"delete reference\" message when a reference is locally garbage collected."
msgstr ""
"éç¥ã¯ãããã©ãã­ã³ã°ãã¡ãã»ã¼ã¸ã®éä¿¡ãä»ãã¦è¡ããã¾ãããã®ã¡ãã»ã¼ã¸ã¨ã¯ãåç§ãå¥ã®ãã­ã»ã¹ã«ã·ãªã¢ã«åãããã¨ãã«ã¯ããåç§ã®è¿½å ã"
"ã¡ãã»ã¼ã¸ã§ãããåç§ãã­ã¼ã«ã«ã®ã¬ãã¼ã¸ ã³ã¬ã¯ã·ã§ã³ã§å¦çãããã¨ãã«ã¯ãåç§ãåé¤ãã¡ãã»ã¼ã¸ã«ç¸å½ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1126
msgid ""
"Since [`Future`](@ref Distributed.Future)s are write-once and cached locally, the act of [`fetch`](@ref)ing a [`Future`](@ref Distributed."
"Future) also updates reference tracking information on the node owning the value."
msgstr ""
"[`Future`](@ref Distributed.Future)ã¯ãæ¸ãè¾¼ã¿ãä¸åº¦ã§ãã­ã¼ã«ã«ã«ã­ã£ãã·ã¥ãããã®ã§ã [`fetch`](@ref Distributed.Future)ã®æ¯ãèãã¯ãã"
"ã®å¤ãææãã¦ãããã¼ãã®åç§è¿½è·¡æå ±ã®æ´æ°ãè¡ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1128
msgid "The node which owns the value frees it once all references to it are cleared."
msgstr "å¤ãææãããã¼ãã¯ãå¤ã¸ã®ãã¹ã¦ã®åç§ãã¯ãªã¢ãããã¨ãå¤(ã®ã¡ã¢ãªã)è§£æ¾ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1131
msgid ""
"With [`Future`](@ref Distributed.Future)s, serializing an already fetched [`Future`](@ref Distributed.Future) to a different node also sends "
"the value since the original remote store may have collected the value by this time."
msgstr ""
"[`Future`](@ref Distributed.Future)ãä½¿ç¨ããã¨ãæ¢ã«ãã§ããããã [`Future`](@ref Distributed.Future) ãå¥ã®ãã¼ãã«ã·ãªã¢ã«åããã¨ã(åç§"
"ã ãã§ãªã)å¤ãã®ãã®ãéä¿¡ããã¾ããåã®ãªã¢ã¼ã ã¹ãã¢ãç¾æç¹ã¾ã§ã®éã«å¤ãåéããå¯è½æ§ãããããã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1134
msgid ""
"It is important to note that *when* an object is locally garbage collected depends on the size of the object and the current memory pressure "
"in the system."
msgstr ""
"*ãã¤*ãªãã¸ã§ã¯ããã­ã¼ã«ã«ã«åéããããã¯ããªãã¸ã§ã¯ãã®ãµã¤ãºã¨ã·ã¹ãã åã®ç¾å¨ã®ã¡ã¢ãªè² è·ã«ãã£ã¦ç°ãªããã¨ãããã¨ã¯æ³¨æãã¹ãã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1142
msgid ""
"In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite "
"large. Since the local object may not be collected immediately, it is a good practice to explicitly call [`finalize`](@ref) on local "
"instances of a [`RemoteChannel`](@ref), or on unfetched [`Future`](@ref Distributed.Future)s. Since calling [`fetch`](@ref)  on a [`Future`]"
"(@ref Distributed.Future) also removes its reference from the remote store, this is not required on fetched [`Future`](@ref Distributed."
"Future)s. Explicitly calling [`finalize`](@ref) results in an immediate message sent to the remote node to go ahead and remove its reference "
"to the value."
msgstr ""
"ãªã¢ã¼ãåç§ã®å ´åããªã¢ã¼ããã¼ãã«ããå¤ãéå¸¸ã«å¤§ãããªãå¯è½æ§ãããã®ã§ãããã­ã¼ã«ã«åç§ãªãã¸ã§ã¯ãã®ãµã¤ãºã¯éå¸¸ã«å°ãããªãã¾ãã"
"ã­ã¼ã«ã«ãªãã¸ã§ã¯ãã¯ããã«åéãããªããã¨ãããããã[`RemoteChannel`](@ref Distributed.Future)ã®ã­ã¼ã«ã«ã¤ã³ã¹ã¿ã³ã¹ãããã§ããããã¦ã"
"ãªã[`Future`](@ref Distributed.Future)ã«å¯¾ãã¦ã[`finalize`](@ref) ãæç¤ºçã«å¼ã¶ã®ã¯ããã¢ã¤ãã£ã¢ã§ãã[`Future`](@ref Distributed.Future)"
"ã«å¯¾ãã¦[`fetch`](@ref)ãå¼ã¶ã¨ããã®åç§ããªã¢ã¼ãã¹ãã¢ããåé¤ããã¦ãã¾ãã®ã§ããã§ããããã[`Future`](@ref Distributed.Future)ã«ã¤ãã¦"
"ã¯ãfinalizeããå¿è¦ã¯ããã¾ãããæç¤ºçã«[`finalize`](@ref)ãå¼ã¶ã¨ãªã¢ã¼ããã¼ãã«å¯¾ãã¦ããã«ã¡ãã»ã¼ã¸ãéä¿¡ããã¦ãå¦çãåã«é²ã¿ãå¤ã¸"
"ã®åç§ãåé¤ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1144
msgid "Once finalized, a reference becomes invalid and cannot be used in any further calls."
msgstr "ãã£ãããã¡ã¤ãã©ã¤ãºãããã¨ãåç§ã¯ç¡å¹ã«ãªããããä»¥éã®å¼ã³åºãã§ã¯ä½¿ç¨ã§ãã¾ããã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:1146
#, no-wrap
msgid "Local invocations(@id man-distributed-local-invocations)"
msgstr "[ã­ã¼ã«ã«å¼ã³åºã](@id man-distributed-local-invocations)"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1156
msgid ""
"Data is necessarily copied over to the remote node for execution. This is the case for both remotecalls and when data is stored to "
"a[`RemoteChannel`](@ref) / [`Future`](@ref Distributed.Future) on a different node. As expected, this results in a copy of the serialized "
"objects on the remote node. However, when the destination node is the local node, i.e.  the calling process id is the same as the remote "
"node id, it is executed as a local call. It is usually(not always) executed in a different task - but there is no serialization/"
"deserialization of data. Consequently, the call refers to the same object instances as passed - no copies are created. This behavior is "
"highlighted below:"
msgstr ""
"ãã¼ã¿ã¯ãå¦çãå®è¡ããããªã¢ã¼ããã¼ãã«å¿ãã³ãã¼ããã¾ããããã¯ãremotecallãããå ´åããã¼ã¿ã[`RemoteChannel`](@ref) ã«æ ¼ç´ããããå¥"
"ã®ãã¼ãã§ [`Future`](@ref Distributed.Future)ãå¼ã°ããå ´åã§ãåæ§ã§ããäºæ³ã§ããããã«ãããã¯ãªã¢ã¼ããã¼ãã§ã®ã·ãªã¢ã«åããããªãã¸ã§"
"ã¯ãã®ã³ãã¼ã¨ãªãã¾ããããªãã¡ãå¼ã³åºããè¡ããã­ã»ã¹ã®IDã¨ããªã¢ã¼ãã®ãã¼ãã®IDã¯åãã§ãã­ã¼ã«ã«å¼ã³åºãã¨ãã¦å®è¡ããã¾ããå¤§æµã®å ´å"
"(å¸¸ã«ãã§ã¯ããã¾ãã)ã¯ãå¥ã®ã¿ã¹ã¯ã§å®è¡ããããããããã§ã¯ãã¼ã¿ã®ã·ãªã¢ã©ã¤ãº/éã·ãªã¢ã©ã¤ãºã®å¦çã¯çºçãã¾ãããå¼ã³åºãã§ã¯ãåãæ¸¡ã"
"ãããªãã¸ã§ã¯ãã¤ã³ã¹ã¿ã³ã¹ã¨å¨ãåããã®ãåç§ãã¦ãã³ãã¼ã¯ã¤ãããã¾ãããããã§è¿°ã¹ãæ¯ãèãã¯ãä»¥ä¸ã®ä¾ã§ããåããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1157
#, no-wrap
msgid ""
"julia> using Distributed;\n"
"\n"
"julia> rc = RemoteChannel(()->Channel(3));   # RemoteChannel created on local node\n"
"\n"
"julia> v = [0];\n"
"\n"
"julia> for i in 1:3\n"
"           v[1] = i                          # Reusing `v`\n"
"           put!(rc, v)\n"
"       end;\n"
"\n"
"julia> result = [take!(rc) for _ in 1:3];\n"
"\n"
"julia> println(result);\n"
"Array{Int64,1}[[3], [3], [3]]\n"
"\n"
"julia> println(\"Num Unique objects : \", length(unique(map(objectid, result))));\n"
"Num Unique objects : 1\n"
"\n"
"julia> addprocs(1);\n"
"\n"
"julia> rc = RemoteChannel(()->Channel(3), workers()[1]);   # RemoteChannel created on remote node\n"
"\n"
"julia> v = [0];\n"
"\n"
"julia> for i in 1:3\n"
"           v[1] = i\n"
"           put!(rc, v)\n"
"       end;\n"
"\n"
"julia> result = [take!(rc) for _ in 1:3];\n"
"\n"
"julia> println(result);\n"
"Array{Int64,1}[[1], [2], [3]]\n"
"\n"
"julia> println(\"Num Unique objects : \", length(unique(map(objectid, result))));\n"
"Num Unique objects : 3\n"
msgstr ""
"julia> using Distributed;\n"
"\n"
"julia> rc = RemoteChannel(()->Channel(3));   # RemoteChannel created on local node\n"
"\n"
"julia> v = [0];\n"
"\n"
"julia> for i in 1:3\n"
"           v[1] = i                          # Reusing `v`\n"
"           put!(rc, v)\n"
"       end;\n"
"\n"
"julia> result = [take!(rc) for _ in 1:3];\n"
"\n"
"julia> println(result);\n"
"Array{Int64,1}[[3], [3], [3]]\n"
"\n"
"julia> println(\"Num Unique objects : \", length(unique(map(objectid, result))));\n"
"Num Unique objects : 1\n"
"\n"
"julia> addprocs(1);\n"
"\n"
"julia> rc = RemoteChannel(()->Channel(3), workers()[1]);   # RemoteChannel created on remote node\n"
"\n"
"julia> v = [0];\n"
"\n"
"julia> for i in 1:3\n"
"           v[1] = i\n"
"           put!(rc, v)\n"
"       end;\n"
"\n"
"julia> result = [take!(rc) for _ in 1:3];\n"
"\n"
"julia> println(result);\n"
"Array{Int64,1}[[1], [2], [3]]\n"
"\n"
"julia> println(\"Num Unique objects : \", length(unique(map(objectid, result))));\n"
"Num Unique objects : 3\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1200
msgid ""
"As can be seen, [`put!`](@ref) on a locally owned [`RemoteChannel`](@ref) with the same object `v` modifed between calls results in the same "
"single object instance stored. As opposed to copies of `v` being created when the node owning `rc` is a different node."
msgstr ""
"ãè¦§ã®éããã­ã¼ã«ã«ã§ææããã[`RemoteChannel`](@ref)ã¨`v` ã«å¯¾ãã¦[`put!`](@ref) ã(è¤æ°å)å¼ã¶å ´åããã®è¤æ°åã®å¼ã³åºãã®éã« `v` ãä¿®æ­£"
"ããã¨ãåä¸ã®ãªãã¸ã§ã¯ãã¤ã³ã¹ã¿ã³ã¹ãæ ¼ç´ããã¾ããå¯¾è±¡çã«ã`rc` ãææãããã¼ããå¥ã®ãã¼ãã§ããæã(ãã®æãã®)`v`ã®ã³ãã¼ãçæãã"
"ãã®ã¨å¯¾è±¡çã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1204
msgid ""
"It is to be noted that this is generally not an issue. It is something to be factored in only if the object is both being stored locally and "
"modifed post the call. In such cases it may be appropriate to store a `deepcopy` of the object."
msgstr ""
"ãã®æ¯ãèãã¯ãä¸è¬çã«ã¯å¤§ããåé¡ã«ã¯ãªããªãã¨æã£ã¦ãã ããããã®æ¯ãèããèæ®ããå¿è¦ãããã¨ããã°ãããã¯ããªãã¸ã§ã¯ããã­ã¼ã«ã«ã«"
"æ ¼ç´ããããã®å¾ (`put!`ãªã©ã®)å¼ã³åºãã®å¾ã§ããã®ãªãã¸ã§ã¯ããå¤æ´ãããç¶æ³ã ãã§ãããã®ãããªå ´åã¯ããªãã¸ã§ã¯ãã®ããã£ã¼ãã³ãã¼ãã"
"ä¿å­ããã®ãé©åã§ãããã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1206
msgid "This is also true for remotecalls on the local node as seen in the following example:"
msgstr "ããã¯ãæ¬¡ã®ä¾ã«ç¤ºãããã«ãã­ã¼ã«ã« ãã¼ãã®`remotecall`ã«ãå½ã¦ã¯ã¾ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1207
#, no-wrap
msgid ""
"julia> using Distributed; addprocs(1);\n"
"\n"
"julia> v = [0];\n"
"\n"
"julia> v2 = remotecall_fetch(x->(x[1] = 1; x), myid(), v);     # Executed on local node\n"
"\n"
"julia> println(\"v=$v, v2=$v2, \", v === v2);\n"
"v=[1], v2=[1], true\n"
"\n"
"julia> v = [0];\n"
"\n"
"julia> v2 = remotecall_fetch(x->(x[1] = 1; x), workers()[1], v); # Executed on remote node\n"
"\n"
"julia> println(\"v=$v, v2=$v2, \", v === v2);\n"
"v=[0], v2=[1], false\n"
msgstr ""
"julia> using Distributed; addprocs(1);\n"
"\n"
"julia> v = [0];\n"
"\n"
"julia> v2 = remotecall_fetch(x->(x[1] = 1; x), myid(), v);     # Executed on local node\n"
"\n"
"julia> println(\"v=$v, v2=$v2, \", v === v2);\n"
"v=[1], v2=[1], true\n"
"\n"
"julia> v = [0];\n"
"\n"
"julia> v2 = remotecall_fetch(x->(x[1] = 1; x), workers()[1], v); # Executed on remote node\n"
"\n"
"julia> println(\"v=$v, v2=$v2, \", v === v2);\n"
"v=[0], v2=[1], false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1228
msgid ""
"As can be seen once again, a remote call onto the local node behaves just like a direct invocation.  The call modifies local objects passed "
"as arguments. In the remote invocation, it operates on a copy of the arguments."
msgstr ""
"ããã§ãã¾ããè¦§ã®éããã­ã¼ã«ã« ãã¼ãã¸ã® `remotecall` ã¯ãç´æ¥å¼ã³åºãã¨åæ§ã«æ©è½ãã¾ãã ã­ã¼ã«ã«ãã¼ãã¸ã® `remotecall` ã¯ãå¼æ°ã¨ãã¦"
"æ¸¡ãããã­ã¼ã«ã« ãªãã¸ã§ã¯ããå¤æ´ãã¾ãããªã¢ã¼ãå¼ã³åºãã§ã¯ãå¼æ°ã®ã³ãã¼ã«å¯¾ããå¦çã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1233
msgid ""
"To repeat, in general this is not an issue. If the local node is also being used as a compute node, and the arguments used post the call, "
"this behavior needs to be factored in and if required deep copies of arguments must be passed to the call invoked on the local node. Calls "
"on remote nodes will always operate on copies of arguments."
msgstr ""
"ç¹°ãè¿ãã¾ãããä¸è¬çã«ãã®ãµãã¾ããåé¡ã«ãªããã¨ã¯ããã¾ããããããã­ã¼ã«ã« ãã¼ããã³ã³ãã¥ã¼ãã£ã³ã° ãã¼ãã¨ãã¦ãä½¿ç¨ãããå¼æ°ã "
"ã­ã¼ã«ã«å¼ã³åºãã®å¾ã«ãä½¿ç¨ãããã¨ããã°ãããã§è§¦ããæ¯ãèããèæ®ããå¿è¦ãããã¾ããå·ä½çã«ã¯ãå¿è¦ã«å¿ãã¦å¼æ°ã®ãã£ã¼ãã³ãã¼ãç¨æ"
"ãã¦ã­ã¼ã«ã«ãã¼ãã§å¼ã³åºãããå¼ã³åºãã«æ¸¡ãå¿è¦ãããã¾ãããããããªã¢ã¼ã ãã¼ãã®å¼ã³åºãã¯ãå¸¸ã«å¼æ°ã®ã³ãã¼ã§åä½ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:1235
#, no-wrap
msgid "[Shared Arrays](@id man-shared-arrays)"
msgstr "[å±æéå](@id man-shared-arrays)"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1244
msgid ""
"Shared Arrays use system shared memory to map the same array across many processes. While there are some similarities to a [`DArray`]"
"(https://github.com/JuliaParallel/DistributedArrays.jl), the behavior of a [`SharedArray`](@ref) is quite different. In a [`DArray`](https://"
"github.com/JuliaParallel/DistributedArrays.jl), each process has local access to just a chunk of the data, and no two processes share the "
"same chunk; in contrast, in a [`SharedArray`](@ref) each \"participating\" process has access to the entire array.  A [`SharedArray`](@ref) "
"is a good choice when you want to have a large amount of data jointly accessible to two or more processes on the same machine."
msgstr ""
"å±æã¢ã¬ã¤ã¯ãã·ã¹ãã ã®å±æã¡ã¢ãªãä½¿ç¨ãã¦ãè¤æ°ã®ãã­ã»ã¹ã§åãéåãããããã¾ãã\n"
"[`SharedArray`](@ref) ã¯ã [`DArray`](https://github.com/JuliaParallel/DistributedArrays.jl) ã¨ã¯ããã¤ãã®é¡ä¼¼ç¹ããããã®ã®ã\n"
"ãã®åä½ã¯å¨ãç°ãªãã¾ãã [`DArray`](https://github.com/JuliaParallel/DistributedArrays.jl) ã§ã¯ã\n"
"åãã­ã»ã¹ã¯ãã¼ã¿ãã£ã³ã¯ã«å¯¾ããã­ã¼ã«ã«ã¢ã¯ã»ã¹æ¨©ãæã¡ã 2ã¤ã®ãã­ã»ã¹ãåããã£ã³ã¯ãå±æãã¾ããã\n"
"å¯¾ç§çã«ã [`SharedArray`](@ref) ã§ã¯ãéåã®å±æã«ãåå ãã¦ããããã­ã»ã¹ã¯ã¢ã¬ã¤å¨ä½ã«ã¢ã¯ã»ã¹ã§ãã¾ãã\n"
" [`SharedArray`](@ref) ã¯ãåããã·ã³ä¸ã®è¤æ°ã®ãã­ã»ã¹ãå±åã§ãå¤§éã®ãã¼ã¿ã¢ã¯ã»ã¹ããããå ´åã«é©ãã¦ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1247
msgid "Shared Array support is available via module `SharedArrays` which must be explicitly loaded on all participating workers."
msgstr "å±æéåã«ãµãã¼ãããã«ã¯ãåå ãããã¹ã¦ã®ã¯ã¼ã«ã¼ã§ `SharedArray` ã¢ã¸ã¥ã¼ã«ãæç¤ºçã«ã­ã¼ãããå¿è¦ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1254
msgid ""
"[`SharedArray`](@ref) indexing (assignment and accessing values) works just as with regular arrays, and is efficient because the underlying "
"memory is available to the local process. Therefore, most algorithms work naturally on [`SharedArray`](@ref)s, albeit in single-process "
"mode. In cases where an algorithm insists on an [`Array`](@ref) input, the underlying array can be retrieved from a [`SharedArray`](@ref) by "
"calling [`sdata`](@ref). For other `AbstractArray` types, [`sdata`](@ref)  just returns the object itself, so it's safe to use [`sdata`]"
"(@ref) on any `Array`-type object."
msgstr ""
"[`SharedArray`](@ref) ã®æ·»å­ã¢ã¯ã»ã¹ (å¤ã®ä»£å¥ã¨åç§) ã¯éå¸¸ã®éåã¨åæ§ã«æ©è½ãã¾ããã¾ããå®éã«å¤ãæ ¼ç´ããã¦ããã¡ã¢ãªã«ã­ã¼ã«ã« ãã­ã»ã¹"
"ããã¢ã¯ã»ã¹ã§ããããå¹ççã§ãããããã£ã¦ã(ãã«ããã­ã»ã¹æ³å®ã§å®è£ããã) ã»ã¨ãã©ã®ã¢ã«ã´ãªãºã ã¯ãåä¸ãã­ã»ã¹ã¢ã¼ãã ã¨ãã¦ãã"
"[`SharedArray`](@ref) ä¸ã§èªç¶ã«åä½ãã¾ããã¢ã«ã´ãªãºã ã« [`Array`](@ref) å¥åãå¿è¦ãªå ´åãå®éã«å¤ãæ ¼ç´ãã¦ããéåã¯[`sdata`](@ref) ãå¼"
"ã³åºããã¨ã«ãã£ã¦ [`SharedArray`](@ref) ããåå¾ã§ãã¾ããä»ã® `AbstractArray` åã®å ´åã¯ã [`sdata`](@ref) ã¯ãªãã¸ã§ã¯ããã®ãã®ãè¿ãã¾"
"ãããªã®ã§ã( `SharedArray` ãã©ããæ°ã«ãã) `Array` åãªãã¸ã§ã¯ãã§ [`sdata`](@ref) ãä½¿ç¨ãã¦ãå®å¨ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1256
msgid "The constructor for a shared array is of the form:"
msgstr "å±æéåã®ã³ã³ã¹ãã©ã¯ã¿ã¯ãæ¬¡ã®å½¢å¼ã§æ¸ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1257
#, no-wrap
msgid "SharedArray{T,N}(dims::NTuple; init=false, pids=Int[])\n"
msgstr "SharedArray{T,N}(dims::NTuple; init=false, pids=Int[])\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1265
msgid ""
"which creates an `N`-dimensional shared array of a bits type `T` and size `dims` across the processes specified by `pids`. Unlike "
"distributed arrays, a shared array is accessible only from those participating workers specified by the `pids` named argument (and the "
"creating process too, if it is on the same host)."
msgstr ""
"ãã®ã³ã³ã¹ãã©ã¯ã¿ã¯ããããå `T` ãè¦ç´ ã«ãã¡ã`dims` ã§æå®ããããµã¤ãºã® `N`æ¬¡åå±æéåã `pids` ã§æå®ããããã­ã»ã¹å¨ä½ã§ä½æãã¾ãã"
"åæ£éåã¨ã¯ç°ãªããå±æéåã¯`pids` ååä»ãå¼æ°ã§æå®ããã¦ãã å±æã«åå ãã¦ããã¯ã¼ã«ã¼ããã®ã¿ã¢ã¯ã»ã¹ã§ãã¾ã (åããã¹ãä¸ã«ããå ´å"
"ã¯ã¯ã¼ã«ã¼ãä½æããã¡ã¤ã³ãã­ã»ã¹ãããã¢ã¯ã»ã¹å¯è½ã§ã)ã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1269
msgid ""
"If an `init` function, of signature `initfn(S::SharedArray)`, is specified, it is called on all the participating workers. You can specify "
"that each worker runs the `init` function on a distinct portion of the array, thereby parallelizing initialization."
msgstr ""
"ã·ã°ããã£ `initfn(S:SharedArray)` ã® `init` é¢æ°ãæå®ããã¦ããå ´åã¯ããã®åæåé¢æ°ã¯ãåå ãã¦ãããã¹ã¦ã®ã¯ã¼ã«ã¼ã§å¼ã³åºããã¾ããå"
"ã¯ã¼ã«ã¼ãéåã®å¥åã®é¨åã§ `init` é¢æ°ãå®è¡ããåæåãä¸¦ååãããã¨ãæå®ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1271
msgid "Here's a brief example:"
msgstr "ç°¡åãªä¾ãæ¬¡ã«ç¤ºãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1272
#, no-wrap
msgid ""
"julia> using Distributed\n"
"\n"
"julia> addprocs(3)\n"
"3-element Array{Int64,1}:\n"
" 2\n"
" 3\n"
" 4\n"
"\n"
"julia> @everywhere using SharedArrays\n"
"\n"
"julia> S = SharedArray{Int,2}((3,4), init = S -> S[localindices(S)] = myid())\n"
"3Ã4 SharedArray{Int64,2}:\n"
" 2  2  3  4\n"
" 2  3  3  4\n"
" 2  3  4  4\n"
"\n"
"julia> S[3,2] = 7\n"
"7\n"
"\n"
"julia> S\n"
"3Ã4 SharedArray{Int64,2}:\n"
" 2  2  3  4\n"
" 2  3  3  4\n"
" 2  7  4  4\n"
msgstr ""
"julia> using Distributed\n"
"\n"
"julia> addprocs(3)\n"
"3-element Array{Int64,1}:\n"
" 2\n"
" 3\n"
" 4\n"
"\n"
"julia> @everywhere using SharedArrays\n"
"\n"
"julia> S = SharedArray{Int,2}((3,4), init = S -> S[localindices(S)] = myid())\n"
"3Ã4 SharedArray{Int64,2}:\n"
" 2  2  3  4\n"
" 2  3  3  4\n"
" 2  3  4  4\n"
"\n"
"julia> S[3,2] = 7\n"
"7\n"
"\n"
"julia> S\n"
"3Ã4 SharedArray{Int64,2}:\n"
" 2  2  3  4\n"
" 2  3  3  4\n"
" 2  7  4  4\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1302
msgid ""
"[`SharedArrays.localindices`](@ref) provides disjoint one-dimensional ranges of indices, and is sometimes convenient for splitting up tasks "
"among processes. You can, of course, divide the work any way you wish:"
msgstr ""
"[`SharedArrays.localindices`](@ref) ã¯ãã¤ã³ããã¯ã¹ã® 1 æ¬¡åã®ãªãã®ããã¤ã³ããã¯ã¹ç¯å²ãã³ã¢éã§éãªããªãæä¾ãã¾ãããã­ã»ã¹éã§ã¿ã¹ã¯ã"
"åå²ããã®ã«ä¾¿å©ãªãã¨ãããã¾ãããã¡ãããä½æ¥­ãä»»æã®æ¹æ³ã§åå²ãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1303
#, no-wrap
msgid ""
"julia> S = SharedArray{Int,2}((3,4), init = S -> S[indexpids(S):length(procs(S)):length(S)] = myid())\n"
"3Ã4 SharedArray{Int64,2}:\n"
" 2  2  2  2\n"
" 3  3  3  3\n"
" 4  4  4  4\n"
msgstr ""
"julia> S = SharedArray{Int,2}((3,4), init = S -> S[indexpids(S):length(procs(S)):length(S)] = myid())\n"
"3Ã4 SharedArray{Int64,2}:\n"
" 2  2  2  2\n"
" 3  3  3  3\n"
" 4  4  4  4\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1313
msgid "Since all processes have access to the underlying data, you do have to be careful not to set up conflicts. For example:"
msgstr "ãã¹ã¦ã®ãã­ã»ã¹ã¯å®ãã¼ã¿ã«ã¢ã¯ã»ã¹ã§ãããããç«¶åãçºçããªãããæ³¨æããå¿è¦ãããã¾ããä¾ãã°ï¼"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1314
#, no-wrap
msgid ""
"@sync begin\n"
"    for p in procs(S)\n"
"        @async begin\n"
"            remotecall_wait(fill!, p, S, p)\n"
"        end\n"
"    end\n"
"end\n"
msgstr ""
"@sync begin\n"
"    for p in procs(S)\n"
"        @async begin\n"
"            remotecall_wait(fill!, p, S, p)\n"
"        end\n"
"    end\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1327
msgid ""
"would result in undefined behavior. Because each process fills the *entire* array with its own `pid`, whichever process is the last to "
"execute (for any particular element of `S`) will have its `pid` retained."
msgstr ""
"ä¸è¨ã®ã³ã¼ãã®åä½ã¯æªå®ç¾©ã§ããåãã­ã»ã¹ã¯éå*å¨è¦ç´ *ã«èªåèªèº«ã®`pid`ã®æ°å­ãä»£å¥ãããã¨ããããã(ããããã®`S`ã®è¦ç´ ã«å¯¾ãã¦)ä»£å¥è¨ç®"
"ãæå¾ã«å®è¡ãããã­ã»ã¹ã®`pid`ãä¿æãããã¨ã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1329
msgid "As a more extended and complex example, consider running the following \"kernel\" in parallel:"
msgstr "ããçºå±çã»è¤éãªä¾ã¨ãã¦ãæ¬¡ã® \"ã«ã¼ãã«\" ãä¸¦è¡ãã¦å®è¡ããå ´åãèãã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1330
#, no-wrap
msgid "q[i,j,t+1] = q[i,j,t] + u[i,j,t]\n"
msgstr "q[i,j,t+1] = q[i,j,t] + u[i,j,t]\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1340
msgid ""
"In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if `q[i,j,t]` is near the end "
"of the block assigned to one worker and `q[i,j,t+1]` is near the beginning of the block assigned to another, it's very likely that `q[i,j,"
"t]` will not be ready at the time it's needed for computing `q[i,j,t+1]`. In such cases, one is better off chunking the array manually. "
"Let's split along the second dimension.  Define a function that returns the `(irange, jrange)` indices assigned to this worker:"
msgstr ""
"ãã®å ´åã1 æ¬¡åã¤ã³ããã¯ã¹ãä½¿ç¨ãã¦ä½æ¥­ãåå²ãããã¨ããã¨ãæ¬¡ã®ãããªåé¡ãçºçããå¯è½æ§ãããã¾ã: `q[i,j,t]` ãããã¯ã¼ã«ã¼ã«å²ãå½ã¦"
"ããããã­ãã¯ã®çµããä»è¿ã«ããã`q[i,j,t+1]` ãå¥ã®ã¯ã¼ã«ã¼ã«å²ãå½ã¦ããããã­ãã¯ã®åé ­ä»è¿ã«ããå ´åã`q[i,j,t]` ãè¨ç®ã«å¿è¦ãªæç¹ã§ã"
"æºååºæ¥ã¦ããªãå¯è½æ§ãéå¸¸ã«é«ãã§ãããã®ãããªå ´åã¯ãæåã§éåããã£ã³ã¯ããæ¹ãè¯ãã§ãããã2 çªç®ã®æ¬¡åã«æ²¿ã£ã¦åå²ãã¦ã¿ã¾ãããã "
"ãã®ã¯ã¼ã«ã¼ã«å²ãå½ã¦ããã `(irange,jrange)` ã¤ã³ããã¯ã¹ãè¿ãé¢æ°ãå®ç¾©ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1341
#, no-wrap
msgid ""
"julia> @everywhere function myrange(q::SharedArray)\n"
"           idx = indexpids(q)\n"
"           if idx == 0 # This worker is not assigned a piece\n"
"               return 1:0, 1:0\n"
"           end\n"
"           nchunks = length(procs(q))\n"
"           splits = [round(Int, s) for s in range(0, stop=size(q,2), length=nchunks+1)]\n"
"           1:size(q,1), splits[idx]+1:splits[idx+1]\n"
"       end\n"
msgstr ""
"julia> @everywhere function myrange(q::SharedArray)\n"
"           idx = indexpids(q)\n"
"           if idx == 0 # This worker is not assigned a piece\n"
"               return 1:0, 1:0\n"
"           end\n"
"           nchunks = length(procs(q))\n"
"           splits = [round(Int, s) for s in range(0, stop=size(q,2), length=nchunks+1)]\n"
"           1:size(q,1), splits[idx]+1:splits[idx+1]\n"
"       end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1354
msgid "Next, define the kernel:"
msgstr "æ¬¡ã«ãã«ã¼ãã«ãå®ç¾©ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1355
#, no-wrap
msgid ""
"julia> @everywhere function advection_chunk!(q, u, irange, jrange, trange)\n"
"           @show (irange, jrange, trange)  # display so we can see what's happening\n"
"           for t in trange, j in jrange, i in irange\n"
"               q[i,j,t+1] = q[i,j,t] + u[i,j,t]\n"
"           end\n"
"           q\n"
"       end\n"
msgstr ""
"julia> @everywhere function advection_chunk!(q, u, irange, jrange, trange)\n"
"           @show (irange, jrange, trange)  # display so we can see what's happening\n"
"           for t in trange, j in jrange, i in irange\n"
"               q[i,j,t+1] = q[i,j,t] + u[i,j,t]\n"
"           end\n"
"           q\n"
"       end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1366
msgid "We also define a convenience wrapper for a `SharedArray` implementation"
msgstr "ã¾ãã`SharedArray` å®è£ã«å©ä¾¿ãªã©ããã¼ãå®ç¾©ãã¾ã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1367
#, no-wrap
msgid ""
"julia> @everywhere advection_shared_chunk!(q, u) =\n"
"           advection_chunk!(q, u, myrange(q)..., 1:size(q,3)-1)\n"
msgstr ""
"julia> @everywhere advection_shared_chunk!(q, u) =\n"
"           advection_chunk!(q, u, myrange(q)..., 1:size(q,3)-1)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1373
msgid "Now let's compare three different versions, one that runs in a single process:"
msgstr "ããã3 ã¤ã®ç°ãªããã¼ã¸ã§ã³ãæ¯è¼ãã¦ã¿ã¾ããããï¼ã¤ç®ã¯1ã¤ã®ã³ã¢ã§å®è¡ããããã®:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1374
#, no-wrap
msgid "julia> advection_serial!(q, u) = advection_chunk!(q, u, 1:size(q,1), 1:size(q,2), 1:size(q,3)-1);\n"
msgstr "julia> advection_serial!(q, u) = advection_chunk!(q, u, 1:size(q,1), 1:size(q,2), 1:size(q,3)-1);\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1379
msgid "one that uses [`@distributed`](@ref):"
msgstr "ããã²ã¨ã¤ã¯ã [`@distributed`](@ref) ãä½¿ããã®:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1380
#, no-wrap
msgid ""
"julia> function advection_parallel!(q, u)\n"
"           for t = 1:size(q,3)-1\n"
"               @sync @distributed for j = 1:size(q,2)\n"
"                   for i = 1:size(q,1)\n"
"                       q[i,j,t+1]= q[i,j,t] + u[i,j,t]\n"
"                   end\n"
"               end\n"
"           end\n"
"           q\n"
"       end;\n"
msgstr ""
"julia> function advection_parallel!(q, u)\n"
"           for t = 1:size(q,3)-1\n"
"               @sync @distributed for j = 1:size(q,2)\n"
"                   for i = 1:size(q,1)\n"
"                       q[i,j,t+1]= q[i,j,t] + u[i,j,t]\n"
"                   end\n"
"               end\n"
"           end\n"
"           q\n"
"       end;\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1394
msgid "and one that delegates in chunks:"
msgstr "ããã¦ããã£ã³ã¯åä½ã§å¥ãã®ã³ã¢ã«è¨ç®ãä»»ãããã®:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1395
#, no-wrap
msgid ""
"julia> function advection_shared!(q, u)\n"
"           @sync begin\n"
"               for p in procs(q)\n"
"                   @async remotecall_wait(advection_shared_chunk!, p, q, u)\n"
"               end\n"
"           end\n"
"           q\n"
"       end;\n"
msgstr ""
"julia> function advection_shared!(q, u)\n"
"           @sync begin\n"
"               for p in procs(q)\n"
"                   @async remotecall_wait(advection_shared_chunk!, p, q, u)\n"
"               end\n"
"           end\n"
"           q\n"
"       end;\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1407
msgid "If we create `SharedArray`s and time these functions, we get the following results (with `julia -p 4`):"
msgstr "`SharedArray` ãä½æãããããã®é¢æ°ã®å®è¡æéãæ¸¬å®ããã¨ãæ¬¡ã®çµæãå¾ããã¾ã ( `julia -p 4` ã§å®è¡ããã¨ãã¾ã):"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1408
#, no-wrap
msgid ""
"julia> q = SharedArray{Float64,3}((500,500,500));\n"
"\n"
"julia> u = SharedArray{Float64,3}((500,500,500));\n"
msgstr ""
"julia> q = SharedArray{Float64,3}((500,500,500));\n"
"\n"
"julia> u = SharedArray{Float64,3}((500,500,500));\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1415
msgid "Run the functions once to JIT-compile and [`@time`](@ref) them on the second run:"
msgstr "JITã³ã³ãã¤ã«ã®ããã«ä¸åº¦é¢æ°ãå®è¡ãã¦ãããäºåç®ã®å®è¡ã§æ¸¬å®ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1416
#, no-wrap
msgid ""
"julia> @time advection_serial!(q, u);\n"
"(irange,jrange,trange) = (1:500,1:500,1:499)\n"
" 830.220 milliseconds (216 allocations: 13820 bytes)\n"
"\n"
"julia> @time advection_parallel!(q, u);\n"
"   2.495 seconds      (3999 k allocations: 289 MB, 2.09% gc time)\n"
"\n"
"julia> @time advection_shared!(q,u);\n"
"        From worker 2:       (irange,jrange,trange) = (1:500,1:125,1:499)\n"
"        From worker 4:       (irange,jrange,trange) = (1:500,251:375,1:499)\n"
"        From worker 3:       (irange,jrange,trange) = (1:500,126:250,1:499)\n"
"        From worker 5:       (irange,jrange,trange) = (1:500,376:500,1:499)\n"
" 238.119 milliseconds (2264 allocations: 169 KB)\n"
msgstr ""
"julia> @time advection_serial!(q, u);\n"
"(irange,jrange,trange) = (1:500,1:500,1:499)\n"
" 830.220 milliseconds (216 allocations: 13820 bytes)\n"
"\n"
"julia> @time advection_parallel!(q, u);\n"
"   2.495 seconds      (3999 k allocations: 289 MB, 2.09% gc time)\n"
"\n"
"julia> @time advection_shared!(q,u);\n"
"        From worker 2:       (irange,jrange,trange) = (1:500,1:125,1:499)\n"
"        From worker 4:       (irange,jrange,trange) = (1:500,251:375,1:499)\n"
"        From worker 3:       (irange,jrange,trange) = (1:500,126:250,1:499)\n"
"        From worker 5:       (irange,jrange,trange) = (1:500,376:500,1:499)\n"
" 238.119 milliseconds (2264 allocations: 169 KB)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1434
msgid ""
"The biggest advantage of `advection_shared!` is that it minimizes traffic among the workers, allowing each to compute for an extended time "
"on the assigned piece."
msgstr ""
"`advection_shared!` ã®æå¤§ã®å©ç¹ã¯ãã¯ã¼ã«ã¼éã®ãã©ãã£ãã¯ãæå°éã«æããå²ãå½ã¦ããããã¼ã¹ã«å¯¾ãã¦é·æéè¨ç®ã§ããããã«ãããã¨ã§ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/parallel-computing.md:1435
#, no-wrap
msgid "Shared Arrays and Distributed Garbage Collection"
msgstr "å±æéåã¨åæ£ã¬ãã¼ã¸ ã³ã¬ã¯ã·ã§ã³"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1441
msgid ""
"Like remote references, shared arrays are also dependent on garbage collection on the creating node to release references from all "
"participating workers. Code which creates many short lived shared array objects would benefit from explicitly finalizing these objects as "
"soon as possible.  This results in both memory and file handles mapping the shared segment being released sooner."
msgstr ""
"ãªã¢ã¼ãåç§ã¨åæ§ã«ãå±æéåãã¾ããéåãçæããããã¼ãã®ã¬ãã¼ã¸ ã³ã¬ã¯ã·ã§ã³ã«ä¾å­ãã¾ããããã§ããã¬ãã¼ã¸ã³ã¬ã¯ã·ã§ã³ã¯ããã®éåã"
"å±æãã¦ãããã¹ã¦ã®ã¯ã¼ã«ã¼ããã®åç§ãè§£æ¾ãããã®ã§ãããµã¤ãºãå°ããå±æéåãããããçæãããããªã³ã¼ãã¯ããããã®ãªãã¸ã§ã¯ããã§ã"
"ãã ãæ©ãæç¤ºçã«ãã¡ã¤ãã©ã¤ãºããã¨ãå¾ããã®ãå¤ãã§ããããçµæãã¡ã¢ãªãã³ãã«ã»ãã¡ã¤ã«ãã³ãã«ã®ä¸¡æ¹ã§ãããæ©ãè§£æ¾ãããå±æã»ã°ã¡"
"ã³ãããããã³ã°ãã¦ããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:1442
#, no-wrap
msgid "ClusterManagers"
msgstr "ã¯ã©ã¹ã¿ããã¼ã¸ã£"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1446
msgid ""
"The launching, management and networking of Julia processes into a logical cluster is done via cluster managers. A `ClusterManager` is "
"responsible for"
msgstr ""
"Julia ãã­ã»ã¹ã®èµ·åãç®¡çãããã³è«çã¯ã©ã¹ã¿ã¸ã®ãããã¯ã¼ã­ã³ã°ã¯ãã¯ã©ã¹ã¿ ããã¼ã¸ã£ãä»ãã¦è¡ããã¾ãã`ClusterManager` ãæå½ããã®ã¯"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1450
msgid "launching worker processes in a cluster environment"
msgstr "ã¯ã©ã¹ã¿ç°å¢ã§ã¯ã¼ã«ã¼ãã­ã»ã¹ãèµ·åãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1450
msgid "managing events during the lifetime of each worker"
msgstr "åã¯ã¼ã«ã¼ã®æå¹æéä¸­ã®ã¤ãã³ãã®ç®¡ç"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1450
msgid "optionally, providing data transport"
msgstr "å¿è¦ã«å¿ãã¦ããã¼ã¿è»¢éãæä¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1452
msgid "A Julia cluster has the following characteristics:"
msgstr "Julia ã¯ã©ã¹ã¿ã¼ã«ã¯ãæ¬¡ã®ç¹å¾´ãããã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1456
msgid "The initial Julia process, also called the `master`, is special and has an `id` of 1."
msgstr "`master`ã¨ãå¼ã°ããæåã®Juliaãã­ã»ã¹ã¯ç¹å¥ã§ããã1ã®`id`ãæã£ã¦ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1456
msgid "Only the `master` process can add or remove worker processes."
msgstr "ã¯ã¼ã«ã¼ãã­ã»ã¹ãè¿½å ã¾ãã¯åé¤ã§ããã®ã¯`master`ãã­ã»ã¹ã ãã§ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1456
msgid "All processes can directly communicate with each other."
msgstr "ãã¹ã¦ã®ãã­ã»ã¹ã¯ãäºãã«ç´æ¥éä¿¡ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1459
msgid "Connections between workers (using the in-built TCP/IP transport) is established in the following manner:"
msgstr "(çµã¿è¾¼ã¿ã® TCP/IP ãã©ã³ã¹ãã¼ããä½¿ç¨ãã¦) ã¯ã¼ã«ã¼éã®æ¥ç¶ã¯ãæ¬¡ã®æ¹æ³ã§ç¢ºç«ããã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1471
msgid "[`addprocs`](@ref) is called on the master process with a `ClusterManager` object."
msgstr "[`addprocs`](@ref) ã¯ã`ClusterManager` ãªãã¸ã§ã¯ããæã¤ãã¹ã¿ã¼ã»ãã­ã»ã¹ã§å¼ã³åºããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1471
msgid ""
"[`addprocs`](@ref) calls the appropriate [`launch`](@ref) method which spawns required number of worker processes on appropriate machines."
msgstr "[`addprocs`](@ref) ã¯ãè¦æ±ãããæ°ã®ã¯ã¼ã«ã¼ãã­ã»ã¹ãé©åãªãã·ã³ä¸ã§èµ·åããé©åãª [`launch`](@ref) ã¡ã½ãããå¼ã³åºãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1471
msgid "Each worker starts listening on a free port and writes out its host and port information to [`stdout`](@ref)."
msgstr "åã¯ã¼ã«ã¼ã¯ç©ºããã¼ãã§ãªãã¹ã³ãéå§ãããã¹ãã¨ãã¼ãã®æå ±ã [`stdout`](@ref)ã«æ¸ãåºãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1471
msgid "The cluster manager captures the [`stdout`](@ref) of each worker and makes it available to the master process."
msgstr "ã¯ã©ã¹ã¿ ããã¼ã¸ã£ã¯ãåã¯ã¼ã«ã¼ã® [`stdout`](@ref)ãã­ã£ããã£ãããã¹ã¿ã¼ãã­ã»ã¹ã§ä½¿ç¨ã§ããããã«ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1471
msgid "The master process parses this information and sets up TCP/IP connections to each worker."
msgstr "ãã¹ã¿ ãã­ã»ã¹ã¯ããã®æå ±ãè§£æããåã¯ã¼ã«ã¼ã¸ã® TCP/IP æ¥ç¶ãè¨­å®ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1471
msgid "Every worker is also notified of other workers in the cluster."
msgstr "ãã¹ã¦ã®ã¯ã¼ã«ã¼ã«ã¯ãã¯ã©ã¹ã¿ã¼åã®ä»ã®ã¯ã¼ã«ã¼ã®æå ±ãç¥ãããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1471
msgid "Each worker connects to all workers whose `id` is less than the worker's own `id`."
msgstr "åã¯ã¼ã«ã¼ã¯ã`id` ããã®ã¯ã¼ã«ã¼èªèº«ã® `id` ããå°ãããã¹ã¦ã®ã¯ã¼ã«ã¼ã«æ¥ç¶ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1471
msgid "In this way a mesh network is established, wherein every worker is directly connected with every other worker."
msgstr "ãã®ããã«ãã¦ã¡ãã·ã¥ ãããã¯ã¼ã¯ãç¢ºç«ããããã¹ã¦ã®ã¯ã¼ã«ã¼ãä»ã®ãã¹ã¦ã®ã¯ã¼ã«ã¼ã¨ç´æ¥æ¥ç¶ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1474
msgid "While the default transport layer uses plain [`TCPSocket`](@ref), it is possible for a Julia cluster to provide its own transport."
msgstr ""
"æ¢å®ã®ãã©ã³ã¹ãã¼ãå±¤ã§ã¯ããã¬ã¼ã³ [`TCPSocket`](@ref)ãä½¿ããã¾ãããJulia ã¯ã©ã¹ã¿ã¼ãç¬èªã®ãã©ã³ã¹ãã¼ããæä¾ããå ´åãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1476
msgid "Julia provides two in-built cluster managers:"
msgstr "Julia ã¯ãæ¬¡ã® 2 ã¤ã®çµã¿è¾¼ã¿ã¯ã©ã¹ã¿ ããã¼ã¸ã£ãæä¾ãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1479
msgid "`LocalManager`, used when [`addprocs()`](@ref) or [`addprocs(np::Integer)`](@ref) are called"
msgstr "`LocalManager`:   [`addprocs()`](@ref) ãããã¯ [`addprocs(np::Integer)`](@ref) ãå¼ã³åºãããæã«ä½¿ããã¾ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1479
msgid "`SSHManager`, used when [`addprocs(hostnames::Array)`](@ref) is called with a list of hostnames"
msgstr "`SSHManager`:  [`addprocs(hostnames::Array)`](@ref) ã hostname ã®ãªã¹ããä¼´ã£ã¦å¼ã³åºãããæã«ä½¿ããã¾ã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1482
msgid "`LocalManager` is used to launch additional workers on the same host, thereby leveraging multi-core and multi-processor hardware."
msgstr "`LocalManager` ã¯ãåããã¹ãä¸ã§è¿½å ã®ã¯ã¼ã«ã¼ãèµ·åããããã«ä½¿ç¨ããããã«ãã³ã¢ããã³ãã«ããã­ã»ããµ ãã¼ãã¦ã§ã¢ãæ´»ç¨ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1484
msgid "Thus, a minimal cluster manager would need to:"
msgstr "ãããã£ã¦ãæå°éã®ã¯ã©ã¹ã¿ ããã¼ã¸ã£ã¼ã¯æ¬¡ã®ãã¨ãå¿è¦ã«ãªãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1489
msgid "be a subtype of the abstract `ClusterManager`"
msgstr "æ½è±¡å `ClusterManager` ã®ãµãã¿ã¤ãã§ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1489
msgid "implement [`launch`](@ref), a method responsible for launching new workers"
msgstr "æ°ããã¯ã¼ã«ã¼ãç«ã¡ä¸ããã¡ã½ãã [`launch`](@ref) ãå®è£ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1489
msgid "implement [`manage`](@ref), which is called at various events during a worker's lifetime (for example, sending an interrupt signal)"
msgstr "ã¯ã¼ã«ã¼ã®æå¹æéä¸­ã«ãã¾ãã¾ãªã¤ãã³ãã§å¼ã³åºããã [`manage`](@ref) ãå®è£ãã (ä¾ãã°ãå²ãè¾¼ã¿ä¿¡å·ã®éä¿¡ãªã©)"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1491
msgid "[`addprocs(manager::FooManager)`](@ref addprocs) requires `FooManager` to implement:"
msgstr "[`addprocs(manager::FooManager)`](@ref addprocs) ãæ­£ããå¦çãããããã«ã¯ `FooManager` ã«æ¬¡ã®é¢æ°ãå®è£ããã¦ããå¿è¦ãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1492
#, no-wrap
msgid ""
"function launch(manager::FooManager, params::Dict, launched::Array, c::Condition)\n"
"    [...]\n"
"end\n"
"\n"
"function manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)\n"
"    [...]\n"
"end\n"
msgstr ""
"function launch(manager::FooManager, params::Dict, launched::Array, c::Condition)\n"
"    [...]\n"
"end\n"
"\n"
"function manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)\n"
"    [...]\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1504
msgid "As an example let us see how the `LocalManager`, the manager responsible for starting workers on the same host, is implemented:"
msgstr "ä¾ã¨ãã¦ãåããã¹ãã§ã¯ã¼ã«ã¼ãéå§ããããã¼ã¸ã£`LocalManager`ãã©ã®ããã«å®è£ããã¦ããããè¦ã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1505
#, no-wrap
msgid ""
"struct LocalManager <: ClusterManager\n"
"    np::Integer\n"
"end\n"
"\n"
"function launch(manager::LocalManager, params::Dict, launched::Array, c::Condition)\n"
"    [...]\n"
"end\n"
"\n"
"function manage(manager::LocalManager, id::Integer, config::WorkerConfig, op::Symbol)\n"
"    [...]\n"
"end\n"
msgstr ""
"struct LocalManager <: ClusterManager\n"
"    np::Integer\n"
"end\n"
"\n"
"function launch(manager::LocalManager, params::Dict, launched::Array, c::Condition)\n"
"    [...]\n"
"end\n"
"\n"
"function manage(manager::LocalManager, id::Integer, config::WorkerConfig, op::Symbol)\n"
"    [...]\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1520
msgid "The [`launch`](@ref) method takes the following arguments:"
msgstr "[`launch`](@ref) ã¡ã½ããã¯ãæ¬¡ã®å¼æ°ãåãåãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1525
msgid "`manager::ClusterManager`: the cluster manager that [`addprocs`](@ref) is called with"
msgstr "`manager::ClusterManager`: ãã®ã¯ã©ã¹ã¿ã¼ããã¼ã¸ã£ãç¨ãã¦ã[`addprocs`](@ref) ãå¼ã°ãã¾ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1525
msgid "`params::Dict`: all the keyword arguments passed to [`addprocs`](@ref)"
msgstr "`params::Dict`: [`addprocs`](@ref)ã«æ¸¡ããããã¹ã¦ã®ã­ã¼ã¯ã¼ãå¼æ°ãæ ¼ç´ãã¾ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1525
msgid "`launched::Array`: the array to append one or more `WorkerConfig` objects to"
msgstr "`launched::Array`: 1 ã¤ä»¥ä¸ã® `WorkerConfig`ãªãã¸ã§ã¯ããè¿½å ããéå"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1525
msgid "`c::Condition`: the condition variable to be notified as and when workers are launched"
msgstr "`c::Condition`: ã¯ã¼ã«ã¼ãèµ·åãããã¨ãã«éç¥ãããæ¡ä»¶å¤æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1529
msgid ""
"The [`launch`](@ref) method is called asynchronously in a separate task. The termination of this task signals that all requested workers "
"have been launched. Hence the [`launch`](@ref)  function MUST exit as soon as all the requested workers have been launched."
msgstr ""
"[`launch`](@ref) ã¡ã½ããã¯ãç¬ç«ããã¿ã¹ã¯ã§éåæçã«å¼ã³åºããã¾ãããã®ã¿ã¹ã¯ãçµäºããã¨ãããã¨ã¯ãè¦æ±ããããã¹ã¦ã®ã¯ã¼ã«ã¼ãèµ·åãã"
"ãã¨ãããã¨ã§ãããããã£ã¦ã[`launch`](@ref) é¢æ°ã¯ãè¦æ±ããããã¹ã¦ã®ã¯ã¼ã«ã¼ãèµ·åãããã¨ããã«çµäºããå¿è¦ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1533
#, no-wrap
msgid ""
"Newly launched workers are connected to each other and the master process in an all-to-all manner.\n"
"Specifying the command line argument `--worker[=<cookie>]` results in the launched processes\n"
"initializing themselves as workers and connections being set up via TCP/IP sockets.\n"
msgstr ""
"æ°ããèµ·åãããã¯ã¼ã«ã¼ã¯ãäºãã«ã¯ã¼ã«ã¼åå£«ã§ãããã¦ãã¹ã¿ã¼ãã­ã»ã¹ã¨ ç¶²ç¾çã«æ¥ç¶ããã¾ãã\n"
"ã³ãã³ãã©ã¤ã³å¼æ° `--worker[=<cookie>]`ãæå®ããã¨ãèµ·åããããã­ã»ã¹ãèªåèªèº«ãã¯ã¼ã«ã¼ã¨ãã¦åæåããæ¥ç¶ãTCP/IP ã½ã±ãããä»ãã¦ã»ããã¢ããããã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1538
#, no-wrap
msgid ""
"All workers in a cluster share the same [cookie](@ref man-cluster-cookie) as the master. When the cookie is\n"
"unspecified, i.e, with the `--worker` option, the worker tries to read it from its standard input.\n"
" `LocalManager` and `SSHManager` both pass the cookie to newly launched workers via their\n"
" standard inputs.\n"
msgstr ""
"ã¯ã©ã¹ã¿ã¼åã®ãã¹ã¦ã®ã¯ã¼ã«ã¼ã¯ããã¹ã¿ã¼ã¨åã [cookie](@ref man-cluster-cookie) ãå±æãã¾ãã\n"
"ã¯ãã­ã¼ãæå®ããã¦ããªããã¤ã¾ã`--worker`ãªãã·ã§ã³ãä½¿ç¨ããã¨ãã¯ã¼ã«ã¼ã¯æ¨æºå¥åããã¯ãã­ã¼ãèª­ã¿åããã¨ãã¾ãã\n"
" `LocalManager`ã¨`SSHManager`ã®ä¸¡æ¹ããæ°ããç«ã¡ä¸ããã¯ã¼ã«ã¼ã«æ¨æºå¥åãä»ãã¦ã¯ãã­ã¼ãæ¸¡ãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1542
msgid ""
"By default a worker will listen on a free port at the address returned by a call to [`getipaddr()`](@ref).  A specific address to listen on "
"may be specified by optional argument `--bind-to bind_addr[:port]`.  This is useful for multi-homed hosts."
msgstr ""
"æ¢å®ã§ã¯ãã¯ã¼ã«ã¼ã¯ [`getipaddr()`](@ref)ã®å¼ã³åºãã«ãã£ã¦è¿ãããã¢ãã¬ã¹ã§ç©ºããã¼ãããªãã¹ã³ãã¾ãã ãªãã¹ã³ããç¹å®ã®ã¢ãã¬ã¹ã¯ããªã"
"ã·ã§ã³å¼æ° `--bind-to bind_addr[:port]`ã§æå®ã§ãã¾ãã ããã¯ããã«ããã¼ã ã(è¤æ°ã®ãããã¯ã¼ã¯ã¢ãã¬ã¹ãæã¤)ãã¹ãã§ã®å©ç¨ã«å½¹ç«ã¡ã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1546
msgid ""
"As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case `--worker` must NOT be specified. Instead, "
"newly launched workers should call `init_worker(cookie)` before using any of the parallel constructs."
msgstr ""
"TCP/IPãã©ã³ã¹ãã¼ãä»¥å¤ã®ä¾ã¨ãã¦ã¯ãMPI ãå©ç¨ããå®è£ãèãããã¾ããMPIå©ç¨ã«ããã¦ã¯ã`--worker` ãªãã·ã§ã³ã«ããæå®ãä½¿ã£ã¦ãã¯ããã¾"
"ãããå¨ã¦ã®ä¸¦è¡å¦çã®æ§æè¦ç´ ãç¨ããããåã«ãæ°ããèµ·åããã¯ã¼ã«ã¼ã¯ã`init_worker(cookie)` ãå¼ã³ Cookieã®æå®ãããªãã¦ã¯ãªãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1549
msgid ""
"For every worker launched, the [`launch`](@ref) method must add a `WorkerConfig` object (with appropriate fields initialized) to `launched`"
msgstr ""
"èµ·åãããã¹ã¦ã®ã¯ã¼ã«ã¼ã«å¯¾ãã¦ã[`launch`](@ref) ã¡ã½ããã¯ã(é©åãªãã£ã¼ã«ããåæåãã) `workerConfig` ãªãã¸ã§ã¯ã ã `launched` ã«è¿½"
"å ããå¿è¦ãããã¾ã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1550
#, no-wrap
msgid ""
"mutable struct WorkerConfig\n"
"    # Common fields relevant to all cluster managers\n"
"    io::Union{IO, Nothing}\n"
"    host::Union{AbstractString, Nothing}\n"
"    port::Union{Integer, Nothing}\n"
"\n"
"    # Used when launching additional workers at a host\n"
"    count::Union{Int, Symbol, Nothing}\n"
"    exename::Union{AbstractString, Cmd, Nothing}\n"
"    exeflags::Union{Cmd, Nothing}\n"
"\n"
"    # External cluster managers can use this to store information at a per-worker level\n"
"    # Can be a dict if multiple fields need to be stored.\n"
"    userdata::Any\n"
"\n"
"    # SSHManager / SSH tunnel connections to workers\n"
"    tunnel::Union{Bool, Nothing}\n"
"    bind_addr::Union{AbstractString, Nothing}\n"
"    sshflags::Union{Cmd, Nothing}\n"
"    max_parallel::Union{Integer, Nothing}\n"
"\n"
"    # Used by Local/SSH managers\n"
"    connect_at::Any\n"
"\n"
"    [...]\n"
"end\n"
msgstr ""
"mutable struct WorkerConfig\n"
"    # Common fields relevant to all cluster managers\n"
"    io::Union{IO, Nothing}\n"
"    host::Union{AbstractString, Nothing}\n"
"    port::Union{Integer, Nothing}\n"
"\n"
"    # Used when launching additional workers at a host\n"
"    count::Union{Int, Symbol, Nothing}\n"
"    exename::Union{AbstractString, Cmd, Nothing}\n"
"    exeflags::Union{Cmd, Nothing}\n"
"\n"
"    # External cluster managers can use this to store information at a per-worker level\n"
"    # Can be a dict if multiple fields need to be stored.\n"
"    userdata::Any\n"
"\n"
"    # SSHManager / SSH tunnel connections to workers\n"
"    tunnel::Union{Bool, Nothing}\n"
"    bind_addr::Union{AbstractString, Nothing}\n"
"    sshflags::Union{Cmd, Nothing}\n"
"    max_parallel::Union{Integer, Nothing}\n"
"\n"
"    # Used by Local/SSH managers\n"
"    connect_at::Any\n"
"\n"
"    [...]\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1581
msgid ""
"Most of the fields in `WorkerConfig` are used by the inbuilt managers. Custom cluster managers would typically specify only `io` or `host` / "
"`port`:"
msgstr ""
"`WorkerConfig` ã®ãã£ã¼ã«ãã®ã»ã¨ãã©ã¯ãçµã¿è¾¼ã¿ã®ããã¼ã¸ã£ã«ãã£ã¦ä½¿ç¨ããã¾ããç¬èªå®è£ã®ã¯ã©ã¹ã¿ ããã¼ã¸ã£ã¼ã¯ãéå¸¸ã`io` ã¾ãã¯ "
"`host` / `port` ã®ã¿ãæå®ãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1589
msgid ""
"If `io` is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows "
"Julia workers to listen on any free port available instead of requiring worker ports to be configured manually."
msgstr ""
"`io` ãæå®ããã¦ããå ´åã¯ããã¹ã/ãã¼ãæå ±ã®èª­ã¿åãã«ä½¿ç¨ããã¾ããJulia ã®ã¯ã¼ã«ã¼ã¯ãèµ·åæã«ãã¤ã³ãããã IPã¢ãã¬ã¹ã¨ãã¼ããããªã³"
"ãåºåãã¾ããããã«ãããJulia ã¯ã¼ã«ã¼ã¯ãã¯ã¼ã«ã¼ ã®ãã¼ããæåã§è¨­å®ããä»£ããã«ãä½¿ç¨å¯è½ãªä»»æã®ç©ºããã¼ãããªãã¹ã³ã§ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1589
msgid "If `io` is not specified, `host` and `port` are used to connect."
msgstr "`io` ãæå®ããã¦ããªãå ´åã¯ã`host`, `port` ãä½¿ç¨ãã¦æ¥ç¶ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1589
msgid ""
"`count`, `exename` and `exeflags` are relevant for launching additional workers from a worker.  For example, a cluster manager may launch a "
"single worker per node, and use that to launch additional workers."
msgstr ""
"`count`, `exename` , `exeflags` ã¯ãã¯ã¼ã«ã¼ããå¥ã®è¿½å ã®ã¯ã¼ã«ã¼ãèµ·åããæ©è½ã«é¢é£ãããã®ã§ãä¾ãã°ãã¯ã©ã¹ã¿ã¼ããã¼ã¸ã£ã¼ããã¼ãæ¯ã«1"
"ã¤ã®ã¯ã¼ã«ã¼ãèµ·åãããã®ã¯ã¼ã«ã¼ã«è¿½å ã®ã¯ã¼ã«ã¼ãèµ·åããããã¨ãã§ãã¾ãã"

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/parallel-computing.md:1597
msgid "`count` with an integer value `n` will launch a total of `n` workers."
msgstr "`count` ã¯  æ´æ°å¤ `n`ãæå®ããã¨ããã®ãã·ã³ã§åè¨`n` åã®ã¯ã¼ã«ã¼ãèµ·åãã¾ãã"

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/parallel-computing.md:1597
msgid "`count` with a value of `:auto` will launch as many workers as the number of CPU threads (logical cores) on that machine."
msgstr "`count` ã« `:auto`å¤ãæå®ããã¨ããã®ãã·ã³ã®CPUã¹ã¬ãã(è«çã³ã¢)æ°ã¨åãã ãã®ã¯ã¼ã«ã¼ãèµ·åãã¾ãã"

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/parallel-computing.md:1597
msgid "`exename` is the name of the `julia` executable including the full path."
msgstr "`exename` ã¯ããã«ãã¹ãå«ã `julia`ãã­ã°ã©ã ã®ååã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1597
#, no-wrap
msgid ""
"      * `exeflags` should be set to the required command line arguments for new workers.\n"
"  * `tunnel`, `bind_addr`, `sshflags` and `max_parallel` are used when a ssh tunnel is required to\n"
"    connect to the workers from the master process.\n"
"  * `userdata` is provided for custom cluster managers to store their own worker-specific information.\n"
msgstr ""
"      * `exeflags` ã«ã¯ãæ°ããã¯ã¼ã«ã«å¿è¦ãªã³ãã³ãã©ã¤ã³å¼æ°ãè¨­å®ããå¿è¦ãããã¾ãã.\n"
"  * `tunnel`, `bind_addr`, `sshflags` , `max_parallel` ã¯ãssh ãã³ãã«ããã¹ã¿ã¼ãã­ã»ã¹ããã¯ã¼ã«ã¼ã«æ¥ç¶ããå¿è¦ãããã¨ãã«ç¨ãããã¾ã\n"
"  * `userdata` ã¯ãç¬èªå®è£ã®ã¯ã©ã¹ã¿ã¼ããã¼ã¸ã£ã¼ããã¯ã¼ã«ã¼åºæã®æå ±ãåå¾ã»ä¿æããç®çã§æä¾ããã¾ã\n"
"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1600
#, fuzzy
msgid ""
"`manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)` is called at different times during the worker's lifetime with "
"appropriate `op` values:"
msgstr ""
"`manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)`ã¯ãé©åãª `op` å¤ãæã¤ã¯ã¼ã«ã¼ã®æå¹æéä¸­ã®ç°ãªãæå»ã«å¼ã°ã"
"ã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1605
msgid "with `:register`/`:deregister` when a worker is added / removed from the Julia worker pool."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1605
msgid ""
"with `:interrupt` when `interrupt(workers)` is called. The `ClusterManager` should signal the appropriate worker with an interrupt signal."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1605
msgid "with `:finalize` for cleanup purposes."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/parallel-computing.md:1606
#, no-wrap
msgid "Cluster Managers with Custom Transports"
msgstr "ã«ã¹ã¿ã  ãã©ã³ã¹ãã¼ããä½¿ç¨ããã¯ã©ã¹ã¿ ããã¼ã¸ã£"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1611
msgid ""
"Replacing the default TCP/IP all-to-all socket connections with a custom transport layer is a little more involved. Each Julia process has "
"as many communication tasks as the workers it is connected to. For example, consider a Julia cluster of 32 processes in an all-to-all mesh "
"network:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1618
msgid "Each Julia process thus has 31 communication tasks."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1618
msgid "Each task handles all incoming messages from a single remote worker in a message-processing loop."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1618
msgid ""
"The message-processing loop waits on an `IO` object (for example, a [`TCPSocket`](@ref) in the default implementation), reads an entire "
"message, processes it and waits for the next one."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1618
msgid ""
"Sending messages to a process is done directly from any Julia task--not just communication tasks--again, via the appropriate `IO` object."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1622
msgid ""
"Replacing the default transport requires the new implementation to set up connections to remote workers and to provide appropriate `IO` "
"objects that the message-processing loops can wait on.  The manager-specific callbacks to be implemented are:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1623
#, no-wrap
msgid ""
"connect(manager::FooManager, pid::Integer, config::WorkerConfig)\n"
"kill(manager::FooManager, pid::Int, config::WorkerConfig)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1629
msgid ""
"The default implementation (which uses TCP/IP sockets) is implemented as `connect(manager::ClusterManager, pid::Integer, config::"
"WorkerConfig)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1634
msgid ""
"`connect` should return a pair of `IO` objects, one for reading data sent from worker `pid`, and the other to write data that needs to be "
"sent to worker `pid`. Custom cluster managers can use an in-memory `BufferStream` as the plumbing to proxy data between the custom, possibly "
"non-`IO` transport and Julia's in-built parallel infrastructure."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1637
msgid "A `BufferStream` is an in-memory [`IOBuffer`](@ref) which behaves like an `IO`--it is a stream which can be handled asynchronously."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1643
msgid ""
"The folder `clustermanager/0mq` in the [Examples repository](https://github.com/JuliaAttic/Examples)  contains an example of using ZeroMQ to "
"connect Julia workers in a star topology with a 0MQ broker in the middle. Note: The Julia processes are still all *logically* connected to "
"each other--any worker can message any other worker directly without any awareness of 0MQ being used as the transport layer."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1645
msgid "When using custom transports:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1656
msgid ""
"Julia workers must NOT be started with `--worker`. Starting with `--worker` will result in the newly launched workers defaulting to the TCP/"
"IP socket transport implementation."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1656
msgid ""
"For every incoming logical connection with a worker, `Base.process_messages(rd::IO, wr::IO)()` must be called. This launches a new task that "
"handles reading and writing of messages from/to the worker represented by the `IO` objects."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1656
msgid "`init_worker(cookie, manager::FooManager)` *must* be called as part of worker process initialization."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1656
msgid ""
"Field `connect_at::Any` in `WorkerConfig` can be set by the cluster manager when [`launch`](@ref)  is called. The value of this field is "
"passed in in all [`connect`](@ref) callbacks. Typically, it carries information on *how to connect* to a worker. For example, the TCP/IP "
"socket transport uses this field to specify the `(host, port)` tuple at which to connect to a worker."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1660
msgid ""
"`kill(manager, pid, config)` is called to remove a worker from the cluster. On the master process, the corresponding `IO` objects must be "
"closed by the implementation to ensure proper cleanup.  The default implementation simply executes an `exit()` call on the specified remote "
"worker."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1663
msgid ""
"The Examples folder `clustermanager/simple` is an example that shows a simple implementation using UNIX domain sockets for cluster setup."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/parallel-computing.md:1664
#, no-wrap
msgid "Network Requirements for LocalManager and SSHManager"
msgstr "LocalManager ã¨ SSHManager ã®ãããã¯ã¼ã¯è¦ä»¶"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1669
msgid ""
"Julia clusters are designed to be executed on already secured environments on infrastructure such as local laptops, departmental clusters, "
"or even the cloud. This section covers network security requirements for the inbuilt `LocalManager` and `SSHManager`:"
msgstr ""
"Julia ã®ã¯ã©ã¹ã¿ã¼ã¯ãã­ã¼ã«ã«ã©ããããããé¨éã®ã¯ã©ã¹ã¿ãã¯ã©ã¦ããªã©ã®ã¤ã³ãã©ä¸ã§æ¢ã«ã»ã­ã¥ãªãã£ã§ä¿è­·ããã¦ããç°å¢ãæ³å®ãã¦è¨­è¨ãã"
"ã¦ãã¾ããããã®ç¯ã§ã¯ãçµã¿è¾¼ã¿ã®`LocalManager` ã¨ `SSHManager`ã®ãããã¯ã¼ã¯ã®ã»ã­ã¥ãªãã£è¦ä»¶ã«ã¤ãã¦èª¬æãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1689
msgid "The master process does not listen on any port. It only connects out to the workers."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1689
msgid "Each worker binds to only one of the local interfaces and listens on an ephemeral port number assigned by the OS."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1689
msgid ""
"`LocalManager`, used by `addprocs(N)`, by default binds only to the loopback interface. This means that workers started later on remote "
"hosts (or by anyone with malicious intentions) are unable to connect to the cluster. An `addprocs(4)` followed by an `addprocs([\"remote_host"
"\"])` will fail.  Some users may need to create a cluster comprising their local system and a few remote systems.  This can be done by "
"explicitly requesting `LocalManager` to bind to an external network interface via the `restrict` keyword argument: `addprocs(4; "
"restrict=false)`."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1689
msgid ""
"`SSHManager`, used by `addprocs(list_of_remote_hosts)`, launches workers on remote hosts via SSH.  By default SSH is only used to launch "
"Julia workers. Subsequent master-worker and worker-worker connections use plain, unencrypted TCP/IP sockets. The remote hosts must have "
"passwordless login enabled. Additional SSH flags or credentials may be specified via keyword argument `sshflags`."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1689
msgid ""
"`addprocs(list_of_remote_hosts; tunnel=true, sshflags=<ssh keys and other flags>)` is useful when we wish to use SSH connections for master-"
"worker too. A typical scenario for this is a local laptop running the Julia REPL (i.e., the master) with the rest of the cluster on the "
"cloud, say on Amazon EC2. In this case only port 22 needs to be opened at the remote cluster coupled with SSH client authenticated via "
"public key infrastructure (PKI). Authentication credentials can be supplied via `sshflags`, for example ```sshflags=`-i <keyfile>` ```."
msgstr ""
"`addprocs(list_of_remote_hosts; tunnel=true, sshflags=<ssh keys and other flags>)` \n"
"is useful when we wish to use SSH connections for master-worker too. A typical scenario for this is a local laptop running the Julia REPL (i."
"e., the master) with the rest of the cluster on the cloud, say on Amazon EC2. In this case only port 22 needs to be opened at the remote "
"cluster coupled with SSH client authenticated via public key infrastructure (PKI). Authentication credentials can be supplied via "
"`sshflags`, for example ```sshflags=`-i <keyfile>` ```."

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1693
#, no-wrap
msgid ""
"    In an all-to-all topology (the default), all workers connect to each other via plain TCP sockets.\n"
"    The security policy on the cluster nodes must thus ensure free connectivity between workers for\n"
"    the ephemeral port range (varies by OS).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1696
#, no-wrap
msgid ""
"    Securing and encrypting all worker-worker traffic (via SSH) or encrypting individual messages\n"
"    can be done via a custom `ClusterManager`.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/parallel-computing.md:1697
#, no-wrap
msgid "[Cluster Cookie](@id man-cluster-cookie)"
msgstr "[ã¯ã©ã¹ã¿ã¼ã¯ãã­ã¼](@id man-cluster-cookie)"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1701
msgid "All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1712
msgid "[`cluster_cookie()`](@ref) returns the cookie, while `cluster_cookie(cookie)()` sets it and returns the new cookie."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1712
msgid "All connections are authenticated on both sides to ensure that only workers started by the master are allowed to connect to each other."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1712
msgid ""
"The cookie may be passed to the workers at startup via argument `--worker=<cookie>`. If argument `--worker` is specified without the cookie, "
"the worker tries to read the cookie from its standard input ([`stdin`](@ref)). The `stdin` is closed immediately after the cookie is "
"retrieved."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1712
msgid ""
"`ClusterManager`s can retrieve the cookie on the master by calling [`cluster_cookie()`](@ref).  Cluster managers not using the default TCP/"
"IP transport (and hence not specifying `--worker`)  must call `init_worker(cookie, manager)` with the same cookie as on the master."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1715
msgid ""
"Note that environments requiring higher levels of security can implement this via a custom `ClusterManager`.  For example, cookies can be "
"pre-shared and hence not specified as a startup argument."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:1716
#, no-wrap
msgid "Specifying Network Topology (Experimental)"
msgstr "ãããã¯ã¼ã¯ ããã­ã¸ã®æå® (å®é¨çå®è£)"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1720
msgid "The keyword argument `topology` passed to `addprocs` is used to specify how the workers must be connected to each other:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1726
msgid "`:all_to_all`, the default: all workers are connected to each other."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1726
msgid "`:master_worker`: only the driver process, i.e. `pid` 1, has connections to the workers."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/parallel-computing.md:1726
msgid ""
"`:custom`: the `launch` method of the cluster manager specifies the connection topology via the fields `ident` and `connect_idents` in "
"`WorkerConfig`. A worker with a cluster-manager-provided identity `ident` will connect to all workers specified in `connect_idents`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1732
msgid ""
"Keyword argument `lazy=true|false` only affects `topology` option `:all_to_all`. If `true`, the cluster starts off with the master connected "
"to all workers. Specific worker-worker connections are established at the first remote invocation between two workers. This helps in "
"reducing initial resources allocated for intra-cluster communication. Connections are setup depending on the runtime requirements of a "
"parallel program. Default value for `lazy` is `true`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1736
msgid ""
"Currently, sending a message between unconnected workers results in an error. This behaviour, as with the functionality and interface, "
"should be considered experimental in nature and may change in future releases."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/parallel-computing.md:1737
#, no-wrap
msgid "Noteworthy external packages"
msgstr "æ³¨ç®ã«å¤ããå¤é¨ããã±ã¼ã¸"

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1743
msgid ""
"Outside of Julia parallelism there are plenty of external packages that should be mentioned.  For example [MPI.jl](https://github.com/"
"JuliaParallel/MPI.jl) is a Julia wrapper for the `MPI` protocol, or [DistributedArrays.jl](https://github.com/JuliaParallel/"
"Distributedarrays.jl), as presented in [Shared Arrays](@ref).  A mention must be made of Julia's GPU programming ecosystem, which includes:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/parallel-computing.md:1745
msgid ""
"Low-level (C kernel) based operations [OpenCL.jl](https://github.com/JuliaGPU/OpenCL.jl) and [CUDAdrv.jl](https://github.com/JuliaGPU/"
"CUDAdrv.jl) which are respectively an OpenCL interface and a CUDA wrapper."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/parallel-computing.md:1747
msgid ""
"Low-level (Julia Kernel) interfaces like [CUDAnative.jl](https://github.com/JuliaGPU/CUDAnative.jl) which is a Julia native CUDA "
"implementation."
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/manual/parallel-computing.md:1749
msgid ""
"High-level vendor-specific abstractions like [CuArrays.jl](https://github.com/JuliaGPU/CuArrays.jl) and [CLArrays.jl](https://github.com/"
"JuliaGPU/CLArrays.jl)"
msgstr ""

#. type: Bullet: '4. '
#: ext/julia/doc/src/manual/parallel-computing.md:1751
msgid ""
"High-level libraries like [ArrayFire.jl](https://github.com/JuliaComputing/ArrayFire.jl) and [GPUArrays.jl](https://github.com/JuliaGPU/"
"GPUArrays.jl)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1755
msgid ""
"In the following example we will use both `DistributedArrays.jl` and `CuArrays.jl` to distribute an array across multiple processes by first "
"casting it through `distribute()` and `CuArray()`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1757
msgid "Remember when importing `DistributedArrays.jl` to import it across all processes using [`@everywhere`](@ref)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1759
#, no-wrap
msgid ""
"$ ./julia -p 4\n"
"\n"
"julia> addprocs()\n"
"\n"
"julia> @everywhere using DistributedArrays\n"
"\n"
"julia> using CuArrays\n"
"\n"
"julia> B = ones(10_000) ./ 2;\n"
"\n"
"julia> A = ones(10_000) .* Ï;\n"
"\n"
"julia> C = 2 .* A ./ B;\n"
"\n"
"julia> all(C .â 4*Ï)\n"
"true\n"
"\n"
"julia> typeof(C)\n"
"Array{Float64,1}\n"
"\n"
"julia> dB = distribute(B);\n"
"\n"
"julia> dA = distribute(A);\n"
"\n"
"julia> dC = 2 .* dA ./ dB;\n"
"\n"
"julia> all(dC .â 4*Ï)\n"
"true\n"
"\n"
"julia> typeof(dC)\n"
"DistributedArrays.DArray{Float64,1,Array{Float64,1}}\n"
"\n"
"julia> cuB = CuArray(B);\n"
"\n"
"julia> cuA = CuArray(A);\n"
"\n"
"julia> cuC = 2 .* cuA ./ cuB;\n"
"\n"
"julia> all(cuC .â 4*Ï);\n"
"true\n"
"\n"
"julia> typeof(cuC)\n"
"CuArray{Float64,1}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1805
msgid ""
"Keep in mind that some Julia features are not currently supported by CUDAnative.jl [^2] , especially some functions like `sin` will need to "
"be replaced with `CUDAnative.sin`(cc: @maleadt)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1808
msgid ""
"In the following example we will use both `DistributedArrays.jl` and `CuArrays.jl` to distribute an array across multiple processes and call "
"a generic function on it."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1809
#, no-wrap
msgid ""
"function power_method(M, v)\n"
"    for i in 1:100\n"
"        v = M*v\n"
"        v /= norm(v)\n"
"    end\n"
"\n"
"    return v, norm(M*v) / norm(v)  # or  (M*v) ./ v\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1822
msgid ""
"`power_method` repeatedly creates a new vector and normalizes it. We have not specified any type signature in function declaration, let's "
"see if it works with the aforementioned datatypes:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1823
#, no-wrap
msgid ""
"julia> M = [2. 1; 1 1];\n"
"\n"
"julia> v = rand(2)\n"
"2-element Array{Float64,1}:\n"
"0.40395\n"
"0.445877\n"
"\n"
"julia> power_method(M,v)\n"
"([0.850651, 0.525731], 2.618033988749895)\n"
"\n"
"julia> cuM = CuArray(M);\n"
"\n"
"julia> cuv = CuArray(v);\n"
"\n"
"julia> curesult = power_method(cuM, cuv);\n"
"\n"
"julia> typeof(curesult)\n"
"CuArray{Float64,1}\n"
"\n"
"julia> dM = distribute(M);\n"
"\n"
"julia> dv = distribute(v);\n"
"\n"
"julia> dC = power_method(dM, dv);\n"
"\n"
"julia> typeof(dC)\n"
"Tuple{DistributedArrays.DArray{Float64,1,Array{Float64,1}},Float64}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1856
msgid ""
"To end this short exposure to external packages, we can consider `MPI.jl`, a Julia wrapper of the MPI protocol. As it would take too long to "
"consider every inner function, it would be better to simply appreciate the approach used to implement the protocol."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1859
msgid ""
"Consider this toy script which simply calls each subprocess, instantiate its rank and when the master process is reached, performs the "
"ranks' sum"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1860
#, no-wrap
msgid ""
"import MPI\n"
"\n"
"MPI.Init()\n"
"\n"
"comm = MPI.COMM_WORLD\n"
"MPI.Barrier(comm)\n"
"\n"
"root = 0\n"
"r = MPI.Comm_rank(comm)\n"
"\n"
"sr = MPI.Reduce(r, MPI.SUM, root, comm)\n"
"\n"
"if(MPI.Comm_rank(comm) == root)\n"
"   @printf(\"sum of ranks: %s\\n\", sr)\n"
"end\n"
"\n"
"MPI.Finalize()\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1880
#, no-wrap
msgid "mpirun -np 4 ./julia example.jl\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1889
#, no-wrap
msgid ""
"[^1]:\n"
"    In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee\n"
"    introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access\n"
"    (RMA). The motivation for adding rma to the MPI standard was to facilitate one-sided communication\n"
"    patterns. For additional information on the latest MPI standard, see <https://mpi-forum.org/docs>.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/parallel-computing.md:1891
#, no-wrap
msgid ""
"[^2]:\n"
"    [Julia GPU man pages](http://juliagpu.github.io/CUDAnative.jl/stable/man/usage.html#Julia-support-1)\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1
#, no-wrap
msgid "Calling C and Fortran Code"
msgstr "[C, Fortran ã³ã¼ãã®å¼ã³åºã](@id Calling-C-and-Fortran-Code)"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:9
msgid ""
"Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and "
"Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a \"no "
"boilerplate\" philosophy: functions can be called directly from Julia without any \"glue\" code, code generation, or compilation -- even "
"from the interactive prompt. This is accomplished just by making an appropriate call with [`ccall`](@ref) syntax, which looks like an "
"ordinary function call."
msgstr ""
"ã»ã¨ãã©ã®ã³ã¼ãã¯ Julia ã§è¨è¿°ã§ãã¾ãããC ã¨ Fortran ã§æ¢ã«è¨è¿°ããã¦ããæ°å¤è¨ç®ç¨ã®é«åè³ªã§æçããã©ã¤ãã©ãªãå¤æ°ããã¾ãããã®æ¢å­ã®"
"ã³ã¼ããç°¡åã«ä½¿ç¨ã§ããããã«ãJulia ã¯ C é¢æ°ã¨ Fortran é¢æ°ãç°¡åãã¤å¹ççã«å¼ã³åºããã¨ãã§ãã¾ããJulia ã¯ãå®åæãªããã®å²å­¦ãæã£ã¦"
"ãã¾ã:é¢æ°ã¯ãæ¥çå¤ãã³ã¼ããã³ã¼ãçæãããã¯ã³ã³ãã¤ã«ãªãã§Julia ããç´æ¥å¼ã³åºããã¨ãã§ãã¾ãã-- å¯¾è©±ãã­ã³ããããã§ããã§ããéå¸¸"
"ã®é¢æ°å¼ã³åºãã®ããã«è¦ãã [`ccall`](@ref) æ§æãä½¿ç¨ãã¦é©åãªå¼ã³åºããè¡ãã ãã§å®ç¾ãããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:15
msgid ""
"The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if "
"you are compiling the code yourself using GCC (or Clang), you will need to use the `-shared` and `-fPIC` options. The machine instructions "
"generated by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from "
"C code. [^1]"
msgstr ""
"Julia ããå¼ã³åºãããã³ã¼ãã¯ãå±æã©ã¤ãã©ãªã¨ãã¦ä½¿ç¨ã§ããªããã°ãªãã¾ãããã»ã¨ãã©ã® C ã©ã¤ãã©ãªã¨ Fortran ã©ã¤ãã©ãªã¯æ¢ã«å±æã©ã¤ã"
"ã©ãªã¨ãã¦ã³ã³ãã¤ã«ããã¦ãã¾ãããGCC (ã¾ãã¯ Clang) ãä½¿ç¨ãã¦ã³ã¼ããèªåã§ã³ã³ãã¤ã«ããå ´åã¯ã`-shared` ããã³ `fPIC` ãªãã·ã§ã³ãä½¿ç¨"
"ãã¦ãã ãããJulia ã® JIT ã«ãã£ã¦çæããããã·ã³å½ä»¤ã¯ãã¤ãã£ã C å¼ã³åºãã¨åããªã®ã§ãçµæã¨ãã¦çãããªã¼ãã¼ãããã¯ C ã³ã¼ãããã©ã¤"
"ãã©ãªé¢æ°ãå¼ã³åºãã®ã¨åãã§ãã[^1]"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:20
msgid ""
"Shared libraries and functions are referenced by a tuple of the form `(:function, \"library\")` or `(\"function\", \"library\")` where "
"`function` is the C-exported function name, and `library` refers to the shared library name.  Shared libraries available in the (platform-"
"specific) load path will be resolved by name.  The full path to the library may also be specified."
msgstr ""
"å±æã©ã¤ãã©ãªã¨é¢æ°ã¯ã`(:function, \"library\")` or `(\"function\", \"library\")` ã®æ¸å¼ã®ã¿ãã«ã§åç§ã§ãã¾ããããã§ ã`function` ã¯ãCåº"
"ã¨ã¯ã¹ãã¼ããããé¢æ°åãlibrary` ã¯å±æã©ã¤ãã©ãªã®ååã§ã: ã©ã¤ãã©ãªèª­ã¿è¾¼ã¿ãã¹(ãã©ãããã©ã¼ã åºæã®ç©ãå«ã)ä¸­ã®å±ç¨ã©ã¤ãã©ãªã¼ã¯ã"
"ã®ååã®ã¿ã§è§£æ±ºããã¾ããã©ã¤ãã©ãªã®ãã«ãã¹ãæå®ãã¦ãæ§ãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:24
msgid ""
"A function name may be used alone in place of the tuple (just `:function` or `\"function\"`). In this case the name is resolved within the "
"current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to "
"Julia."
msgstr ""
"é¢æ°åã¯ãã¿ãã«ã®ä»£ããã«åç¬ã§(åã« `:function` ã¾ãã¯ \"function\" ã¨ãã¦) ä½¿ç¨ã§ãã¾ãããã®å ´åãååã¯ç¾å¨ã®ãã­ã»ã¹åã§è§£æ±ºããã¾ãã"
"ãã®å½¢å¼ãä½¿ç¨ã§ããã®ã¯ãC ã©ã¤ãã©ãªé¢æ°ãJulia ã©ã³ã¿ã¤ã ã®é¢æ°ãã¾ãã¯ Julia ã«ãªã³ã¯ãããã¢ããªã±ã¼ã·ã§ã³ã®é¢æ°ã®ãããããå¼ã³åºãæã§"
"ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:35
msgid ""
"By default, Fortran compilers [generate mangled names](https://en.wikipedia.org/wiki/Name_mangling#Fortran) (for example, converting "
"function names to lowercase or uppercase, often appending an underscore), and so to call a Fortran function via [`ccall`](@ref) you must "
"pass the mangled identifier corresponding to the rule followed by your Fortran compiler.  Also, when calling a Fortran function, all inputs "
"must be passed as pointers to allocated values on the heap or stack. This applies not only to arrays and other mutable objects which are "
"normally heap-allocated, but also to scalar values such as integers and floats which are normally stack-allocated and commonly passed in "
"registers when using C or Julia calling conventions."
msgstr ""
"ããã©ã«ãã§ã¯ãFortran ã³ã³ãã¤ã©ã¯[ãã³ã°ãªã³ã°ãããååãçæããã®ã§] (https://en.wikipedia.org/wiki/Name_mangling#Fortran) (ãã¨ãã°ã"
"é¢æ°åãå°æå­ã¾ãã¯å¤§æå­ã«å¤æããã¢ã³ãã¼ã¹ã³ã¢ãè¿½å ããï¼ã[`ccall`](@ref)çµç±ã§Fortranã®é¢æ°ãå¼ã¶ããã«ã¯ãFortran ã³ã³ãã¤ã©ãå¾ã"
"ã«ã¼ã«ã«å¯¾å¿ãã¦ãã³ã°ãªã³ã°ãããé¢æ°åãæ¸¡ãå¿è¦ãããã¾ãã ã¾ããFortran é¢æ°ãå¼ã³åºãæã¯ããã¹ã¦ã®å¥åããã¼ãã¾ãã¯ã¹ã¿ãã¯ã«å²ãå½ã¦"
"ãããå¤ã¸ã®ãã¤ã³ã¿ã¼ã¨ãã¦æ¸¡ãå¿è¦ãããã¾ããããã¯ãéå¸¸ãã¼ãå²ãå½ã¦ãããéåããã®ä»ã®ãã¥ã¼ã¿ãã«ãªãªãã¸ã§ã¯ãã ãã§ãªããéå¸¸ã¹"
"ã¿ãã¯å²ãå½ã¦ãããC ã¾ãã¯ Julia å¼ã³åºãè¦ç´ãä½¿ç¨ããæã«ã¬ã¸ã¹ã¿ã«ä¸è¬çã«æ¸¡ãããæ´æ°ãæµ®åå°æ°ç¹æ°ãªã©ã®ã¹ã«ã©ã¼å¤ã«ã¤ãã¦ãåæ§ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:38
msgid "Finally, you can use [`ccall`](@ref) to actually generate a call to the library function. The arguments to [`ccall`](@ref) are:"
msgstr "æå¾ã«ã[`ccall`](@ref)ãä½¿ç¨ãã¦ãã©ã¤ãã©ãªé¢æ°ã®å¼ã³åºããè¡ãå®éã«çæãããã¨ãã§ãã¾ãã[`ccall`](@ref)ã®å¼æ°ã¯:"

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:40
msgid "A `(:function, \"library\")` pair (most common),"
msgstr "`(:function, \"library\")` ã®ãã¢ (ãããæãä¸è¬ç)"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:42 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:46
#, no-wrap
msgid "   OR\n"
msgstr "   ãããã¯\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:44
#, no-wrap
msgid "   a `:function` name symbol or `\"function\"` name string (for symbols in the current process or libc),\n"
msgstr "   é¢æ°åã·ã³ãã« `:function` ã é¢æ°åæå­å `\"function\"`  ( ç¾å¨ã®ãã­ã»ã¹ã libc åã®ã·ã³ãã«ã«å¯¾ãã¦ä½¿ç¨å¯è½) ,\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:48
#, no-wrap
msgid "   a function pointer (for example, from `dlsym`).\n"
msgstr "   é¢æ°ãã¤ã³ã¿(ä¾ãã°ã`dlsym` é¢æ°ãã).\n"

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:50 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:174
msgid "The function's return type"
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:52 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:174
msgid "A tuple of input types, corresponding to the function signature"
msgstr ""

#. type: Bullet: '4. '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:54
msgid "The actual argument values to be passed to the function, if any; each is a separate parameter."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:58
#, no-wrap
msgid ""
"!!! note\n"
"    The `(:function, \"library\")` pair, return type, and input types must be literal constants\n"
"    (i.e., they can't be variables, but see [Non-constant Function Specifications](@ref) below).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:60
#, no-wrap
msgid "    The remaining parameters are evaluated at compile time, when the containing method is defined.\n"
msgstr "    æ®ãã®ãã©ã¡ã¼ã¿ã¯ã¯ãå¯¾è±¡ã®ã¡ã½ãããå®ç¾©ãããã¨ããã³ã³ãã¤ã«æã«è©ä¾¡ããã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:63
#, no-wrap
msgid ""
"!!! note\n"
"    See below for how to [map C types to Julia types](@ref mapping-c-types-to-julia).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:66
msgid "As a complete but simple example, the following calls the `clock` function from the standard C library on most Unix-derived systems:"
msgstr "ä¸è¨å¨ã¦ã®åå®¹ãå«ãã·ã³ãã«ãªä¾ã§ãããæ¬¡ã®é¢æ°ã¯ ã»ã¨ãã©ã®Unix æ´¾çã®ã·ã¹ãã ã§ã¯ æ¨æº C ã©ã¤ãã©ãªãã `clock` é¢æ°ãå¼ã³åºãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:67
#, no-wrap
msgid ""
"julia> t = ccall(:clock, Int32, ())\n"
"2292761\n"
"\n"
"julia> t\n"
"2292761\n"
"\n"
"julia> typeof(ans)\n"
"Int32\n"
msgstr ""
"julia> t = ccall(:clock, Int32, ())\n"
"2292761\n"
"\n"
"julia> t\n"
"2292761\n"
"\n"
"julia> typeof(ans)\n"
"Int32\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:81
msgid ""
"`clock` takes no arguments and returns an [`Int32`](@ref). One common gotcha is that a 1-tuple of argument types must be written with a "
"trailing comma. For example, to call the `getenv` function to get a pointer to the value of an environment variable, one makes a call like "
"this:"
msgstr ""
"`clock` ã¯å¼æ°ãåãåããã[`Int32`](@ref)ãè¿ãã¾ããããããè½ã¨ãç©´1 ã¤ã¯ãå¼æ°åã® 1è¦ç´ ã¿ãã«ã«ãæ«å°¾ã®ã³ã³ããå¿è¦ã«ãªãç¹ã§ãããã¨ã"
"ã°ã`getenv` é¢æ°ãå¼ã³åºãã¦ç°å¢å¤æ°ã®å¤ã¸ã®ãã¤ã³ã¿ã¼ãåå¾ããã«ã¯ãæ¬¡ã®ãããªå¼ã³åºããè¡ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:82
#, no-wrap
msgid ""
"julia> path = ccall(:getenv, Cstring, (Cstring,), \"SHELL\")\n"
"Cstring(@0x00007fff5fbffc45)\n"
"\n"
"julia> unsafe_string(path)\n"
"\"/bin/bash\"\n"
msgstr ""
"julia> path = ccall(:getenv, Cstring, (Cstring,), \"SHELL\")\n"
"Cstring(@0x00007fff5fbffc45)\n"
"\n"
"julia> unsafe_string(path)\n"
"\"/bin/bash\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:93
msgid ""
"Note that the argument type tuple must be written as `(Cstring,)`, rather than `(Cstring)`. This is because `(Cstring)` is just the "
"expression `Cstring` surrounded by parentheses, rather than a 1-tuple containing `Cstring`:"
msgstr ""
"æ³¨æãã¦ã»ããã®ã¯ãå¼æ°åã®ã¿ãã«ã¯ã`(Cstring)` ã§ã¯ãªã `(Cstring,)` ã¨æ¸ããªããã°ãããªãç¹ã§ããããã¯ã`(Cstring)` ã¯ã`Cstring` ãæ¬"
"å¼§ã§ããããã¦ããã ãã®å¼ã«éããªãããã§ãã `Cstring` 1è¦ç´ ã ããå«ãã¿ãã«ãè¡¨ãã«ã¯ã«ã³ããå¿è¦ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:94
#, no-wrap
msgid ""
"julia> (Cstring)\n"
"Cstring\n"
"\n"
"julia> (Cstring,)\n"
"(Cstring,)\n"
msgstr ""
"julia> (Cstring)\n"
"Cstring\n"
"\n"
"julia> (Cstring,)\n"
"(Cstring,)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:108
msgid ""
"In practice, especially when providing reusable functionality, one generally wraps [`ccall`](@ref)  uses in Julia functions that set up "
"arguments and then check for errors in whatever manner the C or Fortran function indicates them, propagating to the Julia caller as "
"exceptions. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For "
"example, the `getenv` C library function is wrapped in the following Julia function, which is a simplified version of the actual definition "
"from [`env.jl`](https://github.com/JuliaLang/julia/blob/master/base/env.jl):"
msgstr ""
"å®éã«ã¯ãç¹ã«åå©ç¨å¯è½ãªæ©è½ãæä¾ããå ´åã®è©±ã§ããã[`ccall`](@ref)ãä½¿ç¨ããã³ã¼ãã«å¯¾ãã¦ãå¼æ°ãè¨­å®ãã¦ãCã¾ãã¯Fortranã®ã¿ã¼ã²ããé¢"
"æ°ã®æ¯ãèãã®ã¨ã©ã¼ãã§ãã¯ããã¦ãä¾å¤ãJuliaå´ã«ã¾ã§ä¼æ­ããããããªã©ããã¼é¢æ°ãæºåãããã¨ãå¤ãã§ããC API ã¨ Fortran API ã¯ãã¨ã©ã¼"
"æ¡ä»¶ãç¤ºãæ¹æ³ã«é¢ãã¦ä¸è²«æ§ããªããããããã¯ç¹ã«éè¦ã§ãããã¨ãã°ã`getenv` C ã©ã¤ãã©ãªé¢æ°ã¯ã[`env.jl`] (https://github.com/JuliaLang/"
"julia/blob/master/base/env.jl) ããå®éã®å®ç¾©ã®ç°¡ç¥åããããã¼ã¸ã§ã³ã§ããæ¬¡ã® Julia é¢æ°ã«ã©ããããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:109
#, no-wrap
msgid ""
"function getenv(var::AbstractString)\n"
"    val = ccall(:getenv, Cstring, (Cstring,), var)\n"
"    if val == C_NULL\n"
"        error(\"getenv: undefined variable: \", var)\n"
"    end\n"
"    return unsafe_string(val)\n"
"end\n"
msgstr ""
"function getenv(var::AbstractString)\n"
"    val = ccall(:getenv, Cstring, (Cstring,), var)\n"
"    if val == C_NULL\n"
"        error(\"getenv: undefined variable: \", var)\n"
"    end\n"
"    return unsafe_string(val)\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:123
msgid ""
"The C `getenv` function indicates an error by returning `NULL`, but other standard C functions indicate errors in various different ways, "
"including by returning -1, 0, 1 and other special values.  This wrapper throws an exception clearly indicating the problem if the caller "
"tries to get a non-existent environment variable:"
msgstr ""
"Cè¨èªã® `getenv` é¢æ°ã¯ `NULL` ãè¿ããã¨ã«ãã£ã¦ã¨ã©ã¼ãç¤ºãã¾ãããä»ã®æ¨æº C é¢æ°ã¯-1ã0ã1 ããã³ãã®ä»ã®ç¹æ®å¤ãè¿ããªã©ããã¾ãã¾ãªæ¹æ³"
"ã§ã¨ã©ã¼ãç¤ºãã¾ãã ãã®ã©ããã¼ã¯ãå¼ã³åºãåãå­å¨ããªãç°å¢å¤æ°ãåå¾ãããã¨ããå ´åã«åé¡ãæç¢ºã«ç¤ºãä¾å¤ãã¹ã­ã¼ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:124
#, no-wrap
msgid ""
"julia> getenv(\"SHELL\")\n"
"\"/bin/bash\"\n"
"\n"
"julia> getenv(\"FOOBAR\")\n"
"getenv: undefined variable: FOOBAR\n"
msgstr ""
"julia> getenv(\"SHELL\")\n"
"\"/bin/bash\"\n"
"\n"
"julia> getenv(\"FOOBAR\")\n"
"getenv: undefined variable: FOOBAR\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:136
msgid ""
"Here is a slightly more complex example that discovers the local machine's hostname.  In this example, the networking library code is "
"assumed to be in a shared library named \"libc\".  In practice, this function is usually part of the C standard library, and so the \"libc\" "
"portion should be omitted, but we wish to show here the usage of this syntax."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:137
#, no-wrap
msgid ""
"function gethostname()\n"
"    hostname = Vector{UInt8}(undef, 256) # MAXHOSTNAMELEN\n"
"    err = ccall((:gethostname, \"libc\"), Int32,\n"
"                (Ptr{UInt8}, Csize_t),\n"
"                hostname, sizeof(hostname))\n"
"    Base.systemerror(\"gethostname\", err != 0)\n"
"    hostname[end] = 0 # ensure null-termination\n"
"    return unsafe_string(pointer(hostname))\n"
"end\n"
msgstr ""
"function gethostname()\n"
"    hostname = Vector{UInt8}(undef, 256) # MAXHOSTNAMELEN\n"
"    err = ccall((:gethostname, \"libc\"), Int32,\n"
"                (Ptr{UInt8}, Csize_t),\n"
"                hostname, sizeof(hostname))\n"
"    Base.systemerror(\"gethostname\", err != 0)\n"
"    hostname[end] = 0 # ensure null-termination\n"
"    return unsafe_string(pointer(hostname))\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:158
msgid ""
"This example first allocates an array of bytes, then calls the C library function `gethostname` to fill the array in with the hostname, "
"takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is "
"common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and filled in. Allocation "
"of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C "
"function. This is why we don't use the `Cstring` type here: as the array is uninitialized, it could contain NUL bytes. Converting to a "
"`Cstring` as part of the [`ccall`](@ref) checks for contained NUL bytes and could therefore throw a conversion error."
msgstr ""
"æ¬¡ã®ä½¿ç¨ä¾ã¯ãæåã«ãã¤ãã®éåãå²ãå½ã¦ãæ¬¡ã« C ã©ã¤ãã©ãªé¢æ° `gethostname` ãå¼ã³åºãã¦éåããã¹ãåã§åãããã¹ãåãããã¡ã¼ã¸ã®ãã¤"
"ã³ã¿ã¼ãåå¾ããNULL çµç«¯ C æå­åã§ããã¨ä»®å®ãã¦Julia æå­åã«ãã¤ã³ã¿ãå¤æãã¾ããC ã©ã¤ãã©ãªã§ã¯ãå¼ã³åºãåã«ã¡ã¢ãªãå²ãå½ã¦ã¦ãå¼ã³"
"åºãåã«æ¸¡ãã¦å¥åããããã«è¦æ±ãããã®ãã¿ã¼ã³ãä½¿ç¨ããã®ãä¸è¬çã§ãããã®ãããª Julia ããã®ã¡ã¢ãªã®å²ãå½ã¦ã¯ãä¸è¬ã«ãåæåããã¦ããª"
"ãéåãä½æãããã®ãã¼ã¿ã¸ã®ãã¤ã³ã¿ã C é¢æ°ã«æ¸¡ããã¨ã«ãã£ã¦è¡ããã¾ããéåãåæåããã¦ããªããããNULL ãã¤ããå«ããã¨ãã§ããã"
"ããããã§ `Cstring` åãä½¿ç¨ããªãçç±ã§ãã[`ccall`](@ref)ã®ä¸é¨ã¨ãã¦`Cstring`ã«å¤æããã¨ãå«ã¾ãã NULL ãã¤ãããã§ãã¯ããããããå¤æ"
"ã¨ã©ã¼ãã¹ã­ã¼ãããå¯è½æ§ãããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:159
#, no-wrap
msgid "Creating C-Compatible Julia Function Pointers"
msgstr "Cè¨èªã³ã³ãããª Juliaé¢æ°ã®ãã¤ã³ã¿ãã¤ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:163
msgid ""
"It is possible to pass Julia functions to native C functions that accept function pointer arguments.  For example, to match C prototypes of "
"the form:"
msgstr ""
"é¢æ°ãã¤ã³ã¿ã¼å¥åå¼æ°ã«æã¤ C é¢æ°ã« Julia é¢æ°ãæ¸¡ããã¨ãã§ãã¾ãã ãã¨ãã°ãä¸è¨ã®æ§ãªC ãã­ãã¿ã¤ãå®£è¨ãä¸è´ãããã«ã¯ä¸è¨ã®ããã«ãã¾"
"ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:164
#, no-wrap
msgid "typedef returntype (*functiontype)(argumenttype, ...)\n"
msgstr "typedef returntype (*functiontype)(argumenttype, ...)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:170
msgid ""
"The macro [`@cfunction`](@ref) generates the C-compatible function pointer for a call to a Julia function. The arguments to [`@cfunction`]"
"(@ref) are:"
msgstr ""
"[`@cfunction`](@ref) ãã¯ã­ã¯ãJuliaé¢æ°ã®å¼ã³åºããããããã®ãCè¨èªã³ã³ãããªé¢æ°ãã¤ã³ã¿ãçæãã¾ãã [`@cfunction`](@ref) ã¸ã®å¼æ°ã¯:"

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:174
msgid "A Julia function"
msgstr "Julia é¢æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:177
#, no-wrap
msgid ""
"!!! note\n"
"    As with `ccall`, the return type and tuple of input types must be literal constants.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:183
#, no-wrap
msgid ""
"!!! note\n"
"    Currently, only the platform-default C calling convention is supported. This means that\n"
"    `@cfunction`-generated pointers cannot be used in calls where WINAPI expects `stdcall`\n"
"    function on 32-bit Windows, but can be used on WIN64 (where `stdcall` is unified with the\n"
"    C calling convention).\n"
msgstr ""
"!!! note\n"
"    ç¾å¨ã¯ããã©ãããã©ã¼ã ã§ããã©ã«ãã® Cå¼ã³åºãè¦åã®ã¿ããµãã¼ãããã¦ãã¾ãã\n"
"    ã¤ã¾ãã`@cfunction` ã§çæããããã¤ã³ã¿ã¯ãWINAPIã 32bit Windows ä¸ã®`stdcall` é¢æ°ãæå¾ããå ´åã«ã¯ç¨ãããã¨ãã§ãã¾ããã\n"
"    WIN64 (`stdcall` ããCå¼ã³åºãè¦åã¨çµ±åããã¦ãã) ä¸ã§ããã°ä½¿ãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:185
msgid "A classic example is the standard C library `qsort` function, declared as:"
msgstr "å¤å¸çãªä¾ã¨ãã¦ãC ã®æ¨æºé¢æ° `qsort`ã¯ä»¥ä¸ã®ããã«å®£è¨ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:186
#, no-wrap
msgid ""
"void qsort(void *base, size_t nmemb, size_t size,\n"
"           int (*compare)(const void*, const void*));\n"
msgstr ""
"void qsort(void *base, size_t nmemb, size_t size,\n"
"           int (*compare)(const void*, const void*));\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:195
msgid ""
"The `base` argument is a pointer to an array of length `nmemb`, with elements of `size` bytes each. `compare` is a callback function which "
"takes pointers to two elements `a` and `b` and returns an integer less/greater than zero if `a` should appear before/after `b` (or zero if "
"any order is permitted)."
msgstr ""
"`base` å¼æ°ã¯ãé·ã `nmemb` ã®éåã¸ã®ãã¤ã³ã¿ã§ãåè¦ç´ ã¯ `size` ãã¤ãã§ãã\n"
"`compare` ã¯ã2 ã¤ã®è¦ç´  `a` ã¨ `b` ã¸ã®ãã¤ã³ã¿ãåãåããã½ã¼ãã®ããã®æ¯è¼çµæãæ´æ°å¤ã§è¿ãã³ã¼ã«ããã¯é¢æ°ã§ãã\n"
"ãã®è¿ãå¤ã¯ã`a` ã `b` ãããå/å¾ã«ç¾ããã¹ãå ´åã«ã¯ãã¼ã­ãããå°ãã/å¤§ããå¤ã«ãªãã¾ã(ã½ã¼ãçµæã¨ãã¦`a,b` ã®é çªãä»»æã¨ããå ´åã¯0"
"ãè¿ããã¨ãå¯è½ã§ã)ã\n"
"ãã¦ãããã§ä¸¦ã¹æ¿ããå¤ã®1æ¬¡åéå `A` ãããã¨ãã¾ãã\n"
"'qsort' é¢æ°ãä½¿ç¨ãã¾ã (Julia ã®çµã¿è¾¼ã¿ã® 'sort' é¢æ°ã§ã¯ãªã)ãå¿éããåã«\n"
"'qsort' ãå¼ã³åºãã¦å¼æ°ãæ¸¡ãå ´åã¯ãä¸é¨ã®é¢æ°ã§åä½ããæ¯è¼é¢æ°ãè¨è¿°ããå¿è¦ãããã¾ãã\n"
"ä»»æã®ãªãã¸ã§ã¯ã ('<'ãå®ç¾©ãã¾ã)ã"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:199
msgid ""
"Now, suppose that we have a 1d array `A` of values in Julia that we want to sort using the `qsort` function (rather than Julia's built-in "
"`sort` function). Before we worry about calling `qsort` and passing arguments, we need to write a comparison function:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:200 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:212
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:222
#, no-wrap
msgid "jldoctest mycompare"
msgstr "jldoctest mycompare"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:200
#, no-wrap
msgid ""
"julia> function mycompare(a, b)::Cint\n"
"           return (a < b) ? -1 : ((a > b) ? +1 : 0)\n"
"       end\n"
"mycompare (generic function with 1 method)\n"
msgstr ""
"julia> function mycompare(a, b)::Cint\n"
"           return (a < b) ? -1 : ((a > b) ? +1 : 0)\n"
"       end\n"
"mycompare (generic function with 1 method)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:209
msgid "``qsort`` expects a comparison function that return a C ``int``, so we annotate the return type to be ``Cint``."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:211
msgid "In order to pass this function to C, we obtain its address using the macro `@cfunction`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:212
#, no-wrap
msgid "julia> mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:219
msgid ""
"[`@cfunction`](@ref) requires three arguments: the Julia function (`mycompare`), the return type (`Cint`), and a literal tuple of the input "
"argument types, in this case to sort an array of `Cdouble` ([`Float64`](@ref)) elements."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:221
msgid "The final call to `qsort` looks like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:222
#, no-wrap
msgid ""
"julia> A = [1.3, -2.7, 4.4, 3.1]\n"
"4-element Array{Float64,1}:\n"
"  1.3\n"
" -2.7\n"
"  4.4\n"
"  3.1\n"
"\n"
"julia> ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),\n"
"             A, length(A), sizeof(eltype(A)), mycompare_c)\n"
"\n"
"julia> A\n"
"4-element Array{Float64,1}:\n"
" -2.7\n"
"  1.3\n"
"  3.1\n"
"  4.4\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:244
msgid ""
"As can be seen, `A` is changed to the sorted array `[-2.7, 1.3, 3.1, 4.4]`. Note that Julia [takes care of converting the array to a "
"`Ptr{Cdouble}`](@ref automatic-type-conversion)), computing the size of the element type in bytes, and so on."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:248
msgid ""
"For fun, try inserting a `println(\"mycompare($a, $b)\")` line into `mycompare`, which will allow you to see the comparisons that `qsort` is "
"performing (and to verify that it is really calling the Julia function that you passed to it)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:249
#, no-wrap
msgid "[Mapping C Types to Julia](@id mapping-c-types-to-julia)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:254
msgid ""
"It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on "
"one system to fail or produce indeterminate results on a different system."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:258
msgid ""
"Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia "
"types and call signatures accurately reflect those in the C header file.[^2]"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:259
#, no-wrap
msgid "[Automatic Type Conversion](@id automatic-type-conversion)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:263
msgid ""
"Julia automatically inserts calls to the [`Base.cconvert`](@ref) function to convert each argument to the specified type. For example, the "
"following call:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:264
#, no-wrap
msgid "ccall((:foo, \"libfoo\"), Cvoid, (Int32, Float64), x, y)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:269
msgid "will behave as if the following were written:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:270
#, no-wrap
msgid ""
"ccall((:foo, \"libfoo\"), Cvoid, (Int32, Float64),\n"
"      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n"
"      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:280
msgid ""
"[`Base.cconvert`](@ref) normally just calls [`convert`](@ref), but can be defined to return an arbitrary new object more appropriate for "
"passing to C.  This should be used to perform all allocations of memory that will be accessed by the C code.  For example, this is used to "
"convert an `Array` of objects (e.g. strings) to an array of pointers."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:284
msgid ""
"[`Base.unsafe_convert`](@ref) handles conversion to [`Ptr`](@ref) types. It is considered unsafe because converting an object to a native "
"pointer can hide the object from the garbage collector, causing it to be freed prematurely."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:285
#, no-wrap
msgid "Type Correspondences"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:288
msgid "First, let's review some relevant Julia type terminology:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:300
#, no-wrap
msgid ""
"| Syntax / Keyword              | Example                                     | Description                                                                                                                                                                                                                                                                    |\n"
"|:----------------------------- |:------------------------------------------- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n"
"| `mutable struct`              | `BitSet`                                    | \"Leaf Type\" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no `TypeVars` are allowed) in order for the instance to be constructed.              |\n"
"| `abstract type`               | `Any`, `AbstractArray{T, N}`, `Complex{T}`  | \"Super Type\" :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.                                                                                                                                                      |\n"
"| `T{A}`                        | `Vector{Int}`                               | \"Type Parameter\" :: A specialization of a type (typically used for dispatch or storage optimization).                                                                                                                                                                          |\n"
"|                               |                                             | \"TypeVar\" :: The `T` in the type parameter declaration is referred to as a TypeVar (short for type variable).                                                                                                                                                                  |\n"
"| `primitive type`              | `Int`, `Float64`                            | \"Primitive Type\" :: A type with no fields, but a size. It is stored and defined by-value.                                                                                                                                                                                           |\n"
"| `struct`                      | `Pair{Int, Int}`                            | \"Struct\" :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.                                                                                                                                                       |\n"
"|                               | `ComplexF64` (`isbits`)                     | \"Is-Bits\"   :: A `primitive type`, or a `struct` type where all fields are other `isbits` types. It is defined by-value, and is stored without a type-tag.                                                                                                                       |\n"
"| `struct ...; end`             | `nothing`                                   | \"Singleton\" :: a Leaf Type or Struct with no fields.                                                                                                                                                                                                                        |\n"
"| `(...)` or `tuple(...)`       | `(1, 2, 3)`                                 | \"Tuple\" :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct.                                                                                                                                |\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:301
#, no-wrap
msgid "[Bits Types](@id man-bits-types)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:305
msgid "There are several special types to be aware of, as no other type can be defined to behave the same:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:307
msgid "`Float32`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:309
#, no-wrap
msgid "    Exactly corresponds to the `float` type in C (or `REAL*4` in Fortran).\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:311
msgid "`Float64`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:313
#, no-wrap
msgid "    Exactly corresponds to the `double` type in C (or `REAL*8` in Fortran).\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:315
msgid "`ComplexF32`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:317
#, no-wrap
msgid "    Exactly corresponds to the `complex float` type in C (or `COMPLEX*8` in Fortran).\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:319
msgid "`ComplexF64`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:321
#, no-wrap
msgid "    Exactly corresponds to the `complex double` type in C (or `COMPLEX*16` in Fortran).\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:323
msgid "`Signed`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:326
#, no-wrap
msgid ""
"    Exactly corresponds to the `signed` type annotation in C (or any `INTEGER` type in Fortran).\n"
"    Any Julia type that is not a subtype of [`Signed`](@ref) is assumed to be unsigned.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:329
msgid "`Ref{T}`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:331
#, no-wrap
msgid "    Behaves like a `Ptr{T}` that can manage its memory via the Julia GC.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:334
msgid "`Array{T,N}`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:337
#, no-wrap
msgid ""
"    When an array is passed to C as a `Ptr{T}` argument, it is not reinterpret-cast: Julia requires\n"
"    that the element type of the array matches `T`, and the address of the first element is passed.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:340
#, no-wrap
msgid ""
"    Therefore, if an `Array` contains data in the wrong format, it will have to be explicitly converted\n"
"    using a call such as `trunc(Int32, a)`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:344
#, no-wrap
msgid ""
"    To pass an array `A` as a pointer of a different type *without* converting the data beforehand\n"
"    (for example, to pass a `Float64` array to a function that operates on uninterpreted bytes), you\n"
"    can declare the argument as `Ptr{Cvoid}`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:349
#, no-wrap
msgid ""
"    If an array of eltype `Ptr{T}` is passed as a `Ptr{Ptr{T}}` argument, [`Base.cconvert`](@ref)\n"
"    will attempt to first make a null-terminated copy of the array with each element replaced by its\n"
"    [`Base.cconvert`](@ref) version. This allows, for example, passing an `argv` pointer array of type\n"
"    `Vector{String}` to an argument of type `Ptr{Ptr{Cchar}}`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:354
msgid ""
"On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a "
"corresponding Julia type with the same name, prefixed by C.  This can help for writing portable code (and remembering that an `int` in C is "
"not the same as an `Int` in Julia)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:357
#, no-wrap
msgid "**System Independent Types**\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:387
#, no-wrap
msgid ""
"| C name                                                  | Fortran name             | Standard Julia Alias | Julia Base Type                                                                                                |\n"
"|:------------------------------------------------------- |:------------------------ |:-------------------- |:-------------------------------------------------------------------------------------------------------------- |\n"
"| `unsigned char`                                         | `CHARACTER`              | `Cuchar`             | `UInt8`                                                                                                        |\n"
"| `bool` (only in C++)                                    |                          | `Cuchar`             | `UInt8`                                                                                                        |\n"
"| `short`                                                 | `INTEGER*2`, `LOGICAL*2` | `Cshort`             | `Int16`                                                                                                        |\n"
"| `unsigned short`                                        | Â                         | `Cushort`            | `UInt16`                                                                                                       |\n"
"| `int`, `BOOL` (C, typical)                              | `INTEGER*4`, `LOGICAL*4` | `Cint`               | `Int32`                                                                                                        |\n"
"| `unsigned int`                                          | Â                         | `Cuint`              | `UInt32`                                                                                                       |\n"
"| `long long`                                             | `INTEGER*8`, `LOGICAL*8` | `Clonglong`          | `Int64`                                                                                                        |\n"
"| `unsigned long long`                                    | Â                         | `Culonglong`         | `UInt64`                                                                                                       |\n"
"| `intmax_t`                                              | Â                         | `Cintmax_t`          | `Int64`                                                                                                        |\n"
"| `uintmax_t`                                             | Â                         | `Cuintmax_t`         | `UInt64`                                                                                                       |\n"
"| `float`                                                 | `REAL*4i`                | `Cfloat`             | `Float32`                                                                                                      |\n"
"| `double`                                                | `REAL*8`                 | `Cdouble`            | `Float64`                                                                                                      |\n"
"| `complex float`                                         | `COMPLEX*8`              | `ComplexF32`          | `Complex{Float32}`                                                                                             |\n"
"| `complex double`                                        | `COMPLEX*16`             | `ComplexF64`         | `Complex{Float64}`                                                                                             |\n"
"| `ptrdiff_t`                                             | Â                         | `Cptrdiff_t`         | `Int`                                                                                                          |\n"
"| `ssize_t`                                               | Â                         | `Cssize_t`           | `Int`                                                                                                          |\n"
"| `size_t`                                                | Â                         | `Csize_t`            | `UInt`                                                                                                         |\n"
"| `void`                                                  | Â                         | Â                     | `Cvoid`                                                                                                         |\n"
"| `void` and `[[noreturn]]` or `_Noreturn`                | Â                         | Â                     | `Union{}`                                                                                                      |\n"
"| `void*`                                                 | Â                         | Â                     | `Ptr{Cvoid}`                                                                                                    |\n"
"| `T*` (where T represents an appropriately defined type) | Â                         | Â                     | `Ref{T}`                                                                                                       |\n"
"| `char*` (or `char[]`, e.g. a string)                    | `CHARACTER*N`            | Â                     | `Cstring` if NUL-terminated, or `Ptr{UInt8}` if not                                                            |\n"
"| `char**` (or `*char[]`)                                 | Â                         | Â                     | `Ptr{Ptr{UInt8}}`                                                                                              |\n"
"| `jl_value_t*` (any Julia Type)                          | Â                         | Â                     | `Any`                                                                                                          |\n"
"| `jl_value_t**` (a reference to a Julia Type)            | Â                         | Â                     | `Ref{Any}`                                                                                                     |\n"
"| `va_arg`                                                | Â                         | Â                     | Not supported                                                                                                  |\n"
"| `...` (variadic function specification)                 | Â                         | Â                     | `T...` (where `T` is one of the above types, variadic functions of different argument types are not supported) |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:396
msgid ""
"The [`Cstring`](@ref) type is essentially a synonym for `Ptr{UInt8}`, except the conversion to `Cstring` throws an error if the Julia string "
"contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator).  "
"If you are passing a `char*` to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if "
"you know for certain that your Julia string does not contain NUL and want to skip the check, you can use `Ptr{UInt8}` as the argument type. "
"`Cstring` can also be used as the [`ccall`](@ref) return type, but in that case it obviously does not introduce any extra checks and is only "
"meant to improve readability of the call."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:398
#, no-wrap
msgid "**System Dependent Types**\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:405
#, no-wrap
msgid ""
"| C name          | Standard Julia Alias | Julia Base Type                              |\n"
"|:--------------- |:-------------------- |:-------------------------------------------- |\n"
"| `char`          | `Cchar`              | `Int8` (x86, x86_64), `UInt8` (powerpc, arm) |\n"
"| `long`          | `Clong`              | `Int` (UNIX), `Int32` (Windows)              |\n"
"| `unsigned long` | `Culong`             | `UInt` (UNIX), `UInt32` (Windows)            |\n"
"| `wchar_t`       | `Cwchar_t`           | `Int32` (UNIX), `UInt16` (Windows)           |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:410
#, no-wrap
msgid ""
"!!! note\n"
"    When calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated\n"
"    values, so all type correspondences above should contain an additional `Ptr{..}` or\n"
"    `Ref{..}` wrapper around their type specification.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:416
#, no-wrap
msgid ""
"!!! warning\n"
"    For string arguments (`char*`) the Julia type should be `Cstring` (if NUL- terminated data is\n"
"    expected) or either `Ptr{Cchar}` or `Ptr{UInt8}` otherwise (these two pointer types have the same\n"
"    effect), as described above, not `String`. Similarly, for array arguments (`T[]` or `T*`), the\n"
"    Julia type should again be `Ptr{T}`, not `Vector{T}`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:420
#, no-wrap
msgid ""
"!!! warning\n"
"    Julia's `Char` type is 32 bits, which is not the same as the wide character type (`wchar_t` or\n"
"    `wint_t`) on all platforms.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:425
#, no-wrap
msgid ""
"!!! warning\n"
"    A return type of `Union{}` means the function will not return i.e. C++11 `[[noreturn]]` or C11\n"
"    `_Noreturn` (e.g. `jl_throw` or `longjmp`). Do not use this for functions that return no value\n"
"    (`void`) but do return, use `Cvoid` instead.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:432
#, no-wrap
msgid ""
"!!! note\n"
"    For `wchar_t*` arguments, the Julia type should be [`Cwstring`](@ref) (if the C routine expects a\n"
"    NUL-terminated string) or `Ptr{Cwchar_t}` otherwise. Note also that UTF-8 string data in Julia is\n"
"    internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without\n"
"    making a copy (but using the `Cwstring` type will cause an error to be thrown if the string itself\n"
"    contains NUL characters).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:436
#, no-wrap
msgid ""
"!!! note\n"
"    C functions that take an argument of the type `char**` can be called by using a `Ptr{Ptr{UInt8}}`\n"
"    type within Julia. For example, C functions of the form:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:440
#, no-wrap
msgid ""
"    ```c\n"
"    int main(int argc, char **argv);\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:442
#, no-wrap
msgid "    can be called via the following Julia code:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:447
#, no-wrap
msgid ""
"    ```julia\n"
"    argv = [ \"a.out\", \"arg1\", \"arg2\" ]\n"
"    ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:455
#, no-wrap
msgid ""
"!!! note\n"
"    For Fortran functions taking variable length strings of type `character(len=*)` the string lengths\n"
"    are provided as *hidden arguments*. Type and position of these arguments in the list are compiler\n"
"    specific, where compiler vendors usually default to using `Csize_t` as type and append the hidden\n"
"    arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU),\n"
"    others *optionally* permit placing hidden arguments directly after the character argument (Intel,PGI).\n"
"    For example, Fortran subroutines of the form\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:460
#, no-wrap
msgid ""
"    ```fortran\n"
"    subroutine test(str1, str2)\n"
"    character(len=*) :: str1,str2\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:462
#, no-wrap
msgid "    can be called via the following Julia code, where the lengths are appended\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:469
#, no-wrap
msgid ""
"    ```julia\n"
"    str1 = \"foo\"\n"
"    str2 = \"bar\"\n"
"    ccall(:test, Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),\n"
"                        str1, str2, sizeof(str1), sizeof(str2))\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:476
#, no-wrap
msgid ""
"!!! warning\n"
"    Fortran compilers *may* also add other hidden arguments for pointers, assumed-shape (`:`)\n"
"    and assumed-size (`*`) arrays. Such behaviour can be avoided by using `ISO_C_BINDING` and\n"
"    including `bind(c)` in the definition of the subroutine, which is strongly recommended for\n"
"    interoperable code. In this case there will be no hidden arguments, at the cost of some\n"
"    language features (e.g. only `character(len=1)` will be permitted to pass strings).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:479
#, no-wrap
msgid ""
"!!! note\n"
"    A C function declared to return `Cvoid` will return the value `nothing` in Julia.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:480
#, no-wrap
msgid "Struct Type Correspondences"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:485
msgid ""
"Composite types, aka `struct` in C or `TYPE` in Fortran90 (or `STRUCTURE` / `RECORD` in some variants of F77), can be mirrored in Julia by "
"creating a `struct` definition with the same field layout."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:491
msgid ""
"When used recursively, `isbits` types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used "
"by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve "
"the correct field alignment. Instead, declare an `isbits` struct type and use that instead. Unnamed structs are not possible in the "
"translation to Julia."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:493
msgid "Packed structs and union declarations are not supported by Julia."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:497
msgid ""
"You can get an approximation of a `union` if you know, a priori, the field that will have the greatest size (potentially including padding). "
"When translating your fields to Julia, declare the Julia field to be only of that type."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:499
msgid "Arrays of parameters can be expressed with `NTuple`.  For example, the struct in C notation written as"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:500
#, no-wrap
msgid ""
"struct B {\n"
"    int A[3];\n"
"};\n"
"\n"
"b_a_2 = B.A[2];\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:509
msgid "can be written in Julia as"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:510
#, no-wrap
msgid ""
"struct B\n"
"    A::NTuple{3, Cint}\n"
"end\n"
"\n"
"b_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:521
msgid ""
"Arrays of unknown size (C99-compliant variable length structs specified by `[]` or `[0]`) are not directly supported. Often the best way to "
"deal with these is to deal with the byte offsets directly.  For example, if a C library declared a proper string type and returned a pointer "
"to it:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:522
#, no-wrap
msgid ""
"struct String {\n"
"    int strlen;\n"
"    char data[];\n"
"};\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:530
msgid "In Julia, we can access the parts independently to make a copy of that string:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:531
#, no-wrap
msgid ""
"str = from_c::Ptr{Cvoid}\n"
"len = unsafe_load(Ptr{Cint}(str))\n"
"unsafe_string(str + Core.sizeof(Cint), len)\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:537
#, no-wrap
msgid "Type Parameters"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:543
msgid ""
"The type arguments to `ccall` and `@cfunction` are evaluated statically, when the method containing the usage is defined.  They therefore "
"must take the form of a literal tuple, not a variable, and cannot reference local variables."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:547
msgid ""
"This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept "
"argument types with a statically-known, fixed signature."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:556
msgid ""
"However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered "
"to be part of this static environment.  The static parameters of the function may be used as type parameters in the call signature, as long "
"as they don't affect the layout of the type.  For example, `f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)` is valid, since `Ptr` "
"is always a word-size primitive type.  But, `g(x::T) where {T} = ccall(:notvalid, T, (T,), x)` is not valid, since the type layout of `T` is "
"not known statically."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:557
#, no-wrap
msgid "SIMD Values"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:560
msgid "Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:563
msgid ""
"If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of "
"`VecElement` that naturally maps to the SIMD type.  Specifically:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:568
#, no-wrap
msgid ""
">   * The tuple must be the same size as the SIMD type. For example, a tuple representing an `__m128`\n"
">     on x86 must have a size of 16 bytes.\n"
">   * The element type of the tuple must be an instance of `VecElement{T}` where `T` is a primitive type that\n"
">     is 1, 2, 4 or 8 bytes.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:570
msgid "For instance, consider this C routine that uses AVX intrinsics:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:571
#, no-wrap
msgid ""
"#include <immintrin.h>\n"
"\n"
"__m256 dist( __m256 a, __m256 b ) {\n"
"    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n"
"                                        _mm256_mul_ps(b, b)));\n"
"}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:581
msgid "The following Julia code calls `dist` using `ccall`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:582
#, no-wrap
msgid ""
"const m256 = NTuple{8, VecElement{Float32}}\n"
"\n"
"a = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))\n"
"b = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))\n"
"\n"
"function call_dist(a::m256, b::m256)\n"
"    ccall((:dist, \"libdist\"), m256, (m256, m256), a, b)\n"
"end\n"
"\n"
"println(call_dist(a,b))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:597
msgid "The host machine must have the requisite SIMD registers.  For example, the code above will not work on hosts without AVX support."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:598
#, no-wrap
msgid "Memory Ownership"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:601
#, no-wrap
msgid "**malloc/free**\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:607
msgid ""
"Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, "
"just like in any C program. Do not try to free an object received from a C library with [`Libc.free`](@ref) in Julia, as this may result in "
"the `free` function being called via the wrong library and cause the process to abort. The reverse (passing an object allocated in Julia to "
"be freed by an external library) is equally invalid."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:608
#, no-wrap
msgid "When to use T, Ptr{T} and Ref{T}"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:618
msgid ""
"In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type `T` inside the [`ccall`]"
"(@ref), as they are passed by value.  For C code accepting pointers, [`Ref{T}`](@ref) should generally be used for the types of input "
"arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to [`Base.cconvert`](@ref).  In "
"contrast, pointers returned by the C function called should be declared to be of output type [`Ptr{T}`](@ref), reflecting that the memory "
"pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type `Ptr{T}` within the corresponding "
"Julia struct types designed to mimic the internal structure of corresponding C structs."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:623
msgid ""
"In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type `Ref{T}`, as Fortran passes all "
"variables by pointers to memory locations. The return type should either be `Cvoid` for Fortran subroutines, or a `T` for Fortran functions "
"returning the type `T`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:624
#, no-wrap
msgid "Mapping C Functions to Julia"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:626
#, no-wrap
msgid "`ccall` / `@cfunction` argument translation guide"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:629
msgid "For translating a C argument list to Julia:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:632
msgid ""
"`T`, where `T` is one of the primitive types: `char`, `int`, `long`, `short`, `float`, `double`, `complex`, `enum` or any of their `typedef` "
"equivalents"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:637 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:683
msgid "`T`, where `T` is an equivalent Julia Bits Type (per the table above)"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:637 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:683
msgid "if `T` is an `enum`, the argument type should be equivalent to `Cint` or `Cuint`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:637
#, no-wrap
msgid ""
"      * argument value will be copied (passed by value)\n"
"  * `struct T` (including typedef to a struct)\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:641
msgid "`T`, where `T` is a Julia leaf type"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:641
#, no-wrap
msgid ""
"      * argument value will be copied (passed by value)\n"
"  * `void*`\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:646 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:692
msgid ""
"depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the "
"remaining rules in this list"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:646 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:692
#, no-wrap
msgid ""
"      * this argument may be declared as `Ptr{Cvoid}`, if it really is just an unknown pointer\n"
"  * `jl_value_t*`\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:650 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:696
msgid "`Any`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:650 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:696
#, no-wrap
msgid ""
"      * argument value must be a valid Julia object\n"
"  * `jl_value_t**`\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:654
msgid "`Ref{Any}`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:654 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:700
#, no-wrap
msgid ""
"      * argument value must be a valid Julia object (or `C_NULL`)\n"
"  * `T*`\n"
msgstr ""

#. type: Bullet: '          * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:659 ext/julia/doc/src/manual/calling-c-and-fortran-code.md:708
msgid "`Ref{T}`, where `T` is the Julia type corresponding to `T`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:659
#, no-wrap
msgid ""
"      * argument value will be copied if it is an `isbits` type otherwise, the value must be a valid Julia\n"
"        object\n"
"  * `T (*)(...)` (e.g. a pointer to a function)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:662
#, no-wrap
msgid ""
"      * `Ptr{Cvoid}` (you may need to use [`@cfunction`](@ref) explicitly to create this pointer)\n"
"  * `...` (e.g. a vararg)\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:666
msgid "`T...`, where `T` is the Julia type"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:666
#, no-wrap
msgid ""
"      * currently unsupported by `@cfunction`\n"
"  * `va_arg`\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:668
msgid "not supported by `ccall` or `@cfunction`"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:669
#, no-wrap
msgid "`ccall` / `@cfunction` return type translation guide"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:672
msgid "For translating a C return type to Julia:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:674
msgid "`void`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:678
#, no-wrap
msgid ""
"      * `Cvoid` (this will return the singleton instance `nothing::Cvoid`)\n"
"  * `T`, where `T` is one of the primitive types: `char`, `int`, `long`, `short`, `float`, `double`,\n"
"    `complex`, `enum` or any of their `typedef` equivalents\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:683
#, no-wrap
msgid ""
"      * argument value will be copied (returned by-value)\n"
"  * `struct T` (including typedef to a struct)\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:687
msgid "`T`, where `T` is a Julia Leaf Type"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:687
#, no-wrap
msgid ""
"      * argument value will be copied (returned by-value)\n"
"  * `void*`\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:700
msgid "`Ptr{Any}` (`Ref{Any}` is invalid as a return type)"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:702
msgid "If the memory is already owned by Julia, or is an `isbits` type, and is known to be non-null:"
msgstr ""

#. type: Bullet: '          * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:708
msgid ""
"a return type of `Ref{Any}` is invalid, it should either be `Any` (corresponding to `jl_value_t*`) or `Ptr{Any}` (corresponding to "
"`jl_value_t**`)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:708
#, no-wrap
msgid ""
"          * C **MUST NOT** modify the memory returned via `Ref{T}` if `T` is an `isbits` type\n"
"      * If the memory is owned by C:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:711
#, no-wrap
msgid ""
"          * `Ptr{T}`, where `T` is the Julia type corresponding to `T`\n"
"  * `T (*)(...)` (e.g. a pointer to a function)\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:713
msgid "`Ptr{Cvoid}` (you may need to use [`@cfunction`](@ref) explicitly to create this pointer)"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:714
#, no-wrap
msgid "Passing Pointers for Modifying Inputs"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:720
msgid ""
"Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish "
"this within a [`ccall`](@ref), you need to first encapsulate the value inside a [`Ref{T}`](@ref) of the appropriate type. When you pass this "
"`Ref` object as an argument, Julia will automatically pass a C pointer to the encapsulated data:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:721
#, no-wrap
msgid ""
"width = Ref{Cint}(0)\n"
"range = Ref{Cfloat}(0)\n"
"ccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:729
msgid ""
"Upon return, the contents of `width` and `range` can be retrieved (if they were changed by `foo`)  by `width[]` and `range[]`; that is, they "
"act like zero-dimensional arrays."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:730
#, no-wrap
msgid "C Wrapper Examples"
msgstr "C åãã©ããã¼ã®ä¾"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:733
msgid "Let's start with a simple example of a C wrapper that returns a `Ptr` type:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:734
#, no-wrap
msgid ""
"mutable struct gsl_permutation\n"
"end\n"
"\n"
"# The corresponding C signature is\n"
"#     gsl_permutation * gsl_permutation_alloc (size_t n);\n"
"function permutation_alloc(n::Integer)\n"
"    output_ptr = ccall(\n"
"        (:gsl_permutation_alloc, :libgsl), # name of C function and library\n"
"        Ptr{gsl_permutation},              # output type\n"
"        (Csize_t,),                        # tuple of input types\n"
"        n                                  # name of Julia variable to pass in\n"
"    )\n"
"    if output_ptr == C_NULL # Could not allocate memory\n"
"        throw(OutOfMemoryError())\n"
"    end\n"
"    return output_ptr\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:761
msgid ""
"The [GNU Scientific Library](https://www.gnu.org/software/gsl/) (here assumed to be accessible through `:libgsl`) defines an opaque pointer, "
"`gsl_permutation *`, as the return type of the C function `gsl_permutation_alloc`. As user code never has to look inside the "
"`gsl_permutation` struct, the corresponding Julia wrapper simply needs a new type declaration, `gsl_permutation`, that has no internal "
"fields and whose sole purpose is to be placed in the type parameter of a `Ptr` type.  The return type of the [`ccall`](@ref) is declared as "
"`Ptr{gsl_permutation}`, since the memory allocated and pointed to by `output_ptr` is controlled by C."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:769
msgid ""
"The input `n` is passed by value, and so the function's input signature is simply declared as `(Csize_t,)` without any `Ref` or `Ptr` "
"necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature would instead be "
"`(Ref{Csize_t},)`, since Fortran variables are passed by pointers.) Furthermore, `n` can be any type that is convertible to a `Csize_t` "
"integer; the [`ccall`](@ref) implicitly calls [`Base.cconvert(Csize_t, n)`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:771
msgid "Here is a second example wrapping the corresponding destructor:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:772
#, no-wrap
msgid ""
"# The corresponding C signature is\n"
"#     void gsl_permutation_free (gsl_permutation * p);\n"
"function permutation_free(p::Ref{gsl_permutation})\n"
"    ccall(\n"
"        (:gsl_permutation_free, :libgsl), # name of C function and library\n"
"        Cvoid,                             # output type\n"
"        (Ref{gsl_permutation},),          # tuple of input types\n"
"        p                                 # name of Julia variable to pass in\n"
"    )\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:788
msgid ""
"Here, the input `p` is declared to be of type `Ref{gsl_permutation}`, meaning that the memory that `p` points to may be managed by Julia or "
"by C. A pointer to memory allocated by C should be of type `Ptr{gsl_permutation}`, but it is convertible using [`Base.cconvert`](@ref) and "
"therefore"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:794
msgid ""
"Now if you look closely enough at this example, you may notice that it is incorrect, given our explanation above of preferred declaration "
"types. Do you see it? The function we are calling is going to free the memory. This type of operation cannot be given a Julia object (it "
"will crash or cause memory corruption).  Therefore, it may be preferable to declare the `p` type as `Ptr{gsl_permutation }`, to make it "
"harder for the user to mistakenly pass another sort of object there than one obtained via `gsl_permutation_alloc`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:798
msgid ""
"If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using `p::Ptr{gsl_permutation}` for the method "
"signature of the wrapper and similarly in the [`ccall`](@ref)  is also acceptable."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:800
msgid "Here is a third example passing Julia arrays:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:801
#, no-wrap
msgid ""
"# The corresponding C signature is\n"
"#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n"
"#                                double result_array[])\n"
"function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n"
"    if nmax < nmin\n"
"        throw(DomainError())\n"
"    end\n"
"    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)\n"
"    errorcode = ccall(\n"
"        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library\n"
"        Cint,                               # output type\n"
"        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types\n"
"        nmin, nmax, x, result_array         # names of Julia variables to pass in\n"
"    )\n"
"    if errorcode != 0\n"
"        error(\"GSL error code $errorcode\")\n"
"    end\n"
"    return result_array\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:828
msgid ""
"The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array "
"`result_array`. This variable is declared as a `Ref{Cdouble}`, since its memory is allocated and managed by Julia. The implicit call to "
"[`Base.cconvert(Ref{Cdouble}, result_array)`](@ref) unpacks the Julia pointer to a Julia array data structure into a form understandable by "
"C."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:829
#, no-wrap
msgid "Fortran Wrapper Example"
msgstr "Fortran åãã©ããã¼ã®ä¾"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:837
msgid ""
"The following example utilizes ccall to call a function in a common Fortran library (libBLAS) to computes a dot product. Notice that the "
"argument mapping is a bit different here than above, as we need to map from Julia to Fortran.  On every argument type, we specify `Ref` or "
"`Ptr`. This mangling convention may be specific to your fortran compiler and operating system, and is likely undocumented. However, wrapping "
"each in a `Ref` (or `Ptr`, where equivalent) is a frequent requirement of Fortran compiler implementations:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:838
#, no-wrap
msgid ""
"function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n"
"    @assert length(DX) == length(DY)\n"
"    n = length(DX)\n"
"    incx = incy = 1\n"
"    product = ccall((:ddot_, \"libLAPACK\"),\n"
"                    Float64,\n"
"                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),\n"
"                    n, DX, incx, DY, incy)\n"
"    return product\n"
"end\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:852
#, no-wrap
msgid "Garbage Collection Safety"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:861
msgid ""
"When passing data to a [`ccall`](@ref), it is best to avoid using the [`pointer`](@ref) function.  Instead define a convert method and pass "
"the variables directly to the [`ccall`](@ref). [`ccall`](@ref)  automatically arranges that all of its arguments will be preserved from "
"garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the [`ccall`](@ref)  "
"returns, you must arrange that the object remains visible to the garbage collector. The suggested way to handle this is to make a global "
"variable of type `Array{Ref,1}` to hold these values, until the C library notifies you that it is finished with them."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:868
msgid ""
"Whenever you have created a pointer to Julia data, you must ensure the original data exists until you are done with using the pointer. Many "
"methods in Julia such as [`unsafe_load`](@ref) and [`String`](@ref) make copies of data instead of taking ownership of the buffer, so that "
"it is safe to free (or alter) the original data without affecting Julia. A notable exception is [`unsafe_wrap`](@ref) which, for performance "
"reasons, shares (or can be told to take ownership of) the underlying buffer."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:873
msgid ""
"The garbage collector does not guarantee any order of finalization. That is, if `a` contained a reference to `b` and both `a` and `b` are "
"due for garbage collection, there is no guarantee that `b` would be finalized after `a`. If proper finalization of `a` depends on `b` being "
"valid, it must be handled in other ways."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:874
#, no-wrap
msgid "Non-constant Function Specifications"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:878
msgid ""
"A `(name, library)` function specification must be a constant expression. However, it is possible to use computed values as function names "
"by staging through [`eval`](@ref) as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:879
#, no-wrap
msgid "@eval ccall(($(string(\"a\", \"b\")), \"lib\"), ...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:889
msgid ""
"This expression constructs a name using `string`, then substitutes this name into a new [`ccall`](@ref)  expression, which is then "
"evaluated. Keep in mind that `eval` only operates at the top level, so within this expression local variables will not be available (unless "
"their values are substituted with `$`). For this reason, `eval` is typically only used to form top-level definitions, for example when "
"wrapping libraries that contain many similar functions.  A similar example can be constructed for [`@cfunction`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:892
msgid ""
"However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading.  The next section "
"discusses how to use indirect calls to efficiently accomplish a similar effect."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:893
#, no-wrap
msgid "Indirect Calls"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:899
msgid ""
"The first argument to [`ccall`](@ref) can also be an expression evaluated at run time. In this case, the expression must evaluate to a "
"`Ptr`, which will be used as the address of the native function to call. This behavior occurs when the first [`ccall`](@ref) argument "
"contains references to non-constants, such as local variables, function arguments, or non-constant globals."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:902
msgid "For example, you might look up the function via `dlsym`, then cache it in a shared reference for that session. For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:903
#, no-wrap
msgid ""
"macro dlsym(func, lib)\n"
"    z = Ref{Ptr{Cvoid}}(C_NULL)\n"
"    quote\n"
"        let zlocal = $z[]\n"
"            if zlocal == C_NULL\n"
"                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}\n"
"                $z[] = $zlocal\n"
"            end\n"
"            zlocal\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"mylibvar = Libdl.dlopen(\"mylib\")\n"
"ccall(@dlsym(\"myfunc\", mylibvar), Cvoid, ())\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:921
#, no-wrap
msgid "Closure cfunctions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:930
msgid ""
"The first argument to [`@cfunction`](@ref) can be marked with a `$`, in which case the return value will instead be a `struct CFunction` "
"which closes over the argument.  You must ensure that this return object is kept alive until all uses of it are done.  The contents and code "
"at the cfunction pointer will be erased via a [`finalizer`](@ref)  when this reference is dropped and atexit. This is not usually needed, "
"since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don't provide a separate closure "
"environment parameter."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:931
#, no-wrap
msgid ""
"function qsort(a::Vector{T}, cmp) where T\n"
"    isbits(T) || throw(ArgumentError(\"this method can only qsort isbits arrays\"))\n"
"    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})\n"
"    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}\n"
"    # (and protected against finalization) by the ccall\n"
"    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),\n"
"        a, length(a), Base.elsize(a), callback)\n"
"    # We could instead use:\n"
"    #    GC.@preserve callback begin\n"
"    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))\n"
"    #    end\n"
"    # if we needed to use it outside of a `ccall`\n"
"    return a\n"
"end\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:949
#, no-wrap
msgid "Closing a Library"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:956
msgid ""
"It is sometimes useful to close (unload) a library so that it can be reloaded.  For instance, when developing C code for use with Julia, one "
"may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can "
"either restart Julia or use the `Libdl` functions to manage the library explicitly, such as:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:957
#, no-wrap
msgid ""
"lib = Libdl.dlopen(\"./my_lib.so\") # Open the library explicitly.\n"
"sym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.\n"
"ccall(sym, ...) # Use the pointer `sym` instead of the (symbol, library) tuple (remaining arguments are the\n"
"same).  Libdl.dlclose(lib) # Close the library explicitly.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:967
msgid ""
"Note that when using `ccall` with the tuple input (e.g., `ccall((:my_fcn, \"./my_lib.so\"), ...)`), the library is opened implicitly and it "
"may not be explicitly closed."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:968
#, no-wrap
msgid "Calling Convention"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:975
msgid ""
"The second argument to [`ccall`](@ref) can optionally be a calling convention specifier (immediately preceding return type). Without any "
"specifier, the platform-default C calling convention is used.  Other supported conventions are: `stdcall`, `cdecl`, `fastcall`, and "
"`thiscall` (no-op on 64-bit Windows).  For example (from `base/libc.jl`) we see the same `gethostname`[`ccall`](@ref) as above, but with the "
"correct signature for Windows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:976
#, no-wrap
msgid ""
"hn = Vector{UInt8}(undef, 256)\n"
"err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:982
msgid "For more information, please see the [LLVM Language Reference](http://llvm.org/docs/LangRef.html#calling-conventions)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:987
msgid ""
"There is one additional special calling convention [`llvmcall`](@ref Base.llvmcall), which allows inserting calls to LLVM intrinsics "
"directly.  This can be especially useful when targeting unusual platforms such as GPGPUs.  For example, for [CUDA](http://llvm.org/docs/"
"NVPTXUsage.html), we need to be able to read the thread index:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:988
#, no-wrap
msgid "ccall(\"llvm.nvvm.read.ptx.sreg.tid.x\", llvmcall, Int32, ())\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:996
msgid ""
"As with any `ccall`, it is essential to get the argument signature exactly correct.  Also, note that there is no compatibility layer that "
"ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by `Core.Intrinsics`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:997
#, no-wrap
msgid "Accessing Global Variables"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1002
msgid ""
"Global variables exported by native libraries can be accessed by name using the [`cglobal`](@ref)  function. The arguments to [`cglobal`]"
"(@ref) are a symbol specification identical to that used by [`ccall`](@ref), and a type describing the value stored in the variable:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1003
#, no-wrap
msgid ""
"julia> cglobal((:errno, :libc), Int32)\n"
"Ptr{Int32} @0x00007f418d0816b8\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1010
msgid ""
"The result is a pointer giving the address of the value. The value can be manipulated through this pointer using [`unsafe_load`](@ref) and "
"[`unsafe_store!`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1019
#, no-wrap
msgid ""
"!!! note\n"
"    This `errno` symbol may not be found in a library named \"libc\", as this is an implementation detail of\n"
"    your system compiler. Typically standard library symbols should be accessed just by name,\n"
"    allowing the compiler to fill in the correct one.\n"
"    Also, however, the `errno` symbol shown in this example is special in most compilers, and so the value\n"
"    seen here is probably not what you expect or want. Compiling the equivalent code in C on any\n"
"    multi-threaded-capable system would typically actually call a different function (via macro preprocessor\n"
"    overloading), and may give a different result than the legacy value printed here.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1020
#, no-wrap
msgid "Accessing Data through a Pointer"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1024
msgid "The following methods are described as \"unsafe\" because a bad pointer or type declaration can cause Julia to terminate abruptly."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1029
msgid ""
"Given a `Ptr{T}`, the contents of type `T` can generally be copied from the referenced memory into a Julia object using `unsafe_load(ptr, "
"[index])`. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is "
"intentionally similar to the behavior of [`getindex`](@ref) and [`setindex!`](@ref) (e.g. `[]` access syntax)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1032
msgid ""
"The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can "
"safely be freed or released."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1041
msgid ""
"If `T` is `Any`, then the memory is assumed to contain a reference to a Julia object (a `jl_value_t*`), the result will be a reference to "
"this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage "
"collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not "
"originally allocated by Julia, the new object will never be finalized by Julia's garbage collector.  If the `Ptr` itself is actually a "
"`jl_value_t*`, it can be converted back to a Julia object reference by [`unsafe_pointer_to_objref(ptr)`](@ref). (Julia values `v` can be "
"converted to `jl_value_t*` pointers, as `Ptr{Cvoid}`, by calling [`pointer_from_objref(v)`](@ref).)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1045
msgid ""
"The reverse operation (writing data to a `Ptr{T}`), can be performed using [`unsafe_store!(ptr, value, [index])`](@ref).  Currently, this is "
"only supported for primitive types or other pointer-free (`isbits`) immutable struct types."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1048
msgid "Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1055
msgid ""
"If the pointer of interest is a plain-data array (primitive type or immutable struct), the function [`unsafe_wrap(Array, ptr,dims, own = "
"false)`](@ref)  may be more useful. The final parameter should be true if Julia should \"take ownership\" of the underlying buffer and call "
"`free(ptr)` when the returned `Array` object is finalized.  If the `own` parameter is omitted or false, the caller must ensure the buffer "
"remains in existence until all access is complete."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1060
msgid ""
"Arithmetic on the `Ptr` type in Julia (e.g. using `+`) does not behave the same as C's pointer arithmetic. Adding an integer to a `Ptr` in "
"Julia always moves the pointer by some number of *bytes*, not elements. This way, the address values obtained from pointer arithmetic do not "
"depend on the element types of pointers."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1061
#, no-wrap
msgid "Thread-safety"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1067
msgid ""
"Some C libraries execute their callbacks from a different thread, and since Julia isn't thread-safe you'll need to take some extra "
"precautions. In particular, you'll need to set up a two-layered system: the C callback should only *schedule* (via Julia's event loop) the "
"execution of your \"real\" callback. To do this, create an [`AsyncCondition`](@ref Base.AsyncCondition) object and [`wait`](@ref) on it:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1068
#, no-wrap
msgid ""
"cond = Base.AsyncCondition()\n"
"wait(cond)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1076
msgid ""
"The callback you pass to C should only execute a [`ccall`](@ref) to `:uv_async_send`, passing `cond.handle` as the argument, taking care to "
"avoid any allocations or other interactions with the Julia runtime."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1079
msgid "Note that events may be coalesced, so multiple calls to `uv_async_send` may result in a single wakeup notification to the condition."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1080
#, no-wrap
msgid "More About Callbacks"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1083
msgid "For more details on how to pass callbacks to C libraries, see this [blog post](https://julialang.org/blog/2013/05/callback)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1084
#, no-wrap
msgid "C++"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1088
msgid ""
"For direct C++ interfacing, see the [Cxx](https://github.com/Keno/Cxx.jl) package. For tools to create C++ bindings, see the [CxxWrap]"
"(https://github.com/JuliaInterop/CxxWrap.jl) package."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1094
#, no-wrap
msgid ""
"[^1]: Non-library function calls in both C and Julia can be inlined and thus may have\n"
"    even less overhead than calls to shared library functions.\n"
"    The point above is that the cost of actually doing foreign function call is about the same as doing a call in either native language.\n"
msgstr ""
"[^1]: C ã¨ Julia ã®ä¸¡æ¹ã®éã©ã¤ãã©ãªé¢æ°å¼ã³åºãã¯ã¤ã³ã©ã¤ã³åã§ãããããå±æã©ã¤ãã©ãªé¢æ°ã®å¼ã³åºãããããªã¼ãã¼ããããå°ãªãå ´åãããã¾ãã\n"
"    ããã§éè¦ãªã®ã¯ãJulia å¤ã®é¢æ°ã³ã¼ã«ã®å®éã®ã³ã¹ãã¯ããã¤ãã£ãå®è¡ã®ã³ã¹ãã¨ã»ã¼åãã§ããã¨ãããã¨ã§ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/calling-c-and-fortran-code.md:1096
#, no-wrap
msgid ""
"[^2]: The [Clang package](https://github.com/ihnorton/Clang.jl) can be used to auto-generate Julia code\n"
"    from a C header file.\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/missing.md:1
#, no-wrap
msgid "[Missing Values](@id missing)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:11
msgid ""
"Julia provides support for representing missing values in the statistical sense, that is for situations where no value is available for a "
"variable in an observation, but a valid value theoretically exists.  Missing values are represented via the [`missing`](@ref) object, which "
"is the singleton instance of the type [`Missing`](@ref). `missing` is equivalent to [`NULL` in SQL](https://en.wikipedia.org/wiki/"
"NULL_(SQL)) and [`NA` in R](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling), and behaves like them in most "
"situations."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/missing.md:12
#, no-wrap
msgid "Propagation of Missing Values"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:19
msgid ""
"The behavior of `missing` values follows one basic rule: `missing` values *propagate* automatically when passed to standard operators and "
"functions, in particular mathematical functions. Uncertainty about the value of one of the operands induces uncertainty about the result. In "
"practice, this means an operation involving a `missing` value generally returns `missing`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:19
#, no-wrap
msgid ""
"julia> missing + 1\n"
"missing\n"
"\n"
"julia> \"a\" * missing\n"
"missing\n"
"\n"
"julia> abs(missing)\n"
"missing\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:39
msgid ""
"As `missing` is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This "
"can be achieved either via a specific method defined for arguments of type `Missing`, or simply by accepting arguments of this type, and "
"passing them to functions which propagate them (like standard operators). Packages should consider whether it makes sense to propagate "
"missing values when defining new functions, and define methods appropriately if that is the case. Passing a `missing` value to a function "
"for which no method accepting arguments of type `Missing` is defined throws a [`MethodError`](@ref), just like for any other type."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/missing.md:40
#, no-wrap
msgid "Equality and Comparison Operators"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:45
msgid ""
"Standard equality and comparison operators follow the propagation rule presented above: if any of the operands is `missing`, the result is "
"`missing`.  Here are a few examples"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:45
#, no-wrap
msgid ""
"julia> missing == 1\n"
"missing\n"
"\n"
"julia> missing == missing\n"
"missing\n"
"\n"
"julia> missing < 1\n"
"missing\n"
"\n"
"julia> 2 >= missing\n"
"missing\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:62
msgid ""
"In particular, note that `missing == missing` returns `missing`, so `==` cannot be used to test whether a value is missing. To test whether "
"`x` is `missing`, use [`ismissing(x)`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:67
msgid ""
"Special comparison operators [`isequal`](@ref) and [`===`](@ref) are exceptions to the propagation rule: they always return a `Bool` value, "
"even in the presence of `missing` values, considering `missing` as equal to `missing` and as different from any other value. They can "
"therefore be used to test whether a value is `missing`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:67
#, no-wrap
msgid ""
"julia> missing === 1\n"
"false\n"
"\n"
"julia> isequal(missing, 1)\n"
"false\n"
"\n"
"julia> missing === missing\n"
"true\n"
"\n"
"julia> isequal(missing, missing)\n"
"true\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:84
msgid ""
"The [`isless`](@ref) operator is another exception: `missing` is considered as greater than any other value. This operator is used by "
"[`sort`](@ref), which therefore places `missing` values after all other values."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:84
#, no-wrap
msgid ""
"julia> isless(1, missing)\n"
"true\n"
"\n"
"julia> isless(missing, Inf)\n"
"false\n"
"\n"
"julia> isless(missing, missing)\n"
"false\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/missing.md:95
#, no-wrap
msgid "Logical operators"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:105
msgid ""
"Logical (or boolean) operators [`|`](@ref), [`&`](@ref) and [`xor`](@ref) are another special case, as they only propagate `missing` values "
"when it is logically required. For these operators, whether or not the result is uncertain depends on the particular operation, following "
"the well-established rules of [*three-valued logic*](https://en.wikipedia.org/wiki/Three-valued_logic) which are also implemented by `NULL` "
"in SQL and `NA` in R. This abstract definition actually corresponds to a relatively natural behavior which is best explained via concrete "
"examples."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:110
msgid ""
"Let us illustrate this principle with the logical \"or\" operator [`|`](@ref).  Following the rules of boolean logic, if one of the operands "
"is `true`, the value of the other operand does not have an influence on the result, which will always be `true`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:110
#, no-wrap
msgid ""
"julia> true | true\n"
"true\n"
"\n"
"julia> true | false\n"
"true\n"
"\n"
"julia> false | true\n"
"true\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:127
msgid ""
"Based on this observation, we can conclude that if one of the operands is `true` and the other `missing`, we know that the result is `true` "
"in spite of the uncertainty about the actual value of one of the operands. If we had been able to observe the actual value of the second "
"operand, it could only be `true` or `false`, and in both cases the result would be `true`. Therefore, in this particular case, missingness "
"does *not* propagate"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:127
#, no-wrap
msgid ""
"julia> true | missing\n"
"true\n"
"\n"
"julia> missing | true\n"
"true\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:138
msgid ""
"On the contrary, if one of the operands is `false`, the result could be either `true` or `false` depending on the value of the other "
"operand. Therefore, if that operand is `missing`, the result has to be `missing` too"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:138
#, no-wrap
msgid ""
"julia> false | true\n"
"true\n"
"\n"
"julia> true | false\n"
"true\n"
"\n"
"julia> false | false\n"
"false\n"
"\n"
"julia> false | missing\n"
"missing\n"
"\n"
"julia> missing | false\n"
"missing\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:159
msgid ""
"The behavior of the logical \"and\" operator [`&`](@ref) is similar to that of the `|` operator, with the difference that missingness does "
"not propagate when one of the operands is `false`. For example, when that is the case of the first operand"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:159
#, no-wrap
msgid ""
"julia> false & false\n"
"false\n"
"\n"
"julia> false & true\n"
"false\n"
"\n"
"julia> false & missing\n"
"false\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:172
msgid "On the other hand, missingness propagates when one of the operands is `true`, for example the first one"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:172
#, no-wrap
msgid ""
"julia> true & true\n"
"true\n"
"\n"
"julia> true & false\n"
"false\n"
"\n"
"julia> true & missing\n"
"missing\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:187
msgid ""
"Finally, the \"exclusive or\" logical operator [`xor`](@ref) always propagates `missing` values, since both operands always have an effect "
"on the result.  Also note that the negation operator [`!`](@ref) returns `missing` when the operand is `missing` just like other unary "
"operators."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/missing.md:188
#, no-wrap
msgid "Control Flow and Short-Circuiting Operators"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:196
msgid ""
"Control flow operators including [`if`](@ref), [`while`](@ref) and the [ternary operator](@ref man-conditional-evaluation) `x ? y : z` do "
"not allow for missing values. This is because of the uncertainty about whether the actual value would be `true` or `false` if we could "
"observe it, which implies that we do not know how the program should behave. A [`TypeError`](@ref)  is thrown as soon as a `missing` value "
"is encountered in this context"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:196
#, no-wrap
msgid ""
"julia> if missing\n"
"           println(\"here\")\n"
"       end\n"
"ERROR: TypeError: non-boolean (Missing) used in boolean context\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:207
msgid ""
"For the same reason, contrary to logical operators presented above, the short-circuiting boolean operators [`&&`](@ref) and [`||`](@ref) do "
"not allow for `missing` values in situations where the value of the operand determines whether the next operand is evaluated or not. For "
"example"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:207
#, no-wrap
msgid ""
"julia> missing || false\n"
"ERROR: TypeError: non-boolean (Missing) used in boolean context\n"
"\n"
"julia> missing && false\n"
"ERROR: TypeError: non-boolean (Missing) used in boolean context\n"
"\n"
"julia> true && missing && false\n"
"ERROR: TypeError: non-boolean (Missing) used in boolean context\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:222
msgid ""
"On the other hand, no error is thrown when the result can be determined without the `missing` values. This is the case when the code short-"
"circuits before evaluating the `missing` operand, and when the `missing` operand is the last one"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:222
#, no-wrap
msgid ""
"julia> true && missing\n"
"missing\n"
"\n"
"julia> false && missing\n"
"false\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/missing.md:230
#, no-wrap
msgid "Arrays With Missing Values"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:233
msgid "Arrays containing missing values can be created like other arrays"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:233
#, no-wrap
msgid ""
"julia> [1, missing]\n"
"2-element Array{Union{Missing, Int64},1}:\n"
" 1\n"
"  missing\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:246
msgid ""
"As this example shows, the element type of such arrays is `Union{Missing, T}`, with `T` the type of the non-missing values. This simply "
"reflects the fact that array entries can be either of type `T` (here, `Int64`) or of type `Missing`.  This kind of array uses an efficient "
"memory storage equivalent to an `Array{T}` holding the actual values combined with an `Array{UInt8}` indicating the type of the entry (i.e. "
"whether it is `Missing` or `T`)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:250
msgid ""
"Arrays allowing for missing values can be constructed with the standard syntax.  Use `Array{Union{Missing, T}}(missing, dims)` to create "
"arrays filled with missing values:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:250
#, no-wrap
msgid ""
"julia> Array{Union{Missing, String}}(missing, 2, 3)\n"
"2Ã3 Array{Union{Missing, String},2}:\n"
" missing  missing  missing\n"
" missing  missing  missing\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:261
msgid ""
"An array allowing for `missing` values but which does not contain any such value can be converted back to an array which does not allow for "
"missing values using [`convert`](@ref). If the array contains `missing` values, a `MethodError` is thrown during conversion"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:261
#, no-wrap
msgid ""
"julia> x = Union{Missing, String}[\"a\", \"b\"]\n"
"2-element Array{Union{Missing, String},1}:\n"
" \"a\"\n"
" \"b\"\n"
"\n"
"julia> convert(Array{String}, x)\n"
"2-element Array{String,1}:\n"
" \"a\"\n"
" \"b\"\n"
"\n"
"julia> y = Union{Missing, String}[missing, \"b\"]\n"
"2-element Array{Union{Missing, String},1}:\n"
" missing\n"
" \"b\"\n"
"\n"
"julia> convert(Array{String}, y)\n"
"ERROR: MethodError: Cannot `convert` an object of type Missing to an object of type String\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/missing.md:280
#, no-wrap
msgid "Skipping Missing Values"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:284
msgid ""
"Since `missing` values propagate with standard mathematical operators, reduction functions return `missing` when called on arrays which "
"contain missing values"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:284
#, no-wrap
msgid ""
"julia> sum([1, missing])\n"
"missing\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:290
msgid "In this situation, use the [`skipmissing`](@ref) function to skip missing values"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:290
#, no-wrap
msgid ""
"julia> sum(skipmissing([1, missing]))\n"
"1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:297
msgid ""
"This convenience function returns an iterator which filters out `missing` values efficiently. It can therefore be used with any function "
"which supports iterators"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/missing.md:297
#, no-wrap
msgid "jldoctest skipmissing; setup = :(using Statistics)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:297
#, no-wrap
msgid ""
"julia> x = skipmissing([3, missing, 2, 1])\n"
"Base.SkipMissing{Array{Union{Missing, Int64},1}}(Union{Missing, Int64}[3, missing, 2, 1])\n"
"\n"
"julia> maximum(x)\n"
"3\n"
"\n"
"julia> mean(x)\n"
"2.0\n"
"\n"
"julia> mapreduce(sqrt, +, x)\n"
"4.146264369941973\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:315
msgid ""
"Objects created by calling `skipmissing` on an array can be indexed using indices from the parent array. Indices corresponding to missing "
"values are not valid for these objects and an error is thrown when trying to use them (they are also skipped by `keys` and `eachindex`)"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/missing.md:315 ext/julia/doc/src/manual/missing.md:328 ext/julia/doc/src/manual/missing.md:341
#, no-wrap
msgid "jldoctest skipmissing"
msgstr "jldoctest skipmissing"

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:315
#, no-wrap
msgid ""
"julia> x[1]\n"
"3\n"
"\n"
"julia> x[2]\n"
"ERROR: MissingException: the value at index (2,) is missing\n"
"[...]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:328
msgid ""
"This allows functions which operate on indices to work in combination with `skipmissing`.  This is notably the case for search and find "
"functions, which return indices valid for the object returned by `skipmissing` which are also the indices of the matching entries *in the "
"parent array*"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:328
#, no-wrap
msgid ""
"julia> findall(==(1), x)\n"
"1-element Array{Int64,1}:\n"
" 4\n"
"\n"
"julia> findfirst(!iszero, x)\n"
"1\n"
"\n"
"julia> argmax(x)\n"
"1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:341
msgid "Use [`collect`](@ref) to extract non-`missing` values and store them in an array"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:341
#, no-wrap
msgid ""
"julia> collect(x)\n"
"3-element Array{Int64,1}:\n"
" 3\n"
" 2\n"
" 1\n"
msgstr ""
"julia> collect(x)\n"
"3-element Array{Int64,1}:\n"
" 3\n"
" 2\n"
" 1\n"

#. type: Title ##
#: ext/julia/doc/src/manual/missing.md:349
#, no-wrap
msgid "Logical Operations on Arrays"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:358
msgid ""
"The three-valued logic described above for logical operators is also used by logical functions applied to arrays. Thus, array equality tests "
"using the [`==`](@ref) operator return `missing` whenever the result cannot be determined without knowing the actual value of the `missing` "
"entry. In practice, this means that `missing` is returned if all non-missing values of the compared arrays are equal, but one or both arrays "
"contain missing values (possibly at different positions)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:358
#, no-wrap
msgid ""
"julia> [1, missing] == [2, missing]\n"
"false\n"
"\n"
"julia> [1, missing] == [1, missing]\n"
"missing\n"
"\n"
"julia> [1, 2, missing] == [1, missing, 2]\n"
"missing\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:371
msgid ""
"As for single values, use [`isequal`](@ref) to treat `missing` values as equal to other `missing` values but different from non-missing "
"values"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:371
#, no-wrap
msgid ""
"julia> isequal([1, missing], [1, missing])\n"
"true\n"
"\n"
"julia> isequal([1, 2, missing], [1, missing, 2])\n"
"false\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:381
msgid ""
"Functions [`any`](@ref) and [`all`](@ref) also follow the rules of three-valued logic, returning `missing` when the result cannot be "
"determined"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/missing.md:381
#, no-wrap
msgid ""
"julia> all([true, missing])\n"
"missing\n"
"\n"
"julia> all([false, missing])\n"
"false\n"
"\n"
"julia> any([true, missing])\n"
"true\n"
"\n"
"julia> any([false, missing])\n"
"missing\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/variables-and-scoping.md:1
#, no-wrap
msgid "[Scope of Variables](@id scope-of-variables)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:9
msgid ""
"The *scope* of a variable is the region of code within which a variable is visible. Variable scoping helps avoid variable naming conflicts. "
"The concept is intuitive: two functions can both have arguments called `x` without the two `x`'s referring to the same thing. Similarly, "
"there are many other cases where different blocks of code can use the same name without referring to the same thing. The rules for when the "
"same variable name does or doesn't refer to the same thing are called scope rules; this section spells them out in detail."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:15
msgid ""
"Certain constructs in the language introduce *scope blocks*, which are regions of code that are eligible to be the scope of some set of "
"variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. "
"There are two main types of scopes in Julia, *global scope* and *local scope*. The latter can be nested. The constructs introducing scope "
"blocks are:"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/variables-and-scoping.md:16
#, no-wrap
msgid "[Scope constructs](@id man-scope-table)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:26
#, no-wrap
msgid ""
"Construct | Scope type | Scope blocks it may be nested in\n"
"------------ | -------------  |---------------------------\n"
"[`module`](@ref), [`baremodule`](@ref)            | global | global\n"
"interactive prompt (REPL)                         | global | global\n"
"(mutable) [`struct`](@ref), [`macro`](@ref)       | local  | global\n"
"[`for`](@ref), [`while`](@ref), [`try-catch-finally`](@ref try), [`let`](@ref) |local | global or local\n"
"functions (either syntax, anonymous & do-blocks) | local | global or local\n"
"comprehensions, broadcast-fusing                 | local | global or local\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:31
msgid ""
"Notably missing from this table are [begin blocks](@ref man-compound-expressions) and [if blocks](@ref man-conditional-evaluation)  which do "
"*not* introduce new scopes.  Both types of scopes follow somewhat different rules which will be explained below."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:36
msgid ""
"Julia uses [lexical scoping](https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping), meaning that a "
"function's scope does not inherit from its caller's scope, but from the scope in which the function was defined. For example, in the "
"following code the `x` inside `foo` refers to the `x` in the global scope of its module `Bar`:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/variables-and-scoping.md:37 ext/julia/doc/src/manual/variables-and-scoping.md:46
#, no-wrap
msgid "jldoctest moduleBar"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:37
#, no-wrap
msgid ""
"julia> module Bar\n"
"           x = 1\n"
"           foo() = x\n"
"       end;\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:45
msgid "and not a `x` in the scope where `foo` is used:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:46
#, no-wrap
msgid ""
"julia> import .Bar\n"
"\n"
"julia> x = -1;\n"
"\n"
"julia> Bar.foo()\n"
"1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:56
msgid "Thus *lexical scope* means that the scope of variables can be inferred from the source code alone."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/variables-and-scoping.md:57
#, no-wrap
msgid "Global Scope"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:64
msgid ""
"Each module introduces a new global scope, separate from the global scope of all other modules; there is no all-encompassing global scope. "
"Modules can introduce variables of other modules into their scope through the [using or import](@ref modules) statements or through "
"qualified access using the dot-notation, i.e. each module is a so-called *namespace*. Note that variable bindings can only be changed within "
"their global scope and not from an outside module."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:65
#, no-wrap
msgid ""
"julia> module A\n"
"           a = 1 # a global in A's scope\n"
"       end;\n"
"\n"
"julia> module B\n"
"           module C\n"
"               c = 2\n"
"           end\n"
"           b = C.c    # can access the namespace of a nested global scope\n"
"                      # through a qualified access\n"
"           import ..A # makes module A available\n"
"           d = A.a\n"
"       end;\n"
"\n"
"julia> module D\n"
"           b = a # errors as D's global scope is separate from A's\n"
"       end;\n"
"ERROR: UndefVarError: a not defined\n"
"\n"
"julia> module E\n"
"           import ..A # make module A available\n"
"           A.a = 2    # throws below error\n"
"       end;\n"
"ERROR: cannot assign variables in other modules\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:93
msgid "Note that the interactive prompt (aka REPL) is in the global scope of the module `Main`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/variables-and-scoping.md:94
#, no-wrap
msgid "Local Scope"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:103
msgid ""
"A new local scope is introduced by most code blocks (see above [table](@ref man-scope-table) for a complete list).  A local scope inherits "
"all the variables from a parent local scope, both for reading and writing.  Unlike global scopes, local scopes are not namespaces, thus "
"variables in an inner scope cannot be retrieved from the parent scope through some sort of qualified access."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:107
msgid ""
"The following rules and examples pertain to local scopes.  A newly introduced variable in a local scope cannot be referenced by a parent "
"scope.  For example, here the ``z`` is not introduced into the top-level scope:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:108
#, no-wrap
msgid ""
"julia> for i = 1:10\n"
"           z = i\n"
"       end\n"
"\n"
"julia> z\n"
"ERROR: UndefVarError: z not defined\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:120
#, no-wrap
msgid ""
"!!! note\n"
"    In this and all following examples it is assumed that their top-level is a global scope\n"
"    with a clean workspace, for instance a newly started REPL.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:122
msgid "Inner local scopes can, however, update variables in their parent scopes:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:123
#, no-wrap
msgid ""
"julia> for i = 1:1\n"
"           z = i\n"
"           for j = 1:1\n"
"               z = 0\n"
"           end\n"
"           println(z)\n"
"       end\n"
"0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:135
msgid "Inside a local scope a variable can be forced to be a new local variable using the [`local`](@ref) keyword:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:136
#, no-wrap
msgid ""
"julia> for i = 1:1\n"
"           x = i + 1\n"
"           for j = 1:1\n"
"               local x = 0\n"
"           end\n"
"           println(x)\n"
"       end\n"
"2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:148
msgid "Inside a local scope a global variable can be assigned to by using the keyword [`global`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:149
#, no-wrap
msgid ""
"julia> for i = 1:10\n"
"           global z\n"
"           z = i\n"
"       end\n"
"\n"
"julia> z\n"
"10\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:161
msgid ""
"The location of both the `local` and `global` keywords within the scope block is irrelevant.  The following is equivalent to the last "
"example (although stylistically worse):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:162
#, no-wrap
msgid ""
"julia> for i = 1:10\n"
"           z = i\n"
"           global z\n"
"       end\n"
"\n"
"julia> z\n"
"10\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:174
msgid ""
"The `local` and `global` keywords can also be applied to destructuring assignments, e.g.  `local x, y = 1, 2`. In this case the keyword "
"affects all listed variables."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:177
msgid "In a local scope, all variables are inherited from its parent global scope block unless:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/variables-and-scoping.md:180
msgid "an assignment would result in a modified *global* variable, or"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/variables-and-scoping.md:180
msgid "a variable is specifically marked with the keyword `local`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:182
msgid "Thus global variables are only inherited for reading, not for writing:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:183
#, no-wrap
msgid ""
"julia> x, y = 1, 2;\n"
"\n"
"julia> function foo()\n"
"           x = 2        # assignment introduces a new local\n"
"           return x + y # y refers to the global\n"
"       end;\n"
"\n"
"julia> foo()\n"
"4\n"
"\n"
"julia> x\n"
"1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:199
msgid "An explicit `global` is needed to assign to a global variable:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:207
#, no-wrap
msgid ""
"!!! sidebar \"Avoiding globals\"\n"
"    Avoiding changing the value of global variables is considered by many\n"
"    to be a programming best-practice.\n"
"    Changing the value of a global variable can cause \"action at a distance\",\n"
"    making the behavior of a program harder to reason about.\n"
"    This is why the scope blocks that introduce local scope require the `global`\n"
"    keyword to declare the intent to modify a global variable.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:208
#, no-wrap
msgid ""
"julia> x = 1;\n"
"\n"
"julia> function foobar()\n"
"           global x = 2\n"
"       end;\n"
"\n"
"julia> foobar();\n"
"\n"
"julia> x\n"
"2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:222
msgid "Note that *nested functions* can modify their parent scope's *local* variables:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:223
#, no-wrap
msgid ""
"julia> x, y = 1, 2;\n"
"\n"
"julia> function baz()\n"
"           x = 2 # introduces a new local\n"
"           function bar()\n"
"               x = 10       # modifies the parent's x\n"
"               return x + y # y is global\n"
"           end\n"
"           return bar() + x # 12 + 10 (x is modified in call of bar())\n"
"       end;\n"
"\n"
"julia> baz()\n"
"22\n"
"\n"
"julia> x, y # verify that global x and y are unchanged\n"
"(1, 2)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:246
msgid ""
"The reason to allow modifying local variables of parent scopes in nested functions is to allow constructing [`closures`](https://en."
"wikipedia.org/wiki/Closure_%28computer_programming%29)  which have private state, for instance the `state` variable in the following example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:247
#, no-wrap
msgid ""
"julia> let state = 0\n"
"           global counter() = (state += 1)\n"
"       end;\n"
"\n"
"julia> counter()\n"
"1\n"
"\n"
"julia> counter()\n"
"2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:264
msgid ""
"See also the closures in the examples in the next two sections. A variable, such as `x` in the first example and `state` in the second, that "
"is inherited from the enclosing scope by the inner function is sometimes called a *captured* variable. Captured variables can present "
"performance challenges discussed in [performance tips](@ref man-performance-tips)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:269
msgid ""
"The distinction between inheriting global scope and nesting local scope can lead to some slight differences between functions defined in "
"local versus global scopes for variable assignments.  Consider the modification of the last example by moving `bar` to the global scope:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:270
#, no-wrap
msgid ""
"julia> x, y = 1, 2;\n"
"\n"
"julia> function bar()\n"
"           x = 10 # local, no longer a closure variable\n"
"           return x + y\n"
"       end;\n"
"\n"
"julia> function quz()\n"
"           x = 2 # local\n"
"           return bar() + x # 12 + 2 (x is not modified)\n"
"       end;\n"
"\n"
"julia> quz()\n"
"14\n"
"\n"
"julia> x, y # verify that global x and y are unchanged\n"
"(1, 2)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:293
msgid ""
"Note that the above nesting rules do not pertain to type and macro definitions as they can only appear at the global scope. There are "
"special scoping rules concerning the evaluation of default and keyword function arguments which are described in the [Function section](@ref "
"man-functions)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:296
msgid "An assignment introducing a variable used inside a function, type or macro definition need not come before its inner usage:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:297
#, no-wrap
msgid ""
"julia> f = y -> y + a;\n"
"\n"
"julia> f(3)\n"
"ERROR: UndefVarError: a not defined\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> a = 1\n"
"1\n"
"\n"
"julia> f(3)\n"
"4\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:318
msgid ""
"This behavior may seem slightly odd for a normal variable, but allows for named functions -- which are just normal variables holding "
"function objects -- to be used before they are defined. This allows functions to be defined in whatever order is intuitive and convenient, "
"rather than forcing bottom up ordering or requiring forward declarations, as long as they are defined by the time they are actually called. "
"As an example, here is an inefficient, mutually recursive way to test if positive integers are even or odd:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:319
#, no-wrap
msgid ""
"julia> even(n) = (n == 0) ? true : odd(n - 1);\n"
"\n"
"julia> odd(n) = (n == 0) ? false : even(n - 1);\n"
"\n"
"julia> even(3)\n"
"false\n"
"\n"
"julia> odd(3)\n"
"true\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:334
msgid ""
"Julia provides built-in, efficient functions to test for oddness and evenness called [`iseven`](@ref)  and [`isodd`](@ref) so the above "
"definitions should only be considered to be examples of scope, not efficient design."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/variables-and-scoping.md:335
#, no-wrap
msgid "Let Blocks"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:342
msgid ""
"Unlike assignments to local variables, `let` statements allocate new variable bindings each time they run. An assignment modifies an "
"existing value location, and `let` creates new locations.  This difference is usually not important, and is only detectable in the case of "
"variables that outlive their scope via closures. The `let` syntax accepts a comma-separated series of assignments and variable names:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:343
#, no-wrap
msgid ""
"julia> x, y, z = -1, -1, -1;\n"
"\n"
"julia> let x = 1, z\n"
"           println(\"x: $x, y: $y\") # x is local variable, y the global\n"
"           println(\"z: $z\") # errors as z has not been assigned yet but is local\n"
"       end\n"
"x: 1, y: -1\n"
"ERROR: UndefVarError: z not defined\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:358
msgid ""
"The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has "
"been introduced. Therefore it makes sense to write something like `let x = x` since the two `x` variables are distinct and have separate "
"storage.  Here is an example where the behavior of `let` is needed:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:359
#, no-wrap
msgid ""
"julia> Fs = Vector{Any}(undef, 2); i = 1;\n"
"\n"
"julia> while i <= 2\n"
"           Fs[i] = ()->i\n"
"           global i += 1\n"
"       end\n"
"\n"
"julia> Fs[1]()\n"
"3\n"
"\n"
"julia> Fs[2]()\n"
"3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:377
msgid ""
"Here we create and store two closures that return variable `i`. However, it is always the same variable `i`, so the two closures behave "
"identically. We can use `let` to create a new binding for `i`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:378
#, no-wrap
msgid ""
"julia> Fs = Vector{Any}(undef, 2); i = 1;\n"
"\n"
"julia> while i <= 2\n"
"           let i = i\n"
"               Fs[i] = ()->i\n"
"           end\n"
"           global i += 1\n"
"       end\n"
"\n"
"julia> Fs[1]()\n"
"1\n"
"\n"
"julia> Fs[2]()\n"
"2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:397
msgid ""
"Since the `begin` construct does not introduce a new scope, it can be useful to use a zero-argument `let` to just introduce a new scope "
"block without creating any new bindings:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:398
#, no-wrap
msgid ""
"julia> let\n"
"           local x = 1\n"
"           let\n"
"               local x = 2\n"
"           end\n"
"           x\n"
"       end\n"
"1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:411
msgid "Since `let` introduces a new scope block, the inner local `x` is a different variable than the outer local `x`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/variables-and-scoping.md:412
#, no-wrap
msgid "For Loops and Comprehensions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:417
msgid ""
"`for` loops, `while` loops, and [Comprehensions](@ref) have the following behavior: any new variables introduced in their body scopes are "
"freshly allocated for each loop iteration, as if the loop body were surrounded by a `let` block:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:418
#, no-wrap
msgid ""
"julia> Fs = Vector{Any}(undef, 2);\n"
"\n"
"julia> for j = 1:2\n"
"           Fs[j] = ()->j\n"
"       end\n"
"\n"
"julia> Fs[1]()\n"
"1\n"
"\n"
"julia> Fs[2]()\n"
"2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:433
msgid "A `for` loop or comprehension iteration variable is always a new variable:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/variables-and-scoping.md:434
#, no-wrap
msgid "julia-repl enable_doctest_when_deprecation_warning_is_removed"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:434
#, no-wrap
msgid ""
"julia> function f()\n"
"           i = 0\n"
"           for i = 1:3\n"
"           end\n"
"           return i\n"
"       end;\n"
"\n"
"julia> f()\n"
"0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:448
msgid ""
"However, it is occasionally useful to reuse an existing local variable as the iteration variable.  This can be done conveniently by adding "
"the keyword `outer`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:449
#, no-wrap
msgid ""
"julia> function f()\n"
"           i = 0\n"
"           for outer i = 1:3\n"
"           end\n"
"           return i\n"
"       end;\n"
"\n"
"julia> f()\n"
"3\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/variables-and-scoping.md:461 ext/julia/doc/src/stdlib/Dates.md:843
#, no-wrap
msgid "Constants"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:465
msgid ""
"A common use of variables is giving names to specific, unchanging values. Such variables are only assigned once. This intent can be conveyed "
"to the compiler using the [`const`](@ref) keyword:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:466
#, no-wrap
msgid ""
"julia> const e  = 2.71828182845904523536;\n"
"\n"
"julia> const pi = 3.14159265358979323846;\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:473
msgid "Multiple variables can be declared in a single `const` statement:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:473
#, no-wrap
msgid ""
"julia> const a, b = 1, 2\n"
"(1, 2)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:482
msgid ""
"The `const` declaration should only be used in global scope on globals.  It is difficult for the compiler to optimize code involving global "
"variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a `const` "
"declaration solves this performance problem."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:486
msgid ""
"Local constants are quite different. The compiler is able to determine automatically when a local variable is constant, so local constant "
"declarations are not necessary, and in fact are currently not supported."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:489
msgid "Special top-level assignments, such as those performed by the `function` and `struct` keywords, are constant by default."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:493
msgid ""
"Note that `const` only affects the variable binding; the variable may be bound to a mutable object (such as an array), and that object may "
"still be modified. Additionally when one tries to assign a value to a variable that is declared constant the following scenarios are "
"possible:"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/variables-and-scoping.md:495
msgid "if a new value has a different type than the type of the constant then an error is thrown:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:495
#, no-wrap
msgid ""
"julia> const x = 1.0\n"
"1.0\n"
"\n"
"julia> x = 1\n"
"ERROR: invalid redefinition of constant x\n"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/variables-and-scoping.md:503
msgid "if a new value has the same type as the constant then a warning is printed:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:503
#, no-wrap
msgid ""
"julia> const y = 1.0\n"
"1.0\n"
"\n"
"julia> y = 2.0\n"
"WARNING: redefining constant y\n"
"2.0\n"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/variables-and-scoping.md:512
msgid "if an assignment would not result in the change of variable value no message is given:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:512
#, no-wrap
msgid ""
"julia> const z = 100\n"
"100\n"
"\n"
"julia> z = 100\n"
"100\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:520
msgid "The last rule applies for immutable objects even if the variable binding would change, e.g.:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:520
#, no-wrap
msgid ""
"julia> const s1 = \"1\"\n"
"\"1\"\n"
"\n"
"julia> s2 = \"1\"\n"
"\"1\"\n"
"\n"
"julia> pointer.([s1, s2], 1)\n"
"2-element Array{Ptr{UInt8},1}:\n"
" Ptr{UInt8} @0x00000000132c9638\n"
" Ptr{UInt8} @0x0000000013dd3d18\n"
"\n"
"julia> s1 = s2\n"
"\"1\"\n"
"\n"
"julia> pointer.([s1, s2], 1)\n"
"2-element Array{Ptr{UInt8},1}:\n"
" Ptr{UInt8} @0x0000000013dd3d18\n"
" Ptr{UInt8} @0x0000000013dd3d18\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:541
msgid "However, for mutable objects the warning is printed as expected:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:541
#, no-wrap
msgid ""
"julia> const a = [1]\n"
"1-element Array{Int64,1}:\n"
" 1\n"
"\n"
"julia> a = [1]\n"
"WARNING: redefining constant a\n"
"1-element Array{Int64,1}:\n"
" 1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:558
msgid ""
"Note that although sometimes possible, changing the value of a `const` variable is strongly discouraged, and is intended only for "
"convenience during interactive use.  Changing constants can cause various problems or unexpected behaviors.  For instance, if a method "
"references a constant and is already compiled before the constant is changed then it might keep using the old value:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/variables-and-scoping.md:558
#, no-wrap
msgid ""
"julia> const x = 1\n"
"1\n"
"\n"
"julia> f() = x\n"
"f (generic function with 1 method)\n"
"\n"
"julia> f()\n"
"1\n"
"\n"
"julia> x = 2\n"
"WARNING: redefining constant x\n"
"2\n"
"\n"
"julia> f()\n"
"1\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/handling-operating-system-variation.md:1
#, no-wrap
msgid "Handling Operating System Variation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/handling-operating-system-variation.md:8
msgid ""
"When writing cross-platform applications or libraries, it is often necessary to allow for differences between operating systems. The "
"variable `Sys.KERNEL` can be used to handle such cases. There are several functions in the `Sys` module intended to make this easier, such "
"as `isunix`, `islinux`, `isapple`, `isbsd`, `isfreebsd`, and `iswindows`. These may be used as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/handling-operating-system-variation.md:9
#, no-wrap
msgid ""
"if Sys.iswindows()\n"
"    windows_specific_thing(a)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/handling-operating-system-variation.md:18
msgid ""
"Note that `islinux`, `isapple`, and `isfreebsd` are mutually exclusive subsets of `isunix`.  Additionally, there is a macro `@static` which "
"makes it possible to use these functions to conditionally hide invalid code, as demonstrated in the following examples."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/handling-operating-system-variation.md:20
msgid "Simple blocks:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/handling-operating-system-variation.md:21
#, no-wrap
msgid "ccall((@static Sys.iswindows() ? :_fopen : :fopen), ...)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/handling-operating-system-variation.md:26
msgid "Complex blocks:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/handling-operating-system-variation.md:27
#, no-wrap
msgid ""
"@static if Sys.islinux()\n"
"    linux_specific_thing(a)\n"
"else\n"
"    generic_thing(a)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/handling-operating-system-variation.md:37
msgid ""
"When chaining conditionals (including `if`/`elseif`/`end`), the `@static` must be repeated for each level (parentheses optional, but "
"recommended for readability):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/handling-operating-system-variation.md:38
#, no-wrap
msgid "@static Sys.iswindows() ? :a : (@static Sys.isapple() ? :b : :c)\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/variables.md:1
#, no-wrap
msgid "Variables"
msgstr "å¤æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:5
msgid ""
"A variable, in Julia, is a name associated (or bound) to a value. It's useful when you want to store a value (that you obtained after some "
"math, for example) for later use. For example:"
msgstr ""
"Julia ã®å¤æ°ã¯ãå¤ã«é¢é£ä»ãããã (ã¾ãã¯ãã¤ã³ã) ååã§ããããã¯ãå¾ã§ä½¿ç¨ããããã«(ãã¨ãã°ãããã¤ãã®è¨ç®ã®å¾ã«åå¾ããå¤)ãæ ¼ç´ãã"
"å ´åã«ä¾¿å©ã§ããä¾ãã°ï¼"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:6
#, no-wrap
msgid ""
"# Assign the value 10 to the variable x\n"
"julia> x = 10\n"
"10\n"
"\n"
"# Doing math with x's value\n"
"julia> x + 1\n"
"11\n"
"\n"
"# Reassign x's value\n"
"julia> x = 1 + 1\n"
"2\n"
"\n"
"# You can assign values of other types, like strings of text\n"
"julia> x = \"Hello World!\"\n"
"\"Hello World!\"\n"
msgstr ""
"# Assign the value 10 to the variable x\n"
"julia> x = 10\n"
"10\n"
"\n"
"# Doing math with x's value\n"
"julia> x + 1\n"
"11\n"
"\n"
"# Reassign x's value\n"
"julia> x = 1 + 1\n"
"2\n"
"\n"
"# You can assign values of other types, like strings of text\n"
"julia> x = \"Hello World!\"\n"
"\"Hello World!\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:27
msgid ""
"Julia provides an extremely flexible system for naming variables. Variable names are case-sensitive, and have no semantic meaning (that is, "
"the language will not treat variables differently based on their names)."
msgstr ""
"Julia ã¯ãå¤æ°ã®å½åã·ã¹ãã ã¯éå¸¸ã«æè»ã§ããå¤æ°åã¯å¤§æå­ã¨å°æå­ãåºå¥ããæå³è«çãªåºå¥ã¯ããã¾ãã (ã¤ã¾ããã¤ããããååã®éããã£ã¦"
"Julia ãå¤æ°ã®æ±ããããããã¨ã¯æãã¾ãã)ã"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:28
#, no-wrap
msgid ""
"julia> x = 1.0\n"
"1.0\n"
"\n"
"julia> y = -3\n"
"-3\n"
"\n"
"julia> Z = \"My string\"\n"
"\"My string\"\n"
"\n"
"julia> customary_phrase = \"Hello world!\"\n"
"\"Hello world!\"\n"
"\n"
"julia> UniversalDeclarationOfHumanRightsStart = \"äººäººçèèªç±ï¼å¨å°ä¸¥åæå©ä¸ä¸å¾å¹³ç­ã\"\n"
"\"äººäººçèèªç±ï¼å¨å°ä¸¥åæå©ä¸ä¸å¾å¹³ç­ã\"\n"
msgstr ""
"julia> x = 1.0\n"
"1.0\n"
"\n"
"julia> y = -3\n"
"-3\n"
"\n"
"julia> Z = \"My string\"\n"
"\"My string\"\n"
"\n"
"julia> customary_phrase = \"Hello world!\"\n"
"\"Hello world!\"\n"
"\n"
"julia> UniversalDeclarationOfHumanRightsStart = \"äººäººçèèªç±ï¼å¨å°ä¸¥åæå©ä¸ä¸å¾å¹³ç­ã\"\n"
"\"äººäººçèèªç±ï¼å¨å°ä¸¥åæå©ä¸ä¸å¾å¹³ç­ã\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:46
msgid "Unicode names (in UTF-8 encoding) are allowed:"
msgstr "ã¦ãã³ã¼ã (UTF-8 ã¨ã³ã³ã¼ãã£ã³ã°) ããã¡ããå½åãå¯è½ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:47
#, no-wrap
msgid ""
"julia> Î´ = 0.00001\n"
"1.0e-5\n"
"\n"
"julia> ìëíì¸ì = \"Hello\"\n"
"\"Hello\"\n"
msgstr ""
"julia> Î´ = 0.00001\n"
"1.0e-5\n"
"\n"
"julia> ìëíì¸ì = \"Hello\"\n"
"\"Hello\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:61
msgid ""
"In the Julia REPL and several other Julia editing environments, you can type many Unicode math symbols by typing the backslashed LaTeX "
"symbol name followed by tab. For example, the variable name `Î´` can be entered by typing `\\delta`-*tab*, or even `Î±Ìâ` by `\\alpha`-*tab*-`"
"\\hat`- *tab*-`\\_2`-*tab*. (If you find a symbol somewhere, e.g. in someone else's code, that you don't know how to type, the REPL help "
"will tell you: just type `?` and then paste the symbol.)"
msgstr ""
"Julia REPL ããã³ãã®ä»ã®ããã¤ãã® Julia ç·¨éç°å¢ã§ã¯ãããã¯ã¹ã©ãã·ã¥è¨å·ä»ãã® LaTeX ã·ã³ãã«åãå¥åãã¦ããã®å¾ã«ã¿ããå¥åãã¦ãå¤ã"
"ã® Unicode æ°å­¦è¨å·ãå¥åã§ãã¾ãããã¨ãã°ãå¤æ°å `Î´` ã¯`\\delta`-*tab*ã§å¥åã§ãã¾ããã`Î±Ìâ` ã¯ `\alpha`-*tab*-`\\hat`- *tab*-`\\_2`-*tab*"
"ã§å¥åãããã¨ãã§ãã¾ãã(ããä¾ãã°èª°ãã®ã³ã¼ããªã©ã§ãã©ã®ããã«å¥åããã°ãããããããªãã·ã³ãã«ãè¦ã¤ããå ´åã«ã¯ãREPL ã®ãã«ãæ©è½ã"
"æãã¦ããã¾ã: `?`ãæ¼ããå¾ã«ããã®ã·ã³ãã«ããã¼ã¹ããã°ããã®ã§ããï¼"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:64
msgid ""
"Julia will even let you redefine built-in constants and functions if needed (although this is not recommended to avoid potential confusions):"
msgstr "Julia ã§ã¯ãå¿è¦ã«å¿ãã¦çµã¿è¾¼ã¿ã®å®æ°ã¨é¢æ°ãåå®ç¾©ãããã¨ãã§ãã¾ã (ãã ããæ··ä¹±ã®åã«ãªãããé¿ãããã¨ããå§ããã¾ã):"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:65
#, no-wrap
msgid ""
"julia> pi = 3\n"
"3\n"
"\n"
"julia> pi\n"
"3\n"
"\n"
"julia> sqrt = 4\n"
"4\n"
msgstr ""
"julia> pi = 3\n"
"3\n"
"\n"
"julia> pi\n"
"3\n"
"\n"
"julia> sqrt = 4\n"
"4\n"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:78
msgid "However, if you try to redefine a built-in constant or function already in use, Julia will give you an error:"
msgstr "ãã ããæ¢ã«ä½¿ç¨ä¸­ã®çµã¿è¾¼ã¿å®æ°ã¾ãã¯é¢æ°ãåå®ç¾©ãããã¨ããã¨ãJulia ã«ãã£ã¦ã¨ã©ã¼ãçºçãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:79
#, no-wrap
msgid ""
"julia> pi\n"
"Ï = 3.1415926535897...\n"
"\n"
"julia> pi = 3\n"
"ERROR: cannot assign a value to variable MathConstants.pi from module Main\n"
"\n"
"julia> sqrt(100)\n"
"10.0\n"
"\n"
"julia> sqrt = 4\n"
"ERROR: cannot assign a value to variable Base.sqrt from module Main\n"
msgstr ""
"julia> pi\n"
"Ï = 3.1415926535897...\n"
"\n"
"julia> pi = 3\n"
"ERROR: cannot assign a value to variable MathConstants.pi from module Main\n"
"\n"
"julia> sqrt(100)\n"
"10.0\n"
"\n"
"julia> sqrt = 4\n"
"ERROR: cannot assign a value to variable Base.sqrt from module Main\n"

#. type: Title ##
#: ext/julia/doc/src/manual/variables.md:93
#, no-wrap
msgid "Allowed Variable Names"
msgstr "å©ç¨å¯è½ãªå¤æ°å"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:102
msgid ""
"Variable names must begin with a letter (A-Z or a-z), underscore, or a subset of Unicode code points greater than 00A0; in particular, "
"[Unicode character categories](http://www.fileformat.info/info/unicode/category/index.htm)  Lu/Ll/Lt/Lm/Lo/Nl (letters), Sc/So (currency and "
"other symbols), and a few other letter-like characters (e.g. a subset of the Sm math symbols) are allowed. Subsequent characters may also "
"include ! and digits (0-9 and other characters in categories Nd/No), as well as other Unicode code points: diacritics and other modifying "
"marks (categories Mn/Mc/Me/Sk), some punctuation connectors (category Pc), primes, and a few other characters."
msgstr ""
"å¤æ°åã¯ãæå­ (A ãã Z ã¾ãã¯ a-z)ãã¢ã³ãã¼ã¹ã³ã¢ãã¦ãã³ã¼ãã®ä¸é¨ã§ãç¬¦å·ä½ç½®ã 00A0 ããå¤§ãããã®ãã®ããããã§å§ã¾ãå¿è¦ãããã¾ãã"
"ç¹ã«[Unicode æå­ã«ãã´ãª](http://www.fileformat.info/info/unicode/category/index.htm) Lu/Ll/Lt/Lm/Lo/Nl (æå­)ãSc/So (éè²¨ããã³ãã®ä»ã®è¨"
"å·)ãããã³ããã¤ãã®ä»ã®æå­ (Sm æ°å­¦è¨å·ã®ãµãã»ãããªã©)ãå©ç¨ã§ãã¾ããäºæå­ç®ä»¥éã¯ ,`!`ããã³æ°å­ (0 ãã 9 ããã³ã«ãã´ãª Nd/No ã®ä»"
"ã®æå­) ã ãã§ãªããä»ã®ç¬¦å·ä½ç½®ã®ã¦ãã³ã¼ãã§ã¯çºé³è¨å·ããã³ãã®ä»ã®ä¿®é£¾è¨å·(ã«ãã´ãª Mn/Mc/Me/Sk)ãä¸é¨ã®å¥èª­ç¹ã³ãã¯ã¿ (ã«ãã´ãª Pc)ãã"
"ã©ã¤ã ããã³ãã®ä»ã®ããã¤ãã®æå­ãå©ç¨å¯è½ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:109
msgid ""
"Operators like `+` are also valid identifiers, but are parsed specially. In some contexts, operators can be used just like variables; for "
"example `(+)` refers to the addition function, and `(+) = f` will reassign it. Most of the Unicode infix operators (in category Sm), such as "
"`â`, are parsed as infix operators and are available for user-defined methods (e.g. you can use `const â = kron` to define `â` as an infix "
"Kronecker product).  Operators can also be suffixed with modifying marks, primes, and sub/superscripts, e.g. `+Ìââ³` is parsed as an infix "
"operator with the same precedence as `+`."
msgstr ""
"`+` ã®ãããªæ¼ç®å­ãæå¹ãªè­å¥å­ã§ãããæ§æè§£æã®ããæ¹ãç¹æ®ã§ããæ¼ç®å­ã¯å¤æ°ã¨ããªãããã«æ±ããããã¨ãããã¾ãããã¨ãã°ã`(+)` ã¯å ç®"
"é¢æ°ãè¡¨ãã¾ããã`(+) = f` ã®ããã«ä»£å¥ãã§ãã¾ããUnicode ã®äºé æ¼ç®å­ (ã«ãã´ãª Sm) ã®ã»ã¨ãã©ã¯ãäºé æ¼ç®å­ã¨ãã¦è§£æãããã¦ã¼ã¶ã¼å®ç¾©ã®"
"ã¡ã½ããã§ä½¿ç¨ã§ãã¾ã (ãã¨ãã°ã`const â= kron` ãä½¿ç¨ãã¦`â` ãä¸­ç½®è¨æ³ã®ã¯ã­ããã«ã¼ç©ã¨ãã¦å®ç¾©ã§ãã¾ã)ã æ¼ç®å­ã¯ãä¿®é£¾è¨å·ããã©ã¤"
"ã ãããã³ä¸ä»ã»ä¸ä»æå­ãã¤ãããã¨ãã§ãã¾ãã(ä¾: `+Ìââ³`ã¯`+` ã¨åãåªåé ä½ãæã¤äºé æ¼ç®å­ã¨ãã¦è§£æããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:111
msgid "The only explicitly disallowed names for variables are the names of built-in statements:"
msgstr "æç¤ºçã«ç¦æ­¢ããã¦ããå¤æ°åã¯ãçµã¿è¾¼ã¿ã®äºç´èªã ãã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:112
#, no-wrap
msgid ""
"julia> else = false\n"
"ERROR: syntax: unexpected \"else\"\n"
"\n"
"julia> try = \"No\"\n"
"ERROR: syntax: unexpected \"=\"\n"
msgstr ""
"julia> else = false\n"
"ERROR: syntax: unexpected \"else\"\n"
"\n"
"julia> try = \"No\"\n"
"ERROR: syntax: unexpected \"=\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:126
msgid ""
"Some Unicode characters are considered to be equivalent in identifiers.  Different ways of entering Unicode combining characters (e.g., "
"accents)  are treated as equivalent (specifically, Julia identifiers are NFC-normalized).  The Unicode characters `É` (U+025B: Latin small "
"letter open e)  and `Âµ` (U+00B5: micro sign) are treated as equivalent to the corresponding Greek letters, because the former are easily "
"accessible via some input methods."
msgstr ""
"ä¸é¨ã® Unicode æå­ã¯ãè­å¥å­ã¨ãã¦åç­ã«æ±ããã¾ãã æå­ãçµã¿åããã Unicode ã®çµåæå­ (ã¢ã¯ã»ã³ããªã©) ã«å¯¾ããç°ãªãå¥åæ¹æ³ã¯åç­ã®ã"
"ã®ã¨ãã¦æ±ããã¾ã (å·ä½çã«ã¯ãJulia è­å¥å­ã¯ NFC æ­£è¦åããã¾ã)ã Unicode æå­ `Îµ` (U+025B: ã©ãã³èªã®å°æå­ãªã¼ãã³ e) ã¨ `Î¼` (U+00B5: ã"
"ã¯ã­è¨å·) ã¯å¯¾å¿ããã®ãªã·ã£æå­ã¨åç­ã¨ãã¦æ±ããã¾ããåèãããã¤ãã®å¥åæ¹æ³ãä»ãã¦ç°¡åã«ã¢ã¯ã»ã¹ã§ããããã§ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/variables.md:127
#, no-wrap
msgid "Stylistic Conventions"
msgstr "æä½ä¸ã®æ£ç¿"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:131
msgid "While Julia imposes few restrictions on valid names, it has become useful to adopt the following conventions:"
msgstr "Juliaã®å¦¥å½ãªååã«ã¯ã»ã¨ãã©å¶éãããã¾ããããä»¥ä¸ã®ãããªæ£ç¿ã«å¾ãã¨å½¹ç«ã¤ã§ããã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/variables.md:141
msgid "Names of variables are in lower case."
msgstr "å¤æ°åãå°æå­ã«ããã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/variables.md:141
msgid ""
"Word separation can be indicated by underscores (`'_'`), but use of underscores is discouraged unless the name would be hard to read "
"otherwise."
msgstr "èªå¥ã®åºåãã¨ãã«ãã¢ã³ãã¼ã¹ã³ã¢(`_`)ãå©ç¨ãã¦ããããããããã¢ã³ãã¼ã¹ã³ã¢ç¡ãã§èª­ã¿ã¥ãããªãã®ã§ãªããã°ãä½¿ããªãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/variables.md:141
msgid "Names of `Type`s and `Module`s begin with a capital letter and word separation is shown with upper camel case instead of underscores."
msgstr ""
"`å` ã¨ `ã¢ã¸ã¥ã¼ã«` ã®ååã¯å¤§æå­ã§å§ããåèªã®åºåãã¯ã¢ã³ãã¼ã¹ã³ã¢ã®ä»£ããã«ã¢ããã¼ã­ã£ã¡ã«ã±ã¼ã¹(åèªã®æåã®æå­ãå¤§æå­ã«ãã)ãä½¿"
"ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/variables.md:141
msgid "Names of `function`s and `macro`s are in lower case, without underscores."
msgstr "`é¢æ°` ã¨ `ãã¯ã­` ã®ååã¯ãã¢ã³ãã¼ã¹ã³ã¢ãªãã®å°æå­ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/variables.md:141
msgid ""
"Functions that write to their arguments have names that end in `!`. These are sometimes called \"mutating\" or \"in-place\" functions "
"because they are intended to produce changes in their arguments after the function is called, not just return a value."
msgstr ""
"å¼æ°ã®åå®¹ãå¤æ´ããé¢æ°ã¯ååã®æå¾ã«!ãã¤ããããããã£ãé¢æ°ã¯ææããå¤ç°(mutating)ããä¸æ¸ã(in-place)ãé¢æ°ã¨ãã°ãã¾ãã ããã¯ï¼é¢æ°"
"ãå¼ã³åºãããå¾ãåã«å¤ãè¿ãã ãã§ãªããå¼æ°ã«å¯¾ãã¦å¤åãèµ·ãããã¨ããããã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/variables.md:142
msgid "For more information about stylistic conventions, see the [Style Guide](@ref)."
msgstr "æä½è¦ç´ã®è©³ç´°ã«ã¤ãã¦ã¯ããã¹ã¿ã¤ã«ã¬ã¤ãã(@ref)ããè¦§ãã ããã"

#. type: Title #
#: ext/julia/doc/src/manual/control-flow.md:1
#, no-wrap
msgid "Control Flow"
msgstr "[å¶å¾¡ãã­ã¼](@id Control-Flow)"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:4
msgid "Julia provides a variety of control flow constructs:"
msgstr "Julia ã¯ããã¾ãã¾ãªå¶å¾¡ãã­ã¼æ§é ãæä¾ãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/control-flow.md:11
msgid "[Compound Expressions](@ref man-compound-expressions): `begin` and `(;)`."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/control-flow.md:11
msgid "[Conditional Evaluation](@ref man-conditional-evaluation): `if`-`elseif`-`else` and `?:` (ternary operator)."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/control-flow.md:11
msgid "[Short-Circuit Evaluation](@ref): `&&`, `||` and chained comparisons."
msgstr "[ç­çµ¡è©ä¾¡](@ref short-circuit-evaluation): `&&`, `||` ã¨æ¯è¼ã®é£éã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/control-flow.md:11
msgid "[Repeated Evaluation: Loops](@ref man-loops): `while` and `for`."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/control-flow.md:11
msgid "[Exception Handling](@ref): `try`-`catch`, [`error`](@ref) and [`throw`](@ref)."
msgstr "[ä¾å¤å¦ç](@ref exception-handlin): `try`-`catch`ã[`error`](@ref)ã¨[`throw`](@ref)ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/control-flow.md:11
msgid "[Tasks (aka Coroutines)](@ref man-tasks): [`yieldto`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:17
msgid ""
"The first five control flow mechanisms are standard to high-level programming languages. [`Task`](@ref)s are not so standard: they provide "
"non-local control flow, making it possible to switch between temporarily-suspended computations. This is a powerful construct: both "
"exception handling and cooperative multitasking are implemented in Julia using tasks. Everyday programming requires no direct usage of "
"tasks, but certain problems can be solved much more easily by using tasks."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/control-flow.md:18
#, no-wrap
msgid "[Compound Expressions](@id man-compound-expressions)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:24
msgid ""
"Sometimes it is convenient to have a single expression which evaluates several subexpressions in order, returning the value of the last "
"subexpression as its value. There are two Julia constructs that accomplish this: `begin` blocks and `(;)` chains. The value of both compound "
"expression constructs is that of the last subexpression. Here's an example of a `begin` block:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:25
#, no-wrap
msgid ""
"julia> z = begin\n"
"           x = 1\n"
"           y = 2\n"
"           x + y\n"
"       end\n"
"3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:36
msgid ""
"Since these are fairly small, simple expressions, they could easily be placed onto a single line, which is where the `(;)` chain syntax "
"comes in handy:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:37
#, no-wrap
msgid ""
"julia> z = (x = 1; y = 2; x + y)\n"
"3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:45
msgid ""
"This syntax is particularly useful with the terse single-line function definition form introduced in [Functions](@ref). Although it is "
"typical, there is no requirement that `begin` blocks be multiline or that `(;)` chains be single-line:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:46
#, no-wrap
msgid ""
"julia> begin x = 1; y = 2; x + y end\n"
"3\n"
"\n"
"julia> (x = 1;\n"
"        y = 2;\n"
"        x + y)\n"
"3\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/control-flow.md:56
#, no-wrap
msgid "[Conditional Evaluation](@id man-conditional-evaluation)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:60
msgid ""
"Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the "
"anatomy of the `if`-`elseif`-`else` conditional syntax:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:61
#, no-wrap
msgid ""
"if x < y\n"
"    println(\"x is less than y\")\n"
"elseif x > y\n"
"    println(\"x is greater than y\")\n"
"else\n"
"    println(\"x is equal to y\")\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:74
#, no-wrap
msgid ""
"If the condition expression `x < y` is `true`, then the corresponding block is evaluated; otherwise\n"
"the condition expression `x > y` is evaluated, and if it is `true`, the corresponding block is\n"
"evaluated; if neither expression is true, the `else` block is evaluated. Here it is in action:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:75
#, no-wrap
msgid ""
"julia> function test(x, y)\n"
"           if x < y\n"
"               println(\"x is less than y\")\n"
"           elseif x > y\n"
"               println(\"x is greater than y\")\n"
"           else\n"
"               println(\"x is equal to y\")\n"
"           end\n"
"       end\n"
"test (generic function with 1 method)\n"
"\n"
"julia> test(1, 2)\n"
"x is less than y\n"
"\n"
"julia> test(2, 1)\n"
"x is greater than y\n"
"\n"
"julia> test(1, 1)\n"
"x is equal to y\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:101
msgid ""
"The `elseif` and `else` blocks are optional, and as many `elseif` blocks as desired can be used.  The condition expressions in the `if`-"
"`elseif`-`else` construct are evaluated until the first one evaluates to `true`, after which the associated block is evaluated, and no "
"further condition expressions or blocks are evaluated."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:105
msgid ""
"`if` blocks are \"leaky\", i.e. they do not introduce a local scope. This means that new variables defined inside the `if` clauses can be "
"used after the `if` block, even if they weren't defined before. So, we could have defined the `test` function above as"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:106
#, no-wrap
msgid ""
"julia> function test(x,y)\n"
"           if x < y\n"
"               relation = \"less than\"\n"
"           elseif x == y\n"
"               relation = \"equal to\"\n"
"           else\n"
"               relation = \"greater than\"\n"
"           end\n"
"           println(\"x is \", relation, \" y.\")\n"
"       end\n"
"test (generic function with 1 method)\n"
"\n"
"julia> test(2, 1)\n"
"x is greater than y.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:126
msgid ""
"The variable `relation` is declared inside the `if` block, but used outside. However, when depending on this behavior, make sure all "
"possible code paths define a value for the variable. The following change to the above function results in a runtime error"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/control-flow.md:127 ext/julia/doc/src/manual/control-flow.md:318 ext/julia/doc/src/manual/control-flow.md:613
#, no-wrap
msgid "jldoctest; filter = r\"Stacktrace:(\\n \\[[0-9]+\\].*)*\""
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:127
#, no-wrap
msgid ""
"julia> function test(x,y)\n"
"           if x < y\n"
"               relation = \"less than\"\n"
"           elseif x == y\n"
"               relation = \"equal to\"\n"
"           end\n"
"           println(\"x is \", relation, \" y.\")\n"
"       end\n"
"test (generic function with 1 method)\n"
"\n"
"julia> test(1,2)\n"
"x is less than y.\n"
"\n"
"julia> test(2,1)\n"
"ERROR: UndefVarError: relation not defined\n"
"Stacktrace:\n"
" [1] test(::Int64, ::Int64) at ./none:7\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:150
msgid ""
"`if` blocks also return a value, which may seem unintuitive to users coming from many other languages.  This value is simply the return "
"value of the last executed statement in the branch that was chosen, so"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:151
#, no-wrap
msgid ""
"julia> x = 3\n"
"3\n"
"\n"
"julia> if x > 0\n"
"           \"positive!\"\n"
"       else\n"
"           \"negative...\"\n"
"       end\n"
"\"positive!\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:165
msgid ""
"Note that very short conditional statements (one-liners) are frequently expressed using Short-Circuit Evaluation in Julia, as outlined in "
"the next section."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:168
msgid ""
"Unlike C, MATLAB, Perl, Python, and Ruby -- but like Java, and a few other stricter, typed languages -- it is an error if the value of a "
"conditional expression is anything but `true` or `false`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:169
#, no-wrap
msgid ""
"julia> if 1\n"
"           println(\"true\")\n"
"       end\n"
"ERROR: TypeError: non-boolean (Int64) used in boolean context\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:178
msgid "This error indicates that the conditional was of the wrong type: [`Int64`](@ref) rather than the required [`Bool`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:183
msgid ""
"The so-called \"ternary operator\", `?:`, is closely related to the `if`-`elseif`-`else` syntax, but is used where a conditional choice "
"between single expression values is required, as opposed to conditional execution of longer blocks of code. It gets its name from being the "
"only operator in most languages taking three operands:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:184
#, no-wrap
msgid "a ? b : c\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:193
msgid ""
"The expression `a`, before the `?`, is a condition expression, and the ternary operation evaluates the expression `b`, before the `:`, if "
"the condition `a` is `true` or the expression `c`, after the `:`, if it is `false`. Note that the spaces around `?` and `:` are mandatory: "
"an expression like `a?b:c` is not a valid ternary expression (but a newline is acceptable after both the `?` and the `:`)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:198
msgid ""
"The easiest way to understand this behavior is to see an example. In the previous example, the `println` call is shared by all three "
"branches: the only real choice is which literal string to print. This could be written more concisely using the ternary operator. For the "
"sake of clarity, let's try a two-way version first:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:199
#, no-wrap
msgid ""
"julia> x = 1; y = 2;\n"
"\n"
"julia> println(x < y ? \"less than\" : \"not less than\")\n"
"less than\n"
"\n"
"julia> x = 1; y = 0;\n"
"\n"
"julia> println(x < y ? \"less than\" : \"not less than\")\n"
"not less than\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:214
#, no-wrap
msgid ""
"If the expression `x < y` is true, the entire ternary operator expression evaluates to the string\n"
"`\"less than\"` and otherwise it evaluates to the string `\"not less than\"`. The original three-way\n"
"example requires chaining multiple uses of the ternary operator together:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:215
#, no-wrap
msgid ""
"julia> test(x, y) = println(x < y ? \"x is less than y\"    :\n"
"                            x > y ? \"x is greater than y\" : \"x is equal to y\")\n"
"test (generic function with 1 method)\n"
"\n"
"julia> test(1, 2)\n"
"x is less than y\n"
"\n"
"julia> test(2, 1)\n"
"x is greater than y\n"
"\n"
"julia> test(1, 1)\n"
"x is equal to y\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:231
msgid "To facilitate chaining, the operator associates from right to left."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:234
msgid ""
"It is significant that like `if`-`elseif`-`else`, the expressions before and after the `:` are only evaluated if the condition expression "
"evaluates to `true` or `false`, respectively:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:235
#, no-wrap
msgid ""
"julia> v(x) = (println(x); x)\n"
"v (generic function with 1 method)\n"
"\n"
"julia> 1 < 2 ? v(\"yes\") : v(\"no\")\n"
"yes\n"
"\"yes\"\n"
"\n"
"julia> 1 > 2 ? v(\"yes\") : v(\"no\")\n"
"no\n"
"\"no\"\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/control-flow.md:248
#, no-wrap
msgid "Short-Circuit Evaluation"
msgstr "[ç­çµ¡è©ä¾¡](@id short-circuit-evaluation)"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:255
msgid ""
"Short-circuit evaluation is quite similar to conditional evaluation. The behavior is found in most imperative programming languages having "
"the `&&` and `||` boolean operators: in a series of boolean expressions connected by these operators, only the minimum number of expressions "
"are evaluated as are necessary to determine the final boolean value of the entire chain. Explicitly, this means that:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/control-flow.md:258
msgid "In the expression `a && b`, the subexpression `b` is only evaluated if `a` evaluates to `true`."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/control-flow.md:258
msgid "In the expression `a || b`, the subexpression `b` is only evaluated if `a` evaluates to `false`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:263
msgid ""
"The reasoning is that `a && b` must be `false` if `a` is `false`, regardless of the value of `b`, and likewise, the value of `a || b` must "
"be true if `a` is `true`, regardless of the value of `b`. Both `&&` and `||` associate to the right, but `&&` has higher precedence than `||"
"` does.  It's easy to experiment with this behavior:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/control-flow.md:264 ext/julia/doc/src/manual/control-flow.md:344
#, no-wrap
msgid "jldoctest tandf"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:264
#, no-wrap
msgid ""
"julia> t(x) = (println(x); true)\n"
"t (generic function with 1 method)\n"
"\n"
"julia> f(x) = (println(x); false)\n"
"f (generic function with 1 method)\n"
"\n"
"julia> t(1) && t(2)\n"
"1\n"
"2\n"
"true\n"
"\n"
"julia> t(1) && f(2)\n"
"1\n"
"2\n"
"false\n"
"\n"
"julia> f(1) && t(2)\n"
"1\n"
"false\n"
"\n"
"julia> f(1) && f(2)\n"
"1\n"
"false\n"
"\n"
"julia> t(1) || t(2)\n"
"1\n"
"true\n"
"\n"
"julia> t(1) || f(2)\n"
"1\n"
"true\n"
"\n"
"julia> f(1) || t(2)\n"
"1\n"
"2\n"
"true\n"
"\n"
"julia> f(1) || f(2)\n"
"1\n"
"2\n"
"false\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:310
msgid "You can easily experiment in the same way with the associativity and precedence of various combinations of `&&` and `||` operators."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:315
#, no-wrap
msgid ""
"This behavior is frequently used in Julia to form an alternative to very short `if` statements.\n"
"Instead of `if <cond> <statement> end`, one can write `<cond> && <statement>` (which could be\n"
"read as: <cond> *and then* <statement>). Similarly, instead of `if ! <cond> <statement> end`,\n"
"one can write `<cond> || <statement>` (which could be read as: <cond> *or else* <statement>).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:317
msgid "For example, a recursive factorial routine could be defined like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:318
#, no-wrap
msgid ""
"julia> function fact(n::Int)\n"
"           n >= 0 || error(\"n must be non-negative\")\n"
"           n == 0 && return 1\n"
"           n * fact(n-1)\n"
"       end\n"
"fact (generic function with 1 method)\n"
"\n"
"julia> fact(5)\n"
"120\n"
"\n"
"julia> fact(0)\n"
"1\n"
"\n"
"julia> fact(-1)\n"
"ERROR: n must be non-negative\n"
"Stacktrace:\n"
" [1] error at ./error.jl:33 [inlined]\n"
" [2] fact(::Int64) at ./none:2\n"
" [3] top-level scope\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:343
msgid ""
"Boolean operations *without* short-circuit evaluation can be done with the bitwise boolean operators introduced in [Mathematical Operations "
"and Elementary Functions](@ref): `&` and `|`. These are normal functions, which happen to support infix operator syntax, but always evaluate "
"their arguments:"
msgstr ""
"ãã¼ã«æ¼ç® *ãªã* ã®ç­çµ¡è©ä¾¡ã¯ã[ç®è¡æ¼ç®ã¨åç­é¢æ°](@ref mathematical-operations-and-elementary-functions)ã§å°å¥ããããããæ¯ã®ãã¼ã«æ¼ç®å­"
"ã§è¡ããã¨ãã§ãã¾ã: `&`ã¨`|`ã§ãããããã¯éå¸¸ã®é¢æ°ã§ãäºé æ¼ç®å­æ§æããµãã¼ããã¾ãããå¸¸ã«å¼æ°ãè©ä¾¡ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:344
#, no-wrap
msgid ""
"julia> f(1) & t(2)\n"
"1\n"
"2\n"
"false\n"
"\n"
"julia> t(1) | t(2)\n"
"1\n"
"2\n"
"true\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:359
msgid ""
"Just like condition expressions used in `if`, `elseif` or the ternary operator, the operands of `&&` or `||` must be boolean values (`true` "
"or `false`). Using a non-boolean value anywhere except for the last entry in a conditional chain is an error:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:360
#, no-wrap
msgid ""
"julia> 1 && true\n"
"ERROR: TypeError: non-boolean (Int64) used in boolean context\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:367
msgid ""
"On the other hand, any type of expression can be used at the end of a conditional chain. It will be evaluated and returned depending on the "
"preceding conditionals:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:368
#, no-wrap
msgid ""
"julia> true && (x = (1, 2, 3))\n"
"(1, 2, 3)\n"
"\n"
"julia> false && (x = (1, 2, 3))\n"
"false\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/control-flow.md:376
#, no-wrap
msgid "[Repeated Evaluation: Loops](@id man-loops)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:380
msgid ""
"There are two constructs for repeated evaluation of expressions: the `while` loop and the `for` loop. Here is an example of a `while` loop:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:381
#, no-wrap
msgid ""
"julia> i = 1;\n"
"\n"
"julia> while i <= 5\n"
"           println(i)\n"
"           global i += 1\n"
"       end\n"
"1\n"
"2\n"
"3\n"
"4\n"
"5\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:398
#, no-wrap
msgid ""
"The `while` loop evaluates the condition expression (`i <= 5` in this case), and as long it remains\n"
"`true`, keeps also evaluating the body of the `while` loop. If the condition expression is `false`\n"
"when the `while` loop is first reached, the body is never evaluated.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:402
msgid ""
"The `for` loop makes common repeated evaluation idioms easier to write. Since counting up and down like the above `while` loop does is so "
"common, it can be expressed more concisely with a `for` loop:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:403
#, no-wrap
msgid ""
"julia> for i = 1:5\n"
"           println(i)\n"
"       end\n"
"1\n"
"2\n"
"3\n"
"4\n"
"5\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:421
msgid ""
"Here the `1:5` is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. The `for` loop iterates through these values, "
"assigning each one in turn to the variable `i`. One rather important distinction between the previous `while` loop form and the `for` loop "
"form is the scope during which the variable is visible. If the variable `i` has not been introduced in another scope, in the `for` loop "
"form, it is visible only inside of the `for` loop, and not outside/afterwards. You'll either need a new interactive session instance or a "
"different variable name to test this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:422
#, no-wrap
msgid ""
"julia> for j = 1:5\n"
"           println(j)\n"
"       end\n"
"1\n"
"2\n"
"3\n"
"4\n"
"5\n"
"\n"
"julia> j\n"
"ERROR: UndefVarError: j not defined\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:438
msgid "See [Scope of Variables](@ref scope-of-variables) for a detailed explanation of variable scope and how it works in Julia."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:442
msgid ""
"In general, the `for` loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword `in` or "
"`â` is typically used instead of `=`, since it makes the code read more clearly:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:443
#, no-wrap
msgid ""
"julia> for i in [1,4,0]\n"
"           println(i)\n"
"       end\n"
"1\n"
"4\n"
"0\n"
"\n"
"julia> for s â [\"foo\",\"bar\",\"baz\"]\n"
"           println(s)\n"
"       end\n"
"foo\n"
"bar\n"
"baz\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:461
msgid ""
"Various types of iterable containers will be introduced and discussed in later sections of the manual (see, e.g., [Multi-dimensional Arrays]"
"(@ref man-multi-dim-arrays))."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:465
msgid ""
"It is sometimes convenient to terminate the repetition of a `while` before the test condition is falsified or stop iterating in a `for` loop "
"before the end of the iterable object is reached.  This can be accomplished with the `break` keyword:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:466
#, no-wrap
msgid ""
"julia> i = 1;\n"
"\n"
"julia> while true\n"
"           println(i)\n"
"           if i >= 5\n"
"               break\n"
"           end\n"
"           global i += 1\n"
"       end\n"
"1\n"
"2\n"
"3\n"
"4\n"
"5\n"
"\n"
"julia> for j = 1:1000\n"
"           println(j)\n"
"           if j >= 5\n"
"               break\n"
"           end\n"
"       end\n"
"1\n"
"2\n"
"3\n"
"4\n"
"5\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:496
msgid ""
"Without the `break` keyword, the above `while` loop would never terminate on its own, and the `for` loop would iterate up to 1000. These "
"loops are both exited early by using `break`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:499
msgid ""
"In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The `continue` keyword "
"accomplishes this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:500
#, no-wrap
msgid ""
"julia> for i = 1:10\n"
"           if i % 3 != 0\n"
"               continue\n"
"           end\n"
"           println(i)\n"
"       end\n"
"3\n"
"6\n"
"9\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:516
msgid ""
"This is a somewhat contrived example since we could produce the same behavior more clearly by negating the condition and placing the "
"`println` call inside the `if` block. In realistic usage there is more code to be evaluated after the `continue`, and often there are "
"multiple points from which one calls `continue`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:519
msgid "Multiple nested `for` loops can be combined into a single outer loop, forming the cartesian product of its iterables:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:520
#, no-wrap
msgid ""
"julia> for i = 1:2, j = 3:4\n"
"           println((i, j))\n"
"       end\n"
"(1, 3)\n"
"(1, 4)\n"
"(2, 3)\n"
"(2, 4)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:535
msgid ""
"With this syntax, iterables may still refer to outer loop variables; e.g. `for i = 1:n, j = 1:i` is valid.  However a `break` statement "
"inside such a loop exits the entire nest of loops, not just the inner one.  Both variables (`i` and `j`) are set to their current iteration "
"values each time the inner loop runs.  Therefore, assignments to `i` will not be visible to subsequent iterations:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:536
#, no-wrap
msgid ""
"julia> for i = 1:2, j = 3:4\n"
"           println((i, j))\n"
"           i = 0\n"
"       end\n"
"(1, 3)\n"
"(1, 4)\n"
"(2, 3)\n"
"(2, 4)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:549
msgid ""
"If this example were rewritten to use a `for` keyword for each variable, then the output would be different: the second and fourth values "
"would contain `0`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/control-flow.md:550
#, no-wrap
msgid "Exception Handling"
msgstr "[ä¾å¤å¦ç](@id exception-handlin)"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:556
msgid ""
"When an unexpected condition occurs, a function may be unable to return a reasonable value to its caller. In such cases, it may be best for "
"the exceptional condition to either terminate the program while printing a diagnostic error message, or if the programmer has provided code "
"to handle such exceptional circumstances then allow that code to take the appropriate action."
msgstr ""
"äºæ³å¤ã®ç¶æ³ãçºçããã¨ãé¢æ°ãå¼ã³åºãåã«å¦¥å½ãªå¤ãè¿ããã¨ãã§ããªããã¨ãããã¾ãããã®ãããªäºæã«å¯¾ããæåã®ç­ã¯ããã­ã°ã©ã ãçµäºã"
"ãããã¨ããããã¾ããããç¶æ³å ±åã®ã¨ã©ã¼ã¡ãã»ã¼ã¸ãåºåãããã¨ããããã¾ããããããã¯ããããã­ã°ã©ãããã®ãããªä¾å¤çãªç¶æ³ãä¸æãæ±"
"ãã³ã¼ããæä¾ãã¦ãããªãã°ããã®ã³ã¼ããé©åãªã¢ã¯ã·ã§ã³ãå®è¡ã§ããããã«ããã®ãããããããã¾ããã"

#. type: Title ###
#: ext/julia/doc/src/manual/control-flow.md:557
#, no-wrap
msgid "Built-in `Exception`s"
msgstr "çµã¿è¾¼ã¿ã®ä¾å¤"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:561
msgid ""
"`Exception`s are thrown when an unexpected condition has occurred. The built-in `Exception`s listed below all interrupt the normal flow of "
"control."
msgstr "ä¾å¤ã¯ãäºæããªãç¶æãçºçããã¨ãã«ã¹ã­ã¼ããã¾ããä»¥ä¸ã«ç¤ºãçµã¿è¾¼ã¿ã®`Exception`ã¯ãéå¸¸ã®å¶å¾¡ãã­ã¼ãä¸­æ­ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:589
#, no-wrap
msgid ""
"| `Exception`                   |\n"
"|:----------------------------- |\n"
"| [`ArgumentError`](@ref)       |\n"
"| [`BoundsError`](@ref)         |\n"
"| [`CompositeException`](@ref)  |\n"
"| [`DimensionMismatch`](@ref)   |\n"
"| [`DivideError`](@ref)         |\n"
"| [`DomainError`](@ref)         |\n"
"| [`EOFError`](@ref)            |\n"
"| [`ErrorException`](@ref)      |\n"
"| [`InexactError`](@ref)        |\n"
"| [`InitError`](@ref)           |\n"
"| [`InterruptException`](@ref)  |\n"
"| `InvalidStateException`       |\n"
"| [`KeyError`](@ref)            |\n"
"| [`LoadError`](@ref)           |\n"
"| [`OutOfMemoryError`](@ref)    |\n"
"| [`ReadOnlyMemoryError`](@ref) |\n"
"| [`RemoteException`](@ref)     |\n"
"| [`MethodError`](@ref)         |\n"
"| [`OverflowError`](@ref)       |\n"
"| [`Meta.ParseError`](@ref)     |\n"
"| [`SystemError`](@ref)         |\n"
"| [`TypeError`](@ref)           |\n"
"| [`UndefRefError`](@ref)       |\n"
"| [`UndefVarError`](@ref)       |\n"
"| [`StringIndexError`](@ref)    |\n"
msgstr ""
"| `Exception`                   |\n"
"|:----------------------------- |\n"
"| [`ArgumentError`](@ref)       |\n"
"| [`BoundsError`](@ref)         |\n"
"| [`CompositeException`](@ref)  |\n"
"| [`DimensionMismatch`](@ref)   |\n"
"| [`DivideError`](@ref)         |\n"
"| [`DomainError`](@ref)         |\n"
"| [`EOFError`](@ref)            |\n"
"| [`ErrorException`](@ref)      |\n"
"| [`InexactError`](@ref)        |\n"
"| [`InitError`](@ref)           |\n"
"| [`InterruptException`](@ref)  |\n"
"| `InvalidStateException`       |\n"
"| [`KeyError`](@ref)            |\n"
"| [`LoadError`](@ref)           |\n"
"| [`OutOfMemoryError`](@ref)    |\n"
"| [`ReadOnlyMemoryError`](@ref) |\n"
"| [`RemoteException`](@ref)     |\n"
"| [`MethodError`](@ref)         |\n"
"| [`OverflowError`](@ref)       |\n"
"| [`Meta.ParseError`](@ref)     |\n"
"| [`SystemError`](@ref)         |\n"
"| [`TypeError`](@ref)           |\n"
"| [`UndefRefError`](@ref)       |\n"
"| [`UndefVarError`](@ref)       |\n"
"| [`StringIndexError`](@ref)    |\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:592
msgid "For example, the [`sqrt`](@ref) function throws a [`DomainError`](@ref) if applied to a negative real value:"
msgstr "ãã¨ãã°ã[`sqrt`](@ref) é¢æ°ã¯ãè² ã®å®å¤ã«é©ç¨ãããå ´åã« [`DomainError`](@ref) ãã¹ã­ã¼ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:593
#, no-wrap
msgid ""
"julia> sqrt(-1)\n"
"ERROR: DomainError with -1.0:\n"
"sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n"
"Stacktrace:\n"
"[...]\n"
msgstr ""
"julia> sqrt(-1)\n"
"ERROR: DomainError with -1.0:\n"
"sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n"
"Stacktrace:\n"
"[...]\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:602
msgid "You may define your own exceptions in the following way:"
msgstr "ç¬èªã®ä¾å¤ã¯ãæ¬¡ã®æ¹æ³ã§å®ç¾©ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:603
#, no-wrap
msgid "julia> struct MyCustomException <: Exception end\n"
msgstr "julia> struct MyCustomException <: Exception end\n"

#. type: Title ###
#: ext/julia/doc/src/manual/control-flow.md:607
#, no-wrap
msgid "The [`throw`](@ref) function"
msgstr "[`throw`](@ref) é¢æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:612
msgid ""
"Exceptions can be created explicitly with [`throw`](@ref). For example, a function defined only for nonnegative numbers could be written to "
"[`throw`](@ref) a [`DomainError`](@ref) if the argument is negative:"
msgstr ""
"ä¾å¤ã¯ [`throw`](@ref)ãä½¿ç¨ãã¦æç¤ºçã«çºçããããã¾ãããã¨ãã°ãè² ä»¥å¤ã®æ°å¤ã«å¯¾ãã¦ã®ã¿å®ç¾©ãããé¢æ°ã¯ãå¼æ°ãè² ã®å ´åã¯[`DomainError`]"
"(@ref)ã[`throw`](@ref) ããããã«ã³ã¼ãã£ã³ã°ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:613
#, no-wrap
msgid ""
"julia> f(x) = x>=0 ? exp(-x) : throw(DomainError(x, \"argument must be nonnegative\"))\n"
"f (generic function with 1 method)\n"
"\n"
"julia> f(1)\n"
"0.36787944117144233\n"
"\n"
"julia> f(-1)\n"
"ERROR: DomainError with -1:\n"
"argument must be nonnegative\n"
"Stacktrace:\n"
" [1] f(::Int64) at ./none:1\n"
msgstr ""
"julia> f(x) = x>=0 ? exp(-x) : throw(DomainError(x, \"argument must be nonnegative\"))\n"
"f (generic function with 1 method)\n"
"\n"
"julia> f(1)\n"
"0.36787944117144233\n"
"\n"
"julia> f(-1)\n"
"ERROR: DomainError with -1:\n"
"argument must be nonnegative\n"
"Stacktrace:\n"
" [1] f(::Int64) at ./none:1\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:629
msgid ""
"Note that [`DomainError`](@ref) without parentheses is not an exception, but a type of exception.  It needs to be called to obtain an "
"`Exception` object:"
msgstr ""
"[`DomainError`](@ref) ã¯æ¬å¼§ãã¤ããªãå ´åã¯ãä¾å¤ã§ã¯ãªããä¾å¤ã®åãè¡¨ãç¹ã«æ³¨æãã¦ãã ããã ä¾å¤ãªãã¸ã§ã¯ããåå¾ããã«ã¯ãæ¬å¼§ãä»ãã¦"
"é¢æ°å¼ã³åºããè¡ãå¿è¦ãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:630
#, no-wrap
msgid ""
"julia> typeof(DomainError(nothing)) <: Exception\n"
"true\n"
"\n"
"julia> typeof(DomainError) <: Exception\n"
"false\n"
msgstr ""
"julia> typeof(DomainError(nothing)) <: Exception\n"
"true\n"
"\n"
"julia> typeof(DomainError) <: Exception\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:639
msgid "Additionally, some exception types take one or more arguments that are used for error reporting:"
msgstr "ããã«ãä¸é¨ã®ä¾å¤ã®åã¯ãã¨ã©ã¼å ±åã«ä½¿ç¨ããã 1 ã¤ä»¥ä¸ã®å¼æ°ãåãåãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:640
#, no-wrap
msgid ""
"julia> throw(UndefVarError(:x))\n"
"ERROR: UndefVarError: x not defined\n"
msgstr ""
"julia> throw(UndefVarError(:x))\n"
"ERROR: UndefVarError: x not defined\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:647
msgid "This mechanism can be implemented easily by custom exception types following the way [`UndefVarError`](@ref)  is written:"
msgstr "ç¬èªã®ä¾å¤åãæ¸ãã¦ã[`UndefVarError`](@ref) ã¨åæ§ã®ä»çµã¿ãå®è£ããã®ã¯ç°¡åã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:648
#, no-wrap
msgid ""
"julia> struct MyUndefVarError <: Exception\n"
"           var::Symbol\n"
"       end\n"
"\n"
"julia> Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, \" not defined\")\n"
msgstr ""
"julia> struct MyUndefVarError <: Exception\n"
"           var::Symbol\n"
"       end\n"
"\n"
"julia> Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, \" not defined\")\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:659
#, no-wrap
msgid ""
"!!! note\n"
"    When writing an error message, it is preferred to make the first word lowercase. For example,\n"
"    `size(A) == size(B) || throw(DimensionMismatch(\"size of A not equal to size of B\"))`\n"
msgstr ""
"!!! note\n"
"    ã¨ã©ã¼ã¡ãã»ã¼ã¸ãæ¸ãã¨ãã«ã¯ãæåã®æå­ãå°æå­ã§æ¸ããã¨ãå¥½ã¾ããã§ããä¾ãã°ã\n"
"`size(A) == size(B) || throw(DimensionMismatch(\"size of A not equal to size of B\"))`\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:661
#, no-wrap
msgid "    is preferred over\n"
msgstr "    ã®æ¹ã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:663
#, no-wrap
msgid "    `size(A) == size(B) || throw(DimensionMismatch(\"Size of A not equal to size of B\"))`.\n"
msgstr ""
"    `size(A) == size(B) || throw(DimensionMismatch(\"Size of A not equal to size of B\"))`.\n"
"ããå¥½ã¾ããã§ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:666
#, no-wrap
msgid ""
"    However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument\n"
"    to a function is a capital letter: `size(A,1) == size(B,2) || throw(DimensionMismatch(\"A has first dimension...\"))`.\n"
msgstr ""
"    ãã ããæå³çã«æåã®æå­ãå¤§æå­ã«ãããã¨ãããã¾ããä¾ãã°ãé¢æ°ã®å¼æ°ãå¤§æå­ã®å ´å:\n"
"    `size(A,1) == size(B,2) || throw(DimensionMismatch(\"A has first dimension...\"))`.\n"

#. type: Title ##
#: ext/julia/doc/src/manual/control-flow.md:667 ext/julia/doc/src/base/base.md:325
#, no-wrap
msgid "Errors"
msgstr "ã¨ã©ã¼"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:671
msgid "The [`error`](@ref) function is used to produce an [`ErrorException`](@ref) that interrupts the normal flow of control."
msgstr "[`error`](@ref) é¢æ°ã¯ãå¶å¾¡ã®éå¸¸ã®æµããä¸­æ­ãã [`ErrorException`](@ref) ãçæããããã«ä½¿ç¨ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:675
msgid ""
"Suppose we want to stop execution immediately if the square root of a negative number is taken.  To do this, we can define a fussy version "
"of the [`sqrt`](@ref) function that raises an error if its argument is negative:"
msgstr ""
"è² ã®æ°ã®å¹³æ¹æ ¹ãåå¾ãããå ´åãããã«å®è¡ãåæ­¢ããã¨ãã¾ãã ãããè¡ãã«ã¯ãå¼æ°ãè² ã®å ´åã«ã¨ã©ã¼ãçºçãããå°ãããããã¼ã¸ã§ã³ã® "
"[`sqrt`](@ref) é¢æ°ãå®ç¾©ã§ãã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/control-flow.md:676 ext/julia/doc/src/manual/control-flow.md:695
#, no-wrap
msgid "jldoctest fussy_sqrt; filter = r\"Stacktrace:(\\n \\[[0-9]+\\].*)*\""
msgstr "jldoctest fussy_sqrt; filter = r\"Stacktrace:(\\n \\[[0-9]+\\].*)*\""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:676
#, no-wrap
msgid ""
"julia> fussy_sqrt(x) = x >= 0 ? sqrt(x) : error(\"negative x not allowed\")\n"
"fussy_sqrt (generic function with 1 method)\n"
"\n"
"julia> fussy_sqrt(2)\n"
"1.4142135623730951\n"
"\n"
"julia> fussy_sqrt(-1)\n"
"ERROR: negative x not allowed\n"
"Stacktrace:\n"
" [1] error at ./error.jl:33 [inlined]\n"
" [2] fussy_sqrt(::Int64) at ./none:1\n"
" [3] top-level scope\n"
msgstr ""
"julia> fussy_sqrt(x) = x >= 0 ? sqrt(x) : error(\"negative x not allowed\")\n"
"fussy_sqrt (generic function with 1 method)\n"
"\n"
"julia> fussy_sqrt(2)\n"
"1.4142135623730951\n"
"\n"
"julia> fussy_sqrt(-1)\n"
"ERROR: negative x not allowed\n"
"Stacktrace:\n"
" [1] error at ./error.jl:33 [inlined]\n"
" [2] fussy_sqrt(::Int64) at ./none:1\n"
" [3] top-level scope\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:694
msgid ""
"If `fussy_sqrt` is called with a negative value from another function, instead of trying to continue execution of the calling function, it "
"returns immediately, displaying the error message in the interactive session:"
msgstr ""
"`fussy_sqrt` ãå¥ã®é¢æ°ããè² ã®å¤ã§å¼ã³åºãããå ´åã(`fussy_sqrt` ä»¥éã®)é¢æ°å¼ã³åºãç¶ãããã¨ãããããã«returnãã¦ãå¯¾è©±åã»ãã·ã§ã³ã«ã¨"
"ã©ã¼ ã¡ãã»ã¼ã¸ãè¡¨ç¤ºãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:695
#, no-wrap
msgid ""
"julia> function verbose_fussy_sqrt(x)\n"
"           println(\"before fussy_sqrt\")\n"
"           r = fussy_sqrt(x)\n"
"           println(\"after fussy_sqrt\")\n"
"           return r\n"
"       end\n"
"verbose_fussy_sqrt (generic function with 1 method)\n"
"\n"
"julia> verbose_fussy_sqrt(2)\n"
"before fussy_sqrt\n"
"after fussy_sqrt\n"
"1.4142135623730951\n"
"\n"
"julia> verbose_fussy_sqrt(-1)\n"
"before fussy_sqrt\n"
"ERROR: negative x not allowed\n"
"Stacktrace:\n"
" [1] error at ./error.jl:33 [inlined]\n"
" [2] fussy_sqrt at ./none:1 [inlined]\n"
" [3] verbose_fussy_sqrt(::Int64) at ./none:3\n"
" [4] top-level scope\n"
msgstr ""
"julia> function verbose_fussy_sqrt(x)\n"
"           println(\"before fussy_sqrt\")\n"
"           r = fussy_sqrt(x)\n"
"           println(\"after fussy_sqrt\")\n"
"           return r\n"
"       end\n"
"verbose_fussy_sqrt (generic function with 1 method)\n"
"\n"
"julia> verbose_fussy_sqrt(2)\n"
"before fussy_sqrt\n"
"after fussy_sqrt\n"
"1.4142135623730951\n"
"\n"
"julia> verbose_fussy_sqrt(-1)\n"
"before fussy_sqrt\n"
"ERROR: negative x not allowed\n"
"Stacktrace:\n"
" [1] error at ./error.jl:33 [inlined]\n"
" [2] fussy_sqrt at ./none:1 [inlined]\n"
" [3] verbose_fussy_sqrt(::Int64) at ./none:3\n"
" [4] top-level scope\n"

#. type: Title ###
#: ext/julia/doc/src/manual/control-flow.md:719
#, no-wrap
msgid "The `try/catch` statement"
msgstr "`try/catch`æ"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:730
msgid ""
"The `try/catch` statement allows for `Exception`s to be tested for, and for the graceful handling of things that may ordinarily break your "
"application. For example, in the below code the function for square root would normally throw an exception. By placing a `try/catch` block "
"around it we can mitigate that here. You may choose how you wish to handle this exception, whether logging it, return a placeholder value or "
"as in the case below where we just printed out a statement. One thing to think about when deciding how to handle unexpected situations is "
"that using a `try/catch` block is much slower than using conditional branching to handle those situations.  Below there are more examples of "
"handling exceptions with a `try/catch` block:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:731
#, no-wrap
msgid ""
"julia> try\n"
"           sqrt(\"ten\")\n"
"       catch e\n"
"           println(\"You should have entered a numeric value\")\n"
"       end\n"
"You should have entered a numeric value\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:743
msgid ""
"`try/catch` statements also allow the `Exception` to be saved in a variable. The following contrived example calculates the square root of "
"the second element of `x` if `x` is indexable, otherwise assumes `x` is a real number and returns its square root:"
msgstr ""
"`try/catch` æã§ã¯ãä¾å¤ãå¤æ°ã«ä¿å­ãããã¨ãã§ãã¾ããä»¥ä¸ã®ä¾ã§ã¯ãä¸èªç¶ã§ã¯ããã¾ããã`x` ãã¤ã³ããã¯ã¹å¯è½ãªå ´åã¯ `x` ã® 2 çªç®ã®è¦"
"ç´ ã®å¹³æ¹æ ¹ãè¨ç®ããããä»¥å¤ã®å ´åã¯ `x` ãå®æ°ã§ããã¨ä»®å®ãããã®å¹³æ¹æ ¹ãè¿ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:744
#, no-wrap
msgid ""
"julia> sqrt_second(x) = try\n"
"           sqrt(x[2])\n"
"       catch y\n"
"           if isa(y, DomainError)\n"
"               sqrt(complex(x[2], 0))\n"
"           elseif isa(y, BoundsError)\n"
"               sqrt(x)\n"
"           end\n"
"       end\n"
"sqrt_second (generic function with 1 method)\n"
"\n"
"julia> sqrt_second([1 4])\n"
"2.0\n"
"\n"
"julia> sqrt_second([1 -4])\n"
"0.0 + 2.0im\n"
"\n"
"julia> sqrt_second(9)\n"
"3.0\n"
"\n"
"julia> sqrt_second(-9)\n"
"ERROR: DomainError with -9.0:\n"
"sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n"
"Stacktrace:\n"
"[...]\n"
msgstr ""
"julia> sqrt_second(x) = try\n"
"           sqrt(x[2])\n"
"       catch y\n"
"           if isa(y, DomainError)\n"
"               sqrt(complex(x[2], 0))\n"
"           elseif isa(y, BoundsError)\n"
"               sqrt(x)\n"
"           end\n"
"       end\n"
"sqrt_second (generic function with 1 method)\n"
"\n"
"julia> sqrt_second([1 4])\n"
"2.0\n"
"\n"
"julia> sqrt_second([1 -4])\n"
"0.0 + 2.0im\n"
"\n"
"julia> sqrt_second(9)\n"
"3.0\n"
"\n"
"julia> sqrt_second(-9)\n"
"ERROR: DomainError with -9.0:\n"
"sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n"
"Stacktrace:\n"
"[...]\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:775
msgid ""
"Note that the symbol following `catch` will always be interpreted as a name for the exception, so care is needed when writing `try/catch` "
"expressions on a single line. The following code will *not* work to return the value of `x` in case of an error:"
msgstr ""
"`catch` ã«ç¶ãã·ã³ãã«ã¯å¸¸ã«ä¾å¤ã®ååã¨ãã¦è§£éãããã®ã§ã`try/catch` å¼ã1 è¡ã§è¨è¿°ããå ´åã¯æ³¨æãå¿è¦ã§ããæ¬¡ã®ã³ã¼ãã¯ãã¨ã©ã¼ãçºçã"
"ãå ´åã« `x` ã®å¤ãè¿ãã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:776
#, no-wrap
msgid "try bad() catch x end\n"
msgstr "try bad() catch x end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:781
msgid "Instead, use a semicolon or insert a line break after `catch`:"
msgstr "ä»£ããã«ã`catch` ã®å¾ã«ã»ãã³ã­ã³ãä½¿ç¨ãããæ¹è¡ãæ¿å¥ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:782
#, no-wrap
msgid ""
"try bad() catch; x end\n"
"\n"
"try bad()\n"
"catch\n"
"    x\n"
"end\n"
msgstr ""
"try bad() catch; x end\n"
"\n"
"try bad()\n"
"catch\n"
"    x\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:796
msgid ""
"The power of the `try/catch` construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the "
"stack of calling functions. There are situations where no error has occurred, but the ability to unwind the stack and pass a value to a "
"higher level is desirable. Julia provides the [`rethrow`](@ref), [`backtrace`](@ref), [`catch_backtrace`](@ref)  and [`Base.catch_stack`]"
"(@ref) functions for more advanced error handling."
msgstr ""
"`try/catch`ã®å¨åã¯ãæ·±ããã¹ããããè¨ç®ãããé¢æ°ã³ã¼ã«ã®ã¹ã¿ãã¯ã«ããã¦ã¯ããã«ä¸ã®ã¬ãã«ã«é£ã³è¶ãã¦æ»ããã¨ãã§ããç¹ã«ããã¾ããã¨ã©ã¼"
"ãçºçãã¦ããªãå ´åã§ããã¹ã¿ãã¯ãé£ã³è¶ãã¦æ»ããããä¸ã®éå±¤ã«å¤ãæ¸¡ããæ©è½ã¯æ¬²ããç©ã§ããJuliaã¯ã[`rethrow`](@ref)ã"
"[`backtrace`(@ref)]ã[`catch_backtrace`](@ref)ããã¦[`Base.catch_stack`](@ref)ã¨ãã£ãããé«åº¦ãªã¨ã©ã¼å¦çã®ããã®é¢æ°ãæä¾ãã¾ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/control-flow.md:797
#, no-wrap
msgid "`finally` Clauses"
msgstr "`finally`ç¯"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:804
msgid ""
"In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be "
"done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching "
"its normal end. The `finally` keyword provides a way to run some code when a given block of code exits, regardless of how it exits."
msgstr ""
"ç¶æå¤åãçããã³ã¼ãããã¡ã¤ã«ãªã©ã®ãªã½ã¼ã¹ãä½¿ç¨ããã³ã¼ãã§ã¯ãéå¸¸ãã³ã¼ãã®çµäºæã«å®è¡ããã¹ãã¯ãªã¼ã³ã¢ããä½æ¥­ (ãã¡ã¤ã«ãéãããª"
"ã©) ãããã¾ããä¾å¤ãä½¿ãã¨ãã®ãããªã¿ã¹ã¯ãè¤éã«ãªãå¯è½æ§ãããã¾ããã¨ããã®ããä¾å¤ã«ãã£ã¦ãå¯¾è±¡ã®ã³ã¼ããã­ãã¯ããæ­£å¸¸çµäºå¦çã«è³"
"ãåã«ãå®è¡ãçµäºãããã¾ãå¯è½æ§ãããããã§ãã`finally` ã­ã¼ã¯ã¼ãã¯ãçµäºæ¹æ³ã«é¢ä¿ãªããç¹å®ã®ã³ã¼ã ãã­ãã¯ãçµäºããã¨ãã«ããã¤ãã®"
"ã³ã¼ããå®è¡ããæ¹æ³ãæä¾ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:806
msgid "For example, here is how we can guarantee that an opened file is closed:"
msgstr "ããã§ã¯ãéãããã¡ã¤ã«ãå¿ãéãããã¨ãä¿è¨¼ããã³ã¼ãä¾ãæãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:807
#, no-wrap
msgid ""
"f = open(\"file\")\n"
"try\n"
"    # operate on file f\n"
"finally\n"
"    close(f)\n"
"end\n"
msgstr ""
"f = open(\"file\")\n"
"try\n"
"    # operate on file f\n"
"finally\n"
"    close(f)\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:820
msgid ""
"When control leaves the `try` block (for example due to a `return`, or just finishing normally), `close(f)` will be executed. If the `try` "
"block exits due to an exception, the exception will continue propagating. A `catch` block may be combined with `try` and `finally` as well. "
"In this case the `finally` block will run after `catch` has handled the error."
msgstr ""
"ãã­ã°ã©ã å¶å¾¡ã `try`ãã­ãã¯ãé¢ããæ (ãã¨ãã°`return`ã«ããå ´åãã¾ãã¯æ­£å¸¸çµäºã®å ´åãªã©)ã`close(f)` ãå®è¡ããã¾ãã`try` ãã­ãã¯ã"
"ä¾å¤ã«ãã£ã¦çµäºããå ´åãä¾å¤ã¯å¼ãç¶ãä¼æ­ãã¾ãã`catch`ãã­ãã¯ã¯ã`try`, `finally`ã¨çµã¿åããã¦ãæ§ãã¾ããããã®å ´åã`finally` ãã­ã"
"ã¯ã¯ `catch` ãã¨ã©ã¼ãå¦çããå¾ã«å®è¡ããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/control-flow.md:821
#, no-wrap
msgid "[Tasks (aka Coroutines)](@id man-tasks)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:826
msgid ""
"Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible manner. This feature is sometimes called "
"by other names, such as symmetric coroutines, lightweight threads, cooperative multitasking, or one-shot continuations."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:834
msgid ""
"When a piece of computing work (in practice, executing a particular function) is designated as a [`Task`](@ref), it becomes possible to "
"interrupt it by switching to another [`Task`](@ref).  The original [`Task`](@ref) can later be resumed, at which point it will pick up right "
"where it left off. At first, this may seem similar to a function call. However there are two key differences.  First, switching tasks does "
"not use any space, so any number of task switches can occur without consuming the call stack. Second, switching among tasks can occur in any "
"order, unlike function calls, where the called function must finish executing before control returns to the calling function."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:842
msgid ""
"This kind of control flow can make it much easier to solve certain problems. In some problems, the various pieces of required work are not "
"naturally related by function calls; there is no obvious \"caller\" or \"callee\" among the jobs that need to be done. An example is the "
"producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer "
"cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready "
"to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:846
msgid ""
"Julia provides a [`Channel`](@ref) mechanism for solving this problem.  A [`Channel`](@ref) is a waitable first-in first-out queue which can "
"have multiple tasks reading from and writing to it."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:851
msgid ""
"Let's define a producer task, which produces values via the [`put!`](@ref) call.  To consume values, we need to schedule the producer to run "
"in a new task. A special [`Channel`](@ref)  constructor which accepts a 1-arg function as an argument can be used to run a task bound to a "
"channel.  We can then [`take!`](@ref) values repeatedly from the channel object:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/control-flow.md:852 ext/julia/doc/src/manual/control-flow.md:888
#, no-wrap
msgid "jldoctest producer"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:852
#, no-wrap
msgid ""
"julia> function producer(c::Channel)\n"
"           put!(c, \"start\")\n"
"           for n=1:4\n"
"               put!(c, 2n)\n"
"           end\n"
"           put!(c, \"stop\")\n"
"       end;\n"
"\n"
"julia> chnl = Channel(producer);\n"
"\n"
"julia> take!(chnl)\n"
"\"start\"\n"
"\n"
"julia> take!(chnl)\n"
"2\n"
"\n"
"julia> take!(chnl)\n"
"4\n"
"\n"
"julia> take!(chnl)\n"
"6\n"
"\n"
"julia> take!(chnl)\n"
"8\n"
"\n"
"julia> take!(chnl)\n"
"\"stop\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:884
msgid ""
"One way to think of this behavior is that `producer` was able to return multiple times. Between calls to [`put!`](@ref), the producer's "
"execution is suspended and the consumer has control."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:887
msgid ""
"The returned [`Channel`](@ref) can be used as an iterable object in a `for` loop, in which case the loop variable takes on all the produced "
"values. The loop is terminated when the channel is closed."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:888
#, no-wrap
msgid ""
"julia> for x in Channel(producer)\n"
"           println(x)\n"
"       end\n"
"start\n"
"2\n"
"4\n"
"6\n"
"8\n"
"stop\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:904
msgid ""
"Note that we did not have to explicitly close the channel in the producer. This is because the act of binding a [`Channel`](@ref) to a "
"[`Task`](@ref) associates the open lifetime of a channel with that of the bound task. The channel object is closed automatically when the "
"task terminates. Multiple channels can be bound to a task, and vice-versa."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:909
msgid ""
"While the [`Task`](@ref) constructor expects a 0-argument function, the [`Channel`](@ref)  method which creates a channel bound task expects "
"a function that accepts a single argument of type [`Channel`](@ref). A common pattern is for the producer to be parameterized, in which case "
"a partial function application is needed to create a 0 or 1 argument [anonymous function](@ref man-anonymous-functions)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:911
msgid "For [`Task`](@ref) objects this can be done either directly or by use of a convenience macro:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:912
#, no-wrap
msgid ""
"function mytask(myarg)\n"
"    ...\n"
"end\n"
"\n"
"taskHdl = Task(() -> mytask(7))\n"
"# or, equivalently\n"
"taskHdl = @task mytask(7)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:925
msgid ""
"To orchestrate more advanced work distribution patterns, [`bind`](@ref) and [`schedule`](@ref)  can be used in conjunction with [`Task`]"
"(@ref) and [`Channel`](@ref)  constructors to explicitly link a set of channels with a set of producer/consumer tasks."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:928
msgid ""
"Note that currently Julia tasks are not scheduled to run on separate CPU cores.  True kernel threads are discussed under the topic of "
"[Parallel Computing](@ref)."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/control-flow.md:929
#, no-wrap
msgid "Core task operations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:937
msgid ""
"Let us explore the low level construct [`yieldto`](@ref) to understand how task switching works.  `yieldto(task,value)` suspends the current "
"task, switches to the specified `task`, and causes that task's last [`yieldto`](@ref) call to return the specified `value`. Notice that "
"[`yieldto`](@ref)  is the only operation required to use task-style control flow; instead of calling and returning we are always just "
"switching to a different task. This is why this feature is also called \"symmetric coroutines\"; each task is switched to and from using the "
"same mechanism."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:945
msgid ""
"[`yieldto`](@ref) is powerful, but most uses of tasks do not invoke it directly. Consider why this might be. If you switch away from the "
"current task, you will probably want to switch back to it at some point, but knowing when to switch back, and knowing which task has the "
"responsibility of switching back, can require considerable coordination. For example, [`put!`](@ref) and [`take!`](@ref)  are blocking "
"operations, which, when used in the context of channels maintain state to remember who the consumers are. Not needing to manually keep track "
"of the consuming task is what makes [`put!`](@ref)  easier to use than the low-level [`yieldto`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:947
msgid "In addition to [`yieldto`](@ref), a few other basic functions are needed to use tasks effectively."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/control-flow.md:952
msgid "[`current_task`](@ref) gets a reference to the currently-running task."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/control-flow.md:952
msgid "[`istaskdone`](@ref) queries whether a task has exited."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/control-flow.md:952
msgid "[`istaskstarted`](@ref) queries whether a task has run yet."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/control-flow.md:952
msgid "[`task_local_storage`](@ref) manipulates a key-value store specific to the current task."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/control-flow.md:953
#, no-wrap
msgid "Tasks and events"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:958
msgid ""
"Most task switches occur as a result of waiting for events such as I/O requests, and are performed by a scheduler included in Julia Base. "
"The scheduler maintains a queue of runnable tasks, and executes an event loop that restarts tasks based on external events such as message "
"arrival."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:963
msgid ""
"The basic function for waiting for an event is [`wait`](@ref). Several objects implement [`wait`](@ref); for example, given a `Process` "
"object, [`wait`](@ref) will wait for it to exit. [`wait`](@ref)  is often implicit; for example, a [`wait`](@ref) can happen inside a call "
"to [`read`](@ref)  to wait for data to be available."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:970
msgid ""
"In all of these cases, [`wait`](@ref) ultimately operates on a [`Condition`](@ref) object, which is in charge of queueing and restarting "
"tasks. When a task calls [`wait`](@ref) on a [`Condition`](@ref), the task is marked as non-runnable, added to the condition's queue, and "
"switches to the scheduler.  The scheduler will then pick another task to run, or block waiting for external events. If all goes well, "
"eventually an event handler will call [`notify`](@ref) on the condition, which causes tasks waiting for that condition to become runnable "
"again."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:977
msgid ""
"A task created explicitly by calling [`Task`](@ref) is initially not known to the scheduler. This allows you to manage tasks manually using "
"[`yieldto`](@ref) if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, "
"as you would expect. It is also possible to make the scheduler run a task whenever it can, without necessarily waiting for any events. This "
"is done by calling [`schedule`](@ref), or using the [`@async`](@ref)  macro (see [Parallel Computing](@ref) for more details)."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/control-flow.md:978
#, no-wrap
msgid "Task states"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:982
msgid "Tasks have a `state` field that describes their execution status. A [`Task`](@ref) `state` is one of the following symbols:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/control-flow.md:987
#, no-wrap
msgid ""
"| Symbol      | Meaning                                            |\n"
"|:----------- |:-------------------------------------------------- |\n"
"| `:runnable` | Currently running, or able to run                  |\n"
"| `:done`     | Successfully finished executing                    |\n"
"| `:failed`   | Finished with an uncaught exception                |\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/documentation.md:1
#, no-wrap
msgid "Documentation"
msgstr "[ãã­ã¥ã¡ã³ãã¼ã·ã§ã³](@id Documentation)"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:5
msgid ""
"Julia enables package developers and users to document functions, types and other objects easily via a built-in documentation system since "
"Julia 0.4."
msgstr ""
"ããã±ã¼ã¸éçºèãã¦ã¼ã¶ã¼ã¯ãJulia v0.4 ä»¥éã§çµã¿è¾¼ã¿ã®ãã­ã¥ã¡ã³ãã·ã¹ãã ãä½¿ã£ã¦ãé¢æ°ãåãããã³ãã®ä»ã®ãªãã¸ã§ã¯ãã®ãã­ã¥ã¡ã³ãã¼"
"ã·ã§ã³ãç°¡åã«è¡ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:10
msgid ""
"The basic syntax is simple: any string appearing at the top-level right before an object (function, macro, type or instance) will be "
"interpreted as documenting it (these are called *docstrings*).  Note that no blank lines or comments may intervene between a docstring and "
"the documented object.  Here is a basic example:"
msgstr ""
"åºæ¬çãªæ§æã¯åç´ã§ã: ãªãã¸ã§ã¯ã (é¢æ°ããã¯ã­ãåãã¾ãã¯ã¤ã³ã¹ã¿ã³ã¹)ã®ç´åã»æä¸ä½ã®æå­åãæ¸ãã¨ ãã®æå­åã¯ãã­ã¥ã¡ã³ãã¨è§£éãã"
"ã¾ã (ãããã¯ *docstrings*ã¨å¼ã°ãã¾ã)ã docstring ã¨ãã­ã¥ã¡ã³ãåããããªãã¸ã§ã¯ãã®éã«ãç©ºç½è¡ãã³ã¡ã³ãããªãããã«ãã¦ãã ãããåºæ¬"
"çãªä¾ã¯ä»¥ä¸ã®éãã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:11
#, no-wrap
msgid ""
"\"Tell whether there are too foo items in the array.\"\n"
"foo(xs::Array) = ...\n"
msgstr ""
"\"Tell whether there are too foo items in the array.\"\n"
"foo(xs::Array) = ...\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:20
msgid ""
"Documentation is interpreted as [Markdown](https://en.wikipedia.org/wiki/Markdown), so you can use indentation and code fences to delimit "
"code examples from text. Technically, any object can be associated with any other as metadata; Markdown happens to be the default, but one "
"can construct other string macros and pass them to the `@doc` macro just as well."
msgstr ""
"ãã­ã¥ã¡ã³ãã¼ã·ã§ã³ã¯[Markdown](https://en.wikipedia.org/wiki/Markdown)ã¨ãã¦è§£éããã¾ãããã®ãããã¤ã³ãã³ããã³ã¼ããã§ã³ã¹ãä½¿ã£ã¦ãã"
"ã­ã¹ãã¨ã³ã¼ãä¾ãåãã¦æ¸ããã¨ãã§ãã¾ããæè¡çã«ã¯ãå¨ã¦ã®ãªãã¸ã§ã¯ããã¡ã¿ãã¼ã¿ã¨ãã¦ãå¥ã®ãªãã¸ã§ã¯ãã«é¢é£ä»ãããã¨ãã§ãã¾ããã"
"ãã©ã«ãã§ã¯ããã­ã¥ã¡ã³ãã¯ãã¼ã¯ãã¦ã³ã¨ãã¦è§£éããã¾ãããä»ã®æå­åã®ãã¯ã­ãå®ç¾©ãã¦ã`@doc`ãã¯ã­ã«æ¸¡ãã¦ãã­ã¥ã¡ã³ãã¨ãããã¨ãã§ã"
"ã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:25
#, no-wrap
msgid ""
"!!! note\n"
"    Markdown support is implemented in the `Markdown` standard library\n"
"    and for a full list of supported syntax see the\n"
"    [documentation](@ref Markdown).\n"
msgstr ""
"!!! ã¡ã¢\n"
"    Markdown ãµãã¼ãã¯ `Markdown` æ¨æºã©ã¤ãã©ãªã§å®è£ããã¦ãã¾ãããµãã¼ãããã¦ããæ§æä¸è¦§ã¯ [Markdownã®ãã­ã¥ã¡ã³ã](@ref Markdown) ãåç§ãã¦ãã ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:27
msgid "Here is a more complex example, still using Markdown:"
msgstr "Markdownãä½¿ç¨ãããããè¤éãªä¾ãæ¬¡ã«ç¤ºãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:28
#, no-wrap
msgid ""
"\"\"\"\n"
"    bar(x[, y])\n"
"\n"
"Compute the Bar index between `x` and `y`. If `y` is missing, compute\n"
"the Bar index between all pairs of columns of `x`.\n"
"\n"
"# Examples\n"
"```julia-repl\n"
"julia> bar([1, 2], [1, 2])\n"
"1\n"
"```\n"
"\"\"\"\n"
"function bar(x, y) ...\n"
msgstr ""
"\"\"\"\n"
"    bar(x[, y])\n"
"\n"
"Compute the Bar index between `x` and `y`. If `y` is missing, compute\n"
"the Bar index between all pairs of columns of `x`.\n"
"\n"
"# Examples\n"
"```julia-repl\n"
"julia> bar([1, 2], [1, 2])\n"
"1\n"
"```\n"
"\"\"\"\n"
"function bar(x, y) ...\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:45
msgid "As in the example above, we recommend following some simple conventions when writing documentation:"
msgstr "ä¸è¨ã®ä¾ã¨åæ§ã«ããã­ã¥ã¡ã³ããä½æããéã«ã¯ãããã¤ãã®ç°¡åãªè¦åã«å¾ããã¨ããå§ããã¾ã:"

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/documentation.md:48
msgid "Always show the signature of a function at the top of the documentation, with a four-space indent so that it is printed as Julia code."
msgstr "ãã­ã¥ã¡ã³ãã®ä¸é¨ã«é¢æ°ã®ã·ã°ããã£ãå¸¸ã«è¡¨ç¤ºããã¹ãã¼ã¹4ã¤ã®ã¤ã³ãã³ããä½¿ç¨ãã¦ãJulia ã³ã¼ãã¨ãã¦å°å·ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:61
#, no-wrap
msgid ""
"   This can be identical to the signature present in the Julia code (like `mean(x::AbstractArray)`),\n"
"   or a simplified form. Optional arguments should be represented with their default values (i.e.\n"
"   `f(x, y=1)`) when possible, following the actual Julia syntax. Optional arguments which do not\n"
"   have a default value should be put in brackets (i.e. `f(x[, y])` and `f(x[, y[, z]])`). An alternative\n"
"   solution is to use several lines: one without optional arguments, the other(s) with them. This\n"
"   solution can also be used to document several related methods of a given function. When a function\n"
"   accepts many keyword arguments, only include a `<keyword arguments>` placeholder in the signature\n"
"   (i.e. `f(x; <keyword arguments>)`), and give the complete list under an `# Arguments` section\n"
"   (see point 4 below).\n"
"2. Include a single one-line sentence describing what the function does or what the object represents\n"
"   after the simplified signature block. If needed, provide more details in a second paragraph, after\n"
"   a blank line.\n"
msgstr ""
"   ããã§ã®è¡¨è¨ã¯ãJuliaã³ã¼ãã®ã·ã°ããã£ã¨å¨ãåãã«ãã¦ãããã§ãã (`mean(x::AbstractArray)`ãªã©ã®ããã«)ãç°¡ç¥è¡¨è¨ã¨ãã¦ããããããã\n"
"   ãªãã·ã§ã³å¼æ°ã¯ãå¯è½ãªå ´åã¯å®éã®Juliaã®æ§æã«å¾ã£ã¦ãããã©ã«ãå¤ãç¤ºãã¹ãã§ã(ã¤ã¾ã`f(x, y=1)`ã®ããã«)ã\n"
"   ããã©ã«ãå¤ãæããªããªãã·ã§ã³å¼æ°ã¯ãæ¬å¼§åã«å¥ãã¦ãã ãã (ã¤ã¾ãã`f(x[,y])`ã `f(x[,y[,z]]`ã®ããã«)ã\n"
"   ãã®ä»ã®æ¹æ³ã¨ãã¦ã¯ãè¤æ°è¡ãä½¿ç¨ãããã¨ã§ã: 1è¡ãéå¸¸å¼æ°ã«ãã»ãã®è¡ããªãã·ã§ã³å¼æ°ã«ä½¿ããã¨ãããã¨ã§ãã\n"
"   ãã®æ¹æ³ã¯ãããé¢æ°ã«å¯¾ãã¦ãããã¤ãã®é¢é£ããã¡ã½ããã®ãã­ã¥ã¡ã³ãã¼ã·ã§ã³ã«ãä½¿ç¨ã§ãã¾ãã\n"
"   é¢æ°ãå¤ãã®ã­ã¼ã¯ã¼ãå¼æ°ãæã¤æã«ã¯ã`<keyword arguments>`ãã¬ã¼ã¹ãã«ãã®ã¿ãã·ã°ããã£ã«å«ãã·ã°ããã£ã«å«ãã¦\n"
"   (ããªãã¡`f(x;<keyword arguments>)`)ãå®å¨ãªå¼æ°ãªã¹ãã `#Arguments` ã»ã¯ã·ã§ã³ä»¥ä¸ã«æ¸ãã¦ãã ãã(ãã¤ã³ã4åç§)ã\n"
"2. ç°¡ç¥åãããã·ã°ããã£ã®å¾ã«ã¯ãé¢æ°ã®æ¯ãèããããªãã¸ã§ã¯ããä½èã§ãããã1è¡ã§èª¬æãã¾ããã\n"
"   å¿è¦ã«å¿ãã¦ã1è¡ç©ºãããã¨ã®æ®µè½ã§ããè©³ç´°ã«ã¤ãã¦è¨è¿°ãã¦ãã ããã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:68
#, no-wrap
msgid ""
"   The one-line sentence should use the imperative form (\"Do this\", \"Return that\") instead of the\n"
"   third person (do not write \"Returns the length...\") when documenting functions. It should end\n"
"   with a period. If the meaning of a function cannot be summarized easily, splitting it into separate\n"
"   composable parts could be beneficial (this should not be taken as an absolute requirement for\n"
"   every single case though).\n"
"3. Do not repeat yourself.\n"
msgstr ""
"   é¢æ°ã®1 è¡èª¬æã¯ã3åç¾ã®sãä»ããã«ãå½ä»¤å½¢ã§æ¸ãã¦ãã ãããæå¾ã«ããªãªããä»ãã¾ãã\n"
"   é¢æ°ã®æå³ãç°¡åã«è¦ç´ã§ããªãå ´åã¯ãé¢æ°ã®æ§æè¦ç´ ãåå²ããã¨ããããããã¾ãã(çµ¶å¯¾çãªè¦ä»¶ã§ã¯ãªããããã¾ã§ä¸ä¾ã§ã)ã\n"
"3. ç¹°ãè¿ããé¿ãã¾ããã(DRY)ã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:73
#, no-wrap
msgid ""
"   Since the function name is given by the signature, there is no need to start the documentation\n"
"   with \"The function `bar`...\": go straight to the point. Similarly, if the signature specifies\n"
"   the types of the arguments, mentioning them in the description is redundant.\n"
"4. Only provide an argument list when really necessary.\n"
msgstr ""
"   é¢æ°åã¯ã·ã°ããã£ã«ãã£ã¦ä¸ããããã®ã§ããé¢æ°`bar`ã¯..ãã¨ããæè¨ã§ãã­ã¥ã¡ã³ããéå§ããå¿è¦ã¯ããã¾ãã:\n"
"   ã¯ããããè¦ç¹ãæ¸ãã¦ãã ãããåæ§ã«ãã·ã°ããã£ã§å¼æ°ã®åãæå®ããã¦ãããªãã°ãèª¬æã§åã«è¨åãããã¨ã¯åé·ã§ãã\n"
"4. æ¬å½ã«å¿è¦ãªå ´åã«ã®ã¿å¼æ°ãªã¹ããæ¸ãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:80
#, no-wrap
msgid ""
"   For simple functions, it is often clearer to mention the role of the arguments directly in the\n"
"   description of the function's purpose. An argument list would only repeat information already\n"
"   provided elsewhere. However, providing an argument list can be a good idea for complex functions\n"
"   with many arguments (in particular keyword arguments). In that case, insert it after the general\n"
"   description of the function, under an `# Arguments` header, with one `-` bullet for each argument.\n"
"   The list should mention the types and default values (if any) of the arguments:\n"
msgstr ""
"   åç´ãªé¢æ°ã®å ´åãé¢æ°ã®ç®çãèª¬æããéã«ç´æ¥ å¼æ°ã®å½¹å²ã«è¨åããæ¹ãæããã«ãããããããã¨ãããã¾ãã\n"
"   (ãã®ãããªå ´åã)å¼æ°ãªã¹ãã¯ãä»ã®å ´æã§è¨åãããæå ±ãç¹°ãè¿ãã ãã§ã\n"
"   ãã ããå¤ãã®å¼æ°(ç¹ã«ã­ã¼ã¯ã¼ãå¼æ°)ãä½¿ããè¤éãªé¢æ°ã«å¯¾ãã¦ã¯ãå¼æ°ãªã¹ããæ¸ãã®ã¯ããã¢ã¤ãã£ã¢ã§ãã\n"
"   ãã®å ´åãä¸è¬çãªé¢æ°èª¬æã®å¾ã`#Arguments` ãããã®ä¸ã«å¼æ°ãªã¹ããæ¿å¥ãã¾ããå¼æ°1ã¤ãã¤ã«å¯¾ãã¦ `-` ã®ç®æ¡æ¸ããä½¿ãã¾ãããã\n"
"   ãªã¹ãã«ã¯ãå¼æ°ã®åã¨æ¢å®å¤ (ããå ´å) ãæå®ããå¿è¦ãããã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:81
#, no-wrap
msgid ""
"   \"\"\"\n"
"   ...\n"
"   # Arguments\n"
"   - `n::Integer`: the number of elements to compute.\n"
"   - `dim::Integer=1`: the dimensions along which to perform the computation.\n"
"   ...\n"
"   \"\"\"\n"
msgstr ""
"   \"\"\"\n"
"   ...\n"
"   # Arguments\n"
"   - `n::Integer`: the number of elements to compute.\n"
"   - `dim::Integer=1`: the dimensions along which to perform the computation.\n"
"   ...\n"
"   \"\"\"\n"

#. type: Bullet: '5. '
#: ext/julia/doc/src/manual/documentation.md:91
msgid "Provide hints to related functions."
msgstr "é¢é£ããé¢æ°ã«ãã³ã(see. also)ãå ãã¾ãããã"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:94
#, no-wrap
msgid ""
"   Sometimes there are functions of related functionality. To increase discoverability please provide\n"
"   a short list of these in a `See also:` paragraph.\n"
msgstr "   é¢é£ããæ©è½ããã¤é¢æ°ãããå ´åã¯ãé©åãªé¢æ°ãçºè¦ãã¦è²°ãå¯è½æ§ãé«ããããã«ã`See also:` ã®æ®µè½ã§ã«é¢é£ããé¢æ°ã®ç­ããªã¹ããå ãã¾ãããã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:95
#, no-wrap
msgid "   See also: [`bar!`](@ref), [`baz`](@ref), [`baaz`](@ref)\n"
msgstr "   See also: [`bar!`](@ref), [`baz`](@ref), [`baaz`](@ref)\n"

#. type: Bullet: '6. '
#: ext/julia/doc/src/manual/documentation.md:99
msgid "Include any code examples in an `# Examples` section."
msgstr "`# Examples`ã»ã¯ã·ã§ã³ã«ãªãããã®ã³ã¼ãä¾ãç¤ºãã¾ãããã"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:103
#, no-wrap
msgid ""
"   Examples should, whenever possible, be written as *doctests*. A *doctest* is a fenced code block\n"
"   (see [Code blocks](@ref)) starting with ````` ```jldoctest````` and contains any number of `julia>`\n"
"   prompts together with inputs and expected outputs that mimic the Julia REPL.\n"
msgstr ""
"   ä¾ã¯ãå¯è½ãªéã *doctests*ã¨ãã¦è¨è¿°ããå¿è¦ãããã¾ãã*doctest* ã¯ãã§ã³ã¹ã§å²ã¾ããã³ã¼ããã­ãã¯ã§ã([ã³ã¼ããã­ãã¯](@ref Code-blocks) åç§) ã\n"
"   ````` ```jldoctest`````ã§å§ã¾ããä»»æã®æ°ã® `julia>` ãã­ã³ãããããã®å¥åºåã¨ã¨ãã«å«ã¾ãã¾ããããã§ã®åºåã¯Juliaã®REPLã§ããã°ä¸ããããå¥åã«å¯¾ãã¦ããã®åºåãåºãã ããã¨ããæå¾å¤ã§ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:108
#, no-wrap
msgid ""
"   !!! note\n"
"       Doctests are enabled by [`Documenter.jl`](https://github.com/JuliaDocs/Documenter.jl).\n"
"       For more detailed documentation see Documenter's\n"
"       [manual](https://juliadocs.github.io/Documenter.jl/).\n"
msgstr ""
"   !!!ã¡ã¢\n"
"       doctest ã¯[`Documenter.jl`](https://github.com/JuliaDocs/Documenter.jl)ã«ãã£ã¦æå¹åããã¾ãã\n"
"       è©³ç´°ãªãã­ã¥ã¡ã³ãã«ã¤ãã¦ã¯ãDocumenter ã®[ããã¥ã¢ã«](https://juliadocs.github.io/Documenter.jl/)ãè¦ã¦ãã ããã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:111
#, no-wrap
msgid ""
"   For example in the following docstring a variable `a` is defined and the expected result, as printed\n"
"   in a Julia REPL, appears afterwards:\n"
msgstr "   ãã¨ãã°ãæ¬¡ã® docstring ã§ã¯å¤æ° `a` ãå®ç¾©ãããæå¾ãããçµæã Julia ã®REPLã«ããªã³ãåºåãããã®ã¨åãããã«å¾ã§è¡¨ç¤ºããã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:112
#, no-wrap
msgid ""
"   \"\"\"\n"
"   Some nice documentation here.\n"
"\n"
"   # Examples\n"
"   ```jldoctest\n"
"   julia> a = [1 2; 3 4]\n"
"   2Ã2 Array{Int64,2}:\n"
"    1  2\n"
"    3  4\n"
"   ```\n"
"   \"\"\"\n"
msgstr ""
"   \"\"\"\n"
"   Some nice documentation here.\n"
"\n"
"   # Examples\n"
"   ```jldoctest\n"
"   julia> a = [1 2; 3 4]\n"
"   2Ã2 Array{Int64,2}:\n"
"    1  2\n"
"    3  4\n"
"   ```\n"
"   \"\"\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:132
#, no-wrap
msgid ""
"   !!! warning\n"
"       Calling `rand` and other RNG-related functions should be avoided in doctests since they will not\n"
"       produce consistent outputs during different Julia sessions. If you would like to show some random\n"
"       number generation related functionality, one option is to explicitly construct and seed your own\n"
"       [`MersenneTwister`](@ref) (or other pseudorandom number generator) and pass it to the functions you are\n"
"       doctesting.\n"
msgstr ""
"   !!!è­¦å\n"
"       `rand` ããã³ãã®ä»ã® RNG é¢é£ã®é¢æ°ã®å¼ã³åºãã¯ãdoctest ã§ã¯é¿ãã¦ä¸ããã\n"
"       RNGé¢é£ã®é¢æ°ã¯ãç°ãªã Julia ã»ãã·ã§ã³ã§ä¸è²«ããåºåãçæããªãããã§ããä½ããã®ä¹±æ°çæé¢é£ã®æ©è½ãç¤ºãããå ´åã®ä¸ã¤ã®é¸æè¢ã¯ã[`MersenneTwister`](@ref)(ãããã¯ãã®ä»ã®çä¼¼ä¹±æ°çæã®é¢æ°)ã«æç¤ºçã«ã·ã¼ããä¸ãããã®çµæãdoctest ãæ¸ãã¦ããé¢æ°ã«ä¸ãããã¨ã§ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:135
#, no-wrap
msgid ""
"       Operating system word size ([`Int32`](@ref) or [`Int64`](@ref)) as well as path separator differences\n"
"       (`/` or `\\`) will also affect the reproducibility of some doctests.\n"
msgstr ""
"       ãªãã¬ã¼ãã£ã³ã° ã·ã¹ãã ã®ã¯ã¼ããµã¤ãº ([`Int32`](@ref) ã¾ãã¯ [`Int64`](@ref))ã¨ãã¹åºåãè¨å·ã®éã\n"
"       (`/` ã¾ãã¯ `\\`) ã¯ãä¸é¨ã®doctestã®åç¾æ§ã«ãå½±é¿ãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:138
#, no-wrap
msgid ""
"       Note that whitespace in your doctest is significant! The doctest will fail if you misalign the\n"
"       output of pretty-printing an array, for example.\n"
msgstr "       doctest ã®ç©ºç½ã¯éè¦ã§ããdoctest ã¯ä¾ãã°éåã®pritty-printã®åºåä½ç½®ã(æå¾å¤ã¨)ããã¦ããã¨å¤±æãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:141
#, no-wrap
msgid ""
"   You can then run `make -C doc doctest=true` to run all the doctests in the Julia Manual and API\n"
"   documentation, which will ensure that your example works.\n"
msgstr ""
"   Juliaã®ããã¥ã¢ã«ã¨APIãã­ã¥ã¡ã³ãã§ã¯ã³ã¼ãexampleãç¢ºå®ã«æ©è½ãã¾ãã\n"
"   ãã¹ã¦ã®doctestãå®è¡ããã«ã¯ `make -C doctest=true`ãå®è¡ãã¦ãã ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:147
#, no-wrap
msgid ""
"   To indicate that the output result is truncated, you may write\n"
"   `[...]` at the line where checking should stop. This is useful to\n"
"   hide a stacktrace (which contains non-permanent references to lines\n"
"   of julia code) when the doctest shows that an exception is thrown,\n"
"   for example:\n"
msgstr ""
"   åºåçµæãåãæ¨ã¦ããããã¨ãç¤ºãã«ã¯ããã§ãã¯ãåæ­¢ãã¹ãè¡ã§`[...]`ã¨æ¸ããã¨ãã§ãã¾ãã\n"
"   ããã¯ãdoctest ã§ä½ãä¾å¤ãã¹ã­ã¼ãããã¨ããã¹ã¿ãã¯ãã¬ã¼ã¹(ããã¯ãJulia ã®ã³ã¼ãè¡ã¸ã®éæ°¸ç¶çãªåç§ãå«ã¿ã¾ã) ãéè¡¨ç¤ºã«ããã®ã«å½¹ç«ã¡ã¾ããä¾ãã°:\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:148
#, no-wrap
msgid ""
"   ```jldoctest\n"
"   julia> div(1, 0)\n"
"   ERROR: DivideError: integer division error\n"
"   [...]\n"
"   ```\n"
msgstr ""
"   ```jldoctest\n"
"   julia> div(1, 0)\n"
"   ERROR: DivideError: integer division error\n"
"   [...]\n"
"   ```\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:158
#, no-wrap
msgid ""
"   Examples that are untestable should be written within fenced code blocks starting with ````` ```julia`````\n"
"   so that they are highlighted correctly in the generated documentation.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:163
#, no-wrap
msgid ""
"   !!! tip\n"
"       Wherever possible examples should be **self-contained** and **runnable** so that readers are able\n"
"       to try them out without having to include any dependencies.\n"
"7. Use backticks to identify code and equations.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:169
#, no-wrap
msgid ""
"   Julia identifiers and code excerpts should always appear between backticks ``` ` ``` to enable\n"
"   highlighting. Equations in the LaTeX syntax can be inserted between double backticks ``` `` ```.\n"
"   Use Unicode characters rather than their LaTeX escape sequence, i.e. ``` ``Î± = 1`` ``` rather\n"
"   than ``` ``\\\\alpha = 1`` ```.\n"
"8. Place the starting and ending `\"\"\"` characters on lines by themselves.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:171
#, no-wrap
msgid "   That is, write:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:172
#, no-wrap
msgid ""
"   \"\"\"\n"
"   ...\n"
"\n"
"   ...\n"
"   \"\"\"\n"
"   f(x, y) = ...\n"
msgstr ""
"   \"\"\"\n"
"   ...\n"
"\n"
"   ...\n"
"   \"\"\"\n"
"   f(x, y) = ...\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:182
#, no-wrap
msgid "   rather than:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:183
#, no-wrap
msgid ""
"   \"\"\"...\n"
"\n"
"   ...\"\"\"\n"
"   f(x, y) = ...\n"
msgstr ""
"   \"\"\"...\n"
"\n"
"   ...\"\"\"\n"
"   f(x, y) = ...\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:192
#, no-wrap
msgid ""
"   This makes it more clear where docstrings start and end.\n"
"9. Respect the line length limit used in the surrounding code.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:200
#, no-wrap
msgid ""
"   Docstrings are edited using the same tools as code. Therefore, the same conventions should apply.\n"
"   It is advised to add line breaks after 92 characters.\n"
"6. Provide information allowing custom types to implement the function in an\n"
"   `# Implementation` section. These implementation details intended for developers\n"
"   rather than users, explaining e.g. which functions should be overridden and which functions\n"
"   automatically use appropriate fallbacks, are better kept separate from the main description of\n"
"   the function's behavior.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/documentation.md:201
#, no-wrap
msgid "Accessing Documentation"
msgstr "ãã­ã¥ã¡ã³ãã¸ã®ã¢ã¯ã»ã¹"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:205
msgid ""
"Documentation can be accessed at the REPL or in [IJulia](https://github.com/JuliaLang/IJulia.jl)  by typing `?` followed by the name of a "
"function or macro, and pressing `Enter`. For example,"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:206
#, no-wrap
msgid ""
"?cos\n"
"?@time\n"
"?r\"\"\n"
msgstr ""
"?cos\n"
"?@time\n"
"?r\"\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:214
msgid ""
"will bring up docs for the relevant function, macro or string macro respectively. In [Juno](http://junolab.org)  using `Ctrl-J, Ctrl-D` will "
"bring up documentation for the object under the cursor."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/documentation.md:215
#, no-wrap
msgid "Functions & Methods"
msgstr "é¢æ°ã¨ã¡ã½ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:223
msgid ""
"Functions in Julia may have multiple implementations, known as methods. While it's good practice for generic functions to have a single "
"purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or "
"even the function itself (i.e. the object created without any methods by `function bar end`). Specific methods should only be documented if "
"their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:224
#, no-wrap
msgid ""
"\"\"\"\n"
"    *(x, y, z...)\n"
"\n"
"Multiplication operator. `x * y * z *...` calls this function with multiple\n"
"arguments, i.e. `*(x, y, z...)`.\n"
"\"\"\"\n"
"function *(x, y, z...)\n"
"    # ... [implementation sold separately] ...\n"
"end\n"
"\n"
"\"\"\"\n"
"    *(x::AbstractString, y::AbstractString, z::AbstractString...)\n"
"\n"
"When applied to strings, concatenates them.\n"
"\"\"\"\n"
"function *(x::AbstractString, y::AbstractString, z::AbstractString...)\n"
"    # ... [insert secret sauce here] ...\n"
"end\n"
"\n"
"help?> *\n"
"search: * .*\n"
"\n"
"  *(x, y, z...)\n"
"\n"
"  Multiplication operator. x * y * z *... calls this function with multiple\n"
"  arguments, i.e. *(x,y,z...).\n"
"\n"
"  *(x::AbstractString, y::AbstractString, z::AbstractString...)\n"
"\n"
"  When applied to strings, concatenates them.\n"
msgstr ""
"\"\"\"\n"
"    *(x, y, z...)\n"
"\n"
"Multiplication operator. `x * y * z *...` calls this function with multiple\n"
"arguments, i.e. `*(x, y, z...)`.\n"
"\"\"\"\n"
"function *(x, y, z...)\n"
"    # ... [implementation sold separately] ...\n"
"end\n"
"\n"
"\"\"\"\n"
"    *(x::AbstractString, y::AbstractString, z::AbstractString...)\n"
"\n"
"When applied to strings, concatenates them.\n"
"\"\"\"\n"
"function *(x::AbstractString, y::AbstractString, z::AbstractString...)\n"
"    # ... [insert secret sauce here] ...\n"
"end\n"
"\n"
"help?> *\n"
"search: * .*\n"
"\n"
"  *(x, y, z...)\n"
"\n"
"  Multiplication operator. x * y * z *... calls this function with multiple\n"
"  arguments, i.e. *(x,y,z...).\n"
"\n"
"  *(x::AbstractString, y::AbstractString, z::AbstractString...)\n"
"\n"
"  When applied to strings, concatenates them.\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:259
msgid ""
"When retrieving documentation for a generic function, the metadata for each method is concatenated with the `catdoc` function, which can of "
"course be overridden for custom types."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/documentation.md:260
#, no-wrap
msgid "Advanced Usage"
msgstr "é«åº¦ãªä½¿ãæ¹"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:264
msgid "The `@doc` macro associates its first argument with its second in a per-module dictionary called `META`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:269
msgid ""
"To make it easier to write documentation, the parser treats the macro name `@doc` specially: if a call to `@doc` has one argument, but "
"another expression appears after a single line break, then that additional expression is added as an argument to the macro.  Therefore the "
"following syntax is parsed as a 2-argument call to `@doc`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:270
#, no-wrap
msgid ""
"@doc raw\"\"\"\n"
"...\n"
"\"\"\"\n"
"f(x) = x\n"
msgstr ""
"@doc raw\"\"\"\n"
"...\n"
"\"\"\"\n"
"f(x) = x\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:278
msgid "This makes it possible to use expressions other than normal string literals (such as the `raw\"\"` string macro) as a docstring."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:284
msgid ""
"When used for retrieving documentation, the `@doc` macro (or equally, the `doc` function) will search all `META` dictionaries for metadata "
"relevant to the given object and return it. The returned object (some Markdown content, for example) will by default display itself "
"intelligently. This design also makes it easy to use the doc system in a programmatic way; for example, to re-use documentation between "
"different versions of a function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:285
#, no-wrap
msgid ""
"@doc \"...\" foo!\n"
"@doc (@doc foo!) foo\n"
msgstr ""
"@doc \"...\" foo!\n"
"@doc (@doc foo!) foo\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:291
msgid "Or for use with Julia's metaprogramming functionality:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:292
#, no-wrap
msgid ""
"for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))\n"
"    @eval begin\n"
"        $f(a,b) = $op(a,b)\n"
"    end\n"
"end\n"
"@doc \"`add(a,b)` adds `a` and `b` together\" add\n"
"@doc \"`subtract(a,b)` subtracts `b` from `a`\" subtract\n"
msgstr ""
"for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))\n"
"    @eval begin\n"
"        $f(a,b) = $op(a,b)\n"
"    end\n"
"end\n"
"@doc \"`add(a,b)` adds `a` and `b` together\" add\n"
"@doc \"`subtract(a,b)` subtracts `b` from `a`\" subtract\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:304
msgid ""
"Documentation written in non-toplevel blocks, such as `begin`, `if`, `for`, and `let`, is added to the documentation system as blocks are "
"evaluated. For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:305
#, no-wrap
msgid ""
"if condition()\n"
"    \"...\"\n"
"    f(x) = x\n"
"end\n"
msgstr ""
"if condition()\n"
"    \"...\"\n"
"    f(x) = x\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:314
msgid ""
"will add documentation to `f(x)` when `condition()` is `true`. Note that even if `f(x)` goes out of scope at the end of the block, its "
"documentation will remain."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/documentation.md:315
#, no-wrap
msgid "Dynamic documentation"
msgstr "åçãã­ã¥ã¡ã³ã"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:320
msgid ""
"Sometimes the appropriate documentation for an instance of a type depends on the field values of that instance, rather than just on the type "
"itself. In these cases, you can add a method to `Docs.getdoc` for your custom type that returns the documentation on a per-instance basis. "
"For instance,"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:321
#, no-wrap
msgid ""
"struct MyType\n"
"    value::String\n"
"end\n"
"\n"
"Docs.getdoc(t::MyType) = \"Documentation for MyType with value $(t.value)\"\n"
"\n"
"x = MyType(\"x\")\n"
"y = MyType(\"y\")\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:334
msgid "`?x` will display \"Documentation for MyType with value x\" while `?y` will display \"Documentation for MyType with value y\"."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/documentation.md:335
#, no-wrap
msgid "Syntax Guide"
msgstr "æ§æã¬ã¤ã"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:339
msgid ""
"A comprehensive overview of all documentable Julia syntax.  In the following examples `\"...\"` is used to illustrate an arbitrary docstring."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/documentation.md:340
#, no-wrap
msgid "`$` and `\\` characters"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:346
msgid ""
"The `$` and `\\` characters are still parsed as string interpolation or start of an escape sequence in docstrings too. The `raw\"\"` string "
"macro together with the `@doc` macro can be used to avoid having to escape them. This is handy when the docstrings include LaTeX or Julia "
"source code examples containing interpolation:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:347
#, no-wrap
msgid ""
"@doc raw\"\"\"\n"
"```math\n"
"\\LaTeX\n"
"```\n"
"\"\"\"\n"
"function f end\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/documentation.md:356
#, no-wrap
msgid "Functions and Methods"
msgstr "é¢æ°ã¨ã¡ã½ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:358
#, no-wrap
msgid ""
"\"...\"\n"
"function f end\n"
"\n"
"\"...\"\n"
"f\n"
msgstr ""
"\"...\"\n"
"function f end\n"
"\n"
"\"...\"\n"
"f\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:368
msgid "Adds docstring `\"...\"` to the function `f`. The first version is the preferred syntax, however both are equivalent."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:369
#, no-wrap
msgid ""
"\"...\"\n"
"f(x) = x\n"
"\n"
"\"...\"\n"
"function f(x)\n"
"    x\n"
"end\n"
"\n"
"\"...\"\n"
"f(x)\n"
msgstr ""
"\"...\"\n"
"f(x) = x\n"
"\n"
"\"...\"\n"
"function f(x)\n"
"    x\n"
"end\n"
"\n"
"\"...\"\n"
"f(x)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:383
msgid "Adds docstring `\"...\"` to the method `f(::Any)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:384
#, no-wrap
msgid ""
"\"...\"\n"
"f(x, y = 1) = x + y\n"
msgstr ""
"\"...\"\n"
"f(x, y = 1) = x + y\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:390
msgid "Adds docstring `\"...\"` to two `Method`s, namely `f(::Any)` and `f(::Any, ::Any)`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/documentation.md:391 ext/julia/doc/src/devdocs/ast.md:84 ext/julia/doc/src/devdocs/ast.md:228
#, no-wrap
msgid "Macros"
msgstr "ãã¯ã­"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:393
#, no-wrap
msgid ""
"\"...\"\n"
"macro m(x) end\n"
msgstr ""
"\"...\"\n"
"macro m(x) end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:399
msgid "Adds docstring `\"...\"` to the `@m(::Any)` macro definition."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:400
#, no-wrap
msgid ""
"\"...\"\n"
":(@m)\n"
msgstr ""
"\"...\"\n"
":(@m)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:406
msgid "Adds docstring `\"...\"` to the macro named `@m`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/documentation.md:407
#, no-wrap
msgid "Types"
msgstr "å"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:409
#, no-wrap
msgid ""
"\"...\"\n"
"abstract type T1 end\n"
"\n"
"\"...\"\n"
"mutable struct T2\n"
"    ...\n"
"end\n"
"\n"
"\"...\"\n"
"struct T3\n"
"    ...\n"
"end\n"
msgstr ""
"\"...\"\n"
"abstract type T1 end\n"
"\n"
"\"...\"\n"
"mutable struct T2\n"
"    ...\n"
"end\n"
"\n"
"\"...\"\n"
"struct T3\n"
"    ...\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:425
msgid "Adds the docstring `\"...\"` to types `T1`, `T2`, and `T3`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:426
#, no-wrap
msgid ""
"\"...\"\n"
"struct T\n"
"    \"x\"\n"
"    x\n"
"    \"y\"\n"
"    y\n"
"end\n"
msgstr ""
"\"...\"\n"
"struct T\n"
"    \"x\"\n"
"    x\n"
"    \"y\"\n"
"    y\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:438
msgid "Adds docstring `\"...\"` to type `T`, `\"x\"` to field `T.x` and `\"y\"` to field `T.y`. Also applicable to `mutable struct` types."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/documentation.md:439
#, no-wrap
msgid "Modules"
msgstr "ã¢ã¸ã¥ã¼ã«"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:441
#, no-wrap
msgid ""
"\"...\"\n"
"module M end\n"
"\n"
"module M\n"
"\n"
"\"...\"\n"
"M\n"
"\n"
"end\n"
msgstr ""
"\"...\"\n"
"module M end\n"
"\n"
"module M\n"
"\n"
"\"...\"\n"
"M\n"
"\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:455
msgid ""
"Adds docstring `\"...\"` to the `Module``M`. Adding the docstring above the `Module` is the preferred syntax, however both are equivalent."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:456
#, no-wrap
msgid ""
"\"...\"\n"
"baremodule M\n"
"# ...\n"
"end\n"
"\n"
"baremodule M\n"
"\n"
"import Base: @doc\n"
"\n"
"\"...\"\n"
"f(x) = x\n"
"\n"
"end\n"
msgstr ""
"\"...\"\n"
"baremodule M\n"
"# ...\n"
"end\n"
"\n"
"baremodule M\n"
"\n"
"import Base: @doc\n"
"\n"
"\"...\"\n"
"f(x) = x\n"
"\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:475
msgid ""
"Documenting a `baremodule` by placing a docstring above the expression automatically imports `@doc` into the module. These imports must be "
"done manually when the module expression is not documented. Empty `baremodule`s cannot be documented."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/documentation.md:476
#, no-wrap
msgid "Global Variables"
msgstr "ã°ã­ã¼ãã«å¤æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:478
#, no-wrap
msgid ""
"\"...\"\n"
"const a = 1\n"
"\n"
"\"...\"\n"
"b = 2\n"
"\n"
"\"...\"\n"
"global c = 3\n"
msgstr ""
"\"...\"\n"
"const a = 1\n"
"\n"
"\"...\"\n"
"b = 2\n"
"\n"
"\"...\"\n"
"global c = 3\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:490
msgid "Adds docstring `\"...\"` to the `Binding`s `a`, `b`, and `c`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:493
msgid "`Binding`s are used to store a reference to a particular `Symbol` in a `Module` without storing the referenced value itself."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:498
#, no-wrap
msgid ""
"!!! note\n"
"    When a `const` definition is only used to define an alias of another definition, such as is the\n"
"    case with the function `div` and its alias `Ã·` in `Base`, do not document the alias and instead\n"
"    document the actual function.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:501
#, no-wrap
msgid ""
"    If the alias is documented and not the real definition then the docsystem (`?` mode) will not\n"
"    return the docstring attached to the alias when the real definition is searched for.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:503
#, no-wrap
msgid "    For example you should write\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:509
#, no-wrap
msgid ""
"    ```julia\n"
"    \"...\"\n"
"    f(x) = x + 1\n"
"    const alias = f\n"
"    ```\n"
msgstr ""
"    ```julia\n"
"    \"...\"\n"
"    f(x) = x + 1\n"
"    const alias = f\n"
"    ```\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:511
#, no-wrap
msgid "    rather than\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:517
#, no-wrap
msgid ""
"    ```julia\n"
"    f(x) = x + 1\n"
"    \"...\"\n"
"    const alias = f\n"
"    ```\n"
msgstr ""
"    ```julia\n"
"    f(x) = x + 1\n"
"    \"...\"\n"
"    const alias = f\n"
"    ```\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:518
#, no-wrap
msgid ""
"\"...\"\n"
"sym\n"
msgstr ""
"\"...\"\n"
"sym\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:525
msgid "Adds docstring `\"...\"` to the value associated with `sym`. Users should prefer documenting `sym` at its definition."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/documentation.md:526
#, no-wrap
msgid "Multiple Objects"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:528
#, no-wrap
msgid ""
"\"...\"\n"
"a, b\n"
msgstr ""
"\"...\"\n"
"a, b\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:535
msgid "Adds docstring `\"...\"` to `a` and `b` each of which should be a documentable expression. This syntax is equivalent to"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:536
#, no-wrap
msgid ""
"\"...\"\n"
"a\n"
"\n"
"\"...\"\n"
"b\n"
msgstr ""
"\"...\"\n"
"a\n"
"\n"
"\"...\"\n"
"b\n"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:546
msgid ""
"Any number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-"
"mutating and mutating versions `f` and `f!`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/documentation.md:547
#, no-wrap
msgid "Macro-generated code"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:549
#, no-wrap
msgid ""
"\"...\"\n"
"@m expression\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:557
msgid ""
"Adds docstring `\"...\"` to expression generated by expanding `@m expression`. This allows for expressions decorated with `@inline`, "
"`@noinline`, `@generated`, or any other macro to be documented in the same way as undecorated expressions."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:561
msgid ""
"Macro authors should take note that only macros that generate a single expression will automatically support docstrings. If a macro returns "
"a block containing multiple subexpressions then the subexpression that should be documented must be marked using the [`@__doc__`](@ref Core."
"@__doc__) macro."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:565
msgid ""
"The [`@enum`](@ref) macro makes use of `@__doc__` to allow for documenting [`Enum`](@ref)s.  Examining its definition should serve as an "
"example of how to use `@__doc__` correctly."
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/documentation.md:566 ext/julia/doc/src/base/iterators.md:3 ext/julia/doc/src/base/numbers.md:7
#: ext/julia/doc/src/base/numbers.md:19 ext/julia/doc/src/base/numbers.md:43 ext/julia/doc/src/base/numbers.md:64
#: ext/julia/doc/src/base/numbers.md:101 ext/julia/doc/src/base/numbers.md:122 ext/julia/doc/src/base/multi-threading.md:6
#: ext/julia/doc/src/base/multi-threading.md:13 ext/julia/doc/src/base/multi-threading.md:30 ext/julia/doc/src/base/multi-threading.md:38
#: ext/julia/doc/src/base/parallel.md:3 ext/julia/doc/src/base/parallel.md:22 ext/julia/doc/src/base/base.md:20
#: ext/julia/doc/src/base/base.md:56 ext/julia/doc/src/base/base.md:91 ext/julia/doc/src/base/base.md:98 ext/julia/doc/src/base/base.md:112
#: ext/julia/doc/src/base/base.md:147 ext/julia/doc/src/base/base.md:160 ext/julia/doc/src/base/base.md:174 ext/julia/doc/src/base/base.md:190
#: ext/julia/doc/src/base/base.md:203 ext/julia/doc/src/base/base.md:226 ext/julia/doc/src/base/base.md:239 ext/julia/doc/src/base/base.md:265
#: ext/julia/doc/src/base/base.md:276 ext/julia/doc/src/base/base.md:320 ext/julia/doc/src/base/base.md:327 ext/julia/doc/src/base/base.md:368
#: ext/julia/doc/src/base/base.md:377 ext/julia/doc/src/base/base.md:394 ext/julia/doc/src/base/base.md:413 ext/julia/doc/src/base/sort.md:109
#: ext/julia/doc/src/base/sort.md:123 ext/julia/doc/src/base/strings.md:3 ext/julia/doc/src/base/math.md:5 ext/julia/doc/src/base/math.md:58
#: ext/julia/doc/src/base/stacktraces.md:3 ext/julia/doc/src/base/stacktraces.md:12 ext/julia/doc/src/base/libc.md:3
#: ext/julia/doc/src/base/file.md:3 ext/julia/doc/src/base/collections.md:29 ext/julia/doc/src/base/collections.md:54
#: ext/julia/doc/src/base/collections.md:65 ext/julia/doc/src/base/collections.md:88 ext/julia/doc/src/base/collections.md:145
#: ext/julia/doc/src/base/collections.md:195 ext/julia/doc/src/base/collections.md:238 ext/julia/doc/src/base/collections.md:267
#: ext/julia/doc/src/base/collections.md:287 ext/julia/doc/src/base/arrays.md:5 ext/julia/doc/src/base/arrays.md:48
#: ext/julia/doc/src/base/arrays.md:70 ext/julia/doc/src/base/arrays.md:77 ext/julia/doc/src/base/arrays.md:90
#: ext/julia/doc/src/base/arrays.md:107 ext/julia/doc/src/base/arrays.md:122 ext/julia/doc/src/base/arrays.md:149
#: ext/julia/doc/src/base/arrays.md:169 ext/julia/doc/src/base/io-network.md:5 ext/julia/doc/src/base/io-network.md:57
#: ext/julia/doc/src/base/io-network.md:91 ext/julia/doc/src/base/io-network.md:122 ext/julia/doc/src/base/io-network.md:131
#: ext/julia/doc/src/base/constants.md:3 ext/julia/doc/src/base/c.md:3 ext/julia/doc/src/base/c.md:48
#: ext/julia/doc/src/stdlib/DelimitedFiles.md:3 ext/julia/doc/src/stdlib/Printf.md:3 ext/julia/doc/src/stdlib/Mmap.md:3
#: ext/julia/doc/src/stdlib/CRC32c.md:3 ext/julia/doc/src/stdlib/Profile.md:3 ext/julia/doc/src/stdlib/Profile.md:10
#: ext/julia/doc/src/stdlib/Unicode.md:3 ext/julia/doc/src/stdlib/LibGit2.md:16 ext/julia/doc/src/stdlib/UUIDs.md:3
#: ext/julia/doc/src/stdlib/Serialization.md:3 ext/julia/doc/src/stdlib/Statistics.md:5 ext/julia/doc/src/stdlib/Base64.md:3
#: ext/julia/doc/src/stdlib/Distributed.md:3 ext/julia/doc/src/stdlib/Distributed.md:60 ext/julia/doc/src/stdlib/Random.md:36
#: ext/julia/doc/src/stdlib/Random.md:42 ext/julia/doc/src/stdlib/Random.md:55 ext/julia/doc/src/stdlib/Random.md:68
#: ext/julia/doc/src/stdlib/Random.md:139 ext/julia/doc/src/stdlib/Libdl.md:3 ext/julia/doc/src/stdlib/REPL.md:553
#: ext/julia/doc/src/stdlib/Logging.md:242 ext/julia/doc/src/stdlib/Logging.md:248 ext/julia/doc/src/stdlib/Logging.md:267
#: ext/julia/doc/src/stdlib/Logging.md:280 ext/julia/doc/src/stdlib/Logging.md:288 ext/julia/doc/src/stdlib/InteractiveUtils.md:3
#: ext/julia/doc/src/stdlib/FileWatching.md:3 ext/julia/doc/src/stdlib/SparseArrays.md:217 ext/julia/doc/src/stdlib/SharedArrays.md:3
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:333 ext/julia/doc/src/stdlib/LinearAlgebra.md:487 ext/julia/doc/src/stdlib/LinearAlgebra.md:542
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:603 ext/julia/doc/src/stdlib/Sockets.md:3 ext/julia/doc/src/stdlib/Test.md:14
#: ext/julia/doc/src/stdlib/Test.md:29 ext/julia/doc/src/stdlib/Test.md:107 ext/julia/doc/src/stdlib/Test.md:189
#: ext/julia/doc/src/stdlib/Test.md:203 ext/julia/doc/src/stdlib/Test.md:211 ext/julia/doc/src/stdlib/Test.md:222
#: ext/julia/doc/src/stdlib/Test.md:232 ext/julia/doc/src/stdlib/Dates.md:688 ext/julia/doc/src/stdlib/Dates.md:701
#: ext/julia/doc/src/stdlib/Dates.md:728 ext/julia/doc/src/stdlib/Dates.md:756 ext/julia/doc/src/stdlib/Dates.md:775
#: ext/julia/doc/src/stdlib/Dates.md:795 ext/julia/doc/src/stdlib/Dates.md:807 ext/julia/doc/src/stdlib/Dates.md:815
#: ext/julia/doc/src/stdlib/Dates.md:823 ext/julia/doc/src/stdlib/Dates.md:833 ext/julia/doc/src/devdocs/cartesian.md:130
#, no-wrap
msgid "@docs"
msgstr "@docs"

#. type: Plain text
#: ext/julia/doc/src/manual/documentation.md:566
#, no-wrap
msgid "Core.@__doc__\n"
msgstr "Core.@__doc__\n"

#. type: Title #
#: ext/julia/doc/src/manual/performance-tips.md:1
#, no-wrap
msgid "[Performance Tips](@id man-performance-tips)"
msgstr "[ããã©ã¼ãã³ã¹ã»ãã£ããã¹](@id man-performance-tips)"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:5
msgid "In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible."
msgstr "æ¬¡ã®ã»ã¯ã·ã§ã³ã§ã¯ãJulia ã³ã¼ããã§ããã ãéãå®è¡ããã®ã«å½¹ç«ã¤ããã¤ãã®ãã¯ããã¯ãç°¡åã«èª¬æãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:6
#, no-wrap
msgid "Avoid global variables"
msgstr "ã°ã­ã¼ãã«å¤æ°ãé¿ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:11
msgid ""
"A global variable might have its value, and therefore its type, change at any point. This makes it difficult for the compiler to optimize "
"code using global variables. Variables should be local, or passed as arguments to functions, whenever possible."
msgstr ""
"ã°ã­ã¼ãã«å¤æ°ã¯(å®£è¨æã«) å¤ã¨åãæã¤ããããã¾ãããããã®åã¯ãã¤ã§ãå¤ãããã¾ãããã®ãããã³ã³ãã¤ã©ã¯ã°ã­ã¼ãã«å¤æ°ãä½¿ç¨ããã³ã¼ãã"
"æé©åãããã¨ãé£ããã®ã§ããå¤æ°ã¯ãå¯è½ãªéãã­ã¼ã«ã«ã§ããããé¢æ°ã«å¼æ°ã¨ãã¦æ¸¡ãããå¿è¦ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:13
msgid "Any code that is performance critical or being benchmarked should be inside a function."
msgstr "ããã©ã¼ãã³ã¹ãéè¦ãªã³ã¼ãããã³ããã¼ã¯ããã¦ããã³ã¼ãã¯ãé¢æ°åã«å­å¨ããå¿è¦ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:16
msgid "We find that global names are frequently constants, and declaring them as such greatly improves performance:"
msgstr "ã°ã­ã¼ãã«åã¯å®æ°ã§ãããã¨ãå¤ãããã®ããã«å®£è¨ããã¨ããã©ã¼ãã³ã¹ãå¤§å¹ã«åä¸ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:17
#, no-wrap
msgid "const DEFAULT_VAL = 0\n"
msgstr "const DEFAULT_VAL = 0\n"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:22
msgid "Uses of non-constant globals can be optimized by annotating their types at the point of use:"
msgstr "éå®æ°ã°ã­ã¼ãã«ã®ä½¿ãå ´åã¯ãä½¿ç¨æã«åã®ã¢ããã¼ã·ã§ã³ããããã¨ã§æé©åã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:23
#, no-wrap
msgid ""
"global x = rand(1000)\n"
"\n"
"function loop_over_global()\n"
"    s = 0.0\n"
"    for i in x::Vector{Float64}\n"
"        s += i\n"
"    end\n"
"    return s\n"
"end\n"
msgstr ""
"global x = rand(1000)\n"
"\n"
"function loop_over_global()\n"
"    s = 0.0\n"
"    for i in x::Vector{Float64}\n"
"        s += i\n"
"    end\n"
"    return s\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:36
msgid "Passing arguments to functions is better style. It leads to more reusable code and clarifies what the inputs and outputs are."
msgstr "ããåªãã¦ããã®ã¯é¢æ°ã«å¼æ°ã¨ãã¦æ¸¡ãã¹ã¿ã¤ã«ã§ãããã®ã¹ã¿ã¤ã«ã§ã¯ãã³ã¼ããããåå©ç¨ãããããå¥åã¨åºåãæç¢ºã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:41
#, no-wrap
msgid ""
"!!! note\n"
"    All code in the REPL is evaluated in global scope, so a variable defined and assigned\n"
"    at top level will be a **global** variable. Variables defined at top level scope inside\n"
"    modules are also global.\n"
msgstr ""
"!!!ã¡ã¢\n"
"    REPL åã®ãã¹ã¦ã®ã³ã¼ãã¯ã°ã­ã¼ãã« ã¹ã³ã¼ãã§è©ä¾¡ãããã®ã§ãæä¸ä½ã¬ãã«ã§å®ç¾©ã»ä»£å¥ãããå¤æ°ã¯**ã°ã­ã¼ãã«**å¤æ°ã«ãªãã¾ãã\n"
"    ã¢ã¸ã¥ã¼ã«åã®æä¸ä½ã¹ã³ã¼ãã§å®ç¾©ãããå¤æ°ãã¾ãã°ã­ã¼ãã«ã«ãªãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:43
msgid "In the following REPL session:"
msgstr "æ¬¡ã® REPL ã»ãã·ã§ã³ã§:"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:44
#, no-wrap
msgid "julia> x = 1.0\n"
msgstr "julia> x = 1.0\n"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:49
msgid "is equivalent to:"
msgstr "ã¯æ¬¡ã¨åãã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:50
#, no-wrap
msgid "julia> global x = 1.0\n"
msgstr "julia> global x = 1.0\n"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:55
msgid "so all the performance issues discussed previously apply."
msgstr "ãã®ãããåè¿°ã®ããã©ã¼ãã³ã¹ä¸ã®åé¡ããã¹ã¦å½ã¦ã¯ã¾ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:56
#, no-wrap
msgid "Measure performance with [`@time`](@ref) and pay attention to memory allocation"
msgstr "[`@time`](@ref)ã§ããã©ã¼ãã³ã¹ãæ¸¬å®ããã¡ã¢ãªå²ãå½ã¦ã«æ³¨æãæã"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:60
msgid ""
"A useful tool for measuring performance is the [`@time`](@ref) macro. We here repeat the example with the global variable above, but this "
"time with the type annotation removed:"
msgstr ""
"ããã©ã¼ãã³ã¹æ¸¬å®ã®ããã®ä¾¿å©ãªãã¼ã«ã¯[`@time`](@ref)ãã¯ã­ã§ããä¸è¨ã®ã°ã­ã¼ãã«å¤æ°ã®ä¾ãç¹°ãè¿ãã¾ãããä»åã¯åã¢ããã¼ã·ã§ã³ãåé¤ãã¾"
"ãã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/performance-tips.md:61
#, no-wrap
msgid "jldoctest; setup = :(using Random; Random.seed!(1234)), filter = r\"[0-9\\.]+ seconds \\(.*?\\)\""
msgstr "jldoctest; setup = :(using Random; Random.seed!(1234)), filter = r\"[0-9\\.]+ seconds \\(.*?\\)\""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:61
#, no-wrap
msgid ""
"julia> x = rand(1000);\n"
"\n"
"julia> function sum_global()\n"
"           s = 0.0\n"
"           for i in x\n"
"               s += i\n"
"           end\n"
"           return s\n"
"       end;\n"
"\n"
"julia> @time sum_global()\n"
"  0.017705 seconds (15.28 k allocations: 694.484 KiB)\n"
"496.84883432553846\n"
"\n"
"julia> @time sum_global()\n"
"  0.000140 seconds (3.49 k allocations: 70.313 KiB)\n"
"496.84883432553846\n"
msgstr ""
"julia> x = rand(1000);\n"
"\n"
"julia> function sum_global()\n"
"           s = 0.0\n"
"           for i in x\n"
"               s += i\n"
"           end\n"
"           return s\n"
"       end;\n"
"\n"
"julia> @time sum_global()\n"
"  0.017705 seconds (15.28 k allocations: 694.484 KiB)\n"
"496.84883432553846\n"
"\n"
"julia> @time sum_global()\n"
"  0.000140 seconds (3.49 k allocations: 70.313 KiB)\n"
"496.84883432553846\n"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:86
msgid ""
"On the first call (`@time sum_global()`) the function gets compiled. (If you've not yet used [`@time`](@ref)  in this session, it will also "
"compile functions needed for timing.)  You should not take the results of this run seriously. For the second run, note that in addition to "
"reporting the time, it also indicated that a significant amount of memory was allocated. We are here just computing a sum over all elements "
"in a vector of 64-bit floats so there should be no need to allocate memory (at least not on the heap which is what `@time` reports)."
msgstr ""
"æåã®å¼ã³åºã (`@time sum_global()`) ã§é¢æ°ãã³ã³ãã¤ã«ããã¾ãã(ãã®ã»ãã·ã§ã³ã§ [`@time`](@ref) ãã¾ã ä½¿ç¨ãã¦ããªãå ´åã¯ãæéæ¸¬å®ã«å¿"
"è¦ãªé¢æ°ãã³ã³ãã¤ã«ãã¾ã)ã ãã®å®è¡çµæãçå£ã«åãæ­¢ããã¹ãã§ã¯ããã¾ããã2 åç®ã®å®è¡ã§ã¯ãæ¼ç®æéã®ã¬ãã¼ãã«å ãã¦ãå¤§éã®ã¡ã¢ãªã"
"å²ãå½ã¦ããã¦ãããã¨ãç¤ºããã¾ããããã§ã¯ã64 ãããæµ®åå°æ°ç¹æ°ã®ãã¯ãã«åã®ãã¹ã¦ã®è¦ç´ ã«å¯¾ãã¦åè¨ãè¨ç®ããã ãã§ãã¡ã¢ãªãå²ãå½ã¦ã"
"å¿è¦ã¯ããã¾ãã (å°ãªãã¨ã`@time` ãã¬ãã¼ããããã¼ãé åã«ã¯å¿è¦ããã¾ãã)ã"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:92
msgid ""
"Unexpected memory allocation is almost always a sign of some problem with your code, usually a problem with type-stability or creating many "
"small temporary arrays.  Consequently, in addition to the allocation itself, it's very likely that the code generated for your function is "
"far from optimal. Take such indications seriously and follow the advice below."
msgstr ""
"äºæããªãã¡ã¢ãªå²ãå½ã¦ã¯ãã»ã¨ãã©ã®å ´åã§ãããªãã®æ¸ããã³ã¼ãã«åé¡ãããã¨ããåãã§ããéå¸¸ã¯åã®å®å®æ§ã®åé¡ã§ãã£ãããå¤æ°ã®å°ããª"
"ä¸æéåã®ä½æã®åé¡ã§ããäºæããªãã¡ã¢ãªå²å½ã¯ããããã®ãã®ãæªãã¨ããã ãã§ãªããé¢æ°ç¨ã«çæãããã³ã¼ããæé©ã¨ã¯ç¨é ãå¯è½æ§ãéå¸¸ã«"
"é«ãã®ã§ãããã®ãããªæç¤ºãçå£ã«åãæ­¢ããä»¥ä¸ã®ã¢ããã¤ã¹ã«å¾ã£ã¦ãã ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:96
msgid ""
"If we instead pass `x` as an argument to the function it no longer allocates memory (the allocation reported below is due to running the "
"`@time` macro in global scope)  and is significantly faster after the first call:"
msgstr ""
"ã°ã­ã¼ãã«åç§ããã®ã§ãªããé¢æ°ã®å¼æ°ã¨ãã¦`x`ãæ¸¡ãã°ãã¡ã¢ãªå²ãå½ã¦ã¯èµ·ãã¾ãã(ããã§ã¬ãã¼ããããã¡ã¢ãªå²ãå½ã¦ã¯ã`@time` ãã¯ã­ãã°"
"ã­ã¼ãã«ã¹ã³ã¼ãã§å®è¡ããããã¨ã«ãããã®)ã ããã¦ãäºåç®ã®å¼ã³åºãããã¯å¤§å¹ã«é«éã«ãªãã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/performance-tips.md:97
#, no-wrap
msgid "jldoctest sumarg; setup = :(using Random; Random.seed!(1234)), filter = r\"[0-9\\.]+ seconds \\(.*?\\)\""
msgstr "jldoctest sumarg; setup = :(using Random; Random.seed!(1234)), filter = r\"[0-9\\.]+ seconds \\(.*?\\)\""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:97
#, no-wrap
msgid ""
"julia> x = rand(1000);\n"
"\n"
"julia> function sum_arg(x)\n"
"           s = 0.0\n"
"           for i in x\n"
"               s += i\n"
"           end\n"
"           return s\n"
"       end;\n"
"\n"
"julia> @time sum_arg(x)\n"
"  0.007701 seconds (821 allocations: 43.059 KiB)\n"
"496.84883432553846\n"
"\n"
"julia> @time sum_arg(x)\n"
"  0.000006 seconds (5 allocations: 176 bytes)\n"
"496.84883432553846\n"
msgstr ""
"julia> x = rand(1000);\n"
"\n"
"julia> function sum_arg(x)\n"
"           s = 0.0\n"
"           for i in x\n"
"               s += i\n"
"           end\n"
"           return s\n"
"       end;\n"
"\n"
"julia> @time sum_arg(x)\n"
"  0.007701 seconds (821 allocations: 43.059 KiB)\n"
"496.84883432553846\n"
"\n"
"julia> @time sum_arg(x)\n"
"  0.000006 seconds (5 allocations: 176 bytes)\n"
"496.84883432553846\n"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:119
msgid ""
"The 5 allocations seen are from running the `@time` macro itself in global scope. If we instead run the timing in a function, we can see "
"that indeed no allocations are performed:"
msgstr ""
"ããã§è¦ããã5 ã¤ã®ã¡ã¢ãªå²ãå½ã¦ã¯ãã°ã­ã¼ãã« ã¹ã³ã¼ãã§ `@time`ãã¯ã­èªä½ã®å®è¡ãããããã®ã§ããä»£ããã«é¢æ°åã§æéæ¸¬å®ãå®è¡ããã¨ãå®"
"éã«é¢æ°åé¨ã§ã¯ã¡ã¢ãªå²ãå½ã¦ãå®è¡ããã¦ããªããã¨ããããã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/performance-tips.md:120
#, no-wrap
msgid "jldoctest sumarg; filter = r\"[0-9\\.]+ seconds\""
msgstr "jldoctest sumarg; filter = r\"[0-9\\.]+ seconds\""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:120
#, no-wrap
msgid ""
"julia> time_sum(x) = @time sum_arg(x);\n"
"\n"
"julia> time_sum(x)\n"
"  0.000001 seconds\n"
"496.84883432553846\n"
msgstr ""
"julia> time_sum(x) = @time sum_arg(x);\n"
"\n"
"julia> time_sum(x)\n"
"  0.000001 seconds\n"
"496.84883432553846\n"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:132
msgid ""
"In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In "
"such cases, consider using one of the [tools](@ref tools)  below to diagnose problems, or write a version of your function that separates "
"allocation from its algorithmic aspects (see [Pre-allocating outputs](@ref))."
msgstr ""
"ç¶æ³ã«ãã£ã¦ã¯ãå¿è¦ãªæä½ã®ä¸é¨ã¨ãã¦é¢æ°ã§ã¡ã¢ãªãå²ãå½ã¦ãå¿è¦ã«ãªãããããã¾ããããã®ã¨ãã«ã¯ãä¸è¿°ã®ä¸è¨ã®åç´ãªã¤ã¡ã¼ã¸ããè¤éã«ãª"
"ãå¯è½æ§ãããã¾ãããã®ãããªå ´åã¯ãä»¥ä¸ã® [ãã¼ã«] (@ref tools) ã®ãããããä½¿ç¨ãã¦åé¡ãè¨ºæ­ããããã¡ã¢ãªå²ãå½ã¦ãã¢ã«ã´ãªãºã çãªå´é¢"
"ããåé¢ãããã¼ã¸ã§ã³ã®é¢æ°ãä½ããã¨ãæ¤è¨ãã¦ãã ãã ([åºåã®äºåå²å½](@ref Pre-allocating-outputs)åç§)ã"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:136
#, no-wrap
msgid ""
"!!! note\n"
"    For more serious benchmarking, consider the [BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl)\n"
"    package which among other things evaluates the function multiple times in order to reduce noise.\n"
msgstr ""
"!!!ã¡ã¢\n"
"    ãããã£ããã¨ãã³ããã¼ã¯ãã¨ãããå ´åã¯ã[BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl)ããã±ã¼ã¸ãæ¤è¨ãã¦ãã ããã\n"
"    ã¨ããããæ¸¬å®å¯¾è±¡ä»¥å¤ã®å¦çã®å®è¡ã«èµ·å ãããã¤ãºãä½æ¸ãããããé¢æ°ãè¤æ°åè©ä¾¡ãã¦ããã¾ãã\n"

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:137
#, no-wrap
msgid "[Tools](@id tools)"
msgstr "[ãã¼ã«](@id tools)"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:141
msgid "Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:"
msgstr "Julia ã¨ãã®ããã±ã¼ã¸ ã¨ã³ã·ã¹ãã ã«ã¯ãåé¡ã®è¨ºæ­ã¨ã³ã¼ãã®ããã©ã¼ãã³ã¹ã®åä¸ã«å½¹ç«ã¤ãã¼ã«ãå«ã¾ãã¦ãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:153
msgid ""
"[Profiling](@ref) allows you to measure the performance of your running code and identify lines that serve as bottlenecks. For complex "
"projects, the [ProfileView](https://github.com/timholy/ProfileView.jl)  package can help you visualize your profiling results."
msgstr ""
"[Profiling](@ref Profiling) ãä½¿ç¨ããã¨ãå®è¡ä¸­ã®ã³ã¼ãã®ããã©ã¼ãã³ã¹ãæ¸¬å®ããããã«ããã¯ã¨ãªãè¡ãç¹å®ã§ãã¾ããè¤éãªãã­ã¸ã§ã¯ãã®å ´"
"åã[ProfileView](https://github.com/timholy/ProfileView.jl)ããã±ã¼ã¸ã¯ããã­ãã¡ã¤ãªã³ã°çµæãè¦è¦åããã«å½¹ç«ã¡ã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:153
msgid "The [Traceur](https://github.com/MikeInnes/Traceur.jl) package can help you find common performance problems in your code."
msgstr "[Traceur](https://github.com/MikeInnes/Traceur.jl)ããã±ã¼ã¸ã¯ãã³ã¼ãåã®ä¸è¬çãªããã©ã¼ãã³ã¹ä¸ã®åé¡ãè¦ã¤ããã®ã«å½¹ç«ã¡ã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:153
#, no-wrap
msgid ""
"  * Unexpectedly-large memory allocations--as reported by [`@time`](@ref), [`@allocated`](@ref), or\n"
"    the profiler (through calls to the garbage-collection routines)--hint that there might be issues\n"
"    with your code. If you don't see another reason for the allocations, suspect a type problem.\n"
"     You can also start Julia with the `--track-allocation=user` option and examine the resulting\n"
"    `*.mem` files to see information about where those allocations occur. See [Memory allocation analysis](@ref).\n"
"  * `@code_warntype` generates a representation of your code that can be helpful in finding expressions\n"
"    that result in type uncertainty. See [`@code_warntype`](@ref) below.\n"
msgstr ""
"  * äºæ³å¤ã«å¤§ããªã¡ã¢ãªå²ãå½ã¦ãããã¯[`@time`](@ref)ã[`@allocated`](@ref)ãã¾ãã¯ãã­ãã¡ã¤ã©ã¼ (ã¬ãã¼ã¸ ã³ã¬ã¯ã·ã§ã³ ã«ã¼ãã³ã®å¼ã³åºããéãã¦)ã«ããå ±åããããã®ã§ãããããªãã®ã³ã¼ãã«åé¡ãããå¯è½æ§ãç¤ºåãã¾ãã\n"
"     ãããã®äºæ³å¤ã®ã¡ã¢ãªå²å½ã«å¿å½ããããªãå ´åã¯ãåã®åé¡ãçã£ã¦ãã ããã\n"
"     ãããã¯ãJulia ã `--track-allocation=user`ãªãã·ã§ã³ãä»ãã¦å®è¡ãããã®çµæãèª¿ã¹ããã¨ãã§ãã¾ãã\n"
"    `*.mem`ãã¡ã¤ã«ã¯ããããã®å²ãå½ã¦ãçºçããå ´æã«é¢ããæå ±ãè¡¨ç¤ºãã¾ãã[ã¡ã¢ãªå²ãå½ã¦ã®åæ](@ref Memory-allocation-analysis)ãåç§ãã¦ãã ããã\n"
"  * `@code_warntype` ã¯ãã©ã®å¼ã§åã®ä¸ç¢ºå®æ§ãçããããè¦ã¤ããã®ã«å½¹ç«ã¤ãããªãããªãã®ã³ã¼ãã«ã¤ãã¦ã®æå ±ãçæãã¾ããä¸è¨ã®[`@code_warntype`](@ref)ãåç§ãã¦ãã ããã\n"

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:154
#, no-wrap
msgid "Avoid containers with abstract type parameters"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:158
msgid "When working with parameterized types, including arrays, it is best to avoid parameterizing with abstract types where possible."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:160
msgid "Consider the following:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:161
#, no-wrap
msgid ""
"julia> a = Real[]\n"
"0-element Array{Real,1}\n"
"\n"
"julia> push!(a, 1); push!(a, 2.0); push!(a, Ï)\n"
"3-element Array{Real,1}:\n"
" 1\n"
" 2.0\n"
" Ï\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:177
msgid ""
"Because `a` is a an array of abstract type [`Real`](@ref), it must be able to hold any `Real` value. Since `Real` objects can be of "
"arbitrary size and structure, `a` must be represented as an array of pointers to individually allocated `Real` objects. However, if we "
"instead only allow numbers of the same type, e.g. [`Float64`](@ref), to be stored in `a` these can be stored more efficiently:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:178
#, no-wrap
msgid ""
"julia> a = Float64[]\n"
"0-element Array{Float64,1}\n"
"\n"
"julia> push!(a, 1); push!(a, 2.0); push!(a,  Ï)\n"
"3-element Array{Float64,1}:\n"
" 1.0\n"
" 2.0\n"
" 3.141592653589793\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:191
msgid ""
"Assigning numbers into `a` will now convert them to `Float64` and `a` will be stored as a contiguous block of 64-bit floating-point values "
"that can be manipulated efficiently."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:193
msgid "See also the discussion under [Parametric Types](@ref)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:194
#, no-wrap
msgid "Type declarations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:200
msgid ""
"In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is *not* the case "
"in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a "
"few specific instances where declarations are helpful."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/performance-tips.md:201
#, no-wrap
msgid "Avoid fields with abstract type"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:204
msgid "Types can be declared without specifying the types of their fields:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/performance-tips.md:205 ext/julia/doc/src/manual/performance-tips.md:216
#, no-wrap
msgid "jldoctest myambig"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:205
#, no-wrap
msgid ""
"julia> struct MyAmbiguousType\n"
"           a\n"
"       end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:215
msgid ""
"This allows `a` to be of any type. This can often be useful, but it does have a downside: for objects of type `MyAmbiguousType`, the "
"compiler will not be able to generate high-performance code. The reason is that the compiler uses the types of objects, not their values, to "
"determine how to build code. Unfortunately, very little can be inferred about an object of type `MyAmbiguousType`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:216
#, no-wrap
msgid ""
"julia> b = MyAmbiguousType(\"Hello\")\n"
"MyAmbiguousType(\"Hello\")\n"
"\n"
"julia> c = MyAmbiguousType(17)\n"
"MyAmbiguousType(17)\n"
"\n"
"julia> typeof(b)\n"
"MyAmbiguousType\n"
"\n"
"julia> typeof(c)\n"
"MyAmbiguousType\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:235
msgid ""
"The values of `b` and `c` have the same type, yet their underlying representation of data in memory is very different. Even if you stored "
"just numeric values in field `a`, the fact that the memory representation of a [`UInt8`](@ref) differs from a [`Float64`](@ref) also means "
"that the CPU needs to handle them using two different kinds of instructions. Since the required information is not available in the type, "
"such decisions have to be made at run-time. This slows performance."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:238
msgid ""
"You can do better by declaring the type of `a`. Here, we are focused on the case where `a` might be any one of several types, in which case "
"the natural solution is to use parameters. For example:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/performance-tips.md:239 ext/julia/doc/src/manual/performance-tips.md:247
#: ext/julia/doc/src/manual/performance-tips.md:256 ext/julia/doc/src/manual/performance-tips.md:273
#: ext/julia/doc/src/manual/performance-tips.md:286 ext/julia/doc/src/manual/performance-tips.md:301
#, no-wrap
msgid "jldoctest myambig2"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:239
#, no-wrap
msgid ""
"julia> mutable struct MyType{T<:AbstractFloat}\n"
"           a::T\n"
"       end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:246
msgid "This is a better choice than"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:247
#, no-wrap
msgid ""
"julia> mutable struct MyStillAmbiguousType\n"
"           a::AbstractFloat\n"
"       end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:255
msgid "because the first version specifies the type of `a` from the type of the wrapper object. For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:256
#, no-wrap
msgid ""
"julia> m = MyType(3.2)\n"
"MyType{Float64}(3.2)\n"
"\n"
"julia> t = MyStillAmbiguousType(3.2)\n"
"MyStillAmbiguousType(3.2)\n"
"\n"
"julia> typeof(m)\n"
"MyType{Float64}\n"
"\n"
"julia> typeof(t)\n"
"MyStillAmbiguousType\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:272
msgid ""
"The type of field `a` can be readily determined from the type of `m`, but not from the type of `t`. Indeed, in `t` it's possible to change "
"the type of the field `a`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:273
#, no-wrap
msgid ""
"julia> typeof(t.a)\n"
"Float64\n"
"\n"
"julia> t.a = 4.5f0\n"
"4.5f0\n"
"\n"
"julia> typeof(t.a)\n"
"Float32\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:285
msgid "In contrast, once `m` is constructed, the type of `m.a` cannot change:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:286
#, no-wrap
msgid ""
"julia> m.a = 4.5f0\n"
"4.5f0\n"
"\n"
"julia> typeof(m.a)\n"
"Float64\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:297
msgid ""
"The fact that the type of `m.a` is known from `m`'s typeâcoupled with the fact that its type cannot change mid-functionâallows the compiler "
"to generate highly-optimized code for objects like `m` but not for objects like `t`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:300
msgid ""
"Of course, all of this is true only if we construct `m` with a concrete type. We can break this by explicitly constructing it with an "
"abstract type:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:301
#, no-wrap
msgid ""
"julia> m = MyType{AbstractFloat}(3.2)\n"
"MyType{AbstractFloat}(3.2)\n"
"\n"
"julia> typeof(m.a)\n"
"Float64\n"
"\n"
"julia> m.a = 4.5f0\n"
"4.5f0\n"
"\n"
"julia> typeof(m.a)\n"
"Float32\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:316
msgid "For all practical purposes, such objects behave identically to those of `MyStillAmbiguousType`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:318
msgid "It's quite instructive to compare the sheer amount code generated for a simple function"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:319
#, no-wrap
msgid "func(m::MyType) = m.a+1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:324
msgid "using"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:325
#, no-wrap
msgid ""
"code_llvm(func, Tuple{MyType{Float64}})\n"
"code_llvm(func, Tuple{MyType{AbstractFloat}})\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:333
msgid ""
"For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the "
"first case, the compiler doesn't need to generate any code to resolve the type at run-time. This results in shorter and faster code."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/performance-tips.md:334
#, no-wrap
msgid "Avoid fields with abstract containers"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:337
msgid "The same best practices also work for container types:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/performance-tips.md:338 ext/julia/doc/src/manual/performance-tips.md:350
#: ext/julia/doc/src/manual/performance-tips.md:379 ext/julia/doc/src/manual/performance-tips.md:402
#: ext/julia/doc/src/manual/performance-tips.md:419
#, no-wrap
msgid "jldoctest containers"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:338
#, no-wrap
msgid ""
"julia> struct MySimpleContainer{A<:AbstractVector}\n"
"           a::A\n"
"       end\n"
"\n"
"julia> struct MyAmbiguousContainer{T}\n"
"           a::AbstractVector{T}\n"
"       end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:350
#, no-wrap
msgid ""
"julia> c = MySimpleContainer(1:3);\n"
"\n"
"julia> typeof(c)\n"
"MySimpleContainer{UnitRange{Int64}}\n"
"\n"
"julia> c = MySimpleContainer([1:3;]);\n"
"\n"
"julia> typeof(c)\n"
"MySimpleContainer{Array{Int64,1}}\n"
"\n"
"julia> b = MyAmbiguousContainer(1:3);\n"
"\n"
"julia> typeof(b)\n"
"MyAmbiguousContainer{Int64}\n"
"\n"
"julia> b = MyAmbiguousContainer([1:3;]);\n"
"\n"
"julia> typeof(b)\n"
"MyAmbiguousContainer{Int64}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:374
msgid ""
"For `MySimpleContainer`, the object is fully-specified by its type and parameters, so the compiler can generate optimized functions. In most "
"instances, this will probably suffice."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:378
msgid ""
"While the compiler can now do its job perfectly well, there are cases where *you* might wish that your code could do different things "
"depending on the *element type* of `a`. Usually the best way to achieve this is to wrap your specific operation (here, `foo`) in a separate "
"function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:379
#, no-wrap
msgid ""
"julia> function sumfoo(c::MySimpleContainer)\n"
"           s = 0\n"
"           for x in c.a\n"
"               s += foo(x)\n"
"           end\n"
"           s\n"
"       end\n"
"sumfoo (generic function with 1 method)\n"
"\n"
"julia> foo(x::Integer) = x\n"
"foo (generic function with 1 method)\n"
"\n"
"julia> foo(x::AbstractFloat) = round(x)\n"
"foo (generic function with 2 methods)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:397
msgid "This keeps things simple, while allowing the compiler to generate optimized code in all cases."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:401
msgid ""
"However, there are cases where you may need to declare different versions of the outer function for different element types or types of the "
"`AbstractVector` of the field `a` in `MySimpleContainer`.  You could do it like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:402
#, no-wrap
msgid ""
"julia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:Integer}})\n"
"           return c.a[1]+1\n"
"       end\n"
"myfunc (generic function with 1 method)\n"
"\n"
"julia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:AbstractFloat}})\n"
"           return c.a[1]+2\n"
"       end\n"
"myfunc (generic function with 2 methods)\n"
"\n"
"julia> function myfunc(c::MySimpleContainer{Vector{T}}) where T <: Integer\n"
"           return c.a[1]+3\n"
"       end\n"
"myfunc (generic function with 3 methods)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:419
#, no-wrap
msgid ""
"julia> myfunc(MySimpleContainer(1:3))\n"
"2\n"
"\n"
"julia> myfunc(MySimpleContainer(1.0:3))\n"
"3.0\n"
"\n"
"julia> myfunc(MySimpleContainer([1:3;]))\n"
"4\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/performance-tips.md:430
#, no-wrap
msgid "Annotate values taken from untyped locations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:435
msgid ""
"It is often convenient to work with data structures that may contain values of any type (arrays of type `Array{Any}`). But, if you're using "
"one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:436
#, no-wrap
msgid ""
"function foo(a::Array{Any,1})\n"
"    x = a[1]::Int32\n"
"    b = x+1\n"
"    ...\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:447
msgid ""
"Here, we happened to know that the first element of `a` would be an [`Int32`](@ref). Making an annotation like this has the added benefit "
"that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:455
msgid ""
"In the case that the type of `a[1]` is not known precisely, `x` can be declared via `x = convert(Int32, a[1])::Int32`. The use of the "
"[`convert`](@ref) function allows `a[1]` to be any object convertible to an `Int32` (such as `UInt8`), thus increasing the genericity of the "
"code by loosening the type requirement. Notice that `convert` itself needs a type annotation in this context in order to achieve type "
"stability. This is because the compiler cannot deduce the type of the return value of a function, even `convert`, unless the types of all "
"the function's arguments are known."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:459
msgid ""
"Type annotation will not enhance (and can actually hinder) performance if the type is constructed at run-time. This is because the compiler "
"cannot use the annotation to specialize the subsequent code, and the type-check itself takes time. For example, in the code:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:460
#, no-wrap
msgid ""
"function nr(a, prec)\n"
"    ctype = prec == 32 ? Float32 : Float64\n"
"    b = Complex{ctype}(a)\n"
"    c = (b + 1.0f0)::Complex{ctype}\n"
"    abs(c)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:476
msgid ""
"the annotation of `c` harms performance. To write performant code involving types constructed at run-time, use the [function-barrier "
"technique](@ref kernel-functions) discussed below, and ensure that the constructed type appears among the argument types of the kernel "
"function so that the kernel operations are properly specialized by the compiler. For example, in the above snippet, as soon as `b` is "
"constructed, it can be passed to another function `k`, the kernel. If, for example, function `k` declares `b` as an argument of type "
"`Complex{T}`, where `T` is a type parameter, then a type annotation appearing in an assignment statement within `k` of the form:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:477
#, no-wrap
msgid "c = (b + 1.0f0)::Complex{T}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:483
msgid "does not hinder performance (but does not help either) since the compiler can determine the type of `c` at the time `k` is compiled."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:484
#, no-wrap
msgid "Break functions into multiple definitions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:488
msgid "Writing a function as many small definitions allows the compiler to directly call the most applicable code, or even inline it."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:490
msgid "Here is an example of a \"compound function\" that should really be written as multiple definitions:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:491
#, no-wrap
msgid ""
"using LinearAlgebra\n"
"\n"
"function mynorm(A)\n"
"    if isa(A, Vector)\n"
"        return sqrt(real(dot(A,A)))\n"
"    elseif isa(A, Matrix)\n"
"        return maximum(svdvals(A))\n"
"    else\n"
"        error(\"mynorm: invalid argument\")\n"
"    end\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:506
msgid "This can be written more concisely and efficiently as:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:507
#, no-wrap
msgid ""
"norm(x::Vector) = sqrt(real(dot(x, x)))\n"
"norm(A::Matrix) = maximum(svdvals(A))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:514
msgid ""
"It should however be noted that the compiler is quite efficient at optimizing away the dead branches in code written as the `mynorm` example."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:515
#, no-wrap
msgid "Write \"type-stable\" functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:519
msgid "When possible, it helps to ensure that a function always returns a value of the same type. Consider the following definition:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:520
#, no-wrap
msgid "pos(x) = x < 0 ? 0 : x\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:528
msgid ""
"Although this seems innocent enough, the problem is that `0` is an integer (of type `Int`) and `x` might be of any type. Thus, depending on "
"the value of `x`, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. "
"But it can easily be fixed as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:529
#, no-wrap
msgid "pos(x) = x < 0 ? zero(x) : x\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:535
msgid ""
"There is also a [`oneunit`](@ref) function, and a more general [`oftype(x, y)`](@ref) function, which returns `y` converted to the type of "
"`x`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:536
#, no-wrap
msgid "Avoid changing the type of a variable"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:539
msgid "An analogous \"type-stability\" problem exists for variables used repeatedly within a function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:540
#, no-wrap
msgid ""
"function foo()\n"
"    x = 1\n"
"    for i = 1:10\n"
"        x /= rand()\n"
"    end\n"
"    return x\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:553
msgid ""
"Local variable `x` starts as an integer, and after one loop iteration becomes a floating-point number (the result of [`/`](@ref) operator). "
"This makes it more difficult for the compiler to optimize the body of the loop. There are several possible fixes:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:558
msgid "Initialize `x` with `x = 1.0`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:558
msgid "Declare the type of `x`: `x::Float64 = 1`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:558
msgid "Use an explicit conversion: `x = oneunit(Float64)`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:558
msgid "Initialize with the first loop iteration, to `x = 1 / rand()`, then loop `for i = 2:10`"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:559
#, no-wrap
msgid "[Separate kernel functions (aka, function barriers)](@id kernel-functions)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:565
msgid ""
"Many functions follow a pattern of performing some set-up work, and then running many iterations to perform a core computation. Where "
"possible, it is a good idea to put these core computations in separate functions. For example, the following contrived function returns an "
"array of a randomly-chosen type:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/performance-tips.md:566 ext/julia/doc/src/manual/performance-tips.md:584
#, no-wrap
msgid "jldoctest; setup = :(using Random; Random.seed!(1234))"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:566
#, no-wrap
msgid ""
"julia> function strange_twos(n)\n"
"           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\n"
"           for i = 1:n\n"
"               a[i] = 2\n"
"           end\n"
"           return a\n"
"       end;\n"
"\n"
"julia> strange_twos(3)\n"
"3-element Array{Float64,1}:\n"
" 2.0\n"
" 2.0\n"
" 2.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:583
msgid "This should be written as:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:584
#, no-wrap
msgid ""
"julia> function fill_twos!(a)\n"
"           for i = eachindex(a)\n"
"               a[i] = 2\n"
"           end\n"
"       end;\n"
"\n"
"julia> function strange_twos(n)\n"
"           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\n"
"           fill_twos!(a)\n"
"           return a\n"
"       end;\n"
"\n"
"julia> strange_twos(3)\n"
"3-element Array{Float64,1}:\n"
" 2.0\n"
" 2.0\n"
" 2.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:608
msgid ""
"Julia's compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of "
"`a` during the loop (since it is chosen randomly).  Therefore the second version is generally faster since the inner loop can be recompiled "
"as part of `fill_twos!` for different types of `a`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:610
msgid "The second form is also often better style and can lead to more code reuse."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:614
msgid ""
"This pattern is used in several places in Julia Base. For example, see `vcat` and `hcat` in [`abstractarray.jl`](https://github.com/"
"JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206), or the [`fill!`](@ref) function, which we "
"could have used instead of writing our own `fill_twos!`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:617
msgid ""
"Functions like `strange_twos` occur when dealing with data of uncertain type, for example data loaded from an input file that might contain "
"either integers, floats, strings, or something else."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:618
#, no-wrap
msgid "Types with values-as-parameters"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:622
msgid "Let's say you want to create an `N`-dimensional array that has size 3 along each axis. Such arrays can be created like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:623
#, no-wrap
msgid ""
"julia> A = fill(5.0, (3, 3))\n"
"3Ã3 Array{Float64,2}:\n"
" 5.0  5.0  5.0\n"
" 5.0  5.0  5.0\n"
" 5.0  5.0  5.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:635
msgid ""
"This approach works very well: the compiler can figure out that `A` is an `Array{Float64,2}` because it knows the type of the fill value "
"(`5.0::Float64`) and the dimensionality (`(3, 3)::NTuple{2,Int}`).  This implies that the compiler can generate very efficient code for any "
"future usage of `A` in the same function."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:638
msgid ""
"But now let's say you want to write a function that creates a 3Ã3Ã... array in arbitrary dimensions; you might be tempted to write a function"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:639
#, no-wrap
msgid ""
"julia> function array3(fillval, N)\n"
"           fill(fillval, ntuple(d->3, N))\n"
"       end\n"
"array3 (generic function with 1 method)\n"
"\n"
"julia> array3(5.0, 2)\n"
"3Ã3 Array{Float64,2}:\n"
" 5.0  5.0  5.0\n"
" 5.0  5.0  5.0\n"
" 5.0  5.0  5.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:657
msgid ""
"This works, but (as you can verify for yourself using `@code_warntype array3(5.0, 2)`) the problem is that the output type cannot be "
"inferred: the argument `N` is a *value* of type `Int`, and type-inference does not (and cannot) predict its value in advance. This means "
"that code using the output of this function has to be conservative, checking the type on each access of `A`; such code will be very slow."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:662
msgid ""
"Now, one very good way to solve such problems is by using the [function-barrier technique](@ref kernel-functions).  However, in some cases "
"you might want to eliminate the type-instability altogether. In such cases, one approach is to pass the dimensionality as a parameter, for "
"example through `Val{T}()` (see [\"Value types\"](@ref)):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:663
#, no-wrap
msgid ""
"julia> function array3(fillval, ::Val{N}) where N\n"
"           fill(fillval, ntuple(d->3, Val(N)))\n"
"       end\n"
"array3 (generic function with 1 method)\n"
"\n"
"julia> array3(5.0, Val(2))\n"
"3Ã3 Array{Float64,2}:\n"
" 5.0  5.0  5.0\n"
" 5.0  5.0  5.0\n"
" 5.0  5.0  5.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:679
msgid ""
"Julia has a specialized version of `ntuple` that accepts a `Val{::Int}` instance as the second parameter; by passing `N` as a type-"
"parameter, you make its \"value\" known to the compiler.  Consequently, this version of `array3` allows the compiler to predict the return "
"type."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:682
msgid ""
"However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called `array3` from a "
"function like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:683
#, no-wrap
msgid ""
"function call_array3(fillval, n)\n"
"    A = array3(fillval, Val(n))\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:694
msgid ""
"Here, you've created the same problem all over again: the compiler can't guess what `n` is, so it doesn't know the *type* of `Val(n)`. "
"Attempting to use `Val`, but doing so incorrectly, can easily make performance *worse* in many situations. (Only in situations where you're "
"effectively combining `Val` with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:696
msgid "An example of correct usage of `Val` would be:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:697
#, no-wrap
msgid ""
"function filter3(A::AbstractArray{T,N}) where {T,N}\n"
"    kernel = array3(1, Val(N))\n"
"    filter(A, kernel)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:707
msgid ""
"In this example, `N` is passed as a parameter, so its \"value\" is known to the compiler. Essentially, `Val(T)` works only when `T` is "
"either hard-coded/literal (`Val(3)`) or already specified in the type-domain."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:708
#, no-wrap
msgid "The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:713
msgid ""
"Once one learns to appreciate multiple dispatch, there's an understandable tendency to go overboard and try to use it for everything. For "
"example, you might imagine using it to store information, e.g."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:714
#, no-wrap
msgid ""
"struct Car{Make, Model}\n"
"    year::Int\n"
"    ...more fields...\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:722
msgid "and then dispatch on objects like `Car{:Honda,:Accord}(year, args...)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:724
msgid "This might be worthwhile when either of the following are true:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:730
msgid ""
"You require CPU-intensive processing on each `Car`, and it becomes vastly more efficient if you know the `Make` and `Model` at compile time "
"and the total number of different `Make` or `Model` that will be used is not too large."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:730
msgid "You have homogenous lists of the same type of `Car` to process, so that you can store them all in an `Array{Car{:Honda,:Accord},N}`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:735
msgid ""
"When the latter holds, a function processing such a homogenous array can be productively specialized: Julia knows the type of each element "
"in advance (all objects in the container have the same concrete type), so Julia can \"look up\" the correct method calls when the function "
"is being compiled (obviating the need to check at run-time) and thereby emit efficient code for processing the whole list."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:743
msgid ""
"When these do not hold, then it's likely that you'll get no benefit; worse, the resulting \"combinatorial explosion of types\" will be "
"counterproductive. If `items[i+1]` has a different type than `item[i]`, Julia has to look up the type at run-time, search for the "
"appropriate method in method tables, decide (via type intersection) which one matches, determine whether it has been JIT-compiled yet (and "
"do so if not), and then make the call. In essence, you're asking the full type- system and JIT-compilation machinery to basically execute "
"the equivalent of a switch statement or dictionary lookup in your own code."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:746
msgid ""
"Some run-time benchmarks comparing (1) type dispatch, (2) dictionary lookup, and (3) a \"switch\" statement can be found [on the mailing "
"list](https://groups.google.com/forum/#!msg/julia-users/jUMu9A3QKQQ/qjgVWr7vAwAJ)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:754
msgid ""
"Perhaps even worse than the run-time impact is the compile-time impact: Julia will compile specialized functions for each different "
"`Car{Make, Model}`; if you have hundreds or thousands of such types, then every function that accepts such an object as a parameter (from a "
"custom `get_year` function you might write yourself, to the generic `push!` function in Julia Base) will have hundreds or thousands of "
"variants compiled for it. Each of these increases the size of the cache of compiled code, the length of internal lists of methods, etc. "
"Excess enthusiasm for values-as-parameters can easily waste enormous resources."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:755
#, no-wrap
msgid "Access arrays in memory order, along columns"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:760
msgid ""
"Multidimensional arrays in Julia are stored in column-major order. This means that arrays are stacked one column at a time. This can be "
"verified using the `vec` function or the syntax `[:]` as shown below (notice that the array is ordered `[1 3 2 4]`, not `[1 2 3 4]`):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:761
#, no-wrap
msgid ""
"julia> x = [1 2; 3 4]\n"
"2Ã2 Array{Int64,2}:\n"
" 1  2\n"
" 3  4\n"
"\n"
"julia> x[:]\n"
"4-element Array{Int64,1}:\n"
" 1\n"
" 3\n"
" 2\n"
" 4\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:781
msgid ""
"This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major "
"ordering is row-major ordering, which is the convention adopted by C and Python (`numpy`) among other languages. Remembering the ordering of "
"arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, "
"the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear "
"in a slice expression."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:787
msgid ""
"Consider the following contrived example. Imagine we wanted to write a function that accepts a [`Vector`](@ref) and returns a square "
"[`Matrix`](@ref) with either the rows or the columns filled with copies of the input vector. Assume that it is not important whether rows or "
"columns are filled with these copies (perhaps the rest of the code can be easily adapted accordingly). We could conceivably do this in at "
"least four ways (in addition to the recommended call to the built-in [`repeat`](@ref)):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:788
#, no-wrap
msgid ""
"function copy_cols(x::Vector{T}) where T\n"
"    inds = axes(x, 1)\n"
"    out = similar(Array{T}, inds, inds)\n"
"    for i = inds\n"
"        out[:, i] = x\n"
"    end\n"
"    return out\n"
"end\n"
"\n"
"function copy_rows(x::Vector{T}) where T\n"
"    inds = axes(x, 1)\n"
"    out = similar(Array{T}, inds, inds)\n"
"    for i = inds\n"
"        out[i, :] = x\n"
"    end\n"
"    return out\n"
"end\n"
"\n"
"function copy_col_row(x::Vector{T}) where T\n"
"    inds = axes(x, 1)\n"
"    out = similar(Array{T}, inds, inds)\n"
"    for col = inds, row = inds\n"
"        out[row, col] = x[row]\n"
"    end\n"
"    return out\n"
"end\n"
"\n"
"function copy_row_col(x::Vector{T}) where T\n"
"    inds = axes(x, 1)\n"
"    out = similar(Array{T}, inds, inds)\n"
"    for row = inds, col = inds\n"
"        out[row, col] = x[col]\n"
"    end\n"
"    return out\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:827
msgid "Now we will time each of these functions using the same random `10000` by `1` input vector:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:828
#, no-wrap
msgid ""
"julia> x = randn(10000);\n"
"\n"
"julia> fmt(f) = println(rpad(string(f)*\": \", 14, ' '), @elapsed f(x))\n"
"\n"
"julia> map(fmt, [copy_cols, copy_rows, copy_col_row, copy_row_col]);\n"
"copy_cols:    0.331706323\n"
"copy_rows:    1.799009911\n"
"copy_col_row: 0.415630047\n"
"copy_row_col: 1.721531501\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:844
msgid ""
"Notice that `copy_cols` is much faster than `copy_rows`. This is expected because `copy_cols` respects the column-based memory layout of the "
"`Matrix` and fills it one column at a time. Additionally, `copy_col_row` is much faster than `copy_row_col` because it follows our rule of "
"thumb that the first element to appear in a slice expression should be coupled with the inner-most loop."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:845
#, no-wrap
msgid "Pre-allocating outputs"
msgstr "[åºåã®äºåå²å½](@id Pre-allocating-outputs)"

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:849
msgid ""
"If your function returns an `Array` or some other complex type, it may have to allocate memory.  Unfortunately, oftentimes allocation and "
"its converse, garbage collection, are substantial bottlenecks."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:852
msgid ""
"Sometimes you can circumvent the need to allocate memory on each function call by preallocating the output. As a trivial example, compare"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/performance-tips.md:853 ext/julia/doc/src/manual/performance-tips.md:870
#, no-wrap
msgid "jldoctest prealloc"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:853
#, no-wrap
msgid ""
"julia> function xinc(x)\n"
"           return [x, x+1, x+2]\n"
"       end;\n"
"\n"
"julia> function loopinc()\n"
"           y = 0\n"
"           for i = 1:10^7\n"
"               ret = xinc(i)\n"
"               y += ret[2]\n"
"           end\n"
"           return y\n"
"       end;\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:869
msgid "with"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:870
#, no-wrap
msgid ""
"julia> function xinc!(ret::AbstractVector{T}, x::T) where T\n"
"           ret[1] = x\n"
"           ret[2] = x+1\n"
"           ret[3] = x+2\n"
"           nothing\n"
"       end;\n"
"\n"
"julia> function loopinc_prealloc()\n"
"           ret = Vector{Int}(undef, 3)\n"
"           y = 0\n"
"           for i = 1:10^7\n"
"               xinc!(ret, i)\n"
"               y += ret[2]\n"
"           end\n"
"           return y\n"
"       end;\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:890
msgid "Timing results:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/performance-tips.md:891
#, no-wrap
msgid "jldoctest prealloc; filter = r\"[0-9\\.]+ seconds \\(.*?\\)\""
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:891
#, no-wrap
msgid ""
"julia> @time loopinc()\n"
"  0.529894 seconds (40.00 M allocations: 1.490 GiB, 12.14% gc time)\n"
"50000015000000\n"
"\n"
"julia> @time loopinc_prealloc()\n"
"  0.030850 seconds (6 allocations: 288 bytes)\n"
"50000015000000\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:904
msgid ""
"Preallocation has other advantages, for example by allowing the caller to control the \"output\" type from an algorithm. In the example "
"above, we could have passed a `SubArray` rather than an [`Array`](@ref), had we so desired."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:909
msgid ""
"Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some judgment may be required. However, for "
"\"vectorized\" (element-wise) functions, the convenient syntax `x .= f.(y)` can be used for in-place operations with fused loops and no "
"temporary arrays (see the [dot syntax for vectorizing functions](@ref man-vectorized))."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:910
#, no-wrap
msgid "More dots: Fuse vectorized operations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:919
msgid ""
"Julia has a special [dot syntax](@ref man-vectorized) that converts any scalar function into a \"vectorized\" function call, and any "
"operator into a \"vectorized\" operator, with the special property that nested \"dot calls\" are *fusing*: they are combined at the syntax "
"level into a single loop, without allocating temporary arrays. If you use `.=` and similar assignment operators, the result can also be "
"stored in-place in a pre-allocated array (see above)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:925
msgid ""
"In a linear-algebra context, this means that even though operations like `vector + vector` and `vector * scalar` are defined, it can be "
"advantageous to instead use `vector .+ vector` and `vector .* scalar` because the resulting loops can be fused with surrounding "
"computations. For example, consider the two functions:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/performance-tips.md:926
#, no-wrap
msgid "jldoctest dotfuse"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:926
#, no-wrap
msgid ""
"julia> f(x) = 3x.^2 + 4x + 7x.^3;\n"
"\n"
"julia> fdot(x) = @. 3x^2 + 4x + 7x^3 # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3;\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:935
msgid ""
"Both `f` and `fdot` compute the same thing. However, `fdot` (defined with the help of the [`@.`](@ref @__dot__) macro) is significantly "
"faster when applied to an array:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/performance-tips.md:936
#, no-wrap
msgid "jldoctest dotfuse; filter = r\"[0-9\\.]+ seconds \\(.*?\\)\""
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:936
#, no-wrap
msgid ""
"julia> x = rand(10^6);\n"
"\n"
"julia> @time f(x);\n"
"  0.019049 seconds (16 allocations: 45.777 MiB, 18.59% gc time)\n"
"\n"
"julia> @time fdot(x);\n"
"  0.002790 seconds (6 allocations: 7.630 MiB)\n"
"\n"
"julia> @time f.(x);\n"
"  0.002626 seconds (8 allocations: 7.630 MiB)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:956
msgid ""
"That is, `fdot(x)` is ten times faster and allocates 1/6 the memory of `f(x)`, because each `*` and `+` operation in `f(x)` allocates a new "
"temporary array and executes in a separate loop. (Of course, if you just do `f.(x)` then it is as fast as `fdot(x)` in this example, but in "
"many contexts it is more convenient to just sprinkle some dots in your expressions rather than defining a separate function for each "
"vectorized operation.)"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:957
#, no-wrap
msgid "Consider using views for slices"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:968
msgid ""
"In Julia, an array \"slice\" expression like `array[1:5, :]` creates a copy of that data (except on the left-hand side of an assignment, "
"where `array[1:5, :] = ...` assigns in-place to that portion of `array`).  If you are doing many operations on the slice, this can be good "
"for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array.  On "
"the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be "
"substantial."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:976
msgid ""
"An alternative is to create a \"view\" of the array, which is an array object (a `SubArray`) that actually references the data of the "
"original array in-place, without making a copy. (If you write to a view, it modifies the original array's data as well.)  This can be done "
"for individual slices by calling [`view`](@ref), or more simply for a whole expression or block of code by putting [`@views`](@ref) in front "
"of that expression. For example:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/performance-tips.md:977
#, no-wrap
msgid "jldoctest; filter = r\"[0-9\\.]+ seconds \\(.*?\\)\""
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:977
#, no-wrap
msgid ""
"julia> fcopy(x) = sum(x[2:end-1]);\n"
"\n"
"julia> @views fview(x) = sum(x[2:end-1]);\n"
"\n"
"julia> x = rand(10^6);\n"
"\n"
"julia> @time fcopy(x);\n"
"  0.003051 seconds (7 allocations: 7.630 MB)\n"
"\n"
"julia> @time fview(x);\n"
"  0.001020 seconds (6 allocations: 224 bytes)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:993
msgid "Notice both the 3Ã speedup and the decreased memory allocation of the `fview` version of the function."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:994
#, no-wrap
msgid "Copying data is not always bad"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1000
msgid ""
"Arrays are stored contiguously in memory, lending themselves to CPU vectorization and fewer memory accesses due to caching. These are the "
"same reasons that it is recommended to access arrays in column-major order (see above). Irregular access patterns and non-contiguous views "
"can drastically slow down computations on arrays because of non-sequential memory access."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1005
msgid ""
"Copying irregularly-accessed data into a contiguous array before operating on it can result in a large speedup, such as in the example "
"below. Here, a matrix and a vector are being accessed at 800,000 of their randomly-shuffled indices before being multiplied. Copying the "
"views into plain arrays speeds up the multiplication even with the cost of the copying operation."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1006
#, no-wrap
msgid ""
"julia> using Random\n"
"\n"
"julia> x = randn(1_000_000);\n"
"\n"
"julia> inds = shuffle(1:1_000_000)[1:800000];\n"
"\n"
"julia> A = randn(50, 1_000_000);\n"
"\n"
"julia> xtmp = zeros(800_000);\n"
"\n"
"julia> Atmp = zeros(50, 800_000);\n"
"\n"
"julia> @time sum(view(A, :, inds) * view(x, inds))\n"
"  0.412156 seconds (14 allocations: 960 bytes)\n"
"-4256.759568345458\n"
"\n"
"julia> @time begin\n"
"           copyto!(xtmp, view(x, inds))\n"
"           copyto!(Atmp, view(A, :, inds))\n"
"           sum(Atmp * xtmp)\n"
"       end\n"
"  0.285923 seconds (14 allocations: 960 bytes)\n"
"-4256.759568345134\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1034
msgid ""
"Provided there is enough memory for the copies, the cost of copying the view to an array is far outweighed by the speed boost from doing the "
"matrix multiplication on a contiguous array."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:1035
#, no-wrap
msgid "Avoid string interpolation for I/O"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1039
msgid "When writing data to a file (or other I/O device), forming extra intermediate strings is a source of overhead. Instead of:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1040
#, no-wrap
msgid "println(file, \"$a $b\")\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1045 ext/julia/doc/src/manual/style-guide.md:74 ext/julia/doc/src/manual/style-guide.md:103
msgid "use:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1046
#, no-wrap
msgid "println(file, a, \" \", b)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1053
msgid ""
"The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also "
"notice that in some cases string interpolation can be harder to read. Consider:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1054
#, no-wrap
msgid "println(file, \"$(f(a))$(f(b))\")\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1059
msgid "versus:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1060
#, no-wrap
msgid "println(file, f(a), f(b))\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:1064
#, no-wrap
msgid "Optimize network I/O during parallel execution"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1067
msgid "When executing a remote function in parallel:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1068
#, no-wrap
msgid ""
"using Distributed\n"
"\n"
"responses = Vector{Any}(undef, nworkers())\n"
"@sync begin\n"
"    for (idx, pid) in enumerate(workers())\n"
"        @async responses[idx] = remotecall_fetch(foo, pid, args...)\n"
"    end\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1080
msgid "is faster than:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1081
#, no-wrap
msgid ""
"using Distributed\n"
"\n"
"refs = Vector{Any}(undef, nworkers())\n"
"for (idx, pid) in enumerate(workers())\n"
"    refs[idx] = @spawnat pid foo(args...)\n"
"end\n"
"responses = [fetch(r) for r in refs]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1095
msgid ""
"The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the [`@spawnat`]"
"(@ref) and the second due to the [`fetch`](@ref)  (or even a [`wait`](@ref)).  The [`fetch`](@ref)/[`wait`](@ref) is also being executed "
"serially resulting in an overall poorer performance."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:1096
#, no-wrap
msgid "Fix deprecation warnings"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1101
msgid ""
"A deprecated function internally performs a lookup in order to print a relevant warning only once.  This extra lookup can cause a "
"significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:1102
#, no-wrap
msgid "Tweaks"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1105
msgid "These are some minor points that might help in tight inner loops."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:1111
msgid "Avoid unnecessary arrays. For example, instead of [`sum([x,y,z])`](@ref) use `x+y+z`."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:1111
msgid ""
"Use [`abs2(z)`](@ref) instead of [`abs(z)^2`](@ref) for complex `z`. In general, try to rewrite code to use [`abs2`](@ref) instead of [`abs`]"
"(@ref) for complex arguments."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:1111
msgid ""
"Use [`div(x,y)`](@ref) for truncating division of integers instead of [`trunc(x/y)`](@ref), [`fld(x,y)`](@ref)  instead of [`floor(x/y)`]"
"(@ref), and [`cld(x,y)`](@ref) instead of [`ceil(x/y)`](@ref)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:1112
#, no-wrap
msgid "[Performance Annotations](@id man-performance-annotations)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1115
msgid "Sometimes you can enable better optimization by promising certain program properties."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:1129
msgid ""
"Use [`@inbounds`](@ref) to eliminate array bounds checking within expressions. Be certain before doing this. If the subscripts are ever out "
"of bounds, you may suffer crashes or silent corruption."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:1129
msgid ""
"Use [`@fastmath`](@ref) to allow floating point optimizations that are correct for real numbers, but lead to differences for IEEE numbers. "
"Be careful when doing this, as this may change numerical results.  This corresponds to the `-ffast-math` option of clang."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/performance-tips.md:1129
msgid ""
"Write [`@simd`](@ref) in front of `for` loops to promise that the iterations are independent and may be reordered.  Note that in many cases, "
"Julia can automatically vectorize code without the `@simd` macro; it is only beneficial in cases where such a transformation would otherwise "
"be illegal, including cases like allowing floating-point re-associativity and ignoring dependent memory accesses (`@simd ivdep`).  Again, be "
"very careful when asserting `@simd` as erroneously annotating a loop with dependent iterations may result in unexpected results. In "
"particular, note that `setindex!` on some `AbstractArray` subtypes is inherently dependent upon iteration order. **This feature is "
"experimental** and could change or disappear in future versions of Julia."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1133
msgid ""
"The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing, and may cause a "
"segmentation fault if bounds checking is turned off. Use `LinearIndices(x)` or `eachindex(x)` instead (see also [offset-arrays](https://docs."
"julialang.org/en/latest/devdocs/offset-arrays/))."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1138
#, no-wrap
msgid ""
"!!! note\n"
"    While `@simd` needs to be placed directly in front of an innermost `for` loop, both `@inbounds` and `@fastmath`\n"
"    can be applied to either single expressions or all the expressions that appear within nested blocks of code, e.g.,\n"
"    using `@inbounds begin` or `@inbounds for ...`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1141
msgid ""
"Here is an example with both `@inbounds` and `@simd` markup (we here use `@noinline` to prevent the optimizer from trying to be too clever "
"and defeat our benchmark):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1142
#, no-wrap
msgid ""
"@noinline function inner(x, y)\n"
"    s = zero(eltype(x))\n"
"    for i=eachindex(x)\n"
"        @inbounds s += x[i]*y[i]\n"
"    end\n"
"    return s\n"
"end\n"
"\n"
"@noinline function innersimd(x, y)\n"
"    s = zero(eltype(x))\n"
"    @simd for i = eachindex(x)\n"
"        @inbounds s += x[i] * y[i]\n"
"    end\n"
"    return s\n"
"end\n"
"\n"
"function timeit(n, reps)\n"
"    x = rand(Float32, n)\n"
"    y = rand(Float32, n)\n"
"    s = zero(Float64)\n"
"    time = @elapsed for j in 1:reps\n"
"        s += inner(x, y)\n"
"    end\n"
"    println(\"GFlop/sec        = \", 2n*reps / time*1E-9)\n"
"    time = @elapsed for j in 1:reps\n"
"        s += innersimd(x, y)\n"
"    end\n"
"    println(\"GFlop/sec (SIMD) = \", 2n*reps / time*1E-9)\n"
"end\n"
"\n"
"timeit(1000, 1000)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1177
msgid "On a computer with a 2.4GHz Intel Core i5 processor, this produces:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1178
#, no-wrap
msgid ""
"GFlop/sec        = 1.9467069505224963\n"
"GFlop/sec (SIMD) = 17.578554163920018\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1184
msgid "(`GFlop/sec` measures the performance, and larger numbers are better.)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1187
msgid ""
"Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then "
"evaluates the L2-norm of the result:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1188
#, no-wrap
msgid ""
"function init!(u::Vector)\n"
"    n = length(u)\n"
"    dx = 1.0 / (n-1)\n"
"    @fastmath @inbounds @simd for i in 1:n #by asserting that `u` is a `Vector` we can assume it has 1-based indexing\n"
"        u[i] = sin(2pi*dx*i)\n"
"    end\n"
"end\n"
"\n"
"function deriv!(u::Vector, du)\n"
"    n = length(u)\n"
"    dx = 1.0 / (n-1)\n"
"    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx\n"
"    @fastmath @inbounds @simd for i in 2:n-1\n"
"        du[i] = (u[i+1] - u[i-1]) / (2*dx)\n"
"    end\n"
"    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx\n"
"end\n"
"\n"
"function mynorm(u::Vector)\n"
"    n = length(u)\n"
"    T = eltype(u)\n"
"    s = zero(T)\n"
"    @fastmath @inbounds @simd for i in 1:n\n"
"        s += u[i]^2\n"
"    end\n"
"    @fastmath @inbounds return sqrt(s)\n"
"end\n"
"\n"
"function main()\n"
"    n = 2000\n"
"    u = Vector{Float64}(undef, n)\n"
"    init!(u)\n"
"    du = similar(u)\n"
"\n"
"    deriv!(u, du)\n"
"    nu = mynorm(du)\n"
"\n"
"    @time for i in 1:10^6\n"
"        deriv!(u, du)\n"
"        nu = mynorm(du)\n"
"    end\n"
"\n"
"    println(nu)\n"
"end\n"
"\n"
"main()\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1238
msgid "On a computer with a 2.7 GHz Intel Core i7 processor, this produces:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1239
#, no-wrap
msgid ""
"$ julia wave.jl;\n"
"  1.207814709 seconds\n"
"4.443986180758249\n"
"\n"
"$ julia --math-mode=ieee wave.jl;\n"
"  4.487083643 seconds\n"
"4.443986180758249\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1250
msgid "Here, the option `--math-mode=ieee` disables the `@fastmath` macro, so that we can compare results."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1258
msgid ""
"In this case, the speedup due to `@fastmath` is a factor of about 3.7. This is unusually large â in general, the speedup will be smaller. "
"(In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory "
"access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, "
"in this case this optimization does not change the result â in general, the result will be slightly different. In some cases, especially for "
"numerically unstable algorithms, the result can be very different."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1267
msgid ""
"The annotation `@fastmath` re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special "
"cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression `1 / (2*dx)` in "
"the function `deriv` is hoisted out of the loop (i.e. calculated outside the loop), as if one had written `idx = 1 / (2*dx)`. In the loop, "
"the expression `... / (2*dx)` then becomes `... * idx`, which is much faster to evaluate. Of course, both the actual optimization that is "
"applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by "
"using Julia's [`code_native`](@ref) function."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1269
msgid "Note that `@fastmath` also assumes that `NaN`s will not occur during the computation, which can lead to surprising behavior:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1270
#, no-wrap
msgid ""
"julia> f(x) = isnan(x);\n"
"\n"
"julia> f(NaN)\n"
"true\n"
"\n"
"julia> f_fast(x) = @fastmath isnan(x);\n"
"\n"
"julia> f_fast(NaN)\n"
"false\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:1282
#, no-wrap
msgid "Treat Subnormal Numbers as Zeros"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1289
msgid ""
"Subnormal numbers, formerly called [denormal numbers](https://en.wikipedia.org/wiki/Denormal_number), are useful in many contexts, but incur "
"a performance penalty on some hardware. A call [`set_zero_subnormals(true)`](@ref)  grants permission for floating-point operations to treat "
"subnormal inputs or outputs as zeros, which may improve performance on some hardware. A call [`set_zero_subnormals(false)`](@ref) enforces "
"strict IEEE behavior for subnormal numbers."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1291
msgid "Below is an example where subnormals noticeably impact performance on some hardware:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1292
#, no-wrap
msgid ""
"function timestep(b::Vector{T}, a::Vector{T}, Ît::T) where T\n"
"    @assert length(a)==length(b)\n"
"    n = length(b)\n"
"    b[1] = 1                            # Boundary condition\n"
"    for i=2:n-1\n"
"        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * Ît\n"
"    end\n"
"    b[n] = 0                            # Boundary condition\n"
"end\n"
"\n"
"function heatflow(a::Vector{T}, nstep::Integer) where T\n"
"    b = similar(a)\n"
"    for t=1:div(nstep,2)                # Assume nstep is even\n"
"        timestep(b,a,T(0.1))\n"
"        timestep(a,b,T(0.1))\n"
"    end\n"
"end\n"
"\n"
"heatflow(zeros(Float32,10),2)           # Force compilation\n"
"for trial=1:6\n"
"    a = zeros(Float32,1000)\n"
"    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic\n"
"    @time heatflow(a,1000)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1320
msgid "This gives an output similar to"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1321
#, no-wrap
msgid ""
"  0.002202 seconds (1 allocation: 4.063 KiB)\n"
"  0.001502 seconds (1 allocation: 4.063 KiB)\n"
"  0.002139 seconds (1 allocation: 4.063 KiB)\n"
"  0.001454 seconds (1 allocation: 4.063 KiB)\n"
"  0.002115 seconds (1 allocation: 4.063 KiB)\n"
"  0.001455 seconds (1 allocation: 4.063 KiB)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1331
msgid "Note how each even iteration is significantly faster."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1334
msgid ""
"This example generates many subnormal numbers because the values in `a` become an exponentially decreasing curve, which slowly flattens out "
"over time."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1337
msgid "Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as `x-y == 0` implies `x == y`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1338
#, no-wrap
msgid ""
"julia> x = 3f-38; y = 2f-38;\n"
"\n"
"julia> set_zero_subnormals(true); (x - y, x == y)\n"
"(0.0f0, false)\n"
"\n"
"julia> set_zero_subnormals(false); (x - y, x == y)\n"
"(1.0000001f-38, false)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1350
#, no-wrap
msgid ""
"In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise.\n"
" For example, instead of initializing `a` with zeros, initialize it with:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1351
#, no-wrap
msgid "a = rand(Float32,1000) * 1.f-9\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:1355
#, no-wrap
msgid "[[`@code_warntype`](@ref)](@id man-code-warntype)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1359
msgid ""
"The macro [`@code_warntype`](@ref) (or its function variant [`code_warntype`](@ref)) can sometimes be helpful in diagnosing type-related "
"problems. Here's an example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1360
#, no-wrap
msgid ""
"julia> @noinline pos(x) = x < 0 ? 0 : x;\n"
"\n"
"julia> function f(x)\n"
"           y = pos(x)\n"
"           return sin(y*x + 1)\n"
"       end;\n"
"\n"
"julia> @code_warntype f(3.2)\n"
"Variables\n"
"  #self#::Core.Compiler.Const(f, false)\n"
"  x::Float64\n"
"  y::Union{Float64, Int64}\n"
"\n"
"Body::Float64\n"
"1 â      (y = Main.pos(x))\n"
"â   %2 = (y * x)::Float64\n"
"â   %3 = (%2 + 1)::Float64\n"
"â   %4 = Main.sin(%3)::Float64\n"
"âââ      return %4\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1389
msgid ""
"Interpreting the output of [`@code_warntype`](@ref), like that of its cousins [`@code_lowered`](@ref), [`@code_typed`](@ref), [`@code_llvm`]"
"(@ref), and [`@code_native`](@ref), takes a little practice.  Your code is being presented in form that has been heavily digested on its way "
"to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the `::T` (where `T` might be [`Float64`]"
"(@ref), for example). The most important characteristic of [`@code_warntype`](@ref)  is that non-concrete types are displayed in red; in the "
"above example, such output is shown in uppercase."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1399
msgid ""
"At the top, the inferred return type of the function is shown as `Body::Float64`.  The next lines represent the body of `f` in Julia's SSA "
"IR form.  The numbered boxes are labels and represent targets for jumps (via `goto`) in your code.  Looking at the body, you can see that "
"the first thing that happens is that `pos` is called and the return value has been inferred as the `Union` type `UNION{FLOAT64, INT64}` "
"shown in uppercase since it is a non-concrete type. This means that we cannot know the exact return type of `pos` based on the input types. "
"However, the result of `y*x`is a `Float64` no matter if `y` is a `Float64` or `Int64` The net result is that `f(x::Float64)` will not be "
"type-unstable in its output, even if some of the intermediate computations are type-unstable."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1413
msgid ""
"How you use this information is up to you. Obviously, it would be far and away best to fix `pos` to be type-stable: if you did so, all of "
"the variables in `f` would be concrete, and its performance would be optimal. However, there are circumstances where this kind of "
"*ephemeral* type instability might not matter too much: for example, if `pos` is never used in isolation, the fact that `f`'s output is type-"
"stable (for [`Float64`](@ref) inputs) will shield later code from the propagating effects of type instability. This is particularly relevant "
"in cases where fixing the type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or "
"breaking up functions) are your best tools to contain the \"damage\" from type instability.  Also, note that even Julia Base has functions "
"that are type unstable.  For example, the function [`findfirst`](@ref) returns the index into an array where a key is found, or `nothing` if "
"it is not found, a clear type instability. In order to make it easier to find the type instabilities that are likely to be important, "
"`Union`s containing either `missing` or `nothing` are color highlighted in yellow, instead of red."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1415
msgid "The following examples may help you interpret expressions marked as containing non-leaf types:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1419
#, no-wrap
msgid ""
"  * Function body starting with `Body::UNION{T1,T2})`\n"
"      * Interpretation: function with unstable return type\n"
"      * Suggestion: make the return value type-stable, even if you have to annotate it\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1423
#, no-wrap
msgid ""
"  * `invoke Main.g(%%x::Int64)::UNION{FLOAT64, INT64}`\n"
"      * Interpretation: call to a type-unstable function `g`.\n"
"      * Suggestion: fix the function, or if necessary annotate the return value\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1428
#, no-wrap
msgid ""
"  * `invoke Base.getindex(%%x::Array{Any,1}, 1::Int64)::ANY`\n"
"      * Interpretation: accessing elements of poorly-typed arrays\n"
"      * Suggestion: use arrays with better-defined types, or if necessary annotate the type of individual\n"
"        element accesses\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1434
#, no-wrap
msgid ""
"  * `Base.getfield(%%x, :(:data))::ARRAY{FLOAT64,N} WHERE N`\n"
"      * Interpretation: getting a field that is of non-leaf type. In this case, `ArrayContainer` had a\n"
"        field `data::Array{T}`. But `Array` needs the dimension `N`, too, to be a concrete type.\n"
"      * Suggestion: use concrete types like `Array{T,3}` or `Array{T,N}`, where `N` is now a parameter\n"
"        of `ArrayContainer`\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/performance-tips.md:1435
#, no-wrap
msgid "[Performance of captured variable](@id man-performance-captured)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1438
msgid "Consider the following example that defines an inner function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1438
#, no-wrap
msgid ""
"function abmult(r::Int)\n"
"    if r < 0\n"
"        r = -r\n"
"    end\n"
"    f = x -> x * r\n"
"    return f\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1452
msgid ""
"Function `abmult` returns a function `f` that multiplies its argument by the absolute value of `r`. The inner function assigned to `f` is "
"called a \"closure\". Inner functions are also used by the language for `do`-blocks and for generator expressions."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1462
msgid ""
"This style of code presents performance challenges for the language.  The parser, when translating it into lower-level instructions, "
"substantially reorganizes the above code by extracting the inner function to a separate code block.  \"Captured\" variables such as `r` that "
"are shared by inner functions and their enclosing scope are also extracted into a heap-allocated \"box\" accessible to both inner and outer "
"functions because the language specifies that `r` in the inner scope must be identical to `r` in the outer scope even after the outer scope "
"(or another inner function) modifies `r`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1468
msgid ""
"The discussion in the preceding paragraph referred to the \"parser\", that is, the phase of compilation that takes place when the module "
"containing `abmult` is first loaded, as opposed to the later phase when it is first invoked. The parser does not \"know\" that `Int` is a "
"fixed type, or that the statement `r = -r` transforms an `Int` to another `Int`.  The magic of type inference takes place in the later phase "
"of compilation."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1476
msgid ""
"Thus, the parser does not know that `r` has a fixed type (`Int`).  nor that `r` does not change value once the inner function is created (so "
"that the box is unneeded).  Therefore, the parser emits code for box that holds an object with an abstract type such as `Any`, which "
"requires run-time type dispatch for each occurrence of `r`.  This can be verified by applying `@code_warntype` to the above function.  Both "
"the boxing and the run-time type dispatch can cause loss of performance."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1482
msgid ""
"If captured variables are used in a performance-critical section of the code, then the following tips help ensure that their use is "
"performant. First, if it is known that a captured variable does not change its type, then this can be declared explicitly with a type "
"annotation (on the variable, not the right-hand side):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1482
#, no-wrap
msgid ""
"function abmult2(r0::Int)\n"
"    r::Int = r0\n"
"    if r < 0\n"
"        r = -r\n"
"    end\n"
"    f = x -> x * r\n"
"    return f\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1497
msgid ""
"The type annotation partially recovers lost performance due to capturing because the parser can associate a concrete type to the object in "
"the box.  Going further, if the captured variable does not need to be boxed at all (because it will not be reassigned after the closure is "
"created), this can be indicated with `let` blocks as follows."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1497
#, no-wrap
msgid ""
"function abmult3(r::Int)\n"
"    if r < 0\n"
"        r = -r\n"
"    end\n"
"    f = let r = r\n"
"            x -> x * r\n"
"    end\n"
"    return f\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1516
msgid ""
"The `let` block creates a new variable `r` whose scope is only the inner function. The second technique recovers full language performance "
"in the presence of captured variables. Note that this is a rapidly evolving aspect of the compiler, and it is likely that future releases "
"will not require this degree of programmer annotation to attain performance.  In the mean time, some user-contributed packages like "
"[FastClosures](https://github.com/c42f/FastClosures.jl) automate the insertion of `let` statements as in `abmult3`."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/performance-tips.md:1517
#, no-wrap
msgid "Checking for equality with a singleton"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/performance-tips.md:1523
msgid ""
"When checking if a value is equal to some singleton it can be better for performance to check for identicality (`===`) instead of equality "
"(`==`). The same advice applies to using `!==` over `!=`.  These type of checks frequently occur e.g. when implementing the iteration "
"protocol and checking if `nothing` is returned from [`iterate`](@ref)."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/constructors.md:1
#, no-wrap
msgid "[Constructors](@id man-constructors)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:7
msgid ""
"Constructors [^1] are functions that create new objects -- specifically, instances of [Composite Types](@ref).  In Julia, type objects also "
"serve as constructor functions: they create new instances of themselves when applied to an argument tuple as a function. This much was "
"already mentioned briefly when composite types were introduced. For example:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/constructors.md:8 ext/julia/doc/src/manual/constructors.md:49 ext/julia/doc/src/manual/constructors.md:60
#: ext/julia/doc/src/manual/types.md:315 ext/julia/doc/src/manual/types.md:328 ext/julia/doc/src/manual/types.md:345
#: ext/julia/doc/src/manual/types.md:354 ext/julia/doc/src/manual/types.md:361
#, no-wrap
msgid "jldoctest footype"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:8
#, no-wrap
msgid ""
"julia> struct Foo\n"
"           bar\n"
"           baz\n"
"       end\n"
"\n"
"julia> foo = Foo(1, 2)\n"
"Foo(1, 2)\n"
"\n"
"julia> foo.bar\n"
"1\n"
"\n"
"julia> foo.baz\n"
"2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:33
msgid ""
"For many types, forming new objects by binding their field values together is all that is ever needed to create instances. However, in some "
"cases more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or "
"by transforming them. [Recursive data structures](https://en.wikipedia.org/wiki/Recursion_%28computer_science"
"%29#Recursive_data_structures_.28structural_recursion.29), especially those that may be self-referential, often cannot be constructed "
"cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from "
"object creation. Sometimes, it's just convenient to be able to construct objects with fewer or different types of parameters than they have "
"fields. Julia's system for object construction addresses all of these cases and more."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:40
#, no-wrap
msgid ""
"[^1]:\n"
"    Nomenclature: while the term \"constructor\" generally refers to the entire function which constructs\n"
"    objects of a type, it is common to abuse terminology slightly and refer to specific constructor\n"
"    methods as \"constructors\". In such situations, it is generally clear from the context that the term\n"
"    is used to mean \"constructor method\" rather than \"constructor function\", especially as it is often\n"
"    used in the sense of singling out a particular method of the constructor from all of the others.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/constructors.md:41
#, no-wrap
msgid "Outer Constructor Methods"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:48
msgid ""
"A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. "
"Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let's say you want to add a constructor "
"method for `Foo` objects that takes only one argument and uses the given value for both the `bar` and `baz` fields. This is simple:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:49
#, no-wrap
msgid ""
"julia> Foo(x) = Foo(x,x)\n"
"Foo\n"
"\n"
"julia> Foo(1)\n"
"Foo(1, 1)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:59
msgid "You could also add a zero-argument `Foo` constructor method that supplies default values for both of the `bar` and `baz` fields:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:60
#, no-wrap
msgid ""
"julia> Foo() = Foo(0)\n"
"Foo\n"
"\n"
"julia> Foo()\n"
"Foo(0, 0)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:73
msgid ""
"Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-"
"argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like "
"this are called *outer* constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor "
"method, such as the automatically provided default ones."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/constructors.md:74
#, no-wrap
msgid "Inner Constructor Methods"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:81
msgid ""
"While outer constructor methods succeed in addressing the problem of providing additional convenience methods for constructing objects, they "
"fail to address the other two use cases mentioned in the introduction of this chapter: enforcing invariants, and allowing construction of "
"self-referential objects. For these problems, one needs *inner* constructor methods. An inner constructor method is like an outer "
"constructor method, except for two differences:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/constructors.md:85
msgid "It is declared inside the block of a type declaration, rather than outside of it like normal methods."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/constructors.md:85
msgid "It has access to a special locally existent function called [`new`](@ref) that creates objects of the block's type."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:89
msgid ""
"For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not "
"greater than the second one. One could declare it like this:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/constructors.md:90
#, no-wrap
msgid "jldoctest pairtype"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:90
#, no-wrap
msgid ""
"julia> struct OrderedPair\n"
"           x::Real\n"
"           y::Real\n"
"           OrderedPair(x,y) = x > y ? error(\"out of order\") : new(x,y)\n"
"       end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:99
#, no-wrap
msgid "Now `OrderedPair` objects can only be constructed such that `x <= y`:\n"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/constructors.md:100
#, no-wrap
msgid "jldoctest pairtype; filter = r\"Stacktrace:(\\n \\[[0-9]+\\].*)*\""
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:100
#, no-wrap
msgid ""
"julia> OrderedPair(1, 2)\n"
"OrderedPair(1, 2)\n"
"\n"
"julia> OrderedPair(2,1)\n"
"ERROR: out of order\n"
"Stacktrace:\n"
" [1] error at ./error.jl:33 [inlined]\n"
" [2] OrderedPair(::Int64, ::Int64) at ./none:4\n"
" [3] top-level scope\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:120
msgid ""
"If the type were declared `mutable`, you could reach in and directly change the field values to violate this invariant. Of course, messing "
"around with an object's internals uninvited is bad practice.  You (or someone else) can also provide additional outer constructor methods at "
"any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can "
"only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This "
"guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with "
"the type, thereby giving some degree of enforcement of a type's invariants."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:126
msgid ""
"If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with "
"all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of "
"the object's fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to `new`, "
"returning the resulting object:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:127
#, no-wrap
msgid ""
"julia> struct Foo\n"
"           bar\n"
"           baz\n"
"           Foo(bar,baz) = new(bar,baz)\n"
"       end\n"
"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:139
msgid ""
"This declaration has the same effect as the earlier definition of the `Foo` type without an explicit inner constructor method. The following "
"two types are equivalent -- one with a default constructor, the other with an explicit constructor:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:140
#, no-wrap
msgid ""
"julia> struct T1\n"
"           x::Int64\n"
"       end\n"
"\n"
"julia> struct T2\n"
"           x::Int64\n"
"           T2(x) = new(x)\n"
"       end\n"
"\n"
"julia> T1(1)\n"
"T1(1)\n"
"\n"
"julia> T2(1)\n"
"T2(1)\n"
"\n"
"julia> T1(1.0)\n"
"T1(1)\n"
"\n"
"julia> T2(1.0)\n"
"T2(1)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:168
msgid ""
"It is good practice to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing "
"essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary "
"transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is "
"typically quite natural."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/constructors.md:169
#, no-wrap
msgid "Incomplete Initialization"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:174
msgid ""
"The final problem which has still not been addressed is construction of self-referential objects, or more generally, recursive data "
"structures. Since the fundamental difficulty may not be immediately obvious, let us briefly explain it. Consider the following recursive "
"type declaration:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/constructors.md:175
#, no-wrap
msgid "jldoctest selfrefer"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:175
#, no-wrap
msgid ""
"julia> mutable struct SelfReferential\n"
"           obj::SelfReferential\n"
"       end\n"
"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:184
msgid ""
"This type may appear innocuous enough, until one considers how to construct an instance of it.  If `a` is an instance of `SelfReferential`, "
"then a second instance can be created by the call:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:185
#, no-wrap
msgid "julia> b = SelfReferential(a)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:193
msgid ""
"But how does one construct the first instance when no instance exists to provide as a valid value for its `obj` field? The only solution is "
"to allow creating an incompletely initialized instance of `SelfReferential` with an unassigned `obj` field, and using that incomplete "
"instance as a valid value for the `obj` field of another instance, such as, for example, itself."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:200
msgid ""
"To allow for the creation of incompletely initialized objects, Julia allows the [`new`](@ref) function to be called with fewer than the "
"number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use "
"the incomplete object, finishing its initialization before returning it. Here, for example, is another attempt at defining the "
"`SelfReferential` type, this time using a zero-argument inner constructor returning instances having `obj` fields pointing to themselves:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/constructors.md:201 ext/julia/doc/src/manual/constructors.md:211
#, no-wrap
msgid "jldoctest selfrefer2"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:201
#, no-wrap
msgid ""
"julia> mutable struct SelfReferential\n"
"           obj::SelfReferential\n"
"           SelfReferential() = (x = new(); x.obj = x)\n"
"       end\n"
"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:210
msgid "We can verify that this constructor works and constructs objects that are, in fact, self-referential:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:211
#, no-wrap
msgid ""
"julia> x = SelfReferential();\n"
"\n"
"julia> x === x\n"
"true\n"
"\n"
"julia> x === x.obj\n"
"true\n"
"\n"
"julia> x === x.obj.obj\n"
"true\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:226
msgid ""
"Although it is generally a good idea to return a fully initialized object from an inner constructor, it is possible to return incompletely "
"initialized objects:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/constructors.md:227 ext/julia/doc/src/manual/constructors.md:239
#, no-wrap
msgid "jldoctest incomplete"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:227
#, no-wrap
msgid ""
"julia> mutable struct Incomplete\n"
"           data\n"
"           Incomplete() = new()\n"
"       end\n"
"\n"
"julia> z = Incomplete();\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:238
msgid "While you are allowed to create objects with uninitialized fields, any access to an uninitialized reference is an immediate error:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:239
#, no-wrap
msgid ""
"julia> z.data\n"
"ERROR: UndefRefError: access to undefined reference\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:249
msgid ""
"This avoids the need to continually check for `null` values. However, not all object fields are references. Julia considers some types to be "
"\"plain data\", meaning all of their data is self-contained and does not reference other objects. The plain data types consist of primitive "
"types (e.g. `Int`)  and immutable structs of other plain data types. The initial contents of a plain data type is undefined:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:250
#, no-wrap
msgid ""
"julia> struct HasPlain\n"
"           n::Int\n"
"           HasPlain() = new()\n"
"       end\n"
"\n"
"julia> HasPlain()\n"
"HasPlain(438103441441)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:261
msgid "Arrays of plain data types exhibit the same behavior."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:263
msgid "You can pass incomplete objects to other functions from inner constructors to delegate their completion:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:264
#, no-wrap
msgid ""
"julia> mutable struct Lazy\n"
"           data\n"
"           Lazy(v) = complete_me(new(), v)\n"
"       end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:274
msgid ""
"As with incomplete objects returned from constructors, if `complete_me` or any of its callees try to access the `data` field of the `Lazy` "
"object before it has been initialized, an error will be thrown immediately."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/constructors.md:275
#, no-wrap
msgid "Parametric Constructors"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:281
msgid ""
"Parametric types add a few wrinkles to the constructor story. Recall from [Parametric Types](@ref)  that, by default, instances of "
"parametric composite types can be constructed either with explicitly given type parameters or with type parameters implied by the types of "
"the arguments given to the constructor. Here are some examples:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/constructors.md:282
#, no-wrap
msgid "jldoctest parametric; filter = r\"Closest candidates.*\\n  .*\""
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:282
#, no-wrap
msgid ""
"julia> struct Point{T<:Real}\n"
"           x::T\n"
"           y::T\n"
"       end\n"
"\n"
"julia> Point(1,2) ## implicit T ##\n"
"Point{Int64}(1, 2)\n"
"\n"
"julia> Point(1.0,2.5) ## implicit T ##\n"
"Point{Float64}(1.0, 2.5)\n"
"\n"
"julia> Point(1,2.5) ## implicit T ##\n"
"ERROR: MethodError: no method matching Point(::Int64, ::Float64)\n"
"Closest candidates are:\n"
"  Point(::T, ::T) where T<:Real at none:2\n"
"\n"
"julia> Point{Int64}(1, 2) ## explicit T ##\n"
"Point{Int64}(1, 2)\n"
"\n"
"julia> Point{Int64}(1.0,2.5) ## explicit T ##\n"
"ERROR: InexactError: Int64(2.5)\n"
"Stacktrace:\n"
"[...]\n"
"\n"
"julia> Point{Float64}(1.0, 2.5) ## explicit T ##\n"
"Point{Float64}(1.0, 2.5)\n"
"\n"
"julia> Point{Float64}(1,2) ## explicit T ##\n"
"Point{Float64}(1.0, 2.0)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:320
msgid ""
"As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: `Point{Int64}"
"(1,2)` works, but `Point{Int64}(1.0,2.5)` raises an [`InexactError`](@ref) when converting `2.5` to [`Int64`](@ref). When the type is "
"implied by the arguments to the constructor call, as in `Point(1,2)`, then the types of the arguments must agree -- otherwise the `T` cannot "
"be determined -- but any pair of real arguments with matching type may be given to the generic `Point` constructor."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:328
#, no-wrap
msgid ""
"What's really going on here is that `Point`, `Point{Float64}` and `Point{Int64}` are all different\n"
"constructor functions. In fact, `Point{T}` is a distinct constructor function for each type `T`.\n"
"Without any explicitly provided inner constructors, the declaration of the composite type `Point{T<:Real}`\n"
"automatically provides an inner constructor, `Point{T}`, for each possible type `T<:Real`, that\n"
"behaves just like non-parametric default inner constructors do. It also provides a single general\n"
"outer `Point` constructor that takes pairs of real arguments, which must be of the same type.\n"
"This automatic provision of constructors is equivalent to the following explicit declaration:\n"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/constructors.md:329 ext/julia/doc/src/manual/constructors.md:353 ext/julia/doc/src/manual/constructors.md:362
#: ext/julia/doc/src/manual/constructors.md:372 ext/julia/doc/src/manual/constructors.md:383 ext/julia/doc/src/manual/constructors.md:391
#, no-wrap
msgid "jldoctest parametric2"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:329
#, no-wrap
msgid ""
"julia> struct Point{T<:Real}\n"
"           x::T\n"
"           y::T\n"
"           Point{T}(x,y) where {T<:Real} = new(x,y)\n"
"       end\n"
"\n"
"julia> Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:348
msgid ""
"Notice that each definition looks like the form of constructor call that it handles.  The call `Point{Int64}(1,2)` will invoke the "
"definition `Point{T}(x,y)` inside the `struct` block.  The outer constructor declaration, on the other hand, defines a method for the "
"general `Point` constructor which only applies to pairs of values of the same real type. This declaration makes constructor calls without "
"explicit type parameters, like `Point(1,2)` and `Point(1.0,2.5)`, work. Since the method declaration restricts the arguments to being of the "
"same type, calls like `Point(1,2.5)`, with arguments of different types, result in \"no method\" errors."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:352
msgid ""
"Suppose we wanted to make the constructor call `Point(1,2.5)` work by \"promoting\" the integer value `1` to the floating-point value `1.0`. "
"The simplest way to achieve this is to define the following additional outer constructor method:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:353
#, no-wrap
msgid "julia> Point(x::Int64, y::Float64) = Point(convert(Float64,x),y);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:361
msgid ""
"This method uses the [`convert`](@ref) function to explicitly convert `x` to [`Float64`](@ref)  and then delegates construction to the "
"general constructor for the case where both arguments are [`Float64`](@ref). With this method definition what was previously a "
"[`MethodError`](@ref) now successfully creates a point of type `Point{Float64}`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:362
#, no-wrap
msgid ""
"julia> Point(1,2.5)\n"
"Point{Float64}(1.0, 2.5)\n"
"\n"
"julia> typeof(ans)\n"
"Point{Float64}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:371
msgid "However, other similar calls still don't work:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:372
#, no-wrap
msgid ""
"julia> Point(1.5,2)\n"
"ERROR: MethodError: no method matching Point(::Float64, ::Int64)\n"
"Closest candidates are:\n"
"  Point(::T, !Matched::T) where T<:Real at none:1\n"
msgstr ""
"julia> Point(1.5,2)\n"
"ERROR: MethodError: no method matching Point(::Float64, ::Int64)\n"
"Closest candidates are:\n"
"  Point(::T, !Matched::T) where T<:Real at none:1\n"

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:382
msgid ""
"For a more general way to make all such calls work sensibly, see [Conversion and Promotion](@ref conversion-and-promotion).  At the risk of "
"spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general "
"`Point` constructor work as one would expect:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:383
#, no-wrap
msgid "julia> Point(x::Real, y::Real) = Point(promote(x,y)...);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:390
msgid ""
"The `promote` function converts all its arguments to a common type -- in this case [`Float64`](@ref).  With this method definition, the "
"`Point` constructor promotes its arguments the same way that numeric operators like [`+`](@ref) do, and works for all kinds of real numbers:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:391
#, no-wrap
msgid ""
"julia> Point(1.5,2)\n"
"Point{Float64}(1.5, 2.0)\n"
"\n"
"julia> Point(1,1//2)\n"
"Point{Rational{Int64}}(1//1, 1//2)\n"
"\n"
"julia> Point(1.0,1//2)\n"
"Point{Float64}(1.0, 0.5)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:406
msgid ""
"Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a "
"more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and "
"multiple dispatch, defining sophisticated behavior is typically quite simple."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/constructors.md:407
#, no-wrap
msgid "Case Study: Rational"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:413
msgid ""
"Perhaps the best way to tie all these pieces together is to present a real world example of a parametric composite type and its constructor "
"methods. To that end, we implement our own rational number type `OurRational`, similar to Julia's built-in [`Rational`](@ref) type, defined "
"in [`rational.jl`](https://github.com/JuliaLang/julia/blob/master/base/rational.jl):"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/constructors.md:415 ext/julia/doc/src/manual/constructors.md:496
#, no-wrap
msgid "jldoctest rational"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:415
#, no-wrap
msgid ""
"julia> struct OurRational{T<:Integer} <: Real\n"
"           num::T\n"
"           den::T\n"
"           function OurRational{T}(num::T, den::T) where T<:Integer\n"
"               if num == 0 && den == 0\n"
"                    error(\"invalid rational: 0//0\")\n"
"               end\n"
"               g = gcd(den, num)\n"
"               num = div(num, g)\n"
"               den = div(den, g)\n"
"               new(num, den)\n"
"           end\n"
"       end\n"
"\n"
"julia> OurRational(n::T, d::T) where {T<:Integer} = OurRational{T}(n,d)\n"
"OurRational\n"
"\n"
"julia> OurRational(n::Integer, d::Integer) = OurRational(promote(n,d)...)\n"
"OurRational\n"
"\n"
"julia> OurRational(n::Integer) = OurRational(n,one(n))\n"
"OurRational\n"
"\n"
"julia> â(n::Integer, d::Integer) = OurRational(n,d)\n"
"â (generic function with 1 method)\n"
"\n"
"julia> â(x::OurRational, y::Integer) = x.num â (x.den*y)\n"
"â (generic function with 2 methods)\n"
"\n"
"julia> â(x::Integer, y::OurRational) = (x*y.den) â y.num\n"
"â (generic function with 3 methods)\n"
"\n"
"julia> â(x::Complex, y::Real) = complex(real(x) â y, imag(x) â y)\n"
"â (generic function with 4 methods)\n"
"\n"
"julia> â(x::Real, y::Complex) = (x*y') â real(y*y')\n"
"â (generic function with 5 methods)\n"
"\n"
"julia> function â(x::Complex, y::Complex)\n"
"           xy = x*y'\n"
"           yy = real(y*y')\n"
"           complex(real(xy) â yy, imag(xy) â yy)\n"
"       end\n"
"â (generic function with 6 methods)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:466
#, no-wrap
msgid ""
"The first line -- `struct OurRational{T<:Integer} <: Real` -- declares that `OurRational` takes one\n"
"type parameter of an integer type, and is itself a real type. The field declarations `num::T`\n"
"and `den::T` indicate that the data held in a `OurRational{T}` object are a pair of integers of type\n"
"`T`, one representing the rational value's numerator and the other representing its denominator.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:475
msgid ""
"Now things get interesting. `OurRational` has a single inner constructor method which checks that both of `num` and `den` aren't zero and "
"ensures that every rational is constructed in \"lowest terms\" with a non-negative denominator. This is accomplished by dividing the given "
"numerator and denominator values by their greatest common divisor, computed using the `gcd` function. Since `gcd` returns the greatest "
"common divisor of its arguments with sign matching the first argument (`den` here), after this division the new value of `den` is guaranteed "
"to be non-negative. Because this is the only inner constructor for `OurRational`, we can be certain that `OurRational` objects are always "
"constructed in this normalized form."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:482
msgid ""
"`OurRational` also provides several outer constructor methods for convenience. The first is the \"standard\" general constructor that infers "
"the type parameter `T` from the type of the numerator and denominator when they have the same type. The second applies when the given "
"numerator and denominator values have different types: it promotes them to a common type and then delegates construction to the outer "
"constructor for arguments of matching type. The third outer constructor turns integer values into rationals by supplying a value of `1` as "
"the denominator."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:495
msgid ""
"Following the outer constructor definitions, we defined a number of methods for the `â` operator, which provides a syntax for writing "
"rationals (e.g. `1 â 2`). Julia's `Rational` type uses the [`//`](@ref) operator for this purpose. Before these definitions, `â` is a "
"completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in [Rational Numbers](@ref) -- its "
"entire behavior is defined in these few lines.  The first and most basic definition just makes `a â b` construct a `OurRational` by applying "
"the `OurRational` constructor to `a` and `b` when they are integers. When one of the operands of `â` is already a rational number, we "
"construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an "
"integer.  Finally, applying `â` to complex integral values creates an instance of `Complex{OurRational}` -- a complex number whose real and "
"imaginary parts are rationals:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:496
#, no-wrap
msgid ""
"julia> z = (1 + 2im) â (1 - 2im);\n"
"\n"
"julia> typeof(z)\n"
"Complex{OurRational{Int64}}\n"
"\n"
"julia> typeof(z) <: Complex{OurRational}\n"
"false\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:510
msgid ""
"Thus, although the `â` operator usually returns an instance of `OurRational`, if either of its arguments are complex integers, it will "
"return an instance of `Complex{OurRational}` instead.  The interested reader should consider perusing the rest of [`rational.jl`](https://"
"github.com/JuliaLang/julia/blob/master/base/rational.jl): it is short, self-contained, and implements an entire basic Julia type."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/constructors.md:511
#, no-wrap
msgid "Outer-only constructors"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:519
msgid ""
"As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to "
"`Point{Int}` but not to `Point`. Optionally, outer constructors that determine type parameters automatically can be added, for example "
"constructing a `Point{Int}` from the call `Point(1,2)`. Outer constructors call inner constructors to actually make instances. However, in "
"some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:522
msgid "For example, say we define a type that stores a vector along with an accurate representation of its sum:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:523
#, no-wrap
msgid ""
"julia> struct SummedArray{T<:Number,S<:Number}\n"
"           data::Vector{T}\n"
"           sum::S\n"
"       end\n"
"\n"
"julia> SummedArray(Int32[1; 2; 3], Int32(6))\n"
"SummedArray{Int32,Int32}(Int32[1, 2, 3], 6)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:539
msgid ""
"The problem is that we want `S` to be a larger type than `T`, so that we can sum many elements with less information loss. For example, when "
"`T` is [`Int32`](@ref), we would like `S` to be [`Int64`](@ref). Therefore we want to avoid an interface that allows the user to construct "
"instances of the type `SummedArray{Int32,Int32}`. One way to do this is to provide a constructor only for `SummedArray`, but inside the "
"`struct` definition block to suppress generation of default constructors:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:540
#, no-wrap
msgid ""
"julia> struct SummedArray{T<:Number,S<:Number}\n"
"           data::Vector{T}\n"
"           sum::S\n"
"           function SummedArray(a::Vector{T}) where T\n"
"               S = widen(T)\n"
"               new{T,S}(a, sum(S, a))\n"
"           end\n"
"       end\n"
"\n"
"julia> SummedArray(Int32[1; 2; 3], Int32(6))\n"
"ERROR: MethodError: no method matching SummedArray(::Array{Int32,1}, ::Int32)\n"
"Closest candidates are:\n"
"  SummedArray(::Array{T,1}) where T at none:5\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/constructors.md:559
msgid ""
"This constructor will be invoked by the syntax `SummedArray(a)`. The syntax `new{T,S}` allows specifying parameters for the type to be "
"constructed, i.e. this call will return a `SummedArray{T,S}`.  `new{T,S}` can be used in any constructor definition, but for convenience the "
"parameters to `new{}` are automatically derived from the type being constructed when possible."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/stacktraces.md:1
#, no-wrap
msgid "Stack Traces"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:5
msgid "The `StackTraces` module provides simple stack traces that are both human readable and easy to use programmatically."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/stacktraces.md:6
#, no-wrap
msgid "Viewing a stack trace"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:9
msgid "The primary function used to obtain a stack trace is [`stacktrace`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:10
#, no-wrap
msgid ""
"6-element Array{Base.StackTraces.StackFrame,1}:\n"
" top-level scope\n"
" eval at boot.jl:317 [inlined]\n"
" eval(::Module, ::Expr) at REPL.jl:5\n"
" eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n"
" macro expansion at REPL.jl:116 [inlined]\n"
" (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:23
msgid ""
"Calling [`stacktrace()`](@ref) returns a vector of [`StackTraces.StackFrame`](@ref) s. For ease of use, the alias [`StackTraces.StackTrace`]"
"(@ref) can be used in place of `Vector{StackFrame}`. (Examples with `[...]` indicate that output may vary depending on how the code is run.)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:24
#, no-wrap
msgid ""
"julia> example() = stacktrace()\n"
"example (generic function with 1 method)\n"
"\n"
"julia> example()\n"
"7-element Array{Base.StackTraces.StackFrame,1}:\n"
" example() at REPL[1]:1\n"
" top-level scope\n"
" eval at boot.jl:317 [inlined]\n"
"[...]\n"
"\n"
"julia> @noinline child() = stacktrace()\n"
"child (generic function with 1 method)\n"
"\n"
"julia> @noinline parent() = child()\n"
"parent (generic function with 1 method)\n"
"\n"
"julia> grandparent() = parent()\n"
"grandparent (generic function with 1 method)\n"
"\n"
"julia> grandparent()\n"
"9-element Array{Base.StackTraces.StackFrame,1}:\n"
" child() at REPL[3]:1\n"
" parent() at REPL[4]:1\n"
" grandparent() at REPL[5]:1\n"
"[...]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:55
msgid ""
"Note that when calling [`stacktrace()`](@ref) you'll typically see a frame with `eval at boot.jl`.  When calling [`stacktrace()`](@ref) from "
"the REPL you'll also have a few extra frames in the stack from `REPL.jl`, usually looking something like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:56
#, no-wrap
msgid ""
"julia> example() = stacktrace()\n"
"example (generic function with 1 method)\n"
"\n"
"julia> example()\n"
"7-element Array{Base.StackTraces.StackFrame,1}:\n"
" example() at REPL[1]:1\n"
" top-level scope\n"
" eval at boot.jl:317 [inlined]\n"
" eval(::Module, ::Expr) at REPL.jl:5\n"
" eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n"
" macro expansion at REPL.jl:116 [inlined]\n"
" (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/stacktraces.md:71
#, no-wrap
msgid "Extracting useful information"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:77
msgid ""
"Each [`StackTraces.StackFrame`](@ref) contains the function name, file name, line number, lambda info, a flag indicating whether the frame "
"has been inlined, a flag indicating whether it is a C function (by default C functions do not appear in the stack trace), and an integer "
"representation of the pointer returned by [`backtrace`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:78
#, no-wrap
msgid ""
"julia> frame = stacktrace()[3]\n"
"eval(::Module, ::Expr) at REPL.jl:5\n"
"\n"
"julia> frame.func\n"
":eval\n"
"\n"
"julia> frame.file\n"
"Symbol(\"~/julia/usr/share/julia/stdlib/v0.7/REPL/src/REPL.jl\")\n"
"\n"
"julia> frame.line\n"
"5\n"
"\n"
"julia> top_frame.linfo\n"
"MethodInstance for eval(::Module, ::Expr)\n"
"\n"
"julia> top_frame.inlined\n"
"false\n"
"\n"
"julia> top_frame.from_c\n"
"false\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:101
#, no-wrap
msgid ""
"julia> top_frame.pointer\n"
"0x00007f92d6293171\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:108
msgid "This makes stack trace information available programmatically for logging, error handling, and more."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/stacktraces.md:109
#, no-wrap
msgid "Error handling"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:113
msgid ""
"While having easy access to information about the current state of the callstack can be helpful in many places, the most obvious application "
"is in error handling and debugging."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:114
#, no-wrap
msgid ""
"julia> @noinline bad_function() = undeclared_variable\n"
"bad_function (generic function with 1 method)\n"
"\n"
"julia> @noinline example() = try\n"
"           bad_function()\n"
"       catch\n"
"           stacktrace()\n"
"       end\n"
"example (generic function with 1 method)\n"
"\n"
"julia> example()\n"
"7-element Array{Base.StackTraces.StackFrame,1}:\n"
" example() at REPL[2]:4\n"
" top-level scope\n"
" eval at boot.jl:317 [inlined]\n"
"[...]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:138
msgid ""
"You may notice that in the example above the first stack frame points points at line 4, where [`stacktrace`](@ref) is called, rather than "
"line 2, where *bad_function* is called, and `bad_function`'s frame is missing entirely. This is understandable, given that [`stacktrace`]"
"(@ref) is called from the context of the *catch*. While in this example it's fairly easy to find the actual source of the error, in complex "
"cases tracking down the source of the error becomes nontrivial."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:142
msgid ""
"This can be remedied by passing the result of [`catch_backtrace`](@ref) to [`stacktrace`](@ref).  Instead of returning callstack information "
"for the current context, [`catch_backtrace`](@ref)  returns stack information for the context of the most recent exception:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:143
#, no-wrap
msgid ""
"julia> @noinline bad_function() = undeclared_variable\n"
"bad_function (generic function with 1 method)\n"
"\n"
"julia> @noinline example() = try\n"
"           bad_function()\n"
"       catch\n"
"           stacktrace(catch_backtrace())\n"
"       end\n"
"example (generic function with 1 method)\n"
"\n"
"julia> example()\n"
"8-element Array{Base.StackTraces.StackFrame,1}:\n"
" bad_function() at REPL[1]:1\n"
" example() at REPL[2]:2\n"
"[...]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:162
msgid "Notice that the stack trace now indicates the appropriate line number and the missing frame."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:163
#, no-wrap
msgid ""
"julia> @noinline child() = error(\"Whoops!\")\n"
"child (generic function with 1 method)\n"
"\n"
"julia> @noinline parent() = child()\n"
"parent (generic function with 1 method)\n"
"\n"
"julia> @noinline function grandparent()\n"
"           try\n"
"               parent()\n"
"           catch err\n"
"               println(\"ERROR: \", err.msg)\n"
"               stacktrace(catch_backtrace())\n"
"           end\n"
"       end\n"
"grandparent (generic function with 1 method)\n"
"\n"
"julia> grandparent()\n"
"ERROR: Whoops!\n"
"10-element Array{Base.StackTraces.StackFrame,1}:\n"
" error at error.jl:33 [inlined]\n"
" child() at REPL[1]:1\n"
" parent() at REPL[2]:1\n"
" grandparent() at REPL[3]:3\n"
"[...]\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/stacktraces.md:190
#, no-wrap
msgid "Exception stacks and `catch_stack`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:194
#, no-wrap
msgid ""
"!!! compat \"Julia 1.1\"\n"
"    Exception stacks requires at least Julia 1.1.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:199
msgid ""
"While handling an exception further exceptions may be thrown. It can be useful to inspect all these exceptions to identify the root cause of "
"a problem. The julia runtime supports this by pushing each exception onto an internal *exception stack* as it occurs. When the code exits a "
"`catch` normally, any exceptions which were pushed onto the stack in the associated `try` are considered to be successfully handled and are "
"removed from the stack."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:201
msgid "The stack of current exceptions can be accessed using the experimental [`Base.catch_stack`](@ref) function. For example,"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:202
#, no-wrap
msgid ""
"julia> try\n"
"           error(\"(A) The root cause\")\n"
"       catch\n"
"           try\n"
"               error(\"(B) An exception while handling the exception\")\n"
"           catch\n"
"               for (exc, bt) in Base.catch_stack()\n"
"                   showerror(stdout, exc, bt)\n"
"                   println()\n"
"               end\n"
"           end\n"
"       end\n"
"(A) The root cause\n"
"Stacktrace:\n"
" [1] error(::String) at error.jl:33\n"
" [2] top-level scope at REPL[7]:2\n"
" [3] eval(::Module, ::Any) at boot.jl:319\n"
" [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n"
" [5] macro expansion at REPL.jl:117 [inlined]\n"
" [6] (::getfield(REPL, Symbol(\"##26#27\")){REPL.REPLBackend})() at task.jl:259\n"
"(B) An exception while handling the exception\n"
"Stacktrace:\n"
" [1] error(::String) at error.jl:33\n"
" [2] top-level scope at REPL[7]:5\n"
" [3] eval(::Module, ::Any) at boot.jl:319\n"
" [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n"
" [5] macro expansion at REPL.jl:117 [inlined]\n"
" [6] (::getfield(REPL, Symbol(\"##26#27\")){REPL.REPLBackend})() at task.jl:259\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:236
msgid ""
"In this example the root cause exception (A) is first on the stack, with a further exception (B) following it. After exiting both catch "
"blocks normally (i.e., without throwing a further exception) all exceptions are removed from the stack and are no longer accessible."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:239
msgid ""
"The exception stack is stored on the `Task` where the exceptions occurred. When a task fails with uncaught exceptions, `catch_stack(task)` "
"may be used to inspect the exception stack for that task."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/stacktraces.md:240
#, no-wrap
msgid "Comparison with [`backtrace`](@ref)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:244
msgid ""
"A call to [`backtrace`](@ref) returns a vector of `Union{Ptr{Nothing}, Base.InterpreterIP}`, which may then be passed into [`stacktrace`]"
"(@ref) for translation:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:245
#, no-wrap
msgid ""
"julia> trace = backtrace()\n"
"18-element Array{Union{Ptr{Nothing}, Base.InterpreterIP},1}:\n"
" Ptr{Nothing} @0x00007fd8734c6209\n"
" Ptr{Nothing} @0x00007fd87362b342\n"
" Ptr{Nothing} @0x00007fd87362c136\n"
" Ptr{Nothing} @0x00007fd87362c986\n"
" Ptr{Nothing} @0x00007fd87362d089\n"
" Base.InterpreterIP(CodeInfo(:(begin\n"
"      Core.SSAValue(0) = backtrace()\n"
"      trace = Core.SSAValue(0)\n"
"      return Core.SSAValue(0)\n"
"  end)), 0x0000000000000000)\n"
" Ptr{Nothing} @0x00007fd87362e4cf\n"
"[...]\n"
"\n"
"julia> stacktrace(trace)\n"
"6-element Array{Base.StackTraces.StackFrame,1}:\n"
" top-level scope\n"
" eval at boot.jl:317 [inlined]\n"
" eval(::Module, ::Expr) at REPL.jl:5\n"
" eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n"
" macro expansion at REPL.jl:116 [inlined]\n"
" (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:275
msgid ""
"Notice that the vector returned by [`backtrace`](@ref) had 18 elements, while the vector returned by [`stacktrace`](@ref) only has 6. This "
"is because, by default, [`stacktrace`](@ref) removes any lower-level C functions from the stack. If you want to include stack frames from C "
"calls, you can do it like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:276
#, no-wrap
msgid ""
"julia> stacktrace(trace, true)\n"
"21-element Array{Base.StackTraces.StackFrame,1}:\n"
" jl_apply_generic at gf.c:2167\n"
" do_call at interpreter.c:324\n"
" eval_value at interpreter.c:416\n"
" eval_body at interpreter.c:559\n"
" jl_interpret_toplevel_thunk_callback at interpreter.c:798\n"
" top-level scope\n"
" jl_interpret_toplevel_thunk at interpreter.c:807\n"
" jl_toplevel_eval_flex at toplevel.c:856\n"
" jl_toplevel_eval_in at builtins.c:624\n"
" eval at boot.jl:317 [inlined]\n"
" eval(::Module, ::Expr) at REPL.jl:5\n"
" jl_apply_generic at gf.c:2167\n"
" eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n"
" jl_apply_generic at gf.c:2167\n"
" macro expansion at REPL.jl:116 [inlined]\n"
" (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92\n"
" jl_fptr_trampoline at gf.c:1838\n"
" jl_apply_generic at gf.c:2167\n"
" jl_apply at julia.h:1540 [inlined]\n"
" start_task at task.c:268\n"
" ip:0xffffffffffffffff\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:304
msgid ""
"Individual pointers returned by [`backtrace`](@ref) can be translated into [`StackTraces.StackFrame`](@ref)  s by passing them into "
"[`StackTraces.lookup`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/stacktraces.md:305
#, no-wrap
msgid ""
"julia> pointer = backtrace()[1];\n"
"\n"
"julia> frame = StackTraces.lookup(pointer)\n"
"1-element Array{Base.StackTraces.StackFrame,1}:\n"
" jl_apply_generic at gf.c:2167\n"
"\n"
"julia> println(\"The top frame is from $(frame[1].func)!\")\n"
"The top frame is from jl_apply_generic!\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/networking-and-streams.md:1
#, no-wrap
msgid "Networking and Streams"
msgstr "[ãããã¯ã¼ã¯ã¨ã¹ããªã¼ã ](@id networking-and-streams)"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:8
msgid ""
"Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though "
"asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the "
"underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading ([coroutine](@ref man-tasks))  "
"functionality."
msgstr ""
"Julia ã¯ãç«¯æ«ããã¤ããTCP ã½ã±ãããªã©ã®ã¹ããªã¼ãã³ã° I/O ãªãã¸ã§ã¯ããæ±ãè±å¯ãªã¤ã³ã¿ã¼ãã§ã¤ã¹ãæä¾ãã¾ãããã®ã¤ã³ã¿ã¼ãã§ã¤ã¹ã¯ãã·"
"ã¹ãã  ã¬ãã«ã§ã¯éåæã§ããããã­ã°ã©ãã«åæçã«æç¤ºãããéå¸¸ã¯èå¾ã«ããéåæå¦çãèããå¿è¦ã¯ããã¾ãããããã¯ãJulia åèª¿ã¹ã¬ãã"
"([coroutine](@ref man-tasks))æ©è½ãå¤ç¨ãããã¨ã«ãã£ã¦éæããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/networking-and-streams.md:9
#, no-wrap
msgid "Basic Stream I/O"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:13
msgid "All Julia streams expose at least a [`read`](@ref) and a [`write`](@ref) method, taking the stream as their first argument, e.g.:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:14
#, no-wrap
msgid ""
"julia> write(stdout, \"Hello World\");  # suppress return value 11 with ;\n"
"Hello World\n"
"julia> read(stdin, Char)\n"
"\n"
"'\\n': ASCII/Unicode U+000a (category Cc: Other, control)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:24
msgid ""
"Note that [`write`](@ref) returns 11, the number of bytes (in `\"Hello World\"`) written to [`stdout`](@ref), but this return value is "
"suppressed with the `;`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:28
msgid ""
"Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, [`write`](@ref) takes the data to "
"write as its second argument, while [`read`](@ref)  takes the type of the data to be read as the second argument."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:30
msgid "For example, to read a simple byte array, we could do:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:31
#, no-wrap
msgid ""
"julia> x = zeros(UInt8, 4)\n"
"4-element Array{UInt8,1}:\n"
" 0x00\n"
" 0x00\n"
" 0x00\n"
" 0x00\n"
"\n"
"julia> read!(stdin, x)\n"
"abcd\n"
"4-element Array{UInt8,1}:\n"
" 0x61\n"
" 0x62\n"
" 0x63\n"
" 0x64\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:50
msgid ""
"However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:51
#, no-wrap
msgid ""
"julia> read(stdin, 4)\n"
"abcd\n"
"4-element Array{UInt8,1}:\n"
" 0x61\n"
" 0x62\n"
" 0x63\n"
" 0x64\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:62
msgid "or if we had wanted to read the entire line instead:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:63
#, no-wrap
msgid ""
"julia> readline(stdin)\n"
"abcd\n"
"\"abcd\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:71
msgid ""
"Note that depending on your terminal settings, your TTY may be line buffered and might thus require an additional enter before the data is "
"sent to Julia."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:73
msgid "To read every line from [`stdin`](@ref) you can use [`eachline`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:74
#, no-wrap
msgid ""
"for line in eachline(stdin)\n"
"    print(\"Found $line\")\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:81
msgid "or [`read`](@ref) if you wanted to read by character instead:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:82
#, no-wrap
msgid ""
"while !eof(stdin)\n"
"    x = read(stdin, Char)\n"
"    println(\"Found: $x\")\n"
"end\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/networking-and-streams.md:89 ext/julia/doc/src/base/io-network.md:55
#, no-wrap
msgid "Text I/O"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:93
msgid ""
"Note that the [`write`](@ref) method mentioned above operates on binary streams. In particular, values do not get converted to any canonical "
"text representation but are written out as is:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:94
#, no-wrap
msgid ""
"julia> write(stdout, 0x61);  # suppress return value 1 with ;\n"
"a\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:101
msgid ""
"Note that `a` is written to [`stdout`](@ref) by the [`write`](@ref) function and that the returned value is `1` (since `0x61` is one byte)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:104
msgid ""
"For text I/O, use the [`print`](@ref) or [`show`](@ref) methods, depending on your needs (see the documentation for these two methods for a "
"detailed discussion of the difference between them):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:105
#, no-wrap
msgid ""
"julia> print(stdout, 0x61)\n"
"97\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:112
msgid ""
"See [Custom pretty-printing](@ref man-custom-pretty-printing) for more information on how to implement display methods for custom types."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/networking-and-streams.md:113
#, no-wrap
msgid "IO Output Contextual Properties"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:120
#, no-wrap
msgid ""
"Sometimes IO output can benefit from the ability to pass contextual information into show methods.\n"
"The [`IOContext`](@ref) object provides this framework for associating arbitrary metadata with an IO object.\n"
"For example, `:compact => true` adds a hinting parameter to the IO object that the invoked show method\n"
"should print a shorter output (if applicable). See the [`IOContext`](@ref) documentation for a list\n"
"of common properties.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/networking-and-streams.md:121
#, no-wrap
msgid "Working with Files"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:126
msgid ""
"Like many other environments, Julia has an [`open`](@ref) function, which takes a filename and returns an [`IOStream`](@ref) object that you "
"can use to read and write things from the file. For example, if we have a file, `hello.txt`, whose contents are `Hello, World!`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:127
#, no-wrap
msgid ""
"julia> f = open(\"hello.txt\")\n"
"IOStream(<file hello.txt>)\n"
"\n"
"julia> readlines(f)\n"
"1-element Array{String,1}:\n"
" \"Hello, World!\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:137
msgid "If you want to write to a file, you can open it with the write (`\"w\"`) flag:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:138
#, no-wrap
msgid ""
"julia> f = open(\"hello.txt\",\"w\")\n"
"IOStream(<file hello.txt>)\n"
"\n"
"julia> write(f,\"Hello again.\")\n"
"12\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:149
msgid ""
"If you examine the contents of `hello.txt` at this point, you will notice that it is empty; nothing has actually been written to disk yet. "
"This is because the `IOStream` must be closed before the write is actually flushed to disk:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:150
#, no-wrap
msgid "julia> close(f)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:155
msgid "Examining `hello.txt` again will show its contents have been changed."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:160
msgid ""
"Opening a file, doing something to its contents, and closing it again is a very common pattern.  To make this easier, there exists another "
"invocation of [`open`](@ref) which takes a function as its first argument and filename as its second, opens the file, calls the function "
"with the file as an argument, and then closes it again. For example, given a function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:161
#, no-wrap
msgid ""
"function read_and_capitalize(f::IOStream)\n"
"    return uppercase(read(f, String))\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:168
msgid "You can call:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:169
#, no-wrap
msgid ""
"julia> open(read_and_capitalize, \"hello.txt\")\n"
"\"HELLO AGAIN.\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:176
msgid "to open `hello.txt`, call `read_and_capitalize` on it, close `hello.txt` and return the capitalized contents."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:179
msgid "To avoid even having to define a named function, you can use the `do` syntax, which creates an anonymous function on the fly:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:180
#, no-wrap
msgid ""
"julia> open(\"hello.txt\") do f\n"
"           uppercase(read(f, String))\n"
"       end\n"
"\"HELLO AGAIN.\"\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/networking-and-streams.md:187
#, no-wrap
msgid "A simple TCP example"
msgstr "ç°¡åãª TCP ã®ä¾"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:192
msgid ""
"Let's jump right in with a simple example involving TCP sockets.  This functionality is in a standard library package called `Sockets`.  "
"Let's first create a simple server:"
msgstr ""
"ããã§ãTCP ã½ã±ãããå«ãç°¡åãªä¾ã«é£ã³è¾¼ãã§è¦ã¾ãããããã®æ©è½ã¯ã`Sockets` ã¨å¼ã°ããæ¨æºã©ã¤ãã©ãª ããã±ã¼ã¸ã«ããã¾ãã æåã«åç´ãª"
"ãµã¼ãã¼ãä½æãã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:193
#, no-wrap
msgid ""
"julia> using Sockets\n"
"\n"
"julia> @async begin\n"
"           server = listen(2000)\n"
"           while true\n"
"               sock = accept(server)\n"
"               println(\"Hello World\\n\")\n"
"           end\n"
"       end\n"
"Task (runnable) @0x00007fd31dc11ae0\n"
msgstr ""
"julia> using Sockets\n"
"\n"
"julia> @async begin\n"
"           server = listen(2000)\n"
"           while true\n"
"               sock = accept(server)\n"
"               println(\"Hello World\\n\")\n"
"           end\n"
"       end\n"
"Task (runnable) @0x00007fd31dc11ae0\n"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:210
msgid ""
"To those familiar with the Unix socket API, the method names will feel familiar, though their usage is somewhat simpler than the raw Unix "
"socket API. The first call to [`listen`](@ref) will create a server waiting for incoming connections on the specified port (2000) in this "
"case. The same function may also be used to create various other kinds of servers:"
msgstr ""
"Unix ã½ã±ãã API ã«ç²¾éãã¦ããäººã«ã¨ã£ã¦è¦ªãã¿ãããã¡ã½ããåã§ããããã®ä½¿ç¨æ³ã¯çã® Unix ã½ã±ãã API ãããããããã·ã³ãã«ã§ãã"
"[`listen`](@ref) ã¸ã®æåã®å¼ã³åºãã¯ããã®å ´åãæå®ããããã¼ã (2000) ä¸ã®çä¿¡æ¥ç¶ãå¾æ©ãããµã¼ãã¼ãä½æãã¾ããåãæ©è½ãä½¿ç¨ãã¦ãä»ã®"
"ãã¾ãã¾ãªç¨®é¡ã®ãµã¼ãã¼ãä½æãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:211
#, no-wrap
msgid ""
"julia> listen(2000) # Listens on localhost:2000 (IPv4)\n"
"Sockets.TCPServer(active)\n"
"\n"
"julia> listen(ip\"127.0.0.1\",2000) # Equivalent to the first\n"
"Sockets.TCPServer(active)\n"
"\n"
"julia> listen(ip\"::1\",2000) # Listens on localhost:2000 (IPv6)\n"
"Sockets.TCPServer(active)\n"
"\n"
"julia> listen(IPv4(0),2001) # Listens on port 2001 on all IPv4 interfaces\n"
"Sockets.TCPServer(active)\n"
"\n"
"julia> listen(IPv6(0),2001) # Listens on port 2001 on all IPv6 interfaces\n"
"Sockets.TCPServer(active)\n"
"\n"
"julia> listen(\"testsocket\") # Listens on a UNIX domain socket\n"
"Sockets.PipeServer(active)\n"
"\n"
"julia> listen(\"\\\\\\\\.\\\\pipe\\\\testsocket\") # Listens on a Windows named pipe\n"
"Sockets.PipeServer(active)\n"
msgstr ""
"julia> listen(2000) # Listens on localhost:2000 (IPv4)\n"
"Sockets.TCPServer(active)\n"
"\n"
"julia> listen(ip\"127.0.0.1\",2000) # Equivalent to the first\n"
"Sockets.TCPServer(active)\n"
"\n"
"julia> listen(ip\"::1\",2000) # Listens on localhost:2000 (IPv6)\n"
"Sockets.TCPServer(active)\n"
"\n"
"julia> listen(IPv4(0),2001) # Listens on port 2001 on all IPv4 interfaces\n"
"Sockets.TCPServer(active)\n"
"\n"
"julia> listen(IPv6(0),2001) # Listens on port 2001 on all IPv6 interfaces\n"
"Sockets.TCPServer(active)\n"
"\n"
"julia> listen(\"testsocket\") # Listens on a UNIX domain socket\n"
"Sockets.PipeServer(active)\n"
"\n"
"julia> listen(\"\\\\\\\\.\\\\pipe\\\\testsocket\") # Listens on a Windows named pipe\n"
"Sockets.PipeServer(active)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:246
msgid ""
"Note that the return type of the last invocation is different. This is because this server does not listen on TCP, but rather on a named "
"pipe (Windows) or UNIX domain socket. Also note that Windows named pipe format has to be a specific pattern such that the name prefix (`\\\\."
"\\pipe\\`) uniquely identifies the [file type](https://docs.microsoft.com/windows/desktop/ipc/pipe-names).  The difference between TCP and "
"named pipes or UNIX domain sockets is subtle and has to do with the [`accept`](@ref) and [`connect`](@ref)  methods. The [`accept`](@ref) "
"method retrieves a connection to the client that is connecting on the server we just created, while the [`connect`](@ref) function connects "
"to a server using the specified method. The [`connect`](@ref) function takes the same arguments as [`listen`](@ref), so, assuming the "
"environment (i.e. host, cwd, etc.) is the same you should be able to pass the same arguments to [`connect`](@ref) as you did to listen to "
"establish the connection. So let's try that out (after having created the server above):"
msgstr ""
"æå¾ã®å¼ã³åºãã®æ»ãå¤ã®åãç°ãªããã¨ã«æ³¨æãã¦ãã ãããããã¯ããã®ãµã¼ãã¼ã TCP ã§ã¯ãªããååä»ããã¤ã (Windows) ã¾ãã¯ UNIX ãã¡ã¤ã³ "
"ã½ã±ããã§ãªãã¹ã³ããããã§ããã¾ããWindows ã®ååä»ããã¤ãå½¢å¼ã¯ãååãã¬ãã£ãã¯ã¹ (`\\\\.\\pipe\\`) ã [ãã¡ã¤ã«ã®ç¨®é¡](https://docs."
"microsoft.com/windows/desktop/ipc/pipe-names) ãä¸æã«è­å¥ããããã«ç¹å®ã®ãã¿ã¼ã³ã§ããå¿è¦ãããã¾ããTCP ã¨ååä»ããã¤ãã¾ãã¯ UNIX ãã¡"
"ã¤ã³ ã½ã±ããã®éãã¯ãããã§ã[`accept`](@ref) ã¡ã½ããã¨ [`connect`](@ref) ã¡ã½ããã«é¢ä¿ãã¦ãã¾ãã[`accept`](@ref) ã¡ã½ããã¯ãä½æãã"
"ãµã¼ãã¼ã«æ¥ç¶ããããã¨ãã¦ããã¯ã©ã¤ã¢ã³ãã¨ã®æ¥ç¶ãåãå¥ãã¾ãã[`connect`](@ref) é¢æ°ã¯æå®ãããã¡ã½ãããä½¿ã£ã¦ãµã¼ãã¼ã«æ¥ç¶ãã¾ãã"
"[`connect`](@ref) é¢æ°ã¯[`listen`](@ref)ã¨åãå¼æ°ãåãåãã®ã§ãç°å¢(ãã¹ããç¾å¨ã®ã«ã¬ã³ããã£ã¬ã¯ããªãªã©)ãåãã§ããã¨ä»®å®ããã¨ãæ¥ç¶"
"ãç¢ºç«ããããã«è¡ã£ãã®ã¨åãå¼æ°ã[`connect`](@ref)ã«æ¸¡ããã¨ãã§ããã¯ãã§ãã(ä¸è¨ã®ãµã¼ãã¼ãä½æããå¾)ãããè©¦ãã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:247
#, no-wrap
msgid ""
"julia> connect(2000)\n"
"TCPSocket(open, 0 bytes waiting)\n"
"\n"
"julia> Hello World\n"
msgstr ""
"julia> connect(2000)\n"
"TCPSocket(open, 0 bytes waiting)\n"
"\n"
"julia> Hello World\n"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:258
msgid ""
"As expected we saw \"Hello World\" printed. So, let's actually analyze what happened behind the scenes. When we called [`connect`](@ref), we "
"connect to the server we had just created. Meanwhile, the accept function returns a server-side connection to the newly created socket and "
"prints \"Hello World\" to indicate that the connection was successful."
msgstr ""
"äºæ³éã\"Hello World\" ã(ãµã¼ãã¼å´ã«)ããªã³ãããã¾ãããããã§ã¯ãèå°è£ã§ä½ãèµ·ãã£ãã®ããå®éã«åæãã¦ã¿ã¾ãããã[`connect`](@ref)ã"
"å¼ã¶ã¨ãä½æãããµã¼ãã¼ã«æ¥ç¶ãã¾ããä¸æ¹ãaccept é¢æ°ã¯ãæ°ããä½æãããã½ã±ããã¸ã®ãµã¼ãã¼å´ããã®æ¥ç¶ãè¿ããæ¥ç¶ãæåãããã¨ãç¤ºã "
"\"Hello World\" ãåºåãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:266
msgid ""
"A great strength of Julia is that since the API is exposed synchronously even though the I/O is actually happening asynchronously, we didn't "
"have to worry about callbacks or even making sure that the server gets to run. When we called [`connect`](@ref) the current task waited for "
"the connection to be established and only continued executing after that was done. In this pause, the server task resumed execution (because "
"a connection request was now available), accepted the connection, printed the message and waited for the next client. Reading and writing "
"works in the same way.  To see this, consider the following simple echo server:"
msgstr ""
"Julia ã®å¤§ããªå¼·ã¿ã¯ãI/O ãå®éã«éåæçã«çºçãã¦ããã«ãããããããAPI ãåæçã«å¬éãããã®ã§ãã³ã¼ã«ããã¯ãå¿éãããããµã¼ãã¼ãç¢º"
"å®ã«å®è¡ããããã¨ãç¢ºèªãããããå¿è¦ããªãã£ããã¨ã§ãã[`connect`](@ref)ãå¼ã³åºãã¨ãç¾å¨ã®ã¿ã¹ã¯ã¯æ¥ç¶ãç¢ºç«ãããã®ãå¾ã¡ããã®å¾ãå®è¡"
"ãç¶è¡ãã¾ããããã®ä¸æåæ­¢ã§ã¯ããµã¼ãã¼ ã¿ã¹ã¯ãå®è¡ãåéã (æ¥ç¶è¦æ±ãå©ç¨å¯è½ã«ãªã£ããã)ãæ¥ç¶ãåãå¥ããã¡ãã»ã¼ã¸ãå°å·ããæ¬¡ã®ã¯"
"ã©ã¤ã¢ã³ããå¾æ©ãã¾ãããReadã¨Writeã¯åãããã«æ©è½ãã¾ãã ãããç¢ºèªããããã«æ¬¡ã®åç´ãªã¨ã³ã¼ ãµã¼ãã¼ãèãã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:267
#, no-wrap
msgid ""
"julia> @async begin\n"
"           server = listen(2001)\n"
"           while true\n"
"               sock = accept(server)\n"
"               @async while isopen(sock)\n"
"                   write(sock, readline(sock, keep=true))\n"
"               end\n"
"           end\n"
"       end\n"
"Task (runnable) @0x00007fd31dc12e60\n"
"\n"
"julia> clientside = connect(2001)\n"
"TCPSocket(RawFD(28) open, 0 bytes waiting)\n"
"\n"
"julia> @async while isopen(clientside)\n"
"           write(stdout, readline(clientside, keep=true))\n"
"       end\n"
"Task (runnable) @0x00007fd31dc11870\n"
"\n"
"julia> println(clientside,\"Hello World from the Echo Server\")\n"
"Hello World from the Echo Server\n"
msgstr ""
"julia> @async begin\n"
"           server = listen(2001)\n"
"           while true\n"
"               sock = accept(server)\n"
"               @async while isopen(sock)\n"
"                   write(sock, readline(sock, keep=true))\n"
"               end\n"
"           end\n"
"       end\n"
"Task (runnable) @0x00007fd31dc12e60\n"
"\n"
"julia> clientside = connect(2001)\n"
"TCPSocket(RawFD(28) open, 0 bytes waiting)\n"
"\n"
"julia> @async while isopen(clientside)\n"
"           write(stdout, readline(clientside, keep=true))\n"
"       end\n"
"Task (runnable) @0x00007fd31dc11870\n"
"\n"
"julia> println(clientside,\"Hello World from the Echo Server\")\n"
"Hello World from the Echo Server\n"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:292
msgid "As with other streams, use [`close`](@ref) to disconnect the socket:"
msgstr "ä»ã®ã¹ããªã¼ã ã¨åæ§ã«ã[`close`](@ref)ãä½¿ç¨ãã¦ã½ã±ãããåæ­ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:293
#, no-wrap
msgid "julia> close(clientside)\n"
msgstr "julia> close(clientside)\n"

#. type: Title ##
#: ext/julia/doc/src/manual/networking-and-streams.md:297
#, no-wrap
msgid "Resolving IP Addresses"
msgstr "IP ã¢ãã¬ã¹ã®è§£æ±º"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:302
msgid ""
"One of the [`connect`](@ref) methods that does not follow the [`listen`](@ref) methods is `connect(host::String,port)`, which will attempt "
"to connect to the host given by the `host` parameter on the port given by the `port` parameter. It allows you to do things like:"
msgstr ""
"[`listen`](@ref) ã¡ã½ããã¨çµã¿åããã¦ä½¿ããã[`connect`](@ref) ã¡ã½ããã®ä»ã«`connect(host::String,port)`ã®å½¢å¼ã®ãã®ãããã¾ããããã¯ã"
"`host`ãã©ã¡ã¼ã¿ã§æå®ããããã¹ãã«å¯¾ãã¦ã`port`ã§æå®ããããã¼ããä½¿ã£ã¦æ¥ç¶ãã¾ããæ¬¡ã®ããã«ä½¿ãæ¹ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:303
#, no-wrap
msgid ""
"julia> connect(\"google.com\", 80)\n"
"TCPSocket(RawFD(30) open, 0 bytes waiting)\n"
msgstr ""
"julia> connect(\"google.com\", 80)\n"
"TCPSocket(RawFD(30) open, 0 bytes waiting)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:310
msgid "At the base of this functionality is [`getaddrinfo`](@ref), which will do the appropriate address resolution:"
msgstr "ãã®æ©è½ã®ãã¼ã¹ã«ãªã£ã¦ããã®ã¯[`getaddrinfo`](@ref)ã§ãé©åãªã¢ãã¬ã¹è§£æ±ºãè¡ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/networking-and-streams.md:311
#, no-wrap
msgid ""
"julia> getaddrinfo(\"google.com\")\n"
"ip\"74.125.226.225\"\n"
msgstr ""
"julia> getaddrinfo(\"google.com\")\n"
"ip\"74.125.226.225\"\n"

#. type: Title #
#: ext/julia/doc/src/manual/getting-started.md:1
#, no-wrap
msgid "[Getting Started](@id man-getting-started)"
msgstr "[ã¯ãããã](@id man-getting-started)"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:5
msgid ""
"Julia installation is straightforward, whether using precompiled binaries or compiling from source.  Download and install Julia by following "
"the instructions at [https://julialang.org/downloads/](https://julialang.org/downloads/)."
msgstr ""
"Julia ã®ã¤ã³ã¹ãã¼ã«ã¯ãã³ã³ãã¤ã«æ¸ã¿ã®ãã¤ããªãä½¿ç¨ããããã½ã¼ã¹ããã³ã³ãã¤ã«ãããã«ããããããç°¡åã§ãã [https://julialang.org/"
"downloads/]ã®æç¤ºã«å¾ã£ã¦ã¸ã¥ãªã¢ããã¦ã³ã­ã¼ããã¦ã¤ã³ã¹ãã¼ã«ãã¦ãã ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:9
msgid ""
"The easiest way to learn and experiment with Julia is by starting an interactive session (also known as a read-eval-print loop or \"REPL\") "
"by double-clicking the Julia executable or running `julia` from the command line:"
msgstr ""
"Julia ãå­¦ç¿ãã¦å®é¨ããæãç°¡åãªæ¹æ³ã¯ãJulia ã®å®è¡ãã¡ã¤ã«ãããã«ã¯ãªãã¯ããããã³ãã³ã ã©ã¤ã³ãã ãjuliaããå®è¡ãã¦å¯¾è©±åã»ãã·ã§"
"ã³ (read-eval-print loop ããªãã¡ \"REPL\" ã¨ãå¼ã°ãã¾ã) ãéå§ãããã¨ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:10
#, no-wrap
msgid ""
"io = IOBuffer()\n"
"Base.banner(io)\n"
"banner = String(take!(io))\n"
"import Markdown\n"
"Markdown.parse(\"```\\n\\$ julia\\n\\n$(banner)\\njulia> 1 + 2\\n3\\n\\njulia> ans\\n3\\n```\")\n"
msgstr ""
"io = IOBuffer()\n"
"Base.banner(io)\n"
"banner = String(take!(io))\n"
"import Markdown\n"
"Markdown.parse(\"```\\n\\$ julia\\n\\n$(banner)\\njulia> 1 + 2\\n3\\n\\njulia> ans\\n3\\n```\")\n"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:25
msgid ""
"To exit the interactive session, type `CTRL-D` (press the Control/`^` key together with the `d` key), or type `exit()`. When run in "
"interactive mode, `julia` displays a banner and prompts the user for input.  Once the user has entered a complete expression, such as `1 + "
"2`, and hits enter, the interactive session evaluates the expression and shows its value. If an expression is entered into an interactive "
"session with a trailing semicolon, its value is not shown. The variable `ans` is bound to the value of the last evaluated expression whether "
"it is shown or not. The `ans` variable is only bound in interactive sessions, not when Julia code is run in other ways."
msgstr ""
"å¯¾è©±åã»ãã·ã§ã³ãçµäºããã«ã¯ããCtrl-Dãã¨å¥åããã (ã³ã³ãã­ã¼ã«/`^` ã­ã¼ã `d` ã­ã¼ã¨ä¸ç·ã«æ¼ã)ã `exit()` ã¨å¥åãã¾ããå¯¾è©±ã¢ã¼ãã§å®"
"è¡ããã¨ã`julia` ã¯ãã­ã³ãããè¡¨ç¤ºããå¥åãæ±ãã¾ãã ã¦ã¼ã¶ã¼ã `1 + 2` ãªã©ã®å®å¨ãªå¼ãå¥åããenter ã­ã¼ãæ¼ãããã¨ãå¯¾è©±åã»ãã·ã§ã³"
"ã¯å¼ãè©ä¾¡ãããã®å¤ãç¤ºãã¾ããå¾ãã«ã»ãã³ã­ã³ãã¤ãã¦å¼ãå¥åããå ´åã«ã¯ãè©ä¾¡çµæã¯è¡¨ç¤ºããã¾ãããå¤æ° `ans` ã¯ãè¡¨ç¤ºããã¦ãããã©ãã"
"ã«ããããããæå¾ã«è©ä¾¡ãããå¼ã®å¤ã«ãã¤ã³ãããã¾ãã`ans` å¤æ°ã¯å¯¾è©±åã»ãã·ã§ã³ã§ã®ã¿ãã¤ã³ããããJulia ã³ã¼ããä»ã®æ¹æ³ã§å®è¡ãããå ´"
"åã«ã¯ä½¿ãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:27
msgid "To evaluate expressions written in a source file `file.jl`, write `include(\"file.jl\")`."
msgstr "ã½ã¼ã¹ ãã¡ã¤ã« `file.jl` ã«æ¸ãããå¼ãè©ä¾¡ããã«ã¯ã`include(\"file.jl\") ã¨æ¸ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:30
msgid "To run code in a file non-interactively, you can give it as the first argument to the `julia` command:"
msgstr "ãã¡ã¤ã«åã®ã³ã¼ããéå¯¾è©±çã«å®è¡ããã«ã¯ã`julia` ã³ãã³ãã®æåã®å¼æ°ã¨ãã¦ãã¡ã¤ã«åãæå®ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:31
#, no-wrap
msgid "$ julia script.jl arg1 arg2...\n"
msgstr "$ julia script.jl arg1 arg2...\n"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:41
msgid ""
"As the example implies, the following command-line arguments to `julia` are interpreted as command-line arguments to the program `script."
"jl`, passed in the global constant `ARGS`. The name of the script itself is passed in as the global `PROGRAM_FILE`. Note that `ARGS` is also "
"set when a Julia expression is given using the `-e` option on the command line (see the `julia` help output below) but `PROGRAM_FILE` will "
"be empty. For example, to just print the arguments given to a script, you could do this:"
msgstr ""
"ãã®ä¾ãç¤ºãããã«ã`julia` ã«å¯¾ããæ¬¡ã®ã³ãã³ãã©ã¤ã³å¼æ°ã¯ãã°ã­ã¼ãã«å®æ° `ARGS` ã«æ¸¡ããããã­ã°ã©ã  `script.jl` ã«å¯¾ããã³ãã³ãã©ã¤ã³å¼"
"æ°ã¨ãã¦è§£éããã¾ããã¹ã¯ãªããèªä½ã®ååã¯ãã°ã­ã¼ãã« `PROGRAM_FILE` ã¨ãã¦æ¸¡ããã¾ãããARGSãã¯ãã³ãã³ãã©ã¤ã³ã®`-e`ãªãã·ã§ã³ãä½¿ç¨ã"
"ã¦ Julia å¼ãæå®ããã¦ããå ´åã«ãè¨­å®ããã¾ãã(ä»¥ä¸ã®ãjuliaããã«ãåºåãåç§)ã`PROGRAM_FILE` ã¯ç©ºã«ãªãã¾ãããã¨ãã°ãã¹ã¯ãªããã«ä¸ã"
"ãããå¼æ°ãè¡¨ç¤ºããã ãã®å ´åã¯ãæ¬¡ã®æä½ãè¡ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:42
#, no-wrap
msgid ""
"$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar\n"
"\n"
"foo\n"
"bar\n"
msgstr ""
"$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar\n"
"\n"
"foo\n"
"bar\n"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:50
msgid "Or you could put that code into a script and run it:"
msgstr "ãããã¯ããã®ã³ã¼ããã¹ã¯ãªãããã¡ã¤ã«ã«ãã¦å®è¡ãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:51
#, no-wrap
msgid ""
"$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' > script.jl\n"
"$ julia script.jl foo bar\n"
"script.jl\n"
"foo\n"
"bar\n"
msgstr ""
"$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' > script.jl\n"
"$ julia script.jl foo bar\n"
"script.jl\n"
"foo\n"
"bar\n"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:60
msgid "The `--` delimiter can be used to separate command-line arguments intended for the script file from arguments intended for Julia:"
msgstr "`--` åºåãæå­ã¯ãã¹ã¯ãªãã ãã¡ã¤ã«ãå¯¾è±¡ã¨ããã³ãã³ã ã©ã¤ã³å¼æ°ã Julia ç¨ã®å¼æ°ããåé¢ããããã«ä½¿ç¨ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:61
#, no-wrap
msgid "$ julia --color=yes -O -- foo.jl arg1 arg2..\n"
msgstr "$ julia --color=yes -O -- foo.jl arg1 arg2..\n"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:66
msgid "See also [Scripting](@ref man-scripting) for more information on writing Julia scripts."
msgstr "Julia ã¹ã¯ãªããã®ä½æã®è©³ç´°ã«ã¤ãã¦ã¯ã[ã¹ã¯ãªããã®ä½æ](@ref man-scripting)ãåç§ãã¦ãã ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:75
msgid ""
"Julia can be started in parallel mode with either the `-p` or the `--machine-file` options. `-p n` will launch an additional `n` worker "
"processes, while `--machine-file file` will launch a worker for each line in file `file`. The machines defined in `file` must be accessible "
"via a password-less `ssh` login, with Julia installed at the same location as the current host. Each machine definition takes the form "
"`[count*][user@]host[:port] [bind_addr[:port]]`. `user` defaults to current user, `port` to the standard ssh port. `count` is the number of "
"workers to spawn on the node, and defaults to 1. The optional `bind-to bind_addr[:port]` specifies the IP address and port that other "
"workers should use to connect to this worker."
msgstr ""
"Julia ã¯`-p` ã¾ãã¯ `--machine-file` ãªãã·ã§ã³ãä½¿ç¨ãã¦ä¸¦åã¢ã¼ãã§èµ·åã§ãã¾ãã`-p n` ã¯è¿½å ã§ nåã® ã¯ã¼ã«ã¼ ãã­ã»ã¹ãèµ·åãã`--"
"machine-file ãã¡ã¤ã«` ã¯ãã¡ã¤ã« `file` ã®åè¡ã§ç¤ºãããåæ°ã®ã¯ã¼ã«ã¼ãèµ·åãã¾ã `file``ã§å®ç¾©ããããã·ã³ã¯ï¼ã¤ã®è¦æ±ãæºããã¦ããå¿è¦ã"
"ããã¾ãã1. ç¾å¨ã®ãã¹ãã¨åããã¹ã«Juliaãã¤ã³ã¹ãã¼ã«ããã¦ãããã¨ã2. ãã¹ã¯ã¼ããªãã®`ssh`ã­ã°ã¤ã³ã§ã¢ã¯ã»ã¹å¯è½ãªãã¨ãåãã·ã³å®ç¾©"
"ã¯ã`[count*][user@]host[:port] [bind_addr[:port]] ` ã®å½¢å¼ã§è¡ãã¾ãã`user` ã¯ããã©ã«ãã§ç¾å¨ã®ã¦ã¼ã¶ã¼ãæ¨æºã® ssh ãã¼ãã¸ã® `port` ã§"
"ãã`count` ã¯ãã®ãã¼ãã§èµ·åããã¯ã¼ã«ã¼ã®æ°ã§ãããã©ã«ãã¯ 1 ã§ãããªãã·ã§ã³ã® `bind-to bind_addr[:port]` ã¯ãä»ã®ã¯ã¼ã«ã¼ããã®ã¯ã¼ã«ã¼"
"ã«æ¥ç¶ããããã«ä½¿ç¨ãã IP ã¢ãã¬ã¹ã¨ãã¼ããæå®ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:78
msgid "If you have code that you want executed whenever Julia is run, you can put it in `~/.julia/config/startup.jl`:"
msgstr "Julia ãå®è¡ãããã³ã«å®è¡ããããå¦çã¯ã`~/.julia/config/startup.jl` ã«è¿½è¨ãã¦ãã ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:79
#, no-wrap
msgid ""
"$ echo 'println(\"Greetings! ä½ å¥½! ìëíì¸ì?\")' > ~/.julia/config/startup.jl\n"
"$ julia\n"
"Greetings! ä½ å¥½! ìëíì¸ì?\n"
"\n"
"...\n"
msgstr ""
"$ echo 'println(\"Greetings! ä½ å¥½! ìëíì¸ì?\")' > ~/.julia/config/startup.jl\n"
"$ julia\n"
"Greetings! ä½ å¥½! ìëíì¸ì?\n"
"\n"
"...\n"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:89
msgid "There are various ways to run Julia code and provide options, similar to those available for the `perl` and `ruby` programs:"
msgstr "Julia ã³ã¼ãã®å®è¡æãªãã·ã§ã³ã¯æ§ãã§ã`perl` ãã­ã°ã©ã ã¨ `ruby` ãã­ã°ã©ã ã§ä½¿ç¨ã§ãããã®ã¨ä¼¼ã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:90
#, no-wrap
msgid "julia [switches] -- [programfile] [args...]\n"
msgstr "julia [switches] -- [programfile] [args...]\n"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:127
#, no-wrap
msgid ""
"|Switch                                 |Description|\n"
"|:---                                   |:---|\n"
"|`-v`, `--version`                      |Display version information|\n"
"|`-h`, `--help`                         |Print command-line options (this message).|\n"
"|`--project[={<dir>\\|@.}]`              |Set <dir> as the home project/environment. The default @. option will search through parent directories until a Project.toml or JuliaProject.toml file is found.|\n"
"|`-J`, `--sysimage <file>`              |Start up with the given system image file|\n"
"|`-H`, `--home <dir>`                   |Set location of `julia` executable|\n"
"|`--startup-file={yes\\|no}`             |Load `~/.julia/config/startup.jl`|\n"
"|`--handle-signals={yes\\|no}`           |Enable or disable Julia's default signal handlers|\n"
"|`--sysimage-native-code={yes\\|no}`     |Use native code from system image if available|\n"
"|`--compiled-modules={yes\\|no}`         |Enable or disable incremental precompilation of modules|\n"
"|`-e`, `--eval <expr>`                  |Evaluate `<expr>`|\n"
"|`-E`, `--print <expr>`                 |Evaluate `<expr>` and display the result|\n"
"|`-L`, `--load <file>`                  |Load `<file>` immediately on all processors|\n"
"|`-p`, `--procs {N\\|auto`}              |Integer value N launches N additional local worker processes; `auto` launches as many workers as the number of local CPU threads (logical cores)|\n"
"|`--machine-file <file>`                |Run processes on hosts listed in `<file>`|\n"
"|`-i`                                   |Interactive mode; REPL runs and `isinteractive()` is true|\n"
"|`-q`, `--quiet`                        |Quiet startup: no banner, suppress REPL warnings|\n"
"|`--banner={yes\\|no\\|auto}`             |Enable or disable startup banner|\n"
"|`--color={yes\\|no\\|auto}`              |Enable or disable color text|\n"
"|`--history-file={yes\\|no}`             |Load or save history|\n"
"|`--depwarn={yes\\|no\\|error}`           |Enable or disable syntax and method deprecation warnings (`error` turns warnings into errors)|\n"
"|`--warn-overwrite={yes\\|no}`           |Enable or disable method overwrite warnings|\n"
"|`-C`, `--cpu-target <target>`          |Limit usage of CPU features up to `<target>`; set to `help` to see the available options|\n"
"|`-O`, `--optimize={0,1,2,3}`           |Set the optimization level (default level is 2 if unspecified or 3 if used without a level)|\n"
"|`-g`, `-g <level>`                     |Enable / Set the level of debug info generation (default level is 1 if unspecified or 2 if used without a level)|\n"
"|`--inline={yes\\|no}`                   |Control whether inlining is permitted, including overriding `@inline` declarations|\n"
"|`--check-bounds={yes\\|no}`             |Emit bounds checks always or never (ignoring declarations)|\n"
"|`--math-mode={ieee,fast}`              |Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)|\n"
"|`--code-coverage={none\\|user\\|all}`    |Count executions of source lines|\n"
"|`--code-coverage`                      |equivalent to `--code-coverage=user`|\n"
"|`--track-allocation={none\\|user\\|all}` |Count bytes allocated by each source line|\n"
"|`--track-allocation`                   |equivalent to `--track-allocation=user`|\n"
msgstr ""
"|ã¹ã¤ãã |èª¬æ |\n"
"|:---                                   |:---|\n"
"|`-v`, `--version` |ãã¼ã¸ã§ã³æå ±ã®è¡¨ç¤º |\n"
"|`-h`, `--help` |ã³ãã³ãã©ã¤ã³ãªãã·ã§ã³(ãã®ã¡ãã»ã¼ã¸)ãè¡¨ç¤ºãã |\n"
"|`--project[={<dir>\\|@.}]`              |<dir>ããã¼ã  ãã­ã¸ã§ã¯ã/ç°å¢ã¨ãã¦è¨­å®ãã¾ããããã©ã«ãã®@.ãªãã·ã§ã³ã¯ãProject.toml ã¾ãã¯ JuliaProject.toml ãã¡ã¤ã«ãè¦ã¤ããã¾ã§ãè¦ªãã£ã¬ã¯ããªãæ¤ç´¢ãã¾ãã\n"
"|`-J`, `--sysimage <file>` |ç¹å®ã®ã·ã¹ãã  ã¤ã¡ã¼ã¸ ãã¡ã¤ã«ãä½¿ç¨ãã¦èµ·å |\n"
"|`-H`, `--ãã¼ã <dir>` | Julia å®è¡å¯è½ãã¡ã¤ã«ã®å ´æãè¨­å® |\n"
"|`--startup-file ={yes\\|no} ` | yesãé¸æããå ´åã`~/.julia/config/startup.jl`ãèª­ã¿è¾¼ã|\n"
"|`--handle-signals={yes\\|no} ` |Juliatã®ããã©ã«ãã®ã·ã°ãã«ãã³ãã©ãæå¹ã¾ãã¯ç¡å¹ã«ãã |\n"
"|`---sysimage-native-code={yes\\|no} ` |ä½¿ç¨å¯è½ãªå ´åã¯ãã·ã¹ãã  ã¤ã¡ã¼ã¸ãããã¤ãã£ã ã³ã¼ããä½¿ç¨ãã |\n"
"|`--compiled-modules={yes\\|no} ` |ã¢ã¸ã¥ã¼ã«ã®å¢åããªã³ã³ãã¤ã«ãæå¹ã¾ãã¯ç¡å¹ã«ãã|\n"
"|`-e`, `--eval <expr>` |å¼`<expr>`ãè©ä¾¡ãã |\n"
"|`-E`, `--print <expr>` |å¼`<expr>`ãè©ä¾¡ããçµæãè¡¨ç¤º |\n"
"|`-L`, `--load <file>` | ãã¹ã¦ã®ãã­ã»ããµã§ `file ` ãèª­ã¿è¾¼ã |\n"
"|`-p`, `--procs {N\\|auto}` |æ´æ°å¤ N åã®è¿½å ã®ã­ã¼ã«ã« ã¯ã¼ã«ã¼ ãã­ã»ã¹ãèµ·åãã¾ãã`auto` ã¯ãã­ã¼ã«ã« CPU ã¹ã¬ãã (è«çã³ã¢) ã®æ°ã¨åãæ°ã®ã¯ã¼ã«ã¼ãèµ·åãã¾ãã\n"
"|`--machine-file <file>` | <file>ã«ãªã¹ãããã¦ãããã¹ãã§ãã­ã»ã¹ãå®è¡ãã\n"
"|`-i` |ã¤ã³ã¿ã©ã¯ãã£ãã¢ã¼ã;REPL ãå®è¡ãããããã®ã¨ãã`isinteractive()` ã®æ»ãå¤ã¯true ã¨ãªã |\n"
"|`-q`, `--quiet` |éããªã¹ã¿ã¼ãã¢ãã:ããã¼ãªããREPLè­¦åãæå¶|\n"
"|`--banner={yes\\|no\\|auto}` |ã¹ã¿ã¼ãã¢ãã ããã¼ãæå¹ã¾ãã¯ç¡å¹ã«ãã |\n"
"|`--color={yes\\|no\\|auto}` |ãã­ã¹ãã®è²ãæå¹ã¾ãã¯ç¡å¹ã«ãã |\n"
"|`--history-file={yes\\|no} ` |å±¥æ­´ã®èª­ã¿è¾¼ã¿ã¾ãã¯ä¿å­ |\n"
"|`--depwarn={yes\\|no\\|error}` |éæ¨å¥¨ã®æ§æã¨ã¡ã½ãããä½¿ç¨ããéã®è­¦åãæå¹ã¾ãã¯ç¡å¹ã«ãã (`error` ã¯è­¦åãã¨ã©ã¼ã«å¤ãã) |\n"
"|`--warn-overwrite={yes\\|no} ` |ã¡ã½ããã®ä¸æ¸ãè­¦åãæå¹ã¾ãã¯ç¡å¹ã«ãã|\n"
"|`-C`, `--cpu-target` <target>| ä½¿ç¨ããCPU æ©è½ã <target>ã«å¶éããã ä½¿ç¨å¯è½ãªãªãã·ã§ã³ãè¡¨ç¤ºããã«ã¯ <target>ã«`help` ãè¨­å®ãã¦ Juliaãå®è¡ãã¦ãã ããã |\n"
"|`-O`, `--optimiza={0,1,2,3}` |æé©åã¬ãã«ãè¨­å®ãã (ä¸æå®ã®å ´åã¯ããã©ã«ã ã¬ãã«ã 2ãã¬ãã«ãªãã§ä½¿ç¨ããå ´åã¯ 3)|\n"
"|`-g`, `-g` <level>|ãããã°æå ±çæã®ã¬ãã«ãæå¹/è¨­å®ãã (æå®ããã¦ããªãå ´åã¯ããã©ã«ãã¬ãã«ã 1ãã¬ãã«ãªãã§ä½¿ç¨ããå ´åã¯ 2) |\n"
"|`--inline={yes\\|no}` |`@inline` å®£è¨ã®ãªã¼ãã¼ã©ã¤ãããå«ã¿ãã¤ã³ã©ã¤ã³åãè¨±å¯ããããã©ãããå¶å¾¡ãã |\n"
"|`--check-bounds={yes\\|no}` | å¢çãã§ãã¯ãå¸¸ã«è¡ãããå¸¸ã«ç¡è¦ãããã®æå®ã(ã³ã¼ãä¸ã®å®£è¨ã¯ç¡è¦ããã¾ãã) |\n"
"|`--math-mode={ieee,fast}` |å®å¨ã§ãªãæµ®åå°æ°ç¹ã®æé©åãè¨±å¯ã¾ãã¯æå¹ã«ãã (ããã§æå®ããå¤ã«ãã£ã¦ã@fastmath å®£è¨ã¯ä¸æ¸ãããã¾ã )| |\n"
"|`--code-coverage={none\\|user\\|all}` |ã½ã¼ã¹è¡ã®å®è¡æ°ãã«ã¦ã³ããã |\n"
"|`--code-coverage` |`--code-coverage=user`ãæå®ããã®ã¨ç­ä¾¡|\n"
"|`--track-allocation={none\\|user\\|all}` |åã½ã¼ã¹è¡ã«ã§å²ãå½ã¦ãã¡ã¢ãªã®ãã¤ãæ°ãã«ã¦ã³ããã |\n"
"|`--track-allocation` |`--track-allocation=user`ãæå®ããã®ã¨ç­ä¾¡|\n"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:132
#, no-wrap
msgid ""
"!!! compat \"Julia 1.1\"\n"
"    In Julia 1.0, the default `--project=@.` option did not search up from the root\n"
"    directory of a Git repository for the `Project.toml` file. From Julia 1.1 forward, it\n"
"    does.\n"
msgstr ""
"!!! compat \"Julia1.1\"\n"
"    Julia 1.0 ã§ã¯ãããã©ã«ãã® `--project=@.` ãªãã·ã§ã³ã¯Gitã¬ãã¸ããªã®ã«ã¼ããã£ã¬ã¯ããªãã`Project.toml`ãæ¢ããã¨ã¯ãã¾ããã§ããã Julia1.1ããã¯ãè¡ãã¾ãã\n"

#. type: Title ##
#: ext/julia/doc/src/manual/getting-started.md:133
#, no-wrap
msgid "Resources"
msgstr "ãªã½ã¼ã¹"

#. type: Plain text
#: ext/julia/doc/src/manual/getting-started.md:135
msgid ""
"A curated list of useful learning resources to help new users get started can be found on the [learning](https://julialang.org/learning/) "
"page of the main Julia web site."
msgstr ""
"æ°ããã¦ã¼ã¶ã¼ãJuliaãå§ããã®ã«å½¹ç«ã¤å­¦ç¿ãªã½ã¼ã¹ã®ã­ã¥ã¬ã¼ã·ã§ã³ãªã¹ãã¯ãJuliaã®ã¡ã¤ã³ã¦ã§ããµã¤ãã®[learning](https://julialang.org/"
"learning/)ãã¼ã¸ã«ããã¾ãã"

#. type: Title #
#: ext/julia/doc/src/manual/types.md:1
#, no-wrap
msgid "[Types](@id man-types)"
msgstr "[å](@id man-types)"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:11
msgid ""
"Type systems have traditionally fallen into two quite different camps: static type systems, where every program expression must have a type "
"computable before the execution of the program, and dynamic type systems, where nothing is known about types until run time, when the actual "
"values manipulated by the program are available. Object orientation allows some flexibility in statically typed languages by letting code be "
"written without the precise types of values being known at compile time. The ability to write code that can operate on different types is "
"called polymorphism.  All code in classic dynamically typed languages is polymorphic: only by explicitly checking types, or when objects "
"fail to support operations at run-time, are the types of any values ever restricted."
msgstr ""
"åã·ã¹ãã ã¯ãå¾æ¥ã2 ã¤ã®å¨ãç°ãªãé£å¶ã«åé¡ããã¦ãã¾ããã: éçåã·ã¹ãã ã¨åçåã·ã¹ãã ã§ããéçåã·ã¹ãã ã§ã¯ã ãã¹ã¦ã®ãã­ã°ã©ã ã®"
"å¼ã¯ããã­ã°ã©ã ã®å®è¡åã«ç®åºå¯è½ãªåãæã¤å¿è¦ãããã¾ããä¸æ¹åçåã·ã¹ãã ã§ã¯ããã­ã°ã©ã ã«ãã£ã¦å¦çããããããå®éã®å¤ãä½¿ç¨å¯è½ã«ãª"
"ãå®è¡æã¾ã§ãåã«ã¤ãã¦ã¯ä½ããããã¾ããããªãã¸ã§ã¯ãå¿åãã­ã°ã©ãã³ã°ãããã°ãéçåä»ãè¨èªã§ããã³ã³ãã¤ã«æã«æ­£ç¢ºãªå¤ã®åãåãããª"
"ãã¦ãã³ã¼ããè¨è¿°ã§ããããã¦ãã©æè»æ§ã¯é«ããªãã¾ããè¤æ°ã®ç°ãªãåãæä½ã§ããã³ã¼ããè¨è¿°ããæ©è½ã¯ãããªã¢ã¼ãã£ãºã ã¨å¼ã°ãã¾ãã å¾æ¥"
"ã®åçåä»ãè¨èªã®ãã¹ã¦ã®ã³ã¼ãã¯ããªã¢ã¼ãã£ãã¯ã§ã: åã«å¶ç´ãçããã®ã¯ãæç¤ºçãªåæ¤æ»ãè¡ãå ´åãããã¯ããªãã¸ã§ã¯ããå®è¡æã«æä½ã«"
"å¯¾å¿ã§ããªããªã£ãå ´åã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:17
msgid ""
"Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain "
"values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method "
"dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in [Methods]"
"(@ref), but is rooted in the type system presented here."
msgstr ""
"Julia ã®åã·ã¹ãã ã¯åçã§ãããç¹å®ã®å¤ãç¹å®ã®åã§ãããã¨ãæç¤ºãããã¨ã§ãéçåã·ã¹ãã ã®å©ç¹ã®ä¸é¨ãå¾ããã¨ãã§ãã¾ããããã¯å¹ççãª"
"ã³ã¼ããçæããä¸ã§å¤§ãã«å©ãã«ãªãã®ã§ãããããã«éè¦ãªãã¨ã«ãé¢æ°å¼æ°ã®åã«å¯¾ããã¡ã½ãããã£ã¹ããããè¨èªã¨æ·±ãçµ±åã§ããã®ã§ããã¡"
"ã½ãããã£ã¹ãããã¯[ã¡ã½ãã](@ref Methods)ã§è©³ããèª¬æãã¾ãããããã§èª¬æããåã·ã¹ãã ã«æ ¹ããã¦ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:24
msgid ""
"The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write many useful Julia functions "
"without ever explicitly using types. When additional expressiveness is needed, however, it is easy to gradually introduce explicit type "
"annotations into previously \"untyped\" code. Adding annotations serves three primary purposes: to take advantage of Julia's powerful "
"multiple-dispatch mechanism, to improve human readability, and to catch programmer errors."
msgstr ""
"åãçç¥ããå ´åã® Julia ã®æ¢å®ã®æåã§ã¯ãå¤ã«å¯¾ãã¦ä»»æã®åãè¨±å®¹ããã¾ãããããã£ã¦ãåãæç¤ºçã«ä½¿ç¨ããªãã¦ããå¤ãã®ä¾¿å©ãª Julia é¢æ°"
"ãè¨è¿°ã§ãã¾ãããã ããè¿½å ã®è¡¨ç¾åãå¿è¦ãªå ´åã¯ãåã® \"åæå®ããã¦ããªã\" ã³ã¼ãã«å¯¾ãã¦æç¤ºçãªåæ³¨éãå¾ãã«å°å¥ãããã¨ã¯ç°¡åã§ãã"
"åæ³¨éã®ç®çã¯ä¸»ã«3ã¤ããã¾ããJulia ã®å¼·åãªå¤éãã£ã¹ããã ã¡ã«ããºã ãå©ç¨ãããã¨ãäººéã«ã¨ã£ã¦èª­ã¿ããããããã¨ããã­ã°ã©ãã®ã¨ã©ã¼ã"
"è£è¶³ã§ããããã«ãããã¨ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:36
msgid ""
"Describing Julia in the lingo of [type systems](https://en.wikipedia.org/wiki/Type_system), it is: dynamic, nominative and parametric. "
"Generic types can be parameterized, and the hierarchical relationships between types are [explicitly declared](https://en.wikipedia.org/wiki/"
"Nominal_type_system), rather than [implied by compatible structure](https://en.wikipedia.org/wiki/Structural_type_system).  One particularly "
"distinctive feature of Julia's type system is that concrete types may not subtype each other: all concrete types are final and may only have "
"abstract types as their supertypes.  While this might at first seem unduly restrictive, it has many beneficial consequences with "
"surprisingly few drawbacks. It turns out that being able to inherit behavior is much more important than being able to inherit structure, "
"and inheriting both causes significant difficulties in traditional object-oriented languages. Other high-level aspects of Julia's type "
"system that should be mentioned up front are:"
msgstr ""
"Julia ãã[åã·ã¹ãã ](https://en.wikipedia.org/wiki/Type_system)ã®è¨èã§èª¬æãããªãã°ãåçã§ãå¬ç§°çã§ããã©ã¡ããªãã¯ãã¨ããããã¨ã«ãªã"
"ã¾ããã¸ã§ããªãã¯åã¯ãã©ã¡ã¼ã¿åã§ããååå£«ãæã¤éå±¤çãªé¢ä¿ã¯[äºææ§ã®ããæ§é ã«ãã£ã¦æç¤ºããã](https://en.wikipedia.org/wiki/"
"Structural_type_system)ã®ã§ã¯ãªãã[æç¤ºçã«å®£è¨](https://en.wikipedia.org/wiki/Nominal_type_system)ããã¾ããJulia ã®åã·ã¹ãã ã®ç¹ã«ç¹å¾´ç"
"ãªç¹å¾´ã® 1 ã¤ã¯ãå·è±¡åãäºãã«äºãã®ãµãã¿ã¤ãã«ã¯ã§ããªãã¨ãããã¨ã§ããå¨ã¦ã®å·ä½åã¯å¨ã¦ãã¡ã¤ãã«(ä¸ã®éå±¤ãæããªã)ã§ãå·è±¡åã®ãµãã¿"
"ã¤ã(ä¸ã®éå±¤)ã¯æ½è±¡åã®ã¿ã§ããæåã¯éåº¦ãªå¶éã«è¦ããããããã¾ãããããã®å¶ç´ã¯é©ãã»ã©æ¬ ç¹ãå°ãªããå¤ãã®æçãªçµæãå°ãã¾ããåä½ã"
"ç¶æ¿ã§ãããã¨ã¯ãæ§é ãç¶æ¿ãããããã¯ããã«éè¦ã§ããããã®ä¸¡æ¹ãç¶æ¿ããã¨ãå¾æ¥ã®ãªãã¸ã§ã¯ãæåè¨èªã®ããã«å¤§ããªå°é£ãçãã¾ããå"
"ãã£ã¦è¨åãã¹ãJuliaã®åã·ã¹ãã ã®ä»ã®é«ã¬ãã«ã®å´é¢ã¯æ¬¡ã®ã¨ããã§ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:49
msgid ""
"There is no division between object and non-object values: all values in Julia are true objects having a type that belongs to a single, "
"fully connected type graph, all nodes of which are equally first-class as types."
msgstr ""
"ãªãã¸ã§ã¯ããéãªãã¸ã§ã¯ããã¨ããåºåã¯ããã¾ãã: Julia ã®ãã¹ã¦ã®å¤ã¯ãåä¸ã®å®å¨ã«æ¥ç¶ãããåã°ã©ãã«å±ããåãæã¤çã®ãªãã¸ã§ã¯ãã§"
"ããããã¹ã¦ã®ãã¼ãã¯åã¨ãã¦ç­ãããã¡ã¼ã¹ãã¯ã©ã¹ã§ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:49
msgid ""
"There is no meaningful concept of a \"compile-time type\": the only type a value has is its actual type when the program is running. This is "
"called a \"run-time type\" in object-oriented languages where the combination of static compilation with polymorphism makes this distinction "
"significant."
msgstr ""
"ãã³ã³ãã¤ã«æã®åãã¨ããèãæ¹ã¯æå³ãããã¾ãã: å¤ãæã¤åã¯ããã­ã°ã©ã ã®å®è¡ä¸­ã®å®éã®åã ãã§ããéçã³ã³ãã¤ã«ã¨ããªã¢ã¼ãã£ãºã ã®çµ"
"ã¿åããã§æãç«ã¤ãªãã¸ã§ã¯ãæåã®è¨èªã«ããã¦ã¯ãã³ã³ãã¤ã«æ/å®è¡ä¸­ã®åã®åºå¥ãéè¦ã«ãªããå®è¡ä¸­ã®åã®ãã¨ã¯ãã©ã³ã¿ã¤ã åãã¨å¼ã³ã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:49
msgid "Only values, not variables, have types -- variables are simply names bound to values."
msgstr "å¤æ°ã§ã¯ãªãå¤ã ããåãæã¡ã¾ããå¤æ°ã¯åã«å¤ã«ãã¤ã³ããããååã§ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:49
msgid ""
"Both abstract and concrete types can be parameterized by other types. They can also be parameterized by symbols, by values of any type for "
"which [`isbits`](@ref) returns true (essentially, things like numbers and bools that are stored like C types or `struct`s with no pointers "
"to other objects), and also by tuples thereof. Type parameters may be omitted when they do not need to be referenced or restricted."
msgstr ""
"æ½è±¡åã¨å·è±¡åã®ä¸¡æ¹ãä»ã®åã§ãã©ã¡ã¼ã¿åã§ãã¾ããã¾ããã·ã³ãã«ãå¤ã§ãã®åã [`isbits`](@ref)ã§ true ãè¿ããããã®(æ¬è³ªçã«ã¯ãæ°å¤ãç"
"å½å¤ãªã©ã§ãä»ã®ãªãã¸ã§ã¯ãã¸ã®ãã¤ã³ã¿ãæããªãCåã`struct`ãªã©ã«æ ¼ç´ããã¦ãããã®)ãããã³ãããã®ã¿ãã«ãªã©ã«ãã£ã¦ãã©ã¡ã¼ã¿åããã"
"ã¨ãã§ãã¾ããåãã©ã¡ã¼ã¿ã¼ã¯ãåç§ãå¶éãããå¿è¦ããªãå ´åã«ã¯çç¥ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:53
msgid ""
"Julia's type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive.  Many Julia programmers may never feel "
"the need to write code that explicitly uses types. Some kinds of programming, however, become clearer, simpler, faster and more robust with "
"declared types."
msgstr ""
"Julia ã®åã·ã¹ãã ã¯ãå¼·åã§è¡¨ç¾åè±ãã§ãããªãããæç¢ºã§ç´æçã§æ§ããã§ããããã«è¨­è¨ããã¦ãã¾ãã Julia ãã­ã°ã©ãã®å¤ãã¯ãåãæç¤ºçã«"
"ä½¿ç¨ããã³ã¼ããè¨è¿°ããå¿è¦æ§ãæããªãããããã¾ããããã ããããç¨®ã®ãã­ã°ã©ãã³ã°ã§ã¯ãå®£è¨ãããåãä½¿ç¨ããã¨ãããæç¢ºã§ãããã·ã³ã"
"ã«ã§ãããéããããå ç¢ã«ãªãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:54
#, no-wrap
msgid "Type Declarations"
msgstr "[åå®£è¨](@id type-declarations)"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:58
msgid ""
"The `::` operator can be used to attach type annotations to expressions and variables in programs.  There are two primary reasons to do this:"
msgstr "æ¼ç®å­ `::` ãä½¿ç¨ããã¨ããã­ã°ã©ã åã®å¼ãå¤æ°ã«åæ³¨éãã¤ãããã¨ãã§ãã¾ãããããè¡ãçç±ã¯ä¸»ã«2 ã¤ã§ã:"

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/types.md:62
msgid "As an assertion to help confirm that your program works the way you expect,"
msgstr "ãã­ã°ã©ã ãæå¾ã©ããã«åä½ãããã¨ãç¢ºèªããããã®ã¢ãµã¼ã·ã§ã³ã¨ãã¦ã"

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/types.md:62
msgid "To provide extra type information to the compiler, which can then improve performance in some cases"
msgstr "ã³ã³ãã¤ã©ã«è¿½å ã®åæå ±ãæä¾ããç¶æ³ã«ãã£ã¦ã¯ããã©ã¼ãã³ã¹ãåä¸ã§ããããã«ãããã¨"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:70
msgid ""
"When appended to an expression computing a value, the `::` operator is read as \"is an instance of\". It can be used anywhere to assert that "
"the value of the expression on the left is an instance of the type on the right. When the type on the right is concrete, the value on the "
"left must have that type as its implementation -- recall that all concrete types are final, so no implementation is a subtype of any other. "
"When the type is abstract, it suffices for the value to be implemented by a concrete type that is a subtype of the abstract type. If the "
"type assertion is not true, an exception is thrown, otherwise, the left-hand value is returned:"
msgstr ""
"è¨ç®å¼ã«è¿½å ãã`::`æ¼ç®å­ã¯ \"is an instance of\" ã¨èª­ã¿ä¸ããã¨ãã§ãã¾ãããã®æ¼ç®å­ã¯ã©ãã§ãä½¿ç¨ãããã¨ãã§ããæ¼ç®å­ã®å·¦å´ã®å¼ã®å¤ãå³"
"å´ã®åã®ã¤ã³ã¹ã¿ã³ã¹ã§ãããã¨ãè¡¨æãã¾ããæ¼ç®å­ã®å³å´ã®åãå·è±¡åã®å ´åãå·¦å´ã®å¤ã¯ãã®åã®å®è£ã§ãªããã°ãªãã¾ãããå¨ã¦ã®å·è±¡åã¯ããã¡"
"ã¤ãã«ã§ããã®å®è£ã¯ä»ã®ã©ã®å·è±¡åã®ãµãã¿ã¤ãã«ããªããªããã¨ãæãåºãã¦ãã ãããä¸æ¹ãæ¼ç®å­ã®å³å´ã®åãæ½è±¡åã®å ´åãæ¼ç®å­ã®å·¦å´ã®å¤"
"ã¯ãæ½è±¡åã®ãµãã¿ã¤ãã§ããå·ä½çãªåã«ãã£ã¦å®è£ãããã¦ããã°ååã§ããåã¢ãµã¼ã·ã§ã³ã çã§ãªãå ´åã¯ãä¾å¤ãæãããã¾ãããããä»¥å¤ã®å ´"
"åã¯æ¼ç®å­ã®å·¦å´ã®å¤ãè¿ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:71
#, no-wrap
msgid ""
"julia> (1+2)::AbstractFloat\n"
"ERROR: TypeError: in typeassert, expected AbstractFloat, got Int64\n"
"\n"
"julia> (1+2)::Int\n"
"3\n"
msgstr ""
"julia> (1+2)::AbstractFloat\n"
"ERROR: TypeError: in typeassert, expected AbstractFloat, got Int64\n"
"\n"
"julia> (1+2)::Int\n"
"3\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:80
msgid "This allows a type assertion to be attached to any expression in-place."
msgstr "ããã«ãããåã¢ãµã¼ã·ã§ã³ãä»»æã®å¼ã«å·®ãè¾¼ããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:85
msgid ""
"When appended to a variable on the left-hand side of an assignment, or as part of a `local` declaration, the `::` operator means something a "
"bit different: it declares the variable to always have the specified type, like a type declaration in a statically-typed language such as C. "
"Every value assigned to the variable will be converted to the declared type using [`convert`](@ref):"
msgstr ""
"ä»£å¥æã®å·¦è¾ºãã`local` å®£è¨ã®ä¸é¨ã«è¿½å ããã¨ã`::` æ¼ç®å­ã®æã¤æå³ãå°ãå¤ããã¾ããCè¨èªã®ãããªãéçåä»ãè¨èªã®åå®£è¨ã®ããã«ãå¸¸ã«æ"
"å®ãããåãæã¤å¤æ°ãå®£è¨ã«ãªãã¾ããå¤æ°ã«å²ãå½ã¦ãããå¤ã¯ãã¹ã¦ã[`convert()`](@ref) ãä½¿ç¨ãã¦å®£è¨ãããåã«å¤æããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:86
#, no-wrap
msgid ""
"julia> function foo()\n"
"           x::Int8 = 100\n"
"           x\n"
"       end\n"
"foo (generic function with 1 method)\n"
"\n"
"julia> foo()\n"
"100\n"
"\n"
"julia> typeof(ans)\n"
"Int8\n"
msgstr ""
"julia> function foo()\n"
"           x::Int8 = 100\n"
"           x\n"
"       end\n"
"foo (generic function with 1 method)\n"
"\n"
"julia> foo()\n"
"100\n"
"\n"
"julia> typeof(ans)\n"
"Int8\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:102
msgid ""
"This feature is useful for avoiding performance \"gotchas\" that could occur if one of the assignments to a variable changed its type "
"unexpectedly."
msgstr ""
"ãã®æ©è½ã¯ãå¤æ°ã¸ã®ä»£å¥ãè¡ã£ã¦ã å¤ãæ³å®ããªãåã«å¤æ´ããã¦ãã¾ã£ãæã«èµ·ãããã¨ã®ãããããã©ã¼ãã³ã¹ä¸ã® ãè½ã¨ãç©´ã ãåé¿ããã®ã«å½¹"
"ç«ã¡ã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:104
msgid "This \"declaration\" behavior only occurs in specific contexts:"
msgstr "ãã® ãå®£è¨ãã®åä½ã¯ãç¹å®ã®ã³ã³ãã­ã¹ãã§ã®ã¿çºçãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:105
#, no-wrap
msgid ""
"local x::Int8  # in a local declaration\n"
"x::Int8 = 10   # as the left-hand side of an assignment\n"
msgstr ""
"local x::Int8  # in a local declaration\n"
"x::Int8 = 10   # as the left-hand side of an assignment\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:113
msgid ""
"and applies to the whole current scope, even before the declaration. Currently, type declarations cannot be used in global scope, e.g. in "
"the REPL, since Julia does not yet have constant-type globals."
msgstr ""
"ããã¦ãå®£è¨ã®åã§ãã£ã¦ããç¾å¨ã®ã¹ã³ã¼ãå¨ä½ã«é©ç¨ããã¾ããç¾å¨ãJulia ã«ã¯å®æ°åã°ã­ã¼ãã«ããªããããåå®£è¨ã¯ REPL ãªã©ã®ã°ã­ã¼ãã« ã¹"
"ã³ã¼ãã§ã¯ä½¿ç¨ã§ãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:115
msgid "Declarations can also be attached to function definitions:"
msgstr "ã¾ããå®£è¨ããé¢æ°å®ç¾©ã«å·®ãè¾¼ããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:116
#, no-wrap
msgid ""
"function sinc(x)::Float64\n"
"    if x == 0\n"
"        return 1\n"
"    end\n"
"    return sin(pi*x)/(pi*x)\n"
"end\n"
msgstr ""
"function sinc(x)::Float64\n"
"    if x == 0\n"
"        return 1\n"
"    end\n"
"    return sin(pi*x)/(pi*x)\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:127
msgid ""
"Returning from this function behaves just like an assignment to a variable with a declared type: the value is always converted to `Float64`."
msgstr "ãã®é¢æ°ã®æ»ãå¤ã¯ãå®£è¨ãããåã®å¤æ°ã¸ã®ä»£å¥ã¨åãæ§ã«å¦çããã¾ããå¤ã¯å¸¸ã«`Float64` ã«å¤æããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:128
#, no-wrap
msgid "Abstract Types"
msgstr "æ½è±¡å"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:135
msgid ""
"Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing sets of related concrete types: those "
"concrete types which are their descendants. We begin with abstract types even though they have no instantiation because they are the "
"backbone of the type system: they form the conceptual hierarchy which makes Julia's type system more than just a collection of object "
"implementations."
msgstr ""
"æ½è±¡åã¯ã¤ã³ã¹ã¿ã³ã¹åã§ãããåã°ã©ãåã®ãã¼ãã¨ãã¦ã®ã¿æ©è½ããã ãã§ãããã ããããé¢é£ããå·è±¡åã®éå(æ½è±¡åã®å­å­«ã§ããå·è±¡å)ãèª¬æ"
"ã§ãã¾ããåã®èª¬æã¯æ½è±¡åããå§ãã¾ããã¤ã³ã¹ã¿ã³ã¹åã¯ã§ããªãã§ãããæ½è±¡åã¯åã·ã¹ãã ã®ããã¯ãã¼ã³ã ããã§ããæ½è±¡åã¯æ¦å¿µçãª(åã®)é"
"å±¤ãå½¢æãã¾ãããã®éå±¤ããJulia Noåã·ã¹ãã ãåãªããªãã¸ã§ã¯ãå®è£ã®å¯ãéãä»¥ä¸ã®ãã®ã«ãã¦ããã®ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:150
msgid ""
"Recall that in [Integers and Floating-Point Numbers](@ref), we introduced a variety of concrete types of numeric values: [`Int8`](@ref), "
"[`UInt8`](@ref), [`Int16`](@ref), [`UInt16`](@ref), [`Int32`](@ref), [`UInt32`](@ref), [`Int64`](@ref), [`UInt64`](@ref), [`Int128`](@ref), "
"[`UInt128`](@ref), [`Float16`](@ref), [`Float32`](@ref), and [`Float64`](@ref). Although they have different representation sizes, `Int8`, "
"`Int16`, `Int32`, `Int64` and `Int128` all have in common that they are signed integer types. Likewise `UInt8`, `UInt16`, `UInt32`, `UInt64` "
"and `UInt128` are all unsigned integer types, while `Float16`, `Float32` and `Float64` are distinct in being floating-point types rather "
"than integers. It is common for a piece of code to make sense, for example, only if its arguments are some kind of integer, but not really "
"depend on what particular *kind* of integer. For example, the greatest common denominator algorithm works for all kinds of integers, but "
"will not work for floating-point numbers. Abstract types allow the construction of a hierarchy of types, providing a context into which "
"concrete types can fit. This allows you, for example, to easily program to any type that is an integer, without restricting an algorithm to "
"a specific type of integer."
msgstr ""
"[æ´æ°ã¨æµ®åå°æ°ç¹æ°](@ref integers-and-floating-point-numbers)ã§ã¯ããã¾ãã¾ãªå·ä½çãªæ°å¤ãå°å¥ãã¾ãã: [`Int8`](@ref)ã[`UInt8`](@ref)ã"
"[`Int16`](@ref)ã[`UInt16`](@ref)ã[`Int32`](@ref)ã[`UInt32`](@ref)ã[`Int64`](@ref)ã[`UInt64]`(@ref)ã[`Int128`](@ref)ã[`UInt128`]"
"(@ref)ã[`Float16`](@ref)ã[`Float32`](@ref)ãããã³[`Float64`](@ref)ã§ããè¡¨ç¾ã®ãµã¤ãºã¯ç°ãªãã¾ããã`Int8`ã`Int16`ã`Int32`ã`Int64`ã"
"`Int128` ã«ã¯ããã¹ã¦æ´æ°åãç¬¦å·ä»ãåã§ããã¨ããå±éç¹ãããã¾ããåæ§ã«ã`UInt8`ã`UInt16`ã`UInt32`ã`UInt64`ããã³`UInt128`ã¯ç¬¦å·ãªãæ´"
"æ°åã§ããã`Float16`ã`Float32`ã`Float64`ã¯æ´æ°ã§ã¯ãªãæµ®åå°æ°ç¹åã¨ã¯ç°ãªãã¾ãããã¨ãã°ãå¼æ°ãä½ããã®æ´æ°ã§ããå ´åã«ã®ã¿ãã³ã¼ãã®ä¸"
"é¨ãæå³ããªãã®ãä¸è¬çã§ãããå®éã«ã¯æ´æ°ã®ç¹å®ã® *ç¨®é¡* ã«ä¾å­ãã¾ããããã¨ãã°ãæå¤§å¬ç´æ°ãæ±ããã¢ã«ã´ãªãºã ã¯ãããããç¨®é¡ã®æ´æ°ã«"
"å¯¾ãã¦æ©è½ãã¾ãããæµ®åå°æ°ç¹æ°ã§ã¯æ©è½ãã¾ãããæ½è±¡åãä½¿ç¨ããã¨ãåã®éå±¤ãæ§ç¯ã§ããå·ä½çãªåãé©åããã³ã³ãã­ã¹ããæä¾ã§ãã¾ããã"
"ãã«ããããã¨ãã°ãã¢ã«ã´ãªãºã ãç¹å®ã®æ´æ°ã«å¶éãããã¨ãªããæ´æ°ã§ããä»»æã®åã«å¯¾ãã¦ãã­ã°ã©ãã³ã°ãããã¨ãç°¡åã«ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:153
msgid "Abstract types are declared using the [`abstract type`](@ref) keyword. The general syntaxes for declaring an abstract type are:"
msgstr "æ½è±¡åã¯[`abstract type`](@ref)ã­ã¼ã¯ã¼ããä½¿ç¨ãã¦å®£è¨ããã¾ããæ½è±¡åãå®£è¨ããããã®ä¸è¬çãªæ§æã¯æ¬¡ã®ã¨ããã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:154
#, no-wrap
msgid ""
"abstract type Â«nameÂ» end\n"
"abstract type Â«nameÂ» <: Â«supertypeÂ» end\n"
msgstr ""
"abstract type Â«nameÂ» end\n"
"abstract type Â«nameÂ» <: Â«supertypeÂ» end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:162
#, no-wrap
msgid ""
"The `abstract type` keyword introduces a new abstract type, whose name is given by `Â«nameÂ»`. This\n"
"name can be optionally followed by [`<:`](@ref) and an already-existing type, indicating that the newly\n"
"declared abstract type is a subtype of this \"parent\" type.\n"
msgstr "`abstract type` ã­ã¼ã¯ã¼ãã¯ãååã `Â«nameÂ»` ã§æå®ãããæ°ããæ½è±¡åãå°å¥ãã¾ãããã®ååã®å¾ã«ã¯ã[`<:`](@ref) ã¨ æ¢å­ã®åãç¶ããã¨ããããããã¯æ°ããå®£è¨ãããæ½è±¡åãã\"è¦ª\"ã¨ãããµãã¿ã¤ãã§ãããã¨ãç¤ºãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:168
msgid ""
"When no supertype is given, the default supertype is `Any` -- a predefined abstract type that all objects are instances of and all types are "
"subtypes of. In type theory, `Any` is commonly called \"top\" because it is at the apex of the type graph. Julia also has a predefined "
"abstract \"bottom\" type, at the nadir of the type graph, which is written as `Union{}`. It is the exact opposite of `Any`: no object is an "
"instance of `Union{}` and all types are supertypes of `Union{}`."
msgstr ""
"ã¹ã¼ãã¼ã¿ã¤ããæå®ããã¦ããªãå ´åãããã©ã«ãã®ã¹ã¼ãã¼ã¿ã¤ãã¯ `Any` ã§ããããã¯ãå®ç¾©æ¸ã¿ã®æ½è±¡åã§ãå¨ã¦ã®ãªãã¸ã§ã¯ãã¯`Any`ã®ã¤ã³ã¹"
"ã¿ã³ã¹ã§ããããã¹ã¦ã®åã`Any`ã®ãµãã¿ã¤ãã«ãªãã¾ããåçè«ã§`Any`ã¯ãåã°ã©ãã®é ç¹ã«ãããããä¸è¬çã« ããããã ã¨å¼ã°ãã¾ããJulia ã«"
"ã¯å®ç¾©æ¸ã®æ½è±¡åã® ãããã ããããã¾ããããã¯ãåã®ã°ã©ãã®æä¸å±¤ã«ãã£ã¦ã`Union{}` ã¨æ¸ãã¾ããããã¯ `Any` ã®æ­£åå¯¾ã§ã: å¨ã¦ã®ãªãã¸ã§"
"ã¯ãã¯ `Union{}` ã®ã¤ã³ã¹ã¿ã³ã¹ã§ã¯ãªããããã¹ã¦ã®åã¯ `Union{}` ã®ã¹ã¼ãã¼ã¿ã¤ãã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:170
msgid "Let's consider some of the abstract types that make up Julia's numerical hierarchy:"
msgstr "Julia ã®æ°å¤åã®éå±¤ãæ§æããæ½è±¡åã®ããã¤ããèãã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:171
#, no-wrap
msgid ""
"abstract type Number end\n"
"abstract type Real     <: Number end\n"
"abstract type AbstractFloat <: Real end\n"
"abstract type Integer  <: Real end\n"
"abstract type Signed   <: Integer end\n"
"abstract type Unsigned <: Integer end\n"
msgstr ""
"abstract type Number end\n"
"abstract type Real     <: Number end\n"
"abstract type AbstractFloat <: Real end\n"
"abstract type Integer  <: Real end\n"
"abstract type Signed   <: Integer end\n"
"abstract type Unsigned <: Integer end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:188
msgid ""
"The [`Number`](@ref) type is a direct child type of `Any`, and [`Real`](@ref) is its child.  In turn, `Real` has two children (it has more, "
"but only two are shown here; we'll get to the others later): [`Integer`](@ref) and [`AbstractFloat`](@ref), separating the world into "
"representations of integers and representations of real numbers. Representations of real numbers include, of course, floating-point types, "
"but also include other types, such as rationals. Hence, `AbstractFloat` is a proper subtype of `Real`, including only floating-point "
"representations of real numbers. Integers are further subdivided into [`Signed`](@ref) and [`Unsigned`](@ref) varieties."
msgstr ""
"[`Number`](@ref)ã¯ãAnyãã®ç´æ¥ã®å­ã§ãã[`Real`](@ref)ã¯ãã®ããã«å­ã«å½ããã¾ããããã¦ã`Real` ã«ã¯2äººã®å­ä¾ããã¾ã(æ¬å½ã¯ãã£ã¨ããã¾ã"
"ããããã§ã¯2ã¤ã ãç¤ºãã¾ããä»ã®ãã®ã¯å¾è¿°ãã¾ã): ä¸ã¤ã¯ [`Integer`](@ref)ãããä¸ã¤ã¯[`AbstractFloat`](@ref) ã§ããæ°ã®ä¸çãæ´æ°ã¨å®æ°ã®"
"è¡¨ç¾ã«åãã¾ããå®æ°ã®è¡¨ç¾ã«ã¯ããã¡ããæµ®åå°æ°ç¹åãå«ã¾ããã®ã§ãããæçæ°ãªã©ä»ã®åãããã¾ãããããã£ã¦ã`AbstractFloat`ã¯ `Real` ã®ç"
"ã®ãµãã¿ã¤ãã§ãå®æ°ã®æµ®åå°æ°ç¹è¡¨ç¾ã®ã¿ãå«ã¿ã¾ããæ´æ°ã¯ããã«[`signed`](@ref)ã¨[`unsigned`](@ref) ã«ç´°åããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:193
#, no-wrap
msgid ""
"The `<:` operator in general means \"is a subtype of\", and, used in declarations like this, declares\n"
"the right-hand type to be an immediate supertype of the newly declared type. It can also be used\n"
"in expressions as a subtype operator which returns `true` when its left operand is a subtype of\n"
"its right operand:\n"
msgstr "`<:` æ¼ç®å­ã¯ä¸è¬ã«\"is a subtype of\" ãæå³ãã¦ãããæ¬¡ã®ããã«å®£è¨ã§ä½¿ç¨ãã¾ããæ¼ç®å­ã®å³å´ã®åããæ°ããå®£è¨ããåã®ã¹ã¼ãã¼ã¿ã¤ãã§ãããã¨ããå®£è¨ããã¾ããã¾ããå¼ã®ä¸­ã§ã¯ããµãã¿ã¤ãæ¼ç®å­ã¨ãã¦å©ç¨ãããã¨ãã§ããå·¦ã®ãªãã©ã³ãããå³ã®ãªãã©ã³ãã®ãµãã¿ã¤ãã§ããå ´åã« `true`ãè¿ãã¾ã:\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:194
#, no-wrap
msgid ""
"julia> Integer <: Number\n"
"true\n"
"\n"
"julia> Integer <: AbstractFloat\n"
"false\n"
msgstr ""
"julia> Integer <: Number\n"
"true\n"
"\n"
"julia> Integer <: AbstractFloat\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:204
msgid "An important use of abstract types is to provide default implementations for concrete types. To give a simple example, consider:"
msgstr "æ½è±¡åã®éè¦ãªä½¿ç¨æ¹æ³ã«ãå·è±¡åã®æ¢å®ã®å®è£ã®æä¾ãããã¾ããç°¡åãªä¾ã¨ãã¦ãä»¥ä¸ãèãã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:205
#, no-wrap
msgid ""
"function myplus(x,y)\n"
"    x+y\n"
"end\n"
msgstr ""
"function myplus(x,y)\n"
"    x+y\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:215
msgid ""
"The first thing to note is that the above argument declarations are equivalent to `x::Any` and `y::Any`. When this function is invoked, say "
"as `myplus(2,5)`, the dispatcher chooses the most specific method named `myplus` that matches the given arguments. (See [Methods](@ref) for "
"more information on multiple dispatch.)"
msgstr ""
"æåã«æ³¨æãã¹ãç¹ã¯ãä¸è¨ã®å¼æ°å®£è¨ã¯ã `x::Any` ããã³ `y::Any` ã¨ããã®ã«ç¸å½ãããã¨ãããã¨ã§ãããã®é¢æ°ã`myplus(2,5)`ã®ããã«å¼ã³åºã"
"ããã¨ããã£ã¹ãããã£ã¼ã¯æå®ãããå¼æ°ã«ä¸è´ãã `myplus`ã¨ããååã®æãå·ä½çãªã¡ã½ãããé¸æãã¾ãã(å¤éãã£ã¹ãããã®è©³ç´°ã«ã¤ãã¦ã¯ã"
"[ã¡ã½ãã](@ref Methods)ãåç§ãã¦ãã ãããï¼"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:219
msgid ""
"Assuming no method more specific than the above is found, Julia next internally defines and compiles a method called `myplus` specifically "
"for two `Int` arguments based on the generic function given above, i.e., it implicitly defines and compiles:"
msgstr ""
"ä¸è¨ã®ã¡ã½ããããå·ä½çãªã¡ã½ãããè¦ã¤ãããªãå ´åãJulia ã¯æ¬¡ã«åé¨ã§ `myplus`ã¨ããååã®ã¡ã½ãããå®ç¾©ãã³ã³ãã¤ã«ãã¾ãããã®ä¾ã§ã¯ãå®"
"ç¾©ã»ã³ã³ãã¤ã«ãããã¡ã½ããã¯ãä¸è¨ã®ã¸ã§ããªãã¯é¢æ°ãããå¼æ°2åã`Int`åã«ç¹åããããã®ã§ããã¤ã¾ããå®ç¾©ã¨ã³ã³ãã¤ã«ã¯æé»è£¡ã«è¡ããã¾"
"ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:220
#, no-wrap
msgid ""
"function myplus(x::Int,y::Int)\n"
"    x+y\n"
"end\n"
msgstr ""
"function myplus(x::Int,y::Int)\n"
"    x+y\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:227
msgid "and finally, it invokes this specific method."
msgstr "æå¾ã«ããã®ç¹åããã¡ã½ãããå¼ã³åºãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:231
msgid ""
"Thus, abstract types allow programmers to write generic functions that can later be used as the default method by many combinations of "
"concrete types. Thanks to multiple dispatch, the programmer has full control over whether the default or more specific method is used."
msgstr ""
"ãã®ããã«ãæ½è±¡åãä½¿ç¨ãããã¨ã§ãã­ã°ã©ãã¯ã¸ã§ããªãã¯é¢æ°ãæ¸ããã¨ãã§ãã¾ããããã¯å¾ã«ãå·è±¡åãçµã¿åããã¦ä½¿ãæã®ãæ¢å®ã®ã¡ã½ãã"
"ã¨ãã¦ä½¿ããã¨ãã§ããã®ã§ããå¤éãã£ã¹ãããã®ãããã§ããã­ã°ã©ãã¯ããã©ã«ãã®é¢æ°ãä½¿ãããããç¹åããã¡ã½ãããä½¿ãããå®å¨ã«å¶å¾¡ã§ã"
"ã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:236
msgid ""
"An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract "
"types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, "
"however, in the case of function arguments that are containers of abstract types; see [Performance Tips](@ref man-performance-tips).)"
msgstr ""
"æ³¨æãã¹ãéè¦ãªç¹ã¯ããã­ã°ã©ãããå¼æ°ãæ½è±¡åã®å¼æ°ãæã¤é¢æ°ä½¿ã£ã¦ããããã©ã¼ãã³ã¹ãä½ä¸ããªããã¨ãããã¨ã§ãããã®ã¡ã½ãããå¼ã³åºã"
"ããæ¯ã«ãå·è±¡åã®å¼æ°ã®ã¿ãã«ããããã«å¯¾ãã¦ã¡ã½ãããåã³ã³ãã¤ã«ããããã§ãã(ãã ããé¢æ°ã®å¼æ°ãæ½è±¡åã®ã³ã³ããã¼ã§ããã¯ãããã©ã¼ã"
"ã³ã¹ä¸ã®åé¡ãçºçããããããã¾ãã [ããã©ã¼ãã³ã¹ã»ãã£ããã¹](@ref man-performance-tips)ãåç§ã®ãã¨ã)"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:237
#, no-wrap
msgid "Primitive Types"
msgstr "ããªããã£ãå"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:243
msgid ""
"A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-"
"point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in "
"ones. In fact, the standard primitive types are all defined in the language itself:"
msgstr ""
"ããªããã£ãåã¯ããã¼ã¿ãæ®éãããã§æ§æãããå·è±¡åã§ããããªããã£ãåã®å¸åçãªä¾ã¯ãæ´æ°ã¨æµ®åå°æ°ç¹ã®å¤ã§ããã»ã¨ãã©ã®è¨èªã¨ã¯ç°ãª"
"ããJulia ã§ã¯ãçµã¿è¾¼ã¿ã®æ±ºããããã»ããã®ã¿ãæä¾ããã®ã§ã¯ãªããç¬èªã®ããªããã£ãåãå®£è¨ã§ãã¾ããå®éãæ¨æºã®ããªããã£ãåã¯ãã¹ã¦(C"
"è¨èªã§ã¯ãªã)Julia è¨èªèªä½ã§å®ç¾©ããã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:244
#, no-wrap
msgid ""
"primitive type Float16 <: AbstractFloat 16 end\n"
"primitive type Float32 <: AbstractFloat 32 end\n"
"primitive type Float64 <: AbstractFloat 64 end\n"
"\n"
"primitive type Bool <: Integer 8 end\n"
"primitive type Char <: AbstractChar 32 end\n"
"\n"
"primitive type Int8    <: Signed   8 end\n"
"primitive type UInt8   <: Unsigned 8 end\n"
"primitive type Int16   <: Signed   16 end\n"
"primitive type UInt16  <: Unsigned 16 end\n"
"primitive type Int32   <: Signed   32 end\n"
"primitive type UInt32  <: Unsigned 32 end\n"
"primitive type Int64   <: Signed   64 end\n"
"primitive type UInt64  <: Unsigned 64 end\n"
"primitive type Int128  <: Signed   128 end\n"
"primitive type UInt128 <: Unsigned 128 end\n"
msgstr ""
"primitive type Float16 <: AbstractFloat 16 end\n"
"primitive type Float32 <: AbstractFloat 32 end\n"
"primitive type Float64 <: AbstractFloat 64 end\n"
"\n"
"primitive type Bool <: Integer 8 end\n"
"primitive type Char <: AbstractChar 32 end\n"
"\n"
"primitive type Int8    <: Signed   8 end\n"
"primitive type UInt8   <: Unsigned 8 end\n"
"primitive type Int16   <: Signed   16 end\n"
"primitive type UInt16  <: Unsigned 16 end\n"
"primitive type Int32   <: Signed   32 end\n"
"primitive type UInt32  <: Unsigned 32 end\n"
"primitive type Int64   <: Signed   64 end\n"
"primitive type UInt64  <: Unsigned 64 end\n"
"primitive type Int128  <: Signed   128 end\n"
"primitive type UInt128 <: Unsigned 128 end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:265
msgid "The general syntaxes for declaring a primitive type are:"
msgstr "ããªããã£ãåãå®£è¨ããããã®ä¸è¬çãªæ§æã¯æ¬¡ã®ã¨ããã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:266
#, no-wrap
msgid ""
"primitive type Â«nameÂ» Â«bitsÂ» end\n"
"primitive type Â«nameÂ» <: Â«supertypeÂ» Â«bitsÂ» end\n"
msgstr ""
"primitive type Â«nameÂ» Â«bitsÂ» end\n"
"primitive type Â«nameÂ» <: Â«supertypeÂ» Â«bitsÂ» end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:278
msgid ""
"The number of bits indicates how much storage the type requires and the name gives the new type a name. A primitive type can optionally be "
"declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having `Any` as its immediate supertype. "
"The declaration of [`Bool`](@ref) above therefore means that a boolean value takes eight bits to store, and has [`Integer`](@ref) as its "
"immediate supertype. Currently, only sizes that are multiples of 8 bits are supported. Therefore, boolean values, although they really need "
"just a single bit, cannot be declared to be any smaller than eight bits."
msgstr ""
"ãããæ° Â«bitsÂ»ã¯ããã®åã«å¿è¦ãªã¹ãã¬ã¼ã¸ã®éã§ããåå Â«nameÂ» ã¯æ°ããåã«ã¤ããååã§ããããªããã£ãåã¯ãå¿è¦ã«å¿ãã¦ãããã¤ãã®ã¹ã¼"
"ãã¼ã¿ã¤ãã®ãµãã¿ã¤ãã¨ãã¦å®£è¨ã§ãã¾ããã¹ã¼ãã¼ã¿ã¤ããçç¥ããå ´åããã®åã¯ããã©ã«ãã§ `Any` ãç´æ¥ã®ã¹ã¼ãã¼ã¿ã¤ãã¨ãã¦è¨­å®ãã¾ããã"
"ããã£ã¦ãä¸è¨ã® [`Bool`](@ref) ã®å®£è¨ã¯ããã¼ã«å¤ãæ ¼ç´ããã®ã« 8 ããããããã[`Integer`](@ref) ãç´æ¥ã®ã¹ã¼ãã¼ã¿ã¤ãã¨ãã¦æã£ã¦ãããã¨"
"ãæå³ãã¾ããç¾å¨ã8 ãããã®åæ°ã®ãµã¤ãºã®ã¿ããµãã¼ãããã¦ãã¾ãããããã£ã¦ããã¼ã«å¤ã¯å®éã«ã¯ 1 ãããããå¿è¦ã¨ãã¾ãããã8 ãããã"
"ãå°ããå¤ãå®£è¨ãããã¨ã¯ã§ãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:289
msgid ""
"The types [`Bool`](@ref), [`Int8`](@ref) and [`UInt8`](@ref) all have identical representations: they are eight-bit chunks of memory. Since "
"Julia's type system is nominative, however, they are not interchangeable despite having identical structure. A fundamental difference "
"between them is that they have different supertypes: [`Bool`](@ref)'s direct supertype is [`Integer`](@ref), [`Int8`](@ref)'s is [`Signed`]"
"(@ref), and [`UInt8`](@ref)'s is [`Unsigned`](@ref). All other differences between [`Bool`](@ref), [`Int8`](@ref), and [`UInt8`](@ref) are "
"matters of behavior -- the way functions are defined to act when given objects of these types as arguments. This is why a nominative type "
"system is necessary: if structure determined type, which in turn dictates behavior, then it would be impossible to make [`Bool`](@ref) "
"behave any differently than [`Int8`](@ref) or [`UInt8`](@ref)."
msgstr ""
"[`Bool`](@ref)ã[`Int8`](@ref)ããã³[`UInt8`](@ref)ã®åã¯ãã¹ã¦åãè¡¨ç¾ãæã£ã¦ãã¾ã: ã©ãã8ãããã®ã¡ã¢ãªãã£ã³ã¯ã§ããããããJuliaã®åã·"
"ã¹ãã ã¯å¬ç§°çã§ãããããåä¸ã®æ§é ã§ãã£ã¦ãäºææ§ã¯ããã¾ããããããã®åºæ¬çãªéãã¯ãç°ãªãã¹ã¼ãã¼ã¿ã¤ããæã£ã¦ããã¨ãããã¨ã§ã:"
"[`Bool`](@ref)`ã®ç´æ¥ã¹ã¼ãã¼ã¿ã¤ãã¯[`Integer`](@ref)ã[`Int8`](@ref)ã¯[`Signed`](@ref)ã`UInt8`(@ref)ã¯[`Unsigned`](@ref)ã§ãã[`Bool`]"
"(@ref)ã[`Int8`](@ref)ãããã³[`UInt8`](@ref)ã®ãã®ä»éãã¯ãã¹ã¦æåã«é¢ãããã®ã§ãããããã®åã®ãªãã¸ã§ã¯ããå¼æ°ã¨ãã¦æå®ããå ´åã«é¢æ°"
"ã®æåãã©ãå®ç¾©ããã¦ãããã®éãã§ãããããåã®æ§é ã«ãã£ã¦æåãæ±ºã¾ã£ã¦ãã¾ãã®ã§ããã°ã[`Int8`](@ref)ã¾ãã¯[`UInt8`](@ref)ã¨ã¯ç°ãªãå"
"ä½ããã[`Bool`](@ref)ãä½ããã¨ã¯ä¸å¯è½ãªãã§ãããã"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:290
#, no-wrap
msgid "Composite Types"
msgstr "[è¤åå](@id Composite-Types)"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:297
msgid ""
"[Composite types](https://en.wikipedia.org/wiki/Composite_data_type) are called records, structs, or objects in various languages. A "
"composite type is a collection of named fields, an instance of which can be treated as a single value. In many languages, composite types "
"are the only kind of user-definable type, and they are by far the most commonly used user-defined type in Julia as well."
msgstr ""
"[è¤åå](https://en.wikipedia.org/wiki/Composite_data_type) ã¯æ§ããªè¨èªã§ãã¬ã³ã¼ããæ§é ä½ãã¾ãã¯ãªãã¸ã§ã¯ãã¨å¼ã°ãã¾ããè¤ååã¯ååä»"
"ããã£ã¼ã«ãã®ã³ã¬ã¯ã·ã§ã³ã§ããã®ã¤ã³ã¹ã¿ã³ã¹ã¯åä¸ã®å¤ã¨ãã¦æ±ããã¨ãã§ãã¾ããå¤ãã®è¨èªã§ã¯ãè¤ååã¯ã¦ã¼ã¶ã¼å®ç¾©å¯è½ãªåã®å¯ä¸ã®ç¨®é¡ã§"
"ãããJulia ã§ãæãä¸è¬çã«ä½¿ç¨ãããã¦ã¼ã¶ã¼å®ç¾©åã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:311
msgid ""
"In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, "
"and the combination is called an \"object\". In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether "
"they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point "
"values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are "
"objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to "
"use by multiple dispatch, meaning that the types of *all* of a function's arguments are considered when selecting a method, rather than just "
"the first one (see [Methods](@ref)  for more information on methods and dispatch). Thus, it would be inappropriate for functions to \"belong"
"\" to only their first argument. Organizing methods into function objects rather than having named bags of methods \"inside\" each object "
"ends up being a highly beneficial aspect of the language design."
msgstr ""
"C++ãJavaãPythonãRubyãªã©ã®ä¸»æµã®ãªãã¸ã§ã¯ãæåè¨èªã§ã¯ãè¤ååã¯ãååä»ããããé¢æ°ãé¢é£ä»ãããã¦ããããã®çµã¿åããã¯ \"ãªãã¸ã§ã¯"
"ã\" ã¨å¼ã°ãã¾ããRuby ã Smalltalk ãªã©ã®ç´ç²ãªãªãã¸ã§ã¯ãæåè¨èªã§ã¯ããããè¤ååã§ãããã¨ãªãããã¨ããã¹ã¦ã®å¤ããªãã¸ã§ã¯ãã§ããC+"
"+ ã Java ãå«ãç´ç²ã§ãªããªãã¸ã§ã¯ãæåè¨èªã§ã¯ãæ´æ°ãæµ®åå°æ°ç¹å¤ãªã©ã®ä¸é¨ã®å¤ã¯ãªãã¸ã§ã¯ãã§ã¯ãªããã¦ã¼ã¶ã¼å®ç¾©ã®è¤ååã®ã¤ã³ã¹ã¿ã³"
"ã¹ã¯çã®ãªãã¸ã§ã¯ãã§ãé¢é£ä»ããããã¡ã½ãããæã¡ã¾ããJulia ã§ã¯ããã¹ã¦ã®å¤ã¯ãªãã¸ã§ã¯ãã§ãããé¢æ°ã¯æä½å¯¾è±¡ã®ãªãã¸ã§ã¯ãã«ãã³ãã«"
"ããã¦ãã¾ãããããã¯ãJuliaãå¤éãã£ã¹ãããã§ä½¿ç¨ããé¢æ°ã®ã¡ã½ãããé¸æããããã§ããããã¯ãé¢æ°ã®æåã®å¼æ°ã ãã§ãªãã*å¨ã¦ã®*å¼æ°ã"
"ã¡ã½ããé¸æã®éã«èæ®ãããã¨ãããã¨ãæå³ãã¦ãã¾ã(ã¡ã½ããã¨ãã£ã¹ãããã«ã¤ãã¦ã®è©³ç´°ã¯ [ã¡ã½ãã](@ref Methods) åç§)ããããã£ã¦ãé¢"
"æ°ããã®æåã®å¼æ°ã ãã« ãå±ãã¦ãããã¨ããèãæ¹ã¯ä¸é©åã§ããåãªãã¸ã§ã¯ãã®ãåé¨ã«ãååä»ãã®ã¡ã½ããã®ããã°(ã¡ã½ããã®éåï¼ãæã¤"
"ã®ã§ã¯ãªããã¡ã½ãããé¢æ°ãªãã¸ã§ã¯ãã«ç·¨æãããã¨ãããã¨ããã¾ããããã¯ãJulia ã®è¨èªè¨­è¨ã®éå¸¸ã«æçãªå´é¢ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:314
msgid ""
"Composite types are introduced with the [`struct`](@ref) keyword followed by a block of field names, optionally annotated with types using "
"the `::` operator:"
msgstr ""
"è¤ååã¯ [`struct`](@ref) ã­ã¼ã¯ã¼ãã®å¾ã«ãã£ã¼ã«ãåã®ãã­ãã¯ãä»å ãããå¿è¦ã«å¿ãã¦ `::` æ¼ç®å­ãä½¿ç¨ãã¦åã«ã¢ããã¼ã·ã§ã³ãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:315
#, no-wrap
msgid ""
"julia> struct Foo\n"
"           bar\n"
"           baz::Int\n"
"           qux::Float64\n"
"       end\n"
msgstr ""
"julia> struct Foo\n"
"           bar\n"
"           baz::Int\n"
"           qux::Float64\n"
"       end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:324
msgid "Fields with no type annotation default to `Any`, and can accordingly hold any type of value."
msgstr "åã¢ããã¼ã·ã§ã³ã®ãªããã£ã¼ã«ãã¯ããã©ã«ãã§ `Any`ã«ãªãã¾ããããã«å¿ãã¦ä»»æã®åã®å¤ãä¿æã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:327
msgid "New objects of type `Foo` are created by applying the `Foo` type object like a function to values for its fields:"
msgstr "å`Foo`ã®æ°ãããªãã¸ã§ã¯ãã¯ãé¢æ°ã®ãããª `Foo` åã®ãªãã¸ã§ã¯ããé¢æ°ã®ããã«ãã¦ãã£ã¼ã«ãã®å¤ã«é©ç¨ãããã¨ã§ä½æã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:328
#, no-wrap
msgid ""
"julia> foo = Foo(\"Hello, world.\", 23, 1.5)\n"
"Foo(\"Hello, world.\", 23, 1.5)\n"
"\n"
"julia> typeof(foo)\n"
"Foo\n"
msgstr ""
"julia> foo = Foo(\"Hello, world.\", 23, 1.5)\n"
"Foo(\"Hello, world.\", 23, 1.5)\n"
"\n"
"julia> typeof(foo)\n"
"Foo\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:341
msgid ""
"When a type is applied like a function it is called a *constructor*. Two constructors are generated automatically (these are called *default "
"constructors*). One accepts any arguments and calls [`convert`](@ref) to convert them to the types of the fields, and the other accepts "
"arguments that match the field types exactly. The reason both of these are generated is that this makes it easier to add new definitions "
"without inadvertently replacing a default constructor."
msgstr ""
"åãé¢æ°ã®ããã«é©ç¨ãããæãããã¯ *ã³ã³ã¹ãã©ã¯ã¿ã¼*ã¨å¼ã°ãã¦ãã¾ãã2 ã¤ã®ã³ã³ã¹ãã©ã¯ã¿ã¼ãèªåçã«çæããã¾ã (ãããã¯ *ããã©ã«ã "
"ã³ã³ã¹ãã©ã¯ã¿ã¼*ã¨å¼ã°ãã¦ãã¾ã)ã1 ã¤ã¯å¼æ°ãåãå¥ãããã£ã¼ã«ãã®åã«å¤æããããã« [`convert`](@ref) ãå¼ã³åºãããã 1 ã¤ã¯ãã£ã¼ã«ã"
"ã®åã¨å®å¨ã«ä¸è´ããå¼æ°ã ããåãå¥ãã¾ãããããã®ä¸¡æ¹ãçæãããçç±ã¯ãèª¤ã£ã¦æ¢å®ã®ã³ã³ã¹ãã©ã¯ã¿ãç½®ãæãããã¨ãªããæ°ããå®ç¾©ãç°¡å"
"ã«è¿½å ã§ããããã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:344
msgid "Since the `bar` field is unconstrained in type, any value will do. However, the value for `baz` must be convertible to `Int`:"
msgstr "`bar`ãã£ã¼ã«ãã«ã¯åã®å¶ç´ã¯ãªãã®ã§ãå¤ã¯ä½ã§ãæ§ãã¾ããããã ãã`baz`ã®å¤ã¯`Int`ã«å¤æã§ããå¿è¦ãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:345
#, no-wrap
msgid ""
"julia> Foo((), 23.5, 1)\n"
"ERROR: InexactError: Int64(23.5)\n"
"Stacktrace:\n"
"[...]\n"
msgstr ""
"julia> Foo((), 23.5, 1)\n"
"ERROR: InexactError: Int64(23.5)\n"
"Stacktrace:\n"
"[...]\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:353
msgid "You may find a list of field names using the [`fieldnames`](@ref) function."
msgstr "[`fieldnames`](@ref)é¢æ°ãã¤ãã£ã¦ããã£ã¼ã«ãåã®ä¸è¦§ãåå¾ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:354
#, no-wrap
msgid ""
"julia> fieldnames(Foo)\n"
"(:bar, :baz, :qux)\n"
msgstr ""
"julia> fieldnames(Foo)\n"
"(:bar, :baz, :qux)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:360
msgid "You can access the field values of a composite object using the traditional `foo.bar` notation:"
msgstr "å¾æ¥ã®è¡¨è¨æ³ `foo.bar`ãä½¿ç¨ãã¦ãè¤åãªãã¸ã§ã¯ãã®ãã£ã¼ã«ãå¤ã«ã¢ã¯ã»ã¹ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:361
#, no-wrap
msgid ""
"julia> foo.bar\n"
"\"Hello, world.\"\n"
"\n"
"julia> foo.baz\n"
"23\n"
"\n"
"julia> foo.qux\n"
"1.5\n"
msgstr ""
"julia> foo.bar\n"
"\"Hello, world.\"\n"
"\n"
"julia> foo.baz\n"
"23\n"
"\n"
"julia> foo.qux\n"
"1.5\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:374
msgid ""
"Composite objects declared with `struct` are *immutable*; they cannot be modified after construction. This may seem odd at first, but it has "
"several advantages:"
msgstr ""
"`struct` ã§å®£è¨ãããè¤ååãªãã¸ã§ã¯ãã¯ *ä¸å¤*ã§ããä½æå¾ã«å¤æ´ã§ãã¾ãããããã¯æåã¯å¥å¦ã«è¦ããããããã¾ããããããã¤ãã®å©ç¹ããã"
"ã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:379
msgid ""
"It can be more efficient. Some structs can be packed efficiently into arrays, and in some cases the compiler is able to avoid allocating "
"immutable objects entirely."
msgstr ""
"ããå¹ççã«ãªããã¨ãããã¾ããä¸é¨ã®æ§é ä½ã¯éåã«å¹ççã«ããã¯ã§ããå ´åã«ãã£ã¦ã¯ã³ã³ãã¤ã©ã¯ä¸å¤ãªãã¸ã§ã¯ãå¨ä½ãå¥ã®ã¡ã¢ãªã«å²ãå½ã¦"
"ããã¨ãåé¿ã§ãããã¨ãããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:379
msgid "It is not possible to violate the invariants provided by the type's constructors."
msgstr "åã³ã³ã¹ãã©ã¯ã¿ã§è¦å®ãããä¸å¤æ§ãç ´ããã¨ã¯ã§ãã¾ããã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:379
msgid "Code using immutable objects can be easier to reason about."
msgstr "ä¸å¤ãªãã¸ã§ã¯ããä½¿ç¨ããã³ã¼ãã¯ãæ¨è«ãããããªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:383
msgid ""
"An immutable object might contain mutable objects, such as arrays, as fields. Those contained objects will remain mutable; only the fields "
"of the immutable object itself cannot be changed to point to different objects."
msgstr ""
"ä¸å¤ãªãã¸ã§ã¯ãã«ã¯ãéåãªã©ã®å¤æ´å¯è½ãªãªãã¸ã§ã¯ãããã£ã¼ã«ãã«å«ã¾ãã¦ããå ´åãããã¾ããå«ã¾ãããªãã¸ã§ã¯ãã¯å¤æ´å¯è½ãªã¾ã¾ã§ããã"
"ã®ä¸å¤ãªãã¸ã§ã¯ãèªä½ãã£ã¼ã«ãããç°ãªããªãã¸ã§ã¯ããæãããå¤æ´ãããã¨ãã§ããªããªãã ãã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:386
msgid ""
"Where required, mutable composite objects can be declared with the keyword [`mutable struct`](@ref), to be discussed in the next section."
msgstr "å¿è¦ã«å¿ãã¦ãæ¬¡ã®ã»ã¯ã·ã§ã³ã§èª¬æããã­ã¼ã¯ã¼ã [`mutable struct`](@ref ) ã§ãå¤æ´å¯è½ãªè¤åãªãã¸ã§ã¯ããå®£è¨ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:388
msgid "Immutable composite types with no fields are singletons; there can be only one instance of such types:"
msgstr "ãã£ã¼ã«ãã®ãªãä¸å¤è¤ååã¯ã·ã³ã°ã«ãã³ã§ãããã®ãããªåã®ã¤ã³ã¹ã¿ã³ã¹ã¯ 1 ã¤ã ãã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:389
#, no-wrap
msgid ""
"julia> struct NoFields\n"
"       end\n"
"\n"
"julia> NoFields() === NoFields()\n"
"true\n"
msgstr ""
"julia> struct NoFields\n"
"       end\n"
"\n"
"julia> NoFields() === NoFields()\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:399
msgid ""
"The [`===`](@ref) function confirms that the \"two\" constructed instances of `NoFields` are actually one and the same. Singleton types are "
"described in further detail [below](@ref man-singleton-types)."
msgstr ""
"[`===`](@ref) ã«ãã£ã¦ã`NoFields`ã®ãï¼ã¤ã®ãã¤ã³ã¹ã¿ã³ã¹ããå®éã«ã¯ä¸ã¤ã§åããã®ã§ãããã¨ãç¢ºèªã§ãã¾ãã ã·ã³ã°ã«ãã³ã¿ã¤ãã«ã¤ãã¦ã¯ã"
"[ä»¥ä¸](@ref man-singleton-types) ã§ããã«è©³ããèª¬æãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:403
msgid ""
"There is much more to say about how instances of composite types are created, but that discussion depends on both [Parametric Types](@ref) "
"and on [Methods](@ref), and is sufficiently important to be addressed in its own section: [Constructors](@ref man-constructors)."
msgstr ""
"è¤ååã®ã¤ã³ã¹ã¿ã³ã¹ãã©ã®ããã«çæããããã«ã¤ãã¦ã¯ãã¾ã ã¾ã èª¬æãã¹ããã¨ãããã¾ããããã®è­°è«ã¯ [ãã©ã¡ããªãã¯å(@ref Parametric-"
"types)ã¨[ã¡ã½ãã](@ref Methods)ã®ä¸¡æ¹ã«ãé¢ããããããã¨ã¦ãéè¦ãªäºé ãªã®ã§ã[ã³ã³ã¹ãã©ã¯ã¿](@ref man-constructors) ã¨ããç¬ç«ã®ã»ã¯ã·ã§"
"ã³ãè¨­ãã¦ããã§æ±ããã¨ã«ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:404
#, no-wrap
msgid "Mutable Composite Types"
msgstr "[å¯å¤è¤åå](@id Mutable-Composite-Types)"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:408
msgid "If a composite type is declared with `mutable struct` instead of `struct`, then instances of it can be modified:"
msgstr "è¤ååãã`struct` ã§ã¯ãªã `mutable struct` ã­ã¼ã¯ã¼ãã§å®£è¨ããã¦ããã°ããã®åã®ã¤ã³ã¹ã¿ã³ã¹ã¯å¤æ´å¯è½ã§ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/types.md:409
#, no-wrap
msgid "jldoctest bartype"
msgstr "jldoctest bartype"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:409
#, no-wrap
msgid ""
"julia> mutable struct Bar\n"
"           baz\n"
"           qux::Float64\n"
"       end\n"
"\n"
"julia> bar = Bar(\"Hello\", 1.5);\n"
"\n"
"julia> bar.qux = 2.0\n"
"2.0\n"
"\n"
"julia> bar.baz = 1//2\n"
"1//2\n"
msgstr ""
"julia> mutable struct Bar\n"
"           baz\n"
"           qux::Float64\n"
"       end\n"
"\n"
"julia> bar = Bar(\"Hello\", 1.5);\n"
"\n"
"julia> bar.qux = 2.0\n"
"2.0\n"
"\n"
"julia> bar.baz = 1//2\n"
"1//2\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:433
msgid ""
"In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses.  A mutable object is like "
"a little container that might hold different values over time, and so can only be reliably identified with its address.  In contrast, an "
"instance of an immutable type is associated with specific field values --- the field values alone tell you everything about the object.  In "
"deciding whether to make a type mutable, ask whether two instances with the same field values would be considered identical, or if they "
"might need to change independently over time. If they would be considered identical, the type should probably be immutable."
msgstr ""
"å¤æ´ã«å¯¾å¿ã§ããããã«ããã®ãããªãªãã¸ã§ã¯ãã¯ãä¸è¬ã«ãã¼ãä¸ã«å²ãå½ã¦ãããã¡ã¢ãªã¢ãã¬ã¹ãä¸å®ã«ãªã£ã¦ãã¾ããå¯å¤ãªãã¸ã§ã¯ãã¯ãæé"
"ã«ãã£ã¦å¤ã®å¤ããããå°ããªã³ã³ããã®ãããªãã®ã§ãã¢ãã¬ã¹ã ãã§ç¢ºå®ã«è­å¥ã§ãã¾ããå¯¾ç§°çã«ãå¤æ´ä¸å¯è½ãªåã®ã¤ã³ã¹ã¿ã³ã¹ã¯ãç¹å®ã®ãã£ã¼"
"ã«ãå¤ã«é¢é£ä»ãããã¦ãã¾ãããã£ã¼ã«ãå¤ã ãã§ããªãã¸ã§ã¯ãã«é¢ããå¨ã¦ããããã¾ããåãå¯å¤ã«ãããã©ãããæ±ºããã«ã¯ãåããã£ã¼ã«ãå¤"
"ãæã¤2ã¤ã®ã¤ã³ã¹ã¿ã³ã¹ã¯åä¸ã ã¨ã¿ãªãããããããã¯æéã¨ã¨ãã«å¥ãã«å¤æ´ããå¿è¦ãããããèãã¾ããåä¸ã§ããã¨ã¿ãªãããªãã°ãããããã"
"ã®åã¯ä¸å¤ã«ãã¹ãã§ãããã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:435
msgid "To recap, two essential properties define immutability in Julia:"
msgstr "ã¾ã¨ããã¨ãJulia ã§ã¯2 ã¤ã®éè¦ãªç¹æ§ã§ä¸å¤æ§ãå®ç¾©ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:452
#, no-wrap
msgid ""
"  * It is not permitted to modify the value of an immutable type.\n"
"    * For bits types this means that the bit pattern of a value once set will never change\n"
"      and that value is the identity of a bits type.\n"
"    * For composite  types, this means that the identity of the values of its fields will\n"
"      never change. When the fields are bits types, that means their bits will never change,\n"
"      for fields whose values are mutable types like arrays, that means the fields will\n"
"      always refer to the same mutable value even though that mutable value's content may\n"
"      itself be modified.\n"
"  * An object with an immutable type may be copied freely by the compiler since its\n"
"    immutability makes it impossible to programmatically distinguish between the original\n"
"    object and a copy.\n"
"    * In particular, this means that small enough immutable values like integers and floats\n"
"      are typically passed to functions in registers (or stack allocated).\n"
"    * Mutable values, on the other hand are heap-allocated and passed to\n"
"      functions as pointers to heap-allocated values except in cases where the compiler\n"
"      is sure that there's no way to tell that this is not what is happening.\n"
msgstr ""
"  * ä¸å¤åã®å¤ãå¤æ´ãããã¨ã¯ã§ãã¾ããã\n"
"    * ãããå(ããªããã£ãå)ã®å ´åãä¸åº¦è¨­å®ãããå¤ã®ããã ãã¿ã¼ã³ã¯æ±ºãã¦å¤ãããããã®å¤ã¯ãã®åã§æç­çã§ãããã¨ãæå³ãã¾ãã\n"
"    * è¤ååã®å ´åããã£ã¼ã«ãã®å¤ã®æç­æ§ã¯æ±ºãã¦å¤ãããªããã¨ãæå³ãã¾ãããã£ã¼ã«ãããããåã®å ´åããã®ãããã¯æ±ºãã¦å¤ãããããã£ã¼ã«ããéåã®ãããªå¤æ´å¯è½ãªåã§ããå ´åããã®å¤æ´å¯è½ãªåã®ä¸­èº«ã¯å¤ãã£ã¦ãããã®ãã£ã¼ã«ãã¯å¸¸ã«åãå¯å¤ã®å¤ãåç§ãããã¨ãæå³ãã¾ãã\n"
"  * ä¸å¤åã®ãªãã¸ã§ã¯ãã¯ãã³ã³ãã¤ã©ãèªç±ã«ã³ãã¼ãããã¨ãã§ãã¾ããã¨ããã®ããä¸å¤æ§ã«ãã£ã¦ãåã®ãªãã¸ã§ã¯ãã¨ã³ãã¼ãããã®ãè¦åãããã¨ãã§ããªãããã§ãã\n"
"    * ç¹ã«ãåå(ã¡ã¢ãªãå°æããé åã)å°ããª æ´æ°ãæµ®åå°æ°ç¹æ°ãªã©ã®ä¸å¤åã¯ãéå¸¸ã¯ã¬ã¸ã¹ã¿ (ã¾ãã¯å²ãå½ã¦ãããã¹ã¿ãã¯) ã«ããé¢æ°ã«ãã®ã¾ã¾æ¸¡ããã¾ãã\n"
"    * å¤æ´å¯è½ãªå¤ã¯ã(éåãªã©ãä¸è¬ã«ã¡ã¢ãªã®ä½¿ç¨éãå¤§ãããªãå¾ãã®ã§)ä¸æ¹ã§ãã¼ãã«å²ãå½ã¦ããããã®éç½®ãããå¤ã¸ã®ãã¤ã³ã¿ã¨ãã¦é¢æ°ã«æ¸¡ããã¾ãããã ãããã®ãããªäºè±¡ãèµ·ãã£ã¦ãããã©ãããå¤å¥ãããã¨ãã©ããã£ã¦ãä¸å¯è½ãªç¶æ³ã ã¨ã³ã³ãã¤ã©ãå¤æ­ããå ´åã«ã¯ããã®éãã§ã¯ããã¾ããã\n"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:453
#, no-wrap
msgid "Declared Types"
msgstr "å®£è¨å"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:457
msgid ""
"The three kinds of types (abstract, primitive, composite) discussed in the previous sections are actually all closely related. They share "
"the same key properties:"
msgstr ""
"ä¸è¨ã»ã¯ã·ã§ã³ã§èª¬æãã 3 ç¨®é¡ã®å (æ½è±¡ãããªããã£ãåãè¤åå) ã¯ãå®éã«ã¯å¯æ¥ã«é¢é£ãã¦ãã¾ãããããã¯ãå±éããéè¦ãªç¹å¾´ãæã¡ã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:462
msgid "They are explicitly declared."
msgstr "æç¤ºçã«å®£è¨ããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:462
msgid "They have names."
msgstr "ååãæã£ã¦ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:462
msgid "They have explicitly declared supertypes."
msgstr "ã¹ã¼ãã¼ã¿ã¤ããæç¤ºçã«å®£è¨ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:462
msgid "They may have parameters."
msgstr "ãã©ã¡ã¼ã¿ãä»ãããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:465
msgid ""
"Because of these shared properties, these types are internally represented as instances of the same concept, `DataType`, which is the type "
"of any of these types:"
msgstr ""
"ããããå±éã®ç¹å¾´ãæã¤ããããããã®åã¯ãåé¨çã«åãæ¦å¿µã® `DataType` ã®ã¤ã³ã¹ã¿ã³ã¹ã¨ãã¦è¡¨ç¾ããã¾ãã`DataType` ããã3ã¤ã®åã®ããã"
"ããããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:466
#, no-wrap
msgid ""
"julia> typeof(Real)\n"
"DataType\n"
"\n"
"julia> typeof(Int)\n"
"DataType\n"
msgstr ""
"julia> typeof(Real)\n"
"DataType\n"
"\n"
"julia> typeof(Int)\n"
"DataType\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:477
msgid ""
"A `DataType` may be abstract or concrete. If it is concrete, it has a specified size, storage layout, and (optionally) field names. Thus a "
"primitive type is a `DataType` with nonzero size, but no field names. A composite type is a `DataType` that has field names or is empty "
"(zero size)."
msgstr ""
"`DataType`ã¯æ½è±¡åãå·è±¡åã©ã¡ãã§ããã¾ãã¾ãããå·è±¡åãªãã°ãç¹å®ã®ãµã¤ãºãæ ¼ç´é åä¸ã®ã¬ã¤ã¢ã¦ãã(å ´åã«ãã£ã¦ã¯ï¼ãã£ã¼ã«ãåãªã©ããã"
"ã¾ããããªããã£ãåã¯ã¼ã­ä»¥å¤ã®ãµã¤ãºã® `DataType` ã§ããããã£ã¼ã«ãåã¯ããã¾ãããè¤ååã¯ããã£ã¼ã«ãåãæã¤ãããã¾ãã¯ç©º (ã¼ã­ ãµã¤"
"ãº)ã®`DataType`ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:479
msgid "Every concrete value in the system is an instance of some `DataType`."
msgstr "ã·ã¹ãã åã®ãã¹ã¦ã®å·è±¡åã®å¤ã¯ããªãããã® `DataType` ã®ã¤ã³ã¹ã¿ã³ã¹ã§ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:480
#, no-wrap
msgid "Type Unions"
msgstr "åä½µå"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:484
msgid ""
"A type union is a special abstract type which includes as objects all instances of any of its argument types, constructed using the special "
"[`Union`](@ref) keyword:"
msgstr "åä½µåã¯ç¹æ®ãªæ½è±¡åã§ãå¼æ°ã®ããããã®åã®ã¤ã³ã¹ã¿ã³ã¹ãå¨ã¦ãªãã¸ã§ã¯ãã¨ãã¦å«ã¿ã¾ããç¹æ®ãªã­ã¼ã¯ã¼ã`Union`ãä½¿ã£ã¦æ§ç¯ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:485
#, no-wrap
msgid ""
"julia> IntOrString = Union{Int,AbstractString}\n"
"Union{Int64, AbstractString}\n"
"\n"
"julia> 1 :: IntOrString\n"
"1\n"
"\n"
"julia> \"Hello!\" :: IntOrString\n"
"\"Hello!\"\n"
"\n"
"julia> 1.0 :: IntOrString\n"
"ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64\n"
msgstr ""
"julia> IntOrString = Union{Int,AbstractString}\n"
"Union{Int64, AbstractString}\n"
"\n"
"julia> 1 :: IntOrString\n"
"1\n"
"\n"
"julia> \"Hello!\" :: IntOrString\n"
"\"Hello!\"\n"
"\n"
"julia> 1.0 :: IntOrString\n"
"ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:503
msgid ""
"The compilers for many languages have an internal union construct for reasoning about types; Julia simply exposes it to the programmer. The "
"Julia compiler is able to generate efficient code in the presence of `Union` types with a small number of types [^1], by generating "
"specialized code in separate branches for each possible type."
msgstr ""
"å¤ãã®è¨èªã®ã³ã³ãã¤ã©ã«ã¯ãåæ¨è«ã®ããã«åé¨ã§ä½¿ãåä½µæ§æãããã¾ããJuliaã¯åã«ããããã­ã°ã©ãã«ãå¬éãã¦ããã¨ããããã§ããJulia ã®ã³"
"ã³ãã¤ã©ã¯ãå°æ°ã®å ã® `Union` å ãä½¿ãã¨å¹ççãªã³ã¼ããçæãããã¨ãããã¾ã[^1]ããªãããåãã¹ã¦ã«åå¥ã«ç¹åããã³ã¼ããçæããããã§"
"ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:510
msgid ""
"A particularly useful case of a `Union` type is `Union{T, Nothing}`, where `T` can be any type and [`Nothing`](@ref) is the singleton type "
"whose only instance is the object [`nothing`](@ref). This pattern is the Julia equivalent of [`Nullable`, `Option` or `Maybe`](https://en."
"wikipedia.org/wiki/Nullable_type)  types in other languages. Declaring a function argument or a field as `Union{T, Nothing}` allows setting "
"it either to a value of type `T`, or to `nothing` to indicate that there is no value.  See [this FAQ entry](@ref faq-nothing) for more "
"information."
msgstr ""
"åä½µåã®ã¦ã¼ã¹ã±ã¼ã¹ã§ç¹ã«ä¾¿å©ãªã®ã¯ã`Uniton{T, Nothing}`ã§ããããã§`T`ã¯ãä»»æã®åãæå®ã§ãã[`Nothing`](@ref)ã¯ãå¯ä¸ã®ã¤ã³ã¹ã¿ã³ã¹ã "
"`nothing`ãªãã¸ã§ã¯ãã§ãããã·ã³ã°ã«ãã³åã§ããJulia ã®ãã®ãã¿ã¼ã³ã¯ãä»ã®è¨èªã®[`Nullable`, `Option`, `Maybe`](https://en.wikipedia.org/"
"wiki/Nullable_type) åãªã©ã¨åç­ã§ããé¢æ°ã®å¼æ°ããã£ã¼ã«ãã`Uniton{T, Nothing}`ã¨ãã¦å®£è¨ããã¨å`T`ã®å¤ããå¤ããªããã¨ãç¤ºã`nothing`ã®"
"ã©ã¡ããã«è¨­å®ãããã¨ãã§ãã¾ããè©³ç´°ã«ã¤ãã¦ã¯ã[FATã®ãã®é ç®](@ref faq-nothing)ãè¦ã¦ãã ããã"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:511
#, no-wrap
msgid "Parametric Types"
msgstr "[ãã©ã¡ããªãã¯å](@id Parametric-Types)"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:527
msgid ""
"An important and powerful feature of Julia's type system is that it is parametric: types can take parameters, so that type declarations "
"actually introduce a whole family of new types -- one for each possible combination of parameter values. There are many languages that "
"support some version of [generic programming](https://en.wikipedia.org/wiki/Generic_programming), wherein data structures and algorithms to "
"manipulate them may be specified without specifying the exact types involved.  For example, some form of generic programming exists in ML, "
"Haskell, Ada, Eiffel, C++, Java, C#, F#, and Scala, just to name a few. Some of these languages support true parametric polymorphism (e.g. "
"ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming (e.g. C++, Java). With so many different "
"varieties of generic programming and parametric types in various languages, we won't even attempt to compare Julia's parametric types to "
"other languages, but will instead focus on explaining Julia's system in its own right. We will note, however, that because Julia is a "
"dynamically typed language and doesn't need to make all type decisions at compile time, many traditional difficulties encountered in static "
"parametric type systems can be relatively easily handled."
msgstr ""
"Juliaã®åã·ã¹ãã ã®éè¦ãã¤å¼·åãªç¹å¾´ã¯ãåããã©ã¡ããªãã¯ã§ããã¨ãããã¨ã§ã: åã«ãã©ã¡ã¼ã¿ãã¨ããã¨ãã§ãã¾ããããããã¨åå®£è¨ã¯ãå®è³ª"
"çã«ã¨ãããããããã®ãã©ã¡ã¼ã¿ã®çµã¿åããã«å¯¾å¿ãã¦ãæ°ããåã®ä¸æãå°å¥ãã¾ããå¤ãã®è¨èªããä½ããã®å½¢ã§[æ±åãã­ã°ã©ãã³ã°](https://"
"en.wikipedia.org/wiki/Generic_programming)ããµãã¼ããã¦ãã¾ããããã®æ±åãã­ã°ã©ãã³ã°ã§ã¯ãå¿è¦ãªåãæ­£ç¢ºã«ããªãã¦ããå¦çãã¹ããã¼ã¿æ§"
"é ã¨ã¢ã«ã´ãªãºã ãæå®ãããã¨ãã§ãã¾ãã ãã¨ãã°ãMLãHaskellãAdaãEiffelãC++ãJavaãC#ãF#ãScala ã«ã¯ãä½ããã®å½¢ã®æ±åãã­ã°ã©ãã³ã°"
"ãåãå¥ãã¦ãã¾ãããããã®è¨èªã®ä¸­ã«ã¯ãçã®ãã©ã¡ããªãã¯å¤ç¸æ§ããµãã¼ããããã®ãããã°(MLãHaskellãScalaãªã©)ãã¢ãããã¯ãªãã³ãã¬ã¼"
"ããã¼ã¹ã®æ±ç¨ãã­ã°ã©ãã³ã°ã¹ã¿ã¤ã«ããµãã¼ããããã®(ä¾ãã°C++ãJava)ãããã¾ãããã¾ãã¾ãªè¨èªã§å¤ç¨®å¤æ§ãªæ±åãã­ã°ã©ãã³ã°ã¨ãã©ã¡ããªã"
"ã¯åãä½¿ããã¦ããã®ã§ãããã§ã¯ããããã¨ãJulia ã®ãã©ã¡ããªãã¯åãæ¯è¼ããã®ã§ã¯ãªããJulia ã®ã·ã¹ãã ãåä½ã«ã¤ãã¦èª¬æãããã¨ã«ç¦ç¹ã"
"å½ã¦ã¾ãããã ããJulia ã¯åçã«åä»ãè¨èªã§ãããã³ã³ãã¤ã«æã«ãã¹ã¦ã®åæ±ºå®ãè¡ãå¿è¦ããªããããéçãã©ã¡ããªãã¯åã·ã¹ãã ã§çºçããå¤"
"ãã®å¾æ¥ã®å°é£ã¯æ¯è¼çç°¡åã«å¦çã§ãããã¨ã«æ³¨æãã¦ãã ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:531
msgid ""
"All declared types (the `DataType` variety) can be parameterized, with the same syntax in each case. We will discuss them in the following "
"order: first, parametric composite types, then parametric abstract types, and finally parametric primitive types."
msgstr ""
"ãã¹ã¦ã®å®£è¨å (`DataType` ã®ä»²é) ã¯ãããããåãæ§æã§ãã©ã¡ã¼ã¿åã§ãã¾ããæåã«ããã©ã¡ããªãã¯è¤ååãæ¬¡ã«ãã©ã¡ããªãã¯æ½è±¡åãæå¾ã«"
"ãã©ã¡ããªãã¯ ããªããã£ãåã®é ã§èª¬æãã¾ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/types.md:532
#, no-wrap
msgid "Parametric Composite Types"
msgstr "ãã©ã¡ããªãã¯è¤åå"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:535
msgid "Type parameters are introduced immediately after the type name, surrounded by curly braces:"
msgstr "åãã©ã¡ã¼ã¿ã¯ãååã®ç´å¾ã«å°å¥ãããä¸­ãã£ãã§å²ã¿ã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/types.md:536 ext/julia/doc/src/manual/types.md:551 ext/julia/doc/src/manual/types.md:565
#: ext/julia/doc/src/manual/types.md:575 ext/julia/doc/src/manual/types.md:585 ext/julia/doc/src/manual/types.md:648
#: ext/julia/doc/src/manual/types.md:658 ext/julia/doc/src/manual/types.md:676 ext/julia/doc/src/manual/types.md:693
#, no-wrap
msgid "jldoctest pointtype"
msgstr "jldoctest pointtype"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:536
#, no-wrap
msgid ""
"julia> struct Point{T}\n"
"           x::T\n"
"           y::T\n"
"       end\n"
msgstr ""
"julia> struct Point{T}\n"
"           x::T\n"
"           y::T\n"
"       end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:550
msgid ""
"This declaration defines a new parametric type, `Point{T}`, holding two \"coordinates\" of type `T`. What, one may ask, is `T`? Well, that's "
"precisely the point of parametric types: it can be any type at all (or a value of any bits type, actually, although here it's clearly used "
"as a type).  `Point{Float64}` is a concrete type equivalent to the type defined by replacing `T` in the definition of `Point` with "
"[`Float64`](@ref). Thus, this single declaration actually declares an unlimited number of types: `Point{Float64}`, `Point{AbstractString}`, "
"`Point{Int64}`, etc. Each of these is now a usable concrete type:"
msgstr ""
"ãã®å®£è¨ã§ã¯ãã¿ã¤ã `T` ã® 2 ã¤ã® ãåº§æ¨ããä¿æããæ°ãããã©ã¡ããªãã¯å `Point{T}` ãå®ç¾©ãã¦ãã¾ãããTãã£ã¦ä½ã ?ã¨æãããããã¾ãã"
"ããã¾ãããããã¾ãã«ãã©ã¡ããªãã¯åã®ãã¤ã³ãã§ã: ã©ããªå(ã¾ãã¯ããªããã£ãåã§ãæ§ãã¾ããããããã§ã¯å®éã«ã¯æãããªåãä½¿ããã¦ãã¾"
"ã)ã§ãæ§ãã¾ããã`Point{Float64}` ã¯ã`Point` ã®å®ç¾©ã§ `T` ã [`Float64`](@ref) ã«ç½®ãæãããã®ã¨åç­ã®å·è±¡åã§ãããããã£ã¦ããã®ä¸ã¤ã®"
"å®£è¨æãå®è³ªçã«ã¯ã`Point{Float64}`ã`Point{AbstractString}`ã`Point{Int64}`ãªã©ãç¡æ°ã®åã«å¯¾ããå®£è¨ã«ç¸å½ãã¾ããããã¦ããããããå·è±¡å"
"ã¨ãã¦å©ç¨ãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:551
#, no-wrap
msgid ""
"julia> Point{Float64}\n"
"Point{Float64}\n"
"\n"
"julia> Point{AbstractString}\n"
"Point{AbstractString}\n"
msgstr ""
"julia> Point{Float64}\n"
"Point{Float64}\n"
"\n"
"julia> Point{AbstractString}\n"
"Point{AbstractString}\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:561
msgid ""
"The type `Point{Float64}` is a point whose coordinates are 64-bit floating-point values, while the type `Point{AbstractString}` is a \"point"
"\" whose \"coordinates\" are string objects (see [Strings](@ref))."
msgstr ""
"`Point{Float64}`ã¨ããåã¯åº§æ¨ã64ãããæµ®åå°æ°ç¹ã®å¤ãæã¤ç¹ã§ããã`Point{AbstractString}`ã¨ããåã¯ãåº§æ¨ããæå­åãªãã¸ã§ã¯ãã§ãããã"
"ã¤ã³ããã§ã([`æå­å`](@ref Strings) ãåç§)ã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:564
msgid "`Point` itself is also a valid type object, containing all instances `Point{Float64}`, `Point{AbstractString}`, etc. as subtypes:"
msgstr ""
"`Point` (åãã©ã¡ã¼ã¿ç¡ãã®åä½) ãæå¹ãªåãªãã¸ã§ã¯ãã§ã`Point{Float64}`ã`Point{AbstractString}`ãªã©ãã¹ã¦ã®ã¤ã³ã¹ã¿ã³ã¹ããµãã¿ã¤ãã¨ã"
"ã¦å«ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:565
#, no-wrap
msgid ""
"julia> Point{Float64} <: Point\n"
"true\n"
"\n"
"julia> Point{AbstractString} <: Point\n"
"true\n"
msgstr ""
"julia> Point{Float64} <: Point\n"
"true\n"
"\n"
"julia> Point{AbstractString} <: Point\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:574
msgid "Other types, of course, are not subtypes of it:"
msgstr "ä»ã®åã¯å½ç¶`Point`ã®ãµãã¿ã¤ãã§ã¯ããã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:575
#, no-wrap
msgid ""
"julia> Float64 <: Point\n"
"false\n"
"\n"
"julia> AbstractString <: Point\n"
"false\n"
msgstr ""
"julia> Float64 <: Point\n"
"false\n"
"\n"
"julia> AbstractString <: Point\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:584
msgid "Concrete `Point` types with different values of `T` are never subtypes of each other:"
msgstr "ç°ãªã `T` ã®å¤ãã¤ããå·è±¡å`Point`ã¯æ±ºãã¦äºãã«ãµãã¿ã¤ãã«ãªããã¨ã¯ããã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:585
#, no-wrap
msgid ""
"julia> Point{Float64} <: Point{Int64}\n"
"false\n"
"\n"
"julia> Point{Float64} <: Point{Real}\n"
"false\n"
msgstr ""
"julia> Point{Float64} <: Point{Int64}\n"
"false\n"
"\n"
"julia> Point{Float64} <: Point{Real}\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:595
#, no-wrap
msgid ""
"!!! warning\n"
"    This last point is *very* important: even though `Float64 <: Real` we **DO NOT** have `Point{Float64} <: Point{Real}`.\n"
msgstr ""
"!!! è­¦å\n"
"    ãã®æå¾ã®ãã¤ã³ãã¯ *éå¸¸ã«* éè¦ã§ã: `Float64 <: Real`ã¯æãç«ã¡ã¾ããã`Point{Float64} <: Point{Real}` ã¯*æãç«ã¡ã¾ãã*\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:600
msgid ""
"In other words, in the parlance of type theory, Julia's type parameters are *invariant*, rather than being [covariant (or even "
"contravariant)](https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29). This is for practical reasons: while "
"any instance of `Point{Float64}` may conceptually be like an instance of `Point{Real}` as well, the two types have different representations "
"in memory:"
msgstr ""
"åçè«ã®è¿°èªã§è¨ãæããã¨ãJulia ã®åãã©ã¡ã¼ã¿ã¯ã[å±å¤ (ãããã¯åå¤)](https://en.wikipedia.org/wiki/Covariance_and_contravariance_"
"%28computer_science%29) ã§ã¯ãªãã*ä¸å¤* ã§ããããã«ã¯ç¾å®çãªçç±ãããã¾ã: `Point{Float64}`ã®ã¤ã³ã¹ã¿ã³ã¹ã¯`Point{Real}`ã®ã¤ã³ã¹ã¿ã³ã¹ã¨"
"æ¦å¿µçã«ã¯ä¼¼ã¦ãã¾ããã2ã¤ã®åã®ã¡ã¢ãªä¸ã§ã®è¡¨ç¾ã¯ç°ãªãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:607
msgid "An instance of `Point{Float64}` can be represented compactly and efficiently as an immediate pair of 64-bit values;"
msgstr "`Point{Float64}` ã®ã¤ã³ã¹ã¿ã³ã¹ã¯ã64 ãããå¤ã®å³æãã¢ã¨ãã¦ã³ã³ãã¯ããã¤å¹ççã«è¡¨ç¾ã§ãã¾ã;"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:607
msgid ""
"An instance of `Point{Real}` must be able to hold any pair of instances of [`Real`](@ref).  Since objects that are instances of `Real` can "
"be of arbitrary size and structure, in practice an instance of `Point{Real}` must be represented as a pair of pointers to individually "
"allocated `Real` objects."
msgstr ""
"`Point{Real}` ã®ã¤ã³ã¹ã¿ã³ã¹ã¯ã[`Real`](@ref) ã®ã¤ã³ã¹ã¿ã³ã¹ã®ä»»æã®ãã¢ãä¿æã§ããå¿è¦ãããã¾ãã `Real` ã®ã¤ã³ã¹ã¿ã³ã¹ã§ãããªãã¸ã§ã¯ã"
"ã¯ä»»æã®ãµã¤ãºã¨æ§é ãæã¤ãã¨ãã§ãããããå®éã«ã¯`Point{Real}` ã®ã¤ã³ã¹ã¿ã³ã¹ã¯ãåå¥ã«å²ãå½ã¦ããã `Real` ãªãã¸ã§ã¯ãã¸ã®ãã¤ã³ã¿ã®ã"
"ã¢ã¨ãã¦è¡¨ãå¿è¦ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:615
msgid ""
"The efficiency gained by being able to store `Point{Float64}` objects with immediate values is magnified enormously in the case of arrays: "
"an `Array{Float64}` can be stored as a contiguous memory block of 64-bit floating-point values, whereas an `Array{Real}` must be an array of "
"pointers to individually allocated [`Real`](@ref) objects -- which may well be [boxed](https://en.wikipedia.org/wiki/Object_type_%28object-"
"oriented_programming%29#Boxing)  64-bit floating-point values, but also might be arbitrarily large, complex objects, which are declared to "
"be implementations of the `Real` abstract type."
msgstr ""
"`Point{Float64}` ã«å¤ãç´æ¥æ ¼ç´ã§ãããã¨ã§å¾ãããå¹çã¯ãéåã®å ´åã¯éå¸¸ã«å¤§ãããªãã¾ã: `Array{Float64}` ã¯ 64 ãããæµ®åå°æ°ç¹å¤ã®é£ç¶"
"ããã¡ã¢ãª ãã­ãã¯ã¨ãã¦æ ¼ç´ããã¾ããã`Array{Real}`ã¯ãåå¥ã«å²ãå½ã¦ããã[`Real`](@ref)ãªãã¸ã§ã¯ãã¸ã®ãã¤ã³ã¿ã®éåã§ãªããã°ãªãã¾ã"
"ããæ½è±¡å`Real`ã«å®£è¨ããããªãã¸ã§ã¯ãã®å®è£ã¯ã64ãããæµ®åå°æ°ç¹æ°ã[ããã¯ã¹å](https://en.wikipedia.org/wiki/Object_type_%28object-"
"oriented_programming%29#Boxing)ããã¦ããå ´åããä»»æã®å¤§ããã®è¤éãªãªãã¸ã§ã¯ãã§ããå ´åãè¨±å®¹ããªãã¦ã¯ããã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:618
msgid "Since `Point{Float64}` is not a subtype of `Point{Real}`, the following method can't be applied to arguments of type `Point{Float64}`:"
msgstr "`Point{Float64}` ã¯ `Point{Real}` ã®ãµãã¿ã¤ãã§ã¯ãªããããæ¬¡ã®ã¡ã½ããã¯ `Point{Float64}` åã®å¼æ°ã«ã¯é©ç¨ã§ãã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:619
#, no-wrap
msgid ""
"function norm(p::Point{Real})\n"
"    sqrt(p.x^2 + p.y^2)\n"
"end\n"
msgstr ""
"function norm(p::Point{Real})\n"
"    sqrt(p.x^2 + p.y^2)\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:627
msgid "A correct way to define a method that accepts all arguments of type `Point{T}` where `T` is a subtype of [`Real`](@ref) is:"
msgstr "`T` ã [`Real`](@ref) ã®ãµãã¿ã¤ãã§ãã `Point{T}`ã®ãã¹ã¦ã®å¼æ°ãè¨±å®¹ããã¡ã½ããã®æ­£ããå®ç¾©æ¹æ³ã¯ä¸è¨ã®éãã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:628
#, no-wrap
msgid ""
"function norm(p::Point{<:Real})\n"
"    sqrt(p.x^2 + p.y^2)\n"
"end\n"
msgstr ""
"function norm(p::Point{<:Real})\n"
"    sqrt(p.x^2 + p.y^2)\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:636
#, no-wrap
msgid ""
"(Equivalently, one could define `function norm(p::Point{T} where T<:Real)` or\n"
"`function norm(p::Point{T}) where T<:Real`; see [UnionAll Types](@ref).)\n"
msgstr "(åç­ã®å®ç¾©ã¨ãã¦ã`function norm(p::Point{T} where T<:Real)` ãã`function norm(p::Point{T}) where T<:Real` ãå¯è½ã§ã; [å¨åä½µå](@ref UnionAll-Types)ãåç§ã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:638
msgid "More examples will be discussed later in [Methods](@ref)."
msgstr "å¾ã® [ã¡ã½ãã](@ref Methods) ã§ãããå¤ãã®ä¾ãèª¬æãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:644
msgid ""
"How does one construct a `Point` object? It is possible to define custom constructors for composite types, which will be discussed in detail "
"in [Constructors](@ref man-constructors), but in the absence of any special constructor declarations, there are two default ways of creating "
"new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the "
"object constructor."
msgstr ""
"`Point` ãªãã¸ã§ã¯ãã¯ã©ã®ããã«æ§ç¯ãããã§ãããã? [ã³ã³ã¹ãã©ã¯ã¿ã¼](@ref man-constructors)ã§è©³ããèª¬æãã¾ãããè¤ååã«å¯¾ãã¦ç¬èªã®ã³ã³"
"ã¹ãã©ã¯ã¿ãå®ç¾©ãããã¨ã¯å¯è½ã§ãããç¹å¥ã«ã³ã³ã¹ãã©ã¯ã¿ã®å®£è¨ãããªãå ´åã«ããããã©ã«ãã§æ°ããè¤ååãªãã¸ã§ã¯ããä½æããæ¹æ³ã2ã¤ãã"
"ã¾ãã1ã¤ã¯åãã©ã¡ã¼ã¿ãæç¤ºçã«ä¸ãããã®ããã1ã¤ã¯ãªãã¸ã§ã¯ãã³ã³ã¹ãã©ã¯ã¿ã¸ã®å¼æ°ããæé»è£¡ã«æ¨å®ããããã®ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:647
msgid ""
"Since the type `Point{Float64}` is a concrete type equivalent to `Point` declared with [`Float64`](@ref)  in place of `T`, it can be applied "
"as a constructor accordingly:"
msgstr ""
"å `Point{Float64}` ã¯ `T` ã®ä»£ããã« [`Float64`](@ref) ãä½¿ã£ã¦å®£è¨ãã`Point` ã¨åç­ã®å·è±¡åã§ãããããããã«å¿ãã¦ã³ã³ã¹ãã©ã¯ã¿ã¨ãã¦ã"
"ã®ã¾ã¾é©ç¨ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:648
#, no-wrap
msgid ""
"julia> Point{Float64}(1.0, 2.0)\n"
"Point{Float64}(1.0, 2.0)\n"
"\n"
"julia> typeof(ans)\n"
"Point{Float64}\n"
msgstr ""
"julia> Point{Float64}(1.0, 2.0)\n"
"Point{Float64}(1.0, 2.0)\n"
"\n"
"julia> typeof(ans)\n"
"Point{Float64}\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:657
msgid "For the default constructor, exactly one argument must be supplied for each field:"
msgstr "ããã©ã«ãã®ã³ã³ã¹ãã©ã¯ã¿ã§ã¯ããã£ã¼ã«ããã¨ã« å¼æ°ãæå®ããå¿è¦ãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:658
#, no-wrap
msgid ""
"julia> Point{Float64}(1.0)\n"
"ERROR: MethodError: no method matching Point{Float64}(::Float64)\n"
"[...]\n"
"\n"
"julia> Point{Float64}(1.0,2.0,3.0)\n"
"ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)\n"
"[...]\n"
msgstr ""
"julia> Point{Float64}(1.0)\n"
"ERROR: MethodError: no method matching Point{Float64}(::Float64)\n"
"[...]\n"
"\n"
"julia> Point{Float64}(1.0,2.0,3.0)\n"
"ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)\n"
"[...]\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:670
msgid ""
"Only one default constructor is generated for parametric types, since overriding it is not possible.  This constructor accepts any arguments "
"and converts them to the field types."
msgstr ""
"ãã©ã¡ããªãã¯åã§ã¯ãããã©ã«ãã®ã³ã³ã¹ãã©ã¯ã¿ã¼ã¯ 1 ã¤ã ãããçæããã¾ããããªã¼ãã¼ã©ã¤ãã§ããªãããããã®ã³ã³ã¹ãã©ã¯ã¿ã¼ã¯ä»»æã®å¼æ°"
"ãåãåãããã£ã¼ã«ãã®åã«å¤æãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:675
msgid ""
"In many cases, it is redundant to provide the type of `Point` object one wants to construct, since the types of arguments to the constructor "
"call already implicitly provide type information. For that reason, you can also apply `Point` itself as a constructor, provided that the "
"implied value of the parameter type `T` is unambiguous:"
msgstr ""
"å¤ãã®å ´åãçæãããã¨ãã `Point` ãªãã¸ã§ã¯ãã®åãæå®ãããã¨ã¯åé·ã§ããã³ã³ã¹ãã©ã¯ã¿ã¼å¼ã³åºãã®å¼æ°ã®åã«ã¯æ¢ã«åæå ±ãé ãã¦ããã"
"ãã§ãããã®ããããã©ã¡ã¼ã¿ã¼å `T` ãæ¨è«å¯è½ã§ææ§ãããªãå ´åã¯ã`Point` èªä½ãã³ã³ã¹ãã©ã¯ã¿ã¨ãã¦é©ç¨ãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:676
#, no-wrap
msgid ""
"julia> Point(1.0,2.0)\n"
"Point{Float64}(1.0, 2.0)\n"
"\n"
"julia> typeof(ans)\n"
"Point{Float64}\n"
"\n"
"julia> Point(1,2)\n"
"Point{Int64}(1, 2)\n"
"\n"
"julia> typeof(ans)\n"
"Point{Int64}\n"
msgstr ""
"julia> Point(1.0,2.0)\n"
"Point{Float64}(1.0, 2.0)\n"
"\n"
"julia> typeof(ans)\n"
"Point{Float64}\n"
"\n"
"julia> Point(1,2)\n"
"Point{Int64}(1, 2)\n"
"\n"
"julia> typeof(ans)\n"
"Point{Int64}\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:692
msgid ""
"In the case of `Point`, the type of `T` is unambiguously implied if and only if the two arguments to `Point` have the same type. When this "
"isn't the case, the constructor will fail with a [`MethodError`](@ref):"
msgstr ""
"`Point` ã®å ´åã2 ã¤ã®å¼æ°ãåãåã§ããå ´åã«ã®ã¿ã`T` ã®åã¯æç¢ºã«æ¨è«ããã¾ããããã§ãªãå ´åãã³ã³ã¹ãã©ã¯ã¿ã¯å¤±æãã¦ [`MethodError`]"
"(@ref)ãçºçãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:693
#, no-wrap
msgid ""
"julia> Point(1,2.5)\n"
"ERROR: MethodError: no method matching Point(::Int64, ::Float64)\n"
"Closest candidates are:\n"
"  Point(::T, !Matched::T) where T at none:2\n"
msgstr ""
"julia> Point(1,2.5)\n"
"ERROR: MethodError: no method matching Point(::Int64, ::Float64)\n"
"Closest candidates are:\n"
"  Point(::T, !Matched::T) where T at none:2\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:702
msgid ""
"Constructor methods to appropriately handle such mixed cases can be defined, but that will not be discussed until later on in [Constructors]"
"(@ref man-constructors)."
msgstr ""
"ãã®ããã«åãæ··å¨ããã±ã¼ã¹ãé©åã«å¦çããã³ã³ã¹ãã©ã¯ã¿ã¼ ã¡ã½ããã¯å®ç¾©ã§ãã¾ãããå¾ã§ [ã³ã³ã¹ãã©ã¯ã¿](@ref man-constructors)ã«è­°è«ã¯è­²"
"ãã¾ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/types.md:703
#, no-wrap
msgid "Parametric Abstract Types"
msgstr "ãã©ã¡ããªãã¯æ½è±¡å"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:707
msgid "Parametric abstract type declarations declare a collection of abstract types, in much the same way:"
msgstr "ãã©ã¡ããªãã¯æ½è±¡åã®å®£è¨ãã»ã¼åãæ¹æ³ã§ãæ½è±¡åã®ä¸ç¾¤ã«å¯¾ãã¦åå®£è¨ãè¡ãã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/types.md:708 ext/julia/doc/src/manual/types.md:715 ext/julia/doc/src/manual/types.md:725
#: ext/julia/doc/src/manual/types.md:736 ext/julia/doc/src/manual/types.md:748 ext/julia/doc/src/manual/types.md:757
#: ext/julia/doc/src/manual/types.md:770 ext/julia/doc/src/manual/types.md:782
#, no-wrap
msgid "jldoctest pointytype"
msgstr "jldoctest pointytype"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:708
#, no-wrap
msgid "julia> abstract type Pointy{T} end\n"
msgstr "julia> abstract type Pointy{T} end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:714
msgid ""
"With this declaration, `Pointy{T}` is a distinct abstract type for each type or integer value of `T`. As with parametric composite types, "
"each such instance is a subtype of `Pointy`:"
msgstr ""
"ãã®å®£è¨ã§ã¯ã`Pointy{T}` ã¯ãåãæ´æ°å¤ãè¡¨ã `T`ããããã«å¯¾ãã¦å¥ãã®æ½è±¡åã«ãªãã¾ãããã©ã¡ããªè¤ååã¨åæ§ã«ãåã¤ã³ã¹ã¿ã³ã¹ã¯`Pointy`"
"ã®ãµãã¿ã¤ãã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:715
#, no-wrap
msgid ""
"julia> Pointy{Int64} <: Pointy\n"
"true\n"
"\n"
"julia> Pointy{1} <: Pointy\n"
"true\n"
msgstr ""
"julia> Pointy{Int64} <: Pointy\n"
"true\n"
"\n"
"julia> Pointy{1} <: Pointy\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:724
msgid "Parametric abstract types are invariant, much as parametric composite types are:"
msgstr "ãã©ã¡ããªãã¯æ½è±¡åã¯ããã©ã¡ããªãã¯ãªè¤ååã¨åãã ä¸å¤ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:725
#, no-wrap
msgid ""
"julia> Pointy{Float64} <: Pointy{Real}\n"
"false\n"
"\n"
"julia> Pointy{Real} <: Pointy{Float64}\n"
"false\n"
msgstr ""
"julia> Pointy{Float64} <: Pointy{Real}\n"
"false\n"
"\n"
"julia> Pointy{Real} <: Pointy{Float64}\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:736
#, no-wrap
msgid ""
"The notation `Pointy{<:Real}` can be used to express the Julia analogue of a\n"
"*covariant* type, while `Pointy{>:Int}` the analogue of a *contravariant* type,\n"
"but technically these represent *sets* of types (see [UnionAll Types](@ref)).\n"
msgstr "`Pointy{<:Real}`ã®è¡¨è¨ã§*å±å¤*åã®ãããªãã®ãã`Point{>:Int}` ã®è¡¨è¨ã§*åå¤*åã®ãããªãã®ãè¡¨ç¾ã§ãã¾ãããæè¡çã«ã¯ããããã¯åã®*éå*ãè¡¨ãã¦ãã¾ãã([å¨åä½µå](@ref UnionAll-Types)åç§)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:736
#, no-wrap
msgid ""
"julia> Pointy{Float64} <: Pointy{<:Real}\n"
"true\n"
"\n"
"julia> Pointy{Real} <: Pointy{>:Int}\n"
"true\n"
msgstr ""
"julia> Pointy{Float64} <: Pointy{<:Real}\n"
"true\n"
"\n"
"julia> Pointy{Real} <: Pointy{>:Int}\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:747
msgid ""
"Much as plain old abstract types serve to create a useful hierarchy of types over concrete types, parametric abstract types serve the same "
"purpose with respect to parametric composite types. We could, for example, have declared `Point{T}` to be a subtype of `Pointy{T}` as "
"follows:"
msgstr ""
"éå¸¸ã®æ½è±¡åã¯ãå·è±¡åã«å¯¾ãã¦å½¹ã«ç«ã¤åã®éå±¤ãä½æããã®ã«ä½¿ãããã®ã«å¯¾ãã¦ããã©ã¡ããªãã¯æ½è±¡åã¯ããã©ã¡ããªãã¯è¤ååã¨åããããªç®ç"
"ã«ä½¿ãã¾ããä¾ãã°ã`Point{T}` ã `Pointy{T}`ã®ãµãã¿ã¤ãã¨ããå®£è¨ã¯æ¬¡ã®ããã«å®£è¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:748
#, no-wrap
msgid ""
"julia> struct Point{T} <: Pointy{T}\n"
"           x::T\n"
"           y::T\n"
"       end\n"
msgstr ""
"julia> struct Point{T} <: Pointy{T}\n"
"           x::T\n"
"           y::T\n"
"       end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:756
msgid "Given such a declaration, for each choice of `T`, we have `Point{T}` as a subtype of `Pointy{T}`:"
msgstr "ãã®å®£è¨ã§ãããããé¸ãã  `T` ã«å¯¾ãã¦ã`Pointy{T}`ã®ãµãã¿ã¤ãã§ãã`Point{T}` ãä½¿ããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:757
#, no-wrap
msgid ""
"julia> Point{Float64} <: Pointy{Float64}\n"
"true\n"
"\n"
"julia> Point{Real} <: Pointy{Real}\n"
"true\n"
"\n"
"julia> Point{AbstractString} <: Pointy{AbstractString}\n"
"true\n"
msgstr ""
"julia> Point{Float64} <: Pointy{Float64}\n"
"true\n"
"\n"
"julia> Point{Real} <: Pointy{Real}\n"
"true\n"
"\n"
"julia> Point{AbstractString} <: Pointy{AbstractString}\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:769
msgid "This relationship is also invariant:"
msgstr "ä»¥ä¸ã®é¢ä¿ãä¸å¤ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:770
#, no-wrap
msgid ""
"julia> Point{Float64} <: Pointy{Real}\n"
"false\n"
"\n"
"julia> Point{Float64} <: Pointy{<:Real}\n"
"true\n"
msgstr ""
"julia> Point{Float64} <: Pointy{Real}\n"
"false\n"
"\n"
"julia> Point{Float64} <: Pointy{<:Real}\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:781
msgid ""
"What purpose do parametric abstract types like `Pointy` serve? Consider if we create a point-like implementation that only requires a single "
"coordinate because the point is on the diagonal line *x = y*:"
msgstr ""
"`Pointy` ã®ãããªãã©ã¡ããªãã¯æ½è±¡åã®ç®çã¯ãªãã§ãããã? `Point` ãå¯¾è§ç· `x=y`ä¸ã«ãããåº§æ¨ã1ã¤ããã°ååãªå ´åã«ããã ç¹ã®ãããªå®è£"
"ãèãã¦ã¿ãã¨:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:782
#, no-wrap
msgid ""
"julia> struct DiagPoint{T} <: Pointy{T}\n"
"           x::T\n"
"       end\n"
msgstr ""
"julia> struct DiagPoint{T} <: Pointy{T}\n"
"           x::T\n"
"       end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:793
msgid ""
"Now both `Point{Float64}` and `DiagPoint{Float64}` are implementations of the `Pointy{Float64}` abstraction, and similarly for every other "
"possible choice of type `T`. This allows programming to a common interface shared by all `Pointy` objects, implemented for both `Point` and "
"`DiagPoint`.  This cannot be fully demonstrated, however, until we have introduced methods and dispatch in the next section, [Methods](@ref)."
msgstr ""
"ããã§ã`Point{Float64}` ã¨ `DiagPoint{Float64}` ã¯ãæ½è±¡å`Pointf{Float64}` ã®å®è£ã§ããããã¯ `T`ã«ä»ã®åãããåãé¸ãã§ãåãã§ããããã«"
"ãã£ã¦ã`Point`ã¨`DiagPoint` ã®ã©ã¡ããå®è£ããã«ãã¦ã `Pointy` ãªãã¸ã§ã¯ããå±éã®ã¤ã³ã¿ã¼ãã§ã¤ã¹ã«ãããã­ã°ã©ãã³ã°ãå¯è½ã«ãªãã¾ããã"
"ãã«ã¤ãã¦ã®ãå®å¨ãªè§£èª¬ã¯ãã¡ã½ããã¨ãã£ã¹ããããå°å¥ããæ¬¡ã® [ã¡ã½ãã](@ref Methods) ã®ç« ã«è­²ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:796
msgid ""
"There are situations where it may not make sense for type parameters to range freely over all possible types. In such situations, one can "
"constrain the range of `T` like so:"
msgstr ""
"ã©ããªåã§ããåãã©ã¡ã¼ã¿ãã¨ãããããã«ãã¦ãã¾ãã¨ãæå³ãæããªãå ´åãããã¾ãããã®ãããªç¶æ³ã§ã¯æ¬¡ã®ããã«ã `T`ã®ç¯å²ãå¶éãããã¨"
"ãã§ãã¾ã :"

#. type: Code fence info string
#: ext/julia/doc/src/manual/types.md:797 ext/julia/doc/src/manual/types.md:804
#, no-wrap
msgid "jldoctest realpointytype"
msgstr "jldoctest realpointytype"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:797
#, no-wrap
msgid "julia> abstract type Pointy{T<:Real} end\n"
msgstr "julia> abstract type Pointy{T<:Real} end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:803
msgid ""
"With such a declaration, it is acceptable to use any type that is a subtype of [`Real`](@ref) in place of `T`, but not types that are not "
"subtypes of `Real`:"
msgstr "ãã®å®£è¨ã§ã¯ã`T`ãä»»æã®`Real`ã®ãµãã¿ã¤ãã®å ´åã«è¨±å®¹ãããããã§ãªããã®ã¯ã¯è¨±å®¹ããã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:804
#, no-wrap
msgid ""
"julia> Pointy{Float64}\n"
"Pointy{Float64}\n"
"\n"
"julia> Pointy{Real}\n"
"Pointy{Real}\n"
"\n"
"julia> Pointy{AbstractString}\n"
"ERROR: TypeError: in Pointy, in T, expected T<:Real, got Type{AbstractString}\n"
"\n"
"julia> Pointy{1}\n"
"ERROR: TypeError: in Pointy, in T, expected T<:Real, got Int64\n"
msgstr ""
"julia> Pointy{Float64}\n"
"Pointy{Float64}\n"
"\n"
"julia> Pointy{Real}\n"
"Pointy{Real}\n"
"\n"
"julia> Pointy{AbstractString}\n"
"ERROR: TypeError: in Pointy, in T, expected T<:Real, got Type{AbstractString}\n"
"\n"
"julia> Pointy{1}\n"
"ERROR: TypeError: in Pointy, in T, expected T<:Real, got Int64\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:819
msgid "Type parameters for parametric composite types can be restricted in the same manner:"
msgstr "ãã©ã¡ããªãã¯è¤ååã®åãã©ã¡ã¼ã¿ãåãæ¹æ³ã§å¶éã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:820
#, no-wrap
msgid ""
"struct Point{T<:Real} <: Pointy{T}\n"
"    x::T\n"
"    y::T\n"
"end\n"
msgstr ""
"struct Point{T<:Real} <: Pointy{T}\n"
"    x::T\n"
"    y::T\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:830
msgid ""
"To give a real-world example of how all this parametric type machinery can be useful, here is the actual definition of Julia's [`Rational`]"
"(@ref) immutable type (except that we omit the constructor here for simplicity), representing an exact ratio of integers:"
msgstr ""
"ç¾å®ä¸çã§ã®ããã©ã¡ã¼ã¿åãã©ãã»ã©å½¹ã«ç«ã¤ãã®ä¾ã¨ãã¦ãããã§ã¯ãæ´æ°ã®æ¯ãè¡¨ã `Rational` ã¨ããä¸å¤åããJuliaã§ã©ã®æ§ã«å®ç¾©ããã¦ããã"
"ãç¤ºãã¾ãã(åç´åã®ãããããã§ã¯ã³ã³ã¹ãã©ã¯ã¿ã¯çç¥):"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:831
#, no-wrap
msgid ""
"struct Rational{T<:Integer} <: Real\n"
"    num::T\n"
"    den::T\n"
"end\n"
msgstr ""
"struct Rational{T<:Integer} <: Real\n"
"    num::T\n"
"    den::T\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:841
msgid ""
"It only makes sense to take ratios of integer values, so the parameter type `T` is restricted to being a subtype of [`Integer`](@ref), and a "
"ratio of integers represents a value on the real number line, so any [`Rational`](@ref) is an instance of the [`Real`](@ref) abstraction."
msgstr ""
"ããã¯ãæ´æ°å¤ã®æ¯çã«ãªãã¨ãã ã æçæ°ã¨ãã¦ã®æå³ããªãã®ã§ããã©ã¡ã¼ã¿ã®å`T`ã¯ã`Integer`ã®ãµãã¿ã¤ãã«éå®ããã¦ãã¾ããæ´æ°ã®æ¯ã¯æ°ç´"
"ç·ä¸ã®å¤ãè¡¨ç¾ããã®ã§ãä»»æã®`Rational`ã¯ãæ½è±¡å`Real`ã®ã¤ã³ã¹ã¿ã³ã¹ã§ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/types.md:842
#, no-wrap
msgid "Tuple Types"
msgstr "[ã¿ãã«å](@id Tuple-Types)"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:848
msgid ""
"Tuples are an abstraction of the arguments of a function -- without the function itself. The salient aspects of a function's arguments are "
"their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one "
"field. For example, a 2-element tuple type resembles the following immutable type:"
msgstr ""
"ã¿ãã«ã¨ã¯ãé¢æ°æ¬ä½ãããå¼æ°ã ããæãåãã ãããã®ã§ããé¢æ°ã®å¼æ°ã®é¡èãªç¹å¾´ã¯ãé åºã¨åã§ãããã®ãããã¿ãã«åã¯ãä¸å¤ãªãã©ã¡ã¼ã¿è¤"
"ååã§ããã¤åãã©ã¡ã¼ã¿ããã£ã¼ã«ãã®åã«å¯¾å¿ãã¦ãããã®ã«ä¼¼ã¦ãã¾ããä¾ãã°ã2è¦ç´ ã®ã¿ãã«åã¯ãæ¬¡ã®è¤ååã«ä¼¼ã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:849
#, no-wrap
msgid ""
"struct Tuple2{A,B}\n"
"    a::A\n"
"    b::B\n"
"end\n"
msgstr ""
"struct Tuple2{A,B}\n"
"    a::A\n"
"    b::B\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:857
msgid "However, there are three key differences:"
msgstr "ãã ããéè¦ãªéãã3 ã¤ããã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:863
msgid "Tuple types may have any number of parameters."
msgstr "ã¿ãã«åã¯ãä»»æã®æ°ã®ãã©ã¡ã¼ã¿ãæã¤ãã¨ãã§ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:863
msgid ""
"Tuple types are *covariant* in their parameters: `Tuple{Int}` is a subtype of `Tuple{Any}`. Therefore `Tuple{Any}` is considered an abstract "
"type, and tuple types are only concrete if their parameters are."
msgstr ""
"ã¿ãã«åã¯ããã®ãã©ã¡ã¼ã¿ã¨ *å±å¤* ã§ã: `Tuple{int}` ã¯ `Tuple{Any}` ã®ãµãã¿ã¤ãã§ãããããã£ã¦ã`Tuple{Any}` ã¯æ½è±¡åã¨ã¿ãªãããã¿ãã«"
"åã¯ãã®ãã©ã¡ã¼ã¿ãå·è±¡åã®å ´åã«ã®ã¿ãå·è±¡åã§ãããã¨ãããã¨ã«ãªãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/types.md:863
msgid "Tuples do not have field names; fields are only accessed by index."
msgstr "ã¿ãã«ã«ãã£ã¼ã«ãåã¯ããã¾ãã; ãã£ã¼ã«ãã¯ã¤ã³ããã¯ã¹ã§ã®ã¿ã¢ã¯ã»ã¹ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:866
msgid "Tuple values are written with parentheses and commas. When a tuple is constructed, an appropriate tuple type is generated on demand:"
msgstr "ã¿ãã«ã®å¤ã¯ãæ¬å¼§ã¨ã«ã³ããä½¿ã£ã¦æ¸ããã¾ããã¿ãã«ãçæãããã¨ããå¿è¦ã«å¿ãã¦é©åãªã¿ãã«åãçæããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:867
#, no-wrap
msgid ""
"julia> typeof((1,\"foo\",2.5))\n"
"Tuple{Int64,String,Float64}\n"
msgstr ""
"julia> typeof((1,\"foo\",2.5))\n"
"Tuple{Int64,String,Float64}\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:873
msgid "Note the implications of covariance:"
msgstr "æé»çã«å±å¤ã¨ãªããã¨ã«æ³¨ç®ãã¦ãã ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:874
#, no-wrap
msgid ""
"julia> Tuple{Int,AbstractString} <: Tuple{Real,Any}\n"
"true\n"
"\n"
"julia> Tuple{Int,AbstractString} <: Tuple{Real,Real}\n"
"false\n"
"\n"
"julia> Tuple{Int,AbstractString} <: Tuple{Real,}\n"
"false\n"
msgstr ""
"julia> Tuple{Int,AbstractString} <: Tuple{Real,Any}\n"
"true\n"
"\n"
"julia> Tuple{Int,AbstractString} <: Tuple{Real,Real}\n"
"false\n"
"\n"
"julia> Tuple{Int,AbstractString} <: Tuple{Real,}\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:887
msgid ""
"Intuitively, this corresponds to the type of a function's arguments being a subtype of the function's signature (when the signature matches)."
msgstr "ç´æçã«ã¯ãããã¯é¢æ°ã®å¼æ°ã®åãé¢æ°ã®ã·ã°ããã£ã®ãµãã¿ã¤ãã§ãããã¨ã«ç¸å½ãã¾ãã(ã·ã°ããã£ãé©åããå ´å)ã"

#. type: Title ###
#: ext/julia/doc/src/manual/types.md:888
#, no-wrap
msgid "Vararg Tuple Types"
msgstr "å¯å¤å¼æ°ã¿ãã«å"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:892
msgid "The last parameter of a tuple type can be the special type [`Vararg`](@ref), which denotes any number of trailing elements:"
msgstr "ã¿ãã«åã®æå¾ã®ãã©ã¡ã¼ã¿ã¯ãç¹æ®ãªå [`Vararg`](@ref )ã«ãããã¨ãå¯è½ã§ãã[`Vararg`](@ref )ã¯ãä»»æåæ°ã®å¾ç¶ã®è¦ç´ ãè¡¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:893
#, no-wrap
msgid ""
"julia> mytupletype = Tuple{AbstractString,Vararg{Int}}\n"
"Tuple{AbstractString,Vararg{Int64,N} where N}\n"
"\n"
"julia> isa((\"1\",), mytupletype)\n"
"true\n"
"\n"
"julia> isa((\"1\",1), mytupletype)\n"
"true\n"
"\n"
"julia> isa((\"1\",1,2), mytupletype)\n"
"true\n"
"\n"
"julia> isa((\"1\",1,2,3.0), mytupletype)\n"
"false\n"
msgstr ""
"julia> mytupletype = Tuple{AbstractString,Vararg{Int}}\n"
"Tuple{AbstractString,Vararg{Int64,N} where N}\n"
"\n"
"julia> isa((\"1\",), mytupletype)\n"
"true\n"
"\n"
"julia> isa((\"1\",1), mytupletype)\n"
"true\n"
"\n"
"julia> isa((\"1\",1,2), mytupletype)\n"
"true\n"
"\n"
"julia> isa((\"1\",1,2,3.0), mytupletype)\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:912
msgid ""
"Notice that `Vararg{T}` corresponds to zero or more elements of type `T`. Vararg tuple types are used to represent the arguments accepted by "
"varargs methods (see [Varargs Functions](@ref))."
msgstr ""
"`Vararg{T}`ã¯ã0åä»¥ä¸ã®å`T`ã«å¯¾å¿ãããã¨ã«æ³¨æãã¦ãã ãããå¯å¤å¼æ°ã¿ãã«åã¯ãå¯å¤å¼æ°ã¡ã½ããã«ãã£ã¦åãå¥ããããå¼æ°ãè¡¨ãããã«ä½¿ç¨"
"ããã¾ãã([å¯å¤å¼æ°é¢æ°](@ref Varargs-Functions)ãåç§ã)"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:915
msgid ""
"The type `Vararg{T,N}` corresponds to exactly `N` elements of type `T`.  `NTuple{N,T}` is a convenient alias for `Tuple{Vararg{T,N}}`, i.e. "
"a tuple type containing exactly `N` elements of type `T`."
msgstr ""
"å`Vararg{T,N}` ã¯ãã¡ããã©`N`åã®å`T`ã«å¯¾å¿ãã¾ãã`NTuple{N,T}` ã¯ `Tuple{Vararg{T,N}}`ã®ä¾¿å©ãªã¨ã¤ãªã¢ã¹ã§ããã¤ã¾ããå`T`ã®è¦ç´ ãã¡ã"
"ãã©`N`åå«ãã¿ãã«åã§ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/types.md:916
#, no-wrap
msgid "Named Tuple Types"
msgstr "ååä»ãã¿ãã«å"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:920
msgid ""
"Named tuples are instances of the [`NamedTuple`](@ref) type, which has two parameters: a tuple of symbols giving the field names, and a "
"tuple type giving the field types."
msgstr ""
"ååä»ãã¿ãã«åã¯ã[`NamedTuple`](@ref ) åã®ã¤ã³ã¹ã¿ã³ã¹ã§ã2 ã¤ã®ãã©ã¡ã¼ã¿ãåãã¾ããã·ã³ãã«ã®ã¿ãã«ã¯ãã£ã¼ã«ãåãåã®ã¿ãã«ã¯ãã£ã¼"
"ã«ãã®åãä¸ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:921
#, no-wrap
msgid ""
"julia> typeof((a=1,b=\"hello\"))\n"
"NamedTuple{(:a, :b),Tuple{Int64,String}}\n"
msgstr ""
"julia> typeof((a=1,b=\"hello\"))\n"
"NamedTuple{(:a, :b),Tuple{Int64,String}}\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:929
msgid ""
"A `NamedTuple` type can be used as a constructor, accepting a single tuple argument.  The constructed `NamedTuple` type can be either a "
"concrete type, with both parameters specified, or a type that specifies only field names:"
msgstr ""
"`NamedTuple`åã¯ãã³ã³ã¹ãã©ã¯ã¿ã¨ãã¦ãå©ç¨å¯è½ã§ã1 åã®ã¿ãã«ãå¼æ°ã¨ãã¦ã¨ãã¾ããçæããã`NamedTuple`ã®åã¯ãä¸¡æ¹ã®ãã©ã¡ã¼ã¿ã®æå®ã"
"ããå·è±¡åãããã£ã¼ã«ãåã ããæå®ãããåã«ãªãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:930
#, no-wrap
msgid ""
"julia> NamedTuple{(:a, :b),Tuple{Float32, String}}((1,\"\"))\n"
"(a = 1.0f0, b = \"\")\n"
"\n"
"julia> NamedTuple{(:a, :b)}((1,\"\"))\n"
"(a = 1, b = \"\")\n"
msgstr ""
"julia> NamedTuple{(:a, :b),Tuple{Float32, String}}((1,\"\"))\n"
"(a = 1.0f0, b = \"\")\n"
"\n"
"julia> NamedTuple{(:a, :b)}((1,\"\"))\n"
"(a = 1, b = \"\")\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:940
msgid "If field types are specified, the arguments are converted. Otherwise the types of the arguments are used directly."
msgstr "ãã£ã¼ã«ãã®åãæå®ããã¨ãå¼æ°ãå¤æããã¾ããããã§ãªãå ´åã¯ãå¼æ°ã®åããã®ã¾ã¾ä½¿ããã¾ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/types.md:941
#, no-wrap
msgid "[Singleton Types](@id man-singleton-types)"
msgstr "[ã·ã³ã°ã«ãã³å](@id man-singleton-types)"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:946
msgid ""
"There is a special kind of abstract parametric type that must be mentioned here: singleton types.  For each type, `T`, the \"singleton type"
"\" `Type{T}` is an abstract type whose only instance is the object `T`. Since the definition is a little difficult to parse, let's look at "
"some examples:"
msgstr ""
"ããã§ãç¹æ®ãªãã©ã¡ã¼ã¿æ½è±¡åã§ããã·ã³ã°ã«ãã³åã«ã¤ãã¦è§¦ãã¦ããã¹ãã§ããããå `T` ããããã«å¯¾ãã¦ããã·ã³ã°ã«ãã³åã `Type{T}` ã¯ã"
"ã¤ã³ã¹ã¿ã³ã¹ã `T`ä¸ã¤ã ãã®æ½è±¡åã§ããå®ç¾©ãæ§æçã«èª¬æããã®ã¯é£ããã®ã§ãä¾ãããã¤ãè¦ã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:947
#, no-wrap
msgid ""
"julia> isa(Float64, Type{Float64})\n"
"true\n"
"\n"
"julia> isa(Real, Type{Float64})\n"
"false\n"
"\n"
"julia> isa(Real, Type{Real})\n"
"true\n"
"\n"
"julia> isa(Float64, Type{Real})\n"
"false\n"
msgstr ""
"julia> isa(Float64, Type{Float64})\n"
"true\n"
"\n"
"julia> isa(Real, Type{Float64})\n"
"false\n"
"\n"
"julia> isa(Real, Type{Real})\n"
"true\n"
"\n"
"julia> isa(Float64, Type{Real})\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:964
msgid ""
"In other words, [`isa(A,Type{B})`](@ref) is true if and only if `A` and `B` are the same object and that object is a type. Without the "
"parameter, `Type` is simply an abstract type which has all type objects as its instances, including, of course, singleton types:"
msgstr ""
"ã¤ã¾ãã[`isa(A,Type{B})`](@ref)ãçãè¿ãã®ã¯ã`A`ã¨`B`ãåããªãã¸ã§ã¯ãã§ããã®ãªãã¸ã§ã¯ããåã§ããå ´åã«éããã¨ãããã¨ã§ãããã©ã¡ã¼"
"ã¿ç¡ãã® `Type`ã¯ãåãªãæ½è±¡åã§ãå¨ã¦ã®ãªãã¸ã§ã¯ãã¯`Type`ã®ã¤ã³ã¹ã¿ã³ã¹ã§ã(ãã¡ããã·ã³ã°ã«ãã³åãå«ã¿ã¾ã):"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:965
#, no-wrap
msgid ""
"julia> isa(Type{Float64}, Type)\n"
"true\n"
"\n"
"julia> isa(Float64, Type)\n"
"true\n"
"\n"
"julia> isa(Real, Type)\n"
"true\n"
msgstr ""
"julia> isa(Type{Float64}, Type)\n"
"true\n"
"\n"
"julia> isa(Float64, Type)\n"
"true\n"
"\n"
"julia> isa(Real, Type)\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:977
msgid "Any object that is not a type is not an instance of `Type`:"
msgstr "åã§ãªããªãã¸ã§ã¯ãã¯ã`Type`ã®ã¤ã³ã¹ã¿ã³ã¹ã§ã¯ããã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:978
#, no-wrap
msgid ""
"julia> isa(1, Type)\n"
"false\n"
"\n"
"julia> isa(\"foo\", Type)\n"
"false\n"
msgstr ""
"julia> isa(1, Type)\n"
"false\n"
"\n"
"julia> isa(\"foo\", Type)\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:991
msgid ""
"Until we discuss [Parametric Methods](@ref) and [conversions](@ref conversion-and-promotion), it is difficult to explain the utility of the "
"singleton type construct, but in short, it allows one to specialize function behavior on specific type *values*. This is useful for writing "
"methods (especially parametric ones) whose behavior depends on a type that is given as an explicit argument rather than implied by the type "
"of one of its arguments."
msgstr ""
"[ãã©ã¡ããªãã¯ã¡ã½ãã](@ref parametric-methods) ã¨ [å¤æ](@ref conversion-and-promotion) ã®è­°è«ãããåã«ãã·ã³ã°ã«ãã³åã®ä»çµã¿ãã©ãå½¹ã«"
"ç«ã¤ããèª¬æãããã¨ã¯é£ããã®ã§ãããæç­ã«ããã¨ãé¢æ°ã®æåãç¹å®ã®åã®å¤ã ãã«ç¹åãããã¨ãã§ãã¾ãããããå½¹ã«ç«ã¤ã®ã¯ãæåãåã«ãã£"
"ã¦ãã¾ã(ç¹ã«ãã©ã¡ããªãã¯ãª)ã¡ã½ãããæ¸ãæã§ãããããã®åãåæã«æ¨è«ãããã®ã§ãªããããããå¼æ°ã¨ãã¦ä¸ããå ´åã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:996
msgid ""
"A few popular languages have singleton types, including Haskell, Scala and Ruby. In general usage, the term \"singleton type\" refers to a "
"type whose only instance is a single value. This meaning applies to Julia's singleton types, but with that caveat that only type objects "
"have singleton types."
msgstr ""
"Haskell, Scala, Rubyãªã©ã®äººæ°ã®ããè¨èªã¯ã·ã³ã°ã«ãã³åãããã¾ããä¸è¬çãªä½¿ç¨æ¹æ³ã§ã¯ããã·ã³ã°ã«ãã³åãã¨ããç¨èªã¯ãå¯ä¸ã®ã¤ã³ã¹ã¿ã³ã¹"
"ãåä¸ã®å¤ã§ããåã®ãã¨ãæãã¾ãããã®æå³ã¯Juliaã®ã·ã³ã°ã«ãã³åã«ãå½ã¦ã¯ã¾ã£ã¦ãã¾ãããåãªãã¸ã§ã¯ãã ããã·ã³ã°ã«ãã³åã«ãªãã¨ããç¹"
"ãç¹æ®ãªã®ã§æ³¨æãã¦ãã ããã"

#. type: Title ###
#: ext/julia/doc/src/manual/types.md:997
#, no-wrap
msgid "Parametric Primitive Types"
msgstr "ãã©ã¡ããªãã¯ããªããã£ãå"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1001
msgid ""
"Primitive types can also be declared parametrically. For example, pointers are represented as primitive types which would be declared in "
"Julia like this:"
msgstr ""
"ããªããã£ã°åã«ããã©ã¡ã¼ã¿ãã¤ãã¦å®£è¨ãããã¨ãã§ãã¾ããä¾ãã°ããã¤ã³ã¿ã¯ããªããã£ãåã¨ãã¦è¡¨ç¾ãã§ããJuliaã§ã¯ä»¥ä¸ã®ããã«å®£è¨ãã¾"
"ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1002
#, no-wrap
msgid ""
"# 32-bit system:\n"
"primitive type Ptr{T} 32 end\n"
"\n"
"# 64-bit system:\n"
"primitive type Ptr{T} 64 end\n"
msgstr ""
"# 32-bit system:\n"
"primitive type Ptr{T} 32 end\n"
"\n"
"# 64-bit system:\n"
"primitive type Ptr{T} 64 end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1016
msgid ""
"The slightly odd feature of these declarations as compared to typical parametric composite types, is that the type parameter `T` is not used "
"in the definition of the type itself -- it is just an abstract tag, essentially defining an entire family of types with identical structure, "
"differentiated only by their type parameter. Thus, `Ptr{Float64}` and `Ptr{Int64}` are distinct types, even though they have identical "
"representations. And of course, all specific pointer types are subtypes of the umbrella [`Ptr`](@ref) type:"
msgstr ""
"ä¸è¬çãªãã©ã¡ããªãã¯è¤ååã¨ã¯æ¯ã¹ã¦ããããã®å®£è¨ã«ã¯å°ãå¤ãªç¹å¾´ãããã¾ããããã¯ãåãã©ã¡ã¼ã¿`T`ããã®åèªä½ã®å®ç¾©ã®ä¸­ã§ä½¿ããã¦ããªã"
"ã¨ããã¨ã§ãããã©ã¡ã¼ã¿ã¯åãªãæ½è±¡çãªã¿ã°ã§ãããå¨ãåä¸ã®æ§é ã§ããåãã¡ããªã¼å¨ä½ãæ¬è³ªçã«å®ç¾©ãã¾ãããã®åãã¡ããªã¼ã®ããããã¯ã"
"åãã©ã¡ã¼ã¿ã®ã¿ã§å·®å¥åããã¦ãã¾ãããã®ããã`Ptr{Float64}` ã¨ `Ptr{Int64}` ã¯ãã¾ã£ããåãè¡¨ç¾ã§ãã£ã¦ãåã¨ãã¦ã¯ç°ãªãã¾ããããã¦ãã¡"
"ãããå¨ã¦ã®åå¥ãã¤ã³ã¿åã¯ãåæ¬å[`Ptr`](@ref)ã®ãµãã¿ã¤ãã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1017
#, no-wrap
msgid ""
"julia> Ptr{Float64} <: Ptr\n"
"true\n"
"\n"
"julia> Ptr{Int64} <: Ptr\n"
"true\n"
msgstr ""
"julia> Ptr{Float64} <: Ptr\n"
"true\n"
"\n"
"julia> Ptr{Int64} <: Ptr\n"
"true\n"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:1025
#, no-wrap
msgid "UnionAll Types"
msgstr "[å¨åä½µå](@id UnionAll-Types)"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1032
msgid ""
"We have said that a parametric type like `Ptr` acts as a supertype of all its instances (`Ptr{Int64}` etc.). How does this work? `Ptr` "
"itself cannot be a normal data type, since without knowing the type of the referenced data the type clearly cannot be used for memory "
"operations.  The answer is that `Ptr` (or other parametric types like `Array`) is a different kind of type called a [`UnionAll`](@ref) type. "
"Such a type expresses the *iterated union* of types for all values of some parameter."
msgstr ""
"ä¸è¿°ã®ããã«ã`Ptr` ã®ãããªãã©ã¡ããªãã¯åã¯ããã¹ã¦ã®ã¤ã³ã¹ã¿ã³ã¹ (`Ptr{Int64}` ãªã©) ã®ã¹ã¼ãã¼ã¿ã¤ãã¨ãã¦æ©è½ãã¾ãããã®å·ä½çãªæ¯ãè"
"ãã¯ã©ã®ãããªãã®ã§ãããã? `Ptr` èªä½ã¯ãéå¸¸ã®ãã¼ã¿åã§ã¯ããã¾ãããã¨ããã®ããåç§ããããã¼ã¿ã®åãç¥ããªããã°ãæããã«ãã®åãã¡"
"ã¢ãªæä½ã«ä½¿ç¨ã§ããªãããã§ããç­ãã¯ã`Ptr` (ã¾ãã¯`Array`ã®ãããªä»ã®ãã©ã¡ããªãã¯å) ã¯ã[`å¨åä½µ`](@ref UnionAll-Types) åã¨å¼ã°ããç¨®"
"é¡ã®ç°ãªãåã§ãããã®åã¯ããããã©ã¡ã¼ã¿ã¼ããã¹ã¦ã®å¤ã«å¯¾ãã¦ãç¹°ãè¿ãåä½µãã *åå¾©å±ç¨ä½* ãè¡¨ç¾ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1039
msgid ""
"`UnionAll` types are usually written using the keyword `where`. For example `Ptr` could be more accurately written as `Ptr{T} where T`, "
"meaning all values whose type is `Ptr{T}` for some value of `T`. In this context, the parameter `T` is also often called a \"type variable\" "
"since it is like a variable that ranges over types.  Each `where` introduces a single type variable, so these expressions are nested for "
"types with multiple parameters, for example `Array{T,N} where N where T`."
msgstr ""
"å¨åä½µåã¯éå¸¸ãã­ã¼ã¯ã¼ã `where` ãä½¿ç¨ãã¦æ¸ããã¾ãããã¨ãã°ã`Ptr` ã¯ ããæ­£ç¢ºã«ã¯`Ptr{T} where T`ã¨æ¸ããã¨ãã§ãã¦ããã®æå³ã¯ããã"
"ã`T`ã¨ããå¤ã«ãã£ã¦`Ptr{T}` ã®ããã«ãããåããã¤å¤å¨ã¦ãã¨ãããã¨ã§ãããã®æèã§ã¯ããã©ã¡ã¼ã¿ `T` ã¯åã«ã¾ããå¤æ°ã®ãããªãã®ã§ã\"å"
"å¤æ°\" ã¨ãå¼ã°ãã¾ãã ããããã® `where` ã¯åä¸ã®åå¤æ°ãå°å¥ããã®ã§ããããã®å¼ã¯è¤æ°ã®ãã©ã¡ã¼ã¿ã¼ãæã¤å ´åãä¾ãã° `Array{T,N} where "
"N where T` ã®ããã«åã«å¯¾ãã¦ãã¹ããã¹ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1048
msgid ""
"The type application syntax `A{B,C}` requires `A` to be a `UnionAll` type, and first substitutes `B` for the outermost type variable in "
"`A`.  The result is expected to be another `UnionAll` type, into which `C` is then substituted.  So `A{B,C}` is equivalent to `A{B}{C}`.  "
"This explains why it is possible to partially instantiate a type, as in `Array{Float64}`: the first parameter value has been fixed, but the "
"second still ranges over all possible values.  Using explicit `where` syntax, any subset of parameters can be fixed. For example, the type "
"of all 1-dimensional arrays can be written as `Array{T,1} where T`."
msgstr ""
"åã®é©ç¨æ§æ `A{B,C}` ã§ã¯ `A` ã å¨åä½µåã«ããå¿è¦ãããã¾ããæåã« `A` ã®æãå¤å´ã®åå¤æ°ã `B` ã§ç½®ãæãã¾ãã ãã®çµæã¯å¥ã® å¨åä½µå"
"ã«ãªããã¨ãæ³å®ããã`C` ã«ç½®ãæãããã¾ãããã£ã¦ `A{B,C}` ã¯ `A{B}{C}` ã«ç¸å½ãã¾ãã ããã¯ã`Array{Float64}` ã®ããã«åãé¨åçã«ã¤ã³ã¹"
"ã¿ã³ã¹åãããã¨ãå¯è½ã§ããçç±ã®èª¬æã«ãªã£ã¦ãã¾ãã: æåã®ãã©ã¡ã¼ã¿ã¼å¤ã¯åºå®ããã¦ãã¾ããã2 çªç®ã®ãã©ã¡ã¼ã¿ã¼ã¯å¨ã¦ã®ã¨ãããå¤ã«ã¾"
"ããã£ã¦ããããã§ãã æç¤ºçãª `where` æ§æãä½¿ç¨ããã¨ãã©ããªãã©ã¡ã¼ã¿ã¼ã®ãµãã»ããã«ã§ãåºå®ã§ãã¾ãããã¨ãã°ããã¹ã¦ã® 1 æ¬¡åéåã®å"
"ã¯ã`Array{T,1} where T` ã¨æ¸ããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1058
#, no-wrap
msgid ""
"Type variables can be restricted with subtype relations.\n"
"`Array{T} where T<:Integer` refers to all arrays whose element type is some kind of\n"
"[`Integer`](@ref).\n"
"The syntax `Array{<:Integer}` is a convenient shorthand for `Array{T} where T<:Integer`.\n"
"Type variables can have both lower and upper bounds.\n"
"`Array{T} where Int<:T<:Number` refers to all arrays of [`Number`](@ref)s that are able to\n"
"contain `Int`s (since `T` must be at least as big as `Int`).\n"
"The syntax `where T>:Int` also works to specify only the lower bound of a type variable,\n"
"and `Array{>:Int}` is equivalent to `Array{T} where T>:Int`.\n"
msgstr ""
"åå¤æ°ã¯ããµãã¿ã¤ãã®é¢ä¿ãã¤ãã£ã¦å¶éãããã¨ãã§ãã¾ãã\n"
"`Array{T}  where T <: Integer` ã§ãè¦ç´ ã®åã [`Integer`](@ref )ã®ããããã§ããéåãã¹ã¦ãæãã¦ãã¾ãã\n"
"æ§æ `Array{<: Integer}` ã¯ã`Array{T} where  T<:Integer` ã®ä¾¿å©ãªç°¡ç¥è¡¨è¨ã§ãã\n"
"åå¤æ°ã¯ãä¸éã¨ä¸éã®ä¸¡æ¹ãæå®ãããã¨ãã§ãã¾ãã\n"
"`Array{T} where Int<:T<:Number` ã¯ã[`Number`](@ref) ã®éåã§`Int`ãå«ããã®å¨ã¦ãæãã¾ãã(`T` ã¯å°ãªãã¨ã `Int` ä»¥ä¸ã®å¤§ããã§ãªããã°ããã¾ãã)ãæ§æ `where T>:Int` ã¯ã¾ããåå¤æ°ã®ä¸éã®ã¿ãæå®ãã¦ãã¾ãã`Array{>:Int}`ã¯ã`Array{T} where T>:Int` ã¨åç­ã§ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1063
#, no-wrap
msgid ""
"Since `where` expressions nest, type variable bounds can refer to outer type variables.\n"
"For example `Tuple{T,Array{S}} where S<:AbstractArray{T} where T<:Real` refers to 2-tuples\n"
"whose first element is some [`Real`](@ref), and whose second element is an `Array` of any\n"
"kind of array whose element type contains the type of the first tuple element.\n"
msgstr ""
"`where` å¼ã¯å¥ãå­ã«ã§ããã®ã§ãåå¤æ°ã®å¢çã¯å¤å´ã®åå¤æ°ãåç§ã§ãã¾ãã\n"
"ãã¨ãã°ã`Tuple{T,Array{S}} where S<:AbstractArray{T} where T<:Real` ã¯ãæ¬¡ã®2è¦ç´ ã¿ãã«ãåç§ãã¾ã: \n"
"ç¬¬ä¸è¦ç´ ã¯ `Real` ã®ãããããç¬¬äºè¦ç´ ã¯ã åè¦ç´ ãç¬¬ä¸è¦ç´ ã¨åãåãè¦ç´ ã«æã¤éåã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1066
msgid ""
"The `where` keyword itself can be nested inside a more complex declaration. For example, consider the two types created by the following "
"declarations:"
msgstr ""
"`where` ã­ã¼ã¯ã¼ãèªä½ã¯ãããè¤éãªå®£è¨ã®åå´ã§å¥ãå­ã«ãããã¨ãã§ãã¾ãããã¨ãã°ãæ¬¡ã®å®£è¨ã«ãã£ã¦ä½æããã 2 ã¤ã®åã«ã¤ãã¦èãã¦ã¿ã¾"
"ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1067
#, no-wrap
msgid ""
"julia> const T1 = Array{Array{T,1} where T, 1}\n"
"Array{Array{T,1} where T,1}\n"
"\n"
"julia> const T2 = Array{Array{T,1}, 1} where T\n"
"Array{Array{T,1},1} where T\n"
msgstr ""
"julia> const T1 = Array{Array{T,1} where T, 1}\n"
"Array{Array{T,1} where T,1}\n"
"\n"
"julia> const T2 = Array{Array{T,1}, 1} where T\n"
"Array{Array{T,1},1} where T\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1079
#, no-wrap
msgid ""
"Type `T1` defines a 1-dimensional array of 1-dimensional arrays; each\n"
"of the inner arrays consists of objects of the same type, but this type may vary from one inner array to the next.\n"
"On the other hand, type `T2` defines a 1-dimensional array of 1-dimensional arrays all of whose inner arrays must have the\n"
"same type.  Note that `T2` is an abstract type, e.g., `Array{Array{Int,1},1} <: T2`, whereas `T1` is a concrete type. As a consequence, `T1` can be constructed with a zero-argument constructor `a=T1()` but `T2` cannot.\n"
msgstr ""
"å `T1` ã¯ã1 æ¬¡åéåãè¦ç´ ã¨ãã 1 æ¬¡åéåãå®ç¾©ãã¾ã:  åå´ã®éåã®ããã¯ `T` ã§è¡¨ããã¦ãã¾ãããåå´ã®éåã1ã¤æãåºãã¦ããã¨ãã®åè¦ç´ ã®åã¯åãã ã¨ãããã¨ã§ãã¾ãå¥ã®åå´ã®éåãåãåºãæ¥ãã¨ãããã®è¦ç´ ã¯å¥ã®åã®å ´åãããã¾ãã\n"
"ä¸æ¹ãå`T2`ã¯ãåé¨éåã®åå´ã®éåã®ãã¹ã¦ã 1 æ¬¡åéåã®æ¹ãç­ãã 1æ¬¡åéåã®1 æ¬¡åéåãå®ç¾©ãã¾ãã\n"
"`T2` ã¯æ½è±¡åã§ãããä¾ãã°`Array{Array{Int,1},1} <: T2` ã§ããã®ã«å¯¾ãã¦ã`T1` ã¯å·è±¡åã§ãããã®çµæã`T1` ã¯ã¼ã­å¼æ°ã³ã³ã¹ãã©ã¯ã¿ `a=T1()` ã§æ§ç¯ã§ãã¾ããã`T2` ã§ã¯ã§ãã¾ããã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1082
msgid "There is a convenient syntax for naming such types, similar to the short form of function definition syntax:"
msgstr "é¢æ°å®ç¾©æ§æã®ç­ãå½¢å¼ã¨åæ§ã«ããã®ãããªåã«ååãä»ããä¾¿å©ãªæ§æãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1083
#, no-wrap
msgid "Vector{T} = Array{T,1}\n"
msgstr "Vector{T} = Array{T,1}\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1094
msgid ""
"This is equivalent to `const Vector = Array{T,1} where T`.  Writing `Vector{Float64}` is equivalent to writing `Array{Float64,1}`, and the "
"umbrella type `Vector` has as instances all `Array` objects where the second parameter -- the number of array dimensions -- is 1, regardless "
"of what the element type is. In languages where parametric types must always be specified in full, this is not especially helpful, but in "
"Julia, this allows one to write just `Vector` for the abstract type including all one-dimensional dense arrays of any element type."
msgstr ""
"ããã¯`const Vector = éå{T,1} T`ã¨åç­ã§ãã `Vector{Float64}` ã®æ¸ãè¾¼ã¿ã¯ `Array{Float64,1}` ãæ¸ãã®ã¨åãã§ãåæ¬åã® `Vector` ã¯ãè¦ç´ "
"ã®åã«é¢ä¿ãªãã2 çªç®ã®ãã©ã¡ã¼ã¿ã¼ (éåãã£ã¡ã³ã·ã§ã³ã®æ°) ã 1 ã§ãããã¹ã¦ã® `Array` ãªãã¸ã§ã¯ããã¤ã³ã¹ã¿ã³ã¹ã¨ãã¦æã¡ã¾ãããã©ã¡ã"
"ãªãã¯åãå¸¸ã«å®å¨ã«æå®ããå¿è¦ãããè¨èªã§ã¯ãããã¯ç¹ã«å½¹ã«ç«ã¡ã¾ããããJulia ã§ã¯ã`Vector` ã¨æ¸ãã ãã§ãä»»æã®è¦ç´ åã®ãã¹ã¦ã® 1 æ¬¡å"
"ã®å¯ãªéåãå«ãæ½è±¡åãè¡¨ç¾ãããã¨ãã§ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:1095
#, no-wrap
msgid "Type Aliases"
msgstr "åã¨ã¤ãªã¢ã¹"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1101
msgid ""
"Sometimes it is convenient to introduce a new name for an already expressible type.  This can be done with a simple assignment statement.  "
"For example, `UInt` is aliased to either [`UInt32`](@ref) or [`UInt64`](@ref) as is appropriate for the size of pointers on the system:"
msgstr ""
"æ¢ã«è¡¨ç¾å¯è½ãªåã«æ°ããååãå°å¥ããã¨ä¾¿å©ãªå ´åãããã¾ãã ããã¯ãåç´ãªä»£å¥æã§è¡ããã¨ãã§ãã¾ãã ãã¨ãã°ã`UInt` ã¯ãã·ã¹ãã ä¸ã®ã"
"ã¤ã³ã¿ã¼ã®ãµã¤ãºã«é©ãã [`UInt32`](@ref) ã¾ãã¯ [`UInt64`](@ref) ã®ããããã«å¥åã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1102
#, no-wrap
msgid ""
"# 32-bit system:\n"
"julia> UInt\n"
"UInt32\n"
"\n"
"# 64-bit system:\n"
"julia> UInt\n"
"UInt64\n"
msgstr ""
"# 32-bit system:\n"
"julia> UInt\n"
"UInt32\n"
"\n"
"# 64-bit system:\n"
"julia> UInt\n"
"UInt64\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1113
msgid "This is accomplished via the following code in `base/boot.jl`:"
msgstr "ããã¯`base/boot.jl`ã®ä»¥ä¸ã®ã³ã¼ãã§å®ç¾ããã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1114
#, no-wrap
msgid ""
"if Int === Int64\n"
"    const UInt = UInt64\n"
"else\n"
"    const UInt = UInt32\n"
"end\n"
msgstr ""
"if Int === Int64\n"
"    const UInt = UInt64\n"
"else\n"
"    const UInt = UInt32\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1124
msgid ""
"Of course, this depends on what `Int` is aliased to -- but that is predefined to be the correct type -- either [`Int32`](@ref) or [`Int64`]"
"(@ref)."
msgstr ""
"ãã¡ãããããã¯ `Int` ã[`Int32`](@ref)ã¾ãã¯ [`Int64`](@ref)) ã®ã©ã¡ãã®å¥åãªã®ãã§å¤ããã¾ããããã®å¥åã¯æ­£ããæ¹ã«ãªãããäºåã«å®ç¾©ã"
"ãã¦ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1129
msgid ""
"(Note that unlike `Int`, `Float` does not exist as a type alias for a specific sized [`AbstractFloat`](@ref). Unlike with integer registers, "
"where the size of `Int` reflects the size of a native pointer on that machine, the floating point register sizes are specified by the "
"IEEE-754 standard.)"
msgstr ""
"(`Int` ã¨ã¯ç°ãªãã`Float` ã¯ç¹å®ã®ãµã¤ãºã® [`AbstractFloat`](@ref)ã®åã®å¥åãå­å¨ããªããã¨ã«æ³¨æãã¦ãã ããã`Int` ã®ãµã¤ãºããã®ãã·ã³ä¸"
"ã®ãã¤ãã£ã ãã¤ã³ã¿ã¼ã®ãµã¤ãºãåæ ããæ´æ°ã¬ã¸ã¹ã¿ã¨ã¯ç°ãªããæµ®åå°æ°ç¹ã¬ã¸ã¹ã¿ ã®ãµã¤ãºã¯ IEEE-754 æ¨æºã§è¦å®ããã¦ãã¾ãã)"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:1130
#, no-wrap
msgid "Operations on Types"
msgstr "åã«å¯¾ããæ¼ç®"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1136
#, no-wrap
msgid ""
"Since types in Julia are themselves objects, ordinary functions can operate on them. Some functions\n"
"that are particularly useful for working with or exploring types have already been introduced,\n"
"such as the `<:` operator, which indicates whether its left hand operand is a subtype of its right\n"
"hand operand.\n"
msgstr ""
"Julia ã®åã¯ããèªä½ããªãã¸ã§ã¯ãã§ãããããéå¸¸ã®é¢æ°ãä½ç¨ããããã¾ãã\n"
"åã®æä½ãæ¢ç´¢ã«ç¹ã«å½¹ç«ã¤é¢æ°ãæ¢ã«å°å¥ããã¦ãã¾ãã\n"
"`<:` æ¼ç®å­ãªã©ã¯ãå·¦æã®ãªãã©ã³ãããå³å´ã®ãªãã©ã³ãã®ãµãã¿ã¤ãã§ãããã©ãããç¤ºãæ¼ç®å­ã§ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1138
msgid "The [`isa`](@ref) function tests if an object is of a given type and returns true or false:"
msgstr "[`isa`](@ref) é¢æ°ã¯ããªãã¸ã§ã¯ããæå®ãããåã§ããããæ¤æ»ããçå½å¤ãè¿ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1139
#, no-wrap
msgid ""
"julia> isa(1, Int)\n"
"true\n"
"\n"
"julia> isa(1, AbstractFloat)\n"
"false\n"
msgstr ""
"julia> isa(1, Int)\n"
"true\n"
"\n"
"julia> isa(1, AbstractFloat)\n"
"false\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1150
msgid ""
"The [`typeof`](@ref) function, already used throughout the manual in examples, returns the type of its argument. Since, as noted above, "
"types are objects, they also have types, and we can ask what their types are:"
msgstr ""
"[`typeof`](@ref) é¢æ°ã¯ããã§ã«ãã®ããã¥ã¢ã«ãéãã¦ä½¿ããã¦ãã¾ãããå¼æ°ã§ä¸ãããããªãã¸ã§ã¯ãã®åãè¿ãã¾ããåè¿°ã®ããã«ãåã¯ãªãã¸ã§"
"ã¯ãã§ãããããåãåãæã¡ã`typeof` ã®å¼æ°ã¨ãã¦åãä¸ãããï½ã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1151
#, no-wrap
msgid ""
"julia> typeof(Rational{Int})\n"
"DataType\n"
"\n"
"julia> typeof(Union{Real,String})\n"
"Union\n"
msgstr ""
"julia> typeof(Rational{Int})\n"
"DataType\n"
"\n"
"julia> typeof(Union{Real,String})\n"
"Union\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1161
msgid ""
"What if we repeat the process? What is the type of a type of a type? As it happens, types are all composite values and thus all have a type "
"of `DataType`:"
msgstr ""
"ãã®æä½ããç¹°ãè¿ãããã©ããªãã§ãããã? åã®åã®åã¯ä½ã§ããã? ãã§ã«è¦ãããã«ãåã¯ãã¹ã¦è¤ååã®å¤ãªã®ã§ããã¹ã¦`DataType`åã«ãªãã¾"
"ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1162
#, no-wrap
msgid ""
"julia> typeof(DataType)\n"
"DataType\n"
"\n"
"julia> typeof(Union)\n"
"DataType\n"
msgstr ""
"julia> typeof(DataType)\n"
"DataType\n"
"\n"
"julia> typeof(Union)\n"
"DataType\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1171
msgid "`DataType` is its own type."
msgstr "`DataType`ã¯èªèº«ã®åã§ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1174
msgid ""
"Another operation that applies to some types is [`supertype`](@ref), which reveals a type's supertype. Only declared types (`DataType`) have "
"unambiguous supertypes:"
msgstr ""
"ä¸é¨ã®åã«é©ç¨ãããã¨ã®ããããã 1 ã¤ã®æä½ã¯[`supertype`](@ref)ã§ããå¼æ°ã®åã®ã¹ã¼ãã¼ã¿ã¤ããæããã«ãã¾ããå®£è¨å (`DataType` ) ã®ã¿"
"ããæç¢ºãªã¹ã¼ãã¼ã¿ã¤ããæã£ã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1175
#, no-wrap
msgid ""
"julia> supertype(Float64)\n"
"AbstractFloat\n"
"\n"
"julia> supertype(Number)\n"
"Any\n"
"\n"
"julia> supertype(AbstractString)\n"
"Any\n"
"\n"
"julia> supertype(Any)\n"
"Any\n"
msgstr ""
"julia> supertype(Float64)\n"
"AbstractFloat\n"
"\n"
"julia> supertype(Number)\n"
"Any\n"
"\n"
"julia> supertype(AbstractString)\n"
"Any\n"
"\n"
"julia> supertype(Any)\n"
"Any\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1191
msgid "If you apply [`supertype`](@ref) to other type objects (or non-type objects), a [`MethodError`](@ref)  is raised:"
msgstr "[`supertype`](@ref)ãä»ã®åãªãã¸ã§ã¯ã(ã¾ãã¯åã§ã¯ãªããªãã¸ã§ã¯ã)ã«é©ç¨ããã¨ã[`MethodError`](@ref)ãçºçãã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/types.md:1192
#, no-wrap
msgid "jldoctest; filter = r\"Closest candidates.*\"s"
msgstr "jldoctest; filter = r\"Closest candidates.*\"s"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1192
#, no-wrap
msgid ""
"julia> supertype(Union{Float64,Int64})\n"
"ERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})\n"
"Closest candidates are:\n"
"  supertype(!Matched::DataType) at operators.jl:42\n"
"  supertype(!Matched::UnionAll) at operators.jl:47\n"
msgstr ""
"julia> supertype(Union{Float64,Int64})\n"
"ERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})\n"
"Closest candidates are:\n"
"  supertype(!Matched::DataType) at operators.jl:42\n"
"  supertype(!Matched::UnionAll) at operators.jl:47\n"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:1200
#, no-wrap
msgid "[Custom pretty-printing](@id man-custom-pretty-printing)"
msgstr "[ç¬èªã®æ´å½¢è¡¨ç¤º](@id man-custom-pretty-printing)"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1205
msgid ""
"Often, one wants to customize how instances of a type are displayed.  This is accomplished by overloading the [`show`](@ref) function.  For "
"example, suppose we define a type to represent complex numbers in polar form:"
msgstr ""
"åã®ã¤ã³ã¹ã¿ã³ã¹ã®è¡¨ç¤ºæ¹æ³ãã«ã¹ã¿ãã¤ãºããããå ´åãããããã¾ããããã¯[`show`](@ref)é¢æ°ããªã¼ãã¼ã­ã¼ããããã¨ã«ãã£ã¦å®ç¾ããã¾ãã ã"
"ã¨ãã°ãæ¥µåº§æ¨å½¢å¼ã§è¤ç´ æ°ãè¡¨ãåãå®ç¾©ããã¨ãã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/types.md:1206 ext/julia/doc/src/manual/types.md:1228 ext/julia/doc/src/manual/types.md:1240
#: ext/julia/doc/src/manual/types.md:1247 ext/julia/doc/src/manual/types.md:1267 ext/julia/doc/src/manual/types.md:1276
#: ext/julia/doc/src/manual/types.md:1291 ext/julia/doc/src/manual/types.md:1306 ext/julia/doc/src/manual/types.md:1326
#: ext/julia/doc/src/manual/types.md:1340 ext/julia/doc/src/manual/types.md:1353
#, no-wrap
msgid "jldoctest polartype"
msgstr "jldoctest polartype"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1206
#, no-wrap
msgid ""
"julia> struct Polar{T<:Real} <: Number\n"
"           r::T\n"
"           Î::T\n"
"       end\n"
"\n"
"julia> Polar(r::Real,Î::Real) = Polar(promote(r,Î)...)\n"
"Polar\n"
msgstr ""
"julia> struct Polar{T<:Real} <: Number\n"
"           r::T\n"
"           Î::T\n"
"       end\n"
"\n"
"julia> Polar(r::Real,Î::Real) = Polar(promote(r,Î)...)\n"
"Polar\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1223
msgid ""
"Here, we've added a custom constructor function so that it can take arguments of different [`Real`](@ref) types and promote them to a common "
"type (see [Constructors](@ref man-constructors)  and [Conversion and Promotion](@ref conversion-and-promotion)).  (Of course, we would have "
"to define lots of other methods, too, to make it act like a [`Number`](@ref), e.g. `+`, `*`, `one`, `zero`, promotion rules and so on.) By "
"default, instances of this type display rather simply, with information about the type name and the field values, as e.g. `Polar{Float64}"
"(3.0,4.0)`."
msgstr ""
"ããã§ã¯ãç°ãªã [`Real`](@ref) åã®å¼æ°ãåãåããããããå±éã®åã«ææ ¼ã§ããããã«ã«ã¹ã¿ã  ã³ã³ã¹ãã©ã¯ã¿ã¼é¢æ°ãè¿½å ãã¾ãã ([ã³ã³ã¹ã"
"ã©ã¯ã¿ã¼](@ref man-constructors)ã¨[å¤æã¨ææ ¼](@ref conversion-and-promotion)ãåç§)ã (ãã¡ããã[`Number`](@ref) åã¨åãç¨ã«åä½ããããã"
"ã«ã¯ãä»ã®å¤ãã®ã¡ã½ãããå®ç¾©ããå¿è¦ãããã§ããããä¾ãã°ã`+`ã`*`ã`one`ã`zero`ãææ ¼ã®ã«ã¼ã«ãªã©ãæ¢å®ã§ã¯ããã®åã®ã¤ã³ã¹ã¿ã³ã¹ã¯ãå"
"ã«ãååã¨ãã£ã¼ã«ãå¤ã«é¢ããæå ±ã`Polar{Float64}(3.0,4.0))ã¨è¡¨ç¤ºãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1227
msgid ""
"If we want it to display instead as `3.0 * exp(4.0im)`, we would define the following method to print the object to a given output object "
"`io` (representing a file, terminal, buffer, etcetera; see [Networking and Streams](@ref)):"
msgstr ""
"ä»£ããã« `3.0 * exp(4.0im)` ã¨ãã¦è¡¨ç¤ºãããå ´åã¯ãç¹å®ã®åºåãªãã¸ã§ã¯ã `io`(ãã¡ã¤ã«ãç«¯æ«ããããã¡ãªã©ãè¡¨ãã¾ãã [ãããã¯ã¼ã¯ã¨ã¹ã"
"ãªã¼ã ](@ref networking-and-streams)ãåç§) ã«ãªãã¸ã§ã¯ããåºåããæ¬¡ã®ã¡ã½ãããå®ç¾©ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1228
#, no-wrap
msgid "julia> Base.show(io::IO, z::Polar) = print(io, z.r, \" * exp(\", z.Î, \"im)\")\n"
msgstr "julia> Base.show(io::IO, z::Polar) = print(io, z.r, \" * exp(\", z.Î, \"im)\")\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1239
msgid ""
"More fine-grained control over display of `Polar` objects is possible. In particular, sometimes one wants both a verbose multi-line printing "
"format, used for displaying a single object in the REPL and other interactive environments, and also a more compact single-line format used "
"for [`print`](@ref) or for displaying the object as part of another object (e.g. in an array). Although by default the `show(io, z)` "
"function is called in both cases, you can define a *different* multi-line format for displaying an object by overloading a three-argument "
"form of `show` that takes the `text/plain` MIME type as its second argument (see [Multimedia I/O](@ref)), for example:"
msgstr ""
"`Polar`ãªãã¸ã§ã¯ãã®è¡¨ç¤ºãããç´°ããå¶å¾¡ãããã¨ãã§ãã¾ããç¹ã«ãREPL ãªã©ã®å¯¾è©±åç°å¢ã§åä¸ã®ãªãã¸ã§ã¯ããè¡¨ç¤ºããã®ã«ä½¿ç¨ãããåé·ãªè¤"
"æ°è¡å°å·å½¢å¼ã¨ããªãã¸ã§ã¯ããå¥ã®(éåãªã©ã®)ãªãã¸ã§ã¯ãã®ä¸é¨ã¨ãã¦[`print`](@ref) ããã·ã³ãã«ãªåä¸è¡å½¢å¼ ã®ä¸¡æ¹ãå¿è¦ãªå ´åãããã¾ãã"
"ããã©ã«ãã§ã¯ `show(io,z)` é¢æ°ãã©ã¡ãã®å ´åãå¼ã³åºããã¾ãããã¦ã¼ã¶ã¼å®ç¾©ã® *å¥ã®* è¤æ°å½¢å¼ã§è¡¨ç¤ºããããã«ã¯ã3å¼æ°ãã¨ã`show`é¢æ°ã§ã"
"2çªãã®å¼æ°ã« `text/plain` MIME ã¿ã¤ã ([Multimedia I/O](@ref)åç§)ãã¨ããã®ããªã¼ãã¼ã­ã¼ããã¾ããä¾ãã°:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1240
#, no-wrap
msgid ""
"julia> Base.show(io::IO, ::MIME\"text/plain\", z::Polar{T}) where{T} =\n"
"           print(io, \"Polar{$T} complex number:\\n   \", z)\n"
msgstr ""
"julia> Base.show(io::IO, ::MIME\"text/plain\", z::Polar{T}) where{T} =\n"
"           print(io, \"Polar{$T} complex number:\\n   \", z)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1246
msgid "(Note that `print(..., z)` here will call the 2-argument `show(io, z)` method.) This results in:"
msgstr "(ããã§ `print(...,z)` ã¯ 2 å¼æ° ã®`show(io,z)` ã¡ã½ãããå¼ã³åºããã¨ã«æ³¨æã) ãã®çµæã¯ãä¸è¨ã®ã¨ããã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1247
#, no-wrap
msgid ""
"julia> Polar(3, 4.0)\n"
"Polar{Float64} complex number:\n"
"   3.0 * exp(4.0im)\n"
"\n"
"julia> [Polar(3, 4.0), Polar(4.0,5.3)]\n"
"2-element Array{Polar{Float64},1}:\n"
" 3.0 * exp(4.0im)\n"
" 4.0 * exp(5.3im)\n"
msgstr ""
"julia> Polar(3, 4.0)\n"
"Polar{Float64} complex number:\n"
"   3.0 * exp(4.0im)\n"
"\n"
"julia> [Polar(3, 4.0), Polar(4.0,5.3)]\n"
"2-element Array{Polar{Float64},1}:\n"
" 3.0 * exp(4.0im)\n"
" 4.0 * exp(5.3im)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1262
#, no-wrap
msgid ""
"where the single-line `show(io, z)` form is still used for an array of `Polar` values.   Technically,\n"
"the REPL calls `display(z)` to display the result of executing a line, which defaults to `show(stdout, MIME(\"text/plain\"), z)`,\n"
"which in turn defaults to `show(stdout, z)`, but you should *not* define new [`display`](@ref)\n"
"methods unless you are defining a new multimedia display handler (see [Multimedia I/O](@ref)).\n"
msgstr ""
"ããã§ãåä¸è¡ã® `show(io,z)` å½¢å¼ã¯`Polar` å¤ã®éåã«å¼ãç¶ãä½¿ç¨ããã¾ãã¦ãã¾ãã\n"
"æè¡çã«ã¯ REPL ã `display(z)` ãå¼ã³åºãã¦è¡ãå®è¡ããçµæãè¡¨ç¤ºãã¾ããè¤æ°è¡å°å·å½¢å¼ã§ã¯ã`show(stdout, MIME(\"text/plain\"), z)`  åä¸è¡å½¢å¼ã¯`show(stdout,z)` ãããã©ã«ãã«ãªãã¾ãã\n"
"ããããæ°ãããã«ãã¡ãã£ã¢è¡¨ç¤ºãã³ãã©ãå®ç¾©ããªãéãã¯([Multimedia I/O](@ref)ãåç§)ãæ°ãã [`display`](@ref)ã¡ã½ãããå®ç¾©ãã¹ãã§ã¯ããã¾ããã \n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1266
#, no-wrap
msgid ""
"Moreover, you can also define `show` methods for other MIME types in order to enable richer display\n"
"(HTML, images, etcetera) of objects in environments that support this (e.g. IJulia).   For example,\n"
"we can define formatted HTML display of `Polar` objects, with superscripts and italics, via:\n"
msgstr ""
"ããã«ãIJulia ãªã©ã®ç°å¢ã§ããªãã¸ã§ã¯ãã®ããè±ããªè¡¨ç¤º(HTMLãç»åãªã©)ãããããã«ãä»ã® MIME ã¿ã¤ãã® `show`ã¡ã½ãããå®ç¾©ãããã¨ãã§ãã¾ãã\n"
" ä¾ãã°ã`Polar`ãªãã¸ã§ã¯ãã«å¯¾ãã¦ãæ¸å¼ä»ãã®HTMLè¡¨ç¤ºãå®ç¾©ãã¦ãä¸ä»ãæå­ã¨æä½ãä½¿ãã«ã¯ä»¥ä¸ã®ããã«ãã¾ã:\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1267
#, no-wrap
msgid ""
"julia> Base.show(io::IO, ::MIME\"text/html\", z::Polar{T}) where {T} =\n"
"           println(io, \"<code>Polar{$T}</code> complex number: \",\n"
"                   z.r, \" <i>e</i><sup>\", z.Î, \" <i>i</i></sup>\")\n"
msgstr ""
"julia> Base.show(io::IO, ::MIME\"text/html\", z::Polar{T}) where {T} =\n"
"           println(io, \"<code>Polar{$T}</code> complex number: \",\n"
"                   z.r, \" <i>e</i><sup>\", z.Î, \" <i>i</i></sup>\")\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1275
msgid ""
"A `Polar` object will then display automatically using HTML in an environment that supports HTML display, but you can call `show` manually "
"to get HTML output if you want:"
msgstr ""
"`Polar`ãªãã¸ã§ã¯ãã¯ãHTML è¡¨ç¤ºããµãã¼ãããç°å¢ã§ã¯ã HTMLãä½¿ç¨ãã¦èªåçã«è¡¨ç¤ºããã¾ãããå¿è¦ã«å¿ãã¦æåã§ `show` ãå¼ã³åºãã¦ HTML åº"
"åãåå¾ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1276
#, no-wrap
msgid ""
"julia> show(stdout, \"text/html\", Polar(3.0,4.0))\n"
"<code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup>\n"
msgstr ""
"julia> show(stdout, \"text/html\", Polar(3.0,4.0))\n"
"<code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup>\n"

#. type: Code fence info string
#: ext/julia/doc/src/manual/types.md:1281
#, no-wrap
msgid "@raw html"
msgstr "@raw html"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1281
#, no-wrap
msgid "<p>An HTML renderer would display this as: <code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup></p>\n"
msgstr "<p>An HTML renderer would display this as: <code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup></p>\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1290
msgid ""
"As a rule of thumb, the single-line `show` method should print a valid Julia expression for creating the shown object.  When this `show` "
"method contains infix operators, such as the multiplication operator (`*`) in our single-line `show` method for `Polar` above, it may not "
"parse correctly when printed as part of another object.  To see this, consider the expression object (see [Program representation](@ref)) "
"which takes the square of a specific instance of our `Polar` type:"
msgstr ""
"çµé¨åã¨ãã¦ãåä¸è¡ã® `show` ã¡ã½ããã¯ãè¡¨ç¤ºããããªãã¸ã§ã¯ããä½æãããæå¹ãª Julia å¼ãè¡¨ç¤ºãã¹ãã§ããä¸è¨ã® `Polar` ã®åä¸è¡ã® "
"`show` ã¡ã½ããã«ä¹ç®æ¼ç®å­ (`*`) ãªã©ã®äºé æ¼ç®å­ãå«ã¾ãã¦ããå ´åãå¥ã®ãªãã¸ã§ã¯ãã®ä¸é¨ã¨ãã¦è¡¨ç¤ºããéã«ãæ­£ããè§£æãããªããã¨ããã"
"ã¾ãã ãããç¢ºèªããããã«ã`Polar` åã®å·ä½çãªã¤ã³ã¹ã¿ã³ã¹ã®äºä¹ã®å¼ãªãã¸ã§ã¯ã ([`ãã­ã°ã©ã ã®è¡¨ç¾`](@ref Program-representation)ãåç§)"
"ãèãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1291
#, no-wrap
msgid ""
"julia> a = Polar(3, 4.0)\n"
"Polar{Float64} complex number:\n"
"   3.0 * exp(4.0im)\n"
"\n"
"julia> print(:($a^2))\n"
"3.0 * exp(4.0im) ^ 2\n"
msgstr ""
"julia> a = Polar(3, 4.0)\n"
"Polar{Float64} complex number:\n"
"   3.0 * exp(4.0im)\n"
"\n"
"julia> print(:($a^2))\n"
"3.0 * exp(4.0im) ^ 2\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1305
msgid ""
"Because the operator `^` has higher precedence than `*` (see [Operator Precedence and Associativity](@ref)), this output does not faithfully "
"represent the expression `a ^ 2` which should be equal to `(3.0 * exp(4.0im)) ^ 2`.  To solve this issue, we must make a custom method for "
"`Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)`, which is called internally by the expression object when printing:"
msgstr ""
"æ¼ç®å­ `^` ã®åªåé ä½ã¯ `*` ãããé«ããã ([æ¼ç®å­ã®åªåé ä½ã¨çµåå](@ref operator-precedence-and-associativity)ãåç§)ããã®åºåã¯ `(3.0 "
"* exp(4.0im)) ^ 2` ã¨ç­ããã¯ãã®å¼ `a ^ 2` ãå¿ å®ã«è¡¨ç¤ºãã¾ããã ãã®åé¡ãè§£æ±ºããã«ã¯ãåºåæã«å¼ãªãã¸ã§ã¯ãã«ãã£ã¦åé¨çã«å¼ã³åºãã"
"ã `Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)`ã®ã«ã¹ã¿ã ã¡ã½ãããä½æããå¿è¦ãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1306
#, no-wrap
msgid ""
"julia> function Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)\n"
"           if Base.operator_precedence(:*) <= precedence\n"
"               print(io, \"(\")\n"
"               show(io, z)\n"
"               print(io, \")\")\n"
"           else\n"
"               show(io, z)\n"
"           end\n"
"       end\n"
"\n"
"julia> :($a^2)\n"
":((3.0 * exp(4.0im)) ^ 2)\n"
msgstr ""
"julia> function Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)\n"
"           if Base.operator_precedence(:*) <= precedence\n"
"               print(io, \"(\")\n"
"               show(io, z)\n"
"               print(io, \")\")\n"
"           else\n"
"               show(io, z)\n"
"           end\n"
"       end\n"
"\n"
"julia> :($a^2)\n"
":((3.0 * exp(4.0im)) ^ 2)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1325
msgid ""
"The method defined above adds parentheses around the call to `show` when the precedence of the calling operator is higher than or equal to "
"the precedence of multiplication.  This check allows expressions which parse correctly without the parentheses (such as `:($a + 2)` and `:"
"($a == 2)`) to omit them when printing:"
msgstr ""
"ä¸è¨ã§å®ç¾©ããã¡ã½ããã¯ãå¼ã³åºãåæ¼ç®å­ã®åªåé ä½ãä¹ç®ã®åªåé ä½ä»¥ä¸ã§ããå ´åã«ãæ¬å¼§ãè¿½å ãã¾ãã ãã®æ¤æ»ã«ãã£ã¦ãæ¬å¼§ãªãã§ãæ­£ãã"
"è§£æããå¼ (`:($a + 2)`ã`:($a =2)`ãªã©) ã§ã¯ãæ¬å¼§ãçç¥ãã¦è¡¨ç¤ºã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1326
#, no-wrap
msgid ""
"julia> :($a + 2)\n"
":(3.0 * exp(4.0im) + 2)\n"
"\n"
"julia> :($a == 2)\n"
":(3.0 * exp(4.0im) == 2)\n"
msgstr ""
"julia> :($a + 2)\n"
":(3.0 * exp(4.0im) + 2)\n"
"\n"
"julia> :($a == 2)\n"
":(3.0 * exp(4.0im) == 2)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1340
msgid ""
"In some cases, it is useful to adjust the behavior of `show` methods depending on the context. This can be achieved via the [`IOContext`]"
"(@ref) type, which allows passing contextual properties together with a wrapped IO stream.  For example, we can build a shorter "
"representation in our `show` method when the `:compact` property is set to `true`, falling back to the long representation if the property "
"is `false` or absent:"
msgstr ""
"å ´åã«ãã£ã¦ã¯ãã³ã³ãã­ã¹ãã«å¿ãã¦ `show` ã¡ã½ããã®åä½ãèª¿æ´ããã¨ä¾¿å©ã§ããããã¯[`IOContext`](@ref)åã§å®ç¾å¯è½ã§ããã©ããããã IO ã¹"
"ããªã¼ã ã¨å±ã«ã³ã³ãã­ã¹ããã­ããã£ãæ¸¡ããã¨ãã§ãã¾ãã ãã¨ãã°ã`:compact` ãã­ããã£ã `true` ã«è¨­å®ããã¦ããå ´åã¯ã`show` ã¡ã½ããã§"
"ç­ãè¡¨ç¾ãä½æãã`false` ã¾ãã¯æå®ãªãã ã¨ãé·ãè¡¨ç¾ã«ãªãã¨ãããããªãã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1340
#, no-wrap
msgid ""
"julia> function Base.show(io::IO, z::Polar)\n"
"           if get(io, :compact, false)\n"
"               print(io, z.r, \"â¯\", z.Î, \"im\")\n"
"           else\n"
"               print(io, z.r, \" * exp(\", z.Î, \"im)\")\n"
"           end\n"
"       end\n"
msgstr ""
"julia> function Base.show(io::IO, z::Polar)\n"
"           if get(io, :compact, false)\n"
"               print(io, z.r, \"â¯\", z.Î, \"im\")\n"
"           else\n"
"               print(io, z.r, \" * exp(\", z.Î, \"im)\")\n"
"           end\n"
"       end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1353
msgid ""
"This new compact representation will be used when the passed IO stream is an `IOContext` object with the `:compact` property set. In "
"particular, this is the case when printing arrays with multiple columns (where horizontal space is limited):"
msgstr ""
"ãã®æ°ããç°¡æ½ãªè¡¨ç¾ã¯ãæ¸¡ããã IO ã¹ããªã¼ã ã `:compact` ãã­ããã£ ã»ãããæã¤ `IOContext` ãªãã¸ã§ã¯ãã§ããå ´åã«ä½¿ç¨ããã¾ããç¹ã«ã"
"æ°´å¹³æ¹åã®å¹ãå¶éããã¦ãã¦ãéåãä½æ®µãã§è¡¨ç¤ºããå ´åãªã©ã«å½¹ç«ã¡ã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1353
#, no-wrap
msgid ""
"julia> show(IOContext(stdout, :compact=>true), Polar(3, 4.0))\n"
"3.0â¯4.0im\n"
"\n"
"julia> [Polar(3, 4.0) Polar(4.0,5.3)]\n"
"1Ã2 Array{Polar{Float64},2}:\n"
" 3.0â¯4.0im  4.0â¯5.3im\n"
msgstr ""
"julia> show(IOContext(stdout, :compact=>true), Polar(3, 4.0))\n"
"3.0â¯4.0im\n"
"\n"
"julia> [Polar(3, 4.0) Polar(4.0,5.3)]\n"
"1Ã2 Array{Polar{Float64},2}:\n"
" 3.0â¯4.0im  4.0â¯5.3im\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1364
msgid "See the [`IOContext`](@ref) documentation for a list of common properties which can be used to adjust printing."
msgstr "è¡¨ç¤ºã®èª¿æ´ã«ä½¿ç¨ã§ããä¸è¬çãªãã­ããã£ã®ä¸è¦§ã«ã¤ãã¦ã¯ã[`IOContext`](@ref)ã®ãã­ã¥ã¡ã³ããåç§ãã¦ãã ããã"

#. type: Title ##
#: ext/julia/doc/src/manual/types.md:1365
#, no-wrap
msgid "\"Value types\""
msgstr "[\"å¤å\"](@id \"Value-types\")"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1371
msgid ""
"In Julia, you can't dispatch on a *value* such as `true` or `false`. However, you can dispatch on parametric types, and Julia allows you to "
"include \"plain bits\" values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters.  A common example is the "
"dimensionality parameter in `Array{T,N}`, where `T` is a type (e.g., [`Float64`](@ref)) but `N` is just an `Int`."
msgstr ""
"Julia ã§ã¯ã`true` ã `false`ãªã©ã®*å¤*ãé¢æ°ãã£ã¹ãããã«ä½¿ç¨ã§ãã¾ããããã ãããã©ã¡ããªãã¯åã«ãããã£ã¹ãããã¯å¯è½ã§ããã®åãã©ã¡ã¼"
"ã¿ã¨ãã¦ ãæ®éã®ãå¤ (åãã·ã³ãã«ãæ´æ°ãæµ®åå°æ°ç¹æ°ãã¿ãã«ãªã©) ãä½¿ããã¨ãã§ãã¾ãã ä¸è¬çãªä¾ã¯`Array{T,N}`ã®æ¬¡åãã©ã¡ã¼ã¿ã§ãã`T`"
"ã¯å (ä¾ãã°ã[`Float64`](@ref))ã§ããã`N`ã¯åãªã`Int`åã®å¤ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1376
msgid ""
"You can create your own custom types that take values as parameters, and use them to control dispatch of custom types. By way of "
"illustration of this idea, let's introduce a parametric type, `Val{x}`, and a constructor `Val(x) = Val{x}()`, which serves as a customary "
"way to exploit this technique for cases where you don't need a more elaborate hierarchy."
msgstr ""
"å¤ããã©ã¡ã¼ã¿ã¼ã¨ãã¦åãåãç¬èªã®åãä½æããããããä½¿ç¨ãã¦ãã£ã¹ããããå¶å¾¡ã§ãã¾ãããã®èãæ¹ãèª¬æããããã«ããã©ã¡ããªãã¯åã® "
"`Val{x}`ã¨ã³ã³ã¹ãã©ã¯ã¿ã¼ `Val(x) = Val{x}()`ãå°å¥ãã¾ããããæã®æ··ãã éå±¤ãå¿è¦ã¨ããªãã¨ãã«ã¯ããã®ææ³ã«ã¯ãã®åãæ£ç¨çã«ç¨ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1378
msgid "[`Val`](@ref) is defined as:"
msgstr "[`Val`](@ref)ã¯æ¬¡ã®ããã«å®ç¾©ãã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/types.md:1379 ext/julia/doc/src/manual/types.md:1391
#, no-wrap
msgid "jldoctest valtype"
msgstr "jldoctest valtype"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1379
#, no-wrap
msgid ""
"julia> struct Val{x}\n"
"       end\n"
"\n"
"julia> Val(x) = Val{x}()\n"
"Val\n"
msgstr ""
"julia> struct Val{x}\n"
"       end\n"
"\n"
"julia> Val(x) = Val{x}()\n"
"Val\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1390
#, no-wrap
msgid ""
"There is no more to the implementation of `Val` than this.  Some functions in Julia's standard\n"
"library accept `Val` instances as arguments, and you can also use it to write your own functions.\n"
" For example:\n"
msgstr ""
"`Val`ã®å®è£ã¯ããä»¥ä¸ããã¾ããã Julia ã®æ¨æºã©ã¤ãã©ãªã®é¢æ°ã«ã¯ã`Val`åã®ã¤ã³ã¹ã¿ã³ã¹ãå¼æ°ã«ã¨ããã®ããããç¬èªã®é¢æ°ãæ¸ãã¨ãã«ã `Val` åãå©ç¨ã§ãã¾ããä¾ãã°:\n"
" ä¾ãã°ï¼\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1391
#, no-wrap
msgid ""
"julia> firstlast(::Val{true}) = \"First\"\n"
"firstlast (generic function with 1 method)\n"
"\n"
"julia> firstlast(::Val{false}) = \"Last\"\n"
"firstlast (generic function with 2 methods)\n"
"\n"
"julia> firstlast(Val(true))\n"
"\"First\"\n"
"\n"
"julia> firstlast(Val(false))\n"
"\"Last\"\n"
msgstr ""
"julia> firstlast(::Val{true}) = \"First\"\n"
"firstlast (generic function with 1 method)\n"
"\n"
"julia> firstlast(::Val{false}) = \"Last\"\n"
"firstlast (generic function with 2 methods)\n"
"\n"
"julia> firstlast(Val(true))\n"
"\"First\"\n"
"\n"
"julia> firstlast(Val(false))\n"
"\"Last\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1407
msgid ""
"For consistency across Julia, the call site should always pass a `Val`*instance* rather than using a *type*, i.e., use `foo(Val(:bar))` "
"rather than `foo(Val{:bar})`."
msgstr ""
"Julia å¨ä½ã§ä¸è²«æ§ãä¿ã¤ããã«ãå¼ã³åºãå´ã§å¸¸ã« `Val`*type*ãä½¿ç¨ããã®ã§ã¯ãªãã`Val`ã®*ã¤ã³ã¹ã¿ã³ã¹*ãæ¸¡ãã¾ããã¤ã¾ããå¼ã³æ¹ã¯ã"
"`foo(Val{:bar})` ã§ã¯ãªã `foo(Val(:bar))` ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1412
#, no-wrap
msgid ""
"It's worth noting that it's extremely easy to mis-use parametric \"value\" types, including `Val`;\n"
"in unfavorable cases, you can easily end up making the performance of your code much *worse*.\n"
" In particular, you would never want to write actual code as illustrated above.  For more information\n"
"about the proper (and improper) uses of `Val`, please read the more extensive discussion in [the performance tips](@ref man-performance-tips).\n"
msgstr ""
"`Val`ãå«ããã©ã¡ããªãã¯ãªãå¤ãåã¯ãéå¸¸ã«èª¤ç¨ããããã®ã§æ³¨æãã¦ä¸ããã\n"
"ã²ã©ãã¨ãã¯ãã³ã¼ãã®ããã©ã¼ãã³ã¹ãå¤§å¹ã«*ä½ä¸*ãããå¯è½æ§ãããã¾ãã\n"
" ç¹ã«ãä¸è¨ã®ãããªã³ã¼ãããå®ç¨çã«ä½¿ãããã¨æããã¨ã¯ãªãã§ãããã\n"
"é©å(ããã³ä¸é©å)ãª`Val`ã®ä½¿ç¨æ¹æ³éè©³ç´°ã«ã¤ãã¦ã¯ã[ããã©ã¼ãã³ã¹ã»ãã£ããã¹](@ref man-performance-tips)ã®åºç¯ãªè­°è«ãèª­ãã§ãã ããã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/types.md:1413
msgid "[^1]: \"Small\" is defined by the `MAX_UNION_SPLITTING` constant, which is currently set to 4."
msgstr "[^1]: ããã§ããã\"å°æ°\" ã¯`MAX_UNION_SPLITTING`å®æ°ã§å®ç¾©ãããç¾å¨ 4 ã«è¨­å®ããã¦ãã¾ãã"

#. type: Title #
#: ext/julia/doc/src/manual/modules.md:1
#, no-wrap
msgid "[Modules](@id modules)"
msgstr "[ã¢ã¸ã¥ã¼ã«](@id modules)"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:8
msgid ""
"Modules in Julia are separate variable workspaces, i.e. they introduce a new global scope. They are delimited syntactically, inside `module "
"Name ... end`. Modules allow you to create top-level definitions (aka global variables) without worrying about name conflicts when your code "
"is used together with somebody else's. Within a module, you can control which names from other modules are visible (via importing), and "
"specify which of your names are intended to be public (via exporting)."
msgstr ""
"Julia ã®ã¢ã¸ã¥ã¼ã«ã¯ç¬ç«ããå¤æ°ã®ã¯ã¼ã¯ã¹ãã¼ã¹ã§ãããæ°ããã°ã­ã¼ãã« ã¹ã³ã¼ããå°å¥ãã¾ããã¢ã¸ã¥ã¼ã«ã¯ã`module Name ... end ` ã§æ§æç"
"ã«åºåããã¦ãã¾ãã ã¢ã¸ã¥ã¼ã«ãä½¿ç¨ããã¨ã(ã°ã­ã¼ãã«å¤æ°ã¨ãã¦ç¥ããã)æä¸ä½ã®å®ç¾©ãè¡ããã¨ãã§ãã¦ããã¤ãèªåã®ã³ã¼ãã¨ä»ã®ã¦ã¼ã¶ã¼ã®"
"ã³ã¼ãã¨ãä¸ç·ã«ä½¿ç¨ããéã«ååã®ç«¶åãå¿éããªãã¦ãã¿ã¾ããã¢ã¸ã¥ã¼ã«åã§ã¯ãä»ã®ã¢ã¸ã¥ã¼ã«ããåç§ããååã (ã¤ã³ãã¼ããã¦) å¶å¾¡ããèª"
"åã®ã¢ã¸ã¥ã¼ã«åã®ã©ã®ååã(ã¨ã¯ã¹ãã¼ãã§) ãããªãã¯ã«ããããæå®ãããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:11
msgid "The following example demonstrates the major features of modules. It is not meant to be run, but is shown for illustrative purposes:"
msgstr "æ¬¡ã®ä¾ã¯ãã¢ã¸ã¥ã¼ã«ã®ä¸»ãªæ©è½ãç¤ºãã¦ãã¾ããããã¯èª¬æç¨ã®ããã®ãã®ã§ãå®éã«å®è¡ããããã«æ¸ãããã³ã¼ãã§ã¯ããã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:12
#, no-wrap
msgid ""
"module MyModule\n"
"using Lib\n"
"\n"
"using BigLib: thing1, thing2\n"
"\n"
"import Base.show\n"
"\n"
"export MyType, foo\n"
"\n"
"struct MyType\n"
"    x\n"
"end\n"
"\n"
"bar(x) = 2x\n"
"foo(a::MyType) = bar(a.x) + 1\n"
"\n"
"show(io::IO, a::MyType) = print(io, \"MyType $(a.x)\")\n"
"end\n"
msgstr ""
"module MyModule\n"
"using Lib\n"
"\n"
"using BigLib: thing1, thing2\n"
"\n"
"import Base.show\n"
"\n"
"export MyType, foo\n"
"\n"
"struct MyType\n"
"    x\n"
"end\n"
"\n"
"bar(x) = 2x\n"
"foo(a::MyType) = bar(a.x) + 1\n"
"\n"
"show(io::IO, a::MyType) = print(io, \"MyType $(a.x)\")\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:35
msgid "Note that the style is not to indent the body of the module, since that would typically lead to whole files being indented."
msgstr ""
"è¡¨è¨ã¹ã¿ã¤ã«ä¸ã®æ³¨æç¹ã¯ãã¢ã¸ã¥ã¼ã«ã®æ¬ä½ãã¤ã³ãã³ãããªãã¨ãããã¨ã§ããããã¤ã³ãã³ãããã¨ãªãã¨ãéå¸¸ã¯ãã¡ã¤ã«å¨ä½ãã¤ã³ãã³ãããã"
"ãã¨ã«ãªã£ã¦ãã¾ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:38
msgid ""
"This module defines a type `MyType`, and two functions. Function `foo` and type `MyType` are exported, and so will be available for "
"importing into other modules.  Function `bar` is private to `MyModule`."
msgstr ""
"ãã®ã¢ã¸ã¥ã¼ã«ã§ã¯ãå `MyType` ã¨ 2 ã¤ã®é¢æ°ãå®ç¾©ããã¦ãã¾ããé¢æ° `foo` ã¨å `MyType` ãã¨ã¯ã¹ãã¼ããããä»ã®ã¢ã¸ã¥ã¼ã«ã¸ã®ã¤ã³ãã¼ãã«"
"ä½¿ç¨ã§ããããã«ãªãã¾ãã é¢æ° `bar` ã¯ `MyModule` åã§ã®ã¿ä½¿ç¨ãããã©ã¤ãã¼ããªé¢æ°ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:44
msgid ""
"The statement `using Lib` means that a module called `Lib` will be available for resolving names as needed. When a global variable is "
"encountered that has no definition in the current module, the system will search for it among variables exported by `Lib` and import it if "
"it is found there.  This means that all uses of that global within the current module will resolve to the definition of that variable in "
"`Lib`."
msgstr ""
"`using Lib`ã¨å®£è¨ãããã¨ã§ãå¿è¦ã«å¿ãã¦ `Lib` ã¨ããã¢ã¸ã¥ã¼ã«ãä½¿ç¨ãã¦ååãè§£æ±ºãã¾ããç¾å¨ã®ã¢ã¸ã¥ã¼ã«ã«å®ç¾©ããªãã°ã­ã¼ãã«å¤æ°ãæ¤åº"
"ãããã¨ãã·ã¹ãã ã¯`Lib` ã«ãã£ã¦ã¨ã¯ã¹ãã¼ããããå¤æ°ã®ä¸­ãããã®å¤æ°ãæ¤ç´¢ããããã«è¦ã¤ãã£ãå ´åã¯ã¤ã³ãã¼ããã¾ãã ã¤ã¾ããç¾å¨ã®ã¢"
"ã¸ã¥ã¼ã«åã§ã°ã­ã¼ãã«å¤æ°ãä½¿ãã¨å¨ã¦`Lib` åã®ååã®å¤æ°å®ç¾©ã«ãã£ã¦è§£æ±ºããããã¨ãæå³ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:48
msgid ""
"The statement `using BigLib: thing1, thing2` brings just the identifiers `thing1` and `thing2` into scope from module `BigLib`. If these "
"names refer to functions, adding methods to them will not be allowed (you may only \"use\" them, not extend them)."
msgstr ""
"`using BigLib: thing1, thing2` ã¨ãå®£è¨ã§ã`thing1` ã¨ `thing2` ã¨ããè­å¥å­ã `BigLib` ããç¾å¨ã®ã¹ã³ã¼ãã«æã¡è¾¼ã¾ããããããããã®åå"
"ããé¢æ°ãåç§ãããã®ãªãã°ãã¡ã½ããã®è¿½å ã¯è¨±ããã¾ãã(ã¡ã½ãããä½¿ç¨ããã ãã§ãæ¡å¼µã¯è¨±ãããªã)ã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:52
msgid ""
"The [`import`](@ref) keyword supports the same syntax as [`using`](@ref).  It does not add modules to be searched the way `using` does. "
"`import` also differs from `using` in that functions imported using `import` can be extended with new methods."
msgstr ""
"[`import`](@ref ) ã­ã¼ã¯ã¼ãã¯ [`using`](@ref ) ã¨åãæ§æããµãã¼ããã¾ãã`using`ã®ããã«ã¢ã¸ã¥ã¼ã«å¨ä½ãæ¤ç´¢å¯¾è±¡ã«è¿½å ãããã¨ã¯ã§ãã¾ã"
"ãã`import` ãä½¿ç¨ãã¦ã¤ã³ãã¼ããããé¢æ°ã¯æ°ããã¡ã½ããã§æ¡å¼µã§ããã¨ããç¹ã§ã`using` ã¨ã¯ç°ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:55
msgid ""
"In `MyModule` above we wanted to add a method to the standard [`show`](@ref) function, so we had to write `import Base.show`. Functions "
"whose names are only visible via `using` cannot be extended."
msgstr ""
"ä¸è¨ã®`MyModule`ã§ã¯ãæ¨æºã®[`show`](@ref )é¢æ°ã«ã¡ã½ãããè¿½å ãããã£ãã®ã§ã`import Base.show`ã¨æ¸ãå¿è¦ãæãã¾ãããååã `using` ãä»"
"ãã¦ã®ã¿åç§ã§ããé¢æ°ã¯æ¡å¼µã§ãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:59
msgid ""
"Once a variable is made visible via `using` or `import`, a module may not create its own variable with the same name. Imported variables are "
"read-only; assigning to a global variable always affects a variable owned by the current module, or else raises an error."
msgstr ""
"`using` ã¾ãã¯ `import` ãä½¿ç¨ãã¦å¤æ°ãä¸åº¦åç§ãããã¨ããã®å¤æ°ã¨åãååãæã¤å¤æ°ããã¢ã¸ã¥ã¼ã«åã«ç¬èªã«å®ç¾©ãããã¨ã¯ã§ããªããªãã¾"
"ããã¤ã³ãã¼ããããå¤æ°ã¯èª­ã¿åãå°ç¨ã§ããã°ã­ã¼ãã«å¤æ°ã«ä»£å¥ã¯ãå¸¸ã«ç¾å¨ã®ã¢ã¸ã¥ã¼ã«ãææããå¤æ°ã«å¯¾ãããã®ã§ããããã§ãªããã°ã¨ã©ã¼"
"ãçºçãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/modules.md:60
#, no-wrap
msgid "Summary of module usage"
msgstr "ã¢ã¸ã¥ã¼ã«ã®ä½¿ç¨æ³ã®ã¾ã¨ã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:64
msgid "To load a module, two main keywords can be used: `using` and `import`. To understand their differences, consider the following example:"
msgstr "ã¢ã¸ã¥ã¼ã«ãèª­ã¿è¾¼ãã«ã¯ã`using` ã¨ `import` ã®2ã¤ã®ä¸»è¦ã­ã¼ã¯ã¼ããå©ç¨ã§ãã¾ããä¸¡èã®éããçè§£ããã«ã¯ãæ¬¡ã®ä¾ãèãã¦ãã ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:65
#, no-wrap
msgid ""
"module MyModule\n"
"\n"
"export x, y\n"
"\n"
"x() = \"x\"\n"
"y() = \"y\"\n"
"p() = \"p\"\n"
"\n"
"end\n"
msgstr ""
"module MyModule\n"
"\n"
"export x, y\n"
"\n"
"x() = \"x\"\n"
"y() = \"y\"\n"
"p() = \"p\"\n"
"\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:80
msgid ""
"In this module we export the `x` and `y` functions (with the keyword `export`), and also have the non-exported function `p`. There are "
"several different ways to load the Module and its inner functions into the current workspace:"
msgstr ""
"ãã®ã¢ã¸ã¥ã¼ã«ã¯ãé¢æ° `x` ã¨ é¢æ° `y` ã(ã­ã¼ã¯ã¼ã `export`ãç¨ãã¦) ã¨ã¯ã¹ãã¼ãããããã¨ã¯å¥ã«ã¨ã¯ã¹ãã¼ãããã¦ããªãé¢æ° `p` ãå®ç¾©ã"
"ãã¦ãã¾ããã¢ã¸ã¥ã¼ã«ã¨ãã®åé¨é¢æ°ãç¾å¨ã®ã¯ã¼ã¯ã¹ãã¼ã¹ã«ã­ã¼ãããã«ã¯ãããã¤ãã®ç°ãªãæ¹æ³ãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:88
#, no-wrap
msgid ""
"| Import Command                  | What is brought into scope                                                      | Available for method extension              |\n"
"|:------------------------------- |:------------------------------------------------------------------------------- |:------------------------------------------- |\n"
"| `using MyModule`                | All `export`ed names (`x` and `y`), `MyModule.x`, `MyModule.y` and `MyModule.p` | `MyModule.x`, `MyModule.y` and `MyModule.p` |\n"
"| `using MyModule: x, p`          | `x` and `p`                                                                     | Â                                            |\n"
"| `import MyModule`               | `MyModule.x`, `MyModule.y` and `MyModule.p`                                     | `MyModule.x`, `MyModule.y` and `MyModule.p` |\n"
"| `import MyModule.x, MyModule.p` | `x` and `p`                                                                     | `x` and `p`                                 |\n"
"| `import MyModule: x, p`         | `x` and `p`                                                                     | `x` and `p`                                 |\n"
msgstr ""
"| ã¤ã³ãã¼ãããã³ãã³ã                  | ã¹ã³ã¼ãã«å°å¥ããããã®                                                      | ã¡ã½ããæ¡å¼µã«å©ç¨ã§ãããã®              |\n"
"|:------------------------------- |:------------------------------------------------------------------------------- |:------------------------------------------- |\n"
"| `using MyModule`                | All `export`ed names (`x` and `y`), `MyModule.x`, `MyModule.y` and `MyModule.p` | `MyModule.x`, `MyModule.y` and `MyModule.p` |\n"
"| `using MyModule: x, p`          | `x` and `p`                                                                     | Â                                            |\n"
"| `import MyModule`               | `MyModule.x`, `MyModule.y` and `MyModule.p`                                     | `MyModule.x`, `MyModule.y` and `MyModule.p` |\n"
"| `import MyModule.x, MyModule.p` | `x` and `p`                                                                     | `x` and `p`                                 |\n"
"| `import MyModule: x, p`         | `x` and `p`                                                                     | `x` and `p`                                 |\n"

#. type: Title ###
#: ext/julia/doc/src/manual/modules.md:89
#, no-wrap
msgid "Modules and files"
msgstr "ã¢ã¸ã¥ã¼ã«ã¨ãã¡ã¤ã«"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:93
msgid ""
"Files and file names are mostly unrelated to modules; modules are associated only with module expressions. One can have multiple files per "
"module, and multiple modules per file:"
msgstr ""
"ãã¡ã¤ã«ã¨ãã¡ã¤ã«åã¯ãã»ã¨ãã©ã¢ã¸ã¥ã¼ã«ã¨ã¯ç¡é¢ä¿ã§ããã¢ã¸ã¥ã¼ã«ã¯ã¢ã¸ã¥ã¼ã«å¼ã«ã®ã¿é¢é£ä»ãããã¦ãã¾ãã1 ã¤ã®ã¢ã¸ã¥ã¼ã«ãè¤æ°ã®ãã¡ã¤"
"ã«ãã¾ãããã¨ãã§ãã¾ãããè¤æ°ã®ã¢ã¸ã¥ã¼ã«ãåã1ã¤ã®ãã¡ã¤ã«ã«å®ç¾©ãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:94
#, no-wrap
msgid ""
"module Foo\n"
"\n"
"include(\"file1.jl\")\n"
"include(\"file2.jl\")\n"
"\n"
"end\n"
msgstr ""
"module Foo\n"
"\n"
"include(\"file1.jl\")\n"
"include(\"file2.jl\")\n"
"\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:106
msgid ""
"Including the same code in different modules provides mixin-like behavior. One could use this to run the same code with different base "
"definitions, for example testing code by running it with \"safe\" versions of some operators:"
msgstr ""
"ç°ãªãã¢ã¸ã¥ã¼ã«ã«åãã³ã¼ããå«ããã¨ãmixin ã®ãããªåä½ãæä¾ããã¾ãããããä½¿ç¨ãã¦ãç°ãªãåºæ¬å®ç¾©ã§åãã³ã¼ããå®è¡ã§ãã¾ããä¾ãã°ã"
"ãããå®è¡ãããã¨ã§ããå¦çããå®å¨ãã¼ã¸ã§ã³ãå®è¡ãã¦ã³ã¼ããæ¤æ»ãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:107
#, no-wrap
msgid ""
"module Normal\n"
"include(\"mycode.jl\")\n"
"end\n"
"\n"
"module Testing\n"
"include(\"safe_operators.jl\")\n"
"include(\"mycode.jl\")\n"
"end\n"
msgstr ""
"module Normal\n"
"include(\"mycode.jl\")\n"
"end\n"
"\n"
"module Testing\n"
"include(\"safe_operators.jl\")\n"
"include(\"mycode.jl\")\n"
"end\n"

#. type: Title ###
#: ext/julia/doc/src/manual/modules.md:118
#, no-wrap
msgid "Standard modules"
msgstr "æ¨æºã¢ã¸ã¥ã¼ã«"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:124
msgid ""
"There are three important standard modules: * [`Core`](@ref) contains all functionality \"built into\" the language.  * [`Base`](@ref) "
"contains basic functionality that is useful in almost all cases.  * [`Main`](@ref) is the top-level module and the current module, when "
"Julia is started."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/modules.md:125
#, no-wrap
msgid "Default top-level definitions and bare modules"
msgstr "ããã©ã«ãã®æä¸ä½å®ç¾©ã¨ãã¢ã¢ã¸ã¥ã¼ã«"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:130
msgid ""
"In addition to `using Base`, modules also automatically contain definitions of the [`eval`](@ref) and [`include`](@ref) functions, which "
"evaluate expressions/files within the global scope of that module."
msgstr ""
"`using Base`ã«å ãã¦ãã¢ã¸ã¥ã¼ã«ã«ã¯ [`eval`](@ref )é¢æ°ã¨ [`include`](@ref ) é¢æ°ã®å®ç¾©ãèªåçã«å«ã¾ãããã®ã¢ã¸ã¥ã¼ã«ã®ã°ã­ã¼ãã«ã¹ã³ã¼ã"
"åã®å¼ããã¡ã¤ã«ãè©ä¾¡ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:134
msgid ""
"If these default definitions are not wanted, modules can be defined using the keyword [`baremodule`](@ref)  instead (note: `Core` is still "
"imported, as per above). In terms of `baremodule`, a standard `module` looks like this:"
msgstr ""
"ãããã®ããã©ã«ãã®å®ç¾©ãä¸è¦ãªå ´åã¯ãä»£ããã«ã­ã¼ã¯ã¼ã `baremodule` ãä½¿ç¨ãã¦ã¢ã¸ã¥ã¼ã«ãå®ç¾©ã§ãã¾ã (æ³¨: `baremodule`ã­ã¼ã¯ã¼ããä½¿ã£"
"ã¦ã `Core` ã¯ã¤ã³ãã¼ãããã¾ã)ã`baremodule` ã®ä½¿ç¨ãã¨ããè¦³ç¹ãããæ¨æºçãªã¢ã¸ã¥ã¼ã«ã®åä½ãè¦ã¦ã¿ãã¨:"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:135
#, no-wrap
msgid ""
"baremodule Mod\n"
"\n"
"using Base\n"
"\n"
"eval(x) = Core.eval(Mod, x)\n"
"include(p) = Base.include(Mod, p)\n"
"\n"
"...\n"
"\n"
"end\n"
msgstr ""
"baremodule Mod\n"
"\n"
"using Base\n"
"\n"
"eval(x) = Core.eval(Mod, x)\n"
"include(p) = Base.include(Mod, p)\n"
"\n"
"...\n"
"\n"
"end\n"

#. type: Title ###
#: ext/julia/doc/src/manual/modules.md:148
#, no-wrap
msgid "Relative and absolute module paths"
msgstr "ç¸å¯¾ã¢ã¸ã¥ã¼ã«ãã¹ã¨çµ¶å¯¾ã¢ã¸ã¥ã¼ã«ãã¹"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:153
msgid ""
"Given the statement `using Foo`, the system consults an internal table of top-level modules to look for one named `Foo`. If the module does "
"not exist, the system attempts to `require(:Foo)`, which typically results in loading code from an installed package."
msgstr ""
"`using Foo` æãè¨è¿°ããã¦ããã¨ãã·ã¹ãã ã¯æä¸ä½ã¢ã¸ã¥ã¼ã«ã®åé¨ãã¼ãã«ãåç§ãã¦ `Foo` ã¨ããååã®ã¢ã¸ã¥ã¼ã«ãæ¢ãã¾ããã¢ã¸ã¥ã¼ã«ãå­å¨"
"ããªãå ´åãã·ã¹ãã ã¯ `require(:Foo)` ãè©¦ã¿ãéå¸¸ã¯ã¤ã³ã¹ãã¼ã«ãããããã±ã¼ã¸ããã³ã¼ããèª­ã¿è¾¼ã¿ã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:158
msgid ""
"However, some modules contain submodules, which means you sometimes need to access a non-top-level module. There are two ways to do this. "
"The first is to use an absolute path, for example `using Base.Sort`. The second is to use a relative path, which makes it easier to import "
"submodules of the current module or any of its enclosing modules:"
msgstr ""
"ããããä¸é¨ã®ã¢ã¸ã¥ã¼ã«ã«ã¯ãµãã¢ã¸ã¥ã¼ã«ãå«ããã®ããããæä¸ä½ä»¥å¤ã®(Mainããç´æ¥ã¢ã¯ã»ã¹ã§ããªã)ã¢ã¸ã¥ã¼ã«ã«ã¢ã¯ã»ã¹ããå¿è¦ãããå ´å"
"ãããã¾ãããããè¡ãã«ã¯ 2 ã¤ã®æ¹æ³ãããã¾ãã1 ã¤ç®ã¯ã`using Base.Sort` ãªã©ã®ããã«çµ¶å¯¾ãã¹ãä½¿ç¨ãããã¨ã§ãã2 ã¤ç®ã¯ç¸å¯¾ãã¹ãä½¿ç¨ã"
"ãæ¹æ³ã§ãç¾å¨ã®ã¢ã¸ã¥ã¼ã«ãããµãã¢ã¸ã¥ã¼ã«ãå«ãã¢ã¸ã¥ã¼ã«ããããµãã¢ã¸ã¥ã¼ã«ã®ã¤ã³ãã¼ããç°¡åã«ãããªãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:159
#, no-wrap
msgid ""
"module Parent\n"
"\n"
"module Utils\n"
"...\n"
"end\n"
"\n"
"using .Utils\n"
"\n"
"...\n"
"end\n"
msgstr ""
"module Parent\n"
"\n"
"module Utils\n"
"...\n"
"end\n"
"\n"
"using .Utils\n"
"\n"
"...\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:176
msgid ""
"Here module `Parent` contains a submodule `Utils`, and code in `Parent` wants the contents of `Utils` to be visible. This is done by "
"starting the `using` path with a period. Adding more leading periods moves up additional levels in the module hierarchy. For example "
"`using ..Utils` would look for `Utils` in `Parent`'s enclosing module rather than in `Parent` itself."
msgstr ""
"ããã§ã¯ã¢ã¸ã¥ã¼ã« `Parent` ã«ã¯ãµãã¢ã¸ã¥ã¼ã« `Utils` ãå«ã¾ãã¦ããã`Parent` ã®ã³ã¼ãã¯ `Utils` ã®åå®¹ãåç§ããå¿è¦ãããã¾ããããã¯ã"
"`using` å¯¾è±¡ã®ãã¹ãããªãªãããéå§ãããã¨ã«ãã£ã¦è¡ããã¾ããåé ­ã«ããã«ããä¸ã¤ããªãªããè¿½å ããã¨ãã¢ã¸ã¥ã¼ã«éå±¤ã®ã¬ãã«ãä¸ããã¾"
"ãããã¨ãã°ã`using ..Utils`ã¯`Parent`ã¢ã¸ã¥ã¼ã«èªä½ã§ã¯ãªããã¾ãããã«ãã®ä¸ã®`Parent`ã¢ã¸ã¥ã¼ã«ãå«ãã¢ã¸ã¥ã¼ã«éå±¤ã§ã`Utils` ãæ¢ãã¾"
"ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:178
msgid "Note that relative-import qualifiers are only valid in `using` and `import` statements."
msgstr "ç¸å¯¾ã¤ã³ãã¼ãä¿®é£¾å­ã¯`using` ã¹ãã¼ãã¡ã³ãã¨ `import` ã¹ãã¼ãã¡ã³ãã§ã®ã¿æå¹ã§ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/modules.md:179
#, no-wrap
msgid "Namespace miscellanea"
msgstr "ååç©ºéã«é¢ããéè¨"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:187
msgid ""
"If a name is qualified (e.g. `Base.sin`), then it can be accessed even if it is not exported.  This is often useful when debugging. It can "
"also have methods added to it by using the qualified name as the function name. However, due to syntactic ambiguities that arise, if you "
"wish to add methods to a function in a different module whose name contains only symbols, such as an operator, `Base.+` for example, you "
"must use `Base.:+` to refer to it. If the operator is more than one character in length you must surround it in brackets, such as: `Base.:"
"(==)`."
msgstr ""
"ååãä¿®é£¾ããã¦ããå ´å (ä¾: `Base.sin`) ã¯ãã¨ã¯ã¹ãã¼ãããã¦ããªãå ´åã§ãã¢ã¯ã»ã¹ã§ãã¾ãã ããã¯ãå¤ãã®å ´åããããã°æã«ä¾¿å©ã§ããä¿®"
"é£¾åãé¢æ°åã¨ãã¦ä½¿ç¨ãã¦ã¡ã½ãããè¿½å ãããã¨ãã§ãã¾ãããã ããæ§æã®ããã¾ãããçãããããå¥ã®ã¢ã¸ã¥ã¼ã«ã«å«ã¾ããé¢æ°ã§ãä¾ãã°æ¼ç®"
"å­`Base.+`ã®ããã«é¢æ°åãè¨å·ã®ã¿ã§æ§æããããã®ã«ã¡ã½ãããè¿½å ãããã¨ãã«ã¯ããã®é¢æ°ãåç§ããã®ã« `Base.:+` ãä½¿ç¨ãã¦ãã ãããæ¼ç®å­"
"ãè¤æ°æå­ã®å ´åã¯ãæ¬¡ã®ããã«æ¬å¼§ã§å²ãã§ãã ãã: `Base.:(==)`."

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:190
msgid ""
"Macro names are written with `@` in import and export statements, e.g. `import Mod.@mac`. Macros in other modules can be invoked as `Mod."
"@mac` or `@Mod.mac`."
msgstr ""
"ã¤ã³ãã¼ãããã³ã¨ã¯ã¹ãã¼ãæã®ä¸­ã§ããã¯ã­åã¯`@`ãä»ãã¦`import Mod.@mac`ã®ããã«æ¸ããã¾ããä»ã®ã¢ã¸ã¥ã¼ã«ã®ãã¯ã­ã¯`Mod.@mac` ã¾ãã¯ "
"`@Mod.mac` ã®ããã«ãã¦å¼ã³åºããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:193
msgid "The syntax `M.x = y` does not work to assign a global in another module; global assignment is always module-local."
msgstr ""
"æ§æ `M.x = y` ã¨ããæ§æã§ã¯ãå¥ã®ã¢ã¸ã¥ã¼ã«ã®ã°ã­ã¼ãã«å¤æ°ã«ä»£å¥ããããã¨ã¯ã§ãã¾ãããã°ã­ã¼ãã«å¤æ°ã®ä»£å¥ã¯å¸¸ã«ã­ã¼ã«ã«ãªã¢ã¸ã¥ã¼ã«ã§è¡"
"ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:196
msgid ""
"A variable name can be \"reserved\" without assigning to it by declaring it as `global x`.  This prevents name conflicts for globals "
"initialized after load time."
msgstr ""
"å¤æ°åã¯ã`global x` ã®ããã«æä¸ä½ã§å®£è¨ãããã¨ã§ãå¤æ°ã¸ã®ä»£å¥ãè¡ããã¨ç¡ããååãäºç´ãããã¨ãã§ãã¾ããããã«ãããã­ã¼ãå¾ã«åæåã"
"ããã°ã­ã¼ãã«å¤æ°åã®ç«¶åãé²ããã¨ãã§ãã¾ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/modules.md:197
#, no-wrap
msgid "Module initialization and precompilation"
msgstr "[ã¢ã¸ã¥ã¼ã«ã®åæåã¨ããªã³ã³ãã¤ã«](@id Module-initialization-and-precompilation)"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:202
msgid ""
"Large modules can take several seconds to load because executing all of the statements in a module often involves compiling a large amount "
"of code.  Julia creates precompiled caches of the module to reduce this time."
msgstr ""
"å¤§ããªã¢ã¸ã¥ã¼ã«ã®èª­ã¿è¾¼ã¿ã«ã¯æ°ç§ããããã¨ãããã¾ããã¢ã¸ã¥ã¼ã«åã®ãã¹ã¦ã®ã¹ãã¼ãã¡ã³ããå®è¡ããã«ã¯ãå¤ãã®å ´åãå¤§éã®ã³ã¼ããã³ã³ã"
"ã¤ã«ããå¿è¦ãããããã§ãã Julia ã¯ããã®æéãç­ç¸®ããããã«ãã¢ã¸ã¥ã¼ã«ã®äºåã³ã³ãã¤ã«æ¸ã¿ã­ã£ãã·ã¥ãã¡ã¤ã«ãä½æãã¦ããã¦ããã®æéã"
"ç­ç¸®ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:210
msgid ""
"The incremental precompiled module file are created and used automatically when using `import` or `using` to load a module.  This will cause "
"it to be automatically compiled the first time it is imported. Alternatively, you can manually call [`Base.compilecache(modulename)`](@ref). "
"The resulting cache files will be stored in `DEPOT_PATH[1]/compiled/`. Subsequently, the module is automatically recompiled upon `using` or "
"`import` whenever any of its dependencies change; dependencies are modules it imports, the Julia build, files it includes, or explicit "
"dependencies declared by [`include_dependency(path)`](@ref)  in the module file(s)."
msgstr ""
"ã¤ã³ã¯ãªã¡ã³ã¿ã«ããªã³ã³ãã¤ã«ãããã¢ã¸ã¥ã¼ã«ãã¡ã¤ã«ã¯ã`import` ã `using` ãä½¿ããã¦ã¢ã¸ã¥ã¼ã«ãã­ã¼ãããéã«èªåçã«ä½æããã¾ãããã"
"ã«ãããåãã¦ã¤ã³ãã¼ãããã¨ãã«èªåçã«ã³ã³ãã¤ã«ããã¾ããã¾ãã¯ãæåã§ [`Base.compilecache(Module Name)`](@ref )ã¨ãã¦ã³ã³ãã¤ã«ããã"
"ãã¨ãã§ãã¾ããå¾ãããã­ã£ãã·ã¥ãã¡ã¤ã«ã¯ã`DEPOT_PATH[1]/compiled/` ã«æ ¼ç´ããã¾ãããã®å¾ãä¾å­é¢ä¿ãå¤æ´ããããã³ã«ãã¢ã¸ã¥ã¼ã«ã¯èªå"
"çã« `using`ã¾ãã¯`import`æã«åã³ã³ãã¤ã«ããã¾ããããã§ããä¾å­é¢ä¿ã¨ã¯ãã¤ã³ãã¼ãããã¢ã¸ã¥ã¼ã«ãJulia ã®ãã«ããinclude ããï½ãã¡ã¤"
"ã«ãã¾ãã¯ã¢ã¸ã¥ã¼ã« ãã¡ã¤ã«åã® [`include_dependency(path)`](@ref ) ã«ãã£ã¦å®£è¨ãããæç¤ºçãªä¾å­é¢ä¿ãªã©ã®ãã¨ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:219
msgid ""
"For file dependencies, a change is determined by examining whether the modification time (mtime)  of each file loaded by `include` or added "
"explicitly by `include_dependency` is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems "
"that can't copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in "
"`require` matches the path that had created the precompile file. It also takes into account the set of dependencies already loaded into the "
"current process and won't recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities "
"between the running system and the precompile cache."
msgstr ""
"ãã¡ã¤ã«ã®ä¾å­é¢ä¿ã«ã¤ãã¦ã¯ãä¾å­é¢ä¿ã®å¤æ´ããã£ããã©ããã¯ã`include` ã«ãã£ã¦èª­ã¿è¾¼ã¾ãããã`include_dependency` ã«ãã£ã¦æç¤ºçã«è¿½å ã"
"ããåãã¡ã¤ã«ã«ã¤ãã¦ããã®æ´æ°æå» (mtime) ãå¤ãã£ã¦ããªããã©ããããããã¯ (1ç§ä»¥ä¸ã®ç²¾åº¦ã§mtime ãã³ãã¼ã§ããªãã·ã¹ãã ã«å¯¾å¿ãããã"
"ã«)æãè¿ãç§ã«åãæ¨ã¦ãããå¤æ´æéã¨ç­ãããã©ããã§å¤æ­ããã¾ããã¾ãã`require` ã®æ¤ç´¢ã­ã¸ãã¯ã§é¸æããããã¡ã¤ã«ã¸ã®ãã¹ããããªã³ã³ã"
"ã¤ã« ãã¡ã¤ã«ãä½æãããã¹ã¨ä¸è´ãããã©ãããèæ®ããã¾ããã¾ããç¾å¨ã®ãã­ã»ã¹ãæ¢ã«èª­ã¿è¾¼ãã§ããä¸é£ã®ä¾å­é¢ä¿ãèæ®ããã¾ããå®è¡ä¸­ã®ã·"
"ã¹ãã ã¨ããªã³ã³ãã¤ã« ã­ã£ãã·ã¥ã®éã«ä¸æ´åãçããªãããã«ãå®è¡ä¸­ã«ãã¡ã¤ã«ãå¤æ´ããããåé¤ããã¦ãããããã®ã¢ã¸ã¥ã¼ã«ãåã³ã³ãã¤ã«ã"
"ã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:226
msgid ""
"If you know that a module is *not* safe to precompile your module (for example, for one of the reasons described below), you should put "
"`__precompile__(false)` in the module file (typically placed at the top).  This will cause `Base.compilecache` to throw an error, and will "
"cause `using` / `import` to load it directly into the current process and skip the precompile and caching.  This also thereby prevents the "
"module from being imported by any other precompiled module."
msgstr ""
"ã¢ã¸ã¥ã¼ã«ãäºåã³ã³ãã¤ã«ããã®ãå®å¨ã§ãªããã¨ãããã£ã¦ããå ´å (ãã®çç±ã®ä¸ä¾ã¯ãã®å¾ã«è¿°ã¹ã¾ãã) ãã¢ã¸ã¥ã¼ã« ãã¡ã¤ã«(éå¸¸ã¯ãã¡ã¤ã«"
"ã®ä¸é¨)ã« `__precompile__(false)`ãè¨å¥ãã¦ãã ããã ããã«ããã`Base.compilecache` ãã¨ã©ã¼ãã¹ã­ã¼ãã¦ã`using` / `import` ãç¾å¨ã®ãã­ã»"
"ã¹ã«ç´æ¥ãã®ã¢ã¸ã¥ã¼ã«ãèª­ã¿è¾¼ã¿ãããªã³ã³ãã¤ã«ã¨ã­ã£ãã·ã¥ãã¹ã­ãããã¾ãã ããã«ãããã¢ã¸ã¥ã¼ã«ãä»ã®ããªã³ã³ãã¤ã«æ¸ã¿ã¢ã¸ã¥ã¼ã«ã«ãã£"
"ã¦ã¤ã³ãã¼ããããã®ãé²ããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:240
msgid ""
"You may need to be aware of certain behaviors inherent in the creation of incremental shared libraries which may require care when writing "
"your module. For example, external state is not preserved.  To accommodate this, explicitly separate any initialization steps that must "
"occur at *runtime* from steps that can occur at *compile time*.  For this purpose, Julia allows you to define an `__init__()` function in "
"your module that executes any initialization steps that must occur at runtime.  This function will not be called during compilation (`--"
"output-*`).  Effectively, you can assume it will be run exactly once in the lifetime of the code.  You may, of course, call it manually if "
"necessary, but the default is to assume this function deals with computing state for the local machine, which does not need to be â or even "
"should not be â captured in the compiled image. It will be called after the module is loaded into a process, including if it is being loaded "
"into an incremental compile (`--output-incremental=yes`), but not if it is being loaded into a full-compilation process."
msgstr ""
"ã¢ã¸ã¥ã¼ã«ã®ã³ã¼ããæ¸ãã¦ããã¨ãã«ã¯ãå¢åå±æã©ã¤ãã©ãªã®ä½æã«åºæã®ç¹å®ã®åä½ã«æ³¨æããå¿è¦ãããã¾ãããã¨ãã°ãå¤é¨ç¶æã¯ä¿æããã¾ã"
"ãã ããã«å¯¾å¿ããããã«ã*å®è¡æ* ã« å¦çãããå¿è¦ã®ããåæåã¹ãããã¨ã*ã³ã³ãã¤ã«æ*ã«å¦çãã¦ãããã¹ãããã¨ãæç¤ºçã«åé¢ãã¦ãã ã"
"ããJulia ã§ã¯ãã¢ã¸ã¥ã¼ã«ã« `__init__()`é¢æ°ãå®ç¾©ããããã«ãå®è¡æã«å¦çãããå¿è¦ãããåæåã¹ããããæ¸ããã¨ãã§ãã¾ãããã®é¢æ°ã¯(`--"
"output-*`ã«ãã)ã³ã³ãã¤ã«ä¸­ã«ã¯å¼ã³åºãããã ã³ã¼ããå®è¡ããã¦ããéã« 1 åã ãå®è¡ãããã¨æ³å®ã§ãã¾ãã ãã¡ãããå¿è¦ã«å¿ãã¦æåã§å¼ã³"
"åºããã¨ãã§ãã¾ãããããã©ã«ãã§ã¯ããã®é¢æ°ããå¦çãå®è¡ä¸­ãã·ã³ã®è¨ç®ç¶æãæ±ã£ã¦ããã¨æ³å®ã§ãã¾ããããã§ããè¨ç®ç¶æã¨ã¯ãããªã³ã³ã"
"ã¤ã«ã¤ã¡ã¼ã¸ã«å«ã¾ããå¿è¦ããªã - ãããå«ã¾ãã¦ã¯ãããªã ãããªã¢ããè¡¨ãã¾ãããã® `__init__()`é¢æ°ã¯ãã¢ã¸ã¥ã¼ã«ããã­ã»ã¹ã«ã­ã¼ãããã"
"ãã¨ã§ãå¼ã°ãã¾ããããã¯ãã¤ã³ã¯ãªã¡ã³ã¿ã« ã³ã³ãã¤ã« (`-output-incremental=yes`) ã§ã­ã¼ããããå ´åãè©²å½ãã¾ããããã«ã³ã³ãã¤ã«ãã­ã»ã¹"
"ã«ã­ã¼ããããå ´åã¯è©²å½ãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:247
msgid ""
"In particular, if you define a `function __init__()` in a module, then Julia will call `__init__()` immediately *after* the module is loaded "
"(e.g., by `import`, `using`, or `require`) at runtime for the *first* time (i.e., `__init__` is only called once, and only after all "
"statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported "
"modules have their `__init__` functions called *before* the `__init__` of the enclosing module."
msgstr ""
"ç¹ã«ãã¢ã¸ã¥ã¼ã«åã«`__init__()`é¢æ°ãå®ç¾©ããå ´åã(ä¾ãã°ã`import`ã`using`ã`require`ãªã©ãç¨ãã¦)ã¢ã¸ã¥ã¼ã«ãã­ã¼ãããã*ç´å¾*ãåãã¦"
"ã®å®è¡æã« `__init__()`é¢æ°ãå¼ã°ãã¾ãã (ã¤ã¾ããã¢ã¸ã¥ã¼ã«åã®ãã¹ã¦ã®æãå®è¡ãããå¾ã«`__init__` ã¯ 1 åã ãå¼ã³åºããã¾ã)ãã¢ã¸ã¥ã¼ã«"
"ãå®å¨ã«ã¤ã³ãã¼ããããå¾ã«å¼ã³åºãããããããµãã¢ã¸ã¥ã¼ã«ããã®ä»ã®ã¤ã³ãã¼ããããã¢ã¸ã¥ã¼ã«ã® `__init__()`é¢æ°ã¯ãããå²ãã¢ã¸ã¥ã¼ã«ã®"
"`__init__`ããã *åã«* å¼ã³åºããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:255
msgid ""
"Two typical uses of `__init__` are calling runtime initialization functions of external C libraries and initializing global constants that "
"involve pointers returned by external libraries.  For example, suppose that we are calling a C library `libfoo` that requires us to call a "
"`foo_init()` initialization function at runtime. Suppose that we also want to define a global constant `foo_data_ptr` that holds the return "
"value of a `void *foo_data()` function defined by `libfoo` -- this constant must be initialized at runtime (not at compile time) because the "
"pointer address will change from run to run.  You could accomplish this by defining the following `__init__` function in your module:"
msgstr ""
"`__init__` ã® 2 ã¤ã®å¸åçãªç¨éã¯ãå¤é¨ C ã©ã¤ãã©ãªã®ã©ã³ã¿ã¤ã åæåé¢æ°ãå¼ã³åºããå¤é¨ã©ã¤ãã©ãªã«ãã£ã¦è¿ããããã¤ã³ã¿ã¼ãå«ãã°ã­ã¼ã"
"ã«å®æ°ãåæåãããã¨ã§ãã ãã¨ãã°ãå®è¡æã« `foo_init()` åæåé¢æ°ãå¼ã³åºãå¿è¦ããã C ã©ã¤ãã©ãª `libfoo` ãå¼ã³åºãã¨ãã¾ãã"
"`libfoo` ã§å®ç¾©ããã `void *foo_data()` é¢æ°ã®æ»ãå¤ãä¿æããã°ã­ã¼ãã«å®æ° `foo_data_ptr` ãå®ç¾©ããã¨ãã¾ãããã®æããã¤ã³ã¿ã®ã¢ãã¬ã¹ã¯"
"å®è¡ãããã¨ã«å¤ããããã`foo_data_ptr` ã¯(ã³ã³ãã¤ã«æã§ã¯ãªã)å®è¡æã«åæåããå¿è¦ãããã¾ããããã¯ãã¢ã¸ã¥ã¼ã«åã«æ¬¡ã®ãããª`__init__`"
"é¢æ°ãå®ç¾©ããã°ãå®è¡ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:256
#, no-wrap
msgid ""
"const foo_data_ptr = Ref{Ptr{Cvoid}}(0)\n"
"function __init__()\n"
"    ccall((:foo_init, :libfoo), Cvoid, ())\n"
"    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())\n"
"    nothing\n"
"end\n"
msgstr ""
"const foo_data_ptr = Ref{Ptr{Cvoid}}(0)\n"
"function __init__()\n"
"    ccall((:foo_init, :libfoo), Cvoid, ())\n"
"    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())\n"
"    nothing\n"
"end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:270
msgid ""
"Notice that it is perfectly possible to define a global inside a function like `__init__`; this is one of the advantages of using a dynamic "
"language. But by making it a constant at global scope, we can ensure that the type is known to the compiler and allow it to generate better "
"optimized code. Obviously, any other globals in your module that depends on `foo_data_ptr` would also have to be initialized in `__init__`."
msgstr ""
"`__init__`ã®ãããªé¢æ°åã§ã°ã­ã¼ãã«ã«ã·ã³ãã«ãå®ç¾©ãããã¨ã¯å¯è½ã§ãããã¨ã«æ³¨ç®ãã¦ãã ãããããã¯åçè¨èªãä½¿ç¨ããå©ç¹ã® 1 ã¤ã§ãããã°"
"ã­ã¼ãã«ã¹ã³ã¼ãã§å®æ°ã¨ãããã¨ã§ãã³ã³ãã¤ã©ãåãèªè­ããããæé©åãããã³ã¼ããçæã§ããããã«ãªãã¾ããæããã«ãã¢ã¸ã¥ã¼ã«åã®ä»ã®ã°"
"ã­ã¼ãã«ã `foo_data_ptr` ã«ä¾å­ãããã®ã«ã¤ãã¦ã¯ã`__init__` ã§åæåããå¿è¦ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:277
msgid ""
"Constants involving most Julia objects that are not produced by [`ccall`](@ref) do not need to be placed in `__init__`: their definitions "
"can be precompiled and loaded from the cached module image. This includes complicated heap-allocated objects like arrays. However, any "
"routine that returns a raw pointer value must be called at runtime for precompilation to work ([`Ptr`](@ref) objects will turn into null "
"pointers unless they are hidden inside an [`isbits`](@ref) object). This includes the return values of the Julia functions `cfunction` and "
"[`pointer`](@ref)."
msgstr ""
"[`ccall`](@ref ) ãä½¿ããã«çæãããã»ã¨ãã©ã® Julia ãªãã¸ã§ã¯ããå«ãå®æ°ã¯`__init__` ã«éç½®ããå¿è¦ã¯ããã¾ããã ããããå®æ°ã®å®ç¾©ã¯ã"
"ããªã³ã³ãã¤ã«ã§ããã­ã£ãã·ã¥ãããã¢ã¸ã¥ã¼ã«ã¤ã¡ã¼ã¸ããã­ã¼ããããã¨ãã§ãã¾ããããã«ã¯ãéåã®ããã«ãã¼ããå²ãå½ã¦ãããè¤éãªãªã"
"ã¸ã§ã¯ããå«ã¾ãã¾ãããçã®ãã¤ã³ã¿ã¼å¤ãè¿ãã«ã¼ãã³ã¯ãããªã³ã³ãã¤ã«ããã¾ãåä½ããããã«å®è¡æã«å¼ã³åºãå¿è¦ãããã¾ã([`Ptr`](@ref ) "
"ãªãã¸ã§ã¯ãã¯ã[`isbits`](@ref ) ãªãã¸ã§ã¯ãåã«é ããã¦ããªãéããnull ãã¤ã³ã¿ã¼ã« ãªãã¾ã)ãããã«ã¯ãJulia é¢æ° `cfunction` ã¨ "
"[`pointer`](@ref )ã®æ»ãå¤ãå«ã¾ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:288
msgid ""
"Dictionary and set types, or in general anything that depends on the output of a `hash(key)` method, are a trickier case.  In the common "
"case where the keys are numbers, strings, symbols, ranges, `Expr`, or compositions of these types (via arrays, tuples, sets, pairs, etc.) "
"they are safe to precompile.  However, for a few other key types, such as `Function` or `DataType` and generic user-defined types where you "
"haven't defined a `hash` method, the fallback `hash` method depends on the memory address of the object (via its `objectid`) and hence may "
"change from run to run.  If you have one of these key types, or if you aren't sure, to be safe you can initialize this dictionary from "
"within your `__init__` function. Alternatively, you can use the [`IdDict`](@ref)  dictionary type, which is specially handled by "
"precompilation so that it is safe to initialize at compile-time."
msgstr ""
"è¾æ¸åãéååãã¾ãã¯ä¸è¬ã«`hash(key)`ã¡ã½ããã®åºåã«ä½ããä¾å­ãããã®ã¯åãæ±ããåä»ãªã±ã¼ã¹ã§ããkey ãæ°å¤ãæå­åãã·ã³ãã«ãç¯å²ã"
"`Expr`ãã¾ãã¯ãããã®åã®è¤åå (éåãã¿ãã«ãéåãPairãªã©ãä»ãã¦) ã§ããä¸è¬çãªã±ã¼ã¹ã§ã¯ãããªã³ã³ãã¤ã«ãã¦ãå®å¨ã§ãã ãã ãããã"
"ã¤ãã®ã­ã¼åãä¾ãã° `Function`ã`DataType`  ããã¦ `hash`ã¡ã½ãããå®ç¾©ãã¦ããªãæ±ç¨ã¦ã¼ã¶ã¼å®ç¾©ã®åãªã©ã«ã¤ãã¯ããã©ã¼ã«ããã¯ `hash`ã¡"
"ã½ããã¯ã(`objectid` ãä»ãã) ãªãã¸ã§ã¯ãã®ã¡ã¢ãª ã¢ãã¬ã¹ã«ä¾å­ãã¦ãããå®è¡ãããã³ã«å¤æ´ãããããããã¾ããããããã®ã­ã¼ã¿ã¤ãã®ãã"
"ãããæã£ã¦ããå ´åãã¾ãã¯å®å¨ã§ããã¨ç¢ºä¿¡ãæã¦ãªãå ´åã¯ã`__init__` é¢æ°åãããã®è¾æ¸ãåæåã§ãã¾ãããããã¯ã[`IdDict`](@ref )è¾æ¸"
"åãä½¿ããã¨ãã§ãã¾ããããã¯ã³ã³ãã¤ã«æã«å®å¨ã«åæåã§ããããã«ãããªã³ã³ãã¤ã«ã«ãã£ã¦ç¹æ®ãªå¦çãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:293
msgid ""
"When using precompilation, it is important to keep a clear sense of the distinction between the compilation phase and the execution phase. "
"In this mode, it will often be much more clearly apparent that Julia is a compiler which allows execution of arbitrary Julia code, not a "
"standalone interpreter that also generates compiled code."
msgstr ""
"ããªã³ã³ãã¤ã«ãä½¿ç¨ããå ´åã¯ãã³ã³ãã¤ã« ãã§ã¼ãºã¨å®è¡ãã§ã¼ãºã®éããæç¢ºã«çè§£ãã¦ããå¿è¦ãããã¾ãããã®ã¢ã¼ãã§ã¯ãJulia ãã³ã³ãã¤ã«"
"æ¸ã¿ã³ã¼ããçæããã¹ã¿ã³ãã¢ã­ã³ã¤ã³ã¿ããªã¿ã§ã¯ãªããä»»æã® Julia ã³ã¼ãã®å®è¡ãå¯è½ã«ããã³ã³ãã¤ã©ã§ãããã¨ãæããã«ãªããã¨ããããã"
"ã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:295
msgid "Other known potential failure scenarios include:"
msgstr "ãã®ä»æ¢ç¥ã®å¤±æããã¡ãªã·ããªãªã¯ä¸è¨ã®éãã§ã:"

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/modules.md:298
msgid "Global counters (for example, for attempting to uniquely identify objects). Consider the following code snippet:"
msgstr "ã°ã­ã¼ãã«ã«ã¦ã³ã¿ã¼(ä¾ãã°ããªãã¸ã§ã¯ããä¸æã«è­å¥ãã)ã«ã¤ãã¦ãæ¬¡ã®ã³ã¼ããèãã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:299
#, no-wrap
msgid ""
"   mutable struct UniquedById\n"
"       myid::Int\n"
"       let counter = 0\n"
"           UniquedById() = new(counter += 1)\n"
"       end\n"
"   end\n"
msgstr ""
"   mutable struct UniquedById\n"
"       myid::Int\n"
"       let counter = 0\n"
"           UniquedById() = new(counter += 1)\n"
"       end\n"
"   end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:311
#, no-wrap
msgid ""
"   while the intent of this code was to give every instance a unique id, the counter value is recorded\n"
"   at the end of compilation. All subsequent usages of this incrementally compiled module will start\n"
"   from that same counter value.\n"
msgstr "   ãã®ã³ã¼ãã®ç®çã¯ããã¹ã¦ã®ã¤ã³ã¹ã¿ã³ã¹ã«ä¸æã® ID ãä¸ãããã®ã§ããããã³ã³ãã¤ã«ã®æå¾ã«ã«ã¦ã³ã¿å¤ã¯ãè¨é²ããã¾ãããã®ãã¨ã§ãã¤ã³ã¯ãªã¡ã³ã¿ã«ã³ã³ãã¤ã«ãããã¢ã¸ã¥ã¼ã«ãä½¿ãããã¨ãã¯ãã¤ããåãã«ã¦ã³ã¿å¤ããèµ·åãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:314
#, no-wrap
msgid ""
"   Note that `objectid` (which works by hashing the memory pointer) has similar issues (see notes\n"
"   on `Dict` usage below).\n"
msgstr "   `objectid` ã¯ãã¡ã¢ãªãã¤ã³ã¿ãããã·ã¥ãããã®ã§ãããä¼¼ããããªåé¡ããããã¨ã«æ³¨æ ( ä¸è¨ã® `Dict` ç¨æ³åç§ ) ã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:324
#, no-wrap
msgid ""
"   One alternative is to use a macro to capture [`@__MODULE__`](@ref) and store it alone with the current `counter` value,\n"
"   however, it may be better to redesign the code to not depend on this global state.\n"
"2. Associative collections (such as `Dict` and `Set`) need to be re-hashed in `__init__`. (In the\n"
"   future, a mechanism may be provided to register an initializer function.)\n"
"3. Depending on compile-time side-effects persisting through load-time. Example include: modifying\n"
"   arrays or other variables in other Julia modules; maintaining handles to open files or devices;\n"
"   storing pointers to other system resources (including memory);\n"
"4. Creating accidental \"copies\" of global state from another module, by referencing it directly instead\n"
"   of via its lookup path. For example, (in global scope):\n"
msgstr ""
"   ãã 1 ã¤ã®æ¹æ³ã¯ããã¯ã­ãä½¿ç¨ãã¦ [`@__MODULE__`](@ref) ãã­ã£ããã£ããç¾å¨ã® 'ã«ã¦ã³ã¿' å¤ãä½¿ç¨ãã¦åç¬ã§æ ¼ç´ãããã¨ã§ãããã ãããã®ã°ã­ã¼ãã«ç¶æã«ä¾å­ããªãããã«ã³ã¼ããåè¨­è¨ããã»ããããããããã¾ããã\n"
"2. é£æ³ã³ã¬ã¯ã·ã§ã³ (`Dict` ã `Set` ãªã©) ã¯ `__init__`ã§åããã·ã¥ããå¿è¦ãããã¾ãã(å°æ¥çã«ã¯ãåæåé¢æ°ãç»é²ããã¡ã«ããºã ãæä¾ãããããããã¾ãã)ã\n"
"3. ã³ã³ãã¤ã«æã®å¯ä½ç¨ã®å½±é¿ã¯ã¯å®è¡æã«ãæ®ãã¾ããä¾: ä»ã® Julia ã¢ã¸ã¥ã¼ã«ã®éåã¾ãã¯ãã®ä»ã®å¤æ°ã®åå®¹ã®å¤æ´ããã¡ã¤ã«ã¾ãã¯ããã¤ã¹ãéãããã«ãã³ãã«ã®ä¿æãä»ã®ã·ã¹ãã  ãªã½ã¼ã¹ (ã¡ã¢ãªãå«ã) ã¸ã®ãã¤ã³ã¿ã¼ã®æ ¼ç´ã\n"
"4. ã«ãã¯ã¢ãããã¹ã§ã¯ãªããç´æ¥åç§ããããã¨ã§ãå¥ã®ã¢ã¸ã¥ã¼ã«ããã°ã­ã¼ãã«ãªç¶æã®ãã³ãã¼ããæå³ããä½æãã¦ãã¾ããã¨ãä¾ãã°ã(ã°ã­ã¼ãã«ã¹ã³ã¼ãã§ã¯):\n"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:325
#, no-wrap
msgid ""
"   #mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#\n"
"   # instead use accessor functions:\n"
"   getstdout() = Base.stdout #= best option =#\n"
"   # or move the assignment into the runtime:\n"
"   __init__() = global mystdout = Base.stdout #= also works =#\n"
msgstr ""
"   #mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#\n"
"   # instead use accessor functions:\n"
"   getstdout() = Base.stdout #= best option =#\n"
"   # or move the assignment into the runtime:\n"
"   __init__() = global mystdout = Base.stdout #= also works =#\n"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:335
msgid ""
"Several additional restrictions are placed on the operations that can be done while precompiling code to help the user avoid other wrong-"
"behavior situations:"
msgstr "ã³ã¼ãã®ããªã³ã³ãã¤ã«ä¸­ã«å¯è½ãªå¦çã«ã¯æ§ããªå¶éãèª²ããã¾ããã¦ã¼ã¶ã¼ãééã£ãç¶æ³ãé¿ããã®ãæ¯æ´ããããã§ã:"

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/modules.md:341
msgid ""
"Calling [`eval`](@ref) to cause a side-effect in another module. This will also cause a warning to be emitted when the incremental "
"precompile flag is set."
msgstr ""
"å¥ã®ã¢ã¸ã¥ã¼ã«ã§å¯ä½ç¨ãå¼ãèµ·ãã[`eval`](@ref)ã®å¼ã³åºããã¾ããã¤ã³ã¯ãªã¡ã³ã¿ã«ãªããªã³ã³ãã¤ã«ã®ãã©ã°ãè¨­å®ããã¦ããæã«ã¯è­¦åãåºåã"
"ãã¾ãã"

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/modules.md:341
msgid "`global const` statements from local scope after `__init__()` has been started (see issue #12010 for plans to add an error for this)"
msgstr ""
"`__init__()`ãå¦çéå§ãããå¾ã® ã­ã¼ã«ã«ã¹ã³ã¼ãããã® `global const` å®£è¨ (ããã«å¯¾ãã¦ã¨ã©ã¼ãçºçããããã¨ããè¨ç»ã«ã¤ãã¦ã¯ãissue "
"#12010 ãåç§)"

#. type: Bullet: '3. '
#: ext/julia/doc/src/manual/modules.md:341
msgid "Replacing a module is a runtime error while doing an incremental precompile."
msgstr "ã¢ã¸ã¥ã¼ã«ã®ç½®ãæãã¯ãå¢åããªã³ã³ãã¤ã«ã®å®è¡ä¸­ã«ã©ã³ã¿ã¤ã  ã¨ã©ã¼ãå¼ãèµ·ããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:343
msgid "A few other points to be aware of:"
msgstr "ãã®ä»ã®æ³¨æç¹ã¯æ¬¡ã®ã¨ããã§ã:"

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/modules.md:359
msgid ""
"No code reload / cache invalidation is performed after changes are made to the source files themselves, (including by `Pkg.update`), and no "
"cleanup is done after `Pkg.rm`"
msgstr ""
"ã½ã¼ã¹ ãã¡ã¤ã«èªä½ã«å¤æ´ãå ãããã(`Pkg.update` å«ã)å¾ã« ãã³ã¼ãã®åèª­ã¿è¾¼ã¿/ã­ã£ãã·ã¥ã®ç¡å¹åã¯å®è¡ããã¾ãã ã`Pkg.rm` ã®å¾ã«ã¯ãªã¼"
"ã³ã¢ããã¯è¡ããã¾ãã"

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/modules.md:359
msgid "The memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets its own copy)"
msgstr "Reshape ãããéåã®ã¡ã¢ãªå±æåä½ã¯ãããªã³ã³ãã¤ã«ã«ãã£ã¦ç¡è¦ããã¾ã (åãã¥ã¼ã¯ç¬èªã®ã³ãã¼ãåå¾ãã¾ã)"

#. type: Bullet: '3. '
#: ext/julia/doc/src/manual/modules.md:359
msgid ""
"Expecting the filesystem to be unchanged between compile-time and runtime e.g. [`@__FILE__`](@ref)/`source_path()` to find resources at "
"runtime, or the BinDeps `@checked_lib` macro. Sometimes this is unavoidable.  However, when possible, it can be good practice to copy "
"resources into the module at compile-time so they won't need to be found at runtime."
msgstr ""
"ã³ã³ãã¤ã«æã¨å®è¡æã®éã«ãã¡ã¤ã«ã·ã¹ãã ãå¤æ´ãããªããã¨ãæå¾ãããã®: ä¾ãã°ã[`@__FILE__`](@ref)/`source_path()`ã§å®è¡æã«ãªã½ã¼ã¹ãæ¢"
"ãããã¨ããBinDeps ã® `@checked_lib` ãã¯ã­ãªã©ããããããã¨ã¯é¿ããããªããã¨ãããã¾ãããã ããå¯è½ã§ããã°ãã³ã³ãã¤ã«æã«ãªã½ã¼ã¹ãã¢"
"ã¸ã¥ã¼ã«ã«ã³ãã¼ãã¦ããã¦ãå®è¡æã«ãã®ãªã½ã¼ã¹ãæ¢ãå¿è¦ãç¡ããã¦ããã®ã¯ãããã©ã¯ãã£ã¹ã§ãã"

#. type: Bullet: '4. '
#: ext/julia/doc/src/manual/modules.md:359
msgid "`WeakRef` objects and finalizers are not currently handled properly by the serializer (this will be fixed in an upcoming release)."
msgstr "`WeakRef` ãªãã¸ã§ã¯ãã¨ãã¡ã¤ãã©ã¤ã¶ã¯ãç¾å¨ã·ãªã¢ã©ã¤ã¶ã¼ã«ãã£ã¦é©åã«å¦çããã¦ãã¾ãã (ããã¯ä»å¾ã®ãªãªã¼ã¹ã§ä¿®æ­£ããã¾ã)ã"

#. type: Bullet: '5. '
#: ext/julia/doc/src/manual/modules.md:359
msgid ""
"It is usually best to avoid capturing references to instances of internal metadata objects such as `Method`, `MethodInstance`, "
"`MethodTable`, `TypeMapLevel`, `TypeMapEntry` and fields of those objects, as this can confuse the serializer and may not lead to the "
"outcome you desire. It is not necessarily an error to do this, but you simply need to be prepared that the system will try to copy some of "
"these and to create a single unique instance of others."
msgstr ""
"éå¸¸ã¯ãã·ãªã¢ã©ã¤ã¶ã¼ãæ··ä¹±ãããæã¾ã¬çµæãå°ãå¯è½æ§ãããããã`Method`, `MethodInstance`, `MethodTable`, `TypeMapLeve`, `TypeMapEntry` "
"ããã¦ãããã®ãªãã¸ã§ã¯ãã®ãã£ã¼ã«ããªã©ã®ãåé¨ã¡ã¿ãã¼ã¿ãªãã¸ã§ã¯ãã®ã¤ã³ã¹ã¿ã³ã¹ã¸ã®åç§ãè£è¶³ããªãããã«ãããã¨ããèããã¾ããåç§"
"ãè£è¶³ãããã¨ã¯å¿ãããã¨ã©ã¼ã§ã¯ããã¾ããããã·ã¹ãã ããããã®ä¸é¨ãã³ãã¼ããåä¸ã»å¯ä¸ã®ã¤ã³ã¹ã¿ã³ã¹ãä½æããããã«ããã°ããè©±ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/modules.md:365
msgid ""
"It is sometimes helpful during module development to turn off incremental precompilation. The command line flag `--compiled-modules={yes|no}"
"` enables you to toggle module precompilation on and off. When Julia is started with `--compiled-modules=no` the serialized modules in the "
"compile cache are ignored when loading modules and module dependencies. `Base.compilecache` can still be called manually. The state of this "
"command line flag is passed to `Pkg.build` to disable automatic precompilation triggering when installing, updating, and explicitly building "
"packages."
msgstr ""
"ã¢ã¸ã¥ã¼ã«ã®éçºä¸­ã«ãã¤ã³ã¯ãªã¡ã³ã¿ã«ããªã³ã³ãã¤ã«ããªãã«ããã¨ä¾¿å©ãªå ´åãããã¾ããã³ãã³ãã©ã¤ã³ãã©ã° `--compiled-modules={yes|no}` ã"
"ä½¿ç¨ããã¨ãã¢ã¸ã¥ã¼ã«ã®ããªã³ã³ãã¤ã«ã®ãªã³ã¨ãªããåãæ¿ããã¨ãã§ãã¾ããJulia ã `--compiled-modules=no` ã§èµ·åããã¨ãã¢ã¸ã¥ã¼ã«ã¨ã¢"
"ã¸ã¥ã¼ã«ã®ä¾å­é¢ä¿ãèª­ã¿è¾¼ãã¨ãã«ãã³ã³ãã¤ã« ã­ã£ãã·ã¥åã®ã·ãªã¢ã«åãããã¢ã¸ã¥ã¼ã«ã¯ç¡è¦ããã¾ãã`--compiled-modules=no`ã«ãã¦ãã¦ã"
"`Base.compilecache` ã¯æåã§å¼ã³åºããã¨ãã§ãã¾ãããã®ã³ãã³ã ã©ã¤ã³ ãã©ã°ã®ç¶æã¯ `Pkg.build` ã«æ¸¡ãããããã±ã¼ã¸ã®ã¤ã³ã¹ãã¼ã«ãæ´æ°ã"
"ããã³æç¤ºçãªãã«ãæã«èªåããªã³ã³ãã¤ã«ããªã¬ãç¡å¹ã«ãã¾ãã"

#. type: Title #
#: ext/julia/doc/src/manual/arrays.md:1
#, no-wrap
msgid "[Multi-dimensional Arrays](@id man-multi-dim-arrays)"
msgstr "[å¤æ¬¡åéå](@id man-multi-dim-arrays)"

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:10
msgid ""
"Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of "
"attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array "
"library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in "
"Julia. As such, it's also possible to define custom array types by inheriting from [`AbstractArray`](@ref). See the [manual section on the "
"AbstractArray interface](@ref man-interface-array) for more details on implementing a custom array type."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:14
msgid ""
"An array is a collection of objects stored in a multi-dimensional grid. In the most general case, an array may contain objects of type "
"[`Any`](@ref). For most computational purposes, arrays should contain objects of a more specific type, such as [`Float64`](@ref) or [`Int32`]"
"(@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:19
msgid ""
"In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for "
"performance. Julia's compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in "
"a style that is convenient and readable, without sacrificing performance, and using less memory at times."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:31
msgid ""
"In Julia, all arguments to functions are [passed by sharing](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing)  (i.e. by "
"pointers). Some technical computing languages pass arrays by value, and while this prevents accidental modification by callees of a value in "
"the caller, it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a `!` indicates that it will "
"mutate or destroy the value of one or more of its arguments (compare, for example, [`sort`](@ref) and [`sort!`](@ref)).  Callees must make "
"explicit copies to ensure that they don't modify inputs that they don't intend to change. Many non- mutating functions are implemented by "
"calling a function of the same name with an added `!` at the end on an explicit copy of the input, and returning that copy."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:32
#, no-wrap
msgid "Basic Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:46
#, no-wrap
msgid ""
"| Function               | Description                                                                      |\n"
"|:---------------------- |:-------------------------------------------------------------------------------- |\n"
"| [`eltype(A)`](@ref)    | the type of the elements contained in `A`                                        |\n"
"| [`length(A)`](@ref)    | the number of elements in `A`                                                    |\n"
"| [`ndims(A)`](@ref)     | the number of dimensions of `A`                                                  |\n"
"| [`size(A)`](@ref)      | a tuple containing the dimensions of `A`                                         |\n"
"| [`size(A,n)`](@ref)    | the size of `A` along dimension `n`                                              |\n"
"| [`axes(A)`](@ref)      | a tuple containing the valid indices of `A`                                      |\n"
"| [`axes(A,n)`](@ref)    | a range expressing the valid indices along dimension `n`                         |\n"
"| [`eachindex(A)`](@ref) | an efficient iterator for visiting each position in `A`                          |\n"
"| [`stride(A,k)`](@ref)  | the stride (linear index distance between adjacent elements) along dimension `k` |\n"
"| [`strides(A)`](@ref)   | a tuple of the strides in each dimension                                         |\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:47
#, no-wrap
msgid "Construction and Initialization"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:54
msgid ""
"Many functions for constructing and initializing arrays are provided. In the following list of such functions, calls with a `dims...` "
"argument can either take a single tuple of dimension sizes or a series of dimension sizes passed as a variable number of arguments. Most of "
"these functions also accept a first input `T`, which is the element type of the array. If the type `T` is omitted it will default to "
"[`Float64`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:73
#, no-wrap
msgid ""
"| Function                           | Description                                                                                                                                                                                                                                  |\n"
"|:---------------------------------- |:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n"
"| [`Array{T}(undef, dims...)`](@ref)             | an uninitialized dense [`Array`](@ref)                                                                                                                                                                                                              |\n"
"| [`zeros(T, dims...)`](@ref)                    | an `Array` of all zeros                                                                                                                                                                                                                      |\n"
"| [`ones(T, dims...)`](@ref)                     | an `Array` of all ones                                                                                                                                                                                                                       |\n"
"| [`trues(dims...)`](@ref)                       | a [`BitArray`](@ref) with all values `true`                                                                                                                                                                                                  |\n"
"| [`falses(dims...)`](@ref)                      | a `BitArray` with all values `false`                                                                                                                                                                                                         |\n"
"| [`reshape(A, dims...)`](@ref)                  | an array containing the same data as `A`, but with different dimensions                                                                                                                                                                      |\n"
"| [`copy(A)`](@ref)                              | copy `A`                                                                                                                                                                                                                                     |\n"
"| [`deepcopy(A)`](@ref)                          | copy `A`, recursively copying its elements                                                                                                                                                                                                   |\n"
"| [`similar(A, T, dims...)`](@ref)               | an uninitialized array of the same type as `A` (dense, sparse, etc.), but with the specified element type and dimensions. The second and third arguments are both optional, defaulting to the element type and dimensions of `A` if omitted. |\n"
"| [`reinterpret(T, A)`](@ref)                    | an array with the same binary data as `A`, but with element type `T`                                                                                                                                                                         |\n"
"| [`rand(T, dims...)`](@ref)                     | an `Array` with random, iid [^1] and uniformly distributed values in the half-open interval ``[0, 1)``                                                                                                                                       |\n"
"| [`randn(T, dims...)`](@ref)                    | an `Array` with random, iid and standard normally distributed values                                                                                                                                                                         |\n"
"| [`Matrix{T}(I, m, n)`](@ref)                   | `m`-by-`n` identity matrix                                                                                                                                                                                                                   |\n"
"| [`range(start, stop=stop, length=n)`](@ref)    | range of `n` linearly spaced elements from `start` to `stop`                                                                                                                                                                                 |\n"
"| [`fill!(A, x)`](@ref)                          | fill the array `A` with the value `x`                                                                                                                                                                                                        |\n"
"| [`fill(x, dims...)`](@ref)                     | an `Array` filled with the value `x`                                                                                                                                                                                                         |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:75
msgid "[^1]: *iid*, independently and identically distributed."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:79
msgid ""
"The syntax `[A, B, C, ...]` constructs a 1-d array (i.e., a vector) of its arguments. If all arguments have a common [promotion type](@ref "
"conversion-and-promotion) then they get converted to that type using [`convert`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:81
msgid "To see the various ways we can pass dimensions to these constructors, consider the following examples:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:81
#, no-wrap
msgid ""
"julia> zeros(Int8, 2, 3)\n"
"2Ã3 Array{Int8,2}:\n"
" 0  0  0\n"
" 0  0  0\n"
"\n"
"julia> zeros(Int8, (2, 3))\n"
"2Ã3 Array{Int8,2}:\n"
" 0  0  0\n"
" 0  0  0\n"
"\n"
"julia> zeros((2, 3))\n"
"2Ã3 Array{Float64,2}:\n"
" 0.0  0.0  0.0\n"
" 0.0  0.0  0.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:98
msgid "Here, `(2, 3)` is a [`Tuple`](@ref)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:99
#, no-wrap
msgid "Concatenation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:102
msgid "Arrays can be constructed and also concatenated using the following functions:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:108
#, no-wrap
msgid ""
"| Function                    | Description                                     |\n"
"|:--------------------------- |:----------------------------------------------- |\n"
"| [`cat(A...; dims=k)`](@ref) | concatenate input arrays along dimension(s) `k` |\n"
"| [`vcat(A...)`](@ref)        | shorthand for `cat(A...; dims=1)`               |\n"
"| [`hcat(A...)`](@ref)        | shorthand for `cat(A...; dims=2)`               |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:110
msgid "Scalar values passed to these functions are treated as 1-element arrays. For example,"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:110
#, no-wrap
msgid ""
"julia> vcat([1, 2], 3)\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"julia> hcat([1 2], 3)\n"
"1Ã3 Array{Int64,2}:\n"
" 1  2  3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:123
msgid "The concatenation functions are used so often that they have special syntax:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:129
#, no-wrap
msgid ""
"| Expression        | Calls             |\n"
"|:----------------- |:----------------- |\n"
"| `[A; B; C; ...]`  | [`vcat`](@ref)  |\n"
"| `[A B C ...]`     | [`hcat`](@ref)  |\n"
"| `[A B; C D; ...]` | [`hvcat`](@ref) |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:132
msgid ""
"[`hvcat`](@ref) concatenates in both dimension 1 (with semicolons) and dimension 2 (with spaces).  Consider these examples of this syntax:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:132
#, no-wrap
msgid ""
"julia> [[1; 2]; [3, 4]]\n"
"4-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
" 4\n"
"\n"
"julia> [[1 2] [3 4]]\n"
"1Ã4 Array{Int64,2}:\n"
" 1  2  3  4\n"
"\n"
"julia> [[1 2]; [3 4]]\n"
"2Ã2 Array{Int64,2}:\n"
" 1  2\n"
" 3  4\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:150
#, no-wrap
msgid "Typed array initializers"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:155
msgid ""
"An array with a specific element type can be constructed using the syntax `T[A, B, C, ...]`. This will construct a 1-d array with element "
"type `T`, initialized to contain elements `A`, `B`, `C`, etc. For example, `Any[x, y, z]` constructs a heterogeneous array that can contain "
"any values."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:158
msgid "Concatenation syntax can similarly be prefixed with a type to specify the element type of the result."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:159
#, no-wrap
msgid ""
"julia> [[1 2] [3 4]]\n"
"1Ã4 Array{Int64,2}:\n"
" 1  2  3  4\n"
"\n"
"julia> Int8[[1 2] [3 4]]\n"
"1Ã4 Array{Int8,2}:\n"
" 1  2  3  4\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:169
#, no-wrap
msgid "Comprehensions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:173
msgid ""
"Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to set construction notation in "
"mathematics:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:174
#, no-wrap
msgid "A = [ F(x,y,...) for x=rx, y=ry, ... ]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:183
msgid ""
"The meaning of this form is that `F(x,y,...)` is evaluated with the variables `x`, `y`, etc. taking on each value in their given list of "
"values. Values can be specified as any iterable object, but will commonly be ranges like `1:n` or `2:(n-1)`, or explicit arrays of values "
"like `[1.2, 3.4, 5.7]`.  The result is an N-d dense array with dimensions that are the concatenation of the dimensions of the variable "
"ranges `rx`, `ry`, etc. and each `F(x,y,...)` evaluation returns a scalar."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:186
msgid "The following example computes a weighted average of the current element and its left and right neighbor along a 1-d grid. :"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:187
#, no-wrap
msgid ""
"julia> x = rand(8)\n"
"8-element Array{Float64,1}:\n"
" 0.843025\n"
" 0.869052\n"
" 0.365105\n"
" 0.699456\n"
" 0.977653\n"
" 0.994953\n"
" 0.41084\n"
" 0.809411\n"
"\n"
"julia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]\n"
"6-element Array{Float64,1}:\n"
" 0.736559\n"
" 0.57468\n"
" 0.685417\n"
" 0.912429\n"
" 0.8446\n"
" 0.656511\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:212
msgid ""
"The resulting array type depends on the types of the computed elements. In order to control the type explicitly, a type can be prepended to "
"the comprehension. For example, we could have requested the result in single precision by writing:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:213
#, no-wrap
msgid "Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:217
#, no-wrap
msgid "Generator Expressions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:223
msgid ""
"Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be "
"iterated to produce values on demand, instead of allocating an array and storing them in advance (see [Iteration](@ref)). For example, the "
"following expression sums a series without allocating memory:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:224
#, no-wrap
msgid ""
"julia> sum(1/n^2 for n=1:1000)\n"
"1.6439345666815615\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:231
msgid ""
"When writing a generator expression with multiple dimensions inside an argument list, parentheses are needed to separate the generator from "
"subsequent arguments:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:232
#, no-wrap
msgid ""
"julia> map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])\n"
"ERROR: syntax: invalid iteration specification\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:239
msgid ""
"All comma-separated expressions after `for` are interpreted as ranges. Adding parentheses lets us add a third argument to [`map`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:240
#, no-wrap
msgid ""
"julia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])\n"
"2Ã2 Array{Tuple{Float64,Int64},2}:\n"
" (0.5, 1)       (0.333333, 3)\n"
" (0.333333, 2)  (0.25, 4)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:253
msgid ""
"Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope "
"can be \"captured\" in the inner function.  For example, `sum(p[i] - q[i] for i=1:n)` captures the three variables `p`, `q` and `n` from the "
"enclosing scope.  Captured variables can present performance challenges; see [performance tips](@ref man-performance-tips)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:257
msgid "Ranges in generators and comprehensions can depend on previous ranges by writing multiple `for` keywords:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:258
#, no-wrap
msgid ""
"julia> [(i,j) for i=1:3 for j=1:i]\n"
"6-element Array{Tuple{Int64,Int64},1}:\n"
" (1, 1)\n"
" (2, 1)\n"
" (2, 2)\n"
" (3, 1)\n"
" (3, 2)\n"
" (3, 3)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:270
msgid "In such cases, the result is always 1-d."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:272
msgid "Generated values can be filtered using the `if` keyword:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:273
#, no-wrap
msgid ""
"julia> [(i,j) for i=1:3 for j=1:i if i+j == 4]\n"
"2-element Array{Tuple{Int64,Int64},1}:\n"
" (2, 2)\n"
" (3, 1)\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:280
#, no-wrap
msgid "[Indexing](@id man-array-indexing)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:283
msgid "The general syntax for indexing into an n-dimensional array `A` is:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:284
#, no-wrap
msgid "X = A[I_1, I_2, ..., I_n]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:293 ext/julia/doc/src/manual/arrays.md:413
msgid ""
"where each `I_k` may be a scalar integer, an array of integers, or any other [supported index](@ref man-supported-index-types). This "
"includes [`Colon`](@ref) (`:`) to select all indices within the entire dimension, ranges of the form `a:c` or `a:b:c` to select contiguous "
"or strided subsections, and arrays of booleans to select elements at their `true` indices."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:297
msgid ""
"If all the indices are scalars, then the result `X` is a single element from the array `A`. Otherwise, `X` is an array with the same number "
"of dimensions as the sum of the dimensionalities of all the indices."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:300
msgid ""
"If all indices `I_k` are vectors, for example, then the shape of `X` would be `(length(I_1), length(I_2), ..., length(I_n))`, with location "
"`i_1, i_2, ..., i_n` of `X` containing the value `A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:302 ext/julia/doc/src/manual/arrays.md:352 ext/julia/doc/src/manual/arrays.md:380
#: ext/julia/doc/src/manual/arrays.md:442
msgid "Example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:303
#, no-wrap
msgid ""
"julia> A = reshape(collect(1:16), (2, 2, 2, 2))\n"
"2Ã2Ã2Ã2 Array{Int64,4}:\n"
"[:, :, 1, 1] =\n"
" 1  3\n"
" 2  4\n"
"\n"
"[:, :, 2, 1] =\n"
" 5  7\n"
" 6  8\n"
"\n"
"[:, :, 1, 2] =\n"
"  9  11\n"
" 10  12\n"
"\n"
"[:, :, 2, 2] =\n"
" 13  15\n"
" 14  16\n"
"\n"
"julia> A[1, 2, 1, 1] # all scalar indices\n"
"3\n"
"\n"
"julia> A[[1, 2], [1], [1, 2], [1]] # all vector indices\n"
"2Ã1Ã2Ã1 Array{Int64,4}:\n"
"[:, :, 1, 1] =\n"
" 1\n"
" 2\n"
"\n"
"[:, :, 2, 1] =\n"
" 5\n"
" 6\n"
"\n"
"julia> A[[1, 2], [1], [1, 2], 1] # a mix of index types\n"
"2Ã1Ã2 Array{Int64,3}:\n"
"[:, :, 1] =\n"
" 1\n"
" 2\n"
"\n"
"[:, :, 2] =\n"
" 5\n"
" 6\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:347
msgid "Note how the size of the resulting array is different in the last two cases."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:350
msgid ""
"If `I_1` is changed to a two-dimensional matrix, then `X` becomes an `n+1`-dimensional array of shape `(size(I_1, 1), size(I_1, 2), "
"length(I_2), ..., length(I_n))`. The matrix adds a dimension."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:353
#, no-wrap
msgid ""
"julia> A = reshape(collect(1:16), (2, 2, 2, 2));\n"
"\n"
"julia> A[[1 2; 1 2]]\n"
"2Ã2 Array{Int64,2}:\n"
" 1  2\n"
" 1  2\n"
"\n"
"julia> A[[1 2; 1 2], 1, 2, 1]\n"
"2Ã2 Array{Int64,2}:\n"
" 5  6\n"
" 5  6\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:370
msgid ""
"The location `i_1, i_2, i_3, ..., i_{n+1}` contains the value at `A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]`.  All dimensions indexed "
"with scalars are dropped. For example, if `J` is an array of indices, then the result of `A[2, J, 3]` is an array with size `size(J)`. Its "
"`j`th element is populated by `A[2, J[j], 3]`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:374
msgid ""
"As a special part of this syntax, the `end` keyword may be used to represent the last index of each dimension within the indexing brackets, "
"as determined by the size of the innermost array being indexed. Indexing syntax without the `end` keyword is equivalent to a call to "
"[`getindex`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:375
#, no-wrap
msgid "X = getindex(A, I_1, I_2, ..., I_n)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:381
#, no-wrap
msgid ""
"julia> x = reshape(1:16, 4, 4)\n"
"4Ã4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:\n"
" 1  5   9  13\n"
" 2  6  10  14\n"
" 3  7  11  15\n"
" 4  8  12  16\n"
"\n"
"julia> x[2:3, 2:end-1]\n"
"2Ã2 Array{Int64,2}:\n"
" 6  10\n"
" 7  11\n"
"\n"
"julia> x[1, [2 3; 4 1]]\n"
"2Ã2 Array{Int64,2}:\n"
"  5  9\n"
" 13  1\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:400
#, no-wrap
msgid "Assignment"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:403
msgid "The general syntax for assigning values in an n-dimensional array `A` is:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:404
#, no-wrap
msgid "A[I_1, I_2, ..., I_n] = X\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:417
msgid ""
"If all indices `I_k` are integers, then the value in location `I_1, I_2, ..., I_n` of `A` is overwritten with the value of `X`, [`convert`]"
"(@ref)ing to the [`eltype`](@ref) of `A` if necessary."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:425
msgid ""
"If any index `I_k` selects more than one location, then the right hand side `X` must be an array with the same shape as the result of "
"indexing `A[I_1, I_2, ..., I_n]` or a vector with the same number of elements. The value in location `I_1[i_1], I_2[i_2], ..., I_n[i_n]` of "
"`A` is overwritten with the value `X[I_1, I_2, ..., I_n]`, converting if necessary. The element-wise assignment operator `.=` may be used to "
"[broadcast](@ref Broadcasting) `X` across the selected locations:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:427
#, no-wrap
msgid "A[I_1, I_2, ..., I_n] .= X\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:436
msgid ""
"Just as in [Indexing](@ref man-array-indexing), the `end` keyword may be used to represent the last index of each dimension within the "
"indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the `end` keyword is "
"equivalent to a call to [`setindex!`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:437
#, no-wrap
msgid "setindex!(A, X, I_1, I_2, ..., I_n)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:443
#, no-wrap
msgid ""
"julia> x = collect(reshape(1:9, 3, 3))\n"
"3Ã3 Array{Int64,2}:\n"
" 1  4  7\n"
" 2  5  8\n"
" 3  6  9\n"
"\n"
"julia> x[3, 3] = -9;\n"
"\n"
"julia> x[1:2, 1:2] = [-1 -4; -2 -5];\n"
"\n"
"julia> x\n"
"3Ã3 Array{Int64,2}:\n"
" -1  -4   7\n"
" -2  -5   8\n"
"  3   6  -9\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:461
#, no-wrap
msgid "[Supported index types](@id man-supported-index-types)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:466
msgid ""
"In the expression `A[I_1, I_2, ..., I_n]`, each `I_k` may be a scalar index, an array of scalar indices, or an object that represents an "
"array of scalar indices and can be converted to such by [`to_indices`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:479
#, no-wrap
msgid ""
"1. A scalar index. By default this includes:\n"
"    * Non-boolean integers\n"
"    * [`CartesianIndex{N}`](@ref)s, which behave like an `N`-tuple of integers spanning multiple dimensions (see below for more details)\n"
"2. An array of scalar indices. This includes:\n"
"    * Vectors and multidimensional arrays of integers\n"
"    * Empty arrays like `[]`, which select no elements\n"
"    * Ranges like `a:c` or `a:b:c`, which select contiguous or strided subsections from `a` to `c` (inclusive)\n"
"    * Any custom array of scalar indices that is a subtype of `AbstractArray`\n"
"    * Arrays of `CartesianIndex{N}` (see below for more details)\n"
"3. An object that represents an array of scalar indices and can be converted to such by [`to_indices`](@ref). By default this includes:\n"
"    * [`Colon()`](@ref) (`:`), which represents all indices within an entire dimension or across the entire array\n"
"    * Arrays of booleans, which select elements at their `true` indices (see below for more details)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:481
msgid "Some examples:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:481
#, no-wrap
msgid ""
"julia> A = reshape(collect(1:2:18), (3, 3))\n"
"3Ã3 Array{Int64,2}:\n"
" 1   7  13\n"
" 3   9  15\n"
" 5  11  17\n"
"\n"
"julia> A[4]\n"
"7\n"
"\n"
"julia> A[[2, 5, 8]]\n"
"3-element Array{Int64,1}:\n"
"  3\n"
"  9\n"
" 15\n"
"\n"
"julia> A[[1 4; 3 8]]\n"
"2Ã2 Array{Int64,2}:\n"
" 1   7\n"
" 5  15\n"
"\n"
"julia> A[[]]\n"
"0-element Array{Int64,1}\n"
"\n"
"julia> A[1:2:5]\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 5\n"
" 9\n"
"\n"
"julia> A[2, :]\n"
"3-element Array{Int64,1}:\n"
"  3\n"
"  9\n"
" 15\n"
"\n"
"julia> A[:, 3]\n"
"3-element Array{Int64,1}:\n"
" 13\n"
" 15\n"
" 17\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/arrays.md:524
#, no-wrap
msgid "Cartesian indices"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:528
msgid ""
"The special `CartesianIndex{N}` object represents a scalar index that behaves like an `N`-tuple of integers spanning multiple dimensions.  "
"For example:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/arrays.md:529 ext/julia/doc/src/manual/arrays.md:552 ext/julia/doc/src/manual/arrays.md:576
#, no-wrap
msgid "jldoctest cartesianindex"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:529
#, no-wrap
msgid ""
"julia> A = reshape(1:32, 4, 4, 2);\n"
"\n"
"julia> A[3, 2, 1]\n"
"7\n"
"\n"
"julia> A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7\n"
"true\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:546
msgid ""
"Considered alone, this may seem relatively trivial; `CartesianIndex` simply gathers multiple integers together into one object that "
"represents a single multidimensional index. When combined with other indexing forms and iterators that yield `CartesianIndex`es, however, "
"this can produce very elegant and efficient code. See [Iteration](@ref) below, and for some more advanced examples, see [this blog post on "
"multidimensional algorithms and iteration](https://julialang.org/blog/2016/02/iteration)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:551
msgid ""
"Arrays of `CartesianIndex{N}` are also supported. They represent a collection of scalar indices that each span `N` dimensions, enabling a "
"form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first "
"\"page\" of `A` from above:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:552
#, no-wrap
msgid ""
"julia> page = A[:,:,1]\n"
"4Ã4 Array{Int64,2}:\n"
" 1  5   9  13\n"
" 2  6  10  14\n"
" 3  7  11  15\n"
" 4  8  12  16\n"
"\n"
"julia> page[[CartesianIndex(1,1),\n"
"             CartesianIndex(2,2),\n"
"             CartesianIndex(3,3),\n"
"             CartesianIndex(4,4)]]\n"
"4-element Array{Int64,1}:\n"
"  1\n"
"  6\n"
" 11\n"
" 16\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:575
msgid ""
"This can be expressed much more simply with [dot broadcasting](@ref man-vectorized)  and by combining it with a normal integer index "
"(instead of extracting the first `page` from `A` as a separate step). It can even be combined with a `:` to extract both diagonals from the "
"two pages at the same time:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:576
#, no-wrap
msgid ""
"julia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]\n"
"4-element Array{Int64,1}:\n"
"  1\n"
"  6\n"
" 11\n"
" 16\n"
"\n"
"julia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]\n"
"4Ã2 Array{Int64,2}:\n"
"  1  17\n"
"  6  22\n"
" 11  27\n"
" 16  32\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:593 ext/julia/doc/src/manual/unicode-input.md:11
msgid "!!! warning"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:597
#, no-wrap
msgid ""
"    `CartesianIndex` and arrays of `CartesianIndex` are not compatible with the\n"
"    `end` keyword to represent the last index of a dimension. Do not use `end`\n"
"    in indexing expressions that may contain either `CartesianIndex` or arrays thereof.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/arrays.md:598
#, no-wrap
msgid "Logical indexing"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:610
msgid ""
"Often referred to as logical indexing or indexing with a logical mask, indexing by a boolean array selects elements at the indices where its "
"values are `true`.  Indexing by a boolean vector `B` is effectively the same as indexing by the vector of integers that is returned by "
"[`findall(B)`](@ref). Similarly, indexing by a `N`-dimensional boolean array is effectively the same as indexing by the vector of "
"`CartesianIndex{N}`s where its values are `true`. A logical index must be a vector of the same length as the dimension it indexes into, or "
"it must be the only index provided and match the size and dimensionality of the array it indexes into. It is generally more efficient to use "
"boolean arrays as indices directly instead of first calling [`findall`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:611
#, no-wrap
msgid ""
"julia> x = reshape(1:16, 4, 4)\n"
"4Ã4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:\n"
" 1  5   9  13\n"
" 2  6  10  14\n"
" 3  7  11  15\n"
" 4  8  12  16\n"
"\n"
"julia> x[[false, true, true, false], :]\n"
"2Ã4 Array{Int64,2}:\n"
" 2  6  10  14\n"
" 3  7  11  15\n"
"\n"
"julia> mask = map(ispow2, x)\n"
"4Ã4 Array{Bool,2}:\n"
" 1  0  0  0\n"
" 1  0  0  0\n"
" 0  0  0  0\n"
" 1  1  0  1\n"
"\n"
"julia> x[mask]\n"
"5-element Array{Int64,1}:\n"
"  1\n"
"  2\n"
"  4\n"
"  8\n"
" 16\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/arrays.md:640
#, no-wrap
msgid "Number of indices"
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/manual/arrays.md:642
#, no-wrap
msgid "Cartesian indexing"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:648
msgid ""
"The ordinary way to index into an `N`-dimensional array is to use exactly `N` indices; each index selects the position(s) in its particular "
"dimension. For example, in the three-dimensional array `A = rand(4, 3, 2)`, `A[2, 3, 1]` will select the number in the second row of the "
"third column in the first \"page\" of the array. This is often referred to as _cartesian indexing_."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/arrays.md:649 ext/julia/doc/src/devdocs/subarrays.md:122
#, no-wrap
msgid "Linear indexing"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:656
msgid ""
"When exactly one index `i` is provided, that index no longer represents a location in a particular dimension of the array. Instead, it "
"selects the `i`th element using the column-major iteration order that linearly spans the entire array. This is known as _linear indexing_. "
"It essentially treats the array as though it had been reshaped into a one-dimensional vector with [`vec`](@ref)."
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/arrays.md:657 ext/julia/doc/src/manual/arrays.md:676
#, no-wrap
msgid "jldoctest linindexing"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:657
#, no-wrap
msgid ""
"julia> A = [2 6; 4 7; 3 1]\n"
"3Ã2 Array{Int64,2}:\n"
" 2  6\n"
" 4  7\n"
" 3  1\n"
"\n"
"julia> A[5]\n"
"7\n"
"\n"
"julia> vec(A)[5]\n"
"7\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:675
msgid ""
"A linear index into the array `A` can be converted to a `CartesianIndex` for cartesian indexing with `CartesianIndices(A)[i]` (see "
"[`CartesianIndices`](@ref)), and a set of `N` cartesian indices can be converted to a linear index with `LinearIndices(A)[i_1, i_2, ..., "
"i_N]` (see [`LinearIndices`](@ref))."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:676
#, no-wrap
msgid ""
"julia> CartesianIndices(A)[5]\n"
"CartesianIndex(2, 2)\n"
"\n"
"julia> LinearIndices(A)[2, 2]\n"
"5\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:696
msgid ""
"It's important to note that there's a very large assymmetry in the performance of these conversions. Converting a linear index to a set of "
"cartesian indices requires dividing and taking the remainder, whereas going the other way is just multiplies and adds. In modern processors, "
"integer division can be 10-50 times slower than multiplication. While some arrays â like [`Array`](@ref) itself â are implemented using a "
"linear chunk of memory and directly use a linear index in their implementations, other arrays â like [`Diagonal`](@ref) â need the full set "
"of cartesian indices to do their lookup (see [`IndexStyle`](@ref) to introspect which is which). As such, when iterating over an entire "
"array, it's much better to iterate over [`eachindex(A)`](@ref) instead of `1:length(A)`.  Not only will the former be much faster in cases "
"where `A` is `IndexCartesian`, but it will also support OffsetArrays, too."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/manual/arrays.md:697
#, no-wrap
msgid "Omitted and extra indices"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:701
msgid "In addition to linear indexing, an `N`-dimensional array may be indexed with fewer or more than `N` indices in certain situations."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:709
msgid ""
"Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words, trailing indices can be "
"omitted only if there is only one possible value that those omitted indices could be for an in-bounds indexing expression. For example, a "
"four-dimensional array with size `(3, 4, 2, 1)` may be indexed with only three indices as the dimension that gets skipped (the fourth "
"dimension) has length one. Note that linear indexing takes precedence over this rule."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:710
#, no-wrap
msgid ""
"julia> A = reshape(1:24, 3, 4, 2, 1)\n"
"3Ã4Ã2Ã1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64:\n"
"[:, :, 1, 1] =\n"
" 1  4  7  10\n"
" 2  5  8  11\n"
" 3  6  9  12\n"
"\n"
"[:, :, 2, 1] =\n"
" 13  16  19  22\n"
" 14  17  20  23\n"
" 15  18  21  24\n"
"\n"
"julia> A[1, 3, 2] # Omits the fourth dimension (length 1)\n"
"19\n"
"\n"
"julia> A[1, 3] # Attempts to omit dimensions 3 & 4 (lengths 2 and 1)\n"
"ERROR: BoundsError: attempt to access 3Ã4Ã2Ã1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64 at index [1, 3]\n"
"\n"
"julia> A[19] # Linear indexing\n"
"19\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:736
msgid ""
"When omitting _all_ indices with `A[]`, this semantic provides a simple idiom to retrieve the only element in an array and simultaneously "
"ensure that there was only one element."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:741
msgid ""
"Similarly, more than `N` indices may be provided if all the indices beyond the dimensionality of the array are `1` (or more generally are "
"the first and only element of `axes(A, d)` where `d` is that particular dimension number). This allows vectors to be indexed like one-column "
"matrices, for example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:742
#, no-wrap
msgid ""
"julia> A = [8,6,7]\n"
"3-element Array{Int64,1}:\n"
" 8\n"
" 6\n"
" 7\n"
"\n"
"julia> A[2,1]\n"
"6\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:753
#, no-wrap
msgid "Iteration"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:756
msgid "The recommended ways to iterate over a whole array are"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:757
#, no-wrap
msgid ""
"for a in A\n"
"    # Do something with the element a\n"
"end\n"
"\n"
"for i in eachindex(A)\n"
"    # Do something with i and/or A[i]\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:770
msgid ""
"The first construct is used when you need the value, but not index, of each element. In the second construct, `i` will be an `Int` if `A` is "
"an array type with fast linear indexing; otherwise, it will be a `CartesianIndex`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:771
#, no-wrap
msgid ""
"julia> A = rand(4,3);\n"
"\n"
"julia> B = view(A, 1:3, 2:3);\n"
"\n"
"julia> for i in eachindex(B)\n"
"           @show i\n"
"       end\n"
"i = CartesianIndex(1, 1)\n"
"i = CartesianIndex(2, 1)\n"
"i = CartesianIndex(3, 1)\n"
"i = CartesianIndex(1, 2)\n"
"i = CartesianIndex(2, 2)\n"
"i = CartesianIndex(3, 2)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:789
msgid "In contrast with `for i = 1:length(A)`, iterating with [`eachindex`](@ref) provides an efficient way to iterate over any array type."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:790
#, no-wrap
msgid "Array traits"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:793
msgid "If you write a custom [`AbstractArray`](@ref) type, you can specify that it has fast linear indexing using"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:794
#, no-wrap
msgid "Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:800
msgid ""
"This setting will cause `eachindex` iteration over a `MyArray` to use integers. If you don't specify this trait, the default value "
"`IndexCartesian()` is used."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:801
#, no-wrap
msgid "Array and Vectorized Operators and Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:804
msgid "The following operators are supported for arrays:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/arrays.md:808
msgid "Unary arithmetic -- `-`, `+`"
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/arrays.md:808
msgid "Binary arithmetic -- `-`, `+`, `*`, `/`, `\\`, `^`"
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/manual/arrays.md:808
msgid "Comparison -- `==`, `!=`, `â` ([`isapprox`](@ref)), `â`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:814
msgid ""
"To enable convenient vectorization of mathematical and other operations, Julia [provides the dot syntax](@ref man-vectorized) `f.(args...)`, "
"e.g. `sin.(x)` or `min.(x,y)`, for elementwise operations over arrays or mixtures of arrays and scalars (a [Broadcasting](@ref) operation); "
"these have the additional advantage of \"fusing\" into a single loop when combined with other dot calls, e.g. `sin.(cos.(x))`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:818
msgid ""
"Also, *every* binary operator supports a [dot version](@ref man-dot-operators)  that can be applied to arrays (and combinations of arrays "
"and scalars) in such [fused broadcasting operations](@ref man-vectorized), e.g. `z .== sin.(x .* y)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:822
#, no-wrap
msgid ""
"Note that comparisons such as `==` operate on whole arrays, giving a single boolean\n"
"answer. Use dot operators like `.==` for elementwise comparisons. (For comparison\n"
"operations like `<`, *only* the elementwise `.<` version is applicable to arrays.)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:826
msgid ""
"Also notice the difference between `max.(a,b)`, which [`broadcast`](@ref)s [`max`](@ref)  elementwise over `a` and `b`, and [`maximum(a)`]"
"(@ref), which finds the largest value within `a`. The same relationship holds for `min.(a,b)` and `minimum(a)`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:827
#, no-wrap
msgid "Broadcasting"
msgstr "[ãã­ã¼ãã­ã£ã¹ã](@id Broadcasting)"

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:832
msgid ""
"It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as adding a vector to each column "
"of a matrix. An inefficient way to do this would be to replicate the vector to the size of the matrix:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:833
#, no-wrap
msgid ""
"julia> a = rand(2,1); A = rand(2,3);\n"
"\n"
"julia> repeat(a,1,3)+A\n"
"2Ã3 Array{Float64,2}:\n"
" 1.20813  1.82068  1.25387\n"
" 1.56851  1.86401  1.67846\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:845
msgid ""
"This is wasteful when dimensions get large, so Julia provides [`broadcast`](@ref), which expands singleton dimensions in array arguments to "
"match the corresponding dimension in the other array without using extra memory, and applies the given function elementwise:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:846
#, no-wrap
msgid ""
"julia> broadcast(+, a, A)\n"
"2Ã3 Array{Float64,2}:\n"
" 1.20813  1.82068  1.25387\n"
" 1.56851  1.86401  1.67846\n"
"\n"
"julia> b = rand(1,2)\n"
"1Ã2 Array{Float64,2}:\n"
" 0.867535  0.00457906\n"
"\n"
"julia> broadcast(+, a, b)\n"
"2Ã2 Array{Float64,2}:\n"
" 1.71056  0.847604\n"
" 1.73659  0.873631\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:869
msgid ""
"[Dotted operators](@ref man-dot-operators) such as `.+` and `.*` are equivalent to `broadcast` calls (except that they fuse, as described "
"below). There is also a [`broadcast!`](@ref) function to specify an explicit destination (which can also be accessed in a fusing fashion by "
"`.=` assignment). In fact, `f.(args...)` is equivalent to `broadcast(f, args...)`, providing a convenient syntax to broadcast any function "
"([dot syntax](@ref man-vectorized)). Nested \"dot calls\" `f.(...)` (including calls to `.+` etcetera)  [automatically fuse](@ref man-dot-"
"operators) into a single `broadcast` call."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:875
msgid ""
"Additionally, [`broadcast`](@ref) is not limited to arrays (see the function documentation); it also handles scalars, tuples and other "
"collections.  By default, only some argument types are considered scalars, including (but not limited to) `Number`s, `String`s, `Symbol`s, "
"`Type`s, `Function`s and some common singletons like `missing` and `nothing`. All other arguments are iterated over or indexed into "
"elementwise."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:876
#, no-wrap
msgid ""
"julia> convert.(Float32, [1, 2])\n"
"2-element Array{Float32,1}:\n"
" 1.0\n"
" 2.0\n"
"\n"
"julia> ceil.((UInt8,), [1.2 3.4; 5.6 6.7])\n"
"2Ã2 Array{UInt8,2}:\n"
" 0x02  0x04\n"
" 0x06  0x07\n"
"\n"
"julia> string.(1:3, \". \", [\"First\", \"Second\", \"Third\"])\n"
"3-element Array{String,1}:\n"
" \"1. First\"\n"
" \"2. Second\"\n"
" \"3. Third\"\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/arrays.md:894
#, no-wrap
msgid "Implementation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:901
msgid ""
"The base array type in Julia is the abstract type [`AbstractArray{T,N}`](@ref). It is parameterized by the number of dimensions `N` and the "
"element type `T`. [`AbstractVector`](@ref) and [`AbstractMatrix`](@ref) are aliases for the 1-d and 2-d cases. Operations on `AbstractArray` "
"objects are defined using higher level operators and functions, in a way that is independent of the underlying storage. These operations "
"generally work correctly as a fallback for any specific array implementation."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:914
msgid ""
"The `AbstractArray` type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. "
"For example, elements might be computed on request rather than stored. However, any concrete `AbstractArray{T,N}` type should generally "
"implement at least [`size(A)`](@ref) (returning an `Int` tuple), [`getindex(A,i)`](@ref) and [`getindex(A,i1,...,iN)`](@ref getindex); "
"mutable arrays should also implement [`setindex!`](@ref). It is recommended that these operations have nearly constant time complexity, or "
"technically Ã(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a "
"[`similar(A,T=eltype(A),dims=size(A))`](@ref)  method, which is used to allocate a similar array for [`copy`](@ref) and other out-of-place "
"operations. No matter how an `AbstractArray{T,N}` is represented internally, `T` is the type of object returned by *integer* indexing "
"(`A[1, ..., 1]`, when `A` is not empty) and `N` should be the length of the tuple returned by [`size`](@ref). For more details on defining "
"custom `AbstractArray` implementations, see the [array interface guide in the interfaces chapter](@ref man-interface-array)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:922
msgid ""
"`DenseArray` is an abstract subtype of `AbstractArray` intended to include all arrays where elements are stored contiguously in column-major "
"order (see additional notes in [Performance Tips](@ref man-performance-tips)). The [`Array`](@ref) type is a specific instance of "
"`DenseArray`; [`Vector`](@ref) and [`Matrix`](@ref) are aliases for the 1-d and 2-d cases.  Very few operations are implemented specifically "
"for `Array` beyond those that are required for all `AbstractArray`s; much of the array library is implemented in a generic manner that "
"allows all custom arrays to behave similarly."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:933
msgid ""
"`SubArray` is a specialization of `AbstractArray` that performs indexing by sharing memory with the original array rather than by copying "
"it. A `SubArray` is created with the [`view`](@ref) function, which is called the same way as [`getindex`](@ref) (with an array and a series "
"of index arguments). The result of [`view`](@ref) looks the same as the result of [`getindex`](@ref), except the data is left in place. "
"[`view`](@ref) stores the input index vectors in a `SubArray` object, which can later be used to index the original array indirectly.  By "
"putting the [`@views`](@ref) macro in front of an expression or block of code, any `array[...]` slice in that expression will be converted "
"to create a `SubArray` view instead."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:937
msgid ""
"[`BitArray`](@ref)s are space-efficient \"packed\" boolean arrays, which store one bit per boolean value.  They can be used similarly to "
"`Array{Bool}` arrays (which store one byte per boolean value), and can be converted to/from the latter via `Array(bitarray)` and "
"`BitArray(array)`, respectively."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:952
msgid ""
"A \"strided\" array is stored in memory with elements laid out in regular offsets such that an instance with a supported `isbits` element "
"type can be passed to external C and Fortran functions that expect this memory layout. Strided arrays must define a [`strides(A)`](@ref) "
"method that returns a tuple of \"strides\" for each dimension; a provided [`stride(A,k)`](@ref) method accesses the `k`th element within "
"this tuple. Increasing the index of dimension `k` by `1` should increase the index `i` of [`getindex(A,i)`](@ref) by [`stride(A,k)`](@ref). "
"If a pointer conversion method [`Base.unsafe_convert(Ptr{T}, A)`](@ref) is provided, the memory layout must correspond in the same way to "
"these strides. `DenseArray` is a very specific example of a strided array where the elements are arranged contiguously, thus it provides its "
"subtypes with the appropriate definition of `strides`. More concrete examples can be found within the [interface guide for strided arrays]"
"(@ref man-interface-strided-arrays).  [`StridedVector`](@ref) and [`StridedMatrix`](@ref) are convenient aliases for many of the builtin "
"array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and "
"optimized BLAS and LAPACK functions using just the pointer and strides."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:956
msgid ""
"The following example computes the QR decomposition of a small section of a larger array, without creating any temporaries, and by calling "
"the appropriate LAPACK function with the right leading dimension size and stride parameters."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/arrays.md:957
#, no-wrap
msgid ""
"julia> a = rand(10, 10)\n"
"10Ã10 Array{Float64,2}:\n"
" 0.517515  0.0348206  0.749042   0.0979679  â¦  0.75984     0.950481   0.579513\n"
" 0.901092  0.873479   0.134533   0.0697848     0.0586695   0.193254   0.726898\n"
" 0.976808  0.0901881  0.208332   0.920358      0.288535    0.705941   0.337137\n"
" 0.657127  0.0317896  0.772837   0.534457      0.0966037   0.700694   0.675999\n"
" 0.471777  0.144969   0.0718405  0.0827916     0.527233    0.173132   0.694304\n"
" 0.160872  0.455168   0.489254   0.827851   â¦  0.62226     0.0995456  0.946522\n"
" 0.291857  0.769492   0.68043    0.629461      0.727558    0.910796   0.834837\n"
" 0.775774  0.700731   0.700177   0.0126213     0.00822304  0.327502   0.955181\n"
" 0.9715    0.64354    0.848441   0.241474      0.591611    0.792573   0.194357\n"
" 0.646596  0.575456   0.0995212  0.038517      0.709233    0.477657   0.0507231\n"
"\n"
"julia> b = view(a, 2:2:8,2:2:4)\n"
"4Ã2 view(::Array{Float64,2}, 2:2:8, 2:2:4) with eltype Float64:\n"
" 0.873479   0.0697848\n"
" 0.0317896  0.534457\n"
" 0.455168   0.827851\n"
" 0.700731   0.0126213\n"
"\n"
"julia> (q, r) = qr(b);\n"
"\n"
"julia> q\n"
"4Ã4 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:\n"
" -0.722358    0.227524  -0.247784    -0.604181\n"
" -0.0262896  -0.575919  -0.804227     0.144377\n"
" -0.376419   -0.75072    0.540177    -0.0541979\n"
" -0.579497    0.230151  -0.00552346   0.781782\n"
"\n"
"julia> r\n"
"2Ã2 Array{Float64,2}:\n"
" -1.20921  -0.383393\n"
"  0.0      -0.910506\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/conversion-and-promotion.md:1
#, no-wrap
msgid "[Conversion and Promotion](@id conversion-and-promotion)"
msgstr "[å¤æã¨ææ ¼](@id conversion-and-promotion)"

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:9
msgid ""
"Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, "
"including [Integers and Floating-Point Numbers](@ref), [Mathematical Operations and Elementary Functions](@ref), [Types](@ref man-types), "
"and [Methods](@ref).  In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to "
"functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of "
"arithmetic arguments:"
msgstr ""
"Juliaã¯ãæ°å­¦æ¼ç®å­ã®å¼æ°ãå±éã®åã«ææ ¼ãããã·ã¹ãã ãæã£ã¦ãã¾ãããã®ãã¨ã¯ã[æ´æ°ã¨æµ®åå°æ°ç¹æ°](@ref integers-and-floating-point-"
"numbers)ã[ç®è¡æ¼ç®ã¨åç­é¢æ°](@ref mathematical-operations-and-elementary-functions)ãªã©ã[å](@ref man-types)ãããã³[ã¡ã½ãã](@ref "
"Methods)ãªã©ããã¾ãã¾ãªã»ã¯ã·ã§ã³ã§è¨åããã¦ãã¾ãããã®ã»ã¯ã·ã§ã³ã§ã¯ããã®åã®ææ ¼ã·ã¹ãã ã®ä»çµã¿ã¨ããããæ°ããåã«æ¡å¼µãã¦ãçµã¿è¾¼ã¿"
"ã®æ°å­¦æ¼ç®å­ãããä»¥å¤ã®é¢æ°ã«é©ç¨ããæ¹æ³ã«ã¤ãã¦èª¬æãã¾ããå¾æ¥ããã­ã°ã©ãã³ã°è¨èªã¯ãç®è¡å¼æ°ã®ææ ¼ãã©ã®ããã«æ±ããã§ã2 ã¤ã®é£å¶ã«å"
"é¡ããã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/conversion-and-promotion.md:28
msgid ""
"**Automatic promotion for built-in arithmetic types and operators.** In most languages, built-in numeric types, when used as operands to "
"arithmetic operators with infix syntax, such as `+`, `-`, `*`, and `/`, are automatically promoted to a common type to produce the expected "
"results.  C, Java, Perl, and Python, to name a few, all correctly compute the sum `1 + 1.5` as the floating-point value `2.5`, even though "
"one of the operands to `+` is an integer. These systems are convenient and designed carefully enough that they are generally all-but-"
"invisible to the programmer: hardly anyone consciously thinks of this promotion taking place when writing such an expression, but compilers "
"and interpreters must perform conversion before addition since integers and floating-point values cannot be added as-is. Complex rules for "
"such automatic conversions are thus inevitably part of specifications and implementations for such languages."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/conversion-and-promotion.md:28
msgid ""
"**No automatic promotion.** This camp includes Ada and ML -- very \"strict\" statically typed languages.  In these languages, every "
"conversion must be explicitly specified by the programmer. Thus, the example expression `1 + 1.5` would be a compilation error in both Ada "
"and ML. Instead one must write `real(1) + 1.5`, explicitly converting the integer `1` to a floating-point value before performing addition. "
"Explicit conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic conversion: integer literals are "
"promoted to the expected integer type automatically, and floating-point literals are similarly promoted to appropriate floating-point types."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:41
msgid ""
"In a sense, Julia falls into the \"no automatic promotion\" category: mathematical operators are just functions with special syntax, and the "
"arguments of functions are never automatically converted.  However, one may observe that applying mathematical operations to a wide variety "
"of mixed argument types is just an extreme case of polymorphic multiple dispatch -- something which Julia's dispatch and type systems are "
"particularly well-suited to handle. \"Automatic\" promotion of mathematical operands simply emerges as a special application: Julia comes "
"with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of "
"operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a "
"specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily "
"participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules "
"defining what types they should promote to when mixed with other types."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/conversion-and-promotion.md:42
#, no-wrap
msgid "Conversion"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:51
msgid ""
"The standard way to obtain a value of a certain type `T` is to call the type's constructor, `T(x)`.  However, there are cases where it's "
"convenient to convert a value from one type to another without the programmer asking for it explicitly.  One example is assigning a value "
"into an array: if `A` is a `Vector{Float64}`, the expression `A[1] = 2` should work by automatically converting the `2` from `Int` to "
"`Float64`, and storing the result in the array.  This is done via the [`convert`](@ref) function."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:55
msgid ""
"The `convert` function generally takes two arguments: the first is a type object and the second is a value to convert to that type. The "
"returned value is the value converted to an instance of given type.  The simplest way to understand this function is to see it in action:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:56
#, no-wrap
msgid ""
"julia> x = 12\n"
"12\n"
"\n"
"julia> typeof(x)\n"
"Int64\n"
"\n"
"julia> convert(UInt8, x)\n"
"0x0c\n"
"\n"
"julia> typeof(ans)\n"
"UInt8\n"
"\n"
"julia> convert(AbstractFloat, x)\n"
"12.0\n"
"\n"
"julia> typeof(ans)\n"
"Float64\n"
"\n"
"julia> a = Any[1 2 3; 4 5 6]\n"
"2Ã3 Array{Any,2}:\n"
" 1  2  3\n"
" 4  5  6\n"
"\n"
"julia> convert(Array{Float64}, a)\n"
"2Ã3 Array{Float64,2}:\n"
" 1.0  2.0  3.0\n"
" 4.0  5.0  6.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:88
msgid ""
"Conversion isn't always possible, in which case a no method error is thrown indicating that `convert` doesn't know how to perform the "
"requested conversion:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:89
#, no-wrap
msgid ""
"julia> convert(AbstractFloat, \"foo\")\n"
"ERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat\n"
"[...]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:100
msgid ""
"Some languages consider parsing strings as numbers or formatting numbers as strings to be conversions (many dynamic languages will even "
"perform conversion for you automatically), however Julia does not: even though some strings can be parsed as numbers, most strings are not "
"valid representations of numbers, and only a very limited subset of them are. Therefore in Julia the dedicated [`parse`](@ref)  function "
"must be used to perform this operation, making it more explicit."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/conversion-and-promotion.md:101
#, no-wrap
msgid "When is `convert` called?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:104
msgid "The following language constructs call `convert`:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/conversion-and-promotion.md:111
msgid "Assigning to an array converts to the array's element type."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/conversion-and-promotion.md:111
msgid "Assigning to a field of an object converts to the declared type of the field."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/conversion-and-promotion.md:111
msgid "Constructing an object with [`new`](@ref) converts to the object's declared field types."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/conversion-and-promotion.md:111
msgid "Assigning to a variable with a declared type (e.g. `local x::T`) converts to that type."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/conversion-and-promotion.md:111
msgid "A function with a declared return type converts its return value to that type."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/conversion-and-promotion.md:111
msgid "Passing a value to [`ccall`](@ref) converts it to the corresponding argument type."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/conversion-and-promotion.md:112
#, no-wrap
msgid "Conversion vs. Construction"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:122
msgid ""
"Note that the behavior of `convert(T, x)` appears to be nearly identical to `T(x)`.  Indeed, it usually is.  However, there is a key "
"semantic difference: since `convert` can be called implicitly, its methods are restricted to cases that are considered \"safe\" or "
"\"unsurprising\".  `convert` will only convert between types that represent the same basic kind of thing (e.g. different representations of "
"numbers, or different string encodings).  It is also usually lossless; converting a value to a different type and back again should result "
"in the exact same value."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:124
msgid "There are four general kinds of cases where constructors differ from `convert`:"
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/manual/conversion-and-promotion.md:125
#, no-wrap
msgid "Constructors for types unrelated to their arguments"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:130
msgid ""
"Some constructors don't implement the concept of \"conversion\".  For example, `Timer(2)` creates a 2-second timer, which is not really a "
"\"conversion\" from an integer to a timer."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/manual/conversion-and-promotion.md:131
#, no-wrap
msgid "Mutable collections"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:136
msgid ""
"`convert(T, x)` is expected to return the original `x` if `x` is already of type `T`.  In contrast, if `T` is a mutable collection type then "
"`T(x)` should always make a new collection (copying elements from `x`)."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/manual/conversion-and-promotion.md:137
#, no-wrap
msgid "Wrapper types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:147
msgid ""
"For some types which \"wrap\" other values, the constructor may wrap its argument inside a new object even if it is already of the requested "
"type.  For example `Some(x)` wraps `x` to indicate that a value is present (in a context where the result might be a `Some` or `nothing`).  "
"However, `x` itself might be the object `Some(y)`, in which case the result is `Some(Some(y))`, with two levels of wrapping.  `convert(Some, "
"x)`, on the other hand, would just return `x` since it is already a `Some`."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/manual/conversion-and-promotion.md:148
#, no-wrap
msgid "Constructors that don't return instances of their own type"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:156
msgid ""
"In *very rare* cases it might make sense for the constructor `T(x)` to return an object not of type `T`.  This could happen if a wrapper "
"type is its own inverse (e.g. `Flip(Flip(x)) === x`), or to support an old calling syntax for backwards compatibility when a library is "
"restructured.  But `convert(T, x)` should always return a value of type `T`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/conversion-and-promotion.md:157
#, no-wrap
msgid "Defining New Conversions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:166
msgid ""
"When defining a new type, initially all ways of creating it should be defined as constructors.  If it becomes clear that implicit conversion "
"would be useful, and that some constructors meet the above \"safety\" criteria, then `convert` methods can be added.  These methods are "
"typically quite simple, as they only need to call the appropriate constructor.  Such a definition might look like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:167
#, no-wrap
msgid "convert(::Type{MyType}, x) = MyType(x)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:178
msgid ""
"The type of the first argument of this method is a [singleton type](@ref man-singleton-types), `Type{MyType}`, the only instance of which is "
"`MyType`. Thus, this method is only invoked when the first argument is the type value `MyType`. Notice the syntax used for the first "
"argument: the argument name is omitted prior to the `::` symbol, and only the type is given.  This is the syntax in Julia for a function "
"argument whose type is specified but whose value does not need to be referenced by name. In this example, since the type is a singleton, we "
"already know its value without referring to an argument name."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:183
msgid ""
"All instances of some abstract types are by default considered \"sufficiently similar\" that a universal `convert` definition is provided in "
"Julia Base.  For example, this definition states that it's valid to `convert` any `Number` type to any other by calling a 1-argument "
"constructor:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:184
#, no-wrap
msgid "convert(::Type{T}, x::Number) where {T<:Number} = T(x)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:192
msgid ""
"This means that new `Number` types only need to define constructors, since this definition will handle `convert` for them.  An identity "
"conversion is also provided to handle the case where the argument is already of the requested type:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:193
#, no-wrap
msgid "convert(::Type{T}, x::T) where {T<:Number} = x\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:198
msgid "Similar definitions exist for `AbstractString`, [`AbstractArray`](@ref), and [`AbstractDict`](@ref)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/conversion-and-promotion.md:199
#, no-wrap
msgid "Promotion"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:210
msgid ""
"Promotion refers to converting values of mixed types to a single common type. Although it is not strictly necessary, it is generally implied "
"that the common type to which the values are converted can faithfully represent all of the original values. In this sense, the term "
"\"promotion\" is appropriate since the values are converted to a \"greater\" type -- i.e. one which can represent all of the input values in "
"a single common type. It is important, however, not to confuse this with object-oriented (structural) super-typing, or Julia's notion of "
"abstract super-types: promotion has nothing to do with the type hierarchy, and everything to do with converting between alternate "
"representations.  For instance, although every [`Int32`](@ref) value can also be represented as a [`Float64`](@ref) value, `Int32` is not a "
"subtype of `Float64`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:215
msgid ""
"Promotion to a common \"greater\" type is performed in Julia by the [`promote`](@ref) function, which takes any number of arguments, and "
"returns a tuple of the same number of values, converted to a common type, or throws an exception if promotion is not possible. The most "
"common use case for promotion is to convert numeric arguments to a common type:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:216
#, no-wrap
msgid ""
"julia> promote(1, 2.5)\n"
"(1.0, 2.5)\n"
"\n"
"julia> promote(1, 2.5, 3)\n"
"(1.0, 2.5, 3.0)\n"
"\n"
"julia> promote(2, 3//4)\n"
"(2//1, 3//4)\n"
"\n"
"julia> promote(1, 2.5, 3, 3//4)\n"
"(1.0, 2.5, 3.0, 0.75)\n"
"\n"
"julia> promote(1.5, im)\n"
"(1.5 + 0.0im, 0.0 + 1.0im)\n"
"\n"
"julia> promote(1 + 2im, 3//4)\n"
"(1//1 + 2//1*im, 3//4 + 0//1*im)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:242
msgid ""
"Floating-point values are promoted to the largest of the floating-point argument types. Integer values are promoted to the larger of either "
"the native machine word size or the largest integer argument type. Mixtures of integers and floating-point values are promoted to a floating-"
"point type big enough to hold all the values. Integers mixed with rationals are promoted to rationals.  Rationals mixed with floats are "
"promoted to floats. Complex values mixed with real values are promoted to the appropriate kind of complex value."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:247
msgid ""
"That is really all there is to using promotions. The rest is just a matter of clever application, the most typical \"clever\" application "
"being the definition of catch-all methods for numeric operations like the arithmetic operators `+`, `-`, `*` and `/`. Here are some of the "
"catch-all method definitions given in [`promotion.jl`](https://github.com/JuliaLang/julia/blob/master/base/promotion.jl):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:248
#, no-wrap
msgid ""
"+(x::Number, y::Number) = +(promote(x,y)...)\n"
"-(x::Number, y::Number) = -(promote(x,y)...)\n"
"*(x::Number, y::Number) = *(promote(x,y)...)\n"
"/(x::Number, y::Number) = /(promote(x,y)...)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:266
msgid ""
"These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying and dividing pairs of numeric "
"values, promote the values to a common type and then try again. That's all there is to it: nowhere else does one ever need to worry about "
"promotion to a common numeric type for arithmetic operations -- it just happens automatically. There are definitions of catch-all promotion "
"methods for a number of other arithmetic and mathematical functions in [`promotion.jl`](https://github.com/JuliaLang/julia/blob/master/base/"
"promotion.jl), but beyond that, there are hardly any calls to `promote` required in Julia Base. The most common usages of `promote` occur in "
"outer constructors methods, provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields "
"promoted to an appropriate common type. For example, recall that [`rational.jl`](https://github.com/JuliaLang/julia/blob/master/base/"
"rational.jl)  provides the following outer constructor method:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:267
#, no-wrap
msgid "Rational(n::Integer, d::Integer) = Rational(promote(n,d)...)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:272
msgid "This allows calls like the following to work:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:273
#, no-wrap
msgid ""
"julia> Rational(Int8(15),Int32(-5))\n"
"-3//1\n"
"\n"
"julia> typeof(ans)\n"
"Rational{Int32}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:284
msgid ""
"For most user-defined types, it is better practice to require programmers to supply the expected types to constructor functions explicitly, "
"but sometimes, especially for numeric problems, it can be convenient to do promotion automatically."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/conversion-and-promotion.md:285
#, no-wrap
msgid "Defining Promotion Rules"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:293
msgid ""
"Although one could, in principle, define methods for the `promote` function directly, this would require many redundant definitions for all "
"possible permutations of argument types. Instead, the behavior of `promote` is defined in terms of an auxiliary function called "
"[`promote_rule`](@ref), which one can provide methods for. The `promote_rule` function takes a pair of type objects and returns another type "
"object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:294
#, no-wrap
msgid "promote_rule(::Type{Float64}, ::Type{Float32}) = Float64\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:301
msgid ""
"one declares that when 64-bit and 32-bit floating-point values are promoted together, they should be promoted to 64-bit floating-point. The "
"promotion type does not need to be one of the argument types, however; the following promotion rules both occur in Julia Base:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:302
#, no-wrap
msgid ""
"promote_rule(::Type{BigInt}, ::Type{Float64}) = BigFloat\n"
"promote_rule(::Type{BigInt}, ::Type{Int8}) = BigInt\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:312
msgid ""
"In the latter case, the result type is [`BigInt`](@ref) since `BigInt` is the only type large enough to hold integers for arbitrary-"
"precision integer arithmetic. Also note that one does not need to define both `promote_rule(::Type{A}, ::Type{B})` and `promote_rule(::"
"Type{B}, ::Type{A})` -- the symmetry is implied by the way `promote_rule` is used in the promotion process."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:317
msgid ""
"The `promote_rule` function is used as a building block to define a second function called [`promote_type`](@ref), which, given any number "
"of type objects, returns the common type to which those values, as arguments to `promote` should be promoted. Thus, if one wants to know, in "
"absence of actual values, what type a collection of values of certain types would promote to, one can use `promote_type`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:318
#, no-wrap
msgid ""
"julia> promote_type(Int8, Int64)\n"
"Int64\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:327
msgid ""
"Internally, `promote_type` is used inside of `promote` to determine what type argument values should be converted to for promotion. It can, "
"however, be useful in its own right. The curious reader can read the code in [`promotion.jl`](https://github.com/JuliaLang/julia/blob/master/"
"base/promotion.jl), which defines the complete promotion mechanism in about 35 lines."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/conversion-and-promotion.md:328
#, no-wrap
msgid "Case Study: Rational Promotions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:332
msgid ""
"Finally, we finish off our ongoing case study of Julia's rational number type, which makes relatively sophisticated use of the promotion "
"mechanism with the following promotion rules:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:333
#, no-wrap
msgid ""
"promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}\n"
"promote_rule(::Type{Rational{T}}, ::Type{Rational{S}}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}\n"
"promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:AbstractFloat} = promote_type(T,S)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:345
msgid ""
"The first rule says that promoting a rational number with any other integer type promotes to a rational type whose numerator/denominator "
"type is the result of promotion of its numerator/denominator type with the other integer type. The second rule applies the same logic to two "
"different types of rational numbers, resulting in a rational of the promotion of their respective numerator/denominator types. The third and "
"final rule dictates that promoting a rational with a float results in the same type as promoting the numerator/denominator type with the "
"float."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/conversion-and-promotion.md:350
msgid ""
"This small handful of promotion rules, together with the type's constructors and the default `convert` method for numbers, are sufficient to "
"make rational numbers interoperate completely naturally with all of Julia's other numeric types -- integers, floating-point numbers, and "
"complex numbers. By providing appropriate conversion methods and promotion rules in the same manner, any user-defined numeric type can "
"interoperate just as naturally with Julia's predefined numerics."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:1
#, no-wrap
msgid "Integers and Floating-Point Numbers"
msgstr "[æ´æ°ã¨æµ®åå°æ°ç¹æ°](@id integers-and-floating-point-numbers)"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:8
msgid ""
"Integers and floating-point values are the basic building blocks of arithmetic and computation.  Built-in representations of such values are "
"called numeric primitives, while representations of integers and floating-point numbers as immediate values in code are known as numeric "
"literals.  For example, `1` is an integer literal, while `1.0` is a floating-point literal; their binary in-memory representations as "
"objects are numeric primitives."
msgstr ""
"æ´æ°ã¨æµ®åå°æ°ç¹ã®å¤ã¯ãç®è¡ã¨è¨ç®ã®åºæ¬çãªæ§æè¦ç´ ã§ãã ãã®ãããªå¤ã®çµã¿è¾¼ã¿è¡¨ç¾ã¯æ°å¤ããªããã£ãã¨å¼ã°ããã³ã¼ãåã®å³æå¤ã¨ãã¦ã®æ´æ°"
"ã¨æµ®åå°æ°ç¹æ°ã®è¡¨ç¾ã¯æ°å¤ãªãã©ã«ã¨å¼ã°ãã¾ãã ãã¨ãã°ã`1` ã¯æ´æ°ãªãã©ã«ã§ã`1.0` ã¯æµ®åå°æ°ç¹ãªãã©ã«ã§ãããªãã¸ã§ã¯ãã¨ãã¦ã®ãã¤ããª"
"ã¤ã³ã¡ã¢ãªè¡¨ç¾ã¯æ°å¤ããªããã£ãã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:16
msgid ""
"Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard "
"mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern "
"computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for "
"[Arbitrary Precision Arithmetic](@ref), which can handle operations on numeric values that cannot be represented effectively in native "
"hardware representations, but at the cost of relatively slower performance."
msgstr ""
"Julia ã§ã¯ãæ§ããªããªããã£ãæ°å¤åãæä¾ããããã®ããããã®åã«å¯¾ãã¦ãæ¨æºçãªæ°å­¦é¢æ°ã¨åæ§ã«ãç®è¡æ¼ç®å­ã¨ãããæ¼ç®å­ãå®ç¾©ããã¦ãã¾"
"ãããããæ°å¤åãæ¼ç®ã¯ãææ°ã®ã³ã³ãã¥ã¼ã¿ã§ãã¤ãã£ãã«ãµãã¼ãããã¦ããæ°å¤åã¨æ¼ç®ã«ç´æ¥å¯¾å¿ä»ãããã¦ãããããJulia ã¯è¨ç®ãªã½ã¼ã¹ã"
"æå¤§éã«æ´»ç¨ã§ãã¾ããããã«ãJulia ã¯[ä»»æç²¾åº¦æ¼ç®](@ref arbitrary-precision-arithmetic)ãã½ããã¦ã§ã¢çã«ãµãã¼ããã¦ããããã¤ãã£ããªãã¼"
"ãã¦ã§ã¢è¡¨ç¾ã§ã¯è¡¨ç¾ã§ããªãæ°å¤ã®æ¼ç®ãæ±ãã¾ãããããã©ã¼ãã³ã¹ã¯æ¯è¼çéããªã£ã¦ãã¾ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:18
msgid "The following are Julia's primitive numeric types:"
msgstr "Juliaã®ããªããã£ãæ°å¤åãæ¬¡ã«ç¤ºãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:20
msgid "**Integer types:**"
msgstr "**æ´æ°å:**"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:34
#, no-wrap
msgid ""
"| Type              | Signed? | Number of bits | Smallest value | Largest value |\n"
"|:----------------- |:------- |:-------------- |:-------------- |:------------- |\n"
"| [`Int8`](@ref)    | â       | 8              | -2^7           | 2^7 - 1       |\n"
"| [`UInt8`](@ref)   | Â        | 8              | 0              | 2^8 - 1       |\n"
"| [`Int16`](@ref)   | â       | 16             | -2^15          | 2^15 - 1      |\n"
"| [`UInt16`](@ref)  | Â        | 16             | 0              | 2^16 - 1      |\n"
"| [`Int32`](@ref)   | â       | 32             | -2^31          | 2^31 - 1      |\n"
"| [`UInt32`](@ref)  | Â        | 32             | 0              | 2^32 - 1      |\n"
"| [`Int64`](@ref)   | â       | 64             | -2^63          | 2^63 - 1      |\n"
"| [`UInt64`](@ref)  | Â        | 64             | 0              | 2^64 - 1      |\n"
"| [`Int128`](@ref)  | â       | 128            | -2^127         | 2^127 - 1     |\n"
"| [`UInt128`](@ref) | Â        | 128            | 0              | 2^128 - 1     |\n"
"| [`Bool`](@ref)    | N/A     | 8              | `false` (0)    | `true` (1)    |\n"
msgstr ""
"| å              | ç¬¦å·ã®æç¡ | ãããæ° | æå°å¤ | æå¤§å¤ |\n"
"|:----------------- |:------- |:-------------- |:-------------- |:------------- |\n"
"| [`Int8`](@ref)    | â       | 8              | -2^7           | 2^7 - 1       |\n"
"| [`UInt8`](@ref)   | Â        | 8              | 0              | 2^8 - 1       |\n"
"| [`Int16`](@ref)   | â       | 16             | -2^15          | 2^15 - 1      |\n"
"| [`UInt16`](@ref)  | Â        | 16             | 0              | 2^16 - 1      |\n"
"| [`Int32`](@ref)   | â       | 32             | -2^31          | 2^31 - 1      |\n"
"| [`UInt32`](@ref)  | Â        | 32             | 0              | 2^32 - 1      |\n"
"| [`Int64`](@ref)   | â       | 64             | -2^63          | 2^63 - 1      |\n"
"| [`UInt64`](@ref)  | Â        | 64             | 0              | 2^64 - 1      |\n"
"| [`Int128`](@ref)  | â       | 128            | -2^127         | 2^127 - 1     |\n"
"| [`UInt128`](@ref) | Â        | 128            | 0              | 2^128 - 1     |\n"
"| [`Bool`](@ref)    | N/A     | 8              | `false` (0)    | `true` (1)    |\n"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:36
msgid "**Floating-point types:**"
msgstr "**æµ®åå°æ°ç¹å:**"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:42
#, no-wrap
msgid ""
"| Type              | Precision                                                                      | Number of bits |\n"
"|:----------------- |:------------------------------------------------------------------------------ |:-------------- |\n"
"| [`Float16`](@ref) | [half](https://en.wikipedia.org/wiki/Half-precision_floating-point_format)     | 16             |\n"
"| [`Float32`](@ref) | [single](https://en.wikipedia.org/wiki/Single_precision_floating-point_format) | 32             |\n"
"| [`Float64`](@ref) | [double](https://en.wikipedia.org/wiki/Double_precision_floating-point_format) | 64             |\n"
msgstr ""
"| å              | ç²¾åº¦                                                                      | ãããæ° |\n"
"|:----------------- |:------------------------------------------------------------------------------ |:-------------- |\n"
"| [`Float16`](@ref) | [half](https://en.wikipedia.org/wiki/Half-precision_floating-point_format)     | 16             |\n"
"| [`Float32`](@ref) | [single](https://en.wikipedia.org/wiki/Single_precision_floating-point_format) | 32             |\n"
"| [`Float64`](@ref) | [double](https://en.wikipedia.org/wiki/Double_precision_floating-point_format) | 64             |\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:46
msgid ""
"Additionally, full support for [Complex and Rational Numbers](@ref) is built on top of these primitive numeric types. All numeric types "
"interoperate naturally without explicit casting, thanks to a flexible, user-extensible [type promotion system](@ref conversion-and-"
"promotion)."
msgstr ""
"ããã«ããããã®ããªããã£ãæ°å¤åãç¨ãã¦ãJuliaã¯ [è¤ç´ æ°ã¨æçæ°](@ref complex-and-rational-numbers) ã«å®å¨å¯¾å¿ãã¦ãã¾ãããã¹ã¦ã®æ°å¤å"
"ã¯æç¤ºçãªã­ã£ã¹ããªãã§èªç¶ã«ç¸äºéç¨ããã¾ããããã¯æè»ã§ã¦ã¼ã¶ã¼ãæ¡å¼µå¯è½ãª [åææ ¼ã·ã¹ãã ](@ref conversion-and-promotion)ã®ãããã§"
"ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:47 ext/julia/doc/src/base/numbers.md:99
#, no-wrap
msgid "Integers"
msgstr "æ´æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:50
msgid "Literal integers are represented in the standard manner:"
msgstr "æ´æ°ãªãã©ã«ã¯ãæ¨æºçãªæ¹æ³ã§è¡¨ç¾ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:51
#, no-wrap
msgid ""
"julia> 1\n"
"1\n"
"\n"
"julia> 1234\n"
"1234\n"
msgstr ""
"julia> 1\n"
"1\n"
"\n"
"julia> 1234\n"
"1234\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:61
msgid "The default type for an integer literal depends on whether the target system has a 32-bit architecture or a 64-bit architecture:"
msgstr ""
"æ´æ°ãªãã©ã«ã®ããã©ã«ãã®åã¯ãã¿ã¼ã²ããã»ã·ã¹ãã ã 32 ãããã»ã¢ã¼ã­ãã¯ãã£ã¼ã¨ 64 ãããã»ã¢ã¼ã­ãã¯ãã£ã¼ã®ã©ã¡ãã§ãããã«ãã£ã¦ç°ãª"
"ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:62
#, no-wrap
msgid ""
"# 32-bit system:\n"
"julia> typeof(1)\n"
"Int32\n"
"\n"
"# 64-bit system:\n"
"julia> typeof(1)\n"
"Int64\n"
msgstr ""
"# 32-bit system:\n"
"julia> typeof(1)\n"
"Int32\n"
"\n"
"# 64-bit system:\n"
"julia> typeof(1)\n"
"Int64\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:74
msgid "The Julia internal variable [`Sys.WORD_SIZE`](@ref) indicates whether the target system is 32-bit or 64-bit:"
msgstr "Julia ã®åé¨å¤æ° [`Sys.WORD_SIZE`](@ref) ãè¦ãã¨ãã¿ã¼ã²ããã»ã·ã¹ãã ã 32 ãããã 64 ããããããããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:75
#, no-wrap
msgid ""
"# 32-bit system:\n"
"julia> Sys.WORD_SIZE\n"
"32\n"
"\n"
"# 64-bit system:\n"
"julia> Sys.WORD_SIZE\n"
"64\n"
msgstr ""
"# 32-bit system:\n"
"julia> Sys.WORD_SIZE\n"
"32\n"
"\n"
"# 64-bit system:\n"
"julia> Sys.WORD_SIZE\n"
"64\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:87
msgid ""
"Julia also defines the types `Int` and `UInt`, which are aliases for the system's signed and unsigned native integer types respectively:"
msgstr ""
"Julia ã«ã¯ãã·ã¹ãã ã®ç¬¦å·ä»ããã¤ãã£ãæ´æ°åã¨ç¬¦å·ãªããã¤ãã£ãæ´æ°åã®ã¨ã¤ãªã¢ã¹ã§ãã `Int` åã¨ `UInt` ãããããå®ç¾©ããã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:88
#, no-wrap
msgid ""
"# 32-bit system:\n"
"julia> Int\n"
"Int32\n"
"julia> UInt\n"
"UInt32\n"
"\n"
"# 64-bit system:\n"
"julia> Int\n"
"Int64\n"
"julia> UInt\n"
"UInt64\n"
msgstr ""
"# 32-bit system:\n"
"julia> Int\n"
"Int32\n"
"julia> UInt\n"
"UInt32\n"
"\n"
"# 64-bit system:\n"
"julia> Int\n"
"Int64\n"
"julia> UInt\n"
"UInt64\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:104
msgid ""
"Larger integer literals that cannot be represented using only 32 bits but can be represented in 64 bits always create 64-bit integers, "
"regardless of the system type:"
msgstr ""
"å¤§ããªæ´æ°ãªãã©ã«ã§ã32 ãããã®ã¿ãä½¿ç¨ãã¦è¡¨ããã¨ãã§ããã64 ãããã§è¡¨ããã¨ãã§ãããã®ã«å¯¾ãã¦ã¯ãã·ã¹ãã ã®ç¨®é¡ã«é¢ä¿ãªããå¸¸ã« 64 "
"ãããã®æ´æ°ãçæããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:105
#, no-wrap
msgid ""
"# 32-bit or 64-bit system:\n"
"julia> typeof(3000000000)\n"
"Int64\n"
msgstr ""
"# 32-bit or 64-bit system:\n"
"julia> typeof(3000000000)\n"
"Int64\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:114
msgid ""
"Unsigned integers are input and output using the `0x` prefix and hexadecimal (base 16) digits `0-9a-f` (the capitalized digits `A-F` also "
"work for input). The size of the unsigned value is determined by the number of hex digits used:"
msgstr ""
"ç¬¦å·ãªãã®æ´æ°ã®å¥åºåã«ã¯ã`0x` ãã¬ãã£ãã¯ã¹ãæã¤16é²æ°ã®æ°å­ `0-9a-f` (å¤§æå­ã®æ°å­ `A-F` ãå©ç¨å¯è½)ãä½¿ãã¾ããç¬¦å·ãªãã®å¤ã®ãµã¤ãº"
"ã¯ãä½¿ç¨ãã16é²æ°ã®æ¡æ°ã§æ±ºã¾ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:115
#, no-wrap
msgid ""
"julia> 0x1\n"
"0x01\n"
"\n"
"julia> typeof(ans)\n"
"UInt8\n"
"\n"
"julia> 0x123\n"
"0x0123\n"
"\n"
"julia> typeof(ans)\n"
"UInt16\n"
"\n"
"julia> 0x1234567\n"
"0x01234567\n"
"\n"
"julia> typeof(ans)\n"
"UInt32\n"
"\n"
"julia> 0x123456789abcdef\n"
"0x0123456789abcdef\n"
"\n"
"julia> typeof(ans)\n"
"UInt64\n"
"\n"
"julia> 0x11112222333344445555666677778888\n"
"0x11112222333344445555666677778888\n"
"\n"
"julia> typeof(ans)\n"
"UInt128\n"
msgstr ""
"julia> 0x1\n"
"0x01\n"
"\n"
"julia> typeof(ans)\n"
"UInt8\n"
"\n"
"julia> 0x123\n"
"0x0123\n"
"\n"
"julia> typeof(ans)\n"
"UInt16\n"
"\n"
"julia> 0x1234567\n"
"0x01234567\n"
"\n"
"julia> typeof(ans)\n"
"UInt32\n"
"\n"
"julia> 0x123456789abcdef\n"
"0x0123456789abcdef\n"
"\n"
"julia> typeof(ans)\n"
"UInt64\n"
"\n"
"julia> 0x11112222333344445555666677778888\n"
"0x11112222333344445555666677778888\n"
"\n"
"julia> typeof(ans)\n"
"UInt128\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:150
msgid ""
"This behavior is based on the observation that when one uses unsigned hex literals for integer values, one typically is using them to "
"represent a fixed numeric byte sequence, rather than just an integer value."
msgstr ""
"ããããæ¯ãèãã¯ãç¬¦å·ãªãæ´æ°ã®16é²ãªãã©ã«ãä½¿ç¨ããå ´åãéå¸¸ã¯ãåãªãæ´æ°å¤ã¨ããããã¯ãåºå®é·ãã¤ãåã¨ãã¦ä½¿ããããã¨ãå¤ãã ãã"
"ã¨ããèå¯ã«åºã¥ãã¦ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:153
msgid ""
"Recall that the variable [`ans`](@ref) is set to the value of the last expression evaluated in an interactive session. This does not occur "
"when Julia code is run in other ways."
msgstr ""
"å¤æ° [`ans`](@ref) ã«ã¯ãå¯¾è©±åã»ãã·ã§ã³ã§æå¾ã«è©ä¾¡ãããå¼ã®å¤ãæ ¼ç´ããã¦ãããã¨ãæãåºãã¦ãã ãããããã¯ãJulia ã³ã¼ããå¯¾è©±ã»ãã·ã§"
"ã³ä»¥å¤ã®ä»ã®æ¹æ³ã§å®è¡ããã¦ããå ´åã«ã¯ãã¦ã¯ã¾ãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:155
msgid "Binary and octal literals are also supported:"
msgstr "2é²æ°ã»8é²æ°ãªãã©ã«ã«ãå¯¾å¿ãã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:156
#, no-wrap
msgid ""
"julia> 0b10\n"
"0x02\n"
"\n"
"julia> typeof(ans)\n"
"UInt8\n"
"\n"
"julia> 0o010\n"
"0x08\n"
"\n"
"julia> typeof(ans)\n"
"UInt8\n"
"\n"
"julia> 0x00000000000000001111222233334444\n"
"0x00000000000000001111222233334444\n"
"\n"
"julia> typeof(ans)\n"
"UInt128\n"
msgstr ""
"julia> 0b10\n"
"0x02\n"
"\n"
"julia> typeof(ans)\n"
"UInt8\n"
"\n"
"julia> 0o010\n"
"0x08\n"
"\n"
"julia> typeof(ans)\n"
"UInt8\n"
"\n"
"julia> 0x00000000000000001111222233334444\n"
"0x00000000000000001111222233334444\n"
"\n"
"julia> typeof(ans)\n"
"UInt128\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:182
msgid ""
"As for hexadecimal literals, binary and octal literals produce unsigned integer types. The size of the binary data item is the minimal "
"needed size, if the leading digit of the literal is not `0`. In the case of leading zeros, the size is determined by the minimal needed size "
"for a literal, which has the same length but leading digit `1`. That allows the user to control the size.  Values which cannot be stored in "
"`UInt128` cannot be written as such literals."
msgstr ""
"16é²ã»2é²ã»8é²ãªãã©ã«ã«å¯¾ãã¦ã¯ãç¬¦å·ãªãæ´æ°åãçæããã¾ãããªãã©ã«ã®åé ­æ¡ã `0` ã§åããªãå ´åããã¤ããª ãã¼ã¿ã®ãµã¤ãºã¯å¿è¦æå°éã®"
"ãµã¤ãºã«ãªãã¾ããåé ­ã«ã¼ã­ãä»å ããã¦ããå ´åããã®åé ­ã®æ¡ã`1`ã§ããåãæ¡æ°ã®ãªãã©ã«ã«å¿è¦ãªæå°ãµã¤ãºã«ãªãã¾ããããã«ãããã¦ã¼ã¶ã¼"
"ã¯ãã¼ã¿ã®ãµã¤ãºãå¶å¾¡ã§ãã¾ãã `UInt128` ã«æ ¼ç´ã§ããªãå¤ã¯ããã®ãããªãªãã©ã«ã¨ãã¦è¨è¿°ã§ãã¾ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:186
msgid ""
"Binary, octal, and hexadecimal literals may be signed by a `-` immediately preceding the unsigned literal. They produce an unsigned integer "
"of the same size as the unsigned literal would do, with the two's complement of the value:"
msgstr ""
"2é²ã»8é²ã»16é²ãªãã©ã«ã¯ããªãã©ã«ã®ç´åã« `-` ã®ç¬¦å·ãã¤ãããã¨ãã§ãã¾ãããã®å ´åçæãããã®ã¯ãç¬¦å·ãä»ããåã®æ°ã¨ãµã¤ãºã®ç­ããç¬¦å·ãª"
"ãã®æ´æ°ã§ãåã®æ°ã®2ã®è£æ°è¡¨ç¾ã«ãªãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:187
#, no-wrap
msgid ""
"julia> -0x2\n"
"0xfe\n"
"\n"
"julia> -0x0002\n"
"0xfffe\n"
msgstr ""
"julia> -0x2\n"
"0xfe\n"
"\n"
"julia> -0x0002\n"
"0xfffe\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:197
msgid ""
"The minimum and maximum representable values of primitive numeric types such as integers are given by the [`typemin`](@ref) and [`typemax`]"
"(@ref) functions:"
msgstr "æ´æ°ãªã©ã®ããªããã£ãæ°å¤åã®æå°ã»æå¤§å¤ã¯ã[`typemin`](@ref) é¢æ°ã¨ [`typemax`](@ref) é¢æ°ã«ãã£ã¦å¾ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:198
#, no-wrap
msgid ""
"julia> (typemin(Int32), typemax(Int32))\n"
"(-2147483648, 2147483647)\n"
"\n"
"julia> for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]\n"
"           println(\"$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]\")\n"
"       end\n"
"   Int8: [-128,127]\n"
"  Int16: [-32768,32767]\n"
"  Int32: [-2147483648,2147483647]\n"
"  Int64: [-9223372036854775808,9223372036854775807]\n"
" Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]\n"
"  UInt8: [0,255]\n"
" UInt16: [0,65535]\n"
" UInt32: [0,4294967295]\n"
" UInt64: [0,18446744073709551615]\n"
"UInt128: [0,340282366920938463463374607431768211455]\n"
msgstr ""
"julia> (typemin(Int32), typemax(Int32))\n"
"(-2147483648, 2147483647)\n"
"\n"
"julia> for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]\n"
"           println(\"$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]\")\n"
"       end\n"
"   Int8: [-128,127]\n"
"  Int16: [-32768,32767]\n"
"  Int32: [-2147483648,2147483647]\n"
"  Int64: [-9223372036854775808,9223372036854775807]\n"
" Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]\n"
"  UInt8: [0,255]\n"
" UInt16: [0,65535]\n"
" UInt32: [0,4294967295]\n"
" UInt64: [0,18446744073709551615]\n"
"UInt128: [0,340282366920938463463374607431768211455]\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:221
msgid ""
"The values returned by [`typemin`](@ref) and [`typemax`](@ref) are always of the given argument type. (The above expression uses several "
"features that have yet to be introduced, including [for loops](@ref man-loops), [Strings](@ref man-strings), and [Interpolation](@ref), but "
"should be easy enough to understand for users with some existing programming experience.)"
msgstr ""
"[`typemin`](@ref)ã¨[`typemax`](@ref)ã«ãã£ã¦è¿ãããå¤ã¯ããã®é¢æ°ã«å¼æ°ã¨ãã¦ä¸ããããåã®æ°å¤ã«ãªãã¾ãã(ä¸è¨ã®å¼ã§ã¯ã[for ã«ã¼ã](@ref "
"man-loops)ã[æå­å](@ref man-strings)ã[å¼å±é](@ref command-interpolation)ãªã©ãã¾ã ç´¹ä»ãã¦ããªãæ©è½ãããã¤ãä½¿ç¨ãã¦ãã¾ããããã­ã°ã©"
"ãã³ã°çµé¨ãæã¤ã¦ã¼ã¶ã¼ã«ã¨ã£ã¦ã¯ååã«çè§£ã§ãããã®ã§ãããã)"

#. type: Title ###
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:222
#, no-wrap
msgid "Overflow behavior"
msgstr "ãªã¼ãã¼ãã­ã¼æã®åä½"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:225
msgid "In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:"
msgstr "Julia ã§ã¯ããã®åã§è¡¨ç¾å¯è½ãªå¤ã®ç¯å²ãè¶ããã¨ãã©ããã¢ã©ã¦ã³ã(å¾ªç°)ãçºçãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:226
#, no-wrap
msgid ""
"julia> x = typemax(Int64)\n"
"9223372036854775807\n"
"\n"
"julia> x + 1\n"
"-9223372036854775808\n"
"\n"
"julia> x + 1 == typemin(Int64)\n"
"true\n"
msgstr ""
"julia> x = typemax(Int64)\n"
"9223372036854775807\n"
"\n"
"julia> x + 1\n"
"-9223372036854775808\n"
"\n"
"julia> x + 1 == typemin(Int64)\n"
"true\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:242
msgid ""
"Thus, arithmetic with Julia integers is actually a form of [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic).  This "
"reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is "
"possible, explicit checking for wraparound produced by overflow is essential; otherwise, the [`BigInt`](@ref) type in [Arbitrary Precision "
"Arithmetic](@ref)  is recommended instead."
msgstr ""
"ãããã£ã¦ãJulia ã®æ´æ°åã§ã®æ¼ç®ã¯ãå®éã«ã¯ [ã¢ã¸ã¥ã©ã¼æ¼ç®](https://en.wikipedia.org/wiki/Modular_arithmetic)ã®ä¸å½¢æã§ãã ããã¯ãç¾ä»£"
"ã®ã³ã³ãã¥ã¼ã¿ã«å®è£ããã¦ããæ´æ°ã®åºç¤ã¨ãªãç®è¡æ¼ç®ã®ç¹å¾´ãåæ ãã¦ãã¾ãããªã¼ãã¼ãã­ã¼ãèµ·ããå¾ãã¢ããªã±ã¼ã·ã§ã³ã§ã¯ããªã¼ãã¼ãã­ã¼"
"ã«ãã£ã¦çæãããã©ããã¢ã©ã¦ã³ããæç¤ºçã«ãã§ãã¯ãããã¨ãä¸å¯æ¬ ã§ããããã§ãªããã°ãä»£ããã«[ä»»æç²¾åº¦æ¼ç®](@ref arbitrary-precision-"
"arithmetic)ã®[`BigInt`](@ref)åãä½¿ç¨ãããã¨ããå§ããã¾ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:243
#, no-wrap
msgid "Division errors"
msgstr "é¤ç®ã¨ã©ã¼"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:249
msgid ""
"Integer division (the `div` function) has two exceptional cases: dividing by zero, and dividing the lowest negative number ([`typemin`]"
"(@ref)) by -1. Both of these cases throw a [`DivideError`](@ref).  The remainder and modulus functions (`rem` and `mod`) throw a "
"[`DivideError`](@ref) when their second argument is zero."
msgstr ""
"æ´æ°é¤ç® (`div` é¢æ°) ã«ã¯ 2ã¤ã®ä¾å¤çãªã±ã¼ã¹ãããã¾ããä¸ã¤ã¯ã0 é¤ç®ãããã²ã¨ã¤ã¯ãæå°ã®è² ã®æ° ([`typemin`](@ref)) ã® -1 é¤ç®ã§ããã©ã¡"
"ãã®å ´åã[`DivideError`](@ref)ãã¹ã­ã¼ãã¾ãã ã¾ããå°ä½é¢æ° (`rem` ã¨ `mod`) ã¯ã2 çªç®ã®å¼æ°ãã¼ã­ã®å ´åã« [`DivideError`](@ref)ãã¹ã­ã¼"
"ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:250
#, no-wrap
msgid "Floating-Point Numbers"
msgstr "æµ®åå°æ°ç¹æ°"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:254
msgid ""
"Literal floating-point numbers are represented in the standard formats, using [E-notation](https://en.wikipedia.org/wiki/"
"Scientific_notation#E-notation) when necessary:"
msgstr ""
"æµ®åå°æ°ç¹ãªãã©ã«ã¯ãå¿è¦ã«å¿ãã¦[e-è¡¨è¨](https://en.wikipedia.org/wiki/Scientific_notation#E-è¡¨è¨)ãä½¿ç¨ãã¦ãæ¨æºãã©ã¼ãããã§è¡¨è¨ããã¾"
"ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:255
#, no-wrap
msgid ""
"julia> 1.0\n"
"1.0\n"
"\n"
"julia> 1.\n"
"1.0\n"
"\n"
"julia> 0.5\n"
"0.5\n"
"\n"
"julia> .5\n"
"0.5\n"
"\n"
"julia> -1.23\n"
"-1.23\n"
"\n"
"julia> 1e10\n"
"1.0e10\n"
"\n"
"julia> 2.5e-4\n"
"0.00025\n"
msgstr ""
"julia> 1.0\n"
"1.0\n"
"\n"
"julia> 1.\n"
"1.0\n"
"\n"
"julia> 0.5\n"
"0.5\n"
"\n"
"julia> .5\n"
"0.5\n"
"\n"
"julia> -1.23\n"
"-1.23\n"
"\n"
"julia> 1e10\n"
"1.0e10\n"
"\n"
"julia> 2.5e-4\n"
"0.00025\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:280
msgid "The above results are all [`Float64`](@ref) values. Literal [`Float32`](@ref) values can be entered by writing an `f` in place of `e`:"
msgstr "ä¸è¨ã®çµæã¯ãã¹ã¦ [`Float64`](@ref) å¤ã§ãããªãã©ã« [`Float32`](@ref) å¤ã¯ã`e` ã®ä»£ããã« `f` ãæ¸ããã¨ã«ãã£ã¦å¥åã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:281
#, no-wrap
msgid ""
"julia> 0.5f0\n"
"0.5f0\n"
"\n"
"julia> typeof(ans)\n"
"Float32\n"
"\n"
"julia> 2.5f-4\n"
"0.00025f0\n"
msgstr ""
"julia> 0.5f0\n"
"0.5f0\n"
"\n"
"julia> typeof(ans)\n"
"Float32\n"
"\n"
"julia> 2.5f-4\n"
"0.00025f0\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:293
msgid "Values can be converted to [`Float32`](@ref) easily:"
msgstr "å¤ã¯[`Float32`](@ref)ã«ç°¡åã«å¤æã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:294
#, no-wrap
msgid ""
"julia> Float32(-1.5)\n"
"-1.5f0\n"
"\n"
"julia> typeof(ans)\n"
"Float32\n"
msgstr ""
"julia> Float32(-1.5)\n"
"-1.5f0\n"
"\n"
"julia> typeof(ans)\n"
"Float32\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:304
msgid "Hexadecimal floating-point literals are also valid, but only as [`Float64`](@ref) values, with `p` preceding the base-2 exponent:"
msgstr "16é²è¡¨è¨ã®æµ®åå°æ°ç¹ãªãã©ã«ãæå¹ã§ãããåºæ°2ã®ææ°ã®åã« `p` ãã¤ãã¦å©ç¨ããå¤ã¯ [`Float64`](@ref)ã«ãªãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:305
#, no-wrap
msgid ""
"julia> 0x1p0\n"
"1.0\n"
"\n"
"julia> 0x1.8p3\n"
"12.0\n"
"\n"
"julia> 0x.4p-1\n"
"0.125\n"
"\n"
"julia> typeof(ans)\n"
"Float64\n"
msgstr ""
"julia> 0x1p0\n"
"1.0\n"
"\n"
"julia> 0x1.8p3\n"
"12.0\n"
"\n"
"julia> 0x.4p-1\n"
"0.125\n"
"\n"
"julia> typeof(ans)\n"
"Float64\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:321
msgid ""
"Half-precision floating-point numbers are also supported ([`Float16`](@ref)), but they are implemented in software and use [`Float32`](@ref) "
"for calculations."
msgstr "åç²¾åº¦æµ®åå°æ°ç¹æ°([`Float16`](@ref))ããµãã¼ãããã¦ãã¾ãããããã¯ã½ããã¦ã§ã¢ã§å®è£ãããè¨ç®ã« [`Float32`](@ref) ãä½¿ç¨ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:322
#, no-wrap
msgid ""
"julia> sizeof(Float16(4.))\n"
"2\n"
"\n"
"julia> 2*Float16(4.)\n"
"Float16(8.0)\n"
msgstr ""
"julia> sizeof(Float16(4.))\n"
"2\n"
"\n"
"julia> 2*Float16(4.)\n"
"Float16(8.0)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:331
msgid "The underscore `_` can be used as digit separator:"
msgstr "ã¢ã³ãã¼ã¹ã³ã¢ `_` ã¯ãæ°å­åºåãæå­ã¨ãã¦ä½¿ç¨ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:332
#, no-wrap
msgid ""
"julia> 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010\n"
"(10000, 5.0e-9, 0xdeadbeef, 0xb2)\n"
msgstr ""
"julia> 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010\n"
"(10000, 5.0e-9, 0xdeadbeef, 0xb2)\n"

#. type: Title ###
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:337
#, no-wrap
msgid "Floating-point zero"
msgstr "æµ®åå°æ°ç¹ ã®0"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:342
msgid ""
"Floating-point numbers have [two zeros](https://en.wikipedia.org/wiki/Signed_zero), positive zero and negative zero. They are equal to each "
"other but have different binary representations, as can be seen using the [`bitstring`](@ref) function:"
msgstr ""
"æµ®åå°æ°ç¹æ°ã«ã¯æ­£ã¨è² [2 ã¤ã®ã¼ã­](https://en.wikipedia.org/wiki/Signed_zero)ãããã¾ãããããã¯äºãã«ç­ããå¤ã§ãããç°ãªã2é²æ°è¡¨ç¾ãæã£"
"ã¦ãã¾ãã[`bitstring`](@ref) é¢æ°ã§ç¢ºèªãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:343
#, no-wrap
msgid ""
"julia> 0.0 == -0.0\n"
"true\n"
"\n"
"julia> bitstring(0.0)\n"
"\"0000000000000000000000000000000000000000000000000000000000000000\"\n"
"\n"
"julia> bitstring(-0.0)\n"
"\"1000000000000000000000000000000000000000000000000000000000000000\"\n"
msgstr ""
"julia> 0.0 == -0.0\n"
"true\n"
"\n"
"julia> bitstring(0.0)\n"
"\"0000000000000000000000000000000000000000000000000000000000000000\"\n"
"\n"
"julia> bitstring(-0.0)\n"
"\"1000000000000000000000000000000000000000000000000000000000000000\"\n"

#. type: Title ###
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:354
#, no-wrap
msgid "Special floating-point values"
msgstr "[ç¹æ®ãªæµ®åå°æ°ç¹ã®å¤](@id special-floating-point-values)"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:358
msgid "There are three specified standard floating-point values that do not correspond to any point on the real number line:"
msgstr "æµ®åå°æ°ç¹ã®å¤ã§å®æ°ã®æ°ç´ç·ä¸ã®ã©ã®ç¹ã«ãå¯¾å¿ããªãå¤ã3ã¤ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:364
#, no-wrap
msgid ""
"| `Float16` | `Float32` | `Float64` | Name              | Description                                                     |\n"
"|:--------- |:--------- |:--------- |:----------------- |:--------------------------------------------------------------- |\n"
"| `Inf16`   | `Inf32`   | `Inf`     | positive infinity | a value greater than all finite floating-point values           |\n"
"| `-Inf16`  | `-Inf32`  | `-Inf`    | negative infinity | a value less than all finite floating-point values              |\n"
"| `NaN16`   | `NaN32`   | `NaN`     | not a number      | a value not `==` to any floating-point value (including itself) |\n"
msgstr ""
"| `Float16` | `Float32` | `Float64` | åå              | èª¬æ                                                     |\n"
"|:--------- |:--------- |:--------- |:----------------- |:--------------------------------------------------------------- |\n"
"| `Inf16`   | `Inf32`   | `Inf`     | æ­£ã®ç¡éå¤§ | ãã¹ã¦ã®æéã®æµ®åå°æ°ç¹æ°ãããå¤§ããå¤           |\n"
"| `-Inf16`  | `-Inf32`  | `-Inf`    | è² ã®ç¡éå¤§ | ãã¹ã¦ã®æéã®æµ®åå°æ°ç¹ãããå°ããå¤              |\n"
"| `NaN16`   | `NaN32`   | `NaN`     | éæ°      | ã©ããªæµ®åå°æ°ç¹æ°ã¨ã `==`ã®æãç«ããªãå¤ (èªåèªèº«ã¨ã)  |\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:368
msgid ""
"For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see [Numeric "
"Comparisons](@ref). By the [IEEE 754 standard](https://en.wikipedia.org/wiki/IEEE_754-2008), these floating-point values are the results of "
"certain arithmetic operations:"
msgstr ""
"ãããéæéã®æµ®åå°æ°ç¹å¤ãäºãã«ã©ã®ããã«é åºä»ãããããã«ã¤ãã¦ã®è©³ç´°ã¯ã[æ°å¤ã®æ¯è¼](@ref numeric-comparisons)ãåç§ãã¦ãã ããã"
"[IEEE 754 è¦æ ¼](https://en.wikipedia.org/wiki/IEEE_754-2008)ã§ã¯ããããã®æµ®åå°æ°ç¹æ°ã®å¤ã¯ç¹å®ã®ç®è¡æ¼ç®ã®çµæã¨ãã¦å¾ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:369
#, no-wrap
msgid ""
"julia> 1/Inf\n"
"0.0\n"
"\n"
"julia> 1/0\n"
"Inf\n"
"\n"
"julia> -5/0\n"
"-Inf\n"
"\n"
"julia> 0.000001/0\n"
"Inf\n"
"\n"
"julia> 0/0\n"
"NaN\n"
"\n"
"julia> 500 + Inf\n"
"Inf\n"
"\n"
"julia> 500 - Inf\n"
"-Inf\n"
"\n"
"julia> Inf + Inf\n"
"Inf\n"
"\n"
"julia> Inf - Inf\n"
"NaN\n"
"\n"
"julia> Inf * Inf\n"
"Inf\n"
"\n"
"julia> Inf / Inf\n"
"NaN\n"
"\n"
"julia> 0 * Inf\n"
"NaN\n"
msgstr ""
"julia> 1/Inf\n"
"0.0\n"
"\n"
"julia> 1/0\n"
"Inf\n"
"\n"
"julia> -5/0\n"
"-Inf\n"
"\n"
"julia> 0.000001/0\n"
"Inf\n"
"\n"
"julia> 0/0\n"
"NaN\n"
"\n"
"julia> 500 + Inf\n"
"Inf\n"
"\n"
"julia> 500 - Inf\n"
"-Inf\n"
"\n"
"julia> Inf + Inf\n"
"Inf\n"
"\n"
"julia> Inf - Inf\n"
"NaN\n"
"\n"
"julia> Inf * Inf\n"
"Inf\n"
"\n"
"julia> Inf / Inf\n"
"NaN\n"
"\n"
"julia> 0 * Inf\n"
"NaN\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:408
msgid "The [`typemin`](@ref) and [`typemax`](@ref) functions also apply to floating-point types:"
msgstr "[`typemin`](@ref)é¢æ°ã¨[`typemax`](@ref)é¢æ°ã¯æµ®åå°æ°ç¹åã«ãé©ç¨ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:409
#, no-wrap
msgid ""
"julia> (typemin(Float16),typemax(Float16))\n"
"(-Inf16, Inf16)\n"
"\n"
"julia> (typemin(Float32),typemax(Float32))\n"
"(-Inf32, Inf32)\n"
"\n"
"julia> (typemin(Float64),typemax(Float64))\n"
"(-Inf, Inf)\n"
msgstr ""
"julia> (typemin(Float16),typemax(Float16))\n"
"(-Inf16, Inf16)\n"
"\n"
"julia> (typemin(Float32),typemax(Float32))\n"
"(-Inf32, Inf32)\n"
"\n"
"julia> (typemin(Float64),typemax(Float64))\n"
"(-Inf, Inf)\n"

#. type: Title ###
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:420
#, no-wrap
msgid "Machine epsilon"
msgstr "ãã·ã³ã¤ãã·ã­ã³"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:425
msgid ""
"Most real numbers cannot be represented exactly with floating-point numbers, and so for many purposes it is important to know the distance "
"between two adjacent representable floating-point numbers, which is often known as [machine epsilon](https://en.wikipedia.org/wiki/"
"Machine_epsilon)."
msgstr ""
"ã»ã¨ãã©ã®å®æ°ã¯æµ®åå°æ°ç¹æ°ã§æ­£ç¢ºã«è¡¨ç¾ãããã¨ãã§ããªããããå¤ãã®ç®çã§ã2ã¤ã®é£æ¥ããæµ®åå°æ°ç¹æ°ã®éã®è·é¢ãç¥ããã¨ã¯éè¦ãªãã¨ã§ãã"
"ããã¯ã[ãã·ã³ã¤ãã·ã­ã³](https://en.wikipedia.org/wiki/Machine_epsilon) ã¨ãã¦ç¥ããã¦ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:428
msgid "Julia provides [`eps`](@ref), which gives the distance between `1.0` and the next larger representable floating-point value:"
msgstr ""
"Julia ã§ã¯ [`eps`](@ref) é¢æ°ã§ãåæ°å¤åãå¼æ°ã«ã¨ãããã®åã«ããã¦ã® `1.0` ã¨ããå¤ã¨ããã®å¤ã®æ¬¡ã«å¤§ããªæµ®åå°æ°ç¹æ°ã®éã®è·é¢ãå¾ããã¨"
"ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:429
#, no-wrap
msgid ""
"julia> eps(Float32)\n"
"1.1920929f-7\n"
"\n"
"julia> eps(Float64)\n"
"2.220446049250313e-16\n"
"\n"
"julia> eps() # same as eps(Float64)\n"
"2.220446049250313e-16\n"
msgstr ""
"julia> eps(Float32)\n"
"1.1920929f-7\n"
"\n"
"julia> eps(Float64)\n"
"2.220446049250313e-16\n"
"\n"
"julia> eps() # same as eps(Float64)\n"
"2.220446049250313e-16\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:445
msgid ""
"These values are `2.0^-23` and `2.0^-52` as [`Float32`](@ref) and [`Float64`](@ref) values, respectively. The [`eps`](@ref) function can "
"also take a floating-point value as an argument, and gives the absolute difference between that value and the next representable floating "
"point value. That is, `eps(x)` yields a value of the same type as `x` such that `x + eps(x)` is the next representable floating-point value "
"larger than `x`:"
msgstr ""
"ãããã®å¤ã`2.0^-23`ã¨`2.0^-52`ã¯ãããã [`Float32`](@ref)ã¨[`Float64`](@ref)ã®å¤ã§ãã[`eps`](@ref) é¢æ°ã¯ãå¼æ°ã¨ãã¦æµ®åå°æ°ç¹æ°ãåãå"
"ããã¨ãã§ãããã®å¤ã¨æ¬¡ã«è¡¨ãããæµ®åå°æ°ç¹å¤ã¨ã®å·®ã®çµ¶å¯¾å¤ãè¿ãã¾ããã¤ã¾ã`eps(x)` ã¯ `x` ã¨åãåã®å¤ãçæãã`x + eps(x)` ã¯ `x` ãã"
"å¤§ããæ¬¡ã«è¡¨ãããæµ®åå°æ°ç¹å¤ã«ãªãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:446
#, no-wrap
msgid ""
"julia> eps(1.0)\n"
"2.220446049250313e-16\n"
"\n"
"julia> eps(1000.)\n"
"1.1368683772161603e-13\n"
"\n"
"julia> eps(1e-27)\n"
"1.793662034335766e-43\n"
"\n"
"julia> eps(0.0)\n"
"5.0e-324\n"
msgstr ""
"julia> eps(1.0)\n"
"2.220446049250313e-16\n"
"\n"
"julia> eps(1000.)\n"
"1.1368683772161603e-13\n"
"\n"
"julia> eps(1e-27)\n"
"1.793662034335766e-43\n"
"\n"
"julia> eps(0.0)\n"
"5.0e-324\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:465
msgid ""
"The distance between two adjacent representable floating-point numbers is not constant, but is smaller for smaller values and larger for "
"larger values. In other words, the representable floating-point numbers are densest in the real number line near zero, and grow sparser "
"exponentially as one moves farther away from zero. By definition, `eps(1.0)` is the same as `eps(Float64)` since `1.0` is a 64-bit floating-"
"point value."
msgstr ""
"é£æ¥ãã 2 ã¤ã® è¡¨ç¾å¯è½ãªæµ®åå°æ°ç¹æ°ã®éã®è·é¢ã¯ä¸å®ã§ã¯ãªãããã®è·é¢ã¯åã®å¤ãå°ããã»ã©å°ãããªããå¤§ããã»ã©å¤§ãããªãã¾ããã¤ã¾ããè¡¨"
"ç¾å¯è½ãªæµ®åå°æ°ç¹æ°ã®æ°ç´ç·ã¯0ä»è¿ã§æãå¯åº¦ãé«ãã0ããé ãããã«ã¤ãã¦ææ°é¢æ°çã«çã«ãªãã¾ããå®ç¾©ä¸ã`1.0` ã¯ 64 ãããæµ®åå°æ°ç¹æ°ã§"
"ããããã`eps(1.0)` ã¨`eps(Float64)`ã¯åãã«ãªãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:468
msgid ""
"Julia also provides the [`nextfloat`](@ref) and [`prevfloat`](@ref) functions which return the next largest or smallest representable "
"floating-point number to the argument respectively:"
msgstr ""
"Julia ã¯ã¾ãã [`nextfloat`](@ref)é¢æ°ã¨[`prevfloat`](@ref)é¢æ°ãæä¾ãã¾ãããããã¯ãããããå¼æ°ã®å¤ã«å¯¾ãã¦ããã®åã§è¡¨ç¾å¯è½ãªãæ¬¡ã«å¤§ã"
"ãªå¤ãæ¬¡ã«å°ããªå¤ãè¿ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:469
#, no-wrap
msgid ""
"julia> x = 1.25f0\n"
"1.25f0\n"
"\n"
"julia> nextfloat(x)\n"
"1.2500001f0\n"
"\n"
"julia> prevfloat(x)\n"
"1.2499999f0\n"
"\n"
"julia> bitstring(prevfloat(x))\n"
"\"00111111100111111111111111111111\"\n"
"\n"
"julia> bitstring(x)\n"
"\"00111111101000000000000000000000\"\n"
"\n"
"julia> bitstring(nextfloat(x))\n"
"\"00111111101000000000000000000001\"\n"
msgstr ""
"julia> x = 1.25f0\n"
"1.25f0\n"
"\n"
"julia> nextfloat(x)\n"
"1.2500001f0\n"
"\n"
"julia> prevfloat(x)\n"
"1.2499999f0\n"
"\n"
"julia> bitstring(prevfloat(x))\n"
"\"00111111100111111111111111111111\"\n"
"\n"
"julia> bitstring(x)\n"
"\"00111111101000000000000000000000\"\n"
"\n"
"julia> bitstring(nextfloat(x))\n"
"\"00111111101000000000000000000001\"\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:491
msgid ""
"This example highlights the general principle that the adjacent representable floating-point numbers also have adjacent binary integer "
"representations."
msgstr "ãã®ä¾ã§ã¯ãé£æ¥ããè¡¨ç¾å¯è½ãªæµ®åå°æ°ç¹æ°ã¯ã2é²æ°è¡¨ç¾ã§ãããªããé£æ¥ãããã¨ããä¸è¬çãªååãç¤ºãã¦ãã¾ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:492
#, no-wrap
msgid "Rounding modes"
msgstr "ä¸¸ãã¢ã¼ã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:498
msgid ""
"If a number doesn't have an exact floating-point representation, it must be rounded to an appropriate representable value. However, the "
"manner in which this rounding is done can be changed if required according to the rounding modes presented in the [IEEE 754 standard]"
"(https://en.wikipedia.org/wiki/IEEE_754-2008)."
msgstr ""
"æµ®åå°æ°ç¹ã§æ­£ç¢ºã«è¡¨ç¾ã§ããªãæ°ã¯ãé©åãªè¡¨ç¾å¯è½ãªå¤ã«ä¸¸ããå¿è¦ãããã¾ããä¸¸ãå¦çã®æ¹æ³ã¯ã[IEEE 754 è¦æ ¼](https://en.wikipedia.org/"
"wiki/IEEE_754-2008)ã«è¤æ°ã®ã¢ã¼ããç¤ºããã¦ãããå¿è¦ã«å¿ãã¦ãã®ã¢ã¼ããå¤æ´ãããã¨ãã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:501
msgid ""
"The default mode used is always [`RoundNearest`](@ref), which rounds to the nearest representable value, with ties rounded towards the "
"nearest value with an even least significant bit."
msgstr ""
"ããã©ã«ãã®ä¸¸ãã¢ã¼ãã¯ãå¸¸ã« [`RoundNearest`](@ref)(æè¿æ¥ä¸¸ã)ã§ãããã¯ãæãè¿ãè¡¨ç¾å¯è½ãªå¤ã«ä¸¸ããæ¹æ³ã§ãä»®ã«æè¿æ¥ã®è¡¨ç¾å¯è½ãªæ°ã2"
"ã¤ããå ´åã«ã¯ãæä¸ä½ããããå¶æ°ã«ãªãããã«ä¸¸ãã¾ãã"

#. type: Title ###
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:502
#, no-wrap
msgid "Background and References"
msgstr "èæ¯ã¨åç§"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:507
msgid ""
"Floating-point arithmetic entails many subtleties which can be surprising to users who are unfamiliar with the low-level implementation "
"details. However, these subtleties are described in detail in most books on scientific computation, and also in the following references:"
msgstr ""
"æµ®åå°æ°ç¹æ¼ç®ã«ã¯ãä½ã¬ãã«ã®å®è£ã®è©³ç´°ã«æ£ãã¦ããªãã¦ã¼ã¶ã¼ãé©ããããªå¤ãã®å¾®å¦ãªç¹ãããããããã¾ãããã ãããããã®å¾®å¦ãªç¹ã¯ãç§å­¦"
"è¨ç®ã«é¢ããå¤ãã®æ¸ç±ãä¸è¨ã®è³æã§è©³ããèª¬æããã¦ãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:522
msgid ""
"The definitive guide to floating point arithmetic is the [IEEE 754-2008 Standard](https://standards.ieee.org/standard/754-2008.html); "
"however, it is not available for free online."
msgstr ""
"æµ®åå°æ°ç¹æ¼ç®ã®æãä¿¡é ¼ã®ãããã¬ã¤ãã¯ã[IEEE 754-2008è¦æ ¼](https://standard.ieee.org/standard/754-2008.html)ã§ãããã ããªã³ã©ã¤ã³ã»ç¡æã§"
"ã®å©ç¨ã¯ã§ãã¾ããã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:522
msgid ""
"For a brief but lucid presentation of how floating-point numbers are represented, see John D.  Cook's [article](https://www.johndcook.com/"
"blog/2009/04/06/anatomy-of-a-floating-point-number/)  on the subject as well as his [introduction](https://www.johndcook.com/blog/2009/04/06/"
"numbers-are-a-leaky-abstraction/)  to some of the issues arising from how this representation differs in behavior from the idealized "
"abstraction of real numbers."
msgstr ""
"æµ®åå°æ°ç¹æ°ã®è¡¨ç¾ã«ã¤ãã¦å®çµã ãæå¿«ãªè§£èª¬ã¨ãã¦ãJohn D.Cook'ã®[è¨äº](https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-"
"point-number/)ãåç§ã®ãã¨ã[ã¤ã³ãã­ãã¯ã·ã§ã³](https://www.johndcook.com/blog/2009/04/06/numbers-a-leaky-a-leaky)ã§ã¯ãæµ®åå°æ°ç¹æ°ã¨çæ³å"
"ãããæ½è±¡çãªå®æ°ã¨ã®ä¹é¢ããçããåé¡ã«ã¤ãã¦æ¸ããã¦ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:522
msgid ""
"Also recommended is Bruce Dawson's [series of blog posts on floating-point numbers](https://randomascii.wordpress.com/2012/05/20/thats-not-"
"normalthe-performance-of-odd-floats/)."
msgstr ""
"ã¾ããBruce Dawsonã®[æµ®åå°æ°ç¹æ°ã«é¢ããä¸é£ã®ãã­ã°è¨äº](https://randomascii.wordpress.com/2012/05/20/the-normal-not-normal-of-odd-floats/)"
"ããå§ããã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:522
msgid ""
"For an excellent, in-depth discussion of floating-point numbers and issues of numerical accuracy encountered when computing with them, see "
"David Goldberg's paper [What Every Computer Scientist Should Know About Floating-Point Arithmetic](http://citeseerx.ist.psu.edu/viewdoc/"
"download?doi=10.1.1.22.6768&rep=rep1&type=pdf)."
msgstr ""
"æµ®åå°æ°ç¹æ°ã¨åã³ãæµ®åå°æ°ç¹æ°ãç¨ããæ¼ç®ã§é­éããæ°å¤ç²¾åº¦ã®åé¡ã«ã¤ãã¦ã®è©³ç´°ãªè­°è«ã«ã¤ãã¦ã¯ãDavid Goldbergã®è«æ[What Every Computer "
"Scientists Should Know About](http://citeseerx.ist.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768)ãåç§ãã¦ãã ããã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:522
msgid ""
"For even more extensive documentation of the history of, rationale for, and issues with floating-point numbers, as well as discussion of "
"many other topics in numerical computing, see the [collected writings](https://people.eecs.berkeley.edu/~wkahan/)  of [William Kahan]"
"(https://en.wikipedia.org/wiki/William_Kahan), commonly known as the \"Father of Floating-Point\". Of particular interest may be [An "
"Interview with the Old Man of Floating-Point](https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html)."
msgstr ""
"æµ®åå°æ°ç¹æ°ã®æ­´å²ãçè«ãåé¡ãããã³æ°å¤è¨ç®ã«ãããä»ã®å¤ãã®ãããã¯ã®è­°è«ã«ã¤ãã¦ãããã«åºãæ±ã£ãææ¸ã«ã¤ãã¦ã¯ããæµ®åå°æ°ç¹ã®ç¶ãã¨"
"ãã¦ç¥ããã¦ãã[William Kahan](https://en.wikipedia.org/wiki/William_Kahan)ã® [èä½é](https://people.eecs.berkeley.edu/~wkahan/)ãåç§ãã¦"
"ãã ãããç¹ã«èå³æ·±ãã®ã¯ãæµ®åå°æ°ç¹ã®èäººã®ã¤ã³ã¿ãã¥ã¼ã(https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html)ã§ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:523
#, no-wrap
msgid "Arbitrary Precision Arithmetic"
msgstr "[ä»»æç²¾åº¦æ¼ç®](@id arbitrary-precision-arithmetic)"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:529
msgid ""
"To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps the [GNU Multiple Precision Arithmetic "
"Library (GMP)](https://gmplib.org) and the [GNU MPFR Library](https://www.mpfr.org), respectively. The [`BigInt`](@ref) and [`BigFloat`]"
"(@ref) types are available in Julia for arbitrary precision integer and floating point numbers respectively."
msgstr ""
"ä»»æç²¾åº¦ã®æ´æ°ã¨æµ®åå°æ°ç¹æ°ãä½¿ç¨ããè¨ç®ãå¯è½ã«ããããã«ãJulia ã¯[GNU Multiple Precision Arithmetic Library(GMP)](https://gmplib.org)ã¨"
"[GNU MPFR Library](https://www.mpfr.org)ãã©ãããã¦ãã¾ãã[`BigInt`](@ref)ã¨[`BigFloat`](@ref)ã¯ãããããä»»æã®ç²¾åº¦æ´æ°ã¨æµ®åå°æ°ç¹æ°ã§"
"Juliaã§ä½¿ç¨ã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:533
msgid ""
"Constructors exist to create these types from primitive numerical types, and [`parse`](@ref)  can be used to construct them from "
"`AbstractString`s.  Once created, they participate in arithmetic with all other numeric types thanks to Julia's [type promotion and "
"conversion mechanism](@ref conversion-and-promotion):"
msgstr ""
"ã³ã³ã¹ãã©ã¯ã¿ã¼ã¯ãããªããã£ããªæ°å¤åãããããã®åãä½æããããã«å­å¨ãã[`parse`](@ref)ã¯`AbstractString`ããããããæ§ç¯ããããã«ä½¿ç¨"
"ãããã¨ãã§ãã¾ããä¸åº¦ãããã¦å¤ãçæããããä»ã®ãã¹ã¦ã®æ°å¤åã¨ã®æ¼ç®ãå¯è½ã§ããããã¯ Juliaã®[åææ ¼ã¨å¤æã¡ã«ããºã ](@ref conversion-"
"and-promotion)ã«ãã£ã¦å®ç¾ããã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:534
#, no-wrap
msgid ""
"julia> BigInt(typemax(Int64)) + 1\n"
"9223372036854775808\n"
"\n"
"julia> parse(BigInt, \"123456789012345678901234567890\") + 1\n"
"123456789012345678901234567891\n"
"\n"
"julia> parse(BigFloat, \"1.23456789012345678901\")\n"
"1.234567890123456789010000000000000000000000000000000000000000000000000000000004\n"
"\n"
"julia> BigFloat(2.0^66) / 3\n"
"2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19\n"
"\n"
"julia> factorial(BigInt(40))\n"
"815915283247897734345611269596115894272000000000\n"
msgstr ""
"julia> BigInt(typemax(Int64)) + 1\n"
"9223372036854775808\n"
"\n"
"julia> parse(BigInt, \"123456789012345678901234567890\") + 1\n"
"123456789012345678901234567891\n"
"\n"
"julia> parse(BigFloat, \"1.23456789012345678901\")\n"
"1.234567890123456789010000000000000000000000000000000000000000000000000000000004\n"
"\n"
"julia> BigFloat(2.0^66) / 3\n"
"2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19\n"
"\n"
"julia> factorial(BigInt(40))\n"
"815915283247897734345611269596115894272000000000\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:553
msgid ""
"However, type promotion between the primitive types above and [`BigInt`](@ref)/[`BigFloat`](@ref)  is not automatic and must be explicitly "
"stated."
msgstr "ãã ããããªããã£ãåã¨ [`BigInt`](@ref)ã[`BigFloat`](@ref) ã¨ã®åææ ¼ã¯èªåã«ã¯è¡ããããæç¤ºçã«è¨è¿°ããå¿è¦ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:554
#, no-wrap
msgid ""
"julia> x = typemin(Int64)\n"
"-9223372036854775808\n"
"\n"
"julia> x = x - 1\n"
"9223372036854775807\n"
"\n"
"julia> typeof(x)\n"
"Int64\n"
"\n"
"julia> y = BigInt(typemin(Int64))\n"
"-9223372036854775808\n"
"\n"
"julia> y = y - 1\n"
"-9223372036854775809\n"
"\n"
"julia> typeof(y)\n"
"BigInt\n"
msgstr ""
"julia> x = typemin(Int64)\n"
"-9223372036854775808\n"
"\n"
"julia> x = x - 1\n"
"9223372036854775807\n"
"\n"
"julia> typeof(x)\n"
"Int64\n"
"\n"
"julia> y = BigInt(typemin(Int64))\n"
"-9223372036854775808\n"
"\n"
"julia> y = y - 1\n"
"-9223372036854775809\n"
"\n"
"julia> typeof(y)\n"
"BigInt\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:579
msgid ""
"The default precision (in number of bits of the significand) and rounding mode of [`BigFloat`](@ref)  operations can be changed globally by "
"calling [`setprecision`](@ref) and [`setrounding`](@ref), and all further calculations will take these changes in account.  Alternatively, "
"the precision or the rounding can be changed only within the execution of a particular block of code by using the same functions with a `do` "
"block:"
msgstr ""
"[`BigFloat`](@ref) æ¼ç®ã§ã®ããã©ã«ãã®ç²¾åº¦ã¨ä¸¸ãã¢ã¼ãã¯ã[`setprecision`](@ref)ã[`setrounding`](@ref)ãä½¿ã£ã¦ã°ã­ã¼ãã«ã«å¤æ´ãããã¨ãã§"
"ãã¾ãããã®å¾ã®å¨ã¦ã®è¨ç®ã§ããã®å¤æ´ã®å½±é¿ãåãã¾ãããããã¯ã`do` ãã­ãã¯ã§ãããã®é¢æ°ãä½¿ç¨ãããã®ã³ã¼ããã­ãã¯åã§ã®ã¿ç²¾åº¦ãä¸¸ã"
"ã¢ã¼ããå¤æ´ãããã¨ãå¯è½ã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:580
#, no-wrap
msgid ""
"julia> setrounding(BigFloat, RoundUp) do\n"
"           BigFloat(1) + parse(BigFloat, \"0.1\")\n"
"       end\n"
"1.100000000000000000000000000000000000000000000000000000000000000000000000000003\n"
"\n"
"julia> setrounding(BigFloat, RoundDown) do\n"
"           BigFloat(1) + parse(BigFloat, \"0.1\")\n"
"       end\n"
"1.099999999999999999999999999999999999999999999999999999999999999999999999999986\n"
"\n"
"julia> setprecision(40) do\n"
"           BigFloat(1) + parse(BigFloat, \"0.1\")\n"
"       end\n"
"1.1000000000004\n"
msgstr ""
"julia> setrounding(BigFloat, RoundUp) do\n"
"           BigFloat(1) + parse(BigFloat, \"0.1\")\n"
"       end\n"
"1.100000000000000000000000000000000000000000000000000000000000000000000000000003\n"
"\n"
"julia> setrounding(BigFloat, RoundDown) do\n"
"           BigFloat(1) + parse(BigFloat, \"0.1\")\n"
"       end\n"
"1.099999999999999999999999999999999999999999999999999999999999999999999999999986\n"
"\n"
"julia> setprecision(40) do\n"
"           BigFloat(1) + parse(BigFloat, \"0.1\")\n"
"       end\n"
"1.1000000000004\n"

#. type: Title ##
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:597
#, no-wrap
msgid "[Numeric Literal Coefficients](@id man-numeric-literal-coefficients)"
msgstr "[æ°å¤ãªãã©ã«ä¿æ°](@id man-numeric-literal-coefficients)"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:602
msgid ""
"To make common numeric formulae and expressions clearer, Julia allows variables to be immediately preceded by a numeric literal, implying "
"multiplication. This makes writing polynomial expressions much cleaner:"
msgstr ""
"ä¸è¬çãªæ°å¼ã»å¼ãæç¢ºã«ããããã«ãJulia ã§ã¯å¤æ°ã®ç´åã«æ°å¤ãªãã©ã«ãä»ãããã¨ã§ä¹ç®ãè¡¨ããã¨ãã§ãã¾ããããã«ãããå¤é å¼ã®è¨è¿°ãã¯ã"
"ãã«ã¯ãªã¼ã³ã«ãªãã¾ã:"

#. type: Code fence info string
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:603 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:616
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:630 ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:643
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:651
#, no-wrap
msgid "jldoctest numeric-coefficients"
msgstr "jldoctest numeric-coefficients"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:603
#, no-wrap
msgid ""
"julia> x = 3\n"
"3\n"
"\n"
"julia> 2x^2 - 3x + 1\n"
"10\n"
"\n"
"julia> 1.5x^2 - .5x + 1\n"
"13.0\n"
msgstr ""
"julia> x = 3\n"
"3\n"
"\n"
"julia> 2x^2 - 3x + 1\n"
"10\n"
"\n"
"julia> 1.5x^2 - .5x + 1\n"
"13.0\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:615
msgid "It also makes writing exponential functions more elegant:"
msgstr "ã¾ããææ°é¢æ°ã®è¨è¿°ãã¨ã¬ã¬ã³ãã«ãªãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:616
#, no-wrap
msgid ""
"julia> 2^2x\n"
"64\n"
msgstr ""
"julia> 2^2x\n"
"64\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:627
msgid ""
"The precedence of numeric literal coefficients is slightly lower than that of unary operators such as negation.  So `-2x` is parsed as `(-2) "
"* x` and `â2x` is parsed as `(â2) * x`.  However, numeric literal coefficients parse similarly to unary operators when combined with "
"exponentiation.  For example `2^3x` is parsed as `2^(3x)`, and `2x^3` is parsed as `2*(x^3)`."
msgstr ""
"æ°å¤ãªãã©ã«ä¿æ°ã®åªåé ä½ã¯ãå¦å®ãªã©ã®åé æ¼ç®å­ããããããã«ä½ããªãã¾ãã ãããã£ã¦ã`-2x` ã¯ `(-2) * x` ã¨ `â2x` ã¯ `(â2) * x` ã¨ãã¦"
"è§£æããã¾ãã ãã ããæ°å¤ãªãã©ã«ä¿æ°ã¯ãææ°é¢æ°ã¨çµã¿åãããã¨ãåé æ¼ç®å­ã¨åæ§ã«è§£æããã¾ãã ãã¨ãã°ã`2^3x` ã¯ `2^(3x)` ã¨ãã¦è§£æ"
"ããã`2x^3` ã¯ `2*(x^3)` ã¨ãã¦è§£æããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:629
msgid "Numeric literals also work as coefficients to parenthesized expressions:"
msgstr "æ°å¤ãªãã©ã«ã¯ãæ¬å¼§ä»ãå¼ã«å¯¾ããä¿æ°ã¨ãã¦ãæ©è½ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:630
#, no-wrap
msgid ""
"julia> 2(x-1)^2 - 3(x-1) + 1\n"
"3\n"
msgstr ""
"julia> 2(x-1)^2 - 3(x-1) + 1\n"
"3\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:639
#, no-wrap
msgid ""
"!!! note\n"
"    The precedence of numeric literal coefficients used for implicit\n"
"    multiplication is higher than other binary operators such as multiplication\n"
"    (`*`), and division (`/`, `\\`, and `//`).  This means, for example, that\n"
"    `1 / 2im` equals `-0.5im` and `6 // 2(2 + 1)` equals `1 // 1`.\n"
msgstr ""
"!!!ã¡ã¢\n"
"    æé»çãªä¹ç®ã«ä½¿ç¨ãããæ°å¤ãªãã©ã«ä¿æ°ã®åªåé ä½ã¯\n"
"    ä¹ç®(`*`)ãããã³é¤ç® (`/`ã`\\`ãããã³ `//`) ãªã©ã®ä»ã®äºé æ¼ç®å­ãããé«ããªãã¾ãã\n"
"    ããã¯ãä¾ãã°ã`1 / 2im` ã¯ `-0.5im` ã«ç­ãã`6 // 2(2+ 1)` ã¯ `1 // 1`ã«ç­ãããªãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:642
msgid ""
"Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the expression by the variable:"
msgstr "ããã«ãæ¬å¼§ä»ãå¼ã¯å¤æ°ã¸ã®ä¿æ°ã¨ãã¦ä½¿ç¨ã§ããå¼ã¨å¤æ°ã®æãç®ã¨ãããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:643
#, no-wrap
msgid ""
"julia> (x-1)x\n"
"6\n"
msgstr ""
"julia> (x-1)x\n"
"6\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:650
msgid ""
"Neither juxtaposition of two parenthesized expressions, nor placing a variable before a parenthesized expression, however, can be used to "
"imply multiplication:"
msgstr "ãã ãã2 ã¤ã®æ¬å¼§å¼ã®ä¸¦ã¹ã¦ãããããæ¬å¼§å¼ã®åã«å¤æ°ãéç½®ãã¦ããä¹ç®ã¨ã¯ã¿ãªããã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:651
#, no-wrap
msgid ""
"julia> (x-1)(x+1)\n"
"ERROR: MethodError: objects of type Int64 are not callable\n"
"\n"
"julia> x(x+1)\n"
"ERROR: MethodError: objects of type Int64 are not callable\n"
msgstr ""
"julia> (x-1)(x+1)\n"
"ERROR: MethodError: objects of type Int64 are not callable\n"
"\n"
"julia> x(x+1)\n"
"ERROR: MethodError: objects of type Int64 are not callable\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:663
msgid ""
"Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a "
"parenthetical, is interpreted as a function applied to the values in parentheses (see [Functions](@ref) for more about functions). Thus, in "
"both of these cases, an error occurs since the left-hand value is not a function."
msgstr ""
"æ¬å¼§å¼ãä¸¦ã¹ãå ´åããæ¬å¼§å¼ã®ç´åã«å¤æ°ãç½®ããæããé¢æ°ã®é©å¿ã¨ãã¦è§£éããã¾ã: æ°å¤ãªãã©ã«ã§ã¯ãªãå¼ã®ç´å¾ã«æ¬å¼§ãä»ããã¨ãæ¬å¼§åã®å¤"
"ã«é©ç¨ãããé¢æ°ã¨ãã¦è§£éããã¾ã (é¢æ°ã«ã¤ãã¦ã®è©³ç´°ã¯ã[é¢æ°](@ref Functions)ã®é ãåç§ãã¦ãã ãã)ããããã£ã¦ããããã®å ´åããå·¦å´ã®å¤"
"ãé¢æ°ã§ã¯ãªããããã¨ã©ã¼ãçºçãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:667
msgid ""
"The above syntactic enhancements significantly reduce the visual noise incurred when writing common mathematical formulae. Note that no "
"whitespace may come between a numeric literal coefficient and the identifier or parenthesized expression which it multiplies."
msgstr ""
"ãã®ãããªæ§ææ©è½ã®å¼·åã«ãããä¸è¬çãªæ°å¼ãè¨è¿°ããã¨ãã«çºçããè¦è¦çãªãã¤ãºãå¤§å¹ã«ä½æ¸ããã¾ããæ°å¤ãªãã©ã«ä¿æ°ã¨ãä¹ç®ããè­å¥å­ã¾"
"ãã¯æ¬å¼§å¼ã®éã«ç©ºç½ãçããªããã¨ã«æ³¨æãã¦ãã ããã"

#. type: Title ###
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:668
#, no-wrap
msgid "Syntax Conflicts"
msgstr "æ§æã®ç«¶å"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:673
msgid ""
"Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal integer literals and engineering notation "
"for floating-point literals. Here are some situations where syntactic conflicts arise:"
msgstr ""
"ãªãã©ã«ä¿æ°ãï¼ã¤ä¸¦ã¹ãæ§æã¨ç«¶åãããããããªãï¼ã¤ã®æ°å¤ãªãã©ã«æ§æãããã¾ã:16é²æ´æ°ãªãã©ã« ã¨æµ®åå°æ°ç¹ãªãã©ã«ã®ææ°è¡¨è¨ã§ããæ§æ"
"ä¸ã®ç«¶åãçºçããç¶æ³ãä»¥ä¸ã®ãããªãã®ã§ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:680
msgid "The hexadecimal integer literal expression `0xff` could be interpreted as the numeric literal `0` multiplied by the variable `xff`."
msgstr "16é²æ´æ°å¤ `0xff` ã¯ãæ°å¤ãªãã©ã« `0` ã¨å¤æ° `xff` ã®æãç®ã¨è§£éã§ããã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:680
msgid ""
"The floating-point literal expression `1e10` could be interpreted as the numeric literal `1` multiplied by the variable `e10`, and similarly "
"with the equivalent `E` form."
msgstr "æµ®åå°æ°ç¹ãªãã©ã« `1e10` ã¯ãæ°å¤ãªãã©ã« `1`ã¨ å¤æ° `e10` ã®æãç®ã¨è§£éã§ããã`E`å½¢å¼ãåæ§ã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:680
msgid ""
"The 32-bit floating-point literal expression `1.5f22` could be interpreted as the numeric literal `1.5` multiplied by the variable `f22`."
msgstr "32 ãããæµ®åå°æ°ç¹ãªãã©ã« `1.5f22` ã¯ãæ°å¤ãªãã©ã«`1.5` ã¨ å¤æ° `f22` ã®æãç®ã¨è§£éã§ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:682
msgid "In all cases the ambiguity is resolved in favor of interpretation as numeric literals:"
msgstr "ã©ã®å ´åã«ã¤ãã¦ããæ°å¤ãªãã©ã«ã¨ãã¦ã®è§£éãåªåãã¦è§£æ±ºããã¾ããã¤ã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:686
msgid "Expressions starting with `0x` are always hexadecimal literals."
msgstr "`0x` ã§å§ã¾ãå¼ã¯ãå¸¸ã«16é²æ°ãªãã©ã«ã§ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:686
msgid "Expressions starting with a numeric literal followed by `e` or `E` are always floating-point literals."
msgstr "æ°å¤ãªãã©ã«ã§å§ã¾ãã`e` ã¾ãã¯ `E` ãç¶ãå¼ã¯ãå¸¸ã«æµ®åå°æ°ç¹ãªãã©ã«ã§ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:686
msgid "Expressions starting with a numeric literal followed by `f` are always 32-bit floating-point literals."
msgstr "æ°å¤ãªãã©ã«ã§å§ã¾ãã`f` ãç¶ãå¼ã¯ãå¸¸ã« 32 ãããæµ®åå°æ°ç¹ãªãã©ã«ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:691
msgid ""
"Unlike `E`, which is equivalent to `e` in numeric literals for historical reasons, `F` is just another letter and does not behave like `f` "
"in numeric literals. Hence, expressions starting with a numeric literal followed by `F` are interpreted as the numerical literal multiplied "
"by a variable, which means that, for example, `1.5F22` is equal to `1.5 * F22`."
msgstr ""
"æ­´å²çãªçç±ããæ°å¤ãªãã©ã«ã® `e` ã«ç¸å½ãã `E` ã¨ã¯ç°ãªãã`F` ã¯åãªãæå­ã§ãããæ°å¤ãªãã©ã«ã§ã¯ `f` ã®ããã«åä½ãã¾ããããããã£ã¦ã"
"æ°å¤ãªãã©ã«ã§å§ã¾ã`F`ãç¶ãå¼ã¯ãæ°å¤ãªãã©ã«ã«å¤æ°ãæãããã®ã¨ãã¦è§£éãããä¾ãã°`1.5F22`ã¯`1.5 * F22`ã«ç­ãããã¨ãæå³ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:692
#, no-wrap
msgid "Literal zero and one"
msgstr "0ã¨1ã®ãªãã©ã«"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:696
msgid "Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given variable."
msgstr "Julia ã¯ãæå®ãããåã¾ãã¯ç¹å®ã®å¤æ°ã®åã«å¯¾å¿ãããªãã©ã« 0 ã¨ 1 ãè¿ãé¢æ°ãæä¾ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:701
#, no-wrap
msgid ""
"| Function          | Description                                      |\n"
"|:----------------- |:------------------------------------------------ |\n"
"| [`zero(x)`](@ref) | Literal zero of type `x` or type of variable `x` |\n"
"| [`one(x)`](@ref)  | Literal one of type `x` or type of variable `x`  |\n"
msgstr ""
"| é¢æ°          | èª¬æ                                      |\n"
"|:----------------- |:------------------------------------------------ |\n"
"| [`zero(x)`](@ref) | å `x` ãããã¯ å¤æ° `x`ã¨åãåãæã¤ãªãã©ã«0 |\n"
"| [`one(x)`](@ref)  | å `x` ãããã¯ å¤æ° `x`ã¨åãåãæã¤ãªãã©ã«1  |\n"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:704
msgid ""
"These functions are useful in [Numeric Comparisons](@ref) to avoid overhead from unnecessary [type conversion](@ref conversion-and-"
"promotion)."
msgstr ""
"ãããã®é¢æ°ã¯ã[æ°å¤æ¯è¼](@ref numeric-comparisons)ã®éã«ãä¸è¦ãª [åå¤æ] (@ref conversion-and-promotion) ã®ãªã¼ãã¼ããããåé¿ããã®ã«å½¹"
"ç«ã¡ã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:706
msgid "Examples:"
msgstr "ä¾ï¼"

#. type: Plain text
#: ext/julia/doc/src/manual/integers-and-floating-point-numbers.md:707
#, no-wrap
msgid ""
"julia> zero(Float32)\n"
"0.0f0\n"
"\n"
"julia> zero(1.0)\n"
"0.0\n"
"\n"
"julia> one(Int32)\n"
"1\n"
"\n"
"julia> one(BigFloat)\n"
"1.0\n"
msgstr ""
"julia> zero(Float32)\n"
"0.0f0\n"
"\n"
"julia> zero(1.0)\n"
"0.0\n"
"\n"
"julia> one(Int32)\n"
"1\n"
"\n"
"julia> one(BigFloat)\n"
"1.0\n"

#. type: Title #
#: ext/julia/doc/src/manual/style-guide.md:1
#, no-wrap
msgid "Style Guide"
msgstr "ã¹ã¿ã¤ã«ã¬ã¤ã"

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:6
msgid ""
"The following sections explain a few aspects of idiomatic Julia coding style. None of these rules are absolute; they are only suggestions to "
"help familiarize you with the language and to help you choose among alternative designs."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:7
#, no-wrap
msgid "Write functions, not just scripts"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:14
msgid ""
"Writing code as a series of steps at the top level is a quick way to get started solving a problem, but you should try to divide a program "
"into functions as soon as possible. Functions are more reusable and testable, and clarify what steps are being done and what their inputs "
"and outputs are. Furthermore, code inside functions tends to run much faster than top level code, due to how Julia's compiler works."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:17
msgid ""
"It is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants "
"like [`pi`](@ref))."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:18
#, no-wrap
msgid "Avoid writing overly-specific types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:21
msgid "Code should be as generic as possible. Instead of writing:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:22
#, no-wrap
msgid "Complex{Float64}(x)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:27
msgid "it's better to use available generic functions:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:28
#, no-wrap
msgid "complex(float(x))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:33
msgid "The second version will convert `x` to an appropriate type, instead of always the same type."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:41
msgid ""
"This style point is especially relevant to function arguments. For example, don't declare an argument to be of type `Int` or [`Int32`](@ref) "
"if it really could be any integer, expressed with the abstract type [`Integer`](@ref). In fact, in many cases you can omit the argument type "
"altogether, unless it is needed to disambiguate from other method definitions, since a [`MethodError`](@ref) will be thrown anyway if a type "
"is passed that does not support any of the requisite operations. (This is known as [duck typing](https://en.wikipedia.org/wiki/Duck_typing).)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:44
msgid "For example, consider the following definitions of a function `addone` that returns one plus its argument:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:45
#, no-wrap
msgid ""
"addone(x::Int) = x + 1                 # works only for Int\n"
"addone(x::Integer) = x + oneunit(x)    # any integer type\n"
"addone(x::Number) = x + oneunit(x)     # any numeric type\n"
"addone(x) = x + oneunit(x)             # any type supporting + and oneunit\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:60
msgid ""
"The last definition of `addone` handles any type supporting [`oneunit`](@ref) (which returns 1 in the same type as `x`, which avoids "
"unwanted type promotion) and the [`+`](@ref) function with those arguments. The key thing to realize is that there is *no performance "
"penalty* to defining *only* the general `addone(x) = x + oneunit(x)`, because Julia will automatically compile specialized versions as "
"needed. For example, the first time you call `addone(12)`, Julia will automatically compile a specialized `addone` function for `x::Int` "
"arguments, with the call to `oneunit` replaced by its inlined value `1`. Therefore, the first three definitions of `addone` above are "
"completely redundant with the fourth definition."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:61
#, no-wrap
msgid "Handle excess argument diversity in the caller"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:64 ext/julia/doc/src/manual/style-guide.md:92
msgid "Instead of:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:65
#, no-wrap
msgid ""
"function foo(x, y)\n"
"    x = Int(x); y = Int(y)\n"
"    ...\n"
"end\n"
"foo(x, y)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:75
#, no-wrap
msgid ""
"function foo(x::Int, y::Int)\n"
"    ...\n"
"end\n"
"foo(Int(x), Int(y))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:84
msgid "This is better style because `foo` does not really accept numbers of all types; it really needs `Int` s."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:88
msgid ""
"One issue here is that if a function inherently requires integers, it might be better to force the caller to decide how non-integers should "
"be converted (e.g. floor or ceiling). Another issue is that declaring more specific types leaves more \"space\" for future method "
"definitions."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:89
#, no-wrap
msgid "Append `!` to names of functions that modify their arguments"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:93
#, no-wrap
msgid ""
"function double(a::AbstractArray{<:Number})\n"
"    for i = firstindex(a):lastindex(a)\n"
"        a[i] *= 2\n"
"    end\n"
"    return a\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:104
#, no-wrap
msgid ""
"function double!(a::AbstractArray{<:Number})\n"
"    for i = firstindex(a):lastindex(a)\n"
"        a[i] *= 2\n"
"    end\n"
"    return a\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:117
msgid ""
"Julia Base uses this convention throughout and contains examples of functions with both copying and modifying forms (e.g., [`sort`](@ref) "
"and [`sort!`](@ref)), and others which are just modifying (e.g., [`push!`](@ref), [`pop!`](@ref), [`splice!`](@ref)).  It is typical for "
"such functions to also return the modified array for convenience."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:118
#, no-wrap
msgid "Avoid strange type `Union`s"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:121
msgid "Types such as `Union{Function,AbstractString}` are often a sign that some design could be cleaner."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:122
#, no-wrap
msgid "Avoid elaborate container types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:125
msgid "It is usually not much help to construct arrays like the following:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:126
#, no-wrap
msgid "a = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:132
msgid ""
"In this case `Vector{Any}(undef, n)` is better. It is also more helpful to the compiler to annotate specific uses (e.g. `a[i]::Int`) than to "
"try to pack many alternatives into one type."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:133
#, no-wrap
msgid "Use naming conventions consistent with Julia `base/`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/style-guide.md:142
msgid "modules and type names use capitalization and camel case: `module SparseArrays`, `struct UnitRange`."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/style-guide.md:142
msgid ""
"functions are lowercase ([`maximum`](@ref), [`convert`](@ref)) and, when readable, with multiple words squashed together ([`isequal`](@ref), "
"[`haskey`](@ref)). When necessary, use underscores as word separators. Underscores are also used to indicate a combination of concepts "
"([`remotecall_fetch`](@ref)  as a more efficient implementation of `fetch(remotecall(...))`) or as modifiers."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/style-guide.md:142
msgid ""
"conciseness is valued, but avoid abbreviation ([`indexin`](@ref) rather than `indxin`) as it becomes difficult to remember whether and how "
"particular words are abbreviated."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:145
msgid ""
"If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:146
#, no-wrap
msgid "Write functions with argument ordering similar to Julia Base"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:150
msgid "As a general rule, the Base library uses the following order of arguments to functions, as applicable:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/manual/style-guide.md:154
msgid ""
"**Function argument**.  Putting a function argument first permits the use of [`do`](@ref) blocks for passing multiline anonymous functions."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/manual/style-guide.md:158
msgid ""
"**I/O stream**.  Specifying the `IO` object first permits passing the function to functions such as [`sprint`](@ref), e.g. `sprint(show, x)`."
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/manual/style-guide.md:162
msgid ""
"**Input being mutated**.  For example, in [`fill!(x, v)`](@ref fill!), `x` is the object being mutated and it appears before the value to be "
"inserted into `x`."
msgstr ""

#. type: Bullet: '4. '
#: ext/julia/doc/src/manual/style-guide.md:169
msgid ""
"**Type**.  Passing a type typically means that the output will have the given type.  In [`parse(Int, \"1\")`](@ref parse), the type comes "
"before the string to parse.  There are many such examples where the type appears first, but it's useful to note that in [`read(io, String)`]"
"(@ref read), the `IO` argument appears before the type, which is in keeping with the order outlined here."
msgstr ""

#. type: Bullet: '5. '
#: ext/julia/doc/src/manual/style-guide.md:172
msgid "**Input not being mutated**.  In `fill!(x, v)`, `v` is *not* being mutated and it comes after `x`."
msgstr ""

#. type: Bullet: '6. '
#: ext/julia/doc/src/manual/style-guide.md:176
msgid "**Key**.  For associative collections, this is the key of the key-value pair(s).  For other indexed collections, this is the index."
msgstr ""

#. type: Bullet: '7. '
#: ext/julia/doc/src/manual/style-guide.md:180
msgid "**Value**.  For associative collections, this is the value of the key-value pair(s).  In cases like `fill!(x, v)`, this is `v`."
msgstr ""

#. type: Bullet: '8. '
#: ext/julia/doc/src/manual/style-guide.md:183
msgid "**Everything else**.  Any other arguments."
msgstr ""

#. type: Bullet: '9. '
#: ext/julia/doc/src/manual/style-guide.md:189
msgid ""
"**Varargs**.  This refers to arguments that can be listed indefinitely at the end of a function call.  For example, in `Matrix{T}(undef, "
"dims)`, the dimensions can be given as a [`Tuple`](@ref), e.g. `Matrix{T}(undef, (1,2))`, or as [`Vararg`](@ref)s, e.g. `Matrix{T}(undef, 1, "
"2)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:193
#, no-wrap
msgid ""
"10. **Keyword arguments**.\n"
"   In Julia keyword arguments have to come last anyway in function definitions; they're\n"
"   listed here for the sake of completeness.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:197
msgid ""
"The vast majority of functions will not take every kind of argument listed above; the numbers merely denote the precedence that should be "
"used for any applicable arguments to a function."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:202
msgid ""
"There are of course a few exceptions.  For example, in [`convert`](@ref), the type should always come first.  In [`setindex!`](@ref), the "
"value comes before the indices so that the indices can be provided as varargs."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:205
msgid ""
"When designing APIs, adhering to this general order as much as possible is likely to give users of your functions a more consistent "
"experience."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:206
#, no-wrap
msgid "Don't overuse try-catch"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:209
msgid "It is better to avoid errors than to rely on catching them."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:210
#, no-wrap
msgid "Don't parenthesize conditions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:213
msgid "Julia doesn't require parens around conditions in `if` and `while`. Write:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:214
#, no-wrap
msgid "if a == b\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:219
msgid "instead of:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:220
#, no-wrap
msgid "if (a == b)\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:224
#, no-wrap
msgid "Don't overuse `...`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:229
msgid ""
"Splicing function arguments can be addictive. Instead of `[a..., b...]`, use simply `[a; b]`, which already concatenates arrays. "
"[`collect(a)`](@ref) is better than `[a...]`, but since `a` is already iterable it is often even better to leave it alone, and not convert "
"it to an array."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:230
#, no-wrap
msgid "Don't use unnecessary static parameters"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:233
msgid "A function signature:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:234
#, no-wrap
msgid "foo(x::T) where {T<:Real} = ...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:239
msgid "should be written as:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:240
#, no-wrap
msgid "foo(x::Real) = ...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:247
msgid ""
"instead, especially if `T` is not used in the function body. Even if `T` is used, it can be replaced with [`typeof(x)`](@ref) if convenient. "
"There is no performance difference. Note that this is not a general caution against static parameters, just against uses where they are not "
"needed."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:250
msgid ""
"Note also that container types, specifically may need type parameters in function calls. See the FAQ [Avoid fields with abstract containers]"
"(@ref) for more information."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:251
#, no-wrap
msgid "Avoid confusion about whether something is an instance or a type"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:254
msgid "Sets of definitions like the following are confusing:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:255
#, no-wrap
msgid ""
"foo(::Type{MyType}) = ...\n"
"foo(::MyType) = foo(MyType)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:262
msgid "Decide whether the concept in question will be written as `MyType` or `MyType()`, and stick to it."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:265
msgid ""
"The preferred style is to use instances by default, and only add methods involving `Type{MyType}` later if they become necessary to solve "
"some problem."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:270
msgid ""
"If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive)  type, with the "
"enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over "
"making the enumeration an abstract type, with the \"values\" as subtypes."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:271
#, no-wrap
msgid "Don't overuse macros"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:274
msgid "Be aware of when a macro could really be a function instead."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:278
msgid ""
"Calling [`eval`](@ref) inside a macro is a particularly dangerous warning sign; it means the macro will only work when called at the top "
"level. If such a macro is written as a function instead, it will naturally have access to the run-time values it needs."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:279
#, no-wrap
msgid "Don't expose unsafe operations at the interface level"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:282
msgid "If you have a type that uses a native pointer:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:283
#, no-wrap
msgid ""
"mutable struct NativeType\n"
"    p::Ptr{UInt8}\n"
"    ...\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:291
msgid "don't write definitions like the following:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:292
#, no-wrap
msgid "getindex(x::NativeType, i) = unsafe_load(x.p, i)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:298
msgid ""
"The problem is that users of this type can write `x[i]` without realizing that the operation is unsafe, and then be susceptible to memory "
"bugs."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:301
msgid "Such a function should either check the operation to ensure it is safe, or have `unsafe` somewhere in its name to alert callers."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:302
#, no-wrap
msgid "Don't overload methods of base container types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:305
msgid "It is possible to write definitions like the following:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:306
#, no-wrap
msgid "show(io::IO, v::Vector{MyType}) = ...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:313
msgid ""
"This would provide custom showing of vectors with a specific new element type. While tempting, this should be avoided. The trouble is that "
"users will expect a well-known type like `Vector()` to behave in a certain way, and overly customizing its behavior can make it harder to "
"work with."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:314
#, no-wrap
msgid "Avoid type piracy"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:322
msgid ""
"\"Type piracy\" refers to the practice of extending or redefining methods in Base or other packages on types that you have not defined. In "
"some cases, you can get away with type piracy with little ill effect. In extreme cases, however, you can even crash Julia (e.g. if your "
"method extension or redefinition causes invalid input to be passed to a `ccall`). Type piracy can complicate reasoning about code, and may "
"introduce incompatibilities that are hard to predict and diagnose."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:324
msgid "As an example, suppose you wanted to define multiplication on symbols in a module:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:325
#, no-wrap
msgid ""
"module A\n"
"import Base.*\n"
"*(x::Symbol, y::Symbol) = Symbol(x,y)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:336
msgid ""
"The problem is that now any other module that uses `Base.*` will also see this definition.  Since `Symbol` is defined in Base and is used by "
"other modules, this can change the behavior of unrelated code unexpectedly. There are several alternatives here, including using a different "
"function name, or wrapping the `Symbol`s in another type that you define."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:344
msgid ""
"Sometimes, coupled packages may engage in type piracy to separate features from definitions, especially when the packages were designed by "
"collaborating authors, and when the definitions are reusable. For example, one package might provide some types useful for working with "
"colors; another package could define methods for those types that enable conversions between color spaces. Another example might be a "
"package that acts as a thin wrapper for some C code, which another package might then pirate to implement a higher-level, Julia-friendly API."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:345
#, no-wrap
msgid "Be careful with type equality"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:350
#, no-wrap
msgid ""
"You generally want to use [`isa`](@ref) and [`<:`](@ref) for testing types,\n"
"not `==`. Checking types for exact equality typically only makes sense when comparing to a known\n"
"concrete type (e.g. `T == Float64`), or if you *really, really* know what you're doing.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:351
#, no-wrap
msgid "Do not write `x->f(x)`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:356
#, no-wrap
msgid ""
"Since higher-order functions are often called with anonymous functions, it is easy to conclude\n"
"that this is desirable or even necessary. But any function can be passed directly, without being\n"
"\"wrapped\" in an anonymous function. Instead of writing `map(x->f(x), a)`, write [`map(f, a)`](@ref).\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/style-guide.md:357
#, no-wrap
msgid "Avoid using floats for numeric literals in generic code when possible"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:362
msgid ""
"If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using "
"literals of a numeric type that will affect the arguments as little as possible through promotion."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:364
msgid "For example,"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:365
#, no-wrap
msgid ""
"julia> f(x) = 2.0 * x\n"
"f (generic function with 1 method)\n"
"\n"
"julia> f(1//2)\n"
"1.0\n"
"\n"
"julia> f(1/2)\n"
"1.0\n"
"\n"
"julia> f(1)\n"
"2.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:380
msgid "while"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:381
#, no-wrap
msgid ""
"julia> g(x) = 2 * x\n"
"g (generic function with 1 method)\n"
"\n"
"julia> g(1//2)\n"
"1//1\n"
"\n"
"julia> g(1/2)\n"
"1.0\n"
"\n"
"julia> g(1)\n"
"2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:399
msgid ""
"As you can see, the second version, where we used an `Int` literal, preserved the type of the input argument, while the first didn't. This "
"is because e.g. `promote_type(Int, Float64) == Float64`, and promotion happens with the multiplication. Similarly, [`Rational`](@ref) "
"literals are less type disruptive than [`Float64`](@ref) literals, but more disruptive than `Int`s:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:400
#, no-wrap
msgid ""
"julia> h(x) = 2//1 * x\n"
"h (generic function with 1 method)\n"
"\n"
"julia> h(1//2)\n"
"1//1\n"
"\n"
"julia> h(1/2)\n"
"1.0\n"
"\n"
"julia> h(1)\n"
"2//1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/style-guide.md:415
msgid ""
"Thus, use `Int` literals when possible, with `Rational{Int}` for literal non-integer numbers, in order to make it easier to use your code."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/profile.md:1
#, no-wrap
msgid "Profiling"
msgstr "[ãã­ãã¡ã¤ãªã³ã°](@id Profiling)"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:7
msgid ""
"The `Profile` module provides tools to help developers improve the performance of their code. When used, it takes measurements on running "
"code, and produces output that helps you understand how much time is spent on individual line(s). The most common usage is to identify "
"\"bottlenecks\" as targets for optimization."
msgstr ""
"`Profile`ã¢ã¸ã¥ã¼ã«ã«ã¯ãéçºèãã³ã¼ãã®ããã©ã¼ãã³ã¹ãåä¸ãããã®ã«å½¹ç«ã¤ãã¼ã«ãç¨æããã¦ãã¾ããä½¿ç¨ããã¨ãå®è¡ä¸­ã®ã³ã¼ããæ¸¬å®ããå"
"è¡ã®æ¼ç®ã«ã©ããããã®æéãè²»ãããã¦ããããçè§£ããã®ã«å½¹ç«ã¤åºåãçæãã¾ããæãä¸è¬çãªä½¿ç¨æ³ã¯ãæé©åã®ã¿ã¼ã²ããã¨ãã¦ãããã«ãã"
"ã¯ããç¹å®ãããã¨ã§ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:12
#, no-wrap
msgid ""
"`Profile` implements what is known as a \"sampling\" or [statistical profiler](https://en.wikipedia.org/wiki/Profiling_(computer_programming)).\n"
" It works by periodically taking a backtrace during the execution of any task. Each backtrace\n"
"captures the currently-running function and line number, plus the complete chain of function calls\n"
"that led to this line, and hence is a \"snapshot\" of the current state of execution.\n"
msgstr ""
"`Profile`ã«ã¯ãããµã³ããªã³ã°ãããªãã¡ã[çµ±è¨çãã­ãã¡ã¤ã©ã¼](https://en.wikipedia.org/wiki/Profiling_(computer_programming))ã¨ãã¦ç¥ããã¦ãããã®ãå®è£ããã¦ãã¾ãã\n"
" ããã¯ãä»»æã®ã¿ã¹ã¯ã®å®è¡ä¸­ã«å®æçã«ããã¯ãã¬ã¼ã¹ãåããã¨ã«ãã£ã¦åä½ãã¾ãã\n"
"åããã¯ãã¬ã¼ã¹ã¯ãç¾å¨å®è¡ä¸­ã®é¢æ°ã¨è¡çªå·ãããã¦ããã®è¡ã®å®è¡ã«ã¤ãªããé¢æ°å¼ã³åºãã®å®å¨ãªé£éãè£è¶³ãã¾ãããã®ããã(ããã¯ãã¬ã¼ã¹ã§å¾ãããç¶æã¯)ç¾å¨ã®å®è¡ç¶æã® \"ã¹ãããã·ã§ãã\" ã«ãªãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:17
msgid ""
"If much of your run time is spent executing a particular line of code, this line will show up frequently in the set of all backtraces. In "
"other words, the \"cost\" of a given line--or really, the cost of the sequence of function calls up to and including this line--is "
"proportional to how often it appears in the set of all backtraces."
msgstr ""
"å®è¡æéã®å¤ããç¹å®ã®ã³ã¼ãè¡ã®å®è¡ã«è²»ãããã¦ããå ´åããã®è¡ã¯ãã¹ã¦ã®ããã¯ãã¬ã¼ã¹ã®ã»ããã«é »ç¹ã«ç¾ãã¾ããè¨ãæããã°ãç¹å®ã®è¡ã®"
"ãã³ã¹ãããã¤ã¾ãããã®è¡ãå«ãé¢æ°ã®ä¸é£ã®å¼ã³åºãã®ã³ã¹ãã¯ããã¹ã¦ã®ããã¯ãã¬ã¼ã¹ã®ã»ããã«è¡¨ç¤ºãããé »åº¦ã«æ¯ä¾ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:23
msgid ""
"A sampling profiler does not provide complete line-by-line coverage, because the backtraces occur at intervals (by default, 1 ms on Unix "
"systems and 10 ms on Windows, although the actual scheduling is subject to operating system load). Moreover, as discussed further below, "
"because samples are collected at a sparse subset of all execution points, the data collected by a sampling profiler is subject to "
"statistical noise."
msgstr ""
"ãµã³ããªã³ã° ãã­ãã¡ã¤ã©ã¯ã1è¡1è¡ã®å®è¡ã«å¯¾ããå®å¨ãªã«ãã¬ãã¸ãæä¾ãã¾ãããããã¯ãã¬ã¼ã¹ãä¸å®æéééã§çºçããããã§ã(æ¢å®ã§ã¯ã"
"Unix ã·ã¹ãã ã§ 1 ããªç§ãWindows ã§ã¯ 10 ããªç§ã§ãããå®éã®ã¹ã±ã¸ã¥ã¼ãªã³ã°ã¯ãªãã¬ã¼ãã£ã³ã° ã·ã¹ãã ã®è² è·ã®å½±é¿ãåãã¾ã)ãããã«ãå¾"
"ã§èª¬æããããã«ããµã³ãã«ã¯å¨å®è¡ãã¤ã³ãã«å¯¾ãã¦ãµã³ãã«æ°ã®ã¾ã°ããªé¨åéåã¨ãã¦åéãããããããµã³ããªã³ã° ãã­ãã¡ã¤ã©ã«ãã£ã¦åéãã"
"ããã¼ã¿ã¯çµ±è¨çãã¤ãºã®å½±é¿ãåãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:25
msgid "Despite these limitations, sampling profilers have substantial strengths:"
msgstr "ãããã®å¶éã«ããããããããµã³ããªã³ã° ãã­ãã¡ã¤ã©ã«ã¯å¤§ããªå¼·ã¿ãããã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/profile.md:30
msgid "You do not have to make any modifications to your code to take timing measurements."
msgstr "æ¼ç®æéæ¸¬å®ãè¡ãããã«ã³ã¼ããå¤æ´ããå¿è¦ã¯ããã¾ããã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/profile.md:30
msgid "It can profile into Julia's core code and even (optionally) into C and Fortran libraries."
msgstr "Juliaã®ã³ã¢ã³ã¼ãã®ä¸­ã¾ã§ãããã«ã¯(ãªãã·ã§ã³ã§)Cããã³Fortranã©ã¤ãã©ãªã®ä¸­ããã­ãã¡ã¤ã«ãããã¨ãã§ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/profile.md:30
msgid "By running \"infrequently\" there is very little performance overhead; while profiling, your code can run at nearly native speed."
msgstr ""
"\"ã¾ãã«\" å®è¡ããåã«ã¯ãããã©ã¼ãã³ã¹ã®ãªã¼ãã¼ãããã¯ã»ã¨ãã©ããã¾ããããã­ãã¡ã¤ãªã³ã°ä¸­ã¯ãã³ã¼ãã¯ã»ã¼ãã¤ãã£ãã®éåº¦ã§å®è¡ã§ãã¾"
"ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:33
msgid "For these reasons, it's recommended that you try using the built-in sampling profiler before considering any alternatives."
msgstr "ãã®ãããªçç±ãããä»£æ¿æ¡ãæ¤è¨ããåã«ãçµã¿è¾¼ã¿ã®ãµã³ããªã³ã° ãã­ãã¡ã¤ã©ãä½¿ç¨ãããã¨ããå§ããã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/profile.md:34
#, no-wrap
msgid "Basic usage"
msgstr "åºæ¬çãªä½¿ãæ¹"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:37
msgid "Let's work with a simple test case:"
msgstr "ç°¡åãªãã¹ãã±ã¼ã¹ãè©¦ãã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:38
#, no-wrap
msgid ""
"julia> function myfunc()\n"
"           A = rand(200, 200, 400)\n"
"           maximum(A)\n"
"       end\n"
msgstr ""
"julia> function myfunc()\n"
"           A = rand(200, 200, 400)\n"
"           maximum(A)\n"
"       end\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:47
msgid "It's a good idea to first run the code you intend to profile at least once (unless you want to profile Julia's JIT-compiler):"
msgstr "ãã­ãã¡ã¤ã«ããã³ã¼ããå°ãªãã¨ã 1 åå®è¡ãã¦ããã®ã¯ããã¢ã¤ãã£ã¢ã§ã (Julia ã® JIT ã³ã³ãã¤ã©ããã­ãã¡ã¤ãªã³ã°ããå ´åãé¤ã):"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:48
#, no-wrap
msgid "julia> myfunc() # run once to force compilation\n"
msgstr "julia> myfunc() # run once to force compilation\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:53
msgid "Now we're ready to profile this function:"
msgstr "ããã§ããã®é¢æ°ããã­ãã¡ã¤ã«ããæºåãã§ãã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:54
#, no-wrap
msgid ""
"julia> using Profile\n"
"\n"
"julia> @profile myfunc()\n"
msgstr ""
"julia> using Profile\n"
"\n"
"julia> @profile myfunc()\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:62
msgid ""
"To see the profiling results, there is a [graphical browser](https://github.com/timholy/ProfileView.jl)  available, but here we'll use the "
"text-based display that comes with the standard library:"
msgstr ""
"ãã­ãã¡ã¤ãªã³ã°çµæãç¢ºèªããã«ã¯ã[ã°ã©ãã£ã«ã«ãã©ã¦ã¶](https://github.com/timholy/ProfileView.jl)ãä½¿ç¨ã§ãã¾ãããããã§ã¯æ¨æºã©ã¤ãã©ãª"
"ã«ä»å±ã®ãã­ã¹ããã¼ã¹ã®è¡¨ç¤ºãä½¿ç¨ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:63
#, no-wrap
msgid ""
"julia> Profile.print()\n"
"80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\n"
" 80 ./REPL.jl:97; macro expansion\n"
"  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)\n"
"   80 ./boot.jl:235; eval(::Module, ::Any)\n"
"    80 ./<missing>:?; anonymous\n"
"     80 ./profile.jl:23; macro expansion\n"
"      52 ./REPL[1]:2; myfunc()\n"
"       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...\n"
"        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...\n"
"       14 ./random.jl:278; rand\n"
"        14 ./random.jl:277; rand\n"
"         14 ./random.jl:366; rand\n"
"          14 ./random.jl:369; rand\n"
"      28 ./REPL[1]:3; myfunc()\n"
"       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...\n"
"        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...\n"
"        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...\n"
msgstr ""
"julia> Profile.print()\n"
"80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\n"
" 80 ./REPL.jl:97; macro expansion\n"
"  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)\n"
"   80 ./boot.jl:235; eval(::Module, ::Any)\n"
"    80 ./<missing>:?; anonymous\n"
"     80 ./profile.jl:23; macro expansion\n"
"      52 ./REPL[1]:2; myfunc()\n"
"       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...\n"
"        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...\n"
"       14 ./random.jl:278; rand\n"
"        14 ./random.jl:277; rand\n"
"         14 ./random.jl:366; rand\n"
"          14 ./random.jl:369; rand\n"
"      28 ./REPL[1]:3; myfunc()\n"
"       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...\n"
"        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...\n"
"        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:91
msgid ""
"Each line of this display represents a particular spot (line number) in the code. Indentation is used to indicate the nested sequence of "
"function calls, with more-indented lines being deeper in the sequence of calls. In each line, the first \"field\" is the number of "
"backtraces (samples) taken *at this line or in any functions executed by this line*.  The second field is the file name and line number and "
"the third field is the function name.  Note that the specific line numbers may change as Julia's code changes; if you want to follow along, "
"it's best to run this example yourself."
msgstr ""
"ãã®è¡¨ç¤ºã®åè¡ã¯ãã³ã¼ãåã®ç¹å®ã®ã¹ããã (è¡çªå·) ãè¡¨ãã¾ããã¤ã³ãã³ãã¯ãå¥ãå­ã«ãªã£ãé¢æ°å¼ã³åºãã®ã·ã¼ã±ã³ã¹ãç¤ºãããã«ä½¿ç¨ãããã"
"ãã¤ã³ãã³ããããè¡ã¯å¼ã³åºãã®ã·ã¼ã±ã³ã¹ã®ä¸­ã§ããæ·±ããªãã¾ããåè¡ã§ãæåã®ããã£ã¼ã«ããã¯ã*ãã®è¡ã¾ãã¯ãã®è¡ã§å®è¡ãããé¢æ°*ã§åã"
"åãããããã¯ãã¬ã¼ã¹(ãµã³ãã«)ã®æ°ã§ãã 2 çªç®ã®ãã£ã¼ã«ãã¯ãã¡ã¤ã«åã¨è¡çªå·ã§ã3 çªç®ã®ãã£ã¼ã«ãã¯é¢æ°åã§ãã ã¸ã¥ãªã¢ã®ã³ã¼ããå¤æ´"
"ãããã«ã¤ãã¦ãç¹å®ã®è¡çªå·ãå¤æ´ãããå¯è½æ§ããããã¨ã«æ³¨æãã¦ãã ããããã®å¾ã®è©±ã«ã¤ãã¦ããããã«ããã®ä¾ãèªåã§å®è¡ããã®ããã¹ãã§"
"ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:98
msgid ""
"In this example, we can see that the top level function called is in the file `event.jl`. This is the function that runs the REPL when you "
"launch Julia. If you examine line 97 of `REPL.jl`, you'll see this is where the function `eval_user_input()` is called. This is the function "
"that evaluates what you type at the REPL, and since we're working interactively these functions were invoked when we entered `@profile "
"myfunc()`. The next line reflects actions taken in the [`@profile`](@ref)  macro."
msgstr ""
"ãã®ä¾ã§ã¯ãå¼ã³åºãããæä¸ä½é¢æ°ããã¡ã¤ã« `event.jl` ã«ãããã¨ããããã¾ããããã¯ãJulia èµ·åæã« REPL ãå®è¡ããé¢æ°ã§ãã`REPL.jl` ã® "
"97 è¡ãèª¿ã¹ãã¨ã`eval_user_input()` é¢æ°ãå¼ã³åºãããå ´æã§ãããã¨ãåããã¾ããããã¯REPLã§å¥åããåå®¹ãè©ä¾¡ããé¢æ°ã§ããä»ã¯ å¯¾è©±çã«"
"ä½æ¥­ãã¦ããã®ã§ã`@profile myfunc()` ãREPLããå¥åããã¨ãã«ãããã(è¨³æ³¨: `eval_user_input()ã®ãã¨ã ãããããªãè¤æ°?) ã®é¢æ°ãå¼ã³åºãã"
"ã¾ãããæ¬¡ã®è¡ã¯[`@profile`](@ref)ãã¯ã­ã§å®è¡ãããã¢ã¯ã·ã§ã³ãåæ ãã¦ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:103
msgid ""
"The first line shows that 80 backtraces were taken at line 73 of `event.jl`, but it's not that this line was \"expensive\" on its own: the "
"third line reveals that all 80 of these backtraces were actually triggered inside its call to `eval_user_input`, and so on. To find out "
"which operations are actually taking the time, we need to look deeper in the call chain."
msgstr ""
"æåã®è¡ã¯`event.jl`ã®73è¡ç®ã§80åã®ããã¯ãã¬ã¼ã¹ãåããããã¨ãç¤ºãã¦ãã¾ããããã®è¡èªä½ã®æ¼ç®ã³ã¹ããé«ãããã§ã¯æãã¾ããã: 3è¡ç®ãè¦"
"ãã°ããããã®ããã¯ãã¬ã¼ã¹ã®80åãã¹ã¦ãå®éã«`eval_user_input`ã¸ã®å¼ã³åºãã®ä¸­ã§ããªã¬ããããã¨ãæããã§ããå®éã«æéãããã£ã¦ããæä½"
"ãèª¿ã¹ãã«ã¯ãã³ã¼ã« ãã§ã¼ã³ãããæ·±ãèª¿ã¹ãå¿è¦ãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:105
msgid "The first \"important\" line in this output is this one:"
msgstr "ãã®åºåã®æåã® \"éè¦ãª\" è¡ã¯ããã§ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:106
#, no-wrap
msgid "52 ./REPL[1]:2; myfunc()\n"
msgstr "52 ./REPL[1]:2; myfunc()\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:115
msgid ""
"`REPL` refers to the fact that we defined `myfunc` in the REPL, rather than putting it in a file; if we had used a file, this would show the "
"file name. The `[1]` shows that the function `myfunc` was the first expression evaluated in this REPL session. Line 2 of `myfunc()` contains "
"the call to `rand`, and there were 52 (out of 80) backtraces that occurred at this line. Below that, you can see a call to "
"`dsfmt_fill_array_close_open!` inside `dSFMT.jl`."
msgstr ""
"`REPL` ã¯ãREPL ã§ `myfunc` ãå®ç¾©ããã¨ããäºå®ãæãã¾ãããã¡ã¤ã«ã«`myfunc`ãå®ç¾©ãããã¨ããããã§ã¯ããã¾ããããã¡ã¤ã«ãä½¿ç¨ãã¦ããå ´"
"åã¯ã(`REPL`ã®ä»£ããã«)ãã¡ã¤ã«åãè¡¨ç¤ºããã¾ãã`[1]` ã¯ãé¢æ° `myfunc` ããã® REPL ã»ãã·ã§ã³ã§è©ä¾¡ãããæåã®å¼ã§ãããã¨ãç¤ºãã¦ãã¾"
"ãã`myfunc()` ã® 2 è¡ç®ã«ã¯ `rand` ã®å¼ã³åºããå«ã¾ãã¦ããããã®è¡ã§çºçããããã¯ãã¬ã¼ã¹ã¯ 52 (80 ã®ãã¡) ã§ããããã®ä¸ã«ã¯ã`dSFMT.jl` "
"åã®`dSfmt_fill_array_close_open!` ã®å¼ã³åºããããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:117
msgid "A little further down, you see:"
msgstr "ããå°ãä¸ã«è¡ãã¨ãä¸è¨ã®è¡ãè¦ã¤ããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:118
#, no-wrap
msgid "28 ./REPL[1]:3; myfunc()\n"
msgstr "28 ./REPL[1]:3; myfunc()\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:125
msgid ""
"Line 3 of `myfunc` contains the call to `maximum`, and there were 28 (out of 80) backtraces taken here. Below that, you can see the specific "
"places in `base/reduce.jl` that carry out the time-consuming operations in the `maximum` function for this type of input data."
msgstr ""
"`myfunc` ã® 3 è¡ç®ã«ã¯`maximum`ã®å¼ã³åºãããããããã§ 28 (80 ä»¶ä¸­) ã®ããã¯ãã¬ã¼ã¹ãã«ã¦ã³ãããã¦ãã¾ãããã®ä¸ã«ã¯ããã®ã¿ã¤ãã®å¥åãã¼"
"ã¿ã«å¯¾ãã`maximum` é¢æ°åã®æéã®ãããå¦çãå®è¡ãã¦ããã`base/reduce.jl`ã®ããå ´æãç¢ºèªã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:129
msgid ""
"Overall, we can tentatively conclude that generating the random numbers is approximately twice as expensive as finding the maximum element. "
"We could increase our confidence in this result by collecting more samples:"
msgstr ""
"å¨ä½ã¨ãã¦ãä¹±æ°ã®çæã¯ãæå¤§ã®è¦ç´ ãè¦ã¤ããå¦çã®ç´2åã®ã³ã¹ãããããã¨æ«å®çã«çµè«ä»ãããã¨ãã§ãã¾ããããå¤ãã®ãµã³ãã«ãåéãããã¨"
"ã§ããã®çµæã«å¯¾ããç¢ºä¿¡ãæ·±ãããã¨ãã§ãã¾ãã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:130
#, no-wrap
msgid ""
"julia> @profile (for i = 1:100; myfunc(); end)\n"
"\n"
"julia> Profile.print()\n"
"[....]\n"
" 3821 ./REPL[1]:2; myfunc()\n"
"  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...\n"
"   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...\n"
"  310  ./random.jl:278; rand\n"
"   [....]\n"
" 2893 ./REPL[1]:3; myfunc()\n"
"  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...\n"
"   [....]\n"
msgstr ""
"julia> @profile (for i = 1:100; myfunc(); end)\n"
"\n"
"julia> Profile.print()\n"
"[....]\n"
" 3821 ./REPL[1]:2; myfunc()\n"
"  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...\n"
"   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...\n"
"  310  ./random.jl:278; rand\n"
"   [....]\n"
" 2893 ./REPL[1]:3; myfunc()\n"
"  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...\n"
"   [....]\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:150
msgid ""
"In general, if you have `N` samples collected at a line, you can expect an uncertainty on the order of `sqrt(N)` (barring other sources of "
"noise, like how busy the computer is with other tasks).  The major exception to this rule is garbage collection, which runs infrequently but "
"tends to be quite expensive. (Since Julia's garbage collector is written in C, such events can be detected using the `C=true` output mode "
"described below, or by using [ProfileView.jl](https://github.com/timholy/ProfileView.jl).)"
msgstr ""
"ä¸è¬ã«ãããè¡ã§ã®ã«ã¦ã³ãã`N` ãµã³ãã«ã§ãã£ãå ´åã(ã³ã³ãã¥ã¼ã¿ãä»ã®ã¿ã¹ã¯ã§ãã¸ã¼ç¶æã«ããããªã©ãä»ã®ãã¤ãºæºãé¤ãã¦), ãã®å¤ã®ä¸ç¢º"
"å®æ§ã¯ã `sqrt(N)`ã®ãªã¼ãã¼ã§ãããã¨ãæå¾ã§ãã¾ãããã®ã«ã¼ã«ã®ä¸»ãªä¾å¤ã¯ãå®è¡é »åº¦ã¯ä½ãããéå¸¸ã«æ¼ç®ã³ã¹ãã®é«ãå¾åãããã¬ãã¼ã¸ ã³ã¬"
"ã¯ã·ã§ã³ã§ãã(Julia ã®ã¬ãã¼ã¸ ã³ã¬ã¯ã¿ã¯ C ã§è¨è¿°ããã¦ããã®ã§ããã®ãããªã¤ãã³ãã¯ãä»¥ä¸ã«èª¬æãã `C=true` åºåã¢ã¼ããä½¿ç¨ãããã"
"[ProfileView.jl](https://github.com/timholy/ProfileView.jl) ãä½¿ç¨ãã¦æ¤åºã§ãã¾ãã)"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:153
msgid "This illustrates the default \"tree\" dump; an alternative is the \"flat\" dump, which accumulates counts independent of their nesting:"
msgstr ""
"ããã¯ãããã©ã«ãåºåã§ãã ãããªã¼åããã³ããç¤ºãã¦ãã¾ã; ä»ã«ã¯ãä»£æ¿æ¡ã¯ãå¥ãå­æ§é ã«ä¾å­ããã«ã«ã¦ã³ããèç©ããããã©ããããã³ãã§"
"ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:154
#, no-wrap
msgid ""
"julia> Profile.print(format=:flat)\n"
" Count File          Line Function\n"
"  6714 ./<missing>     -1 anonymous\n"
"  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)\n"
"  6714 ./REPL.jl       97 macro expansion\n"
"  3821 ./REPL[1]        2 myfunc()\n"
"  2893 ./REPL[1]        3 myfunc()\n"
"  6714 ./REPL[7]        1 macro expansion\n"
"  6714 ./boot.jl      235 eval(::Module, ::Any)\n"
"  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...\n"
"  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\n"
"  6714 ./profile.jl    23 macro expansion\n"
"  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...\n"
"   310 ./random.jl    277 rand\n"
"   310 ./random.jl    278 rand\n"
"   310 ./random.jl    366 rand\n"
"   310 ./random.jl    369 rand\n"
"  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...\n"
"     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n"
"   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n"
"  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n"
"    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:181
msgid ""
"If your code has recursion, one potentially-confusing point is that a line in a \"child\" function can accumulate more counts than there are "
"total backtraces. Consider the following function definitions:"
msgstr ""
"ã³ã¼ãã§åå¸°ãä½¿ããã¦ããå ´åã\"å­\" é¢æ°ã®è¡ãåè¨ããã¯ãã¬ã¼ã¹ãããå¤ãã®ã«ã¦ã³ããèç©ããå¯è½æ§ãããã¾ããæ¬¡ã®é¢æ°å®ç¾©ãèãã¦ã¿ã¾"
"ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:182
#, no-wrap
msgid ""
"dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)\n"
"dumbsum3() = dumbsum(3)\n"
msgstr ""
"dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)\n"
"dumbsum3() = dumbsum(3)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:189
msgid "If you were to profile `dumbsum3`, and a backtrace was taken while it was executing `dumbsum(1)`, the backtrace would look like this:"
msgstr "`dumbsum3` ããã­ãã¡ã¤ãªã³ã°ãã`dumbsum(1)` ã®å®è¡ä¸­ã«ããã¯ãã¬ã¼ã¹ãåå¾ãããå ´åãããã¯ãã¬ã¼ã¹ã¯æ¬¡ã®ããã«ãªãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:190
#, no-wrap
msgid ""
"dumbsum3\n"
"    dumbsum(3)\n"
"        dumbsum(2)\n"
"            dumbsum(1)\n"
msgstr ""
"dumbsum3\n"
"    dumbsum(3)\n"
"        dumbsum(2)\n"
"            dumbsum(1)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:200
msgid ""
"Consequently, this child function gets 3 counts, even though the parent only gets one. The \"tree\" representation makes this much clearer, "
"and for this reason (among others) is probably the most useful way to view the results."
msgstr ""
"ãã®çµæãè¦ªã§ã¯1ã«ã¦ã³ãã®ã¿ãªã®ã«å¯¾ãã¦ããã®å­é¢æ°ã¯ 3 ã«ã¦ã³ããåå¾ãã¾ãããããªã¼ãè¡¨ç¾ã¯ãããããæç¢ºã«ãã¾ãããã®ãããããªã¼è¡¨ç¾"
"ã¯ (ç¹ã«) çµæãè¡¨ç¤ºããéã«æãä¾¿å©ãªæ¹æ³ã§ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/profile.md:201
#, no-wrap
msgid "Accumulation and clearing"
msgstr "èç©ã¨ã¯ãªã¢"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:206
msgid ""
"Results from [`@profile`](@ref) accumulate in a buffer; if you run multiple pieces of code under [`@profile`](@ref), then [`Profile.print()`]"
"(@ref) will show you the combined results. This can be very useful, but sometimes you want to start fresh; you can do so with [`Profile."
"clear()`](@ref)."
msgstr ""
"[`@profile`](@ref)ã®çµæã¯ãããã¡ã«èç©ããã¾ãã[`@profile`](@ref)ã§è¤æ°ã®ã³ã¼ããå®è¡ããã¨ã[`Profile.print()`](@ref)ã¯ããããè¤æ°ã®ã³ã¼"
"ãã®ãã­ãã¡ã¤ã«ã®çµæãçµåããçµæãåºåãã¾ããããã¯éå¸¸ã«ä¾¿å©ã§ããããã­ãã¡ã¤ã«ãæ°ãã«éå§ãããå ´åãããã¾ãããã®å ´åã¯ã"
"[`Profile.clear()`](@ref)ã§ãã¯ãªã¢ã§ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/manual/profile.md:207
#, no-wrap
msgid "Options for controlling the display of profile results"
msgstr "ãã­ãã¡ã¤ã«çµæã®è¡¨ç¤ºãå¶å¾¡ãããªãã·ã§ã³"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:210
msgid "[`Profile.print`](@ref) has more options than we've described so far. Let's see the full declaration:"
msgstr "[`Profile.print`](@ref) ã¯ãããã¾ã§èª¬æããä»¥å¤ã«ãå¤ãã®ãªãã·ã§ã³ãæã£ã¦ãã¾ããå¨ã¦ããã§è¦ã¦ã¿ã¾ããã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:211
#, no-wrap
msgid "function print(io::IO = stdout, data = fetch(); kwargs...)\n"
msgstr "function print(io::IO = stdout, data = fetch(); kwargs...)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:216
msgid "Let's first discuss the two positional arguments, and later the keyword arguments:"
msgstr "ã¾ã 2 ã¤ã®ä½ç½®å¼æ°ã«ã¤ãã¦èª¬æããå¾ã«ã­ã¼ã¯ã¼ãå¼æ°ãèª¬æãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/profile.md:222
msgid "`io` -- Allows you to save the results to a buffer, e.g. a file, but the default is to print to `stdout` (the console)."
msgstr "`io` -- ãã¡ã¤ã«ãªã©ã®ãããã¡ã«çµæãä¿å­ãããããã©ã«ãã§ã¯`stdout` (ã³ã³ã½ã¼ã«) ã¸ã®ããªã³ãåºåã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/manual/profile.md:222
msgid ""
"`data` -- Contains the data you want to analyze; by default that is obtained from [`Profile.fetch()`](@ref), which pulls out the backtraces "
"from a pre-allocated buffer. For example, if you want to profile the profiler, you could say:"
msgstr ""
"`data` -- åæããããã¼ã¿ãæå®ãã; ããã©ã«ãã§ã¯ãäºåå²ãå½ã¦ããããããã¡ã¼ããããã¯ãã¬ã¼ã¹æå ±ãåãåºã [`Profile.fetch()`](@ref) "
"ããåå¾ããã¾ããã¨ãã°ããã­ãã¡ã¤ã©ã¼ããã­ãã¡ã¤ãªã³ã°ããå ´åã¯ãæ¬¡ã®ããã«æå®ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:229
#, no-wrap
msgid ""
"    ```julia\n"
"    data = copy(Profile.fetch())\n"
"    Profile.clear()\n"
"    @profile Profile.print(stdout, data) # Prints the previous results\n"
"    Profile.print()                      # Prints results from Profile.print()\n"
"    ```\n"
msgstr ""
"    ```julia\n"
"    data = copy(Profile.fetch())\n"
"    Profile.clear()\n"
"    @profile Profile.print(stdout, data) # Prints the previous results\n"
"    Profile.print()                      # Prints results from Profile.print()\n"
"    ```\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:231
msgid "The keyword arguments can be any combination of:"
msgstr "ã­ã¼ã¯ã¼ãå¼æ°ã«ã¯ãæ¬¡ã®ä»»æã®çµã¿åãããæå®ã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:251
#, no-wrap
msgid ""
"  * `format` -- Introduced above, determines whether backtraces are printed\n"
"     with (default, `:tree`) or without (`:flat`) indentation indicating tree\n"
"     structure.\n"
"  * `C` -- If `true`, backtraces from C and Fortran code are shown (normally they are excluded). Try running the introductory\n"
"    example with `Profile.print(C = true)`. This can be extremely helpful in deciding whether it's\n"
"    Julia code or C code that is causing a bottleneck; setting `C = true` also improves the interpretability\n"
"    of the nesting, at the cost of longer profile dumps.\n"
"  * `combine` -- Some lines of code contain multiple operations; for example, `s += A[i]` contains both an array\n"
"    reference (`A[i]`) and a sum operation. These correspond to different lines in the generated\n"
"    machine code, and hence there may be two or more different addresses captured during backtraces\n"
"    on this line. `combine = true` lumps them together, and is probably what you typically want, but\n"
"    you can generate an output separately for each unique instruction pointer with `combine = false`.\n"
"  * `maxdepth` -- Limits frames at a depth higher than `maxdepth` in the `:tree` format.\n"
"  * `sortedby` -- Controls the order in `:flat` format. `:filefuncline` (default) sorts by the source\n"
"    line, whereas `:count` sorts in order of number of collected samples.\n"
"  * `noisefloor` -- Limits frames that are below the heuristic noise floor of the sample (only applies to format `:tree`).\n"
"    A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which `n <= noisefloor * âN`,\n"
"    where `n` is the number of samples on this line, and `N` is the number of samples for the callee.\n"
"  * `mincount` -- Limits frames with less than `mincount` occurrences.\n"
msgstr ""
"  * `format` -- ä¸ã§ç´¹ä»ããããã«ãããã¯ãã¬ã¼ã¹ã®è¡¨ç¤ºå½¢å¼ãæ±ºå®ãã¾ãã\n"
"     é¢æ°ã³ã¼ã«ã®æ¨æ§é ãç¤ºãã¤ã³ãã³ããç¨ãã `:tree`(ããã©ã«ã) ã¨ã¤ã³ãã³ãç¡ãã®`:flat`\n"
"  * `C` -- `true` ã®å ´åãC ã³ã¼ãã¨ Fortran ã³ã¼ãããã®ããã¯ãã¬ã¼ã¹ãè¡¨ç¤ºããã¾ã (éå¸¸ã¯é¤å¤ããã¾ã)ã\n"
"    `Profile.print(C = true)`ã®ç´¹ä»ä¾ãç¤ºãã®ã§å®è¡ãã¦ã¿ã¦ãã ããããã®æ©è½ã¯ãããã«ããã¯ã«ãªã£ã¦ããã®ã Juliaã³ã¼ããªã®ããCã³ã¼ãã®é¨åãªã®ãå¤æ­ããã®ã«å¤§å¤å½¹ç«ã¡ã¾ãã\n"
"    `C = true` ãè¨­å®ããã¨ãããé·ããã­ãã¡ã¤ã«ãã³ãã«ãªã£ã¦ãã¾ãã¾ããããã¹ãã®è§£éã¯ãããããªãã¾ãã\n"
"  * `combine` -- ã³ã¼ãè¡ã®ä¸­ã«ã¯è¤æ°ã®æä½ãå«ã¾ãã¦ãããã¨ãããã¾ãããã¨ãã°ã`s += A[i]` ã«ã¯éåã®åç§(`A[i]`)ã¨å ç®ã®ä¸¡æ¹ãå«ã¾ãã¦ãã¾ãã\n"
"    ãããã¯ãçæããããã·ã³ã³ã¼ãã§ã¯ãå¥ãã®è¡ã«å¯¾å¿ãã¦ãã¾ãããã®ããããã®è¡ã®ããã¯ãã¬ã¼ã¹ä¸­ã§2ã¤ä»¥ä¸ã®ç°ãªãã¢ãã¬ã¹ãã­ã£ããã£ããããã¾ããã\n"
"    `combine = true` ãªãã·ã§ã³ã¯ããããä¸ç·ã«ã¾ã¨ãã¾ããããã¯ããããããªããéå¸¸æãåä½ã§ãããã\n"
"    ãã ãã`combine = false` ãªãã·ã§ã³ãä½¿ãã°ãä¸æã®å½ä»¤ãã¤ã³ã¿ã¼ãã¨ã«ã«åºåãçæãããã¨ãã§ãã¾ãã\n"
"  * `maxdepth` -- `:tree` å½¢å¼ã§ã® `maxdepth` ããããã«å¤§ããå¤ãæã¤æ·±ãã§è¡¨ç¤ºãããã¬ã¼ã ãå¶éãã¾ãã\n"
"  * `sortby` -- `:flat` å½¢å¼ã§ã®è¡¨ç¤ºé åºãå¶å¾¡ãã¾ãã`:filefuncline` (ããã©ã«ã) ã¯ã½ã¼ã¹ãã¡ã¤ã«ã«ããã½ã¼ãã`:count` ã¯åéããããµã³ãã«ã®æ°ã®é çªã§ã®ã½ã¼ãã§ãã\n"
"  * `noisefloor` -- ãµã³ãã«æ°ã®ãã¤ãºãã­ã¢ããã¥ã¼ãªã¹ãã£ãã¯ã«æå®ãã¾ãããã¤ãºãã­ã¢ããä¸ã®ãã¬ã¼ã ã¯è¡¨ç¤ºãå¶éããã¾ã(ãã©ã¼ããã`:tree`ã«ã®ã¿é©ç¨ããã¾ã)ã\n"
"    ãããè©¦ãéã®æ¨å¥¨å¤ã¯ 2.0 ã§ã (ããã©ã«ãã¯ 0)ããã®ãã©ã¡ã¼ã¿ã¼ã¯ã`n <= ãã¤ãºãã­ã¢ * âN` ã®ãµã³ãã«ãéè¡¨ç¤ºã«ãã¾ãã\n"
"    ããã§ `n` ã¯ããã®è¡ã®ãµã³ãã«ã®æ°ã§ã`N` ã¯å¼ã³åºãåã®ãµã³ãã«ã®æ°ã§ãã\n"
"  * `mincount` -- ããã§æå®ããå¤ãããå°ãããªã«ã¬ã³ã¹ã®ãã¬ã¼ã ãå¶éãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:256
msgid ""
"File/function names are sometimes truncated (with `...`), and indentation is truncated with a `+n` at the beginning, where `n` is the number "
"of extra spaces that would have been inserted, had there been room. If you want a complete profile of deeply-nested code, often a good idea "
"is to save to a file using a wide `displaysize` in an [`IOContext`](@ref):"
msgstr ""
"ãã¡ã¤ã«/é¢æ°åã¯ã(`...`) ãä½¿ã£ã¦åãæ¨ã¦è¡¨ç¤ºããããã¨ãããã¾ãã ã¾ããã¤ã³ãã³ãã¯åé ­ã§ `+n` ã§åãæ¨ã¦ããã¾ããããã§ `n` ã¯æ¿å¥ãã"
"ãè¿½å ã®ã¹ãã¼ã¹ã®æ°ã§ããæ·±ããã¹ããããã³ã¼ãã®å®å¨ãªãã­ãã¡ã¤ã«ãå¿è¦ãªå ´åã¯ã[`IOContext`](@ref)ã§åºããè¡¨ç¤ºãµã¤ãºããä½¿ç¨ãã¦ãã¡ã¤ã«"
"ã«ä¿å­ãããã¨ããèãããã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:257
#, no-wrap
msgid ""
"open(\"/tmp/prof.txt\", \"w\") do s\n"
"    Profile.print(IOContext(s, :displaysize => (24, 500)))\n"
"end\n"
msgstr ""
"open(\"/tmp/prof.txt\", \"w\") do s\n"
"    Profile.print(IOContext(s, :displaysize => (24, 500)))\n"
"end\n"

#. type: Title ##
#: ext/julia/doc/src/manual/profile.md:263
#, no-wrap
msgid "Configuration"
msgstr "æ§æã»è¨­å®"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:270
msgid ""
"[`@profile`](@ref) just accumulates backtraces, and the analysis happens when you call [`Profile.print()`](@ref).  For a long-running "
"computation, it's entirely possible that the pre-allocated buffer for storing backtraces will be filled. If that happens, the backtraces "
"stop but your computation continues.  As a consequence, you may miss some important profiling data (you will get a warning when that "
"happens)."
msgstr ""
"[`@profile`](@ref) ã¯ããã¯ãã¬ã¼ã¹ãèç©ããã ãã§ããå®éã®åæã¯ã[`Profile.print()`](@ref)ãå¼ã³åºããã¨ãã«è¡ããã¾ããå®è¡æéã®é·ãè¨"
"ç®ã§ã¯ãããã¯ãã¬ã¼ã¹ãæ ¼ç´ããããã«äºåã«å²ãå½ã¦ããããããã¡ããã£ã±ãã«ãªãå¯è½æ§ãããã¾ãããã®å ´åãããã¯ãã¬ã¼ã¹ã¯åæ­¢ãã¾ããã"
"ãã­ãã¡ã¤ã«å¯¾è±¡ã®è¨ç®èªä½ã¯ç¶è¡ããã¾ãã ãã®çµæãããã¤ãã®éè¦ãªãã­ãã¡ã¤ãªã³ã° ãã¼ã¿ãè¦éãå¯è½æ§ãããã¾ã (ãã®å ´åã¯è­¦åãè¡¨ç¤ºã"
"ãã¾ã)ã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:272
msgid "You can obtain and configure the relevant parameters this way:"
msgstr "ä»¥ä¸ã§ãé¢é£ãããã©ã¡ã¼ã¿ãåå¾ããã³æ§æã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:273
#, no-wrap
msgid ""
"Profile.init() # returns the current settings\n"
"Profile.init(n = 10^7, delay = 0.01)\n"
msgstr ""
"Profile.init() # returns the current settings\n"
"Profile.init(n = 10^7, delay = 0.01)\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:281
msgid ""
"`n` is the total number of instruction pointers you can store, with a default value of `10^6`.  If your typical backtrace is 20 instruction "
"pointers, then you can collect 50000 backtraces, which suggests a statistical uncertainty of less than 1%. This may be good enough for most "
"applications."
msgstr ""
"`n` ã¯ãæ ¼ç´ã§ããå½ä»¤ãã¤ã³ã¿ã¼ã®åè¨æ°ã§ãããã©ã«ãå¤ã¯ `10^6` ã§ãã ä¸è¬çãªããã¯ãã¬ã¼ã¹ã 20 ã®å½ä»¤ãã¤ã³ã¿ã§ããå ´åã¯ã50000 ããã¯"
"ãã¬ã¼ã¹ãåéã§ãããããçµ±è¨çãªä¸ç¢ºå®æ§ã 1% æªæºã§ãããã¨ãç¤ºåãã¦ãã¾ããããã¯ãã»ã¨ãã©ã®ã¢ããªã±ã¼ã·ã§ã³ã§ååã§ãããã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:288
msgid ""
"Consequently, you are more likely to need to modify `delay`, expressed in seconds, which sets the amount of time that Julia gets between "
"snapshots to perform the requested computations. A very long-running job might not need frequent backtraces. The default setting is `delay = "
"0.001`.  Of course, you can decrease the delay as well as increase it; however, the overhead of profiling grows once the delay becomes "
"similar to the amount of time needed to take a backtrace (~30 microseconds on the author's laptop)."
msgstr ""
"`delay`ã¯ãè¦æ±ãããè¨ç®ãå®è¡ããããã®è¤æ°ã¹ãããã·ã§ããã®éã§Juliaãåå¾ããæéé·ãç§åä½ã§è¡¨è¨ãããã®ã§ãããåæã®ãããªç¶æ³ã§ãã"
"ã°ãã®çµæããã®`delay`ã®ä¿®æ­£ãå¿è¦ã«ãªãå¯è½æ§ãé«ããªãã¾ããéå¸¸ã«é·ãæéå®è¡ãããã¸ã§ãã§ã¯ãé »ç¹ãªããã¯ãã¬ã¼ã¹ã¯å¿è¦ãªãå ´åãããã¾"
"ããããã©ã«ãã®è¨­å®ã¯'éå»¶ = 0.001'ã§ãã ãã¡ãããéå»¶ãæ¸ããã ãã§ãªããéå»¶ãå¢ãããã¨ãã§ãã¾ãããã ããéå»¶ãããã¯ãã¬ã¼ã¹ (ä½æè"
"ã®ã©ãããããã§ç´ 30 ãã¤ã¯ã­ç§) ãåãã®ã«å¿è¦ãªæéã«è¿ããªãã¨ããã­ãã¡ã¤ãªã³ã°ã®ãªã¼ãã¼ããããå¤§ãããªãã¾ãã"

#. type: Title #
#: ext/julia/doc/src/manual/profile.md:289
#, no-wrap
msgid "Memory allocation analysis"
msgstr "[ã¡ã¢ãªå²ãå½ã¦åæ](@id Memory-allocation-analysis)"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:296
msgid ""
"One of the most common techniques to improve performance is to reduce memory allocation. The total amount of allocation can be measured with "
"[`@time`](@ref) and [`@allocated`](@ref), and specific lines triggering allocation can often be inferred from profiling via the cost of "
"garbage collection that these lines incur. However, sometimes it is more efficient to directly measure the amount of memory allocated by "
"each line of code."
msgstr ""
"ããã©ã¼ãã³ã¹ãåä¸ãããæãä¸è¬çãªææ³ã® 1 ã¤ã¯ãã¡ã¢ãªå²ãå½ã¦ãæ¸ãããã¨ã§ããã¡ã¢ãªå²ãå½ã¦ã®åè¨éã¯[`@time`](@ref)ã¨[`@allocated`]"
"(@ref)ã§æ¸¬å®ãããã¨ãã§ããã¡ã¢ãªå²ãå½ã¦ãããªã¬ããç¹å®ã®è¡ã¯ãå¤ãã®å ´åããããã®è¡ã§çºçããã¬ãã¼ã¸ã³ã¬ã¯ã·ã§ã³ã«ããæ¼ç®ã³ã¹ããä»ã"
"ã¦ãã­ãã¡ã¤ãªã³ã°ããæ¨æ¸¬ãããã¨ãã§ãã¾ãããã ããã³ã¼ãè¡ãã¨ã«å²ãå½ã¦ãããã¡ã¢ãªã®éãç´æ¥æ¸¬å®ããæ¹ãå¹ççãªå ´åãããã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:305
#, no-wrap
msgid ""
"To measure allocation line-by-line, start Julia with the `--track-allocation=<setting>` command-line\n"
"option, for which you can choose `none` (the default, do not measure allocation), `user` (measure\n"
"memory allocation everywhere except Julia's core code), or `all` (measure memory allocation at\n"
"each line of Julia code). Allocation gets measured for each line of compiled code. When you quit\n"
"Julia, the cumulative results are written to text files with `.mem` appended after the file name,\n"
"residing in the same directory as the source file. Each line lists the total number of bytes\n"
"allocated. The [`Coverage` package](https://github.com/JuliaCI/Coverage.jl) contains some elementary\n"
"analysis tools, for example to sort the lines in order of number of bytes allocated.\n"
msgstr ""
"ã¡ã¢ãªå²ãå½ã¦ã 1 è¡ãã¤æ¸¬å®ããã«ã¯ã`--track-allocation=<setting>`ã³ãã³ãã©ã¤ã³ãªãã·ã§ã³ãã¤ããã¦Julia ãèµ·åãã¾ãã\n"
"é¸æå¯è½ãªãªãã·ã§ã³ã¯ã`none` (ããã©ã«ãå¤ãã¡ã¢ãªå²ãå½ã¦ãæ¸¬å®ããªã) ã`user`(Juliaã®ã³ã¢ã³ã¼ããé¤ããJuliaã³ã¼ãã®åè¡ã«ãããã¡ã¢ãªå²ãå½ã¦ãæ¸¬å®ãã), `all`(å¨Juliaã³ã¼ãã®åè¡ã§ã¡ã¢ãªå²ãå½ã¦ãæ¸¬å®)ã§ãã\n"
"Juliaçµäºæãåã½ã¼ã¹ãã¡ã¤ã«ã®ãã¡ã¤ã«åã®å¾ã«`.mem`ãä»å ããããã­ã¹ããã¡ã¤ã«ã«æ¸ãè¾¼ã¾ãã¾ããåºååã¯ãã½ã¼ã¹ ãã¡ã¤ã«ã¨åããã£ã¬ã¯ããªã§ãã\n"
"åè¡ã«ã¯ãåè¨ãã¤ãæ°ãä¸è¦§è¡¨ç¤ºããã¾ãã[`Coverage` ããã±ã¼ã¸](https://github.com/JuliaCI/Coverage.jl) ã«ã¯ãåºæ¬çãªåæãã¼ã«ãä¾ãã° ã¡ã¢ãªå²ãå½ã¦ã®ãã¤ãæ°ã§ã®è¡ã½ã¼ããªã©ããå«ã¾ãã¦ãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:314
#, no-wrap
msgid ""
"In interpreting the results, there are a few important details. Under the `user` setting, the\n"
"first line of any function directly called from the REPL will exhibit allocation due to events\n"
"that happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation\n"
"counts, because much of Julia's compiler is written in Julia (and compilation usually requires\n"
"memory allocation). The recommended procedure is to force compilation by executing all the commands\n"
"you want to analyze, then call [`Profile.clear_malloc_data()`](@ref) to reset all allocation counters.\n"
" Finally, execute the desired commands and quit Julia to trigger the generation of the `.mem`\n"
"files.\n"
msgstr ""
"çµæãè§£éããéã«ã¯ãããã¤ãéè¦ãªè©³ç´°æå ±ãããã®ã§æ°ãã¤ãã¦ãã ããã\n"
"`--track-allocation=user` ã§å®è¡ããå ´åãREPL ããç´æ¥å¼ã³åºãããé¢æ°ã®æåã®è¡ã«ã¯ãREPLããã®é¢æ°ã³ã¼ã«èªä½ã«å«ã¾ãã¡ã¢ãªå²ãå½ã¦ã®æå ±ãç¤ºããã¾ãã\n"
"ããã«éè¦ãªã®ã¯ãã¸ã¥ãªã¢ã®ã³ã³ãã¤ã©ã®å¤ãã¯ã¸ã¥ãªã¢ã§æ¸ããã¦ããã®ã§(ããã¦ã³ã³ãã¤ã«ã¯éå¸¸ã¡ã¢ãªå²å½ãå¿è¦ãªã®ã§)ãJIT ã³ã³ãã¤ã«ã«ãã£ã¦ã¡ã¢ãªå²ãå½ã¦ã«ã¦ã³ããè¿½å ãããã¨ãããã¨ã§ããæ¨å¥¨ãããæé ã¯ããã¹ã¦ã®åæããããã¹ã¦ã®ã³ãã³ãããå®è¡ãã¦å¼·å¶çã«ã³ã³ãã¤ã«ãã¦ããã[`Profile.clear_malloc_data()`](@ref)ãå¼ã³åºãã¦ããã¹ã¦ã®å²ãå½ã¦ã«ã¦ã³ã¿ããªã»ãããããã¨ã§ãã\n"
" æå¾ã«ãç®çã®ã³ãã³ããå®è¡ããã¸ã¥ãªã¢ãçµäºãã¦ '.mem'ãã¡ã¤ã«ã®çæãããªã¬ã¼ãã¾ãã\n"

#. type: Title #
#: ext/julia/doc/src/manual/profile.md:315
#, no-wrap
msgid "External Profiling"
msgstr "å¤é¨ã®ãã­ãã¡ã¤ãªã³ã°ãã¼ã«"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:318
msgid "Currently Julia supports `Intel VTune`, `OProfile` and `perf` as external profiling tools."
msgstr "ç¾å¨ãJuliaã¯å¤é¨ãã­ãã¡ã¤ãªã³ã°ãã¼ã«ã¨ãã¦`Intel VTune`ã`OProfile`ã`perf`ããµãã¼ããã¦ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:321
msgid ""
"Depending on the tool you choose, compile with `USE_INTEL_JITEVENTS`, `USE_OPROFILE_JITEVENTS` and `USE_PERF_JITEVENTS` set to 1 in `Make."
"user`. Multiple flags are supported."
msgstr ""
"é¸æãããã¼ã«ã«å¿ãã¦ã`Make.user`ãã¡ã¤ã«åã§ã`USE_INTEL_JITEVENTS`ã`USE_OPROFILE_JITEVENTS`ã`USE_PERF_JITEVENTS` ãªã©ã1ã«è¨­å®ãã¦ã³ã³"
"ãã¤ã«ãã¦ãã ãããè¤æ°ã®ãã©ã°ããµãã¼ãããã¦ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:323
msgid "Before running Julia set the environment variable `ENABLE_JITPROFILING` to 1."
msgstr "Julia ãå®è¡ããåã«ãç°å¢å¤æ° `ENABLE_JITPROFILING` ã 1 ã«è¨­å®ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:326
msgid "Now you have a multitude of ways to employ those tools! For example with `OProfile` you can try a simple recording :"
msgstr "ããã§ãããªãã¯ãããã®ãã¼ã«ãä½¿ç¨ããå¤æ°ã®æ¹æ³ãæã«å¥ãã¾ããããã¨ãã°ã`OProfile` ãä½¿ç¨ããã¨ãç°¡åãªè¨é²ããããã¨ãã§ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:327
#, no-wrap
msgid ""
">ENABLE_JITPROFILING=1 sudo operf -Vdebug ./julia test/fastmath.jl\n"
">opreport -l `which ./julia`\n"
msgstr ""
">ENABLE_JITPROFILING=1 sudo operf -Vdebug ./julia test/fastmath.jl\n"
">opreport -l `which ./julia`\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:333
msgid "Or similary with with `perf` :"
msgstr "ã¾ãã¯ `perf`ã¨ã«ãããæ¹ã§:"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:334
#, no-wrap
msgid ""
"$ ENABLE_JITPROFILING=1 perf record -o /tmp/perf.data --call-graph dwarf ./julia /test/fastmath.jl\n"
"$ perf report --call-graph -G\n"
msgstr ""
"$ ENABLE_JITPROFILING=1 perf record -o /tmp/perf.data --call-graph dwarf ./julia /test/fastmath.jl\n"
"$ perf report --call-graph -G\n"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:341
msgid ""
"There are many more interesting things that you can measure about your program, to get a comprehensive list please read the [Linux perf "
"examples page](http://www.brendangregg.com/perf.html)."
msgstr ""
"ããªãã®ãã­ã°ã©ã ã¤ãã¦æ¸¬å®ãè¡ãæ¹æ³ã¯ä»ã«ããããããããèå³æ·±ãã§ããåæ¬çãªãªã¹ããè¦ãããã°,[Linux perfã®ä¾ã®ãã¼ã¸](http://www."
"brendangregg.com/perf.html)ãèª­ãã§ãã ããã"

#. type: Plain text
#: ext/julia/doc/src/manual/profile.md:344
msgid ""
"Remember that perf saves for each execution a `perf.data` file that, even for small programs, can get quite large. Also the perf LLVM module "
"saves temporarily debug objects in `~/.debug/jit`, remember to clean that folder frequently."
msgstr ""
"å®è¡ãã¨ã«perfã¯ã `perf.data` ãã¡ã¤ã«ãä¿å­ããå°è¦æ¨¡ãªãã­ã°ã©ã ã®å ´åã§ãéå¸¸ã«å¤§ããªãã¡ã¤ã«ãä¿å­ã§ãããã¨ãè¦ãã¦ããã¦ãã ãããã¾"
"ããperf LLVMã¢ã¸ã¥ã¼ã«ã¯ãä¸æçã«ãããã°ãªãã¸ã§ã¯ãã`~/.debug/jit`ã«ä¿å­ãã¾ãããããã®ãã©ã«ããé »ç¹ã«ã¯ãªã¼ã³ã¢ãããããã¨ãå¿ããªã"
"ã§ãã ããã"

#. type: Title #
#: ext/julia/doc/src/manual/unicode-input.md:1
#, no-wrap
msgid "Unicode Input"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/unicode-input.md:9
msgid ""
"The following table lists Unicode characters that can be entered via tab completion of LaTeX-like abbreviations in the Julia REPL (and in "
"various other editing environments).  You can also get information on how to type a symbol by entering it in the REPL help, i.e. by typing `?"
"` and then entering the symbol in the REPL (e.g., by copy-paste from somewhere you saw the symbol)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/unicode-input.md:17
#, no-wrap
msgid ""
"    This table may appear to contain missing characters in the second column, or even\n"
"    show characters that are inconsistent with the characters as they are rendered in\n"
"    the Julia REPL. In these cases, users are strongly advised to check their choice\n"
"    of fonts in their browser and REPL environment, as there are known issues with\n"
"    glyphs in many fonts.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/unicode-input.md:18
#, no-wrap
msgid ""
"#\n"
"# Generate a table containing all LaTeX and Emoji tab completions available in the REPL.\n"
"#\n"
"import REPL, Markdown\n"
"const NBSP = '\\u00A0'\n"
"\n"
"function tab_completions(symbols...)\n"
"    completions = Dict{String, Vector{String}}()\n"
"    for each in symbols, (k, v) in each\n"
"        completions[v] = push!(get!(completions, v, String[]), k)\n"
"    end\n"
"    return completions\n"
"end\n"
"\n"
"function unicode_data()\n"
"    file = normpath(@__DIR__, \"..\", \"..\", \"..\", \"..\", \"..\", \"doc\", \"UnicodeData.txt\")\n"
"    names = Dict{UInt32, String}()\n"
"    open(file) do unidata\n"
"        for line in readlines(unidata)\n"
"            id, name, desc = split(line, \";\")[[1, 2, 11]]\n"
"            codepoint = parse(UInt32, \"0x$id\")\n"
"            names[codepoint] = titlecase(lowercase(\n"
"                name == \"\" ? desc : desc == \"\" ? name : \"$name / $desc\"))\n"
"        end\n"
"    end\n"
"    return names\n"
"end\n"
"\n"
"# Surround combining characters with no-break spaces (i.e '\\u00A0'). Follows the same format\n"
"# for how unicode is displayed on the unicode.org website:\n"
"# http://unicode.org/cldr/utility/character.jsp?a=0300\n"
"function fix_combining_chars(char)\n"
"    cat = Base.Unicode.category_code(char)\n"
"    return cat == 6 || cat == 8 ? \"$NBSP$char$NBSP\" : \"$char\"\n"
"end\n"
"\n"
"\n"
"function table_entries(completions, unicode_dict)\n"
"    entries = [[\n"
"        \"Code point(s)\", \"Character(s)\",\n"
"        \"Tab completion sequence(s)\", \"Unicode name(s)\"\n"
"    ]]\n"
"    for (chars, inputs) in sort!(collect(completions), by = first)\n"
"        code_points, unicode_names, characters = String[], String[], String[]\n"
"        for char in chars\n"
"            push!(code_points, \"U+$(uppercase(string(UInt32(char), base = 16, pad = 5)))\")\n"
"            push!(unicode_names, get(unicode_dict, UInt32(char), \"(No Unicode name)\"))\n"
"            push!(characters, isempty(characters) ? fix_combining_chars(char) : \"$char\")\n"
"        end\n"
"        push!(entries, [\n"
"            join(code_points, \" + \"), join(characters),\n"
"            join(inputs, \", \"), join(unicode_names, \" + \")\n"
"        ])\n"
"    end\n"
"    return Markdown.Table(entries, [:l, :l, :l, :l])\n"
"end\n"
"\n"
"table_entries(\n"
"    tab_completions(\n"
"        REPL.REPLCompletions.latex_symbols,\n"
"        REPL.REPLCompletions.emoji_symbols\n"
"    ),\n"
"    unicode_data()\n"
")\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/manual/interfaces.md:1
#, no-wrap
msgid "Interfaces"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:7
#, no-wrap
msgid ""
"A lot of the power and extensibility in Julia comes from a collection of informal interfaces.\n"
" By extending a few specific methods to work for a custom type, objects of that type not only\n"
"receive those functionalities, but they are also able to be used in other methods that are written\n"
"to generically build upon those behaviors.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/interfaces.md:8
#, no-wrap
msgid "[Iteration](@id man-interface-iteration)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:20
#, no-wrap
msgid ""
"| Required methods               | Â                       | Brief description                                                                     |\n"
"|:------------------------------ |:---------------------- |:------------------------------------------------------------------------------------- |\n"
"| `iterate(iter)`                | Â                       | Returns either a tuple of the first item and initial state or [`nothing`](@ref) if empty        |\n"
"| `iterate(iter, state)`         | Â                       | Returns either a tuple of the next item and next state or `nothing` if no items remain  |\n"
"| **Important optional methods** | **Default definition** | **Brief description**                                                                 |\n"
"| `IteratorSize(IterType)`       | `HasLength()`          | One of `HasLength()`, `HasShape{N}()`, `IsInfinite()`, or `SizeUnknown()` as appropriate |\n"
"| `IteratorEltype(IterType)`     | `HasEltype()`          | Either `EltypeUnknown()` or `HasEltype()` as appropriate                              |\n"
"| `eltype(IterType)`             | `Any`                  | The type of the first entry of the tuple returned by `iterate()`                      |\n"
"| `length(iter)`                 | (*undefined*)          | The number of items, if known                                                         |\n"
"| `size(iter, [dim])`            | (*undefined*)          | The number of items in each dimension, if known                                       |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:27
#, no-wrap
msgid ""
"| Value returned by `IteratorSize(IterType)` | Required Methods                           |\n"
"|:------------------------------------------ |:------------------------------------------ |\n"
"| `HasLength()`                              | [`length(iter)`](@ref)                     |\n"
"| `HasShape{N}()`                            | `length(iter)`  and `size(iter, [dim])`    |\n"
"| `IsInfinite()`                             | (*none*)                                   |\n"
"| `SizeUnknown()`                            | (*none*)                                   |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:32
#, no-wrap
msgid ""
"| Value returned by `IteratorEltype(IterType)` | Required Methods   |\n"
"|:-------------------------------------------- |:------------------ |\n"
"| `HasEltype()`                                | `eltype(IterType)` |\n"
"| `EltypeUnknown()`                            | (*none*)           |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:39
msgid ""
"Sequential iteration is implemented by the [`iterate`](@ref) function. Instead of mutating objects as they are iterated over, Julia "
"iterators may keep track of the iteration state externally from the object. The return value from iterate is always either a tuple of a "
"value and a state, or `nothing` if no elements remain.  The state object will be passed back to the iterate function on the next iteration "
"and is generally considered an implementation detail private to the iterable object."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:42
msgid ""
"Any object that defines this function is iterable and can be used in the [many functions that rely upon iteration](@ref lib-collections-"
"iteration).  It can also be used directly in a [`for`](@ref) loop since the syntax:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:43 ext/julia/doc/src/base/collections.md:8
#, no-wrap
msgid ""
"for i in iter   # or  \"for i = iter\"\n"
"    # body\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:50 ext/julia/doc/src/base/collections.md:15
msgid "is translated into:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:51 ext/julia/doc/src/base/collections.md:16
#, no-wrap
msgid ""
"next = iterate(iter)\n"
"while next !== nothing\n"
"    (i, state) = next\n"
"    # body\n"
"    next = iterate(iter, state)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:61
msgid "A simple example is an iterable sequence of square numbers with a defined length:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/interfaces.md:62 ext/julia/doc/src/manual/interfaces.md:73 ext/julia/doc/src/manual/interfaces.md:90
#: ext/julia/doc/src/manual/interfaces.md:109 ext/julia/doc/src/manual/interfaces.md:118 ext/julia/doc/src/manual/interfaces.md:131
#: ext/julia/doc/src/manual/interfaces.md:150 ext/julia/doc/src/manual/interfaces.md:174 ext/julia/doc/src/manual/interfaces.md:187
#: ext/julia/doc/src/manual/interfaces.md:200
#, no-wrap
msgid "jldoctest squaretype"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:62
#, no-wrap
msgid ""
"julia> struct Squares\n"
"           count::Int\n"
"       end\n"
"\n"
"julia> Base.iterate(S::Squares, state=1) = state > S.count ? nothing : (state*state, state+1)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:72
msgid "With only [`iterate`](@ref) definition, the `Squares` type is already pretty powerful.  We can iterate over all the elements:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:73
#, no-wrap
msgid ""
"julia> for i in Squares(7)\n"
"           println(i)\n"
"       end\n"
"1\n"
"4\n"
"9\n"
"16\n"
"25\n"
"36\n"
"49\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:89
msgid ""
"We can use many of the builtin methods that work with iterables, like [`in`](@ref), or [`mean`](@ref) and [`std`](@ref) from the "
"`Statistics` standard library module:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:90
#, no-wrap
msgid ""
"julia> 25 in Squares(10)\n"
"true\n"
"\n"
"julia> using Statistics\n"
"\n"
"julia> mean(Squares(100))\n"
"3383.5\n"
"\n"
"julia> std(Squares(100))\n"
"3024.355854282583\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:108
msgid ""
"There are a few more methods we can extend to give Julia more information about this iterable collection.  We know that the elements in a "
"`Squares` sequence will always be `Int`. By extending the [`eltype`](@ref) method, we can give that information to Julia and help it make "
"more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend [`length`]"
"(@ref), too:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:109
#, no-wrap
msgid ""
"julia> Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type\n"
"\n"
"julia> Base.length(S::Squares) = S.count\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:117
msgid ""
"Now, when we ask Julia to [`collect`](@ref) all the elements into an array it can preallocate a `Vector{Int}` of the right size instead of "
"blindly [`push!`](@ref)ing each element into a `Vector{Any}`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:118
#, no-wrap
msgid ""
"julia> collect(Squares(4))\n"
"4-element Array{Int64,1}:\n"
"  1\n"
"  4\n"
"  9\n"
" 16\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:130
msgid ""
"While we can rely upon generic implementations, we can also extend specific methods where we know there is a simpler algorithm. For example, "
"there's a formula to compute the sum of squares, so we can override the generic iterative version with a more performant solution:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:131
#, no-wrap
msgid ""
"julia> Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)Ã·6)\n"
"\n"
"julia> sum(Squares(1803))\n"
"1955361914\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:142
msgid ""
"This is a very common pattern throughout Julia Base: a small set of required methods define an informal interface that enable many fancier "
"behaviors. In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be "
"used in their specific case."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:149
msgid ""
"It is also often useful to allow iteration over a collection in *reverse order* by iterating over [`Iterators.reverse(iterator)`](@ref).  To "
"actually support reverse-order iteration, however, an iterator type `T` needs to implement `iterate` for `Iterators.Reverse{T}`.  (Given `r::"
"Iterators.Reverse{T}`, the underling iterator of type `T` is `r.itr`.)  In our `Squares` example, we would implement `Iterators."
"Reverse{Squares}` methods:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:150
#, no-wrap
msgid ""
"julia> Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count) = state < 1 ? nothing : (state*state, state-1)\n"
"\n"
"julia> collect(Iterators.reverse(Squares(4)))\n"
"4-element Array{Int64,1}:\n"
" 16\n"
"  9\n"
"  4\n"
"  1\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/interfaces.md:161
#, no-wrap
msgid "Indexing"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:169
#, no-wrap
msgid ""
"| Methods to implement | Brief description                |\n"
"|:-------------------- |:-------------------------------- |\n"
"| `getindex(X, i)`     | `X[i]`, indexed element access   |\n"
"| `setindex!(X, v, i)` | `X[i] = v`, indexed assignment   |\n"
"| `firstindex(X)`      | The first index                  |\n"
"| `lastindex(X)`        | The last index, used in `X[end]` |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:173
msgid ""
"For the `Squares` iterable above, we can easily compute the `i`th element of the sequence by squaring it.  We can expose this as an indexing "
"expression `S[i]`. To opt into this behavior, `Squares` simply needs to define [`getindex`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:174
#, no-wrap
msgid ""
"julia> function Base.getindex(S::Squares, i::Int)\n"
"           1 <= i <= S.count || throw(BoundsError(S, i))\n"
"           return i*i\n"
"       end\n"
"\n"
"julia> Squares(100)[23]\n"
"529\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:186
msgid ""
"Additionally, to support the syntax `S[end]`, we must define [`lastindex`](@ref) to specify the last valid index. It is recommended to also "
"define [`firstindex`](@ref) to specify the first valid index:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:187
#, no-wrap
msgid ""
"julia> Base.firstindex(S::Squares) = 1\n"
"\n"
"julia> Base.lastindex(S::Squares) = length(S)\n"
"\n"
"julia> Squares(23)[end]\n"
"529\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:199
msgid ""
"Note, though, that the above *only* defines [`getindex`](@ref) with one integer index. Indexing with anything other than an `Int` will throw "
"a [`MethodError`](@ref) saying that there was no matching method.  In order to support indexing with ranges or vectors of `Int`s, separate "
"methods must be written:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:200
#, no-wrap
msgid ""
"julia> Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]\n"
"\n"
"julia> Base.getindex(S::Squares, I) = [S[i] for i in I]\n"
"\n"
"julia> Squares(10)[[3,4.,5]]\n"
"3-element Array{Int64,1}:\n"
"  9\n"
" 16\n"
" 25\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:216
msgid ""
"While this is starting to support more of the [indexing operations supported by some of the builtin types](@ref man-array-indexing), there's "
"still quite a number of behaviors missing. This `Squares` sequence is starting to look more and more like a vector as we've added behaviors "
"to it. Instead of defining all these behaviors ourselves, we can officially define it as a subtype of an [`AbstractArray`](@ref)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/interfaces.md:217
#, no-wrap
msgid "[Abstract Arrays](@id man-interface-array)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:240
#, no-wrap
msgid ""
"| Methods to implement                            | Â                                       | Brief description                                                                     |\n"
"|:----------------------------------------------- |:-------------------------------------- |:------------------------------------------------------------------------------------- |\n"
"| `size(A)`                                       | Â                                       | Returns a tuple containing the dimensions of `A`                                      |\n"
"| `getindex(A, i::Int)`                           | Â                                       | (if `IndexLinear`) Linear scalar indexing                                             |\n"
"| `getindex(A, I::Vararg{Int, N})`                | Â                                       | (if `IndexCartesian`, where `N = ndims(A)`) N-dimensional scalar indexing             |\n"
"| `setindex!(A, v, i::Int)`                       | Â                                       | (if `IndexLinear`) Scalar indexed assignment                                          |\n"
"| `setindex!(A, v, I::Vararg{Int, N})`            | Â                                       | (if `IndexCartesian`, where `N = ndims(A)`) N-dimensional scalar indexed assignment   |\n"
"| **Optional methods**                            | **Default definition**                 | **Brief description**                                                                 |\n"
"| `IndexStyle(::Type)`                            | `IndexCartesian()`                     | Returns either `IndexLinear()` or `IndexCartesian()`. See the description below.      |\n"
"| `getindex(A, I...)`                             | defined in terms of scalar `getindex`  | [Multidimensional and nonscalar indexing](@ref man-array-indexing)                    |\n"
"| `setindex!(A, I...)`                            | defined in terms of scalar `setindex!` | [Multidimensional and nonscalar indexed assignment](@ref man-array-indexing)          |\n"
"| `iterate`                                       | defined in terms of scalar `getindex`  | Iteration                                                                             |\n"
"| `length(A)`                                     | `prod(size(A))`                        | Number of elements                                                                    |\n"
"| `similar(A)`                                    | `similar(A, eltype(A), size(A))`       | Return a mutable array with the same shape and element type                           |\n"
"| `similar(A, ::Type{S})`                         | `similar(A, S, size(A))`               | Return a mutable array with the same shape and the specified element type             |\n"
"| `similar(A, dims::Dims)`                        | `similar(A, eltype(A), dims)`          | Return a mutable array with the same element type and size *dims*                     |\n"
"| `similar(A, ::Type{S}, dims::Dims)`             | `Array{S}(undef, dims)`                | Return a mutable array with the specified element type and size                       |\n"
"| **Non-traditional indices**                     | **Default definition**                 | **Brief description**                                                                 |\n"
"| `axes(A)`                                    | `map(OneTo, size(A))`                  | Return the `AbstractUnitRange` of valid indices                                       |\n"
"| `similar(A, ::Type{S}, inds)`              | `similar(A, S, Base.to_shape(inds))`   | Return a mutable array with the specified indices `inds` (see below)                  |\n"
"| `similar(T::Union{Type,Function}, inds)`   | `T(Base.to_shape(inds))`               | Return an array similar to `T` with the specified indices `inds` (see below)          |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:244
msgid ""
"If a type is defined as a subtype of `AbstractArray`, it inherits a very large set of rich behaviors including iteration and "
"multidimensional indexing built on top of single-element access.  See the [arrays manual page](@ref man-multi-dim-arrays) and the [Julia "
"Base section](@ref lib-arrays) for more supported methods."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:253
#, no-wrap
msgid ""
"A key part in defining an `AbstractArray` subtype is [`IndexStyle`](@ref). Since indexing is\n"
"such an important part of an array and often occurs in hot loops, it's important to make both\n"
"indexing and indexed assignment as efficient as possible.  Array data structures are typically\n"
"defined in one of two ways: either it most efficiently accesses its elements using just one index\n"
"(linear indexing) or it intrinsically accesses the elements with indices specified for every dimension.\n"
" These two modalities are identified by Julia as `IndexLinear()` and `IndexCartesian()`.\n"
" Converting a linear index to multiple indexing subscripts is typically very expensive, so this\n"
"provides a traits-based mechanism to enable efficient generic code for all array types.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:262
msgid ""
"This distinction determines which scalar indexing methods the type must define. `IndexLinear()` arrays are simple: just define `getindex(A::"
"ArrayType, i::Int)`.  When the array is subsequently indexed with a multidimensional set of indices, the fallback `getindex(A::"
"AbstractArray, I...)()` efficiently converts the indices into one linear index and then calls the above method. `IndexCartesian()` arrays, "
"on the other hand, require methods to be defined for each supported dimensionality with `ndims(A)` `Int` indices. For example, "
"[`SparseMatrixCSC`](@ref) from the `SparseArrays` standard library module, only supports two dimensions, so it just defines `getindex(A::"
"SparseMatrixCSC, i::Int, j::Int)`. The same holds for [`setindex!`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:265
msgid "Returning to the sequence of squares from above, we could instead define it as a subtype of an `AbstractArray{Int, 1}`:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/interfaces.md:266 ext/julia/doc/src/manual/interfaces.md:283 ext/julia/doc/src/manual/interfaces.md:314
#: ext/julia/doc/src/manual/interfaces.md:337 ext/julia/doc/src/manual/interfaces.md:363 ext/julia/doc/src/manual/interfaces.md:376
#: ext/julia/doc/src/manual/interfaces.md:387
#, no-wrap
msgid "jldoctest squarevectype"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:266
#, no-wrap
msgid ""
"julia> struct SquaresVector <: AbstractArray{Int, 1}\n"
"           count::Int\n"
"       end\n"
"\n"
"julia> Base.size(S::SquaresVector) = (S.count,)\n"
"\n"
"julia> Base.IndexStyle(::Type{<:SquaresVector}) = IndexLinear()\n"
"\n"
"julia> Base.getindex(S::SquaresVector, i::Int) = i*i\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:282
msgid ""
"Note that it's very important to specify the two parameters of the `AbstractArray`; the first defines the [`eltype`](@ref), and the second "
"defines the [`ndims`](@ref). That supertype and those three methods are all it takes for `SquaresVector` to be an iterable, indexable, and "
"completely functional array:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:283
#, no-wrap
msgid ""
"julia> s = SquaresVector(4)\n"
"4-element SquaresVector:\n"
"  1\n"
"  4\n"
"  9\n"
" 16\n"
"\n"
"julia> s[s .> 8]\n"
"2-element Array{Int64,1}:\n"
"  9\n"
" 16\n"
"\n"
"julia> s + s\n"
"4-element Array{Int64,1}:\n"
"  2\n"
"  8\n"
" 18\n"
" 32\n"
"\n"
"julia> sin.(s)\n"
"4-element Array{Float64,1}:\n"
"  0.8414709848078965\n"
" -0.7568024953079282\n"
"  0.4121184852417566\n"
" -0.2879033166650653\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:313
msgid "As a more complicated example, let's define our own toy N-dimensional sparse-like array type built on top of [`Dict`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:314
#, no-wrap
msgid ""
"julia> struct SparseArray{T,N} <: AbstractArray{T,N}\n"
"           data::Dict{NTuple{N,Int}, T}\n"
"           dims::NTuple{N,Int}\n"
"       end\n"
"\n"
"julia> SparseArray(::Type{T}, dims::Int...) where {T} = SparseArray(T, dims);\n"
"\n"
"julia> SparseArray(::Type{T}, dims::NTuple{N,Int}) where {T,N} = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);\n"
"\n"
"julia> Base.size(A::SparseArray) = A.dims\n"
"\n"
"julia> Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)\n"
"\n"
"julia> Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))\n"
"\n"
"julia> Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:336
msgid ""
"Notice that this is an `IndexCartesian` array, so we must manually define [`getindex`](@ref) and [`setindex!`](@ref)  at the dimensionality "
"of the array. Unlike the `SquaresVector`, we are able to define [`setindex!`](@ref), and so we can mutate the array:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:337
#, no-wrap
msgid ""
"julia> A = SparseArray(Float64, 3, 3)\n"
"3Ã3 SparseArray{Float64,2}:\n"
" 0.0  0.0  0.0\n"
" 0.0  0.0  0.0\n"
" 0.0  0.0  0.0\n"
"\n"
"julia> fill!(A, 2)\n"
"3Ã3 SparseArray{Float64,2}:\n"
" 2.0  2.0  2.0\n"
" 2.0  2.0  2.0\n"
" 2.0  2.0  2.0\n"
"\n"
"julia> A[:] = 1:length(A); A\n"
"3Ã3 SparseArray{Float64,2}:\n"
" 1.0  4.0  7.0\n"
" 2.0  5.0  8.0\n"
" 3.0  6.0  9.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:362
msgid ""
"The result of indexing an `AbstractArray` can itself be an array (for instance when indexing by an `AbstractRange`). The `AbstractArray` "
"fallback methods use [`similar`](@ref) to allocate an `Array` of the appropriate size and element type, which is filled in using the basic "
"indexing method described above. However, when implementing an array wrapper you often want the result to be wrapped as well:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:363
#, no-wrap
msgid ""
"julia> A[1:2,:]\n"
"2Ã3 SparseArray{Float64,2}:\n"
" 1.0  4.0  7.0\n"
" 2.0  5.0  8.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:375
msgid ""
"In this example it is accomplished by defining `Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)` to create the appropriate wrapped "
"array. (Note that while `similar` supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this "
"to work it's important that `SparseArray` is mutable (supports `setindex!`). Defining `similar`, `getindex` and `setindex!` for "
"`SparseArray` also makes it possible to [`copy`](@ref) the array:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:376
#, no-wrap
msgid ""
"julia> copy(A)\n"
"3Ã3 SparseArray{Float64,2}:\n"
" 1.0  4.0  7.0\n"
" 2.0  5.0  8.0\n"
" 3.0  6.0  9.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:386
msgid ""
"In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods "
"defined in Julia Base for `AbstractArrays`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:387
#, no-wrap
msgid ""
"julia> A[SquaresVector(3)]\n"
"3-element SparseArray{Float64,1}:\n"
" 1.0\n"
" 4.0\n"
" 9.0\n"
"\n"
"julia> sum(A)\n"
"45.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:403
msgid ""
"If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize "
"[`axes`](@ref). You should also specialize [`similar`](@ref)  so that the `dims` argument (ordinarily a `Dims` size-tuple) can accept "
"`AbstractUnitRange` objects, perhaps range-types `Ind` of your own design. For more information, see [Arrays with custom indices](@ref man-"
"custom-indices)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/interfaces.md:404
#, no-wrap
msgid "[Strided Arrays](@id man-interface-strided-arrays)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:412
#, no-wrap
msgid ""
"| Methods to implement                            | Â                                       | Brief description                                                                     |\n"
"|:----------------------------------------------- |:-------------------------------------- |:------------------------------------------------------------------------------------- |\n"
"| `strides(A)`                             | Â                                       | Return the distance in memory (in number of elements) between adjacent elements in each dimension as a tuple. If `A` is an `AbstractArray{T,0}`, this should return an empty tuple.    |\n"
"| `Base.unsafe_convert(::Type{Ptr{T}}, A)`        | Â                                       | Return the native address of an array.                                     |\n"
"| **Optional methods**                            | **Default definition**                 | **Brief description**                                                                 |\n"
"| `stride(A, i::Int)`                             | Â    `strides(A)[i]`                                   | Return the distance in memory (in number of elements) between adjacent elements in dimension k.    |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:417
msgid ""
"A strided array is a subtype of `AbstractArray` whose entries are stored in memory with fixed strides.  Provided the element type of the "
"array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines for more efficient linear algebra routines.  A typical "
"example of a user-defined strided array is one that wraps a standard `Array` with additional structure."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:420
msgid ""
"Warning: do not implement these methods if the underlying storage is not actually strided, as it may lead to incorrect results or "
"segmentation faults."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:422
msgid "Here are some examples to demonstrate which type of arrays are strided and which are not:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:422
#, no-wrap
msgid ""
"1:5   # not strided (there is no storage associated with this array.)\n"
"Vector(1:5)  # is strided with strides (1,)\n"
"A = [1 5; 2 6; 3 7; 4 8]  # is strided with strides (1,4)\n"
"V = view(A, 1:2, :)   # is strided with strides (1,4)\n"
"V = view(A, 1:2:3, 1:2)   # is strided with strides (2,4)\n"
"V = view(A, [1,2,4], :)   # is not strided, as the spacing between rows is not fixed.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/manual/interfaces.md:435
#, no-wrap
msgid "[Customizing broadcasting](@id man-interfaces-broadcasting)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:451
msgid ""
"| Methods to implement | Brief description | |:-------------------- |:----------------- | | `Base.BroadcastStyle(::Type{SrcType}) = "
"SrcStyle()` | Broadcasting behavior of `SrcType` | | `Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})` | Allocation of output "
"container | | **Optional methods** | | | | `Base.BroadcastStyle(::Style1, ::Style2) = Style12()` | Precedence rules for mixing styles | | "
"`Base.axes(x)` | Declaration of the indices of `x`, as per [`axes(x)`](@ref). | | `Base.broadcastable(x)` | Convert `x` to an object that "
"has `axes` and supports indexing | | **Bypassing default machinery** | | | `Base.copy(bc::Broadcasted{DestStyle})` | Custom implementation "
"of `broadcast` | | `Base.copyto!(dest, bc::Broadcasted{DestStyle})` | Custom implementation of `broadcast!`, specializing on `DestStyle` | | "
"`Base.copyto!(dest::DestType, bc::Broadcasted{Nothing})` | Custom implementation of `broadcast!`, specializing on `DestType` | | `Base."
"Broadcast.broadcasted(f, args...)` | Override the default lazy behavior within a fused expression | | `Base.Broadcast.instantiate(bc::"
"Broadcasted{DestStyle})` | Override the computation of the lazy broadcast's axes |"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:456
msgid ""
"[Broadcasting](@ref) is triggered by an explicit call to `broadcast` or `broadcast!`, or implicitly by \"dot\" operations like `A .+ b` or "
"`f.(x, y)`. Any object that has [`axes`](@ref) and supports indexing can participate as an argument in broadcasting, and by default the "
"result is stored in an `Array`. This basic framework is extensible in three major ways:"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/interfaces.md:460
msgid "Ensuring that all arguments support broadcast"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/interfaces.md:460
msgid "Selecting an appropriate output array for the given set of arguments"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/interfaces.md:460
msgid "Selecting an efficient implementation for the given set of arguments"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:473
msgid ""
"Not all types support `axes` and indexing, but many are convenient to allow in broadcast.  The [`Base.broadcastable`](@ref) function is "
"called on each argument to broadcast, allowing it to return something different that supports `axes` and indexing. By default, this is the "
"identity function for all `AbstractArray`s and `Number`s â they already support `axes` and indexing. For a handful of other types (including "
"but not limited to types themselves, functions, special singletons like [`missing`](@ref) and [`nothing`](@ref), and dates), `Base."
"broadcastable` returns the argument wrapped in a `Ref` to act as a 0-dimensional \"scalar\" for the purposes of broadcasting. Custom types "
"can similarly specialize `Base.broadcastable` to define their shape, but they should follow the convention that `collect(Base."
"broadcastable(x)) == collect(x)`. A notable exception is `AbstractString`; strings are special-cased to behave as scalars for the purposes "
"of broadcast even though they are iterable collections of their characters (see [Strings](@ref) for more)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:480
msgid ""
"The next two steps (selecting the output array and implementation) are dependent upon determining a single answer for a given set of "
"arguments. Broadcast must take all the varied types of its arguments and collapse them down to just one output array and one implementation. "
"Broadcast calls this single answer a \"style.\" Every broadcastable object each has its own preferred style, and a promotion-like system is "
"used to combine these styles into a single answer â the \"destination style\"."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/interfaces.md:481
#, no-wrap
msgid "Broadcast Styles"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:487
msgid ""
"`Base.BroadcastStyle` is the abstract type from which all broadcast styles are derived. When used as a function it has two possible forms, "
"unary (single-argument) and binary. The unary variant states that you intend to implement specific broadcasting behavior and/or output type, "
"and do not wish to rely on the default fallback [`Broadcast.DefaultArrayStyle`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:489
msgid "To override these defaults, you can define a custom `BroadcastStyle` for your object:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:490
#, no-wrap
msgid ""
"struct MyStyle <: Broadcast.BroadcastStyle end\n"
"Base.BroadcastStyle(::Type{<:MyType}) = MyStyle()\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:497
msgid ""
"In some cases it might be convenient not to have to define `MyStyle`, in which case you can leverage one of the general broadcast wrappers:"
msgstr ""

#. type: Bullet: '  - '
#: ext/julia/doc/src/manual/interfaces.md:503
msgid "`Base.BroadcastStyle(::Type{<:MyType}) = Broadcast.Style{MyType}()` can be used for arbitrary types."
msgstr ""

#. type: Bullet: '  - '
#: ext/julia/doc/src/manual/interfaces.md:503
msgid "`Base.BroadcastStyle(::Type{<:MyType}) = Broadcast.ArrayStyle{MyType}()` is preferred if `MyType` is an `AbstractArray`."
msgstr ""

#. type: Bullet: '  - '
#: ext/julia/doc/src/manual/interfaces.md:503
msgid "For `AbstractArrays` that only support a certain dimensionality, create a subtype of `Broadcast.AbstractArrayStyle{N}` (see below)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:507
msgid ""
"When your broadcast operation involves several arguments, individual argument styles get combined to determine a single `DestStyle` that "
"controls the type of the output container.  For more details, see [below](@ref writing-binary-broadcasting-rules)."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/interfaces.md:508
#, no-wrap
msgid "Selecting an appropriate output array"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:513
msgid ""
"The broadcast style is computed for every broadcasting operation to allow for dispatch and specialization. The actual allocation of the "
"result array is handled by `similar`, using the Broadcasted object as its first argument."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:514
#, no-wrap
msgid "Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:519
msgid "The fallback definition is"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:520
#, no-wrap
msgid ""
"similar(bc::Broadcasted{DefaultArrayStyle{N}}, ::Type{ElType}) where {N,ElType} =\n"
"    similar(Array{ElType}, axes(bc))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:530
msgid ""
"However, if needed you can specialize on any or all of these arguments. The final argument `bc` is a lazy representation of a (potentially "
"fused) broadcast operation, a `Broadcasted` object.  For these purposes, the most important fields of the wrapper are `f` and `args`, "
"describing the function and argument list, respectively.  Note that the argument list can â and often does â include other nested "
"`Broadcasted` wrappers."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:533
msgid "For a complete example, let's say you have created a type, `ArrayAndChar`, that stores an array and a single character:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/interfaces.md:534 ext/julia/doc/src/manual/interfaces.md:549 ext/julia/doc/src/manual/interfaces.md:556
#, no-wrap
msgid "jldoctest ArrayAndChar; output = false"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:534
#, no-wrap
msgid ""
"struct ArrayAndChar{T,N} <: AbstractArray{T,N}\n"
"    data::Array{T,N}\n"
"    char::Char\n"
"end\n"
"Base.size(A::ArrayAndChar) = size(A.data)\n"
"Base.getindex(A::ArrayAndChar{T,N}, inds::Vararg{Int,N}) where {T,N} = A.data[inds...]\n"
"Base.setindex!(A::ArrayAndChar{T,N}, val, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] = val\n"
"Base.showarg(io::IO, A::ArrayAndChar, toplevel) = print(io, typeof(A), \" with char '\", A.char, \"'\")\n"
"# output\n"
"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:548
msgid "You might want broadcasting to preserve the `char` \"metadata.\" First we define"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:549
#, no-wrap
msgid ""
"Base.BroadcastStyle(::Type{<:ArrayAndChar}) = Broadcast.ArrayStyle{ArrayAndChar}()\n"
"# output\n"
"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:556
msgid "This means we must also define a corresponding `similar` method:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:556
#, no-wrap
msgid ""
"function Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{ArrayAndChar}}, ::Type{ElType}) where ElType\n"
"    # Scan the inputs for the ArrayAndChar:\n"
"    A = find_aac(bc)\n"
"    # Use the char field of A to create the output\n"
"    ArrayAndChar(similar(Array{ElType}, axes(bc)), A.char)\n"
"end\n"
"\n"
"\"`A = find_aac(As)` returns the first ArrayAndChar among the arguments.\"\n"
"find_aac(bc::Base.Broadcast.Broadcasted) = find_aac(bc.args)\n"
"find_aac(args::Tuple) = find_aac(find_aac(args[1]), Base.tail(args))\n"
"find_aac(x) = x\n"
"find_aac(a::ArrayAndChar, rest) = a\n"
"find_aac(::Any, rest) = find_aac(rest)\n"
"# output\n"
"find_aac (generic function with 5 methods)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:575
msgid "From these definitions, one obtains the following behavior:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/manual/interfaces.md:575
#, no-wrap
msgid "jldoctest ArrayAndChar"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:575
#, no-wrap
msgid ""
"julia> a = ArrayAndChar([1 2; 3 4], 'x')\n"
"2Ã2 ArrayAndChar{Int64,2} with char 'x':\n"
" 1  2\n"
" 3  4\n"
"\n"
"julia> a .+ 1\n"
"2Ã2 ArrayAndChar{Int64,2} with char 'x':\n"
" 2  3\n"
" 4  5\n"
"\n"
"julia> a .+ [5,10]\n"
"2Ã2 ArrayAndChar{Int64,2} with char 'x':\n"
"  6   7\n"
" 13  14\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/interfaces.md:592
#, no-wrap
msgid "[Extending broadcast with custom implementations](@id extending-in-place-broadcast)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:610
msgid ""
"In general, a broadcast operation is represented by a lazy `Broadcasted` container that holds onto the function to be applied alongside its "
"arguments. Those arguments may themselves be more nested `Broadcasted` containers, forming a large expression tree to be evaluated. A nested "
"tree of `Broadcasted` containers is directly constructed by the implicit dot syntax; `5 .+ 2.*x` is transiently represented by "
"`Broadcasted(+, 5, Broadcasted(*, 2, x))`, for example. This is invisible to users as it is immediately realized through a call to `copy`, "
"but it is this container that provides the basis for broadcast's extensibility for authors of custom types. The built-in broadcast machinery "
"will then determine the result type and size based upon the arguments, allocate it, and then finally copy the realization of the "
"`Broadcasted` object into it with a default `copyto!(::AbstractArray, ::Broadcasted)` method. The built-in fallback `broadcast` and "
"`broadcast!` methods similarly construct a transient `Broadcasted` representation of the operation so they can follow the same codepath. "
"This allows custom array implementations to provide their own `copyto!` specialization to customize and optimize broadcasting. This is again "
"determined by the computed broadcast style. This is such an important part of the operation that it is stored as the first type parameter of "
"the `Broadcasted` type, allowing for dispatch and specialization."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:621
msgid ""
"For some types, the machinery to \"fuse\" operations across nested levels of broadcasting is not available or could be done more efficiently "
"incrementally. In such cases, you may need or want to evaluate `x .* (x .+ 1)` as if it had been written `broadcast(*, x, broadcast(+, x, "
"1))`, where the inner operation is evaluated before tackling the outer operation. This sort of eager operation is directly supported by a "
"bit of indirection; instead of directly constructing `Broadcasted` objects, Julia lowers the fused expression `x .* (x .+ 1)` to `Broadcast."
"broadcasted(*, x, Broadcast.broadcasted(+, x, 1))`. Now, by default, `broadcasted` just calls the `Broadcasted` constructor to create the "
"lazy representation of the fused expression tree, but you can choose to override it for a particular combination of function and arguments."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:628
msgid ""
"As an example, the builtin `AbstractRange` objects use this machinery to optimize pieces of broadcasted expressions that can be eagerly "
"evaluated purely in terms of the start, step, and length (or stop) instead of computing every single element. Just like all the other "
"machinery, `broadcasted` also computes and exposes the combined broadcast style of its arguments, so instead of specializing on "
"`broadcasted(f, args...)`, you can specialize on `broadcasted(::DestStyle, f, args...)` for any combination of style, function, and "
"arguments."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:630
msgid "For example, the following definition supports the negation of ranges:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:631
#, no-wrap
msgid "broadcasted(::DefaultArrayStyle{1}, ::typeof(-), r::OrdinalRange) = range(-first(r), step=-step(r), length=length(r))\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/interfaces.md:635
#, no-wrap
msgid "[Extending in-place broadcasting](@id extending-in-place-broadcast)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:640
msgid ""
"In-place broadcasting can be supported by defining the appropriate `copyto!(dest, bc::Broadcasted)` method. Because you might want to "
"specialize either on `dest` or the specific subtype of `bc`, to avoid ambiguities between packages we recommend the following convention."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:642
msgid "If you wish to specialize on a particular style `DestStyle`, define a method for"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:642
#, no-wrap
msgid "copyto!(dest, bc::Broadcasted{DestStyle})\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:646
msgid "Optionally, with this form you can also specialize on the type of `dest`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:649
msgid ""
"If instead you want to specialize on the destination type `DestType` without specializing on `DestStyle`, then you should define a method "
"with the following signature:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:650
#, no-wrap
msgid "copyto!(dest::DestType, bc::Broadcasted{Nothing})\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:657
msgid ""
"This leverages a fallback implementation of `copyto!` that converts the wrapper into a `Broadcasted{Nothing}`. Consequently, specializing on "
"`DestType` has lower precedence than methods that specialize on `DestStyle`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:660
msgid "Similarly, you can completely override out-of-place broadcasting with a `copy(::Broadcasted)` method."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/manual/interfaces.md:661
#, no-wrap
msgid "Working with `Broadcasted` objects"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:666
msgid ""
"In order to implement such a `copy` or `copyto!`, method, of course, you must work with the `Broadcasted` wrapper to compute each element. "
"There are two main ways of doing so:"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/interfaces.md:672
msgid ""
"`Broadcast.flatten` recomputes the potentially nested operation into a single function and flat list of arguments. You are responsible for "
"implementing the broadcasting shape rules yourself, but this may be helpful in limited situations."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/manual/interfaces.md:672
msgid ""
"Iterating over the `CartesianIndices` of the `axes(::Broadcasted)` and using indexing with the resulting `CartesianIndex` object to compute "
"the result."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/manual/interfaces.md:673
#, no-wrap
msgid "[Writing binary broadcasting rules](@id writing-binary-broadcasting-rules)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:676
msgid "The precedence rules are defined by binary `BroadcastStyle` calls:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:677
#, no-wrap
msgid "Base.BroadcastStyle(::Style1, ::Style2) = Style12()\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:683
msgid "where `Style12` is the `BroadcastStyle` you want to choose for outputs involving arguments of `Style1` and `Style2`. For example,"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:684
#, no-wrap
msgid "Base.BroadcastStyle(::Broadcast.Style{Tuple}, ::Broadcast.AbstractArrayStyle{0}) = Broadcast.Style{Tuple}()\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:691
msgid ""
"indicates that `Tuple` \"wins\" over zero-dimensional arrays (the output container will be a tuple).  It is worth noting that you do not "
"need to (and should not) define both argument orders of this call; defining one is sufficient no matter what order the user supplies the "
"arguments in."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:695
msgid ""
"For `AbstractArray` types, defining a `BroadcastStyle` supersedes the fallback choice, [`Broadcast.DefaultArrayStyle`](@ref). "
"`DefaultArrayStyle` and the abstract supertype, `AbstractArrayStyle`, store the dimensionality as a type parameter to support specialized "
"array types that have fixed dimensionality requirements."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:698
msgid "`DefaultArrayStyle` \"loses\" to any other `AbstractArrayStyle` that has been defined because of the following methods:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:699
#, no-wrap
msgid ""
"BroadcastStyle(a::AbstractArrayStyle{Any}, ::DefaultArrayStyle) = a\n"
"BroadcastStyle(a::AbstractArrayStyle{N}, ::DefaultArrayStyle{N}) where N = a\n"
"BroadcastStyle(a::AbstractArrayStyle{M}, ::DefaultArrayStyle{N}) where {M,N} =\n"
"    typeof(a)(_max(Val(M),Val(N)))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:709
msgid ""
"You do not need to write binary `BroadcastStyle` rules unless you want to establish precedence for two or more non-`DefaultArrayStyle` types."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:712
msgid ""
"If your array type does have fixed dimensionality requirements, then you should subtype `AbstractArrayStyle`. For example, the sparse array "
"code has the following definitions:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:713
#, no-wrap
msgid ""
"struct SparseVecStyle <: Broadcast.AbstractArrayStyle{1} end\n"
"struct SparseMatStyle <: Broadcast.AbstractArrayStyle{2} end\n"
"Base.BroadcastStyle(::Type{<:SparseVector}) = SparseVecStyle()\n"
"Base.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatStyle()\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:723
msgid ""
"Whenever you subtype `AbstractArrayStyle`, you also need to define rules for combining dimensionalities, by creating a constructor for your "
"style that takes a `Val(N)` argument.  For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:724
#, no-wrap
msgid ""
"SparseVecStyle(::Val{0}) = SparseVecStyle()\n"
"SparseVecStyle(::Val{1}) = SparseVecStyle()\n"
"SparseVecStyle(::Val{2}) = SparseMatStyle()\n"
"SparseVecStyle(::Val{N}) where N = Broadcast.DefaultArrayStyle{N}()\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/manual/interfaces.md:735
msgid ""
"These rules indicate that the combination of a `SparseVecStyle` with 0- or 1-dimensional arrays yields another `SparseVecStyle`, that its "
"combination with a 2-dimensional array yields a `SparseMatStyle`, and anything of higher dimensionality falls back to the dense arbitrary-"
"dimensional framework.  These rules allow broadcasting to keep the sparse representation for operations that result in one or two "
"dimensional outputs, but produce an `Array` for any other dimensionality."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/iterators.md:1
#, no-wrap
msgid "Iteration utilities"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/iterators.md:3
#, no-wrap
msgid ""
"Base.Iterators.Stateful\n"
"Base.Iterators.zip\n"
"Base.Iterators.enumerate\n"
"Base.Iterators.rest\n"
"Base.Iterators.countfrom\n"
"Base.Iterators.take\n"
"Base.Iterators.drop\n"
"Base.Iterators.cycle\n"
"Base.Iterators.repeated\n"
"Base.Iterators.product\n"
"Base.Iterators.flatten\n"
"Base.Iterators.partition\n"
"Base.Iterators.filter\n"
"Base.Iterators.reverse\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/punctuation.md:1
#, no-wrap
msgid "Punctuation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/punctuation.md:4
msgid "Extended documentation for mathematical symbols & functions is [here](@ref math-ops)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/punctuation.md:47
#, no-wrap
msgid ""
"| symbol      | meaning                                                                                                                                         |\n"
"|:----------- |:----------------------------------------------------------------------------------------------------------------------------------------------- |\n"
"| `@m`        | invoke macro `m`; followed by space-separated expressions                                   |\n"
"| `!`         | prefix \"not\" (logical negation) operator                                                    |\n"
"| `a!( )`     | at the end of a function name, `!` is used as a convention to indicate that a function modifies its argument(s) |\n"
"| `#`         | begin single line comment                                                                   |\n"
"| `#=`        | begin multi-line comment (these are nestable)                                               |\n"
"| `=#`        | end multi-line comment                                                                      |\n"
"| `$`         | string and expression interpolation                                                         |\n"
"| `%`         | remainder operator                                                                          |\n"
"| `^`         | exponent operator                                                                           |\n"
"| `&`         | bitwise and                                                                                 |\n"
"| `&&`        | short-circuiting boolean and                                                                |\n"
"| `\\|`        | bitwise or                                                                                  |\n"
"| `\\|\\|`      | short-circuiting boolean or                                                                 |\n"
"| `â»`         | bitwise xor operator                                                                        |\n"
"| `*`         | multiply, or matrix multiply                                                                |\n"
"| `()`        | the empty tuple                                                                             |\n"
"| `~`         | bitwise not operator                                                                        |\n"
"| `\\`         | backslash operator                                                                          |\n"
"| `'`         | complex transpose operator Aá´´                                                               |\n"
"| `a[]`       | array indexing (calling [`getindex`](@ref) or [`setindex!`](@ref))                          |\n"
"| `[,]`       | vector literal constructor (calling [`vect`](@ref Base.vect))                               |\n"
"| `[;]`       | vertical concatenation (calling [`vcat`](@ref) or [`hvcat`](@ref))                          |\n"
"| `[ Â   ]`    | with space-separated expressions, horizontal concatenation (calling [`hcat`](@ref) or [`hvcat`](@ref)) |\n"
"| `T{ }`      | parametric type instantiation                                                               |\n"
"| `;`         | statement separator                                                                         |\n"
"| `,`         | separate function arguments or tuple components                                             |\n"
"| `?`         | 3-argument conditional operator (used like: `conditional ? if_true : if_false`)             |\n"
"| `\"\"`        | delimit string literals                                                                     |\n"
"| `''`        | delimit character literals                                                                  |\n"
"| ``` ` ` ``` | delimit external process (command) specifications                                           |\n"
"| `...`       | splice arguments into a function call or declare a varargs function                         |\n"
"| `.`         | access named fields in objects/modules (calling [`getproperty`](@ref Base.getproperty) or [`setproperty!`](@ref Base.setproperty!)), also prefixes elementwise function calls (calling [`broadcast`](@ref)) |\n"
"| `a:b`       | range a, a+1, a+2, ..., b                                                                   |\n"
"| `a:s:b`     | range a, a+s, a+2s, ..., b                                                                  |\n"
"| `:`         | index an entire dimension (firstindex:lastindex), see [`Colon`](@ref))                      |\n"
"| `::`        | type annotation or [`typeassert`](@ref), depending on context                               |\n"
"| `:( )`      | quoted expression                                                                           |\n"
"| `:a`        | symbol a                                                                                    |\n"
"| `<:`        | [`subtype operator`](@ref <:)                                                               |\n"
"| `>:`        | [`supertype operator`](@ref >:) (reverse of subtype operator)                               |\n"
"| `===`       | [`egal comparison operator`](@ref ===)                                                      |\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/numbers.md:1
#, no-wrap
msgid "[Numbers](@id lib-numbers)"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/numbers.md:3
#, no-wrap
msgid "Standard Numeric Types"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/base/numbers.md:5
#, no-wrap
msgid "Abstract number types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/numbers.md:7
#, no-wrap
msgid ""
"Core.Number\n"
"Core.Real\n"
"Core.AbstractFloat\n"
"Core.Integer\n"
"Core.Signed\n"
"Core.Unsigned\n"
"Base.AbstractIrrational\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/base/numbers.md:17
#, no-wrap
msgid "Concrete number types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/numbers.md:19
#, no-wrap
msgid ""
"Core.Float16\n"
"Core.Float32\n"
"Core.Float64\n"
"Base.BigFloat\n"
"Core.Bool\n"
"Core.Int8\n"
"Core.UInt8\n"
"Core.Int16\n"
"Core.UInt16\n"
"Core.Int32\n"
"Core.UInt32\n"
"Core.Int64\n"
"Core.UInt64\n"
"Core.Int128\n"
"Core.UInt128\n"
"Base.BigInt\n"
"Base.Complex\n"
"Base.Rational\n"
"Base.Irrational\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/numbers.md:41
#, no-wrap
msgid "Data Formats"
msgstr "ãã¼ã¿å½¢å¼"

#. type: Plain text
#: ext/julia/doc/src/base/numbers.md:43
#, no-wrap
msgid ""
"Base.digits\n"
"Base.digits!\n"
"Base.bitstring\n"
"Base.parse\n"
"Base.tryparse\n"
"Base.big\n"
"Base.signed\n"
"Base.unsigned\n"
"Base.float(::Any)\n"
"Base.Math.significand\n"
"Base.Math.exponent\n"
"Base.complex(::Complex)\n"
"Base.bswap\n"
"Base.hex2bytes\n"
"Base.hex2bytes!\n"
"Base.bytes2hex\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/numbers.md:62
#, no-wrap
msgid "General Number Functions and Constants"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/numbers.md:64
#, no-wrap
msgid ""
"Base.one\n"
"Base.oneunit\n"
"Base.zero\n"
"Base.im\n"
"Base.MathConstants.pi\n"
"Base.MathConstants.â¯\n"
"Base.MathConstants.catalan\n"
"Base.MathConstants.eulergamma\n"
"Base.MathConstants.golden\n"
"Base.Inf\n"
"Base.Inf32\n"
"Base.Inf16\n"
"Base.NaN\n"
"Base.NaN32\n"
"Base.NaN16\n"
"Base.issubnormal\n"
"Base.isfinite\n"
"Base.isinf\n"
"Base.isnan\n"
"Base.iszero\n"
"Base.isone\n"
"Base.nextfloat\n"
"Base.prevfloat\n"
"Base.isinteger\n"
"Base.isreal\n"
"Core.Float32(::Any)\n"
"Core.Float64(::Any)\n"
"Base.Rounding.rounding\n"
"Base.Rounding.setrounding(::Type, ::Any)\n"
"Base.Rounding.setrounding(::Function, ::Type, ::RoundingMode)\n"
"Base.Rounding.get_zero_subnormals\n"
"Base.Rounding.set_zero_subnormals\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/numbers.md:101
#, no-wrap
msgid ""
"Base.count_ones\n"
"Base.count_zeros\n"
"Base.leading_zeros\n"
"Base.leading_ones\n"
"Base.trailing_zeros\n"
"Base.trailing_ones\n"
"Base.isodd\n"
"Base.iseven\n"
"Base.@int128_str\n"
"Base.@uint128_str\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/numbers.md:114
#, no-wrap
msgid "BigFloats and BigInts"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/numbers.md:121
msgid ""
"The [`BigFloat`](@ref) and [`BigInt`](@ref) types implements arbitrary-precision floating point and integer arithmetic, respectively. For "
"[`BigFloat`](@ref) the [GNU MPFR library](https://www.mpfr.org/) is used, and for [`BigInt`](@ref) the [GNU Multiple Precision Arithmetic "
"Library (GMP)] (https://gmplib.org) is used."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/numbers.md:122
#, no-wrap
msgid ""
"Base.MPFR.BigFloat(::Any, rounding::RoundingMode)\n"
"Base.precision\n"
"Base.MPFR.precision(::Type{BigFloat})\n"
"Base.MPFR.setprecision\n"
"Base.GMP.BigInt(::Any)\n"
"Base.@big_str\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/multi-threading.md:1
#, no-wrap
msgid "[Multi-Threading](@id lib-multithreading)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/multi-threading.md:5
msgid ""
"This experimental interface supports Julia's multi-threading capabilities. Types and functions described here might (and likely will) change "
"in the future."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/multi-threading.md:6
#, no-wrap
msgid ""
"Base.Threads.threadid\n"
"Base.Threads.nthreads\n"
"Base.Threads.@threads\n"
"Base.Threads.@spawn\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/multi-threading.md:13
#, no-wrap
msgid ""
"Base.Threads.Atomic\n"
"Base.Threads.atomic_cas!\n"
"Base.Threads.atomic_xchg!\n"
"Base.Threads.atomic_add!\n"
"Base.Threads.atomic_sub!\n"
"Base.Threads.atomic_and!\n"
"Base.Threads.atomic_nand!\n"
"Base.Threads.atomic_or!\n"
"Base.Threads.atomic_xor!\n"
"Base.Threads.atomic_max!\n"
"Base.Threads.atomic_min!\n"
"Base.Threads.atomic_fence\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/multi-threading.md:28
#, no-wrap
msgid "ccall using a threadpool (Experimental)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/multi-threading.md:30
#, no-wrap
msgid "Base.@threadcall\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/multi-threading.md:34
#, no-wrap
msgid "Low-level synchronization primitives"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/multi-threading.md:37
msgid "These building blocks are used to create the regular synchronization objects."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/multi-threading.md:38
#, no-wrap
msgid "Base.Threads.SpinLock\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/parallel.md:1
#, no-wrap
msgid "Tasks"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/parallel.md:3
#, no-wrap
msgid ""
"Core.Task\n"
"Base.@task\n"
"Base.@async\n"
"Base.@sync\n"
"Base.asyncmap\n"
"Base.asyncmap!\n"
"Base.fetch(t::Task)\n"
"Base.current_task\n"
"Base.istaskdone\n"
"Base.istaskstarted\n"
"Base.istaskfailed\n"
"Base.task_local_storage(::Any)\n"
"Base.task_local_storage(::Any, ::Any)\n"
"Base.task_local_storage(::Function, ::Any, ::Any)\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/parallel.md:20
#, no-wrap
msgid "Scheduling"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/parallel.md:22
#, no-wrap
msgid ""
"Base.yield\n"
"Base.yieldto\n"
"Base.sleep\n"
"Base.wait\n"
"Base.timedwait\n"
"\n"
"Base.Condition\n"
"Base.Threads.Condition\n"
"Base.notify\n"
"Base.schedule\n"
"\n"
"Base.Threads.Event\n"
"\n"
"Base.Semaphore\n"
"Base.acquire\n"
"Base.release\n"
"\n"
"Base.AbstractLock\n"
"Base.lock\n"
"Base.unlock\n"
"Base.trylock\n"
"Base.islocked\n"
"Base.ReentrantLock\n"
"\n"
"Base.Channel\n"
"Base.Channel(::Function)\n"
"Base.put!(::Channel, ::Any)\n"
"Base.take!(::Channel)\n"
"Base.isready(::Channel)\n"
"Base.fetch(::Channel)\n"
"Base.close(::Channel)\n"
"Base.bind(c::Channel, task::Task)\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/base.md:1
#, no-wrap
msgid "Essentials"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:3
#, no-wrap
msgid "Introduction"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:9
msgid ""
"Julia Base contains a range of functions and macros appropriate for performing scientific and numerical computing, but is also as broad as "
"those of many general purpose programming languages.  Additional functionality is available from a growing collection of available "
"packages.  Functions are grouped by topic below."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:11
msgid "Some general notes:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/base.md:17
msgid "To use module functions, use `import Module` to import the module, and `Module.fn(x)` to use the functions."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/base.md:17
msgid "Alternatively, `using Module` will import all exported `Module` functions into the current namespace."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/base.md:17
msgid ""
"By convention, function names ending with an exclamation point (`!`) modify their arguments.  Some functions have both modifying (e.g., "
"`sort!`) and non-modifying (`sort`) versions."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:18
#, no-wrap
msgid "Getting Around"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:20
#, no-wrap
msgid ""
"Base.exit\n"
"Base.atexit\n"
"Base.isinteractive\n"
"Base.summarysize\n"
"Base.require\n"
"Base.compilecache\n"
"Base.__precompile__\n"
"Base.include\n"
"Base.MainInclude.include\n"
"Base.include_string\n"
"Base.include_dependency\n"
"Base.which(::Any, ::Any)\n"
"Base.methods\n"
"Base.@show\n"
"ans\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:38
#, no-wrap
msgid "Keywords"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:46
msgid ""
"This is the list of reserved keywords in Julia: `baremodule`, `begin`, `break`, `catch`, `const`, `continue`, `do`, `else`, `elseif`, `end`, "
"`export`, `false`, `finally`, `for`, `function`, `global`, `if`, `import`, `let`, `local`, `macro`, `module`, `quote`, `return`, `struct`, "
"`true`, `try`, `using`, `while`.  Those keywords are not allowed to be used as variable names."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:51
msgid ""
"The following two-word sequences are reserved: `abstract type`, `mutable struct`, `primitive type`.  However, you can create variables with "
"names: `abstract`, `mutable`, `primitive` and `type`."
msgstr ""
"The following two-word sequences are reserved: `abstract type`, \n"
"`mutable struct`, \n"
"`primitive type`.  However, you can create variables with names: `abstract`, `mutable`, `primitive` and `type`."

#. type: Plain text
#: ext/julia/doc/src/base/base.md:55
msgid ""
"Finally,`where` is parsed as an infix operator for writing parametric method and type definitions. Also `in` and `isa` are parsed as infix "
"operators.  Creation of a variable named `where`, `in` or `isa` is allowed though."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:56
#, no-wrap
msgid ""
"module\n"
"export\n"
"import\n"
"using\n"
"baremodule\n"
"function\n"
"macro\n"
"return\n"
"do\n"
"begin\n"
"end\n"
"let\n"
"if\n"
"for\n"
"while\n"
"break\n"
"continue\n"
"try\n"
"finally\n"
"quote\n"
"local\n"
"global\n"
"const\n"
"struct\n"
"mutable struct\n"
"abstract type\n"
"primitive type\n"
"where\n"
"...\n"
";\n"
"=\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:90
#, no-wrap
msgid "Standard Modules"
msgstr "æ¨æºã¢ã¸ã¥ã¼ã«"

#. type: Plain text
#: ext/julia/doc/src/base/base.md:91
#, no-wrap
msgid ""
"Main\n"
"Core\n"
"Base\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:97
#, no-wrap
msgid "Base Submodules"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:98
#, no-wrap
msgid ""
"Base.Broadcast\n"
"Base.Docs\n"
"Base.Iterators\n"
"Base.Libc\n"
"Base.Meta\n"
"Base.StackTraces\n"
"Base.Sys\n"
"Base.Threads\n"
"Base.GC\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:110
#, no-wrap
msgid "All Objects"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:112
#, no-wrap
msgid ""
"Core.:(===)\n"
"Core.isa\n"
"Base.isequal\n"
"Base.isless\n"
"Base.ifelse\n"
"Core.typeassert\n"
"Core.typeof\n"
"Core.tuple\n"
"Base.ntuple\n"
"Base.objectid\n"
"Base.hash\n"
"Base.finalizer\n"
"Base.finalize\n"
"Base.copy\n"
"Base.deepcopy\n"
"Base.getproperty\n"
"Base.setproperty!\n"
"Base.propertynames\n"
"Base.hasproperty\n"
"Core.getfield\n"
"Core.setfield!\n"
"Core.isdefined\n"
"Base.@isdefined\n"
"Base.convert\n"
"Base.promote\n"
"Base.oftype\n"
"Base.widen\n"
"Base.identity\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:143
#, no-wrap
msgid "Properties of Types"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/base/base.md:145
#, no-wrap
msgid "Type relations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:147
#, no-wrap
msgid ""
"Base.supertype\n"
"Core.:(<:)\n"
"Base.:(>:)\n"
"Base.typejoin\n"
"Base.typeintersect\n"
"Base.promote_type\n"
"Base.promote_rule\n"
"Base.isdispatchtuple\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/base/base.md:158
#, no-wrap
msgid "Declared structure"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:160
#, no-wrap
msgid ""
"Base.isimmutable\n"
"Base.isabstracttype\n"
"Base.isprimitivetype\n"
"Base.issingletontype\n"
"Base.isstructtype\n"
"Base.nameof(::DataType)\n"
"Base.fieldnames\n"
"Base.fieldname\n"
"Base.hasfield\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/base/base.md:172
#, no-wrap
msgid "Memory layout"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:174
#, no-wrap
msgid ""
"Base.sizeof(::Type)\n"
"Base.isconcretetype\n"
"Base.isbits\n"
"Base.isbitstype\n"
"Core.fieldtype\n"
"Base.fieldtypes\n"
"Base.fieldcount\n"
"Base.fieldoffset\n"
"Base.datatype_alignment\n"
"Base.datatype_haspadding\n"
"Base.datatype_pointerfree\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/base/base.md:188
#, no-wrap
msgid "Special values"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:190
#, no-wrap
msgid ""
"Base.typemin\n"
"Base.typemax\n"
"Base.floatmin\n"
"Base.floatmax\n"
"Base.maxintfloat\n"
"Base.eps(::Type{<:AbstractFloat})\n"
"Base.eps(::AbstractFloat)\n"
"Base.instances\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:201
#, no-wrap
msgid "Special Types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:203
#, no-wrap
msgid ""
"Core.Any\n"
"Core.Union\n"
"Union{}\n"
"Core.UnionAll\n"
"Core.Tuple\n"
"Core.NamedTuple\n"
"Base.Val\n"
"Core.Vararg\n"
"Core.Nothing\n"
"Base.isnothing\n"
"Base.Some\n"
"Base.something\n"
"Base.Enums.Enum\n"
"Base.Enums.@enum\n"
"Core.Expr\n"
"Core.Symbol\n"
"Core.Symbol(x...)\n"
"Core.Module\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:224
#, no-wrap
msgid "Generic Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:226
#, no-wrap
msgid ""
"Core.Function\n"
"Base.hasmethod\n"
"Core.applicable\n"
"Core.invoke\n"
"Base.invokelatest\n"
"new\n"
"Base.:(|>)\n"
"Base.:(â)\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:237
#, no-wrap
msgid "Syntax"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:239
#, no-wrap
msgid ""
"Core.eval\n"
"Base.MainInclude.eval\n"
"Base.@eval\n"
"Base.evalfile\n"
"Base.esc\n"
"Base.@inbounds\n"
"Base.@boundscheck\n"
"Base.@propagate_inbounds\n"
"Base.@inline\n"
"Base.@noinline\n"
"Base.@nospecialize\n"
"Base.@specialize\n"
"Base.gensym\n"
"Base.@gensym\n"
"var\"name\"\n"
"Base.@goto\n"
"Base.@label\n"
"Base.@simd\n"
"Base.@polly\n"
"Base.@generated\n"
"Base.@pure\n"
"Base.@deprecate\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:264
#, no-wrap
msgid "Missing Values"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:265
#, no-wrap
msgid ""
"Base.Missing\n"
"Base.missing\n"
"Base.coalesce\n"
"Base.ismissing\n"
"Base.skipmissing\n"
"Base.nonmissingtype\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:274
#, no-wrap
msgid "System"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:276
#, no-wrap
msgid ""
"Base.run\n"
"Base.devnull\n"
"Base.success\n"
"Base.process_running\n"
"Base.process_exited\n"
"Base.kill(::Base.Process, ::Integer)\n"
"Base.Sys.set_process_title\n"
"Base.Sys.get_process_title\n"
"Base.ignorestatus\n"
"Base.detach\n"
"Base.Cmd\n"
"Base.setenv\n"
"Base.withenv\n"
"Base.pipeline(::Any, ::Any, ::Any, ::Any...)\n"
"Base.pipeline(::Base.AbstractCmd)\n"
"Base.Libc.gethostname\n"
"Base.Libc.getpid\n"
"Base.Libc.time()\n"
"Base.time_ns\n"
"Base.@time\n"
"Base.@timev\n"
"Base.@timed\n"
"Base.@elapsed\n"
"Base.@allocated\n"
"Base.EnvDict\n"
"Base.ENV\n"
"Base.Sys.isunix\n"
"Base.Sys.isapple\n"
"Base.Sys.islinux\n"
"Base.Sys.isbsd\n"
"Base.Sys.isfreebsd\n"
"Base.Sys.isopenbsd\n"
"Base.Sys.isnetbsd\n"
"Base.Sys.isdragonfly\n"
"Base.Sys.iswindows\n"
"Base.Sys.windows_version\n"
"Base.Sys.free_memory\n"
"Base.Sys.total_memory\n"
"Base.@static\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:318
#, no-wrap
msgid "Versioning"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:320
#, no-wrap
msgid ""
"Base.VersionNumber\n"
"Base.@v_str\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:327
#, no-wrap
msgid ""
"Base.error\n"
"Core.throw\n"
"Base.rethrow\n"
"Base.backtrace\n"
"Base.catch_backtrace\n"
"Base.catch_stack\n"
"Base.@assert\n"
"Base.ArgumentError\n"
"Base.AssertionError\n"
"Core.BoundsError\n"
"Base.CompositeException\n"
"Base.DimensionMismatch\n"
"Core.DivideError\n"
"Core.DomainError\n"
"Base.EOFError\n"
"Core.ErrorException\n"
"Core.InexactError\n"
"Core.InterruptException\n"
"Base.KeyError\n"
"Base.LoadError\n"
"Base.MethodError\n"
"Base.MissingException\n"
"Core.OutOfMemoryError\n"
"Core.ReadOnlyMemoryError\n"
"Core.OverflowError\n"
"Base.ProcessFailedException\n"
"Core.StackOverflowError\n"
"Base.SystemError\n"
"Core.TypeError\n"
"Core.UndefKeywordError\n"
"Core.UndefRefError\n"
"Core.UndefVarError\n"
"Base.StringIndexError\n"
"Base.InitError\n"
"Base.retry\n"
"Base.ExponentialBackOff\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:366
#, no-wrap
msgid "Events"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:368
#, no-wrap
msgid ""
"Base.Timer(::Function, ::Real)\n"
"Base.Timer\n"
"Base.AsyncCondition\n"
"Base.AsyncCondition(::Function)\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:375
#, no-wrap
msgid "Reflection"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:377
#, no-wrap
msgid ""
"Base.nameof(::Module)\n"
"Base.parentmodule\n"
"Base.pathof(::Module)\n"
"Base.moduleroot\n"
"Base.@__MODULE__\n"
"Base.fullname\n"
"Base.names\n"
"Core.nfields\n"
"Base.isconst\n"
"Base.nameof(::Function)\n"
"Base.functionloc(::Any, ::Any)\n"
"Base.functionloc(::Method)\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:392
#, no-wrap
msgid "Internals"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:394
#, no-wrap
msgid ""
"Base.GC.gc\n"
"Base.GC.enable\n"
"Base.GC.@preserve\n"
"Meta.lower\n"
"Meta.@lower\n"
"Meta.parse(::AbstractString, ::Int)\n"
"Meta.parse(::AbstractString)\n"
"Meta.ParseError\n"
"Core.QuoteNode\n"
"Base.macroexpand\n"
"Base.@macroexpand\n"
"Base.@macroexpand1\n"
"Base.code_lowered\n"
"Base.code_typed\n"
"Base.precompile\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/base.md:412
#, no-wrap
msgid "Meta"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/base.md:413
#, no-wrap
msgid ""
"Meta.quot\n"
"Meta.isexpr\n"
"Meta.show_sexpr\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/sort.md:1
#, no-wrap
msgid "Sorting and Related Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:5
msgid ""
"Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of values. By default, Julia picks reasonable "
"algorithms and sorts in standard ascending order:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:6
#, no-wrap
msgid ""
"julia> sort([2,3,1])\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:15
msgid "You can easily sort in reverse order as well:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:16
#, no-wrap
msgid ""
"julia> sort([2,3,1], rev=true)\n"
"3-element Array{Int64,1}:\n"
" 3\n"
" 2\n"
" 1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:25
msgid "To sort an array in-place, use the \"bang\" version of the sort function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:26
#, no-wrap
msgid ""
"julia> a = [2,3,1];\n"
"\n"
"julia> sort!(a);\n"
"\n"
"julia> a\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:40
msgid "Instead of directly sorting an array, you can compute a permutation of the array's indices that puts the array into sorted order:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:41
#, no-wrap
msgid ""
"julia> v = randn(5)\n"
"5-element Array{Float64,1}:\n"
"  0.297288\n"
"  0.382396\n"
" -0.597634\n"
" -0.0104452\n"
" -0.839027\n"
"\n"
"julia> p = sortperm(v)\n"
"5-element Array{Int64,1}:\n"
" 5\n"
" 3\n"
" 4\n"
" 1\n"
" 2\n"
"\n"
"julia> v[p]\n"
"5-element Array{Float64,1}:\n"
" -0.839027\n"
" -0.597634\n"
" -0.0104452\n"
"  0.297288\n"
"  0.382396\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:68
msgid "Arrays can easily be sorted according to an arbitrary transformation of their values:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:69
#, no-wrap
msgid ""
"julia> sort(v, by=abs)\n"
"5-element Array{Float64,1}:\n"
" -0.0104452\n"
"  0.297288\n"
"  0.382396\n"
" -0.597634\n"
" -0.839027\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:80
msgid "Or in reverse order by a transformation:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:81
#, no-wrap
msgid ""
"julia> sort(v, by=abs, rev=true)\n"
"5-element Array{Float64,1}:\n"
" -0.839027\n"
" -0.597634\n"
"  0.382396\n"
"  0.297288\n"
" -0.0104452\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:92
msgid "If needed, the sorting algorithm can be chosen:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:93
#, no-wrap
msgid ""
"julia> sort(v, alg=InsertionSort)\n"
"5-element Array{Float64,1}:\n"
" -0.839027\n"
" -0.597634\n"
" -0.0104452\n"
"  0.297288\n"
"  0.382396\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:106
msgid ""
"All the sorting and order related functions rely on a \"less than\" relation defining a total order on the values to be manipulated. The "
"`isless` function is invoked by default, but the relation can be specified via the `lt` keyword."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/sort.md:107
#, no-wrap
msgid "Sorting Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:109
#, no-wrap
msgid ""
"Base.sort!\n"
"Base.sort\n"
"Base.sortperm\n"
"Base.InsertionSort\n"
"Base.MergeSort\n"
"Base.QuickSort\n"
"Base.PartialQuickSort\n"
"Base.Sort.sortperm!\n"
"Base.Sort.sortslices\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/sort.md:121
#, no-wrap
msgid "Order-Related Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:123
#, no-wrap
msgid ""
"Base.issorted\n"
"Base.Sort.searchsorted\n"
"Base.Sort.searchsortedfirst\n"
"Base.Sort.searchsortedlast\n"
"Base.Sort.partialsort!\n"
"Base.Sort.partialsort\n"
"Base.Sort.partialsortperm\n"
"Base.Sort.partialsortperm!\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/sort.md:134
#, no-wrap
msgid "Sorting Algorithms"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:137
msgid "There are currently four sorting algorithms available in base Julia:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/sort.md:142
msgid "[`InsertionSort`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/sort.md:142
msgid "[`QuickSort`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/sort.md:142
msgid "[`PartialQuickSort(k)`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/sort.md:142
msgid "[`MergeSort`](@ref)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:145
msgid "`InsertionSort` is an O(n^2) stable sorting algorithm. It is efficient for very small `n`, and is used internally by `QuickSort`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:150
msgid ""
"`QuickSort` is an O(n log n) sorting algorithm which is in-place, very fast, but not stable â i.e. elements which are considered equal will "
"not remain in the same order in which they originally appeared in the array to be sorted. `QuickSort` is the default algorithm for numeric "
"values, including integers and floats."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:153
msgid ""
"`PartialQuickSort(k)` is similar to `QuickSort`, but the output array is only sorted up to index `k` if `k` is an integer, or in the range "
"of `k` if `k` is an `OrdinalRange`. For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:154
#, no-wrap
msgid ""
"x = rand(1:500, 100)\n"
"k = 50\n"
"k2 = 50:100\n"
"s = sort(x; alg=QuickSort)\n"
"ps = sort(x; alg=PartialQuickSort(k))\n"
"qs = sort(x; alg=PartialQuickSort(k2))\n"
"map(issorted, (s, ps, qs))             # => (true, false, false)\n"
"map(x->issorted(x[1:k]), (s, ps, qs))  # => (true, true, false)\n"
"map(x->issorted(x[k2]), (s, ps, qs))   # => (true, false, true)\n"
"s[1:k] == ps[1:k]                      # => true\n"
"s[k2] == qs[k2]                        # => true\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:171
msgid ""
"`MergeSort` is an O(n log n) stable sorting algorithm but is not in-place â it requires a temporary array of half the size of the input "
"array â and is typically not quite as fast as `QuickSort`.  It is the default algorithm for non-numeric data."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:177
msgid ""
"The default sorting algorithms are chosen on the basis that they are fast and stable, or *appear* to be so. For numeric types indeed, "
"`QuickSort` is selected as it is faster and indistinguishable in this case from a stable sort (unless the array records its mutations in "
"some way). The stability property comes at a non-negligible cost, so if you don't need it, you may want to explicitly specify your preferred "
"algorithm, e.g. `sort!(v, alg=QuickSort)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:181
msgid ""
"The mechanism by which Julia picks default sorting algorithms is implemented via the `Base.Sort.defalg` function. It allows a particular "
"algorithm to be registered as the default in all sorting functions for specific arrays. For example, here are the two default methods from "
"[`sort.jl`](https://github.com/JuliaLang/julia/blob/master/base/sort.jl):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:182
#, no-wrap
msgid ""
"defalg(v::AbstractArray) = MergeSort\n"
"defalg(v::AbstractArray{<:Number}) = QuickSort\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/sort.md:189
msgid ""
"As for numeric arrays, choosing a non-stable default algorithm for array types for which the notion of a stable sort is meaningless (i.e. "
"when two values comparing equal can not be distinguished)  may make sense."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/strings.md:1
#, no-wrap
msgid "[Strings](@id lib-strings)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/strings.md:3
#, no-wrap
msgid ""
"Core.AbstractChar\n"
"Core.Char\n"
"Base.codepoint\n"
"Base.length(::AbstractString)\n"
"Base.sizeof(::AbstractString)\n"
"Base.:*(::Union{AbstractChar, AbstractString}, ::Union{AbstractChar, AbstractString}...)\n"
"Base.:^(::AbstractString, ::Integer)\n"
"Base.string\n"
"Base.repeat(::AbstractString, ::Integer)\n"
"Base.repeat(::AbstractChar, ::Integer)\n"
"Base.repr(::Any)\n"
"Core.String(::AbstractString)\n"
"Base.SubString\n"
"Base.transcode\n"
"Base.unsafe_string\n"
"Base.ncodeunits(::AbstractString)\n"
"Base.codeunit\n"
"Base.codeunits\n"
"Base.ascii\n"
"Base.@r_str\n"
"Base.SubstitutionString\n"
"Base.@s_str\n"
"Base.@raw_str\n"
"Base.@b_str\n"
"Base.Docs.@html_str\n"
"Base.Docs.@text_str\n"
"Base.isvalid(::Any)\n"
"Base.isvalid(::Any, ::Any)\n"
"Base.isvalid(::AbstractString, ::Integer)\n"
"Base.match\n"
"Base.eachmatch\n"
"Base.isless(::AbstractString, ::AbstractString)\n"
"Base.:(==)(::AbstractString, ::AbstractString)\n"
"Base.cmp(::AbstractString, ::AbstractString)\n"
"Base.lpad\n"
"Base.rpad\n"
"Base.findfirst(::AbstractString, ::AbstractString)\n"
"Base.findnext(::AbstractString, ::AbstractString, ::Integer)\n"
"Base.findnext(::AbstractChar, ::AbstractString, ::Integer)\n"
"Base.findlast(::AbstractString, ::AbstractString)\n"
"Base.findlast(::AbstractChar, ::AbstractString)\n"
"Base.findprev(::AbstractString, ::AbstractString, ::Integer)\n"
"Base.occursin\n"
"Base.reverse(::Union{String,SubString{String}})\n"
"Base.replace(s::AbstractString, ::Pair)\n"
"Base.split\n"
"Base.rsplit\n"
"Base.strip\n"
"Base.lstrip\n"
"Base.rstrip\n"
"Base.startswith\n"
"Base.endswith\n"
"Base.first(::AbstractString, ::Integer)\n"
"Base.last(::AbstractString, ::Integer)\n"
"Base.uppercase\n"
"Base.lowercase\n"
"Base.titlecase\n"
"Base.uppercasefirst\n"
"Base.lowercasefirst\n"
"Base.join\n"
"Base.chop\n"
"Base.chomp\n"
"Base.thisind\n"
"Base.nextind\n"
"Base.prevind\n"
"Base.textwidth\n"
"Base.isascii\n"
"Base.iscntrl\n"
"Base.isdigit\n"
"Base.isletter\n"
"Base.islowercase\n"
"Base.isnumeric\n"
"Base.isprint\n"
"Base.ispunct\n"
"Base.isspace\n"
"Base.isuppercase\n"
"Base.isxdigit\n"
"Base.escape_string\n"
"Base.unescape_string\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/math.md:1
#, no-wrap
msgid "Mathematics"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/math.md:3
#, no-wrap
msgid "[Mathematical Operators](@id math-ops)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/math.md:5
#, no-wrap
msgid ""
"Base.:-(::Any)\n"
"Base.:(+)\n"
"Base.:-(::Any, ::Any)\n"
"Base.:*(::Any, ::Any...)\n"
"Base.:(/)\n"
"Base.:\\(::Any, ::Any)\n"
"Base.:^(::Number, ::Number)\n"
"Base.fma\n"
"Base.muladd\n"
"Base.inv(::Number)\n"
"Base.div\n"
"Base.fld\n"
"Base.cld\n"
"Base.mod\n"
"Base.rem\n"
"Base.rem2pi\n"
"Base.Math.mod2pi\n"
"Base.divrem\n"
"Base.fldmod\n"
"Base.fld1\n"
"Base.mod1\n"
"Base.fldmod1\n"
"Base.:(//)\n"
"Base.rationalize\n"
"Base.numerator\n"
"Base.denominator\n"
"Base.:(<<)\n"
"Base.:(>>)\n"
"Base.:(>>>)\n"
"Base.:(:)\n"
"Base.range\n"
"Base.OneTo\n"
"Base.StepRangeLen\n"
"Base.:(==)\n"
"Base.:(!=)\n"
"Base.:(!==)\n"
"Base.:(<)\n"
"Base.:(<=)\n"
"Base.:(>)\n"
"Base.:(>=)\n"
"Base.cmp\n"
"Base.:(~)\n"
"Base.:(&)\n"
"Base.:(|)\n"
"Base.xor\n"
"Base.:(!)\n"
"&&\n"
"||\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/math.md:56
#, no-wrap
msgid "Mathematical Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/math.md:58
#, no-wrap
msgid ""
"Base.isapprox\n"
"Base.sin(::Number)\n"
"Base.cos(::Number)\n"
"Base.sincos(::Float64)\n"
"Base.tan(::Number)\n"
"Base.Math.sind\n"
"Base.Math.cosd\n"
"Base.Math.tand\n"
"Base.Math.sinpi\n"
"Base.Math.cospi\n"
"Base.sinh(::Number)\n"
"Base.cosh(::Number)\n"
"Base.tanh(::Number)\n"
"Base.asin(::Number)\n"
"Base.acos(::Number)\n"
"Base.atan(::Number)\n"
"Base.Math.asind\n"
"Base.Math.acosd\n"
"Base.Math.atand\n"
"Base.Math.sec(::Number)\n"
"Base.Math.csc(::Number)\n"
"Base.Math.cot(::Number)\n"
"Base.Math.secd\n"
"Base.Math.cscd\n"
"Base.Math.cotd\n"
"Base.Math.asec(::Number)\n"
"Base.Math.acsc(::Number)\n"
"Base.Math.acot(::Number)\n"
"Base.Math.asecd\n"
"Base.Math.acscd\n"
"Base.Math.acotd\n"
"Base.Math.sech(::Number)\n"
"Base.Math.csch(::Number)\n"
"Base.Math.coth(::Number)\n"
"Base.asinh(::Number)\n"
"Base.acosh(::Number)\n"
"Base.atanh(::Number)\n"
"Base.Math.asech(::Number)\n"
"Base.Math.acsch(::Number)\n"
"Base.Math.acoth(::Number)\n"
"Base.Math.sinc\n"
"Base.Math.cosc\n"
"Base.Math.deg2rad\n"
"Base.Math.rad2deg\n"
"Base.Math.hypot\n"
"Base.log(::Number)\n"
"Base.log(::Number, ::Number)\n"
"Base.log2\n"
"Base.log10\n"
"Base.log1p\n"
"Base.Math.frexp\n"
"Base.exp(::Float64)\n"
"Base.exp2\n"
"Base.exp10\n"
"Base.Math.ldexp\n"
"Base.Math.modf\n"
"Base.expm1\n"
"Base.round(::Type, ::Any)\n"
"Base.Rounding.RoundingMode\n"
"Base.Rounding.RoundNearest\n"
"Base.Rounding.RoundNearestTiesAway\n"
"Base.Rounding.RoundNearestTiesUp\n"
"Base.Rounding.RoundToZero\n"
"Base.Rounding.RoundFromZero\n"
"Base.Rounding.RoundUp\n"
"Base.Rounding.RoundDown\n"
"Base.round(::Complex{<: AbstractFloat}, ::RoundingMode, ::RoundingMode)\n"
"Base.ceil\n"
"Base.floor\n"
"Base.trunc\n"
"Base.unsafe_trunc\n"
"Base.min\n"
"Base.max\n"
"Base.minmax\n"
"Base.Math.clamp\n"
"Base.Math.clamp!\n"
"Base.abs\n"
"Base.Checked.checked_abs\n"
"Base.Checked.checked_neg\n"
"Base.Checked.checked_add\n"
"Base.Checked.checked_sub\n"
"Base.Checked.checked_mul\n"
"Base.Checked.checked_div\n"
"Base.Checked.checked_rem\n"
"Base.Checked.checked_fld\n"
"Base.Checked.checked_mod\n"
"Base.Checked.checked_cld\n"
"Base.Checked.add_with_overflow\n"
"Base.Checked.sub_with_overflow\n"
"Base.Checked.mul_with_overflow\n"
"Base.abs2\n"
"Base.copysign\n"
"Base.sign\n"
"Base.signbit\n"
"Base.flipsign\n"
"Base.sqrt(::Real)\n"
"Base.isqrt\n"
"Base.Math.cbrt\n"
"Base.real(::Complex)\n"
"Base.imag\n"
"Base.reim\n"
"Base.conj\n"
"Base.angle\n"
"Base.cis\n"
"Base.binomial\n"
"Base.factorial\n"
"Base.gcd\n"
"Base.lcm\n"
"Base.gcdx\n"
"Base.ispow2\n"
"Base.nextpow\n"
"Base.prevpow\n"
"Base.nextprod\n"
"Base.invmod\n"
"Base.powermod\n"
"Base.ndigits\n"
"Base.widemul\n"
"Base.Math.@evalpoly\n"
"Base.FastMath.@fastmath\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/stacktraces.md:1
#, no-wrap
msgid "StackTraces"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/stacktraces.md:3
#, no-wrap
msgid ""
"Base.StackTraces.StackFrame\n"
"Base.StackTraces.StackTrace\n"
"Base.StackTraces.stacktrace\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/stacktraces.md:11
msgid "The following methods and types in `Base.StackTraces` are not exported and need to be called e.g.  as `StackTraces.lookup(ptr)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/stacktraces.md:12
#, no-wrap
msgid ""
"Base.StackTraces.lookup\n"
"Base.StackTraces.remove_frames!\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/libc.md:1
#, no-wrap
msgid "C Standard Library"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/libc.md:3
#, no-wrap
msgid ""
"Base.Libc.malloc\n"
"Base.Libc.calloc\n"
"Base.Libc.realloc\n"
"Base.Libc.free\n"
"Base.Libc.errno\n"
"Base.Libc.strerror\n"
"Base.Libc.GetLastError\n"
"Base.Libc.FormatMessage\n"
"Base.Libc.time(::Base.Libc.TmStruct)\n"
"Base.Libc.strftime\n"
"Base.Libc.strptime\n"
"Base.Libc.TmStruct\n"
"Base.Libc.flush_cstdio\n"
"Base.Libc.systemsleep\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/file.md:1
#, no-wrap
msgid "Filesystem"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/file.md:3
#, no-wrap
msgid ""
"Base.Filesystem.pwd\n"
"Base.Filesystem.cd(::AbstractString)\n"
"Base.Filesystem.cd(::Function)\n"
"Base.Filesystem.readdir\n"
"Base.Filesystem.walkdir\n"
"Base.Filesystem.mkdir\n"
"Base.Filesystem.mkpath\n"
"Base.Filesystem.symlink\n"
"Base.Filesystem.readlink\n"
"Base.Filesystem.chmod\n"
"Base.Filesystem.chown\n"
"Base.RawFD\n"
"Base.stat\n"
"Base.Filesystem.lstat\n"
"Base.Filesystem.ctime\n"
"Base.Filesystem.mtime\n"
"Base.Filesystem.filemode\n"
"Base.Filesystem.filesize\n"
"Base.Filesystem.uperm\n"
"Base.Filesystem.gperm\n"
"Base.Filesystem.operm\n"
"Base.Filesystem.cp\n"
"Base.download\n"
"Base.Filesystem.mv\n"
"Base.Filesystem.rm\n"
"Base.Filesystem.touch\n"
"Base.Filesystem.tempname\n"
"Base.Filesystem.tempdir\n"
"Base.Filesystem.mktemp(::AbstractString)\n"
"Base.Filesystem.mktemp(::Function, ::AbstractString)\n"
"Base.Filesystem.mktempdir(::AbstractString)\n"
"Base.Filesystem.mktempdir(::Function, ::AbstractString)\n"
"Base.Filesystem.isblockdev\n"
"Base.Filesystem.ischardev\n"
"Base.Filesystem.isdir\n"
"Base.Filesystem.isfifo\n"
"Base.Filesystem.isfile\n"
"Base.Filesystem.islink\n"
"Base.Filesystem.ismount\n"
"Base.Filesystem.ispath\n"
"Base.Filesystem.issetgid\n"
"Base.Filesystem.issetuid\n"
"Base.Filesystem.issocket\n"
"Base.Filesystem.issticky\n"
"Base.Filesystem.homedir\n"
"Base.Filesystem.dirname\n"
"Base.Filesystem.basename\n"
"Base.@__FILE__\n"
"Base.@__DIR__\n"
"Base.@__LINE__\n"
"Base.Filesystem.isabspath\n"
"Base.Filesystem.isdirpath\n"
"Base.Filesystem.joinpath\n"
"Base.Filesystem.abspath\n"
"Base.Filesystem.normpath\n"
"Base.Filesystem.realpath\n"
"Base.Filesystem.relpath\n"
"Base.Filesystem.expanduser\n"
"Base.Filesystem.splitdir\n"
"Base.Filesystem.splitdrive\n"
"Base.Filesystem.splitext\n"
"Base.Filesystem.splitpath\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/collections.md:1
#, no-wrap
msgid "Collections and Data Structures"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/collections.md:3
#, no-wrap
msgid "[Iteration](@id lib-collections-iteration)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:7
msgid "Sequential iteration is implemented by the [`iterate`](@ref) function.  The general `for` loop:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:28
msgid ""
"The `state` object may be anything, and should be chosen appropriately for each iterable type.  See the [manual section on the iteration "
"interface](@ref man-interface-iteration) for more details about defining a custom iterable type."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:29
#, no-wrap
msgid ""
"Base.iterate\n"
"Base.IteratorSize\n"
"Base.IteratorEltype\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:36 ext/julia/doc/src/base/collections.md:72 ext/julia/doc/src/base/collections.md:153
#: ext/julia/doc/src/base/collections.md:221 ext/julia/doc/src/base/collections.md:257 ext/julia/doc/src/base/collections.md:281
msgid "Fully implemented by:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51 ext/julia/doc/src/base/collections.md:85 ext/julia/doc/src/base/collections.md:169
msgid "[`AbstractRange`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51 ext/julia/doc/src/base/collections.md:85 ext/julia/doc/src/base/collections.md:169
msgid "[`UnitRange`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51 ext/julia/doc/src/base/collections.md:85 ext/julia/doc/src/base/collections.md:169
msgid "`Tuple`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51 ext/julia/doc/src/base/collections.md:85
msgid "`Number`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51 ext/julia/doc/src/base/collections.md:85 ext/julia/doc/src/base/collections.md:158
msgid "[`AbstractArray`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51 ext/julia/doc/src/base/collections.md:85 ext/julia/doc/src/base/collections.md:235
#: ext/julia/doc/src/base/collections.md:260
msgid "[`BitSet`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51 ext/julia/doc/src/base/collections.md:85 ext/julia/doc/src/base/collections.md:169
#: ext/julia/doc/src/base/collections.md:225
msgid "[`IdDict`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51 ext/julia/doc/src/base/collections.md:85 ext/julia/doc/src/base/collections.md:169
#: ext/julia/doc/src/base/collections.md:225
msgid "[`Dict`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51 ext/julia/doc/src/base/collections.md:85 ext/julia/doc/src/base/collections.md:169
#: ext/julia/doc/src/base/collections.md:225
msgid "[`WeakKeyDict`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51
msgid "`EachLine`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51 ext/julia/doc/src/base/collections.md:85 ext/julia/doc/src/base/collections.md:169
msgid "`AbstractString`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51 ext/julia/doc/src/base/collections.md:85 ext/julia/doc/src/base/collections.md:235
#: ext/julia/doc/src/base/collections.md:260
msgid "[`Set`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51
msgid "[`Pair`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:51 ext/julia/doc/src/base/collections.md:85 ext/julia/doc/src/base/collections.md:169
msgid "[`NamedTuple`](@ref)"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/collections.md:52 ext/julia/doc/src/base/arrays.md:3
#, no-wrap
msgid "Constructors and Types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:54
#, no-wrap
msgid ""
"Base.AbstractRange\n"
"Base.OrdinalRange\n"
"Base.AbstractUnitRange\n"
"Base.StepRange\n"
"Base.UnitRange\n"
"Base.LinRange\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/collections.md:63
#, no-wrap
msgid "General Collections"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:65
#, no-wrap
msgid ""
"Base.isempty\n"
"Base.empty!\n"
"Base.length\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/collections.md:86
#, no-wrap
msgid "Iterable Collections"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:88
#, no-wrap
msgid ""
"Base.in\n"
"Base.:â\n"
"Base.eltype\n"
"Base.indexin\n"
"Base.unique\n"
"Base.unique!\n"
"Base.allunique\n"
"Base.reduce(::Any, ::Any)\n"
"Base.foldl(::Any, ::Any)\n"
"Base.foldr(::Any, ::Any)\n"
"Base.maximum\n"
"Base.maximum!\n"
"Base.minimum\n"
"Base.minimum!\n"
"Base.extrema\n"
"Base.argmax\n"
"Base.argmin\n"
"Base.findmax\n"
"Base.findmin\n"
"Base.findmax!\n"
"Base.findmin!\n"
"Base.sum\n"
"Base.sum!\n"
"Base.prod\n"
"Base.prod!\n"
"Base.any(::Any)\n"
"Base.any(::AbstractArray, ::Any)\n"
"Base.any!\n"
"Base.all(::Any)\n"
"Base.all(::AbstractArray, ::Any)\n"
"Base.all!\n"
"Base.count\n"
"Base.any(::Any, ::Any)\n"
"Base.all(::Any, ::Any)\n"
"Base.foreach\n"
"Base.map\n"
"Base.map!\n"
"Base.mapreduce(::Any, ::Any, ::Any)\n"
"Base.mapfoldl(::Any, ::Any, ::Any)\n"
"Base.mapfoldr(::Any, ::Any, ::Any)\n"
"Base.first\n"
"Base.last\n"
"Base.front\n"
"Base.tail\n"
"Base.step\n"
"Base.collect(::Any)\n"
"Base.collect(::Type, ::Any)\n"
"Base.filter\n"
"Base.filter!\n"
"Base.replace(::Any, ::Pair...)\n"
"Base.replace(::Base.Callable, ::Any)\n"
"Base.replace!\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/collections.md:143
#, no-wrap
msgid "Indexable Collections"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:145
#, no-wrap
msgid ""
"Base.getindex\n"
"Base.setindex!\n"
"Base.firstindex\n"
"Base.lastindex\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:158 ext/julia/doc/src/base/collections.md:235 ext/julia/doc/src/base/collections.md:264
msgid "[`Array`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:158 ext/julia/doc/src/base/collections.md:235
msgid "[`BitArray`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:158
msgid "`SubArray`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:160 ext/julia/doc/src/base/collections.md:227 ext/julia/doc/src/base/collections.md:262
msgid "Partially implemented by:"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/collections.md:170
#, no-wrap
msgid "Dictionaries"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:175
msgid ""
"[`Dict`](@ref) is the standard dictionary. Its implementation uses [`hash`](@ref)  as the hashing function for the key, and [`isequal`]"
"(@ref) to determine equality. Define these two functions for custom types to override how they are stored in a hash table."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:177
msgid "[`IdDict`](@ref) is a special hash table where the keys are always object identities."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:182
msgid ""
"[`WeakKeyDict`](@ref) is a hash table implementation where the keys are weak references to objects, and thus may be garbage collected even "
"when referenced in a hash table.  Like `Dict` it uses `hash` for hashing and `isequal` for equality, unlike `Dict` it does not convert keys "
"on insertion."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:187
#, no-wrap
msgid ""
"[`Dict`](@ref)s can be created by passing pair objects constructed with `=>` to a [`Dict`](@ref)\n"
"constructor: `Dict(\"A\"=>1, \"B\"=>2)`. This call will attempt to infer type information from the\n"
"keys and values (i.e. this example creates a `Dict{String, Int64}`). To explicitly specify types\n"
"use the syntax `Dict{KeyType,ValueType}(...)`. For example, `Dict{String,Int32}(\"A\"=>1, \"B\"=>2)`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:189
#, no-wrap
msgid "Dictionaries may also be created with generators. For example, `Dict(i => f(i) for i = 1:10)`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:194
#, no-wrap
msgid ""
"Given a dictionary `D`, the syntax `D[x]` returns the value of key `x` (if it exists) or throws\n"
"an error, and `D[x] = y` stores the key-value pair `x => y` in `D` (replacing any existing value\n"
"for the key `x`).  Multiple arguments to `D[...]` are converted to tuples; for example, the syntax\n"
"`D[x,y]`  is equivalent to `D[(x,y)]`, i.e. it refers to the value keyed by the tuple `(x,y)`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:195
#, no-wrap
msgid ""
"Base.AbstractDict\n"
"Base.Dict\n"
"Base.IdDict\n"
"Base.WeakKeyDict\n"
"Base.ImmutableDict\n"
"Base.haskey\n"
"Base.get(::Any, ::Any, ::Any)\n"
"Base.get\n"
"Base.get!(::Any, ::Any, ::Any)\n"
"Base.get!(::Function, ::Any, ::Any)\n"
"Base.getkey\n"
"Base.delete!\n"
"Base.pop!(::Any, ::Any, ::Any)\n"
"Base.keys\n"
"Base.values\n"
"Base.pairs\n"
"Base.merge\n"
"Base.merge!(::AbstractDict, ::AbstractDict...)\n"
"Base.merge!(::Function, ::AbstractDict, ::AbstractDict...)\n"
"Base.sizehint!\n"
"Base.keytype\n"
"Base.valtype\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:235
msgid "[`EnvDict`](@ref Base.EnvDict)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:235
msgid "[`ImmutableDict`](@ref Base.ImmutableDict)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:235
msgid "[`Iterators.Pairs`](@ref)"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/collections.md:236
#, no-wrap
msgid "Set-Like Collections"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:238
#, no-wrap
msgid ""
"Base.AbstractSet\n"
"Base.Set\n"
"Base.BitSet\n"
"Base.union\n"
"Base.union!\n"
"Base.intersect\n"
"Base.setdiff\n"
"Base.setdiff!\n"
"Base.symdiff\n"
"Base.symdiff!\n"
"Base.intersect!\n"
"Base.issubset\n"
"Base.:â\n"
"Base.:â\n"
"Base.issetequal\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/collections.md:265
#, no-wrap
msgid "Dequeues"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:267
#, no-wrap
msgid ""
"Base.push!\n"
"Base.pop!\n"
"Base.pushfirst!\n"
"Base.popfirst!\n"
"Base.insert!\n"
"Base.deleteat!\n"
"Base.splice!\n"
"Base.resize!\n"
"Base.append!\n"
"Base.prepend!\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:284
msgid "`Vector` (a.k.a. 1-dimensional [`Array`](@ref))"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/collections.md:284
msgid "`BitVector` (a.k.a. 1-dimensional [`BitArray`](@ref))"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/collections.md:285
#, no-wrap
msgid "Utility Collections"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/collections.md:287
#, no-wrap
msgid ""
"Base.Pair\n"
"Iterators.Pairs\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/arrays.md:1
#, no-wrap
msgid "[Arrays](@id lib-arrays)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/arrays.md:5
#, no-wrap
msgid ""
"Core.AbstractArray\n"
"Base.AbstractVector\n"
"Base.AbstractMatrix\n"
"Base.AbstractVecOrMat\n"
"Core.Array\n"
"Core.Array(::UndefInitializer, ::Any)\n"
"Core.Array(::Nothing, ::Any)\n"
"Core.Array(::Missing, ::Any)\n"
"Core.UndefInitializer\n"
"Core.undef\n"
"Base.Vector\n"
"Base.Vector(::UndefInitializer, ::Any)\n"
"Base.Vector(::Nothing, ::Any)\n"
"Base.Vector(::Missing, ::Any)\n"
"Base.Matrix\n"
"Base.Matrix(::UndefInitializer, ::Any, ::Any)\n"
"Base.Matrix(::Nothing, ::Any, ::Any)\n"
"Base.Matrix(::Missing, ::Any, ::Any)\n"
"Base.VecOrMat\n"
"Core.DenseArray\n"
"Base.DenseVector\n"
"Base.DenseMatrix\n"
"Base.DenseVecOrMat\n"
"Base.StridedArray\n"
"Base.StridedVector\n"
"Base.StridedMatrix\n"
"Base.StridedVecOrMat\n"
"Base.getindex(::Type, ::Any...)\n"
"Base.zeros\n"
"Base.ones\n"
"Base.BitArray\n"
"Base.BitArray(::UndefInitializer, ::Integer...)\n"
"Base.BitArray(::Any)\n"
"Base.trues\n"
"Base.falses\n"
"Base.fill\n"
"Base.fill!\n"
"Base.similar\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/arrays.md:46
#, no-wrap
msgid "Basic functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/arrays.md:48
#, no-wrap
msgid ""
"Base.ndims\n"
"Base.size\n"
"Base.axes(::Any)\n"
"Base.axes(::AbstractArray, ::Any)\n"
"Base.length(::AbstractArray)\n"
"Base.eachindex\n"
"Base.IndexStyle\n"
"Base.IndexLinear\n"
"Base.IndexCartesian\n"
"Base.conj!\n"
"Base.stride\n"
"Base.strides\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/arrays.md:63
#, no-wrap
msgid "Broadcast and vectorization"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/arrays.md:69
msgid ""
"See also the [dot syntax for vectorizing functions](@ref man-vectorized); for example, `f.(args...)` implicitly calls `broadcast(f, "
"args...)`.  Rather than relying on \"vectorized\" methods of functions like `sin` to operate on arrays, you should use `sin.(a)` to "
"vectorize via `broadcast`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/arrays.md:70
#, no-wrap
msgid ""
"Base.broadcast\n"
"Base.Broadcast.broadcast!\n"
"Base.@__dot__\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/arrays.md:77
msgid "For specializing broadcast on custom types, see"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/arrays.md:77
#, no-wrap
msgid ""
"Base.BroadcastStyle\n"
"Base.Broadcast.AbstractArrayStyle\n"
"Base.Broadcast.ArrayStyle\n"
"Base.Broadcast.DefaultArrayStyle\n"
"Base.Broadcast.broadcastable\n"
"Base.Broadcast.combine_axes\n"
"Base.Broadcast.combine_styles\n"
"Base.Broadcast.result_style\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/arrays.md:88
#, no-wrap
msgid "Indexing and assignment"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/arrays.md:90
#, no-wrap
msgid ""
"Base.getindex(::AbstractArray, ::Any...)\n"
"Base.setindex!(::AbstractArray, ::Any, ::Any...)\n"
"Base.copyto!(::AbstractArray, ::CartesianIndices, ::AbstractArray, ::CartesianIndices)\n"
"Base.isassigned\n"
"Base.Colon\n"
"Base.CartesianIndex\n"
"Base.CartesianIndices\n"
"Base.Dims\n"
"Base.LinearIndices\n"
"Base.to_indices\n"
"Base.checkbounds\n"
"Base.checkindex\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/arrays.md:105
#, no-wrap
msgid "Views (SubArrays and other view types)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/arrays.md:107
#, no-wrap
msgid ""
"Base.view\n"
"Base.@view\n"
"Base.@views\n"
"Base.parent\n"
"Base.parentindices\n"
"Base.selectdim\n"
"Base.reinterpret\n"
"Base.reshape\n"
"Base.dropdims\n"
"Base.vec\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/arrays.md:120
#, no-wrap
msgid "Concatenation and permutation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/arrays.md:122
#, no-wrap
msgid ""
"Base.cat\n"
"Base.vcat\n"
"Base.hcat\n"
"Base.hvcat\n"
"Base.vect\n"
"Base.circshift\n"
"Base.circshift!\n"
"Base.circcopy!\n"
"Base.findall(::Any)\n"
"Base.findall(::Function, ::Any)\n"
"Base.findfirst(::Any)\n"
"Base.findfirst(::Function, ::Any)\n"
"Base.findlast(::Any)\n"
"Base.findlast(::Function, ::Any)\n"
"Base.findnext(::Any, ::Integer)\n"
"Base.findnext(::Function, ::Any, ::Integer)\n"
"Base.findprev(::Any, ::Integer)\n"
"Base.findprev(::Function, ::Any, ::Integer)\n"
"Base.permutedims\n"
"Base.permutedims!\n"
"Base.PermutedDimsArray\n"
"Base.promote_shape\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/arrays.md:147
#, no-wrap
msgid "Array functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/arrays.md:149
#, no-wrap
msgid ""
"Base.accumulate\n"
"Base.accumulate!\n"
"Base.cumprod\n"
"Base.cumprod!\n"
"Base.cumsum\n"
"Base.cumsum!\n"
"Base.diff\n"
"Base.repeat\n"
"Base.rot180\n"
"Base.rotl90\n"
"Base.rotr90\n"
"Base.mapslices\n"
"Base.eachrow\n"
"Base.eachcol\n"
"Base.eachslice\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/arrays.md:167
#, no-wrap
msgid "Combinatorics"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/arrays.md:169
#, no-wrap
msgid ""
"Base.invperm\n"
"Base.isperm\n"
"Base.permute!(::Any, ::AbstractVector)\n"
"Base.invpermute!\n"
"Base.reverse(::AbstractVector; kwargs...)\n"
"Base.reverseind\n"
"Base.reverse!\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/io-network.md:1
#, no-wrap
msgid "I/O and Network"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/io-network.md:3
#, no-wrap
msgid "General I/O"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/io-network.md:5
#, no-wrap
msgid ""
"Base.stdout\n"
"Base.stderr\n"
"Base.stdin\n"
"Base.open\n"
"Base.IOStream\n"
"Base.IOBuffer\n"
"Base.take!(::Base.GenericIOBuffer)\n"
"Base.fdio\n"
"Base.flush\n"
"Base.close\n"
"Base.write\n"
"Base.read\n"
"Base.read!\n"
"Base.readbytes!\n"
"Base.unsafe_read\n"
"Base.unsafe_write\n"
"Base.position\n"
"Base.seek\n"
"Base.seekstart\n"
"Base.seekend\n"
"Base.skip\n"
"Base.mark\n"
"Base.unmark\n"
"Base.reset\n"
"Base.ismarked\n"
"Base.eof\n"
"Base.isreadonly\n"
"Base.iswritable\n"
"Base.isreadable\n"
"Base.isopen\n"
"Base.Grisu.print_shortest\n"
"Base.fd\n"
"Base.redirect_stdout\n"
"Base.redirect_stdout(::Function, ::Any)\n"
"Base.redirect_stderr\n"
"Base.redirect_stderr(::Function, ::Any)\n"
"Base.redirect_stdin\n"
"Base.redirect_stdin(::Function, ::Any)\n"
"Base.readchomp\n"
"Base.truncate\n"
"Base.skipchars\n"
"Base.countlines\n"
"Base.PipeBuffer\n"
"Base.readavailable\n"
"Base.IOContext\n"
"Base.IOContext(::IO, ::Pair)\n"
"Base.IOContext(::IO, ::IOContext)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/io-network.md:57
#, no-wrap
msgid ""
"Base.show(::Any)\n"
"Base.summary\n"
"Base.print\n"
"Base.println\n"
"Base.printstyled\n"
"Base.sprint\n"
"Base.showerror\n"
"Base.dump\n"
"Meta.@dump\n"
"Base.readline\n"
"Base.readuntil\n"
"Base.readlines\n"
"Base.eachline\n"
"Base.displaysize\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/io-network.md:74
#, no-wrap
msgid "Multimedia I/O"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/io-network.md:79
msgid ""
"Just as text output is performed by [`print`](@ref) and user-defined types can indicate their textual representation by overloading [`show`]"
"(@ref), Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), "
"consisting of three parts:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/io-network.md:86
msgid "A function [`display(x)`](@ref) to request the richest available multimedia display of a Julia object `x` (with a plain-text fallback)."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/io-network.md:86
msgid ""
"Overloading [`show`](@ref) allows one to indicate arbitrary multimedia representations (keyed by standard MIME types) of user-defined types."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/io-network.md:86
msgid ""
"Multimedia-capable display backends may be registered by subclassing a generic [`AbstractDisplay`](@ref) type and pushing them onto a stack "
"of display backends via [`pushdisplay`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/io-network.md:90
msgid ""
"The base Julia runtime provides only plain-text display, but richer displays may be enabled by loading external modules or by using "
"graphical Julia environments (such as the IPython-based IJulia notebook)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/io-network.md:91
#, no-wrap
msgid ""
"Base.AbstractDisplay\n"
"Base.Multimedia.display\n"
"Base.Multimedia.redisplay\n"
"Base.Multimedia.displayable\n"
"Base.show(::Any, ::Any, ::Any)\n"
"Base.Multimedia.showable\n"
"Base.repr(::MIME, ::Any)\n"
"Base.MIME\n"
"Base.@MIME_str\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/io-network.md:106
msgid ""
"As mentioned above, one can also define new display backends. For example, a module that can display PNG images in a window can register "
"this capability with Julia, so that calling [`display(x)`](@ref) on types with PNG representations will automatically display the image "
"using the module's window."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/io-network.md:121
msgid ""
"In order to define a new display backend, one should first create a subtype `D` of the abstract class [`AbstractDisplay`](@ref).  Then, for "
"each MIME type (`mime` string) that can be displayed on `D`, one should define a function `display(d::D, ::MIME\"mime\", x) = ...` that "
"displays `x` as that MIME type, usually by calling [`show(io, mime, x)`](@ref) or [`repr(io, mime, x)`](@ref).  A [`MethodError`](@ref) "
"should be thrown if `x` cannot be displayed as that MIME type; this is automatic if one calls `show` or `repr`. Finally, one should define a "
"function `display(d::D, x)` that queries [`showable(mime, x)`](@ref) for the `mime` types supported by `D` and displays the \"best\" one; a "
"`MethodError` should be thrown if no supported MIME types are found for `x`.  Similarly, some subtypes may wish to override [`redisplay(d::"
"D, ...)`](@ref Base.Multimedia.redisplay). (Again, one should `import Base.display` to add new methods to `display`.) The return values of "
"these functions are up to the implementation (since in some cases it may be useful to return a display \"handle\" of some type).  The "
"display functions for `D` can then be called directly, but they can also be invoked automatically from [`display(x)`](@ref) simply by "
"pushing a new display onto the display-backend stack with:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/io-network.md:122
#, no-wrap
msgid ""
"Base.Multimedia.pushdisplay\n"
"Base.Multimedia.popdisplay\n"
"Base.Multimedia.TextDisplay\n"
"Base.Multimedia.istextmime\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/base/io-network.md:129
#, no-wrap
msgid "Network I/O"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/io-network.md:131
#, no-wrap
msgid ""
"Base.bytesavailable\n"
"Base.ntoh\n"
"Base.hton\n"
"Base.ltoh\n"
"Base.htol\n"
"Base.ENDIAN_BOM\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/constants.md:1
#, no-wrap
msgid "[Constants](@id lib-constants)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/constants.md:3
#, no-wrap
msgid ""
"Core.nothing\n"
"Base.PROGRAM_FILE\n"
"Base.ARGS\n"
"Base.C_NULL\n"
"Base.VERSION\n"
"Base.DEPOT_PATH\n"
"Base.LOAD_PATH\n"
"Base.Sys.BINDIR\n"
"Base.Sys.CPU_THREADS\n"
"Base.Sys.WORD_SIZE\n"
"Base.Sys.KERNEL\n"
"Base.Sys.ARCH\n"
"Base.Sys.MACHINE\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/constants.md:20
msgid "See also:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/constants.md:28
msgid "[`stdin`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/constants.md:28
msgid "[`stdout`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/constants.md:28
msgid "[`stderr`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/constants.md:28
msgid "[`ENV`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/constants.md:28
msgid "[`ENDIAN_BOM`](@ref)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/constants.md:28
msgid "`Libc.MS_ASYNC`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/constants.md:28
msgid "`Libc.MS_INVALIDATE`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/base/constants.md:28
msgid "`Libc.MS_SYNC`"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/c.md:1
#, no-wrap
msgid "C Interface"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/c.md:3
#, no-wrap
msgid ""
"ccall\n"
"Core.Intrinsics.cglobal\n"
"Base.@cfunction\n"
"Base.CFunction\n"
"Base.unsafe_convert\n"
"Base.cconvert\n"
"Base.unsafe_load\n"
"Base.unsafe_store!\n"
"Base.unsafe_copyto!{T}(::Ptr{T}, ::Ptr{T}, ::Any)\n"
"Base.unsafe_copyto!{T}(::Array{T}, ::Any, ::Array{T}, ::Any, ::Any)\n"
"Base.copyto!\n"
"Base.pointer\n"
"Base.unsafe_wrap{T,N}(::Union{Type{Array},Type{Array{T}},Type{Array{T,N}}}, ::Ptr{T}, ::NTuple{N,Int})\n"
"Base.pointer_from_objref\n"
"Base.unsafe_pointer_to_objref\n"
"Base.disable_sigint\n"
"Base.reenable_sigint\n"
"Base.systemerror\n"
"Core.Ptr\n"
"Core.Ref\n"
"Base.Cchar\n"
"Base.Cuchar\n"
"Base.Cshort\n"
"Base.Cstring\n"
"Base.Cushort\n"
"Base.Cint\n"
"Base.Cuint\n"
"Base.Clong\n"
"Base.Culong\n"
"Base.Clonglong\n"
"Base.Culonglong\n"
"Base.Cintmax_t\n"
"Base.Cuintmax_t\n"
"Base.Csize_t\n"
"Base.Cssize_t\n"
"Base.Cptrdiff_t\n"
"Base.Cwchar_t\n"
"Base.Cwstring\n"
"Base.Cfloat\n"
"Base.Cdouble\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/c.md:46
#, no-wrap
msgid "LLVM Interface"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/c.md:48
#, no-wrap
msgid "Core.Intrinsics.llvmcall\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/base/simd-types.md:1
#, no-wrap
msgid "SIMD Support"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/simd-types.md:5
msgid ""
"Type `VecElement{T}` is intended for building libraries of SIMD operations. Practical use of it requires using `llvmcall`. The type is "
"defined as:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/simd-types.md:6
#, no-wrap
msgid ""
"struct VecElement{T}\n"
"    value::T\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/simd-types.md:14
msgid ""
"It has a special compilation rule: a homogeneous tuple of `VecElement{T}` maps to an LLVM `vector` type when `T` is a primitive bits type "
"and the tuple length is in the set {2-6,8-10,16}."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/simd-types.md:18
msgid ""
"At `-O3`, the compiler *might* automatically vectorize operations on such tuples. For example, the following program, when compiled with "
"`julia -O3` generates two SIMD addition instructions (`addps`) on x86 systems:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/simd-types.md:19
#, no-wrap
msgid ""
"const m128 = NTuple{4,VecElement{Float32}}\n"
"\n"
"function add(a::m128, b::m128)\n"
"    (VecElement(a[1].value+b[1].value),\n"
"     VecElement(a[2].value+b[2].value),\n"
"     VecElement(a[3].value+b[3].value),\n"
"     VecElement(a[4].value+b[4].value))\n"
"end\n"
"\n"
"triple(c::m128) = add(add(c,c),c)\n"
"\n"
"code_native(triple,(m128,))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/base/simd-types.md:35
msgid "However, since the automatic vectorization cannot be relied upon, future use will mostly be via libraries that use `llvmcall`."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/DelimitedFiles.md:1
#, no-wrap
msgid "Delimited Files"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/DelimitedFiles.md:3
#, no-wrap
msgid ""
"DelimitedFiles.readdlm(::Any, ::AbstractChar, ::Type, ::AbstractChar)\n"
"DelimitedFiles.readdlm(::Any, ::AbstractChar, ::AbstractChar)\n"
"DelimitedFiles.readdlm(::Any, ::AbstractChar, ::Type)\n"
"DelimitedFiles.readdlm(::Any, ::AbstractChar)\n"
"DelimitedFiles.readdlm(::Any, ::Type)\n"
"DelimitedFiles.readdlm(::Any)\n"
"DelimitedFiles.writedlm\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Printf.md:1
#, no-wrap
msgid "Printf"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Printf.md:3
#, no-wrap
msgid ""
"Printf.@printf\n"
"Printf.@sprintf\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Mmap.md:1
#, no-wrap
msgid "Memory-mapped I/O"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Mmap.md:3
#, no-wrap
msgid ""
"Mmap.Anonymous\n"
"Mmap.mmap\n"
"Mmap.sync!\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Markdown.md:1
#, no-wrap
msgid "Markdown"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:5
msgid ""
"This section describes Julia's markdown syntax, which is enabled by the Markdown standard library. The following Markdown elements are "
"supported:"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Markdown.md:6
#, no-wrap
msgid "Inline elements"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:10
msgid "Here \"inline\" refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:11
#, no-wrap
msgid "Bold"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:15
msgid "Surround words with two asterisks, `**`, to display the enclosed text in boldface."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:16
#, no-wrap
msgid "A paragraph containing a **bold** word.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:20
#, no-wrap
msgid "Italics"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:24
msgid "Surround words with one asterisk, `*`, to display the enclosed text in italics."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:25
#, no-wrap
msgid "A paragraph containing an *emphasized* word.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:29
#, no-wrap
msgid "Literals"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:33
msgid "Surround text that should be displayed exactly as written with single backticks, ``` ` ``` ."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:34
#, no-wrap
msgid "A paragraph containing a `literal` word.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:40
msgid "Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia program."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:44
#, no-wrap
msgid ""
"!!! tip\n"
"    To include a backtick character within literal text use three backticks rather than one to enclose\n"
"    the text.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:48
#, no-wrap
msgid ""
"    ```\n"
"    A paragraph containing a ``` `backtick` character ```.\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:50
#, no-wrap
msgid "    By extension any odd number of backticks may be used to enclose a lesser number of backticks.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:51
#, no-wrap
msgid "``\\LaTeX``"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:55
msgid "Surround text that should be displayed as mathematics using ``\\LaTeX`` syntax with double backticks, ``` `` ``` ."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:56
#, no-wrap
msgid "A paragraph containing some ``\\LaTeX`` markup.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:64
#, no-wrap
msgid ""
"!!! tip\n"
"    As with literals in the previous section, if literal backticks need to be written within double\n"
"    backticks use an even number greater than two. Note that if a single literal backtick needs to\n"
"    be included within ``\\LaTeX`` markup then two enclosing backticks is sufficient.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:73
#, no-wrap
msgid ""
"!!! note\n"
"    The `\\` character should be escaped appropriately if the text is embedded in a Julia source code,\n"
"    for example, ``` \"``\\\\LaTeX`` syntax in a docstring.\" ```, since it is interpreted as a string\n"
"    literal. Alternatively, in order to avoid escaping, it is possible to use the `raw` string macro\n"
"    together with the `@doc` macro:\n"
"    ```\n"
"    @doc raw\"``\\LaTeX`` syntax in a docstring.\" functionname\n"
"    ```\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:74
#, no-wrap
msgid "Links"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:79
msgid ""
"Links to either external or internal addresses can be written using the following syntax, where the text enclosed in square brackets, `[ ]`, "
"is the name of the link and the text enclosed in parentheses, `( )`, is the URL."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:80
#, no-wrap
msgid "A paragraph containing a link to [Julia](http://www.julialang.org).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:87
msgid ""
"It's also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For "
"example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:88
#, no-wrap
msgid ""
"\"\"\"\n"
"    tryparse(type, str; base)\n"
"\n"
"Like [`parse`](@ref), but returns either a value of the requested type,\n"
"or [`nothing`](@ref) if the string does not contain a valid number.\n"
"\"\"\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:102
msgid ""
"This will create a link in the generated docs to the [`parse`](@ref)  documentation (which has more information about what this function "
"actually does), and to the [`nothing`](@ref) documentation. It's good to include cross references to mutating/non-mutating versions of a "
"function, or to highlight a difference between two similar-seeming functions."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:107
#, no-wrap
msgid ""
"!!! note\n"
"    The above cross referencing is *not* a Markdown feature, and relies on\n"
"    [Documenter.jl](https://github.com/JuliaDocs/Documenter.jl), which is\n"
"    used to build base Julia's documentation.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:108
#, no-wrap
msgid "Footnote references"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:113
msgid ""
"Named and numbered footnote references can be written using the following syntax. A footnote name must be a single alphanumeric word "
"containing no punctuation."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:114
#, no-wrap
msgid "A paragraph containing a numbered footnote [^1] and a named one [^named].\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:122
#, no-wrap
msgid ""
"!!! note\n"
"    The text associated with a footnote can be written anywhere within the same page as the footnote\n"
"    reference. The syntax used to define the footnote text is discussed in the [Footnotes](@ref) section\n"
"    below.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Markdown.md:123
#, no-wrap
msgid "Toplevel elements"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:127
msgid "The following elements can be written either at the \"toplevel\" of a document or within another \"toplevel\" element."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:128
#, no-wrap
msgid "Paragraphs"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:133
msgid ""
"A paragraph is a block of plain text, possibly containing any number of inline elements defined in the [Inline elements](@ref) section "
"above, with one or more blank lines above and below it."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:134
#, no-wrap
msgid ""
"This is a paragraph.\n"
"\n"
"And this is *another* one containing some emphasized text.\n"
"A new line, but still part of the same paragraph.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:141
#, no-wrap
msgid "Headers"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:145
msgid "A document can be split up into different sections using headers. Headers use the following syntax:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:146
#, no-wrap
msgid ""
"# Level One\n"
"## Level Two\n"
"### Level Three\n"
"#### Level Four\n"
"##### Level Five\n"
"###### Level Six\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:157
msgid "A header line can contain any inline syntax in the same way as a paragraph can."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:162
#, no-wrap
msgid ""
"!!! tip\n"
"    Try to avoid using too many levels of header within a single document. A heavily nested document\n"
"    may be indicative of a need to restructure it or split it into several pages covering separate\n"
"    topics.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:163
#, no-wrap
msgid "[ã³ã¼ããã­ãã¯](@id Code-blocks)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:167
msgid "Source code can be displayed as a literal block using an indent of four spaces as shown in the following example."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:168
#, no-wrap
msgid ""
"This is a paragraph.\n"
"\n"
"    function func(x)\n"
"        # ...\n"
"    end\n"
"\n"
"Another paragraph.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:180
msgid ""
"Additionally, code blocks can be enclosed using triple backticks with an optional \"language\" to specify how a block of code should be "
"highlighted."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:181
#, no-wrap
msgid ""
"A code block without a \"language\":\n"
"\n"
"```\n"
"function func(x)\n"
"    # ...\n"
"end\n"
"```\n"
"\n"
"and another one with the \"language\" specified as `julia`:\n"
"\n"
"```julia\n"
"function func(x)\n"
"    # ...\n"
"end\n"
"```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:202
#, no-wrap
msgid ""
"!!! note\n"
"    \"Fenced\" code blocks, as shown in the last example, should be preferred over indented code blocks\n"
"    since there is no way to specify what language an indented code block is written in.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:203
#, no-wrap
msgid "Block quotes"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:207
#, no-wrap
msgid ""
"Text from external sources, such as quotations from books or websites, can be quoted using `>`\n"
"characters prepended to each line of the quote as follows.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:208
#, no-wrap
msgid ""
"Here's a quote:\n"
"\n"
"> Julia is a high-level, high-performance dynamic programming language for\n"
"> technical computing, with syntax that is familiar to users of other\n"
"> technical computing environments.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:218
#, no-wrap
msgid ""
"Note that a single space must appear after the `>` character on each line. Quoted blocks may themselves\n"
"contain other toplevel or inline elements.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:219
#, no-wrap
msgid "Images"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:224
msgid ""
"The syntax for images is similar to the link syntax mentioned above. Prepending a `!` character to a link will display an image from the "
"specified URL rather than a link to it."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:225
#, no-wrap
msgid "![alternative text](link/to/image.png)\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:229
#, no-wrap
msgid "Lists"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:233
msgid "Unordered lists can be written by prepending each item in a list with either `*`, `+`, or `-`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:234
#, no-wrap
msgid ""
"A list of items:\n"
"\n"
"  * item one\n"
"  * item two\n"
"  * item three\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:243
msgid "Note the two spaces before each `*` and the single space after each one."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:247
msgid ""
"Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should be left between each list "
"item when including any toplevel elements within a list."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:248
#, no-wrap
msgid ""
"Another list:\n"
"\n"
"  * item one\n"
"\n"
"  * item two\n"
"\n"
"    ```\n"
"    f(x) = x\n"
"    ```\n"
"\n"
"  * And a sublist:\n"
"\n"
"      + sub-item one\n"
"      + sub-item two\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:268
#, no-wrap
msgid ""
"!!! note\n"
"    The contents of each item in the list must line up with the first line of the item. In the above\n"
"    example the fenced code block must be indented by four spaces to align with the `i` in `item two`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:271
msgid ""
"Ordered lists are written by replacing the \"bullet\" character, either `*`, `+`, or `-`, with a positive integer followed by either `.` or "
"`)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:272
#, no-wrap
msgid ""
"Two ordered lists:\n"
"\n"
" 1. item one\n"
" 2. item two\n"
" 3. item three\n"
"\n"
" 5) item five\n"
" 6) item six\n"
" 7) item seven\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:287
msgid ""
"An ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with "
"unordered lists, ordered lists can contain nested toplevel elements."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:288
#, no-wrap
msgid "Display equations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:293
msgid ""
"Large ``\\LaTeX`` equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the "
"\"language\" `math` as in the example below."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:294
#, no-wrap
msgid ""
"```math\n"
"f(a) = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} (\\alpha+R\\cos(\\theta))d\\theta\n"
"```\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:300
#, no-wrap
msgid "Footnotes"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:304
msgid "This syntax is paired with the inline syntax for [Footnote references](@ref). Make sure to read that section as well."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:308
msgid ""
"Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from the `:` character that is "
"appended to the footnote label."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:309
#, no-wrap
msgid ""
"[^1]: Numbered footnote text.\n"
"\n"
"[^note]:\n"
"\n"
"    Named footnote text containing several toplevel elements.\n"
"\n"
"      * item one\n"
"      * item two\n"
"      * item three\n"
"\n"
"    ```julia\n"
"    function func(x)\n"
"        # ...\n"
"    end\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:329
#, no-wrap
msgid ""
"!!! note\n"
"    No checks are done during parsing to make sure that all footnote references have matching footnotes.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:330
#, no-wrap
msgid "Horizontal rules"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:333
#, no-wrap
msgid "The equivalent of an `<hr>` HTML tag can be written using the following syntax:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:334
#, no-wrap
msgid ""
"Text above the line.\n"
"\n"
"---\n"
"\n"
"And text below the line.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:342
#, no-wrap
msgid "Tables"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:349
msgid ""
"Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested "
"toplevel elements unlike other elements discussed above â only inline elements are allowed. Tables must always contain a header row with "
"column names. Cells cannot span multiple rows or columns of the table."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:350
#, no-wrap
msgid ""
"| Column One | Column Two | Column Three |\n"
"|:---------- | ---------- |:------------:|\n"
"| Row `1`    | Column `2` |              |\n"
"| *Row* 2    | **Row** 2  | Column ``3`` |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:359
#, no-wrap
msgid ""
"!!! note\n"
"    As illustrated in the above example each column of `|` characters must be aligned vertically.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:363
#, no-wrap
msgid ""
"    A `:` character on either end of a column's header separator (the row containing `-` characters)\n"
"    specifies whether the row is left-aligned, right-aligned, or (when `:` appears on both ends) center-aligned.\n"
"    Providing no `:` characters will default to right-aligning the column.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Markdown.md:364
#, no-wrap
msgid "Admonitions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:368
msgid ""
"Specially formatted blocks, known as admonitions, can be used to highlight particular remarks.  They can be defined using the following `!!!"
"` syntax:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:369
#, no-wrap
msgid ""
"!!! note\n"
"\n"
"    This is the content of the note.\n"
"\n"
"!!! warning \"Beware!\"\n"
"\n"
"    And this is another one.\n"
"\n"
"    This warning admonition has a custom title: `\"Beware!\"`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:384
msgid ""
"The type of the admonition can be any word, but some types produce special styling, namely (in order of decreasing severity): `danger`, "
"`warning`, `info`/`note`, and `tip`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:389
msgid ""
"A custom title for the box can be provided as a string (in double quotes)  after the admonition type.  If no title text is specified after "
"the admonition type, then the title used will be the type of the block, i.e. `\"Note\"` in the case of the `note` admonition."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:392
msgid "Admonitions, like most other toplevel elements, can contain other toplevel elements."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Markdown.md:393
#, no-wrap
msgid "Markdown Syntax Extensions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:402
msgid ""
"Julia's markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object "
"itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual `show` methods will "
"be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as "
"references) without cluttering the basic syntax."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Markdown.md:405
msgid ""
"In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be "
"used, but this should generally be unnecessary."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/CRC32c.md:1
#, no-wrap
msgid "CRC32c"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/CRC32c.md:3
#, no-wrap
msgid ""
"CRC32c.crc32c\n"
"CRC32c.crc32c(::IO, ::Integer, ::UInt32)\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Profile.md:1
#, no-wrap
msgid "[Profiling](@id lib-profiling)"
msgstr "[ãã­ãã¡ã¤ãªã³ã°](@id lib-profiling)"

#. type: Plain text
#: ext/julia/doc/src/stdlib/Profile.md:3
#, no-wrap
msgid "Profile.@profile\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Profile.md:9
msgid "The methods in `Profile` are not exported and need to be called e.g. as `Profile.print()`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Profile.md:10
#, no-wrap
msgid ""
"Profile.clear\n"
"Profile.print\n"
"Profile.init\n"
"Profile.fetch\n"
"Profile.retrieve\n"
"Profile.callers\n"
"Profile.clear_malloc_data\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Unicode.md:1
#, no-wrap
msgid "Unicode"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Unicode.md:3
#, no-wrap
msgid ""
"Unicode.isassigned\n"
"Unicode.normalize\n"
"Unicode.graphemes\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/SHA.md:1
#, no-wrap
msgid "SHA"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SHA.md:5
msgid "Usage is very straightforward:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SHA.md:5
#, no-wrap
msgid ""
"julia> using SHA\n"
"\n"
"julia> bytes2hex(sha256(\"test\"))\n"
"\"9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SHA.md:16
msgid ""
"Each exported function (at the time of this writing, SHA-1, SHA-2 224, 256, 384 and 512, and SHA-3 224, 256, 384 and 512 functions are "
"implemented)  takes in either an `Array{UInt8}`, a `ByteString` or an `IO` object.  This makes it trivial to checksum a file:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SHA.md:17
#, no-wrap
msgid ""
"shell> cat /tmp/test.txt\n"
"test\n"
"julia> using SHA\n"
"\n"
"julia> open(\"/tmp/test.txt\") do f\n"
"           sha2_256(f)\n"
"       end\n"
"32-element Array{UInt8,1}:\n"
" 0x9f\n"
" 0x86\n"
" 0xd0\n"
" 0x81\n"
" 0x88\n"
" 0x4c\n"
" 0x7d\n"
" 0x65\n"
"    â®\n"
" 0x5d\n"
" 0x6c\n"
" 0x15\n"
" 0xb0\n"
" 0xf0\n"
" 0x0a\n"
" 0x08\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SHA.md:45
#, no-wrap
msgid "Note the lack of a newline at the end of `/tmp/text.txt`.  Julia automatically inserts a newline before the `julia>` prompt.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SHA.md:50
msgid ""
"Due to the colloquial usage of `sha256` to refer to `sha2_256`, convenience functions are provided, mapping `shaxxx()` function calls to "
"`sha2_xxx()`.  For SHA-3, no such colloquialisms exist and the user must use the full `sha3_xxx()` names."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SHA.md:53
msgid "`shaxxx()` takes `AbstractString` and array-like objects (`NTuple` and `Array`) with elements of type `UInt8`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SHA.md:55
msgid "Note that, at the time of this writing, the SHA3 code is not optimized, and as such is roughly an order of magnitude slower than SHA2."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/LibGit2.md:1
#, no-wrap
msgid "LibGit2"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LibGit2.md:8
msgid ""
"The LibGit2 module provides bindings to [libgit2](https://libgit2.org/), a portable C library that implements core functionality for the "
"[Git](https://git-scm.com/) version control system.  These bindings are currently used to power Julia's package manager.  It is expected "
"that this module will eventually be moved into a separate package."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/LibGit2.md:9
#, no-wrap
msgid "Functionality"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LibGit2.md:15
msgid ""
"Some of this documentation assumes some prior knowledge of the libgit2 API.  For more information on some of the objects and methods "
"referenced here, consult the upstream [libgit2 API reference](https://libgit2.org/libgit2/#v0.25.1)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LibGit2.md:16
#, no-wrap
msgid ""
"LibGit2.Buffer\n"
"LibGit2.CheckoutOptions\n"
"LibGit2.CloneOptions\n"
"LibGit2.DescribeOptions\n"
"LibGit2.DescribeFormatOptions\n"
"LibGit2.DiffDelta\n"
"LibGit2.DiffFile\n"
"LibGit2.DiffOptionsStruct\n"
"LibGit2.FetchHead\n"
"LibGit2.FetchOptions\n"
"LibGit2.GitAnnotated\n"
"LibGit2.GitBlame\n"
"LibGit2.GitBlob\n"
"LibGit2.GitCommit\n"
"LibGit2.GitHash\n"
"LibGit2.GitObject\n"
"LibGit2.GitRemote\n"
"LibGit2.GitRemoteAnon\n"
"LibGit2.GitRepo\n"
"LibGit2.GitRepoExt\n"
"LibGit2.GitRevWalker\n"
"LibGit2.GitShortHash\n"
"LibGit2.GitSignature\n"
"LibGit2.GitStatus\n"
"LibGit2.GitTag\n"
"LibGit2.GitTree\n"
"LibGit2.IndexEntry\n"
"LibGit2.IndexTime\n"
"LibGit2.BlameOptions\n"
"LibGit2.MergeOptions\n"
"LibGit2.ProxyOptions\n"
"LibGit2.PushOptions\n"
"LibGit2.RebaseOperation\n"
"LibGit2.RebaseOptions\n"
"LibGit2.RemoteCallbacks\n"
"LibGit2.SignatureStruct\n"
"LibGit2.StatusEntry\n"
"LibGit2.StatusOptions\n"
"LibGit2.StrArrayStruct\n"
"LibGit2.TimeStruct\n"
"LibGit2.add!\n"
"LibGit2.add_fetch!\n"
"LibGit2.add_push!\n"
"LibGit2.addblob!\n"
"LibGit2.author\n"
"LibGit2.authors\n"
"LibGit2.branch\n"
"LibGit2.branch!\n"
"LibGit2.checkout!\n"
"LibGit2.clone\n"
"LibGit2.commit\n"
"LibGit2.committer\n"
"LibGit2.count\n"
"LibGit2.counthunks\n"
"LibGit2.create_branch\n"
"LibGit2.credentials_callback\n"
"LibGit2.credentials_cb\n"
"LibGit2.default_signature\n"
"LibGit2.delete_branch\n"
"LibGit2.diff_files\n"
"LibGit2.entryid\n"
"LibGit2.entrytype\n"
"LibGit2.fetch\n"
"LibGit2.fetchheads\n"
"LibGit2.fetch_refspecs\n"
"LibGit2.fetchhead_foreach_cb\n"
"LibGit2.merge_base\n"
"LibGit2.merge!(::LibGit2.GitRepo; ::Any...)\n"
"LibGit2.merge!(::LibGit2.GitRepo, ::Vector{LibGit2.GitAnnotated}; ::LibGit2.MergeOptions, ::LibGit2.CheckoutOptions)\n"
"LibGit2.merge!(::LibGit2.GitRepo, ::Vector{LibGit2.GitAnnotated}, ::Bool; ::LibGit2.MergeOptions, ::LibGit2.CheckoutOptions)\n"
"LibGit2.ffmerge!\n"
"LibGit2.fullname\n"
"LibGit2.features\n"
"LibGit2.filename\n"
"LibGit2.filemode\n"
"LibGit2.gitdir\n"
"LibGit2.git_url\n"
"LibGit2.@githash_str\n"
"LibGit2.head\n"
"LibGit2.head!\n"
"LibGit2.head_oid\n"
"LibGit2.headname\n"
"LibGit2.init\n"
"LibGit2.is_ancestor_of\n"
"LibGit2.isbinary\n"
"LibGit2.iscommit\n"
"LibGit2.isdiff\n"
"LibGit2.isdirty\n"
"LibGit2.isorphan\n"
"LibGit2.isset\n"
"LibGit2.iszero\n"
"LibGit2.lookup_branch\n"
"LibGit2.map\n"
"LibGit2.mirror_callback\n"
"LibGit2.mirror_cb\n"
"LibGit2.message\n"
"LibGit2.merge_analysis\n"
"LibGit2.name\n"
"LibGit2.need_update\n"
"LibGit2.objtype\n"
"LibGit2.path\n"
"LibGit2.peel\n"
"LibGit2.posixpath\n"
"LibGit2.push\n"
"LibGit2.push!(::LibGit2.GitRevWalker, ::LibGit2.GitHash)\n"
"LibGit2.push_head!\n"
"LibGit2.push_refspecs\n"
"LibGit2.raw\n"
"LibGit2.read_tree!\n"
"LibGit2.rebase!\n"
"LibGit2.ref_list\n"
"LibGit2.reftype\n"
"LibGit2.remotes\n"
"LibGit2.remove!\n"
"LibGit2.reset\n"
"LibGit2.reset!\n"
"LibGit2.restore\n"
"LibGit2.revcount\n"
"LibGit2.set_remote_url\n"
"LibGit2.shortname\n"
"LibGit2.snapshot\n"
"LibGit2.split_cfg_entry\n"
"LibGit2.status\n"
"LibGit2.stage\n"
"LibGit2.tag_create\n"
"LibGit2.tag_delete\n"
"LibGit2.tag_list\n"
"LibGit2.target\n"
"LibGit2.toggle\n"
"LibGit2.transact\n"
"LibGit2.treewalk\n"
"LibGit2.upstream\n"
"LibGit2.update!\n"
"LibGit2.url\n"
"LibGit2.version\n"
"LibGit2.with\n"
"LibGit2.with_warn\n"
"LibGit2.workdir\n"
"LibGit2.GitObject(::LibGit2.GitTreeEntry)\n"
"LibGit2.UserPasswordCredential\n"
"LibGit2.SSHCredential\n"
"LibGit2.isfilled\n"
"LibGit2.CachedCredentials\n"
"LibGit2.CredentialPayload\n"
"LibGit2.approve\n"
"LibGit2.reject\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/UUIDs.md:1
#, no-wrap
msgid "UUIDs"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/UUIDs.md:3
#, no-wrap
msgid ""
"UUIDs.uuid1\n"
"UUIDs.uuid4\n"
"UUIDs.uuid5\n"
"UUIDs.uuid_version\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Serialization.md:1
#, no-wrap
msgid "Serialization"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Serialization.md:3
#, no-wrap
msgid ""
"Serialization.serialize\n"
"Serialization.deserialize\n"
"Serialization.writeheader\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Statistics.md:4
msgid "The Statistics module contains basic statistics functionality."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Statistics.md:5
#, no-wrap
msgid ""
"Statistics.std\n"
"Statistics.stdm\n"
"Statistics.var\n"
"Statistics.varm\n"
"Statistics.cor\n"
"Statistics.cov\n"
"Statistics.mean!\n"
"Statistics.mean\n"
"Statistics.median!\n"
"Statistics.median\n"
"Statistics.middle\n"
"Statistics.quantile!\n"
"Statistics.quantile\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Base64.md:1
#, no-wrap
msgid "Base64"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Base64.md:3
#, no-wrap
msgid ""
"Base64.Base64\n"
"Base64.Base64EncodePipe\n"
"Base64.base64encode\n"
"Base64.Base64DecodePipe\n"
"Base64.base64decode\n"
"Base64.stringmime\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Distributed.md:1
#, no-wrap
msgid "Distributed Computing"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Distributed.md:3
#, no-wrap
msgid ""
"Distributed.addprocs\n"
"Distributed.nprocs\n"
"Distributed.nworkers\n"
"Distributed.procs()\n"
"Distributed.procs(::Integer)\n"
"Distributed.workers\n"
"Distributed.rmprocs\n"
"Distributed.interrupt\n"
"Distributed.myid\n"
"Distributed.pmap\n"
"Distributed.RemoteException\n"
"Distributed.Future\n"
"Distributed.RemoteChannel\n"
"Distributed.fetch(::Distributed.Future)\n"
"Distributed.fetch(::RemoteChannel)\n"
"Distributed.remotecall(::Any, ::Integer, ::Any...)\n"
"Distributed.remotecall_wait(::Any, ::Integer, ::Any...)\n"
"Distributed.remotecall_fetch(::Any, ::Integer, ::Any...)\n"
"Distributed.remote_do(::Any, ::Integer, ::Any...)\n"
"Distributed.put!(::RemoteChannel, ::Any...)\n"
"Distributed.put!(::Distributed.Future, ::Any)\n"
"Distributed.take!(::RemoteChannel, ::Any...)\n"
"Distributed.isready(::RemoteChannel, ::Any...)\n"
"Distributed.isready(::Distributed.Future)\n"
"Distributed.AbstractWorkerPool\n"
"Distributed.WorkerPool\n"
"Distributed.CachingPool\n"
"Distributed.default_worker_pool\n"
"Distributed.clear!(::CachingPool)\n"
"Distributed.remote\n"
"Distributed.remotecall(::Any, ::AbstractWorkerPool, ::Any...)\n"
"Distributed.remotecall_wait(::Any, ::AbstractWorkerPool, ::Any...)\n"
"Distributed.remotecall_fetch(::Any, ::AbstractWorkerPool, ::Any...)\n"
"Distributed.remote_do(::Any, ::AbstractWorkerPool, ::Any...)\n"
"Distributed.@spawnat\n"
"Distributed.@fetch\n"
"Distributed.@fetchfrom\n"
"Distributed.@distributed\n"
"Distributed.@everywhere\n"
"Distributed.clear!(::Any, ::Any; ::Any)\n"
"Distributed.remoteref_id\n"
"Distributed.channel_from_id\n"
"Distributed.worker_id_from_socket\n"
"Distributed.cluster_cookie()\n"
"Distributed.cluster_cookie(::Any)\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Distributed.md:51
#, no-wrap
msgid "Cluster Manager Interface"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Distributed.md:59
msgid ""
"This interface provides a mechanism to launch and manage Julia workers on different cluster environments.  There are two types of managers "
"present in Base: `LocalManager`, for launching additional workers on the same host, and `SSHManager`, for launching on remote hosts via "
"`ssh`. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a "
"different transport."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Distributed.md:60
#, no-wrap
msgid ""
"Distributed.ClusterManager\n"
"Distributed.WorkerConfig\n"
"Distributed.launch\n"
"Distributed.manage\n"
"Distributed.kill(::ClusterManager, ::Int, ::WorkerConfig)\n"
"Distributed.connect(::ClusterManager, ::Int, ::WorkerConfig)\n"
"Distributed.init_worker\n"
"Distributed.start_worker\n"
"Distributed.process_messages\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Random.md:1
#, no-wrap
msgid "Random Numbers"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/stdlib/Random.md:3 ext/julia/doc/src/stdlib/Random.md:402 ext/julia/doc/src/stdlib/SparseArrays.md:3
#: ext/julia/doc/src/stdlib/SparseArrays.md:243 ext/julia/doc/src/stdlib/Pkg.md:1 ext/julia/doc/src/stdlib/LinearAlgebra.md:3
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:689 ext/julia/doc/src/stdlib/Test.md:3 ext/julia/doc/src/stdlib/Test.md:279
#: ext/julia/doc/src/stdlib/Dates.md:3 ext/julia/doc/src/stdlib/Dates.md:874 ext/julia/doc/src/devdocs/cartesian.md:55
#: ext/julia/doc/src/devdocs/cartesian.md:66 ext/julia/doc/src/devdocs/subarrays.md:14 ext/julia/doc/src/devdocs/subarrays.md:31
#, no-wrap
msgid "@meta"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:3
#, no-wrap
msgid "DocTestSetup = :(using Random)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:14
msgid ""
"Random number generation in Julia uses the [Mersenne Twister library](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/#dSFMT)  via "
"`MersenneTwister` objects. Julia has a global RNG, which is used by default. Other RNG types can be plugged in by inheriting the "
"`AbstractRNG` type; they can then be used to have multiple streams of random numbers. Besides `MersenneTwister`, Julia also provides the "
"`RandomDevice` RNG type, which is a wrapper over the OS provided entropy."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:20
msgid ""
"Most functions related to random generation accept an optional `AbstractRNG` object as first argument, which defaults to the global one if "
"not provided. Moreover, some of them accept optionally dimension specifications `dims...` (which can be given as a tuple) to generate arrays "
"of random values."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:30
msgid ""
"A `MersenneTwister` or `RandomDevice` RNG can generate uniformly random numbers of the following types: [`Float16`](@ref), [`Float32`]"
"(@ref), [`Float64`](@ref), [`BigFloat`](@ref), [`Bool`](@ref), [`Int8`](@ref), [`UInt8`](@ref), [`Int16`](@ref), [`UInt16`](@ref), [`Int32`]"
"(@ref), [`UInt32`](@ref), [`Int64`](@ref), [`UInt64`](@ref), [`Int128`](@ref), [`UInt128`](@ref), [`BigInt`](@ref) (or complex numbers of "
"those types).  Random floating point numbers are generated uniformly in ``[0, 1)``. As `BigInt` represents unbounded integers, the interval "
"must be specified (e.g. `rand(big.(1:6))`)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:34
msgid ""
"Additionally, normal and exponential distributions are implemented for some `AbstractFloat` and `Complex` types, see [`randn`](@ref) and "
"[`randexp`](@ref) for details."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Random.md:35
#, no-wrap
msgid "Random numbers module"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:36
#, no-wrap
msgid "Random.Random\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Random.md:40
#, no-wrap
msgid "Random generation functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:42
#, no-wrap
msgid ""
"Random.rand\n"
"Random.rand!\n"
"Random.bitrand\n"
"Random.randn\n"
"Random.randn!\n"
"Random.randexp\n"
"Random.randexp!\n"
"Random.randstring\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Random.md:53
#, no-wrap
msgid "Subsequences, permutations and shuffling"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:55
#, no-wrap
msgid ""
"Random.randsubseq\n"
"Random.randsubseq!\n"
"Random.randperm\n"
"Random.randperm!\n"
"Random.randcycle\n"
"Random.randcycle!\n"
"Random.shuffle\n"
"Random.shuffle!\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Random.md:66
#, no-wrap
msgid "Generators (creation and seeding)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:68
#, no-wrap
msgid ""
"Random.seed!\n"
"Random.AbstractRNG\n"
"Random.MersenneTwister\n"
"Random.RandomDevice\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Random.md:75
#, no-wrap
msgid "Hooking into the `Random` API"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:79
msgid ""
"There are two mostly orthogonal ways to extend `Random` functionalities: 1)  generating random values of custom types 2) creating new "
"generators"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:84
msgid ""
"The API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases of the `Random` module.  "
"For example, it's typically sufficient to implement one `rand` method in order to have all other usual methods work automatically."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:88
msgid ""
"The API for 2) is still rudimentary, and may require more work than strictly necessary from the implementor, in order to support usual types "
"of generated values."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Random.md:89
#, no-wrap
msgid "Generating random values of custom types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:100
msgid ""
"Generating random values for some distributions may involve various trade-offs. *Pre-computed* values, such as an [alias table](https://en."
"wikipedia.org/wiki/Alias_method) for discrete distributions, or [âsqueezingâ functions](https://en.wikipedia.org/wiki/Rejection_sampling) "
"for univariate distributions, can speed up sampling considerably. How much information should be pre-computed can depend on the number of "
"values we plan to draw from a distribution. Also, some random number generators can have certain properties that various algorithms may want "
"to exploit."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:109
msgid ""
"The `Random` module defines a customizable framework for obtaining random values that can address these issues. Each invocation of `rand` "
"generates a *sampler* which can be customized with the above trade-offs in mind, by adding methods to `Sampler`, which in turn can dispatch "
"on the random number generator, the object that characterizes the distribution, and a suggestion for the number of repetitions. Currently, "
"for the latter, `Val{1}` (for a single sample) and `Val{Inf}` (for an arbitrary number) are used, with `Random.Repetition` an alias for both."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:113
msgid ""
"The object returned by `Sampler` is then used to generate the random values. When implementing the random generation interface for a value "
"`X` that can be sampled from, the implementor should define the method"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:114
#, no-wrap
msgid "rand(rng, sampler)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:118
msgid "for the particular `sampler` returned by `Sampler(rng, X, repetition)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:121
msgid ""
"Samplers can be arbitrary values that implement `rand(rng, sampler)`, but for most applications the following predefined samplers may be "
"sufficient:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/stdlib/Random.md:125
msgid ""
"`SamplerType{T}()` can be used for implementing samplers that draw from type `T` (e.g. `rand(Int)`). This is the default returned by "
"`Sampler` for *types*."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/stdlib/Random.md:130
msgid ""
"`SamplerTrivial(self)` is a simple wrapper for `self`, which can be accessed with `[]`. This is the recommended sampler when no pre-computed "
"information is needed (e.g. `rand(1:3)`), and is the default returned by `Sampler` for *values*."
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/stdlib/Random.md:134
msgid ""
"`SamplerSimple(self, data)` also contains the additional `data` field, which can be used to store arbitrary pre-computed values, which "
"should be computed in a *custom method* of `Sampler`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:138
msgid ""
"We provide examples for each of these. We assume here that the choice of algorithm is independent of the RNG, so we use `AbstractRNG` in our "
"signatures."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:139
#, no-wrap
msgid ""
"Random.Sampler\n"
"Random.SamplerType\n"
"Random.SamplerTrivial\n"
"Random.SamplerSimple\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:150
msgid ""
"Decoupling pre-computation from actually generating the values is part of the API, and is also available to the user. As an example, assume "
"that `rand(rng, 1:20)` has to be called repeatedly in a loop: the way to take advantage of this decoupling is as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:151
#, no-wrap
msgid ""
"rng = MersenneTwister()\n"
"sp = Random.Sampler(rng, 1:20) # or Random.Sampler(MersenneTwister, 1:20)\n"
"for x in X\n"
"    n = rand(rng, sp) # similar to n = rand(rng, 1:20)\n"
"    # use n\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:163
msgid ""
"This is the mechanism that is also used in the standard library, e.g. by the default implementation of random array generation (like in "
"`rand(1:20, 10)`)."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/stdlib/Random.md:164
#, no-wrap
msgid "Generating values from a type"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:171
msgid ""
"Given a type `T`, it's currently assumed that if `rand(T)` is defined, an object of type `T` will be produced. `SamplerType` is the *default "
"sampler for types*. In order to define random generation of values of type `T`, the `rand(rng::AbstractRNG, ::Random.SamplerType{T})` method "
"should be defined, and should return values what `rand(rng, T)` is expected to return."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:175
msgid ""
"Let's take the following example: we implement a `Die` type, with a variable number `n` of sides, numbered from `1` to `n`. We want "
"`rand(Die)` to produce a `Die` with a random number of up to 20 sides (and at least 4):"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/stdlib/Random.md:176
#, no-wrap
msgid "jldoctest Die"
msgstr "jldoctest Die"

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:176
#, no-wrap
msgid ""
"struct Die\n"
"    nsides::Int # number of sides\n"
"end\n"
"\n"
"Random.rand(rng::AbstractRNG, ::Random.SamplerType{Die}) = Die(rand(rng, 4:20))\n"
"\n"
"# output\n"
"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:188
msgid "Scalar and array methods for `Die` now work as expected:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/stdlib/Random.md:189 ext/julia/doc/src/stdlib/Random.md:222
#, no-wrap
msgid "jldoctest Die; setup = :(Random.seed!(1))"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:189
#, no-wrap
msgid ""
"julia> rand(Die)\n"
"Die(18)\n"
"\n"
"julia> rand(MersenneTwister(0), Die)\n"
"Die(4)\n"
"\n"
"julia> rand(Die, 3)\n"
"3-element Array{Die,1}:\n"
" Die(6)\n"
" Die(11)\n"
" Die(5)\n"
"\n"
"julia> a = Vector{Die}(undef, 3); rand!(a)\n"
"3-element Array{Die,1}:\n"
" Die(18)\n"
" Die(6)\n"
" Die(8)\n"
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/stdlib/Random.md:209
#, no-wrap
msgid "A simple sampler without pre-computed data"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:214
msgid ""
"Here we define a sampler for a collection. If no pre-computed data is required, it can be implemented with a `SamplerTrivial` sampler, which "
"is in fact the *default fallback for values*."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:221
msgid ""
"In order to define random generation out of objects of type `S`, the following method should be defined: `rand(rng::AbstractRNG, sp::Random."
"SamplerTrivial{S})`. Here, `sp` simply wraps an object of type `S`, which can be accessed via `sp[]`. Continuing the `Die` example, we want "
"now to define `rand(d::Die)` to produce an `Int` corresponding to one of `d`'s sides:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:222
#, no-wrap
msgid ""
"julia> Random.rand(rng::AbstractRNG, d::Random.SamplerTrivial{Die}) = rand(rng, 1:d[].nsides);\n"
"\n"
"julia> rand(Die(4))\n"
"3\n"
"\n"
"julia> rand(Die(4), 3)\n"
"3-element Array{Any,1}:\n"
" 3\n"
" 4\n"
" 2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:239
msgid ""
"Given a collection type `S`, it's currently assumed that if `rand(::S)` is defined, an object of type `eltype(S)` will be produced. In the "
"last example, a `Vector{Any}` is produced; the reason is that `eltype(Die) == Any`. The remedy is to define `Base.eltype(::Type{Die}) = Int`."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/stdlib/Random.md:240
#, no-wrap
msgid "Generating values for an `AbstractFloat` type"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:243
#, no-wrap
msgid "`AbstractFloat` types are special-cased, because by default random values are not produced in the whole type domain, but rather in `[0,1)`. The following method should be implemented for `T <: AbstractFloat`: `Random.rand(::AbstractRNG, ::Random.SamplerTrivial{Random.CloseOpen01{T}})`\n"
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/stdlib/Random.md:244
#, no-wrap
msgid "An optimized sampler with pre-computed data"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:253
msgid ""
"Consider a discrete distribution, where numbers `1:n` are drawn with given probabilities that sum to one. When many values are needed from "
"this distribution, the fastest method is using an [alias table](https://en.wikipedia.org/wiki/Alias_method). We don't provide the algorithm "
"for building such a table here, but suppose it is available in `make_alias_table(probabilities)` instead, and `draw_number(rng, "
"alias_table)` can be used to draw a random number from it."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:255
msgid "Suppose that the distribution is described by"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:255
#, no-wrap
msgid ""
"struct DiscreteDistribution{V <: AbstractVector}\n"
"    probabilities::V\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:262
msgid ""
"and that we *always* want to build an a alias table, regardless of the number of values needed (we learn how to customize this below). The "
"methods"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:262
#, no-wrap
msgid ""
"Random.eltype(::Type{<:DiscreteDistribution}) = Int\n"
"\n"
"function Random.Sampler(::AbstractRng, distribution::DiscreteDistribution, ::Repetition)\n"
"    SamplerSimple(disribution, make_alias_table(distribution.probabilities))\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:270
msgid "should be defined to return a sampler with pre-computed data, then"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:270
#, no-wrap
msgid ""
"function rand(rng::AbstractRNG, sp::SamplerSimple{<:DiscreteDistribution})\n"
"    draw_number(rng, sp.data)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:276
msgid "will be used to draw the values."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/stdlib/Random.md:277
#, no-wrap
msgid "Custom sampler types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:282
msgid ""
"The `SamplerSimple` type is sufficient for most use cases with precomputed data. However, in order to demonstrate how to use custom sampler "
"types, here we implement something similar to `SamplerSimple`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:286
msgid ""
"Going back to our `Die` example: `rand(::Die)` uses random generation from a range, so there is an opportunity for this optimization. We "
"call our custom sampler `SamplerDie`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:287
#, no-wrap
msgid ""
"import Random: Sampler, rand\n"
"\n"
"struct SamplerDie <: Sampler{Int} # generates values of type Int\n"
"    die::Die\n"
"    sp::Sampler{Int} # this is an abstract type, so this could be improved\n"
"end\n"
"\n"
"Sampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =\n"
"    SamplerDie(die, Sampler(RNG, 1:die.nsides, r))\n"
"# the `r` parameter will be explained later on\n"
"\n"
"rand(rng::AbstractRNG, sp::SamplerDie) = rand(rng, sp.sp)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:306
msgid ""
"It's now possible to get a sampler with `sp = Sampler(rng, die)`, and use `sp` instead of `die` in any `rand` call involving `rng`. In the "
"simplistic example above, `die` doesn't need to be stored in `SamplerDie` but this is often the case in practice."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:310
msgid ""
"Of course, this pattern is so frequent that the helper type used above, namely `Random.SamplerSimple`, is available, saving us the "
"definition of `SamplerDie`: we could have implemented our decoupling with:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:311
#, no-wrap
msgid ""
"Sampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =\n"
"    SamplerSimple(die, Sampler(RNG, 1:die.nsides, r))\n"
"\n"
"rand(rng::AbstractRNG, sp::SamplerSimple{Die}) = rand(rng, sp.data)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:321
msgid ""
"Here, `sp.data` refers to the second parameter in the call to the `SamplerSimple` constructor (in this case equal to `Sampler(rng, 1:die."
"nsides, r)`), while the `Die` object can be accessed via `sp[]`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:328
msgid ""
"Like `SamplerDie`, any custom sampler must be a subtype of `Sampler{T}` where `T` is the type of the generated values. Note that "
"`SamplerSimple(x, data) isa Sampler{eltype(x)}`, so this constrains what the first argument to `SamplerSimple` can be (it's recommended to "
"use `SamplerSimple` like in the `Die` example, where `x` is simply forwarded while defining a `Sampler` method).  Similarly, "
"`SamplerTrivial(x) isa Sampler{eltype(x)}`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:332
msgid ""
"Another helper type is currently available for other cases, `Random.SamplerTag`, but is considered as internal API, and can break at any "
"time without proper deprecations."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/stdlib/Random.md:334
#, no-wrap
msgid "Using distinct algorithms for scalar or array generation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:342
msgid ""
"In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of "
"algorithm. This is handled with the third parameter of the `Sampler` constructor. Let's assume we defined two helper types for `Die`, say "
"`SamplerDie1` which should be used to generate only few random values, and `SamplerDieMany` for many values.  We can use those types as "
"follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:343
#, no-wrap
msgid ""
"Sampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{1}) = SamplerDie1(...)\n"
"Sampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{Inf}) = SamplerDieMany(...)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:352
msgid ""
"Of course, `rand` must also be defined on those types (i.e. `rand(::AbstractRNG, ::SamplerDie1)` and `rand(::AbstractRNG, ::"
"SamplerDieMany)`). Note that, as usual, `SamplerTrivial` and `SamplerSimple` can be used if custom types are not necessary."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:356
msgid ""
"Note: `Sampler(rng, x)` is simply a shorthand for `Sampler(rng, x, Val(Inf))`, and `Random.Repetition` is an alias for `Union{Val{1}, "
"Val{Inf}}`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Random.md:358
#, no-wrap
msgid "Creating new generators"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:366
#, no-wrap
msgid ""
"The API is not clearly defined yet, but as a rule of thumb:\n"
"1) any `rand` method producing \"basic\" types (`isbitstype` integer and floating types in `Base`)\n"
"   should be defined for this specific RNG, if they are needed;\n"
"2) other documented `rand` methods accepting an `AbstractRNG` should work out of the box,\n"
"   (provided the methods from 1) what are relied on are implemented),\n"
"   but can of course be specialized for this RNG if there is room for optimization.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:370
msgid ""
"Concerning 1), a `rand` method may happen to work automatically, but it's not officially supported and may break without warnings in a "
"subsequent release."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:375
msgid ""
"To define a new `rand` method for an hypothetical `MyRNG` generator, and a value specification `s` (e.g. `s == Int`, or `s == 1:10`) of type "
"`S==typeof(s)` or `S==Type{s}` if `s` is a type, the same two methods as we saw before must be defined:"
msgstr ""

#. type: Bullet: '1) '
#: ext/julia/doc/src/stdlib/Random.md:379
msgid "`Sampler(::Type{MyRNG}, ::S, ::Repetition)`, which returns an object of type say `SamplerS`"
msgstr ""

#. type: Bullet: '2) '
#: ext/julia/doc/src/stdlib/Random.md:379
msgid "`rand(rng::MyRNG, sp::SamplerS)`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:385
msgid ""
"It can happen that `Sampler(rng::AbstractRNG, ::S, ::Repetition)` is already defined in the `Random` module. It would then be possible to "
"skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding `SamplerS` type is "
"considered as internal detail, and may be changed without warning."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/stdlib/Random.md:387
#, no-wrap
msgid "Specializing array generation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:393
msgid ""
"In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely "
"using the decoupling technique explained before. This is for example the case for `MersenneTwister`, which natively writes random values in "
"an array."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:401
msgid ""
"To implement this specialization for `MyRNG` and for a specification `s`, producing elements of type `S`, the following method can be "
"defined: `rand!(rng::MyRNG, a::AbstractArray{S}, ::SamplerS)`, where `SamplerS` is the type of the sampler returned by `Sampler(MyRNG, s, "
"Val(Inf))`.  Instead of `AbstractArray`, it's possible to implement the functionality only for a subtype, e.g. `Array{S}`.  The non-mutating "
"array method of `rand` will automatically call this specialization internally."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Random.md:402 ext/julia/doc/src/stdlib/SparseArrays.md:243 ext/julia/doc/src/stdlib/LinearAlgebra.md:689
#: ext/julia/doc/src/stdlib/Test.md:279 ext/julia/doc/src/stdlib/Dates.md:874 ext/julia/doc/src/devdocs/cartesian.md:66
#: ext/julia/doc/src/devdocs/subarrays.md:31
#, no-wrap
msgid "DocTestSetup = nothing\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Libdl.md:1
#, no-wrap
msgid "Dynamic Linker"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Libdl.md:3
#, no-wrap
msgid ""
"Libdl.dlopen\n"
"Libdl.dlopen_e\n"
"Libdl.RTLD_NOW\n"
"Libdl.dlsym\n"
"Libdl.dlsym_e\n"
"Libdl.dlclose\n"
"Libdl.dlext\n"
"Libdl.dllist\n"
"Libdl.dlpath\n"
"Libdl.find_library\n"
"Libdl.DL_LOAD_PATH\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/REPL.md:1
#, no-wrap
msgid "The Julia REPL"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:9
msgid ""
"Julia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into the `julia` executable. In addition to "
"allowing quick and easy evaluation of Julia statements, it has a searchable history, tab-completion, many helpful keybindings, and dedicated "
"help and shell modes. The REPL can be started by simply calling `julia` with no arguments or double-clicking on the executable:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:10
#, no-wrap
msgid ""
"io = IOBuffer()\n"
"Base.banner(io)\n"
"banner = String(take!(io))\n"
"import Markdown\n"
"Markdown.parse(\"```\\n\\$ julia\\n\\n$(banner)\\njulia>\\n```\")\n"
msgstr ""
"io = IOBuffer()\n"
"Base.banner(io)\n"
"banner = String(take!(io))\n"
"import Markdown\n"
"Markdown.parse(\"```\\n\\$ julia\\n\\n$(banner)\\njulia>\\n```\")\n"

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:21
#, no-wrap
msgid ""
"To exit the interactive session, type `^D` -- the control key together with the `d` key on a blank\n"
"line -- or type `exit()` followed by the return or enter key. The REPL greets you with a banner\n"
"and a `julia>` prompt.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/REPL.md:22
#, no-wrap
msgid "The different prompt modes"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/REPL.md:24
#, no-wrap
msgid "The Julian mode"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:30
#, no-wrap
msgid ""
"The REPL has four main modes of operation. The first and most common is the Julian prompt. It\n"
"is the default mode of operation; each new line initially starts with `julia>`. It is here that\n"
"you can enter Julia expressions. Hitting return or enter after a complete expression has been\n"
"entered will evaluate the entry and show the result of the last expression.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:31
#, no-wrap
msgid ""
"julia> string(1 + 2)\n"
"\"3\"\n"
msgstr ""
"julia> string(1 + 2)\n"
"\"3\"\n"

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:40
msgid ""
"There are a number useful features unique to interactive work. In addition to showing the result, the REPL also binds the result to the "
"variable `ans`. A trailing semicolon on the line can be used as a flag to suppress showing the result."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:41
#, no-wrap
msgid ""
"julia> string(3 * 4);\n"
"\n"
"julia> ans\n"
"\"12\"\n"
msgstr ""
"julia> string(3 * 4);\n"
"\n"
"julia> ans\n"
"\"12\"\n"

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:56
#, no-wrap
msgid ""
"In Julia mode, the REPL supports something called *prompt pasting*. This activates when pasting\n"
"text that starts with `julia>â` into the REPL. In that case, only expressions starting with\n"
"`julia>â` are parsed, others are removed. This makes it is possible to paste a chunk of code\n"
"that has been copied from a REPL session without having to scrub away prompts and outputs. This\n"
"feature is enabled by default but can be disabled or enabled at will with `REPL.enable_promptpaste(::Bool)`.\n"
"If it is enabled, you can try it out by pasting the code block above this paragraph straight into\n"
"the REPL. This feature does not work on the standard Windows command prompt due to its limitation\n"
"at detecting when a paste occurs.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/REPL.md:57
#, no-wrap
msgid "Help mode"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:62
msgid ""
"When the cursor is at the beginning of the line, the prompt can be changed to a help mode by typing `?`. Julia will attempt to print help or "
"documentation for anything entered in help mode:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:63
#, no-wrap
msgid ""
"julia> ? # upon typing ?, the prompt changes (in place) to: help?>\n"
"\n"
"help?> string\n"
"search: string String Cstring Cwstring RevString randstring bytestring SubString\n"
"\n"
"  string(xs...)\n"
"\n"
"  Create a string from any values using the print function.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:75
msgid "Macros, types and variables can also be queried:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:76
#, no-wrap
msgid ""
"help?> @time\n"
"  @time\n"
"\n"
"  A macro to execute an expression, printing the time it took to execute, the number of allocations,\n"
"  and the total number of bytes its execution caused to be allocated, before returning the value of the\n"
"  expression.\n"
"\n"
"  See also @timev, @timed, @elapsed, and @allocated.\n"
"\n"
"help?> Int32\n"
"search: Int32 UInt32\n"
"\n"
"  Int32 <: Signed\n"
"\n"
"  32-bit signed integer type.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:95
msgid "Help mode can be exited by pressing backspace at the beginning of the line."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/REPL.md:96
#, no-wrap
msgid "[Shell mode](@id man-shell-mode)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:103
msgid ""
"Just as help mode is useful for quick access to documentation, another common task is to use the system shell to execute system commands. "
"Just as `?` entered help mode when at the beginning of the line, a semicolon (`;`)  will enter the shell mode. And it can be exited by "
"pressing backspace at the beginning of the line."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:104
#, no-wrap
msgid ""
"julia> ; # upon typing ;, the prompt changes (in place) to: shell>\n"
"\n"
"shell> echo hello\n"
"hello\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/REPL.md:111
#, no-wrap
msgid "Search modes"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:119
#, no-wrap
msgid ""
"In all of the above modes, the executed lines get saved to a history file, which can be searched.\n"
" To initiate an incremental search through the previous history, type `^R` -- the control key\n"
"together with the `r` key. The prompt will change to ```(reverse-i-search)`':```, and as you\n"
"type the search query will appear in the quotes. The most recent result that matches the query\n"
"will dynamically update to the right of the colon as more is typed. To find an older result using\n"
"the same query, simply type `^R` again.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:123
#, no-wrap
msgid ""
"Just as `^R` is a reverse search, `^S` is a forward search, with the prompt ```(i-search)`':```.\n"
" The two may be used in conjunction with each other to move through the previous or next matching\n"
"results, respectively.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/REPL.md:124
#, no-wrap
msgid "Key bindings"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:132
msgid ""
"The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (`^D` to exit, `^R` and `^S` for "
"searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most "
"terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:182
#, no-wrap
msgid ""
"| Keybinding          | Description                                                                                                |\n"
"|:------------------- |:---------------------------------------------------------------------------------------------------------- |\n"
"| **Program control** | Â                                                                                                           |\n"
"| `^D`                | Exit (when buffer is empty)                                                                                |\n"
"| `^C`                | Interrupt or cancel                                                                                        |\n"
"| `^L`                | Clear console screen                                                                                       |\n"
"| Return/Enter, `^J`  | New line, executing if it is complete                                                                      |\n"
"| meta-Return/Enter   | Insert new line without executing it                                                                       |\n"
"| `?` or `;`          | Enter help or shell mode (when at start of a line)                                                         |\n"
"| `^R`, `^S`          | Incremental history search, described above                                                                |\n"
"| **Cursor movement** | Â                                                                                                           |\n"
"| Right arrow, `^F`   | Move right one character                                                                                   |\n"
"| Left arrow, `^B`    | Move left one character                                                                                    |\n"
"| ctrl-Right, `meta-F`| Move right one word                                                                                        |\n"
"| ctrl-Left, `meta-B` | Move left one word                                                                                         |\n"
"| Home, `^A`          | Move to beginning of line                                                                                  |\n"
"| End, `^E`           | Move to end of line                                                                                        |\n"
"| Up arrow, `^P`      | Move up one line (or change to the previous history entry that matches the text before the cursor)         |\n"
"| Down arrow, `^N`    | Move down one line (or change to the next history entry that matches the text before the cursor)           |\n"
"| Shift-Arrow Key     | Move cursor according to the direction of the Arrow key, while activating the region (\"shift selection\")   |\n"
"| Page-up, `meta-P`   | Change to the previous history entry                                                                       |\n"
"| Page-down, `meta-N` | Change to the next history entry                                                                           |\n"
"| `meta-<`            | Change to the first history entry (of the current session if it is before the current position in history) |\n"
"| `meta->`            | Change to the last history entry                                                                           |\n"
"| `^-Space`           | Set the \"mark\" in the editing region (and de-activate the region if it's active)                           |\n"
"| `^-Space ^-Space`   | Set the \"mark\" in the editing region and make the region \"active\", i.e. highlighted                        |\n"
"| `^G`                | De-activate the region (i.e. make it not highlighted)                                                      |\n"
"| `^X^X`              | Exchange the current position with the mark                                                                |\n"
"| **Editing**         | Â                                                                                                           |\n"
"| Backspace, `^H`     | Delete the previous character, or the whole region when it's active                                        |\n"
"| Delete, `^D`        | Forward delete one character (when buffer has text)                                                        |\n"
"| meta-Backspace      | Delete the previous word                                                                                   |\n"
"| `meta-d`            | Forward delete the next word                                                                               |\n"
"| `^W`                | Delete previous text up to the nearest whitespace                                                          |\n"
"| `meta-w`            | Copy the current region in the kill ring                                                                   |\n"
"| `meta-W`            | \"Kill\" the current region, placing the text in the kill ring                                               |\n"
"| `^K`                | \"Kill\" to end of line, placing the text in the kill ring                                                   |\n"
"| `^Y`                | \"Yank\" insert the text from the kill ring                                                                  |\n"
"| `meta-y`            | Replace a previously yanked text with an older entry from the kill ring                                    |\n"
"| `^T`                | Transpose the characters about the cursor                                                                  |\n"
"| `meta-Up arrow`     | Transpose current line with line above                                                                     |\n"
"| `meta-Down arrow`   | Transpose current line with line below                                                                     |\n"
"| `meta-u`            | Change the next word to uppercase                                                                          |\n"
"| `meta-c`            | Change the next word to titlecase                                                                          |\n"
"| `meta-l`            | Change the next word to lowercase                                                                          |\n"
"| `^/`, `^_`          | Undo previous editing action                                                                               |\n"
"| `^Q`                | Write a number in REPL and press `^Q` to open editor at corresponding stackframe or method                 |\n"
"| `meta-Left Arrow`   | indent the current line on the left                                                                        |\n"
"| `meta-Right Arrow`  | indent the current line on the right                                                                       |\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/REPL.md:184
#, no-wrap
msgid "Customizing keybindings"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:198
msgid ""
"Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary to `REPL.setup_interface`. The keys of this "
"dictionary may be characters or strings. The key `'*'` refers to the default action. Control plus character `x` bindings are indicated with `"
"\"^x\"`.  Meta plus `x` can be written `\"\\\\Mx\"`. The values of the custom keymap must be `nothing` (indicating that the input should be "
"ignored) or functions that accept the signature `(PromptState, AbstractREPL, Char)`.  The `REPL.setup_interface` function must be called "
"before the REPL is initialized, by registering the operation with [`atreplinit`](@ref) . For example, to bind the up and down arrow keys to "
"move through history without prefix search, one could put the following code in `~/.julia/config/startup.jl`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:199
#, no-wrap
msgid ""
"import REPL\n"
"import REPL.LineEdit\n"
"\n"
"const mykeys = Dict{Any,Any}(\n"
"    # Up Arrow\n"
"    \"\\e[A\" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_prev(s, LineEdit.mode(s).hist)),\n"
"    # Down Arrow\n"
"    \"\\e[B\" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_next(s, LineEdit.mode(s).hist))\n"
")\n"
"\n"
"function customize_keys(repl)\n"
"    repl.interface = REPL.setup_interface(repl; extra_repl_keymap = mykeys)\n"
"end\n"
"\n"
"atreplinit(customize_keys)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:219
msgid "Users should refer to `LineEdit.jl` to discover the available actions on key input."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/REPL.md:220
#, no-wrap
msgid "Tab completion"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:225
msgid ""
"In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to "
"get a list all matches:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:226
#, no-wrap
msgid ""
"julia> stri[TAB]\n"
"stride     strides     string      strip\n"
"\n"
"julia> Stri[TAB]\n"
"StridedArray    StridedMatrix    StridedVecOrMat  StridedVector    String\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:236
msgid "The tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents, and get a list of LaTeX matches as well:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:237
#, no-wrap
msgid ""
"julia> \\pi[TAB]\n"
"julia> Ï\n"
"Ï = 3.1415926535897...\n"
"\n"
"julia> e\\_1[TAB] = [1,0]\n"
"julia> eâ = [1,0]\n"
"2-element Array{Int64,1}:\n"
" 1\n"
" 0\n"
"\n"
"julia> e\\^1[TAB] = [1 0]\n"
"julia> eÂ¹ = [1 0]\n"
"1Ã2 Array{Int64,2}:\n"
" 1  0\n"
"\n"
"julia> \\sqrt[TAB]2     # â is equivalent to the sqrt function\n"
"julia> â2\n"
"1.4142135623730951\n"
"\n"
"julia> \\hbar[TAB](h) = h / 2\\pi[TAB]\n"
"julia> Ä§(h) = h / 2Ï\n"
"Ä§ (generic function with 1 method)\n"
"\n"
"julia> \\h[TAB]\n"
"\\hat              \\hermitconjmatrix  \\hkswarow          \\hrectangle\n"
"\\hatapprox        \\hexagon           \\hookleftarrow     \\hrectangleblack\n"
"\\hbar             \\hexagonblack      \\hookrightarrow    \\hslash\n"
"\\heartsuit        \\hksearow          \\house             \\hspace\n"
"\n"
"julia> Î±=\"\\alpha[TAB]\"   # LaTeX completion also works in strings\n"
"julia> Î±=\"Î±\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:273
msgid "A full list of tab-completions can be found in the [Unicode Input](@ref)  section of the manual."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:275
msgid "Completion of paths works for strings and julia's shell mode:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:276
#, no-wrap
msgid ""
"julia> path=\"/[TAB]\"\n"
".dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/\n"
".dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/\n"
"shell> /[TAB]\n"
".dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/\n"
".dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:287
msgid "Tab completion can help with investigation of the available methods matching the input arguments:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:288
#, no-wrap
msgid ""
"julia> max([TAB] # All methods are displayed, not shown here due to size of the list\n"
"\n"
"julia> max([1, 2], [TAB] # All methods where `Vector{Int}` matches as first argument\n"
"max(x, y) in Base at operators.jl:215\n"
"max(a, b, c, xs...) in Base at operators.jl:281\n"
"\n"
"julia> max([1, 2], max(1, 2), [TAB] # All methods matching the arguments.\n"
"max(x, y) in Base at operators.jl:215\n"
"max(a, b, c, xs...) in Base at operators.jl:281\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:302
msgid "Keywords are also displayed in the suggested methods after `;`, see below line where `limit` and `keepempty` are keyword arguments:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:303
#, no-wrap
msgid ""
"julia> split(\"1 1 1\", [TAB]\n"
"split(str::AbstractString; limit, keepempty) in Base at strings/util.jl:302\n"
"split(str::T, splitter; limit, keepempty) where T<:AbstractString in Base at strings/util.jl:277\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:313
msgid ""
"The completion of the methods uses type inference and can therefore see if the arguments match even if the arguments are output from "
"functions. The function needs to be type stable for the completion to be able to remove non-matching methods."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:315
msgid "Tab completion can also help completing fields:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:316
#, no-wrap
msgid ""
"julia> import UUIDs\n"
"\n"
"julia> UUIDs.uuid[TAB]\n"
"uuid1        uuid4         uuid_version\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:324
msgid "Fields for output from functions can also be completed:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:325
#, no-wrap
msgid ""
"julia> split(\"\",\"\")[1].[TAB]\n"
"lastindex  offset  string\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:332
msgid "The completion of fields for output from functions uses type inference, and it can only suggest fields if the function is type stable."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:334
msgid "Dictionary keys can also be tab completed:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:335
#, no-wrap
msgid ""
"julia> foo = Dict(\"qwer1\"=>1, \"qwer2\"=>2, \"asdf\"=>3)\n"
"Dict{String,Int64} with 3 entries:\n"
"  \"qwer2\" => 2\n"
"  \"asdf\"  => 3\n"
"  \"qwer1\" => 1\n"
"\n"
"julia> foo[\"q[TAB]\n"
"\n"
"\"qwer1\" \"qwer2\"\n"
"julia> foo[\"qwer\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/REPL.md:348
#, no-wrap
msgid "Customizing Colors"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:354
msgid ""
"The colors used by Julia and the REPL can be customized, as well. To change the color of the Julia prompt you can add something like the "
"following to your `~/.julia/config/startup.jl` file, which is to be placed inside your home directory:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:355
#, no-wrap
msgid ""
"function customize_colors(repl)\n"
"    repl.prompt_color = Base.text_colors[:cyan]\n"
"end\n"
"\n"
"atreplinit(customize_colors)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:366
msgid ""
"The available color keys can be seen by typing `Base.text_colors` in the help mode of the REPL.  In addition, the integers 0 to 255 can be "
"used as color keys for terminals with 256 color support."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:372
msgid ""
"You can also change the colors for the help and shell prompts and input and answer text by setting the appropriate field of `repl` in the "
"`customize_colors` function above (respectively, `help_color`, `shell_color`, `input_color`, and `answer_color`). For the latter two, be "
"sure that the `envcolors` field is also set to false."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:376
msgid ""
"It is also possible to apply boldface formatting by using `Base.text_colors[:bold]` as a color. For instance, to print answers in boldface "
"font, one can use the following as a `~/.julia/config/startup.jl`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:377
#, no-wrap
msgid ""
"function customize_colors(repl)\n"
"    repl.envcolors = false\n"
"    repl.answer_color = Base.text_colors[:bold]\n"
"end\n"
"\n"
"atreplinit(customize_colors)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:391
msgid ""
"You can also customize the color used to render warning and informational messages by setting the appropriate environment variables. For "
"instance, to render error, warning, and informational messages respectively in magenta, yellow, and cyan you can add the following to your "
"`~/.julia/config/startup.jl` file:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:392
#, no-wrap
msgid ""
"ENV[\"JULIA_ERROR_COLOR\"] = :magenta\n"
"ENV[\"JULIA_WARN_COLOR\"] = :yellow\n"
"ENV[\"JULIA_INFO_COLOR\"] = :cyan\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/REPL.md:398
#, no-wrap
msgid "TerminalMenus"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:402
msgid "TerminalMenus is a submodule of the Julia REPL and enables small, low-profile interactive menus in the terminal."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/REPL.md:403 ext/julia/doc/src/stdlib/REPL.md:513
#, no-wrap
msgid "ä¾"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:405
#, no-wrap
msgid ""
"import REPL\n"
"using REPL.TerminalMenus\n"
"\n"
"options = [\"apple\", \"orange\", \"grape\", \"strawberry\",\n"
"            \"blueberry\", \"peach\", \"lemon\", \"lime\"]\n"
"\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/REPL.md:414
#, no-wrap
msgid "RadioMenu"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:420
msgid ""
"The RadioMenu allows the user to select one option from the list. The `request` function displays the interactive menu and returns the index "
"of the selected choice. If a user presses 'q' or `ctrl-c`, `request` will return a `-1`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:422
#, no-wrap
msgid ""
"# `pagesize` is the number of items to be displayed at a time.\n"
"#  The UI will scroll if the number of options is greater\n"
"#   than the `pagesize`\n"
"menu = RadioMenu(options, pagesize=4)\n"
"\n"
"# `request` displays the menu and returns the index after the\n"
"#   user has selected a choice\n"
"choice = request(\"Choose your favorite fruit:\", menu)\n"
"\n"
"if choice != -1\n"
"    println(\"Your favorite fruit is \", options[choice], \"!\")\n"
"else\n"
"    println(\"Menu canceled.\")\n"
"end\n"
"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:441 ext/julia/doc/src/stdlib/REPL.md:474
msgid "Output:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:442
#, no-wrap
msgid ""
"Choose your favorite fruit:\n"
"^  grape\n"
"   strawberry\n"
" > blueberry\n"
"v  peach\n"
"Your favorite fruit is blueberry!\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/REPL.md:451
#, no-wrap
msgid "MultiSelectMenu"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:454
msgid "The MultiSelectMenu allows users to select many choices from a list."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:455
#, no-wrap
msgid ""
"# here we use the default `pagesize` 10\n"
"menu = MultiSelectMenu(options)\n"
"\n"
"# `request` returns a `Set` of selected indices\n"
"# if the menu us canceled (ctrl-c or q), return an empty set\n"
"choices = request(\"Select the fruits you like:\", menu)\n"
"\n"
"if length(choices) > 0\n"
"    println(\"You like the following fruits:\")\n"
"    for i in choices\n"
"        println(\"  - \", options[i])\n"
"    end\n"
"else\n"
"    println(\"Menu canceled.\")\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:475
#, no-wrap
msgid ""
"Select the fruits you like:\n"
"[press: d=done, a=all, n=none]\n"
"   [ ] apple\n"
" > [X] orange\n"
"   [X] grape\n"
"   [ ] strawberry\n"
"   [ ] blueberry\n"
"   [X] peach\n"
"   [ ] lemon\n"
"   [ ] lime\n"
"You like the following fruits:\n"
"  - orange\n"
"  - grape\n"
"  - peach\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/REPL.md:492
#, no-wrap
msgid "Customization / Configuration"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:496
msgid "All interface customization is done through the keyword only `TerminalMenus.config()` function."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/REPL.md:497
#, no-wrap
msgid "Arguments"
msgstr ""

#. type: Bullet: ' - '
#: ext/julia/doc/src/stdlib/REPL.md:512
msgid "`charset::Symbol=:na`: ui characters to use (`:ascii` or `:unicode`); overridden by other arguments"
msgstr ""

#. type: Bullet: ' - '
#: ext/julia/doc/src/stdlib/REPL.md:512
msgid "`cursor::Char='>'|'â'`: character to use for cursor"
msgstr ""

#. type: Bullet: ' - '
#: ext/julia/doc/src/stdlib/REPL.md:512
msgid "`up_arrow::Char='^'|'â'`: character to use for up arrow"
msgstr ""

#. type: Bullet: ' - '
#: ext/julia/doc/src/stdlib/REPL.md:512
msgid "`down_arrow::Char='v'|'â'`: character to use for down arrow"
msgstr ""

#. type: Bullet: ' - '
#: ext/julia/doc/src/stdlib/REPL.md:512
msgid "`checked::String=\"[X]\"|\"â\"`: string to use for checked"
msgstr ""

#. type: Bullet: ' - '
#: ext/julia/doc/src/stdlib/REPL.md:512
msgid "`unchecked::String=\"[ ]\"|\"â¬\")`: string to use for unchecked"
msgstr ""

#. type: Bullet: ' - '
#: ext/julia/doc/src/stdlib/REPL.md:512
msgid "`scroll::Symbol=:na`: If `:wrap` then wrap the cursor around top and bottom, if :`nowrap` do not wrap cursor"
msgstr ""

#. type: Bullet: ' - '
#: ext/julia/doc/src/stdlib/REPL.md:512
msgid "`supress_output::Bool=false`: For testing. If true, menu will not be printed to console."
msgstr ""

#. type: Bullet: ' - '
#: ext/julia/doc/src/stdlib/REPL.md:512
msgid "`ctrl_c_interrupt::Bool=true`: If `false`, return empty on ^C, if `true` throw InterruptException() on ^C"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:515
#, no-wrap
msgid ""
"julia> menu = MultiSelectMenu(options, pagesize=5);\n"
"\n"
"julia> request(menu) # ASCII is used by default\n"
"[press: d=done, a=all, n=none]\n"
"   [ ] apple\n"
"   [X] orange\n"
"   [ ] grape\n"
" > [X] strawberry\n"
"v  [ ] blueberry\n"
"Set([4, 2])\n"
"\n"
"julia> TerminalMenus.config(charset=:unicode)\n"
"\n"
"julia> request(menu)\n"
"[press: d=done, a=all, n=none]\n"
"   â¬ apple\n"
"   â orange\n"
"   â¬ grape\n"
" â â strawberry\n"
"â  â¬ blueberry\n"
"Set([4, 2])\n"
"\n"
"julia> TerminalMenus.config(checked=\"YEP!\", unchecked=\"NOPE\", cursor='â§')\n"
"\n"
"julia> request(menu)\n"
"[press: d=done, a=all, n=none]\n"
"   NOPE apple\n"
"   YEP! orange\n"
"   NOPE grape\n"
" â§ YEP! strawberry\n"
"â  NOPE blueberry\n"
"Set([4, 2])\n"
"\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/REPL.md:551
#, no-wrap
msgid "References"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/REPL.md:553
#, no-wrap
msgid "Base.atreplinit\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Logging.md:1
#, no-wrap
msgid "Logging"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:6
msgid ""
"The [`Logging`](@ref Logging.Logging) module provides a way to record the history and progress of a computation as a log of events.  Events "
"are created by inserting a logging statement into the source code, for example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:7
#, no-wrap
msgid ""
"@warn \"Abandon printf debugging, all ye who enter here!\"\n"
"â Warning: Abandon printf debugging, all ye who enter here!\n"
"â @ Main REPL[1]:1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:17
msgid ""
"The system provides several advantages over peppering your source code with calls to `println()`.  First, it allows you to control the "
"visibility and presentation of messages without editing the source code.  For example, in contrast to the `@warn` above"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:18
#, no-wrap
msgid "@debug \"The sum of some values $(sum(rand(100)))\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:27
msgid ""
"will produce no output by default.  Furthermore, it's very cheap to leave debug statements like this in the source code because the system "
"avoids evaluating the message if it would later be ignored.  In this case `sum(rand(100))` and the associated string processing will never "
"be executed unless debug logging is enabled."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:32
msgid ""
"Second, the logging tools allow you to attach arbitrary data to each event as a set of key--value pairs. This allows you to capture local "
"variables and other program state for later analysis. For example, to attach the local array variable `A` and the sum of a vector `v` as the "
"key `s` you can use"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:33
#, no-wrap
msgid ""
"A = ones(Int, 4, 4)\n"
"v = ones(100)\n"
"@info \"Some variables\"  A  s=sum(v)\n"
"\n"
"# output\n"
"â Info: Some variables\n"
"â   A =\n"
"â    4Ã4 Array{Int64,2}:\n"
"â     1  1  1  1\n"
"â     1  1  1  1\n"
"â     1  1  1  1\n"
"â     1  1  1  1\n"
"â   s = 100.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:52
msgid ""
"All of the logging macros `@debug`, `@info`, `@warn` and `@error` share common features that are described in detail in the documentation "
"for the more general macro [`@logmsg`](@ref)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Logging.md:53
#, no-wrap
msgid "Log event structure"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:57
msgid ""
"Each event generates several pieces of data, some provided by the user and some automatically extracted. Let's examine the user-defined data "
"first:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:75
#, no-wrap
msgid ""
"* The *log level* is a broad category for the message that is used for early\n"
"  filtering. There are several standard levels of type [`LogLevel`](@ref);\n"
"  user-defined levels are also possible.\n"
"  - Use `Debug` for verbose information that could be useful when debugging an\n"
"    application or module. These events are disabled by default.\n"
"  - Use `Info` to inform the user about the normal operation of the program.\n"
"  - Use `Warn` when a potential problem is detected.\n"
"  - Use `Error` to report errors where the code has enough context to recover\n"
"    and continue.  (When the code doesn't have enough context, an exception or\n"
"    early return is more appropriate.)\n"
"* The *message*  is an object describing the event. By convention\n"
"  `AbstractString`s passed as messages are assumed to be in markdown format.\n"
"  Other types will be displayed using `show(io,mime,obj)` according to the\n"
"  display capabilities of the installed logger.\n"
"* Optional *key--value pairs* allow arbitrary data to be attached to each event.\n"
"  Some keys have conventional meaning that can affect the way an event is\n"
"  interpreted (see [`@logmsg`](@ref)).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:77
msgid "The system also generates some standard information for each event:"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/stdlib/Logging.md:89
msgid "The `module` in which the logging macro was expanded."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/stdlib/Logging.md:89
msgid "The `file` and `line` where the logging macro occurs in the source code."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/stdlib/Logging.md:89
msgid ""
"A message `id` that is a unique, fixed identifier for the *source code statement* where the logging macro appears. This identifier is "
"designed to be fairly stable even if the source code of the file changes, as long as the logging statement itself remains the same."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/stdlib/Logging.md:89
msgid ""
"A `group` for the event, which is set to the base name of the file by default, without extension.  This can be used to group messages into "
"categories more finely than the log level (for example, all deprecation warnings have group `:depwarn`), or into logical groupings across or "
"within modules."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:96
msgid ""
"Notice that some useful information such as the event time is not included by default. This is because such information can be expensive to "
"extract and is also *dynamically* available to the current logger. It's simple to define a [custom logger](@ref AbstractLogger-interface) to "
"augment event data with the time, backtrace, values of global variables and other useful information as required."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Logging.md:98
#, no-wrap
msgid "Processing log events"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:104
msgid ""
"As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design "
"feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:"
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/stdlib/Logging.md:110
msgid ""
"*Creating* log events is the concern of the module author who needs to decide where events are triggered and which information to include."
msgstr ""

#. type: Bullet: '* '
#: ext/julia/doc/src/stdlib/Logging.md:110
msgid ""
"*Processing* of log events â that is, display, filtering, aggregation and recording â is the concern of the application author who needs to "
"bring multiple modules together into a cooperating application."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Logging.md:111
#, no-wrap
msgid "Loggers"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:116
msgid ""
"Processing of events is performed by a *logger*, which is the first piece of user configurable code to see the event. All loggers must be "
"subtypes of [`AbstractLogger`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:126
msgid ""
"When an event is triggered, the appropriate logger is found by looking for a task-local logger with the global logger as fallback.  The idea "
"here is that the application code knows how log events should be processed and exists somewhere at the top of the call stack. So we should "
"look up through the call stack to discover the logger â that is, the logger should be *dynamically scoped*. (This is a point of contrast "
"with logging frameworks where the logger is *lexically scoped*; provided explicitly by the module author or as a simple global variable. In "
"such a system it's awkward to control logging while composing functionality from multiple modules.)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:130
msgid ""
"The global logger may be set with [`global_logger`](@ref), and task-local loggers controlled using [`with_logger`](@ref).  Newly spawned "
"tasks inherit the logger of the parent task."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:139
msgid ""
"There are three logger types provided by the library.  [`ConsoleLogger`](@ref)  is the default logger you see when starting the REPL.  It "
"displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering.  [`NullLogger`]"
"(@ref) is a convenient way to drop all messages where necessary; it is the logging equivalent of the [`devnull`](@ref)  stream.  "
"[`SimpleLogger`](@ref) is a very simplistic text formatting logger, mainly useful for debugging the logging system itself."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:142
msgid "Custom loggers should come with overloads for the functions described in the [reference section](@ref AbstractLogger-interface)."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Logging.md:143
#, no-wrap
msgid "Early filtering and message handling"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:147
msgid "When an event occurs, a few steps of early filtering occur to avoid generating messages that will be discarded:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/stdlib/Logging.md:160
msgid ""
"The message log level is checked against a global minimum level (set via [`disable_logging`](@ref)).  This is a crude but extremely cheap "
"global setting."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/stdlib/Logging.md:160
msgid ""
"The current logger state is looked up and the message level checked against the logger's cached minimum level, as found by calling [`Logging."
"min_enabled_level`](@ref).  This behavior can be overridden via environment variables (more on this later)."
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/stdlib/Logging.md:160
msgid ""
"The [`Logging.shouldlog`](@ref) function is called with the current logger, taking some minimal information (level, module, group, id) which "
"can be computed statically.  Most usefully, `shouldlog` is passed an event `id` which can be used to discard events early based on a cached "
"predicate."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:166
msgid ""
"If all these checks pass, the message and key--value pairs are evaluated in full and passed to the current logger via the [`Logging."
"handle_message`](@ref) function.  `handle_message()` may perform additional filtering as required and display the event to the screen, save "
"it to a file, etc."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:172
msgid ""
"Exceptions that occur while generating the log event are captured and logged by default.  This prevents individual broken events from "
"crashing the application, which is helpful when enabling little-used debug events in a production system.  This behavior can be customized "
"per logger type by extending [`Logging.catch_exceptions`](@ref)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Logging.md:173
#, no-wrap
msgid "Testing log events"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:179
msgid ""
"Log events are a side effect of running normal code, but you might find yourself wanting to test particular informational messages and "
"warnings. The `Test` module provides a [`@test_logs`](@ref) macro that can be used to pattern match against the log event stream."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Logging.md:180
#, no-wrap
msgid "Environment variables"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:186
msgid ""
"Message filtering can be influenced through the `JULIA_DEBUG` environment variable, and serves as an easy way to enable debug logging for a "
"file or module. For example, loading julia with `JULIA_DEBUG=loading` will activate `@debug` log messages in `loading.jl`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:187
#, no-wrap
msgid ""
"$ JULIA_DEBUG=loading julia -e 'using OhMyREPL'\n"
"â Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji due to it containing an invalid cache header\n"
"â @ Base loading.jl:1328\n"
"[ Info: Recompiling stale cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji for module OhMyREPL\n"
"â Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/Tokenize.ji due to it containing an invalid cache header\n"
"â @ Base loading.jl:1328\n"
"...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:200
msgid ""
"Similarly, the environment variable can be used to enable debug logging of modules, such as `Pkg`, or module roots (see [`Base.moduleroot`]"
"(@ref)). To enable all debug logging, use the special value `all`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Logging.md:201
#, no-wrap
msgid "Writing log events to a file"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:206
msgid ""
"Sometimes it can be useful to write log events to a file. Here is an example of how to use a task-local and global logger to write "
"information to a text file:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:207
#, no-wrap
msgid ""
"# Load the logging module\n"
"julia> using Logging\n"
"\n"
"# Open a textfile for writing\n"
"julia> io = open(\"log.txt\", \"w+\")\n"
"IOStream(<file log.txt>)\n"
"\n"
"# Create a simple logger\n"
"julia> logger = SimpleLogger(io)\n"
"SimpleLogger(IOStream(<file log.txt>), Info, Dict{Any,Int64}())\n"
"\n"
"# Log a task-specific message\n"
"julia> with_logger(logger) do\n"
"           @info(\"a context specific log message\")\n"
"       end\n"
"\n"
"# Write all buffered messages to the file\n"
"julia> flush(io)\n"
"\n"
"# Set the global logger to logger\n"
"julia> global_logger(logger)\n"
"SimpleLogger(IOStream(<file log.txt>), Info, Dict{Any,Int64}())\n"
"\n"
"# This message will now also be written to the file\n"
"julia> @info(\"a global log message\")\n"
"\n"
"# Close the file\n"
"julia> close(io)\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Logging.md:239
#, no-wrap
msgid "Reference"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Logging.md:241
#, no-wrap
msgid "Logging module"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:242
#, no-wrap
msgid "Logging.Logging\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Logging.md:246
#, no-wrap
msgid "Creating events"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:248
#, no-wrap
msgid ""
"Logging.@logmsg\n"
"Logging.LogLevel\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Logging.md:253
#, no-wrap
msgid "[Processing events with AbstractLogger](@id AbstractLogger-interface)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:257
msgid "Event processing is controlled by overriding functions associated with `AbstractLogger`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:265
#, no-wrap
msgid ""
"| Methods to implement                |                        | Brief description                        |\n"
"|:----------------------------------- |:---------------------- |:---------------------------------------- |\n"
"| [`Logging.handle_message`](@ref)    |                        | Handle a log event                       |\n"
"| [`Logging.shouldlog`](@ref)         |                        | Early filtering of events                |\n"
"| [`Logging.min_enabled_level`](@ref) |                        | Lower bound for log level of accepted events |\n"
"| **Optional methods**                | **Default definition** | **Brief description**                    |\n"
"| [`Logging.catch_exceptions`](@ref)  | `true`                 | Catch exceptions during event evaluation |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:267
#, no-wrap
msgid ""
"Logging.AbstractLogger\n"
"Logging.handle_message\n"
"Logging.shouldlog\n"
"Logging.min_enabled_level\n"
"Logging.catch_exceptions\n"
"Logging.disable_logging\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Logging.md:276
#, no-wrap
msgid "Using Loggers"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:279
msgid "ã­ã¬ã¼ã®ã¤ã³ã¹ãã¼ã«ã¨ã¤ã³ã¹ãã­ã¹ãã¯ã·ã§ã³:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:280
#, no-wrap
msgid ""
"Logging.global_logger\n"
"Logging.with_logger\n"
"Logging.current_logger\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:287
msgid "Loggers that are supplied with the system:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Logging.md:288
#, no-wrap
msgid ""
"Logging.NullLogger\n"
"Logging.ConsoleLogger\n"
"Logging.SimpleLogger\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/InteractiveUtils.md:1
#, no-wrap
msgid "Interactive Utilities"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/InteractiveUtils.md:3
#, no-wrap
msgid ""
"InteractiveUtils.apropos\n"
"InteractiveUtils.varinfo\n"
"InteractiveUtils.versioninfo\n"
"InteractiveUtils.methodswith\n"
"InteractiveUtils.subtypes\n"
"InteractiveUtils.edit(::AbstractString, ::Integer)\n"
"InteractiveUtils.edit(::Any)\n"
"InteractiveUtils.@edit\n"
"InteractiveUtils.less(::AbstractString)\n"
"InteractiveUtils.less(::Any)\n"
"InteractiveUtils.@less\n"
"InteractiveUtils.@which\n"
"InteractiveUtils.@functionloc\n"
"InteractiveUtils.@code_lowered\n"
"InteractiveUtils.@code_typed\n"
"InteractiveUtils.code_warntype\n"
"InteractiveUtils.@code_warntype\n"
"InteractiveUtils.code_llvm\n"
"InteractiveUtils.@code_llvm\n"
"InteractiveUtils.code_native\n"
"InteractiveUtils.@code_native\n"
"InteractiveUtils.clipboard\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/FileWatching.md:1
#, no-wrap
msgid "[File Events](@id lib-filewatching)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/FileWatching.md:3
#, no-wrap
msgid ""
"FileWatching.poll_fd\n"
"FileWatching.poll_file\n"
"FileWatching.watch_file\n"
"FileWatching.watch_folder\n"
"FileWatching.unwatch_folder\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/SparseArrays.md:1
#, no-wrap
msgid "Sparse Arrays"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:3
#, no-wrap
msgid "DocTestSetup = :(using SparseArrays, LinearAlgebra)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:12
msgid ""
"Julia has support for sparse vectors and [sparse matrices](https://en.wikipedia.org/wiki/Sparse_matrix)  in the `SparseArrays` stdlib "
"module. Sparse arrays are arrays that contain enough zeros that storing them in a special data structure leads to savings in space and "
"execution time, compared to dense arrays."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/SparseArrays.md:13
#, no-wrap
msgid "[Compressed Sparse Column (CSC) Sparse Matrix Storage](@id man-csc)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:21
msgid ""
"In Julia, sparse matrices are stored in the [Compressed Sparse Column (CSC)  format](https://en.wikipedia.org/wiki/"
"Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29).  Julia sparse matrices have the type [`SparseMatrixCSC{Tv,Ti}`](@ref), where `Tv` "
"is the type of the stored values, and `Ti` is the integer type for storing column pointers and row indices. The internal representation of "
"`SparseMatrixCSC` is as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:22
#, no-wrap
msgid ""
"struct SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}\n"
"    m::Int                  # Number of rows\n"
"    n::Int                  # Number of columns\n"
"    colptr::Vector{Ti}      # Column j is in colptr[j]:(colptr[j+1]-1)\n"
"    rowval::Vector{Ti}      # Row indices of stored values\n"
"    nzval::Vector{Tv}       # Stored values, typically nonzeros\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:38
msgid ""
"The compressed sparse column storage makes it easy and quick to access the elements in the column of a sparse matrix, whereas accessing the "
"sparse matrix by rows is considerably slower. Operations such as insertion of previously unstored entries one at a time in the CSC structure "
"tend to be slow. This is because all elements of the sparse matrix that are beyond the point of insertion have to be moved one place over."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:41
msgid ""
"All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive "
"operations."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:47
msgid ""
"If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based "
"indexing. The row indices in every column need to be sorted. If your `SparseMatrixCSC` object contains unsorted row indices, one quick way "
"to sort them is by doing a double transpose."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:58
msgid ""
"In some applications, it is convenient to store explicit zero values in a `SparseMatrixCSC`. These *are* accepted by functions in `Base` "
"(but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural "
"nonzeros by many routines. The [`nnz`](@ref) function returns the number of elements explicitly stored in the sparse data structure, "
"including structural nonzeros. In order to count the exact number of numerical nonzeros, use [`count(!iszero, x)`](@ref), which inspects "
"every stored element of a sparse matrix. [`dropzeros`](@ref), and the in-place [`dropzeros!`](@ref), can be used to remove stored zeros from "
"the sparse matrix."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:59
#, no-wrap
msgid ""
"julia> A = sparse([1, 2, 3], [1, 2, 3], [0, 2, 0])\n"
"3Ã3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\n"
"  [1, 1]  =  0\n"
"  [2, 2]  =  2\n"
"  [3, 3]  =  0\n"
"\n"
"julia> dropzeros(A)\n"
"3Ã3 SparseMatrixCSC{Int64,Int64} with 1 stored entry:\n"
"  [2, 2]  =  2\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/SparseArrays.md:71
#, no-wrap
msgid "Sparse Vector Storage"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:78
msgid ""
"Sparse vectors are stored in a close analog to compressed sparse column format for sparse matrices. In Julia, sparse vectors have the type "
"[`SparseVector{Tv,Ti}`](@ref) where `Tv` is the type of the stored values and `Ti` the integer type for the indices. The internal "
"representation is as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:79
#, no-wrap
msgid ""
"struct SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}\n"
"    n::Int              # Length of the sparse vector\n"
"    nzind::Vector{Ti}   # Indices of stored values\n"
"    nzval::Vector{Tv}   # Stored values, typically nonzeros\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:89
msgid ""
"As for [`SparseMatrixCSC`](@ref), the `SparseVector` type can also contain explicitly stored zeros. (See [Sparse Matrix Storage](@ref man-"
"csc).)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/SparseArrays.md:90
#, no-wrap
msgid "Sparse Vector and Matrix Constructors"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:96
msgid ""
"The simplest way to create a sparse array is to use a function equivalent to the [`zeros`](@ref)  function that Julia provides for working "
"with dense arrays. To produce a sparse array instead, you can use the same name with an `sp` prefix:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:97
#, no-wrap
msgid ""
"julia> spzeros(3)\n"
"3-element SparseVector{Float64,Int64} with 0 stored entries\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:111
msgid ""
"The [`sparse`](@ref) function is often a handy way to construct sparse arrays. For example, to construct a sparse matrix we can input a "
"vector `I` of row indices, a vector `J` of column indices, and a vector `V` of stored values (this is also known as the [COO (coordinate)  "
"format](https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29)).  `sparse(I,J,V)` then constructs a sparse matrix such that "
"`S[I[k], J[k]] = V[k]`. The equivalent sparse vector constructor is [`sparsevec`](@ref), which takes the (row) index vector `I` and the "
"vector `V` with the stored values and constructs a sparse vector `R` such that `R[I[k]] = V[k]`."
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/stdlib/SparseArrays.md:112 ext/julia/doc/src/stdlib/SparseArrays.md:135
#, no-wrap
msgid "jldoctest sparse_function"
msgstr "jldoctest sparse_function"

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:112
#, no-wrap
msgid ""
"julia> I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];\n"
"\n"
"julia> S = sparse(I,J,V)\n"
"5Ã18 SparseMatrixCSC{Int64,Int64} with 4 stored entries:\n"
"  [1,  4]  =  1\n"
"  [4,  7]  =  2\n"
"  [5,  9]  =  3\n"
"  [3, 18]  =  -5\n"
"\n"
"julia> R = sparsevec(I,V)\n"
"5-element SparseVector{Int64,Int64} with 4 stored entries:\n"
"  [1]  =  1\n"
"  [3]  =  -5\n"
"  [4]  =  2\n"
"  [5]  =  3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:134
msgid ""
"The inverse of the [`sparse`](@ref) and [`sparsevec`](@ref) functions is [`findnz`](@ref), which retrieves the inputs used to create the "
"sparse array.  [`findall(!iszero, x)`](@ref) returns the cartesian indices of non-zero entries in `x` (including stored entries equal to "
"zero)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:135
#, no-wrap
msgid ""
"julia> findnz(S)\n"
"([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])\n"
"\n"
"julia> findall(!iszero, S)\n"
"4-element Array{CartesianIndex{2},1}:\n"
" CartesianIndex(1, 4)\n"
" CartesianIndex(4, 7)\n"
" CartesianIndex(5, 9)\n"
" CartesianIndex(3, 18)\n"
"\n"
"julia> findnz(R)\n"
"([1, 3, 4, 5], [1, -5, 2, 3])\n"
"\n"
"julia> findall(!iszero, R)\n"
"4-element Array{Int64,1}:\n"
" 1\n"
" 3\n"
" 4\n"
" 5\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:159
msgid "Another way to create a sparse array is to convert a dense array into a sparse array using the [`sparse`](@ref) function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:160
#, no-wrap
msgid ""
"julia> sparse(Matrix(1.0I, 5, 5))\n"
"5Ã5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:\n"
"  [1, 1]  =  1.0\n"
"  [2, 2]  =  1.0\n"
"  [3, 3]  =  1.0\n"
"  [4, 4]  =  1.0\n"
"  [5, 5]  =  1.0\n"
"\n"
"julia> sparse([1.0, 0.0, 1.0])\n"
"3-element SparseVector{Float64,Int64} with 2 stored entries:\n"
"  [1]  =  1.0\n"
"  [3]  =  1.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:177
msgid ""
"You can go in the other direction using the [`Array`](@ref) constructor. The [`issparse`](@ref)  function can be used to query if a matrix "
"is sparse."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:178
#, no-wrap
msgid ""
"julia> issparse(spzeros(5))\n"
"true\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/SparseArrays.md:183
#, no-wrap
msgid "Sparse matrix operations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:192
msgid ""
"Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse "
"matrices work in the same way as dense matrices.  Indexing operations, especially assignment, are expensive, when carried out one element at "
"a time.  In many cases it may be better to convert the sparse matrix into `(I,J,V)` format using [`findnz`](@ref), manipulate the values or "
"the structure in the dense vectors `(I,J,V)`, and then reconstruct the sparse matrix."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/SparseArrays.md:193
#, no-wrap
msgid "Correspondence of dense and sparse methods"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:202
msgid ""
"The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix "
"types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same "
"sparsity pattern as a given sparse matrix `S`, or that the resulting sparse matrix has density `d`, i.e. each matrix element has a "
"probability `d` of being non-zero."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:205
msgid "Details can be found in the [Sparse Vectors and Matrices](@ref stdlib-sparse-arrays)  section of the standard library reference."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:214
#, no-wrap
msgid ""
"| Sparse                     | Dense                  | Description                                                                                                                                                           |\n"
"|:-------------------------- |:---------------------- |:--------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n"
"| [`spzeros(m,n)`](@ref)     | [`zeros(m,n)`](@ref)   | Creates a *m*-by-*n* matrix of zeros. ([`spzeros(m,n)`](@ref) is empty.)                                                                                              |\n"
"| [`sparse(I, n, n)`](@ref)  | [`Matrix(I,n,n)`](@ref)| Creates a *n*-by-*n* identity matrix.                                                                                                                                 |\n"
"| [`Array(S)`](@ref)         | [`sparse(A)`](@ref)    | Interconverts between dense and sparse formats.                                                                                                                       |\n"
"| [`sprand(m,n,d)`](@ref)    | [`rand(m,n)`](@ref)    | Creates a *m*-by-*n* random matrix (of density *d*) with iid non-zero elements distributed uniformly on the half-open interval ``[0, 1)``.                            |\n"
"| [`sprandn(m,n,d)`](@ref)   | [`randn(m,n)`](@ref)   | Creates a *m*-by-*n* random matrix (of density *d*) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.                  |\n"
"| [`sprandn(m,n,d,X)`](@ref) | [`randn(m,n,X)`](@ref) | Creates a *m*-by-*n* random matrix (of density *d*) with iid non-zero elements distributed according to the *X* distribution. (Requires the `Distributions` package.) |\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/SparseArrays.md:215
#, no-wrap
msgid "[Sparse Arrays](@id stdlib-sparse-arrays)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SparseArrays.md:217
#, no-wrap
msgid ""
"SparseArrays.AbstractSparseArray\n"
"SparseArrays.AbstractSparseVector\n"
"SparseArrays.AbstractSparseMatrix\n"
"SparseArrays.SparseVector\n"
"SparseArrays.SparseMatrixCSC\n"
"SparseArrays.sparse\n"
"SparseArrays.sparsevec\n"
"SparseArrays.issparse\n"
"SparseArrays.nnz\n"
"SparseArrays.findnz\n"
"SparseArrays.spzeros\n"
"SparseArrays.spdiagm\n"
"SparseArrays.blockdiag\n"
"SparseArrays.sprand\n"
"SparseArrays.sprandn\n"
"SparseArrays.nonzeros\n"
"SparseArrays.rowvals\n"
"SparseArrays.nzrange\n"
"SparseArrays.droptol!\n"
"SparseArrays.dropzeros!\n"
"SparseArrays.dropzeros\n"
"SparseArrays.permute\n"
"permute!{Tv, Ti, Tp <: Integer, Tq <: Integer}(::SparseMatrixCSC{Tv,Ti}, ::SparseMatrixCSC{Tv,Ti}, ::AbstractArray{Tp,1}, ::AbstractArray{Tq,1})\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Pkg.md:1
#, no-wrap
msgid "EditURL = \"https://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/basedocs.md\"\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Pkg.md:5
#, no-wrap
msgid "Pkg"
msgstr "Pkg"

#. type: Plain text
#: ext/julia/doc/src/stdlib/Pkg.md:8
msgid "Pkg ã¯ Julia ã®çµã¿è¾¼ã¿ããã±ã¼ã¸ ããã¼ã¸ã£ã§ãããããã±ã¼ã¸ã®ã¤ã³ã¹ãã¼ã«ãæ´æ°ãåé¤ãªã©ã®æä½ãå¦çãã¾ãã"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Pkg.md:15
#, no-wrap
msgid ""
"!!! note\n"
"    What follows is a very brief introduction to Pkg. For more\n"
"    information on `Project.toml` files, `Manifest.toml` files, package\n"
"    version compatibility (`[compat]`), environments, registries, etc.,\n"
"    it is highly recommended to read the full manual, which is available here:\n"
"    [https://julialang.github.io/Pkg.jl/v1/](https://julialang.github.io/Pkg.jl/v1/).\n"
msgstr ""
"!!!ã¡ã¢\n"
"    ä»¥ä¸ã¯ãPkg ã®éå¸¸ã«ç°¡åãªç´¹ä»ã§ãã\n"
"    `Project.toml` ãã¡ã¤ã«ãã`Manifest.toml` ãã¡ã¤ã«ãããã±ã¼ã¸ã®ãã¼ã¸ã§ã³äºææ§ (`[compat]` )ãç°å¢ãã¬ã¸ã¹ããªã¼ç­ã«é¢ããè©³ç´°æå ±ã«ã¤ãã¦ã¯\n"
"   ä»¥ä¸ã§å¥æå¯è½ãªå®å¨ãªããã¥ã¢ã«ãèª­ããã¨ãå¼·ããå§ããã¾ã: [https://julialang.github.io/Pkg.jl/v1/](https://julialang.github.io/Pkg.jl/v1/)ã\n"

#. type: Plain text
#: ext/julia/doc/src/stdlib/Pkg.md:16
#, no-wrap
msgid ""
"import Markdown\n"
"file = joinpath(Sys.STDLIB, \"Pkg\", \"docs\", \"src\", \"getting-started.md\")\n"
"str = read(file, String)\n"
"str = replace(str, r\"^#.*$\"m => \"\")\n"
"str = replace(str, \"[API Reference](@ref)\" =>\n"
"          \"[API Reference](https://julialang.github.io/Pkg.jl/v1/api/)\")\n"
"Markdown.parse(str)\n"
msgstr ""
"import Markdown\n"
"file = joinpath(Sys.STDLIB, \"Pkg\", \"docs\", \"src\", \"getting-started.md\")\n"
"str = read(file, String)\n"
"str = replace(str, r\"^#.*$\"m => \"\")\n"
"str = replace(str, \"[API Reference](@ref)\" =>\n"
"          \"[API Reference](https://julialang.github.io/Pkg.jl/v1/api/)\")\n"
"Markdown.parse(str)\n"

#. type: Title #
#: ext/julia/doc/src/stdlib/SharedArrays.md:1
#, no-wrap
msgid "Shared Arrays"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/SharedArrays.md:3
#, no-wrap
msgid ""
"SharedArrays.SharedArray\n"
"SharedArrays.SharedVector\n"
"SharedArrays.SharedMatrix\n"
"SharedArrays.procs(::SharedArray)\n"
"SharedArrays.sdata\n"
"SharedArrays.indexpids\n"
"SharedArrays.localindices\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:1
#, no-wrap
msgid "Linear Algebra"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:3
#, no-wrap
msgid "DocTestSetup = :(using LinearAlgebra)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:12
msgid ""
"In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful "
"linear algebra operations which can be loaded with `using LinearAlgebra`. Basic operations, such as [`tr`](@ref), [`det`](@ref), and [`inv`]"
"(@ref) are all supported:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:13
#, no-wrap
msgid ""
"julia> A = [1 2 3; 4 1 6; 7 8 1]\n"
"3Ã3 Array{Int64,2}:\n"
" 1  2  3\n"
" 4  1  6\n"
" 7  8  1\n"
"\n"
"julia> tr(A)\n"
"3\n"
"\n"
"julia> det(A)\n"
"104.0\n"
"\n"
"julia> inv(A)\n"
"3Ã3 Array{Float64,2}:\n"
" -0.451923   0.211538    0.0865385\n"
"  0.365385  -0.192308    0.0576923\n"
"  0.240385   0.0576923  -0.0673077\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:35
msgid "As well as other useful operations, such as finding eigenvalues or eigenvectors:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:36
#, no-wrap
msgid ""
"julia> A = [-4. -17.; 2. 2.]\n"
"2Ã2 Array{Float64,2}:\n"
" -4.0  -17.0\n"
"  2.0    2.0\n"
"\n"
"julia> eigvals(A)\n"
"2-element Array{Complex{Float64},1}:\n"
" -1.0 - 5.0im\n"
" -1.0 + 5.0im\n"
"\n"
"julia> eigvecs(A)\n"
"2Ã2 Array{Complex{Float64},2}:\n"
"  0.945905-0.0im        0.945905+0.0im\n"
" -0.166924+0.278207im  -0.166924-0.278207im\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:59
msgid ""
"In addition, Julia provides many [factorizations](@ref man-linalg-factorizations) which can be used to speed up problems such as linear "
"solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See "
"the documentation on [`factorize`](@ref)  for more information. As an example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:60
#, no-wrap
msgid ""
"julia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]\n"
"3Ã3 Array{Float64,2}:\n"
"   1.5   2.0  -4.0\n"
"   3.0  -1.0  -6.0\n"
" -10.0   2.3   4.0\n"
"\n"
"julia> factorize(A)\n"
"LU{Float64,Array{Float64,2}}\n"
"L factor:\n"
"3Ã3 Array{Float64,2}:\n"
"  1.0    0.0       0.0\n"
" -0.15   1.0       0.0\n"
" -0.3   -0.132196  1.0\n"
"U factor:\n"
"3Ã3 Array{Float64,2}:\n"
" -10.0  2.3     4.0\n"
"   0.0  2.345  -3.4\n"
"   0.0  0.0    -5.24947\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:83
msgid ""
"Since `A` is not Hermitian, symmetric, triangular, tridiagonal, or bidiagonal, an LU factorization may be the best we can do. Compare with:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:84
#, no-wrap
msgid ""
"julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\n"
"3Ã3 Array{Float64,2}:\n"
"  1.5   2.0  -4.0\n"
"  2.0  -1.0  -3.0\n"
" -4.0  -3.0   5.0\n"
"\n"
"julia> factorize(B)\n"
"BunchKaufman{Float64,Array{Float64,2}}\n"
"D factor:\n"
"3Ã3 Tridiagonal{Float64,Array{Float64,1}}:\n"
" -1.64286   0.0   â\n"
"  0.0      -2.8  0.0\n"
"   â        0.0  5.0\n"
"U factor:\n"
"3Ã3 UnitUpperTriangular{Float64,Array{Float64,2}}:\n"
" 1.0  0.142857  -0.8\n"
"  â   1.0       -0.6\n"
"  â    â         1.0\n"
"permutation:\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:115
msgid ""
"Here, Julia was able to detect that `B` is in fact symmetric, and used a more appropriate factorization.  Often it's possible to write more "
"efficient code for a matrix that is known to have certain properties e.g.  it is symmetric, or tridiagonal. Julia provides some special "
"types so that you can \"tag\" matrices as having these properties. For instance:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:116
#, no-wrap
msgid ""
"julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\n"
"3Ã3 Array{Float64,2}:\n"
"  1.5   2.0  -4.0\n"
"  2.0  -1.0  -3.0\n"
" -4.0  -3.0   5.0\n"
"\n"
"julia> sB = Symmetric(B)\n"
"3Ã3 Symmetric{Float64,Array{Float64,2}}:\n"
"  1.5   2.0  -4.0\n"
"  2.0  -1.0  -3.0\n"
" -4.0  -3.0   5.0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:134
msgid ""
"`sB` has been tagged as a matrix that's (real) symmetric, so for later operations we might perform on it, such as eigenfactorization or "
"computing matrix-vector products, efficiencies can be found by only referencing half of it. For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:135
#, no-wrap
msgid ""
"julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\n"
"3Ã3 Array{Float64,2}:\n"
"  1.5   2.0  -4.0\n"
"  2.0  -1.0  -3.0\n"
" -4.0  -3.0   5.0\n"
"\n"
"julia> sB = Symmetric(B)\n"
"3Ã3 Symmetric{Float64,Array{Float64,2}}:\n"
"  1.5   2.0  -4.0\n"
"  2.0  -1.0  -3.0\n"
" -4.0  -3.0   5.0\n"
"\n"
"julia> x = [1; 2; 3]\n"
"3-element Array{Int64,1}:\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"julia> sB\\x\n"
"3-element Array{Float64,1}:\n"
" -1.7391304347826084\n"
" -1.1086956521739126\n"
" -1.4565217391304346\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:163
msgid ""
"The `\\` operation here performs the linear solution. The left-division operator is pretty powerful and it's easy to write compact, readable "
"code that is flexible enough to solve all sorts of systems of linear equations."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:164
#, no-wrap
msgid "ç¹æ®è¡å"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:172
msgid ""
"[Matrices with special symmetries and structures](http://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=3274)  arise often in linear "
"algebra and are frequently associated with various matrix factorizations.  Julia features a rich collection of special matrix types, which "
"allow for fast computation with specialized routines that are specially developed for particular matrix types."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:176
msgid ""
"The following tables summarize the types of special matrices that have been implemented in Julia, as well as whether hooks to various "
"optimized methods for them in LAPACK are available."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:191
#, no-wrap
msgid ""
"| Type                          | Description                                                                                   |\n"
"|:----------------------------- |:--------------------------------------------------------------------------------------------- |\n"
"| [`Symmetric`](@ref)           | [Symmetric matrix](https://en.wikipedia.org/wiki/Symmetric_matrix)                            |\n"
"| [`Hermitian`](@ref)           | [Hermitian matrix](https://en.wikipedia.org/wiki/Hermitian_matrix)                            |\n"
"| [`UpperTriangular`](@ref)     | Upper [triangular matrix](https://en.wikipedia.org/wiki/Triangular_matrix)                    |\n"
"| [`UnitUpperTriangular`](@ref) | Upper [triangular matrix](https://en.wikipedia.org/wiki/Triangular_matrix) with unit diagonal |\n"
"| [`LowerTriangular`](@ref)     | Lower [triangular matrix](https://en.wikipedia.org/wiki/Triangular_matrix)                    |     |\n"
"| [`UnitLowerTriangular`](@ref) | Lower [triangular matrix](https://en.wikipedia.org/wiki/Triangular_matrix) with unit diagonal |\n"
"| [`UpperHessenberg`](@ref)     | Upper [Hessenberg matrix](https://en.wikipedia.org/wiki/Hessenberg_matrix)\n"
"| [`Tridiagonal`](@ref)         | [Tridiagonal matrix](https://en.wikipedia.org/wiki/Tridiagonal_matrix)                        |\n"
"| [`SymTridiagonal`](@ref)      | Symmetric tridiagonal matrix                                                                  |\n"
"| [`Bidiagonal`](@ref)          | Upper/lower [bidiagonal matrix](https://en.wikipedia.org/wiki/Bidiagonal_matrix)              |\n"
"| [`Diagonal`](@ref)            | [Diagonal matrix](https://en.wikipedia.org/wiki/Diagonal_matrix)                              |\n"
"| [`UniformScaling`](@ref)      | [Uniform scaling operator](https://en.wikipedia.org/wiki/Uniform_scaling)                     |\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:192
#, no-wrap
msgid "Elementary operations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:208
#, no-wrap
msgid ""
"| Matrix type                   | `+` | `-` | `*` | `\\` | Other functions with optimized methods                      |\n"
"|:----------------------------- |:--- |:--- |:--- |:--- |:----------------------------------------------------------- |\n"
"| [`Symmetric`](@ref)           |     |     |     | MV  | [`inv`](@ref), [`sqrt`](@ref), [`exp`](@ref)                |\n"
"| [`Hermitian`](@ref)           |     |     |     | MV  | [`inv`](@ref), [`sqrt`](@ref), [`exp`](@ref)                |\n"
"| [`UpperTriangular`](@ref)     |     |     | MV  | MV  | [`inv`](@ref), [`det`](@ref)                                |\n"
"| [`UnitUpperTriangular`](@ref) |     |     | MV  | MV  | [`inv`](@ref), [`det`](@ref)                                |\n"
"| [`LowerTriangular`](@ref)     |     |     | MV  | MV  | [`inv`](@ref), [`det`](@ref)                                |\n"
"| [`UnitLowerTriangular`](@ref) |     |     | MV  | MV  | [`inv`](@ref), [`det`](@ref)                                |\n"
"| [`UpperHessenberg`](@ref)     |     |     |     | MM  | [`inv`](@ref), [`det`](@ref)                                |\n"
"| [`SymTridiagonal`](@ref)      | M   | M   | MS  | MV  | [`eigmax`](@ref), [`eigmin`](@ref)                          |\n"
"| [`Tridiagonal`](@ref)         | M   | M   | MS  | MV  |                                                             |\n"
"| [`Bidiagonal`](@ref)          | M   | M   | MS  | MV  |                                                             |\n"
"| [`Diagonal`](@ref)            | M   | M   | MV  | MV  | [`inv`](@ref), [`det`](@ref), [`logdet`](@ref), [`/`](@ref) |\n"
"| [`UniformScaling`](@ref)      | M   | M   | MVS | MVS | [`/`](@ref)                                                 |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:210 ext/julia/doc/src/stdlib/LinearAlgebra.md:233
msgid "Legend:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:216
#, no-wrap
msgid ""
"| Key        | Description                                                   |\n"
"|:---------- |:------------------------------------------------------------- |\n"
"| M (matrix) | An optimized method for matrix-matrix operations is available |\n"
"| V (vector) | An optimized method for matrix-vector operations is available |\n"
"| S (scalar) | An optimized method for matrix-scalar operations is available |\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:217
#, no-wrap
msgid "Matrix factorizations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:231
#, no-wrap
msgid ""
"| Matrix type                   | LAPACK | [`eigen`](@ref) | [`eigvals`](@ref) | [`eigvecs`](@ref) | [`svd`](@ref) | [`svdvals`](@ref) |\n"
"|:----------------------------- |:------ |:------------- |:----------------- |:----------------- |:------------- |:----------------- |\n"
"| [`Symmetric`](@ref)           | SY     |               | ARI               |                   |               |                   |\n"
"| [`Hermitian`](@ref)           | HE     |               | ARI               |                   |               |                   |\n"
"| [`UpperTriangular`](@ref)     | TR     | A             | A                 | A                 |               |                   |\n"
"| [`UnitUpperTriangular`](@ref) | TR     | A             | A                 | A                 |               |                   |\n"
"| [`LowerTriangular`](@ref)     | TR     | A             | A                 | A                 |               |                   |\n"
"| [`UnitLowerTriangular`](@ref) | TR     | A             | A                 | A                 |               |                   |\n"
"| [`SymTridiagonal`](@ref)      | ST     | A             | ARI               | AV                |               |                   |\n"
"| [`Tridiagonal`](@ref)         | GT     |               |                   |                   |               |                   |\n"
"| [`Bidiagonal`](@ref)          | BD     |               |                   |                   | A             | A                 |\n"
"| [`Diagonal`](@ref)            | DI     |               | A                 |                   |               |                   |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:240
#, no-wrap
msgid ""
"| Key          | Description                                                                                                                     | Example              |\n"
"|:------------ |:------------------------------------------------------------------------------------------------------------------------------- |:-------------------- |\n"
"| A (all)      | An optimized method to find all the characteristic values and/or vectors is available                                           | e.g. `eigvals(M)`    |\n"
"| R (range)    | An optimized method to find the `il`th through the `ih`th characteristic values are available                                   | `eigvals(M, il, ih)` |\n"
"| I (interval) | An optimized method to find the characteristic values in the interval [`vl`, `vh`] is available                                 | `eigvals(M, vl, vh)` |\n"
"| V (vectors)  | An optimized method to find the characteristic vectors corresponding to the characteristic values `x=[x1, x2,...]` is available | `eigvecs(M, x)`      |\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:241
#, no-wrap
msgid "The uniform scaling operator"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:251
msgid ""
"A [`UniformScaling`](@ref) operator represents a scalar times the identity operator, `Î»*I`. The identity operator `I` is defined as a "
"constant and is an instance of `UniformScaling`. The size of these operators are generic and match the other matrix in the binary operations "
"[`+`](@ref), [`-`](@ref), [`*`](@ref) and [`\\`](@ref). For `A+I` and `A-I` this means that `A` must be square. Multiplication with the "
"identity operator `I` is a noop (except for checking that the scaling factor is one)  and therefore almost without overhead."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:253
msgid "To see the `UniformScaling` operator in action:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:254
#, no-wrap
msgid ""
"julia> U = UniformScaling(2);\n"
"\n"
"julia> a = [1 2; 3 4]\n"
"2Ã2 Array{Int64,2}:\n"
" 1  2\n"
" 3  4\n"
"\n"
"julia> a + U\n"
"2Ã2 Array{Int64,2}:\n"
" 3  2\n"
" 3  6\n"
"\n"
"julia> a * U\n"
"2Ã2 Array{Int64,2}:\n"
" 2  4\n"
" 6  8\n"
"\n"
"julia> [a U]\n"
"2Ã4 Array{Int64,2}:\n"
" 1  2  2  0\n"
" 3  4  0  2\n"
"\n"
"julia> b = [1 2 3; 4 5 6]\n"
"2Ã3 Array{Int64,2}:\n"
" 1  2  3\n"
" 4  5  6\n"
"\n"
"julia> b - U\n"
"ERROR: DimensionMismatch(\"matrix is not square: dimensions are (2, 3)\")\n"
"Stacktrace:\n"
"[...]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:293
msgid ""
"If you need to solve many systems of the form `(A+Î¼I)x = b` for the same `A` and different `Î¼`, it might be beneficial to first compute the "
"Hessenberg factorization `F` of `A` via the [`hessenberg`](@ref) function.  Given `F`, Julia employs an efficient algorithm for `(F+Î¼*I) \\ "
"b` (equivalent to `(A+Î¼*I)x \\ b`) and related operations like determinants."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:295
#, no-wrap
msgid "[Matrix factorizations](@id man-linalg-factorizations)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:301
msgid ""
"[Matrix factorizations (a.k.a. matrix decompositions)](https://en.wikipedia.org/wiki/Matrix_decomposition)  compute the factorization of a "
"matrix into a product of matrices, and are one of the central concepts in linear algebra."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:306
msgid ""
"The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods "
"can be found in the [Standard Functions](@ref) section of the Linear Algebra documentation."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:325
#, no-wrap
msgid ""
"| Type               | Description                                                                                                    |\n"
"|:------------------ |:-------------------------------------------------------------------------------------------------------------- |\n"
"| `BunchKaufman`     | Bunch-Kaufman factorization                                                                                    |\n"
"| `Cholesky`         | [Cholesky factorization](https://en.wikipedia.org/wiki/Cholesky_decomposition)                                 |\n"
"| `CholeskyPivoted`  | [Pivoted](https://en.wikipedia.org/wiki/Pivot_element) Cholesky factorization                                  |\n"
"| `LDLt`             | [LDL(T) factorization](https://en.wikipedia.org/wiki/Cholesky_decomposition#LDL_decomposition)                 |\n"
"| `LU`               | [LU factorization](https://en.wikipedia.org/wiki/LU_decomposition)                                             |\n"
"| `QR`               | [QR factorization](https://en.wikipedia.org/wiki/QR_decomposition)                                             |\n"
"| `QRCompactWY`      | Compact WY form of the QR factorization                                                                        |\n"
"| `QRPivoted`        | Pivoted [QR factorization](https://en.wikipedia.org/wiki/QR_decomposition)                                     |\n"
"| `LQ`               | [QR factorization](https://en.wikipedia.org/wiki/QR_decomposition) of `transpose(A)`                           |\n"
"| `Hessenberg`       | [Hessenberg decomposition](http://mathworld.wolfram.com/HessenbergDecomposition.html)                          |\n"
"| `Eigen`            | [Spectral decomposition](https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix)                         |\n"
"| `GeneralizedEigen` | [Generalized spectral decomposition](https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix#Generalized_eigenvalue_problem)                            |\n"
"| `SVD`              | [Singular value decomposition](https://en.wikipedia.org/wiki/Singular_value_decomposition)                     |\n"
"| `GeneralizedSVD`   | [Generalized SVD](https://en.wikipedia.org/wiki/Generalized_singular_value_decomposition#Higher_order_version) |\n"
"| `Schur`            | [Schur decomposition](https://en.wikipedia.org/wiki/Schur_decomposition)                                       |\n"
"| `GeneralizedSchur` | [Generalized Schur decomposition](https://en.wikipedia.org/wiki/Schur_decomposition#Generalized_Schur_decomposition) |\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:328
#, no-wrap
msgid "Standard Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:332
#, no-wrap
msgid ""
"Linear algebra functions in Julia are largely implemented by calling functions from [LAPACK](http://www.netlib.org/lapack/).\n"
" Sparse factorizations call functions from [SuiteSparse](http://faculty.cse.tamu.edu/davis/suitesparse.html).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:333
#, no-wrap
msgid ""
"Base.:*(::AbstractMatrix, ::AbstractMatrix)\n"
"Base.:\\(::AbstractMatrix, ::AbstractVecOrMat)\n"
"LinearAlgebra.SingularException\n"
"LinearAlgebra.PosDefException\n"
"LinearAlgebra.dot\n"
"LinearAlgebra.cross\n"
"LinearAlgebra.factorize\n"
"LinearAlgebra.Diagonal\n"
"LinearAlgebra.Bidiagonal\n"
"LinearAlgebra.SymTridiagonal\n"
"LinearAlgebra.Tridiagonal\n"
"LinearAlgebra.Symmetric\n"
"LinearAlgebra.Hermitian\n"
"LinearAlgebra.LowerTriangular\n"
"LinearAlgebra.UpperTriangular\n"
"LinearAlgebra.UnitLowerTriangular\n"
"LinearAlgebra.UnitUpperTriangular\n"
"LinearAlgebra.UpperHessenberg\n"
"LinearAlgebra.UniformScaling\n"
"LinearAlgebra.Factorization\n"
"LinearAlgebra.LU\n"
"LinearAlgebra.lu\n"
"LinearAlgebra.lu!\n"
"LinearAlgebra.Cholesky\n"
"LinearAlgebra.CholeskyPivoted\n"
"LinearAlgebra.cholesky\n"
"LinearAlgebra.cholesky!\n"
"LinearAlgebra.lowrankupdate\n"
"LinearAlgebra.lowrankdowndate\n"
"LinearAlgebra.lowrankupdate!\n"
"LinearAlgebra.lowrankdowndate!\n"
"LinearAlgebra.LDLt\n"
"LinearAlgebra.ldlt\n"
"LinearAlgebra.ldlt!\n"
"LinearAlgebra.QR\n"
"LinearAlgebra.QRCompactWY\n"
"LinearAlgebra.QRPivoted\n"
"LinearAlgebra.qr\n"
"LinearAlgebra.qr!\n"
"LinearAlgebra.LQ\n"
"LinearAlgebra.lq\n"
"LinearAlgebra.lq!\n"
"LinearAlgebra.BunchKaufman\n"
"LinearAlgebra.bunchkaufman\n"
"LinearAlgebra.bunchkaufman!\n"
"LinearAlgebra.Eigen\n"
"LinearAlgebra.GeneralizedEigen\n"
"LinearAlgebra.eigvals\n"
"LinearAlgebra.eigvals!\n"
"LinearAlgebra.eigmax\n"
"LinearAlgebra.eigmin\n"
"LinearAlgebra.eigvecs\n"
"LinearAlgebra.eigen\n"
"LinearAlgebra.eigen!\n"
"LinearAlgebra.Hessenberg\n"
"LinearAlgebra.hessenberg\n"
"LinearAlgebra.hessenberg!\n"
"LinearAlgebra.Schur\n"
"LinearAlgebra.GeneralizedSchur\n"
"LinearAlgebra.schur\n"
"LinearAlgebra.schur!\n"
"LinearAlgebra.ordschur\n"
"LinearAlgebra.ordschur!\n"
"LinearAlgebra.SVD\n"
"LinearAlgebra.GeneralizedSVD\n"
"LinearAlgebra.svd\n"
"LinearAlgebra.svd!\n"
"LinearAlgebra.svdvals\n"
"LinearAlgebra.svdvals!\n"
"LinearAlgebra.Givens\n"
"LinearAlgebra.givens\n"
"LinearAlgebra.triu\n"
"LinearAlgebra.triu!\n"
"LinearAlgebra.tril\n"
"LinearAlgebra.tril!\n"
"LinearAlgebra.diagind\n"
"LinearAlgebra.diag\n"
"LinearAlgebra.diagm\n"
"LinearAlgebra.rank\n"
"LinearAlgebra.norm\n"
"LinearAlgebra.opnorm\n"
"LinearAlgebra.normalize!\n"
"LinearAlgebra.normalize\n"
"LinearAlgebra.cond\n"
"LinearAlgebra.condskeel\n"
"LinearAlgebra.tr\n"
"LinearAlgebra.det\n"
"LinearAlgebra.logdet\n"
"LinearAlgebra.logabsdet\n"
"Base.inv(::AbstractMatrix)\n"
"LinearAlgebra.pinv\n"
"LinearAlgebra.nullspace\n"
"Base.kron\n"
"LinearAlgebra.exp(::StridedMatrix{<:LinearAlgebra.BlasFloat})\n"
"Base.:^(::AbstractMatrix, ::Number)\n"
"Base.:^(::Number, ::AbstractMatrix)\n"
"LinearAlgebra.log(::StridedMatrix)\n"
"LinearAlgebra.sqrt(::StridedMatrix{<:Real})\n"
"LinearAlgebra.cos(::StridedMatrix{<:Real})\n"
"LinearAlgebra.sin(::StridedMatrix{<:Real})\n"
"LinearAlgebra.sincos(::StridedMatrix{<:Real})\n"
"LinearAlgebra.tan(::StridedMatrix{<:Real})\n"
"LinearAlgebra.sec(::StridedMatrix)\n"
"LinearAlgebra.csc(::StridedMatrix)\n"
"LinearAlgebra.cot(::StridedMatrix)\n"
"LinearAlgebra.cosh(::StridedMatrix)\n"
"LinearAlgebra.sinh(::StridedMatrix)\n"
"LinearAlgebra.tanh(::StridedMatrix)\n"
"LinearAlgebra.sech(::StridedMatrix)\n"
"LinearAlgebra.csch(::StridedMatrix)\n"
"LinearAlgebra.coth(::StridedMatrix)\n"
"LinearAlgebra.acos(::StridedMatrix)\n"
"LinearAlgebra.asin(::StridedMatrix)\n"
"LinearAlgebra.atan(::StridedMatrix)\n"
"LinearAlgebra.asec(::StridedMatrix)\n"
"LinearAlgebra.acsc(::StridedMatrix)\n"
"LinearAlgebra.acot(::StridedMatrix)\n"
"LinearAlgebra.acosh(::StridedMatrix)\n"
"LinearAlgebra.asinh(::StridedMatrix)\n"
"LinearAlgebra.atanh(::StridedMatrix)\n"
"LinearAlgebra.asech(::StridedMatrix)\n"
"LinearAlgebra.acsch(::StridedMatrix)\n"
"LinearAlgebra.acoth(::StridedMatrix)\n"
"LinearAlgebra.lyap\n"
"LinearAlgebra.sylvester\n"
"LinearAlgebra.issuccess\n"
"LinearAlgebra.issymmetric\n"
"LinearAlgebra.isposdef\n"
"LinearAlgebra.isposdef!\n"
"LinearAlgebra.istril\n"
"LinearAlgebra.istriu\n"
"LinearAlgebra.isdiag\n"
"LinearAlgebra.ishermitian\n"
"Base.transpose\n"
"LinearAlgebra.transpose!\n"
"LinearAlgebra.Transpose\n"
"Base.adjoint\n"
"LinearAlgebra.adjoint!\n"
"LinearAlgebra.Adjoint\n"
"Base.copy(::Union{Transpose,Adjoint})\n"
"LinearAlgebra.stride1\n"
"LinearAlgebra.checksquare\n"
"LinearAlgebra.peakflops\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:479
#, no-wrap
msgid "Low-level matrix operations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:486
msgid ""
"In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix.  This is "
"useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with `!` "
"below (e.g. `mul!`) according to the usual Julia convention."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:487
#, no-wrap
msgid ""
"LinearAlgebra.mul!\n"
"LinearAlgebra.lmul!\n"
"LinearAlgebra.rmul!\n"
"LinearAlgebra.ldiv!\n"
"LinearAlgebra.rdiv!\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:495
#, no-wrap
msgid "BLAS Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:504
msgid ""
"In Julia (as in much of scientific computation), dense linear-algebra operations are based on the [LAPACK library](http://www.netlib.org/"
"lapack/), which in turn is built on top of basic linear-algebra building-blocks known as the [BLAS](http://www.netlib.org/blas/). There are "
"highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra "
"routines it is useful to call the BLAS functions directly."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:509
msgid ""
"`LinearAlgebra.BLAS` provides wrappers for some of the BLAS functions. Those BLAS functions that overwrite one of the input arrays have "
"names ending in `'!'`.  Usually, a BLAS function has four methods defined, for [`Float64`](@ref), [`Float32`](@ref), `ComplexF64`, and "
"`ComplexF32` arrays."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:510
#, no-wrap
msgid "[BLAS Character Arguments](@id stdlib-blas-chars)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:516
msgid ""
"Many BLAS functions accept arguments that determine whether to transpose an argument (`trans`), which triangle of a matrix to reference "
"(`uplo` or `ul`), whether the diagonal of a triangular matrix can be assumed to be all ones (`dA`) or which side of a matrix multiplication "
"the input argument belongs on (`side`). The possibilities are:"
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:517
#, no-wrap
msgid "[Multplication Order](@id stdlib-blas-side)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:522
#, no-wrap
msgid ""
"| `side` | Meaning                                                             |\n"
"|:-------|:--------------------------------------------------------------------|\n"
"| `'L'`  | The argument goes on the *left* side of a matrix-matrix operation.  |\n"
"| `'R'`  | The argument goes on the *right* side of a matrix-matrix operation. |\n"
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:523
#, no-wrap
msgid "[Triangle Referencing](@id stdlib-blas-uplo)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:528
#, no-wrap
msgid ""
"| `uplo`/`ul` | Meaning                                               |\n"
"|:------------|:------------------------------------------------------|\n"
"| `'U'`       | Only the *upper* triangle of the matrix will be used. |\n"
"| `'L'`       | Only the *lower* triangle of the matrix will be used. |\n"
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:529
#, no-wrap
msgid "[Transposition Operation](@id stdlib-blas-trans)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:535
#, no-wrap
msgid ""
"| `trans`/`tX` | Meaning                                                 |\n"
"|:-------------|:--------------------------------------------------------|\n"
"| `'N'`        | The input matrix `X` is not transposed or conjugated.   |\n"
"| `'T'`        | The input matrix `X` will be transposed.                |\n"
"| `'C'`        | The input matrix `X` will be conjugated and transposed. |\n"
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:536
#, no-wrap
msgid "[Unit Diagonal](@id stdlib-blas-diag)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:541
#, no-wrap
msgid ""
"| `diag`/`dX` | Meaning                                                   |\n"
"|:------------|:----------------------------------------------------------|\n"
"| `'N'`       | The diagonal values of the matrix `X` will be read.       |\n"
"| `'U'`       | The diagonal of the matrix `X` is assumed to be all ones. |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:542
#, no-wrap
msgid ""
"LinearAlgebra.BLAS\n"
"LinearAlgebra.BLAS.dot\n"
"LinearAlgebra.BLAS.dotu\n"
"LinearAlgebra.BLAS.dotc\n"
"LinearAlgebra.BLAS.blascopy!\n"
"LinearAlgebra.BLAS.nrm2\n"
"LinearAlgebra.BLAS.asum\n"
"LinearAlgebra.axpy!\n"
"LinearAlgebra.axpby!\n"
"LinearAlgebra.BLAS.scal!\n"
"LinearAlgebra.BLAS.scal\n"
"LinearAlgebra.BLAS.iamax\n"
"LinearAlgebra.BLAS.ger!\n"
"LinearAlgebra.BLAS.syr!\n"
"LinearAlgebra.BLAS.syrk!\n"
"LinearAlgebra.BLAS.syrk\n"
"LinearAlgebra.BLAS.her!\n"
"LinearAlgebra.BLAS.herk!\n"
"LinearAlgebra.BLAS.herk\n"
"LinearAlgebra.BLAS.gbmv!\n"
"LinearAlgebra.BLAS.gbmv\n"
"LinearAlgebra.BLAS.sbmv!\n"
"LinearAlgebra.BLAS.sbmv(::Any, ::Any, ::Any, ::Any, ::Any)\n"
"LinearAlgebra.BLAS.sbmv(::Any, ::Any, ::Any, ::Any)\n"
"LinearAlgebra.BLAS.gemm!\n"
"LinearAlgebra.BLAS.gemm(::Any, ::Any, ::Any, ::Any, ::Any)\n"
"LinearAlgebra.BLAS.gemm(::Any, ::Any, ::Any, ::Any)\n"
"LinearAlgebra.BLAS.gemv!\n"
"LinearAlgebra.BLAS.gemv(::Any, ::Any, ::Any, ::Any)\n"
"LinearAlgebra.BLAS.gemv(::Any, ::Any, ::Any)\n"
"LinearAlgebra.BLAS.symm!\n"
"LinearAlgebra.BLAS.symm(::Any, ::Any, ::Any, ::Any, ::Any)\n"
"LinearAlgebra.BLAS.symm(::Any, ::Any, ::Any, ::Any)\n"
"LinearAlgebra.BLAS.symv!\n"
"LinearAlgebra.BLAS.symv(::Any, ::Any, ::Any, ::Any)\n"
"LinearAlgebra.BLAS.symv(::Any, ::Any, ::Any)\n"
"LinearAlgebra.BLAS.trmm!\n"
"LinearAlgebra.BLAS.trmm\n"
"LinearAlgebra.BLAS.trsm!\n"
"LinearAlgebra.BLAS.trsm\n"
"LinearAlgebra.BLAS.trmv!\n"
"LinearAlgebra.BLAS.trmv\n"
"LinearAlgebra.BLAS.trsv!\n"
"LinearAlgebra.BLAS.trsv\n"
"LinearAlgebra.BLAS.set_num_threads\n"
"LinearAlgebra.I\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:591
#, no-wrap
msgid "LAPACK Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:595
#, no-wrap
msgid ""
"`LinearAlgebra.LAPACK` provides wrappers for some of the LAPACK functions for linear algebra.\n"
" Those functions that overwrite one of the input arrays have names ending in `'!'`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:598
msgid "Usually a function has 4 methods defined, one each for [`Float64`](@ref), [`Float32`](@ref), `ComplexF64` and `ComplexF32` arrays."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:602
msgid ""
"Note that the LAPACK API provided by Julia can and will change in the future. Since this API is not user-facing, there is no commitment to "
"support/deprecate this specific set of functions in future releases."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/LinearAlgebra.md:603
#, no-wrap
msgid ""
"LinearAlgebra.LAPACK\n"
"LinearAlgebra.LAPACK.gbtrf!\n"
"LinearAlgebra.LAPACK.gbtrs!\n"
"LinearAlgebra.LAPACK.gebal!\n"
"LinearAlgebra.LAPACK.gebak!\n"
"LinearAlgebra.LAPACK.gebrd!\n"
"LinearAlgebra.LAPACK.gelqf!\n"
"LinearAlgebra.LAPACK.geqlf!\n"
"LinearAlgebra.LAPACK.geqrf!\n"
"LinearAlgebra.LAPACK.geqp3!\n"
"LinearAlgebra.LAPACK.gerqf!\n"
"LinearAlgebra.LAPACK.geqrt!\n"
"LinearAlgebra.LAPACK.geqrt3!\n"
"LinearAlgebra.LAPACK.getrf!\n"
"LinearAlgebra.LAPACK.tzrzf!\n"
"LinearAlgebra.LAPACK.ormrz!\n"
"LinearAlgebra.LAPACK.gels!\n"
"LinearAlgebra.LAPACK.gesv!\n"
"LinearAlgebra.LAPACK.getrs!\n"
"LinearAlgebra.LAPACK.getri!\n"
"LinearAlgebra.LAPACK.gesvx!\n"
"LinearAlgebra.LAPACK.gelsd!\n"
"LinearAlgebra.LAPACK.gelsy!\n"
"LinearAlgebra.LAPACK.gglse!\n"
"LinearAlgebra.LAPACK.geev!\n"
"LinearAlgebra.LAPACK.gesdd!\n"
"LinearAlgebra.LAPACK.gesvd!\n"
"LinearAlgebra.LAPACK.ggsvd!\n"
"LinearAlgebra.LAPACK.ggsvd3!\n"
"LinearAlgebra.LAPACK.geevx!\n"
"LinearAlgebra.LAPACK.ggev!\n"
"LinearAlgebra.LAPACK.gtsv!\n"
"LinearAlgebra.LAPACK.gttrf!\n"
"LinearAlgebra.LAPACK.gttrs!\n"
"LinearAlgebra.LAPACK.orglq!\n"
"LinearAlgebra.LAPACK.orgqr!\n"
"LinearAlgebra.LAPACK.orgql!\n"
"LinearAlgebra.LAPACK.orgrq!\n"
"LinearAlgebra.LAPACK.ormlq!\n"
"LinearAlgebra.LAPACK.ormqr!\n"
"LinearAlgebra.LAPACK.ormql!\n"
"LinearAlgebra.LAPACK.ormrq!\n"
"LinearAlgebra.LAPACK.gemqrt!\n"
"LinearAlgebra.LAPACK.posv!\n"
"LinearAlgebra.LAPACK.potrf!\n"
"LinearAlgebra.LAPACK.potri!\n"
"LinearAlgebra.LAPACK.potrs!\n"
"LinearAlgebra.LAPACK.pstrf!\n"
"LinearAlgebra.LAPACK.ptsv!\n"
"LinearAlgebra.LAPACK.pttrf!\n"
"LinearAlgebra.LAPACK.pttrs!\n"
"LinearAlgebra.LAPACK.trtri!\n"
"LinearAlgebra.LAPACK.trtrs!\n"
"LinearAlgebra.LAPACK.trcon!\n"
"LinearAlgebra.LAPACK.trevc!\n"
"LinearAlgebra.LAPACK.trrfs!\n"
"LinearAlgebra.LAPACK.stev!\n"
"LinearAlgebra.LAPACK.stebz!\n"
"LinearAlgebra.LAPACK.stegr!\n"
"LinearAlgebra.LAPACK.stein!\n"
"LinearAlgebra.LAPACK.syconv!\n"
"LinearAlgebra.LAPACK.sysv!\n"
"LinearAlgebra.LAPACK.sytrf!\n"
"LinearAlgebra.LAPACK.sytri!\n"
"LinearAlgebra.LAPACK.sytrs!\n"
"LinearAlgebra.LAPACK.hesv!\n"
"LinearAlgebra.LAPACK.hetrf!\n"
"LinearAlgebra.LAPACK.hetri!\n"
"LinearAlgebra.LAPACK.hetrs!\n"
"LinearAlgebra.LAPACK.syev!\n"
"LinearAlgebra.LAPACK.syevr!\n"
"LinearAlgebra.LAPACK.sygvd!\n"
"LinearAlgebra.LAPACK.bdsqr!\n"
"LinearAlgebra.LAPACK.bdsdc!\n"
"LinearAlgebra.LAPACK.gecon!\n"
"LinearAlgebra.LAPACK.gehrd!\n"
"LinearAlgebra.LAPACK.orghr!\n"
"LinearAlgebra.LAPACK.gees!\n"
"LinearAlgebra.LAPACK.gges!\n"
"LinearAlgebra.LAPACK.trexc!\n"
"LinearAlgebra.LAPACK.trsen!\n"
"LinearAlgebra.LAPACK.tgsen!\n"
"LinearAlgebra.LAPACK.trsyl!\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Sockets.md:3
#, no-wrap
msgid ""
"Sockets.Sockets\n"
"Sockets.connect(::TCPSocket, ::Integer)\n"
"Sockets.connect(::AbstractString)\n"
"Sockets.listen(::Any)\n"
"Sockets.listen(::AbstractString)\n"
"Sockets.getaddrinfo\n"
"Sockets.getipaddr\n"
"Sockets.getipaddrs\n"
"Sockets.getalladdrinfo\n"
"Sockets.getnameinfo\n"
"Sockets.getsockname\n"
"Sockets.getpeername\n"
"Sockets.IPAddr\n"
"Sockets.IPv4\n"
"Sockets.IPv6\n"
"Sockets.@ip_str\n"
"Sockets.TCPSocket\n"
"Sockets.UDPSocket\n"
"Sockets.accept\n"
"Sockets.listenany\n"
"Sockets.bind\n"
"Sockets.send\n"
"Sockets.recv\n"
"Sockets.recvfrom\n"
"Sockets.setopt\n"
"Sockets.nagle\n"
"Sockets.quickack\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Test.md:1
#, no-wrap
msgid "Unit Testing"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:3
#, no-wrap
msgid "DocTestSetup = :(using Test)\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Test.md:7
#, no-wrap
msgid "Testing Base Julia"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:13
msgid ""
"Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from "
"source, you can run this test suite with `make test`.  In a binary install, you can run the test suite using `Base.runtests()`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:14
#, no-wrap
msgid "Base.runtests\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Test.md:18
#, no-wrap
msgid "Basic Unit Tests"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:25
msgid ""
"The `Test` module provides simple *unit testing* functionality. Unit testing is a way to see if your code is correct by checking that the "
"results are what you expect. It can be helpful to ensure your code still works after you make changes, and can be used when developing as a "
"way of specifying the behaviors your code should have when complete."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:28
msgid "Simple unit testing can be performed with the `@test` and `@test_throws` macros:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:29
#, no-wrap
msgid ""
"Test.@test\n"
"Test.@test_throws\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:36
msgid "For example, suppose we want to check our new function `foo(x)` works as expected:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/stdlib/Test.md:37 ext/julia/doc/src/stdlib/Test.md:46 ext/julia/doc/src/stdlib/Test.md:57
#: ext/julia/doc/src/stdlib/Test.md:88 ext/julia/doc/src/stdlib/Test.md:113 ext/julia/doc/src/stdlib/Test.md:125
#, no-wrap
msgid "jldoctest testfoo"
msgstr "jldoctest testfoo"

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:37
#, no-wrap
msgid ""
"julia> using Test\n"
"\n"
"julia> foo(x) = length(x)^2\n"
"foo (generic function with 1 method)\n"
msgstr ""
"julia> using Test\n"
"\n"
"julia> foo(x) = length(x)^2\n"
"foo (generic function with 1 method)\n"

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:45
msgid "If the condition is true, a `Pass` is returned:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:46
#, no-wrap
msgid ""
"julia> @test foo(\"bar\") == 9\n"
"Test Passed\n"
"\n"
"julia> @test foo(\"fizz\") >= 10\n"
"Test Passed\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:56
msgid "If the condition is false, then a `Fail` is returned and an exception is thrown:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:57
#, no-wrap
msgid ""
"julia> @test foo(\"f\") == 20\n"
"Test Failed at none:1\n"
"  Expression: foo(\"f\") == 20\n"
"   Evaluated: 1 == 20\n"
"ERROR: There was an error during testing\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:68
msgid ""
"If the condition could not be evaluated because an exception was thrown, which occurs in this case because `length` is not defined for "
"symbols, an `Error` object is returned and an exception is thrown:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:69
#, no-wrap
msgid ""
"julia> @test foo(:cat) == 1\n"
"Error During Test\n"
"  Test threw an exception of type MethodError\n"
"  Expression: foo(:cat) == 1\n"
"  MethodError: no method matching length(::Symbol)\n"
"  Closest candidates are:\n"
"    length(::SimpleVector) at essentials.jl:256\n"
"    length(::Base.MethodList) at reflection.jl:521\n"
"    length(::MethodTable) at reflection.jl:597\n"
"    ...\n"
"  Stacktrace:\n"
"  [...]\n"
"ERROR: There was an error during testing\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:87
msgid "If we expect that evaluating an expression *should* throw an exception, then we can use `@test_throws` to check that this occurs:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:88
#, no-wrap
msgid ""
"julia> @test_throws MethodError foo(:cat)\n"
"Test Passed\n"
"      Thrown: MethodError\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Test.md:94
#, no-wrap
msgid "Working with Test Sets"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:101
msgid ""
"Typically a large number of tests are used to make sure functions work correctly over a range of inputs. In the event a test fails, the "
"default behavior is to throw an exception immediately.  However, it is normally preferable to run the rest of the tests first to get a "
"better picture of how many errors there are in the code being tested."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:106
msgid ""
"The `@testset` macro can be used to group tests into *sets*. All the tests in a test set will be run, and at the end of the test set a "
"summary will be printed. If any of the tests failed, or could not be evaluated due to an error, the test set will then throw a "
"`TestSetException`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:107
#, no-wrap
msgid "Test.@testset\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:112
msgid "We can put our tests for the `foo(x)` function in a test set:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:113
#, no-wrap
msgid ""
"julia> @testset \"Foo Tests\" begin\n"
"           @test foo(\"a\")   == 1\n"
"           @test foo(\"ab\")  == 4\n"
"           @test foo(\"abc\") == 9\n"
"       end;\n"
"Test Summary: | Pass  Total\n"
"Foo Tests     |    3      3\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:124
msgid "Test sets can also be nested:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:125
#, no-wrap
msgid ""
"julia> @testset \"Foo Tests\" begin\n"
"           @testset \"Animals\" begin\n"
"               @test foo(\"cat\") == 9\n"
"               @test foo(\"dog\") == foo(\"cat\")\n"
"           end\n"
"           @testset \"Arrays $i\" for i in 1:3\n"
"               @test foo(zeros(i)) == i^2\n"
"               @test foo(fill(1.0, i)) == i^2\n"
"           end\n"
"       end;\n"
"Test Summary: | Pass  Total\n"
"Foo Tests     |    8      8\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:143
msgid ""
"In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only "
"the details for the failed test sets will be shown:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:144
#, no-wrap
msgid ""
"julia> @testset \"Foo Tests\" begin\n"
"           @testset \"Animals\" begin\n"
"               @testset \"Felines\" begin\n"
"                   @test foo(\"cat\") == 9\n"
"               end\n"
"               @testset \"Canines\" begin\n"
"                   @test foo(\"dog\") == 9\n"
"               end\n"
"           end\n"
"           @testset \"Arrays\" begin\n"
"               @test foo(zeros(2)) == 4\n"
"               @test foo(fill(1.0, 4)) == 15\n"
"           end\n"
"       end\n"
"\n"
"Arrays: Test Failed\n"
"  Expression: foo(fill(1.0, 4)) == 15\n"
"   Evaluated: 16 == 15\n"
"[...]\n"
"Test Summary: | Pass  Fail  Total\n"
"Foo Tests     |    3     1      4\n"
"  Animals     |    2            2\n"
"  Arrays      |    1     1      2\n"
"ERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Test.md:171
#, no-wrap
msgid "Other Test Macros"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:177
msgid ""
"As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either `@test a â b` (where "
"`â`, typed via tab completion of `\\approx`, is the [`isapprox`](@ref) function) or use [`isapprox`](@ref) directly."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:178
#, no-wrap
msgid ""
"julia> @test 1 â 0.999999999\n"
"Test Passed\n"
"\n"
"julia> @test 1 â 0.999999\n"
"Test Failed at none:1\n"
"  Expression: 1 â 0.999999\n"
"   Evaluated: 1 â 0.999999\n"
"ERROR: There was an error during testing\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:189
#, no-wrap
msgid ""
"Test.@inferred\n"
"Test.@test_logs\n"
"Test.@test_deprecated\n"
"Test.@test_warn\n"
"Test.@test_nowarn\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Test.md:197
#, no-wrap
msgid "Broken Tests"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:202
msgid ""
"If a test fails consistently it can be changed to use the `@test_broken` macro. This will denote the test as `Broken` if the test continues "
"to fail and alerts the user via an `Error` if the test succeeds."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:203
#, no-wrap
msgid "Test.@test_broken\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:210
msgid ""
"`@test_skip` is also available to skip a test without evaluation, but counting the skipped test in the test set reporting. The test will not "
"run but gives a `Broken` `Result`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:211
#, no-wrap
msgid "Test.@test_skip\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Test.md:215
#, no-wrap
msgid "Creating Custom `AbstractTestSet` Types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:221
msgid ""
"Packages can create their own `AbstractTestSet` subtypes by implementing the `record` and `finish` methods. The subtype should have a one-"
"argument constructor taking a description string, with any options passed in as keyword arguments."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:222
#, no-wrap
msgid ""
"Test.record\n"
"Test.finish\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:231
msgid ""
"`Test` takes responsibility for maintaining a stack of nested testsets as they are executed, but any result accumulation is the "
"responsibility of the `AbstractTestSet` subtype. You can access this stack with the `get_testset` and `get_testset_depth` methods. Note that "
"these functions are not exported."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:232
#, no-wrap
msgid ""
"Test.get_testset\n"
"Test.get_testset_depth\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:242
msgid ""
"`Test` also makes sure that nested `@testset` invocations use the same `AbstractTestSet` subtype as their parent unless it is set "
"explicitly. It does not propagate any properties of the testset. Option inheritance behavior can be implemented by packages using the stack "
"infrastructure that `Test` provides."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:244
msgid "Defining a basic `AbstractTestSet` subtype might look like:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:245
#, no-wrap
msgid ""
"import Test: record, finish\n"
"using Test: AbstractTestSet, Result, Pass, Fail, Error\n"
"using Test: get_testset_depth, get_testset\n"
"struct CustomTestSet <: Test.AbstractTestSet\n"
"    description::AbstractString\n"
"    foo::Int\n"
"    results::Vector\n"
"    # constructor takes a description string and options keyword arguments\n"
"    CustomTestSet(desc; foo=1) = new(desc, foo, [])\n"
"end\n"
"\n"
"record(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)\n"
"record(ts::CustomTestSet, res::Result) = push!(ts.results, res)\n"
"function finish(ts::CustomTestSet)\n"
"    # just record if we're not the top-level parent\n"
"    if get_testset_depth() > 0\n"
"        record(get_testset(), ts)\n"
"    end\n"
"    ts\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:269
msgid "And using that testset looks like:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Test.md:270
#, no-wrap
msgid ""
"@testset CustomTestSet foo=4 \"custom testset inner 2\" begin\n"
"    # this testset should inherit the type, but not the argument.\n"
"    @testset \"custom testset inner\" begin\n"
"        @test true\n"
"    end\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:3
#, no-wrap
msgid "DocTestSetup = :(using Dates)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:16
msgid ""
"The `Dates` module provides two types for working with dates: [`Date`](@ref)  and [`DateTime`](@ref), representing day and millisecond "
"precision, respectively; both are subtypes of the abstract [`TimeType`](@ref).  The motivation for distinct types is simple: some operations "
"are much simpler, both in terms of code and mental reasoning, when the complexities of greater precision don't have to be dealt with.  For "
"example, since the [`Date`](@ref) type only resolves to the precision of a single date (i.e.  no hours, minutes, or seconds), normal "
"considerations for time zones, daylight savings/summer time, and leap seconds are unnecessary and avoided."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:34
msgid ""
"Both [`Date`](@ref) and [`DateTime`](@ref) are basically immutable [`Int64`](@ref) wrappers.  The single `instant` field of either type is "
"actually a `UTInstant{P}` type, which represents a continuously increasing machine timeline based on the UT second [^1]. The [`DateTime`]"
"(@ref) type is not aware of time zones (*naive*, in Python parlance), analogous to a *LocalDateTime* in Java 8. Additional time zone "
"functionality can be added through the [TimeZones.jl package](https://github.com/JuliaTime/TimeZones.jl/), which compiles the [IANA time "
"zone database](http://www.iana.org/time-zones). Both [`Date`](@ref) and [`DateTime`](@ref) are based on the [ISO 8601](https://en.wikipedia."
"org/wiki/ISO_8601) standard, which follows the proleptic Gregorian calendar.  One note is that the ISO 8601 standard is particular about BC/"
"BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists.  The ISO "
"standard, however, states that 1 BC/BCE is year zero, so `0000-12-31` is the day before `0001-01-01`, and year `-0001` (yes, negative one "
"for the year) is 2 BC/BCE, year `-0002` is 3 BC/BCE, etc."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:45
#, no-wrap
msgid ""
"[^1]:\n"
"    The notion of the UT second is actually quite fundamental. There are basically two different notions\n"
"    of time generally accepted, one based on the physical rotation of the earth (one full rotation\n"
"    = 1 day), the other based on the SI second (a fixed, constant value). These are radically different!\n"
"    Think about it, a \"UT second\", as defined relative to the rotation of the earth, may have a different\n"
"    absolute length depending on the day! Anyway, the fact that [`Date`](@ref) and [`DateTime`](@ref)\n"
"    are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds\n"
"    and all their complexity can be avoided. This basis of time is formally called [UT](https://en.wikipedia.org/wiki/Universal_Time)\n"
"    or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every\n"
"    day has 24 hours and leads to more natural calculations when working with calendar dates.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Dates.md:46 ext/julia/doc/src/devdocs/functions.md:94
#, no-wrap
msgid "Constructors"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:51
msgid ""
"[`Date`](@ref) and [`DateTime`](@ref) types can be constructed by integer or [`Period`](@ref)  types, by parsing, or through adjusters (more "
"on those later):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:52
#, no-wrap
msgid ""
"julia> DateTime(2013)\n"
"2013-01-01T00:00:00\n"
"\n"
"julia> DateTime(2013,7)\n"
"2013-07-01T00:00:00\n"
"\n"
"julia> DateTime(2013,7,1)\n"
"2013-07-01T00:00:00\n"
"\n"
"julia> DateTime(2013,7,1,12)\n"
"2013-07-01T12:00:00\n"
"\n"
"julia> DateTime(2013,7,1,12,30)\n"
"2013-07-01T12:30:00\n"
"\n"
"julia> DateTime(2013,7,1,12,30,59)\n"
"2013-07-01T12:30:59\n"
"\n"
"julia> DateTime(2013,7,1,12,30,59,1)\n"
"2013-07-01T12:30:59.001\n"
"\n"
"julia> Date(2013)\n"
"2013-01-01\n"
"\n"
"julia> Date(2013,7)\n"
"2013-07-01\n"
"\n"
"julia> Date(2013,7,1)\n"
"2013-07-01\n"
"\n"
"julia> Date(Dates.Year(2013),Dates.Month(7),Dates.Day(1))\n"
"2013-07-01\n"
"\n"
"julia> Date(Dates.Month(7),Dates.Year(2013))\n"
"2013-07-01\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:96
msgid ""
"[`Date`](@ref) or [`DateTime`](@ref) parsing is accomplished by the use of format strings. Format strings work by the notion of defining "
"*delimited* or *fixed-width* \"slots\" that contain a period to parse and passing the text to parse and format string to a [`Date`](@ref) or "
"[`DateTime`](@ref)  constructor, of the form `Date(\"2015-01-01\",\"y-m-d\")` or `DateTime(\"20150101\",\"yyyymmdd\")`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:102
msgid ""
"Delimited slots are marked by specifying the delimiter the parser should expect between two subsequent periods; so `\"y-m-d\"` lets the "
"parser know that between the first and second slots in a date string like `\"2014-07-16\"`, it should find the `-` character. The `y`, `m`, "
"and `d` characters let the parser know which periods to parse in each slot."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:108
msgid ""
"Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between "
"characters. So `\"yyyymmdd\"` would correspond to a date string like `\"20140716\"`. The parser distinguishes a fixed-width slot by the "
"absence of a delimiter, noting the transition `\"yyyymm\"` from one period character to the next."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:115
#, no-wrap
msgid ""
"Support for text-form month parsing is also supported through the `u` and `U` characters, for\n"
"abbreviated and full-length month names, respectively. By default, only English month names are\n"
"supported, so `u` corresponds to \"Jan\", \"Feb\", \"Mar\", etc. And `U` corresponds to \"January\", \"February\",\n"
"\"March\", etc. Similar to other name=>value mapping functions [`dayname`](@ref) and [`monthname`](@ref),\n"
"custom locales can be loaded by passing in the `locale=>Dict{String,Int}` mapping to the `MONTHTOVALUEABBR`\n"
"and `MONTHTOVALUE` dicts for abbreviated and full-name month names, respectively.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:121
msgid ""
"One note on parsing performance: using the `Date(date_string,format_string)` function is fine if only called a few times. If there are many "
"similarly formatted date strings to parse however, it is much more efficient to first create a [`Dates.DateFormat`](@ref), and pass it "
"instead of a raw format string."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:122
#, no-wrap
msgid ""
"julia> df = DateFormat(\"y-m-d\");\n"
"\n"
"julia> dt = Date(\"2015-01-01\",df)\n"
"2015-01-01\n"
"\n"
"julia> dt2 = Date(\"2015-01-02\",df)\n"
"2015-01-02\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:135
msgid ""
"You can also use the `dateformat\"\"` string macro. This macro creates the `DateFormat` object once when the macro is expanded and uses the "
"same `DateFormat` object even if a code snippet is run multiple times."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:136
#, no-wrap
msgid ""
"julia> for i = 1:10^5\n"
"           Date(\"2015-01-01\", dateformat\"y-m-d\")\n"
"       end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:144
msgid ""
"A full suite of parsing and formatting tests and examples is available in [`stdlib/Dates/test/io.jl`](https://github.com/JuliaLang/julia/"
"blob/master/stdlib/Dates/test/io.jl)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Dates.md:145
#, no-wrap
msgid "Durations/Comparisons"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:155
msgid ""
"Finding the length of time between two [`Date`](@ref) or [`DateTime`](@ref)  is straightforward given their underlying representation as "
"`UTInstant{Day}` and `UTInstant{Millisecond}`, respectively.  The difference between [`Date`](@ref) is returned in the number of [`Day`]"
"(@ref), and [`DateTime`](@ref)  in the number of [`Millisecond`](@ref). Similarly, comparing [`TimeType`](@ref) is a simple matter of "
"comparing the underlying machine instants (which in turn compares the internal [`Int64`](@ref)  values)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:156
#, no-wrap
msgid ""
"julia> dt = Date(2012,2,29)\n"
"2012-02-29\n"
"\n"
"julia> dt2 = Date(2000,2,1)\n"
"2000-02-01\n"
"\n"
"julia> dump(dt)\n"
"Date\n"
"  instant: Dates.UTInstant{Day}\n"
"    periods: Day\n"
"      value: Int64 734562\n"
"\n"
"julia> dump(dt2)\n"
"Date\n"
"  instant: Dates.UTInstant{Day}\n"
"    periods: Day\n"
"      value: Int64 730151\n"
"\n"
"julia> dt > dt2\n"
"true\n"
"\n"
"julia> dt != dt2\n"
"true\n"
"\n"
"julia> dt + dt2\n"
"ERROR: MethodError: no method matching +(::Date, ::Date)\n"
"[...]\n"
"\n"
"julia> dt * dt2\n"
"ERROR: MethodError: no method matching *(::Date, ::Date)\n"
"[...]\n"
"\n"
"julia> dt / dt2\n"
"ERROR: MethodError: no method matching /(::Date, ::Date)\n"
"\n"
"julia> dt - dt2\n"
"4411 days\n"
"\n"
"julia> dt2 - dt\n"
"-4411 days\n"
"\n"
"julia> dt = DateTime(2012,2,29)\n"
"2012-02-29T00:00:00\n"
"\n"
"julia> dt2 = DateTime(2000,2,1)\n"
"2000-02-01T00:00:00\n"
"\n"
"julia> dt - dt2\n"
"381110400000 milliseconds\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Dates.md:208 ext/julia/doc/src/stdlib/Dates.md:726
#, no-wrap
msgid "Accessor Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:213
msgid ""
"Because the [`Date`](@ref) and [`DateTime`](@ref) types are stored as single [`Int64`](@ref) values, date parts or fields can be retrieved "
"through accessor functions. The lowercase accessors return the field as an integer:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/stdlib/Dates.md:214 ext/julia/doc/src/stdlib/Dates.md:234 ext/julia/doc/src/stdlib/Dates.md:245
#: ext/julia/doc/src/stdlib/Dates.md:258
#, no-wrap
msgid "jldoctest tdate"
msgstr "jldoctest tdate"

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:214
#, no-wrap
msgid ""
"julia> t = Date(2014, 1, 31)\n"
"2014-01-31\n"
"\n"
"julia> Dates.year(t)\n"
"2014\n"
"\n"
"julia> Dates.month(t)\n"
"1\n"
"\n"
"julia> Dates.week(t)\n"
"5\n"
"\n"
"julia> Dates.day(t)\n"
"31\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:233
msgid "While propercase return the same value in the corresponding [`Period`](@ref)  type:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:234
#, no-wrap
msgid ""
"julia> Dates.Year(t)\n"
"2014 years\n"
"\n"
"julia> Dates.Day(t)\n"
"31 days\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:244
msgid "Compound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:245
#, no-wrap
msgid ""
"julia> Dates.yearmonth(t)\n"
"(2014, 1)\n"
"\n"
"julia> Dates.monthday(t)\n"
"(1, 31)\n"
"\n"
"julia> Dates.yearmonthday(t)\n"
"(2014, 1, 31)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:257
msgid "One may also access the underlying `UTInstant` or integer value:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:258
#, no-wrap
msgid ""
"julia> dump(t)\n"
"Date\n"
"  instant: Dates.UTInstant{Day}\n"
"    periods: Day\n"
"      value: Int64 735264\n"
"\n"
"julia> t.instant\n"
"Dates.UTInstant{Day}(735264 days)\n"
"\n"
"julia> Dates.value(t)\n"
"735264\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Dates.md:272 ext/julia/doc/src/stdlib/Dates.md:754
#, no-wrap
msgid "Query Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:276
msgid "Query functions provide calendrical information about a [`TimeType`](@ref). They include information about the day of the week:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/stdlib/Dates.md:277 ext/julia/doc/src/stdlib/Dates.md:293 ext/julia/doc/src/stdlib/Dates.md:303
#: ext/julia/doc/src/stdlib/Dates.md:324 ext/julia/doc/src/stdlib/Dates.md:338 ext/julia/doc/src/stdlib/Dates.md:352
#, no-wrap
msgid "jldoctest tdate2"
msgstr "jldoctest tdate2"

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:277
#, no-wrap
msgid ""
"julia> t = Date(2014, 1, 31)\n"
"2014-01-31\n"
"\n"
"julia> Dates.dayofweek(t)\n"
"5\n"
"\n"
"julia> Dates.dayname(t)\n"
"\"Friday\"\n"
"\n"
"julia> Dates.dayofweekofmonth(t) # 5th Friday of January\n"
"5\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:292
msgid "Month of the year:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:293
#, no-wrap
msgid ""
"julia> Dates.monthname(t)\n"
"\"January\"\n"
"\n"
"julia> Dates.daysinmonth(t)\n"
"31\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:302
msgid "As well as information about the [`TimeType`](@ref)'s year and quarter:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:303
#, no-wrap
msgid ""
"julia> Dates.isleapyear(t)\n"
"false\n"
"\n"
"julia> Dates.dayofyear(t)\n"
"31\n"
"\n"
"julia> Dates.quarterofyear(t)\n"
"1\n"
"\n"
"julia> Dates.dayofquarter(t)\n"
"31\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:323
msgid ""
"The [`dayname`](@ref) and [`monthname`](@ref) methods can also take an optional `locale` keyword that can be used to return the name of the "
"day or month of the year for other languages/locales.  There are also versions of these functions returning the abbreviated names, namely "
"[`dayabbr`](@ref)  and [`monthabbr`](@ref).  First the mapping is loaded into the `LOCALES` variable:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:324
#, no-wrap
msgid ""
"julia> french_months = [\"janvier\", \"fÃ©vrier\", \"mars\", \"avril\", \"mai\", \"juin\",\n"
"                        \"juillet\", \"aoÃ»t\", \"septembre\", \"octobre\", \"novembre\", \"dÃ©cembre\"];\n"
"\n"
"julia> french_monts_abbrev = [\"janv\",\"fÃ©vr\",\"mars\",\"avril\",\"mai\",\"juin\",\n"
"                              \"juil\",\"aoÃ»t\",\"sept\",\"oct\",\"nov\",\"dÃ©c\"];\n"
"\n"
"julia> french_days = [\"lundi\",\"mardi\",\"mercredi\",\"jeudi\",\"vendredi\",\"samedi\",\"dimanche\"];\n"
"\n"
"julia> Dates.LOCALES[\"french\"] = Dates.DateLocale(french_months, french_monts_abbrev, french_days, [\"\"]);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:337
#, no-wrap
msgid " The above mentioned functions can then be used to perform the queries:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:338
#, no-wrap
msgid ""
"julia> Dates.dayname(t;locale=\"french\")\n"
"\"vendredi\"\n"
"\n"
"julia> Dates.monthname(t;locale=\"french\")\n"
"\"janvier\"\n"
"\n"
"julia> Dates.monthabbr(t;locale=\"french\")\n"
"\"janv\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:351
msgid "Since the abbreviated versions of the days are not loaded, trying to use the function `dayabbr` will error."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:352
#, no-wrap
msgid ""
"julia> Dates.dayabbr(t;locale=\"french\")\n"
"ERROR: BoundsError: attempt to access 1-element Array{String,1} at index [5]\n"
"Stacktrace:\n"
"[...]\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Dates.md:360
#, no-wrap
msgid "TimeType-Period Arithmetic"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:366
msgid ""
"It's good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some "
"[tricky issues](https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/)  to deal with (though much less so for day-"
"precision types)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:379
msgid ""
"The `Dates` module approach tries to follow the simple principle of trying to change as little as possible when doing [`Period`](@ref) "
"arithmetic. This approach is also often known as *calendrical* arithmetic or what you would probably guess if someone were to ask you the "
"same calculation in a conversation. Why all the fuss about this? Let's take a classic example: add 1 month to January 31st, 2014. What's the "
"answer? Javascript will say [March 3](https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/)  (assumes 31 days). PHP "
"says [March 2](https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month)  "
"(assumes 30 days). The fact is, there is no right answer. In the `Dates` module, it gives the result of February 28th. How does it figure "
"that out? I like to think of the classic 7-7-7 gambling game in casinos."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:395
msgid ""
"Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31.  When you ask to add 1 month to this "
"date, the month slot is incremented, so now we have 2014-02-31.  Then the day number is checked if it is greater than the last valid day of "
"the new month; if it is (as in the case above), the day number is adjusted down to the last valid day (28). What are the ramifications with "
"this approach? Go ahead and add another month to our date, `2014-02-28 + Month(1) == 2014-03-28`.  What? Were you expecting the last day of "
"March? Nope, sorry, remember the 7-7-7 slots. As few slots as possible are going to change, so we first increment the month slot by 1, "
"2014-03-28, and boom, we're done because that's a valid date. On the other hand, if we were to add 2 months to our original date, "
"2014-01-31, then we end up with 2014-03-31, as expected. The other ramification of this approach is a loss in associativity when a specific "
"ordering is forced (i.e. adding things in different orders results in different outcomes). For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:396
#, no-wrap
msgid ""
"julia> (Date(2014,1,29)+Dates.Day(1)) + Dates.Month(1)\n"
"2014-02-28\n"
"\n"
"julia> (Date(2014,1,29)+Dates.Month(1)) + Dates.Day(1)\n"
"2014-03-01\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:414
msgid ""
"What's going on there? In the first line, we're adding 1 day to January 29th, which results in 2014-01-30; then we add 1 month, so we get "
"2014-02-30, which then adjusts down to 2014-02-28.  In the second example, we add 1 month *first*, where we get 2014-02-29, which adjusts "
"down to 2014-02-28, and *then* add 1 day, which results in 2014-03-01. One design principle that helps in this case is that, in the presence "
"of multiple Periods, the operations will be ordered by the Periods' *types*, not their value or positional order; this means `Year` will "
"always be added first, then `Month`, then `Week`, etc. Hence the following *does* result in associativity and Just Works:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:415
#, no-wrap
msgid ""
"julia> Date(2014,1,29) + Dates.Day(1) + Dates.Month(1)\n"
"2014-03-01\n"
"\n"
"julia> Date(2014,1,29) + Dates.Month(1) + Dates.Day(1)\n"
"2014-03-01\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:429
msgid ""
"Tricky? Perhaps. What is an innocent `Dates` user to do? The bottom line is to be aware that explicitly forcing a certain associativity, "
"when dealing with months, may lead to some unexpected results, but otherwise, everything should work as expected. Thankfully, that's pretty "
"much the extent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the \"joys\" of dealing with daylight "
"savings, leap seconds, etc.)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:431
msgid "As a bonus, all period arithmetic objects work directly with ranges:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:432
#, no-wrap
msgid ""
"julia> dr = Date(2014,1,29):Day(1):Date(2014,2,3)\n"
"2014-01-29:1 day:2014-02-03\n"
"\n"
"julia> collect(dr)\n"
"6-element Array{Date,1}:\n"
" 2014-01-29\n"
" 2014-01-30\n"
" 2014-01-31\n"
" 2014-02-01\n"
" 2014-02-02\n"
" 2014-02-03\n"
"\n"
"julia> dr = Date(2014,1,29):Dates.Month(1):Date(2014,07,29)\n"
"2014-01-29:1 month:2014-07-29\n"
"\n"
"julia> collect(dr)\n"
"7-element Array{Date,1}:\n"
" 2014-01-29\n"
" 2014-02-28\n"
" 2014-03-29\n"
" 2014-04-29\n"
" 2014-05-29\n"
" 2014-06-29\n"
" 2014-07-29\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Dates.md:459 ext/julia/doc/src/stdlib/Dates.md:773
#, no-wrap
msgid "Adjuster Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:468
msgid ""
"As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a *calendrical* or *temporal* nature "
"rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as \"Memorial Day = Last Monday of May\", or "
"\"Thanksgiving = 4th Thursday of November\". These kinds of temporal expressions deal with rules relative to the calendar, like first or "
"last of the month, next Tuesday, or the first and third Wednesdays, etc."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:475
msgid ""
"The `Dates` module provides the *adjuster* API through several convenient methods that aid in simply and succinctly expressing temporal "
"rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single "
"[`TimeType`](@ref)  as input and return or *adjust to* the first or last of the desired period relative to the input."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:476
#, no-wrap
msgid ""
"julia> Dates.firstdayofweek(Date(2014,7,16)) # Adjusts the input to the Monday of the input's week\n"
"2014-07-14\n"
"\n"
"julia> Dates.lastdayofmonth(Date(2014,7,16)) # Adjusts to the last day of the input's month\n"
"2014-07-31\n"
"\n"
"julia> Dates.lastdayofquarter(Date(2014,7,16)) # Adjusts to the last day of the input's quarter\n"
"2014-09-30\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:493
msgid ""
"The next two higher-order methods, [`tonext`](@ref), and [`toprev`](@ref), generalize working with temporal expressions by taking a "
"`DateFunction` as first argument, along with a starting [`TimeType`](@ref). A `DateFunction` is just a function, usually anonymous, that "
"takes a single [`TimeType`](@ref) as input and returns a [`Bool`](@ref), `true` indicating a satisfied adjustment criterion.  For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:494
#, no-wrap
msgid ""
"julia> istuesday = x->Dates.dayofweek(x) == Dates.Tuesday; # Returns true if the day of the week of x is Tuesday\n"
"\n"
"julia> Dates.tonext(istuesday, Date(2014,7,13)) # 2014-07-13 is a Sunday\n"
"2014-07-15\n"
"\n"
"julia> Dates.tonext(Date(2014,7,13), Dates.Tuesday) # Convenience method provided for day of the week adjustments\n"
"2014-07-15\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:506
msgid "This is useful with the do-block syntax for more complex temporal expressions:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:507
#, no-wrap
msgid ""
"julia> Dates.tonext(Date(2014,7,13)) do x\n"
"           # Return true on the 4th Thursday of November (Thanksgiving)\n"
"           Dates.dayofweek(x) == Dates.Thursday &&\n"
"           Dates.dayofweekofmonth(x) == 4 &&\n"
"           Dates.month(x) == Dates.November\n"
"       end\n"
"2014-11-27\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:519
msgid "The [`Base.filter`](@ref) method can be used to obtain all valid dates/moments in a specified range:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:520
#, no-wrap
msgid ""
"# Pittsburgh street cleaning; Every 2nd Tuesday from April to November\n"
"# Date range from January 1st, 2014 to January 1st, 2015\n"
"julia> dr = Dates.Date(2014):Day(1):Dates.Date(2015);\n"
"\n"
"julia> filter(dr) do x\n"
"           Dates.dayofweek(x) == Dates.Tue &&\n"
"           Dates.April <= Dates.month(x) <= Dates.Nov &&\n"
"           Dates.dayofweekofmonth(x) == 2\n"
"       end\n"
"8-element Array{Date,1}:\n"
" 2014-04-08\n"
" 2014-05-13\n"
" 2014-06-10\n"
" 2014-07-08\n"
" 2014-08-12\n"
" 2014-09-09\n"
" 2014-10-14\n"
" 2014-11-11\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:543
msgid ""
"Additional examples and tests are available in [`stdlib/Dates/test/adjusters.jl`](https://github.com/JuliaLang/julia/blob/master/stdlib/"
"Dates/test/adjusters.jl)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Dates.md:544
#, no-wrap
msgid "Period Types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:555
msgid ""
"Periods are a human view of discrete, sometimes irregular durations of time. Consider 1 month; it could represent, in days, a value of 28, "
"29, 30, or 31 depending on the year and month context.  Or a year could represent 365 or 366 days in the case of a leap year. [`Period`]"
"(@ref) types are simple [`Int64`](@ref) wrappers and are constructed by wrapping any `Int64` convertible type, i.e. `Year(1)` or "
"`Month(3.0)`. Arithmetic between [`Period`](@ref) of the same type behave like integers, and limited `Period-Real` arithmetic is available.  "
"You can extract the underlying integer with [`Dates.value`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:556
#, no-wrap
msgid ""
"julia> y1 = Dates.Year(1)\n"
"1 year\n"
"\n"
"julia> y2 = Dates.Year(2)\n"
"2 years\n"
"\n"
"julia> y3 = Dates.Year(10)\n"
"10 years\n"
"\n"
"julia> y1 + y2\n"
"3 years\n"
"\n"
"julia> div(y3,y2)\n"
"5\n"
"\n"
"julia> y3 - y2\n"
"8 years\n"
"\n"
"julia> y3 % y2\n"
"0 years\n"
"\n"
"julia> div(y3,3) # mirrors integer division\n"
"3 years\n"
"\n"
"julia> Dates.value(Dates.Millisecond(10))\n"
"10\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Dates.md:585
#, no-wrap
msgid "Rounding"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:590
msgid ""
"[`Date`](@ref) and [`DateTime`](@ref) values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with [`floor`](@ref), "
"[`ceil`](@ref), or [`round`](@ref):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:591
#, no-wrap
msgid ""
"julia> floor(Date(1985, 8, 16), Dates.Month)\n"
"1985-08-01\n"
"\n"
"julia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\n"
"2013-02-13T00:45:00\n"
"\n"
"julia> round(DateTime(2016, 8, 6, 20, 15), Dates.Day)\n"
"2016-08-07T00:00:00\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:608
msgid ""
"Unlike the numeric [`round`](@ref) method, which breaks ties toward the even number by default, the [`TimeType`](@ref)[`round`](@ref) method "
"uses the `RoundNearestTiesUp` rounding mode. (It's difficult to guess what breaking ties to nearest \"even\" [`TimeType`](@ref) would "
"entail.) Further details on the available `RoundingMode` s can be found in the [API reference](@ref stdlib-dates-api)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:611
msgid "Rounding should generally behave as expected, but there are a few cases in which the expected behaviour is not obvious."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Dates.md:612
#, no-wrap
msgid "Rounding Epoch"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:619
msgid ""
"In many cases, the resolution specified for rounding (e.g., `Dates.Second(30)`) divides evenly into the next largest period (in this case, "
"`Dates.Minute(1)`). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding "
"a [`DateTime`](@ref)  to the nearest 10 hours?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:620
#, no-wrap
msgid ""
"julia> round(DateTime(2016, 7, 17, 11, 55), Dates.Hour(10))\n"
"2016-07-17T12:00:00\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:629
msgid ""
"That may seem confusing, given that the hour (12) is not divisible by 10. The reason that `2016-07-17T12:00:00` was chosen is that it is "
"17,676,660 hours after `0000-01-01T00:00:00`, and 17,676,660 is divisible by 10."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:638
msgid ""
"As Julia [`Date`](@ref) and [`DateTime`](@ref) values are represented according to the ISO 8601 standard, `0000-01-01T00:00:00` was chosen "
"as base (or \"rounding epoch\") from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this "
"differs slightly from Julia's internal representation of [`Date`](@ref) s using Rata Die notation; but since the ISO 8601 standard is most "
"visible to the end user, `0000-01-01T00:00:00` was chosen as the rounding epoch instead of the `0000-12-31T00:00:00` used internally to "
"minimize confusion.)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:645
msgid ""
"The only exception to the use of `0000-01-01T00:00:00` as the rounding epoch is when rounding to weeks. Rounding to the nearest week will "
"always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use `0000-01-03T00:00:00` (the first day of "
"the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:649
#, no-wrap
msgid ""
"Here is a related case in which the expected behaviour is not necessarily obvious: What happens\n"
"when we round to the nearest `P(2)`, where `P` is a [`Period`](@ref) type? In some cases (specifically,\n"
"when `P <: Dates.TimePeriod`) the answer is clear:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:650
#, no-wrap
msgid ""
"julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Hour(2))\n"
"2016-07-17T08:00:00\n"
"\n"
"julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Minute(2))\n"
"2016-07-17T08:56:00\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:661
msgid ""
"This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two "
"months (which still divides evenly into one year), the answer may be surprising:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:662
#, no-wrap
msgid ""
"julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Month(2))\n"
"2016-07-01T00:00:00\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:671
msgid ""
"Why round to the first day in July, even though it is month 7 (an odd number)? The key is that months are 1-indexed (the first month is "
"assigned 1), unlike hours, minutes, seconds, and milliseconds (the first of which are assigned 0)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:680
msgid ""
"This means that rounding a [`DateTime`](@ref) to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification "
"includes a year zero) will result in a [`DateTime`](@ref)  with an even value in that field, while rounding a [`DateTime`](@ref) to an even "
"multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of "
"days, whether rounding to an even number of days will result in an even value in the days field is uncertain."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:683
msgid "See the [API reference](@ref stdlib-dates-api) for additional information on methods exported from the `Dates` module."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/stdlib/Dates.md:684
#, no-wrap
msgid "[API reference](@id stdlib-dates-api)"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Dates.md:686
#, no-wrap
msgid "Dates and Time Types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:688
#, no-wrap
msgid ""
"Dates.Period\n"
"Dates.CompoundPeriod\n"
"Dates.Instant\n"
"Dates.UTInstant\n"
"Dates.TimeType\n"
"Dates.DateTime\n"
"Dates.Date\n"
"Dates.Time\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/stdlib/Dates.md:699
#, no-wrap
msgid "Dates Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:701
#, no-wrap
msgid ""
"Dates.DateTime(::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\n"
"Dates.DateTime(::Dates.Period)\n"
"Dates.DateTime(::Function, ::Any...)\n"
"Dates.DateTime(::Dates.TimeType)\n"
"Dates.DateTime(::AbstractString, ::AbstractString)\n"
"Dates.format(::Dates.TimeType, ::AbstractString)\n"
"Dates.DateFormat\n"
"Dates.@dateformat_str\n"
"Dates.DateTime(::AbstractString, ::Dates.DateFormat)\n"
"Dates.Date(::Int64, ::Int64, ::Int64)\n"
"Dates.Date(::Dates.Period)\n"
"Dates.Date(::Function, ::Any, ::Any, ::Any)\n"
"Dates.Date(::Dates.TimeType)\n"
"Dates.Date(::AbstractString, ::AbstractString)\n"
"Dates.Date(::AbstractString, ::Dates.DateFormat)\n"
"Dates.Time(::Int64::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\n"
"Dates.Time(::Dates.TimePeriod)\n"
"Dates.Time(::Function, ::Any...)\n"
"Dates.Time(::Dates.DateTime)\n"
"Dates.now()\n"
"Dates.now(::Type{Dates.UTC})\n"
"Base.eps\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:728
#, no-wrap
msgid ""
"Dates.year\n"
"Dates.month\n"
"Dates.week\n"
"Dates.day\n"
"Dates.hour\n"
"Dates.minute\n"
"Dates.second\n"
"Dates.millisecond\n"
"Dates.microsecond\n"
"Dates.nanosecond\n"
"Dates.Year(::Dates.TimeType)\n"
"Dates.Month(::Dates.TimeType)\n"
"Dates.Week(::Dates.TimeType)\n"
"Dates.Day(::Dates.TimeType)\n"
"Dates.Hour(::DateTime)\n"
"Dates.Minute(::DateTime)\n"
"Dates.Second(::DateTime)\n"
"Dates.Millisecond(::DateTime)\n"
"Dates.Microsecond(::Dates.Time)\n"
"Dates.Nanosecond(::Dates.Time)\n"
"Dates.yearmonth\n"
"Dates.monthday\n"
"Dates.yearmonthday\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:756
#, no-wrap
msgid ""
"Dates.dayname\n"
"Dates.dayabbr\n"
"Dates.dayofweek\n"
"Dates.dayofmonth\n"
"Dates.dayofweekofmonth\n"
"Dates.daysofweekinmonth\n"
"Dates.monthname\n"
"Dates.monthabbr\n"
"Dates.daysinmonth\n"
"Dates.isleapyear\n"
"Dates.dayofyear\n"
"Dates.daysinyear\n"
"Dates.quarterofyear\n"
"Dates.dayofquarter\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:775
#, no-wrap
msgid ""
"Base.trunc(::Dates.TimeType, ::Type{Dates.Period})\n"
"Dates.firstdayofweek\n"
"Dates.lastdayofweek\n"
"Dates.firstdayofmonth\n"
"Dates.lastdayofmonth\n"
"Dates.firstdayofyear\n"
"Dates.lastdayofyear\n"
"Dates.firstdayofquarter\n"
"Dates.lastdayofquarter\n"
"Dates.tonext(::Dates.TimeType, ::Int)\n"
"Dates.toprev(::Dates.TimeType, ::Int)\n"
"Dates.tofirst\n"
"Dates.tolast\n"
"Dates.tonext(::Function, ::Dates.TimeType)\n"
"Dates.toprev(::Function, ::Dates.TimeType)\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Dates.md:793
#, no-wrap
msgid "Periods"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:795
#, no-wrap
msgid ""
"Dates.Period(::Any)\n"
"Dates.CompoundPeriod(::Vector{<:Dates.Period})\n"
"Dates.value\n"
"Dates.default\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Dates.md:802
#, no-wrap
msgid "Rounding Functions"
msgstr "ä¸¸ãé¢æ°"

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:806
msgid "`Date` and `DateTime` values can be rounded to a specified resolution (e.g., 1 month or 15 minutes)  with `floor`, `ceil`, or `round`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:807
#, no-wrap
msgid ""
"Base.floor(::Dates.TimeType, ::Dates.Period)\n"
"Base.ceil(::Dates.TimeType, ::Dates.Period)\n"
"Base.round(::Dates.TimeType, ::Dates.Period, ::RoundingMode{:NearestTiesUp})\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:814
msgid "Most `Period` values can also be rounded to a specified resolution:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:815
#, no-wrap
msgid ""
"Base.floor(::Dates.ConvertiblePeriod, ::T) where T <: Dates.ConvertiblePeriod\n"
"Base.ceil(::Dates.ConvertiblePeriod, ::Dates.ConvertiblePeriod)\n"
"Base.round(::Dates.ConvertiblePeriod, ::Dates.ConvertiblePeriod, ::RoundingMode{:NearestTiesUp})\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:822
msgid "The following functions are not exported:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:823
#, no-wrap
msgid ""
"Dates.floorceil\n"
"Dates.epochdays2date\n"
"Dates.epochms2datetime\n"
"Dates.date2epochdays\n"
"Dates.datetime2epochms\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/stdlib/Dates.md:831
#, no-wrap
msgid "Conversion Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:833
#, no-wrap
msgid ""
"Dates.today\n"
"Dates.unix2datetime\n"
"Dates.datetime2unix\n"
"Dates.julian2datetime\n"
"Dates.datetime2julian\n"
"Dates.rata2datetime\n"
"Dates.datetime2rata\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:846
msgid "Days of the Week:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:856
#, no-wrap
msgid ""
"| Variable    | Abbr. | Value (Int) |\n"
"|:----------- |:----- |:----------- |\n"
"| `Monday`    | `Mon` | 1           |\n"
"| `Tuesday`   | `Tue` | 2           |\n"
"| `Wednesday` | `Wed` | 3           |\n"
"| `Thursday`  | `Thu` | 4           |\n"
"| `Friday`    | `Fri` | 5           |\n"
"| `Saturday`  | `Sat` | 6           |\n"
"| `Sunday`    | `Sun` | 7           |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:858
msgid "Months of the Year:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/stdlib/Dates.md:873
#, no-wrap
msgid ""
"| Variable    | Abbr. | Value (Int) |\n"
"|:----------- |:----- |:----------- |\n"
"| `January`   | `Jan` | 1           |\n"
"| `February`  | `Feb` | 2           |\n"
"| `March`     | `Mar` | 3           |\n"
"| `April`     | `Apr` | 4           |\n"
"| `May`       | `May` | 5           |\n"
"| `June`      | `Jun` | 6           |\n"
"| `July`      | `Jul` | 7           |\n"
"| `August`    | `Aug` | 8           |\n"
"| `September` | `Sep` | 9           |\n"
"| `October`   | `Oct` | 10          |\n"
"| `November`  | `Nov` | 11          |\n"
"| `December`  | `Dec` | 12          |\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/locks.md:1
#, no-wrap
msgid "Proper maintenance and care of multi-threading locks"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:5
msgid ""
"The following strategies are used to ensure that the code is dead-lock free (generally by addressing the 4th Coffman condition: circular "
"wait)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:9
#, no-wrap
msgid ""
"> 1. structure code such that only one lock will need to be acquired at a time\n"
"> 2. always acquire shared locks in the same order, as given by the table below\n"
"> 3. avoid constructs that expect to need unrestricted recursion\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/locks.md:10
#, no-wrap
msgid "Locks"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:14
msgid ""
"Below are all of the locks that exist in the system and the mechanisms for using them that avoid the potential for deadlocks (no Ostrich "
"algorithm allowed here):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:16
msgid "The following are definitely leaf locks (level 1), and must not try to acquire any other lock:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:32
#, no-wrap
msgid ""
">   * safepoint\n"
">\n"
">     > Note that this lock is acquired implicitly by `JL_LOCK` and `JL_UNLOCK`. use the `_NOGC` variants\n"
">     > to avoid that for level 1 locks.\n"
">     >\n"
">     > While holding this lock, the code must not do any allocation or hit any safepoints. Note that\n"
">     > there are safepoints when doing allocation, enabling / disabling GC, entering / restoring exception\n"
">     > frames, and taking / releasing locks.\n"
">   * shared_map\n"
">   * finalizers\n"
">   * pagealloc\n"
">   * gc_perm_lock\n"
">   * flisp\n"
">\n"
">     > flisp itself is already threadsafe, this lock only protects the `jl_ast_context_list_t` pool\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:34
msgid "The following is a leaf lock (level 2), and only acquires level 1 locks (safepoint) internally:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:36
#, no-wrap
msgid ">   * typecache\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:38
msgid "The following is a level 2 lock:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:40
#, no-wrap
msgid ">   * Module->lock\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:42
msgid "The following is a level 3 lock, which can only acquire level 1 or level 2 locks internally:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:44
#, no-wrap
msgid ">   * Method->writelock\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:46
msgid "The following is a level 4 lock, which can only recurse to acquire level 1, 2, or 3 locks:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:48
#, no-wrap
msgid ">   * MethodTable->writelock\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:50
msgid "No Julia code may be called while holding a lock above this point."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:52
msgid "The following is a level 6 lock, which can only recurse to acquire locks at lower levels:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:54
#, no-wrap
msgid ">   * codegen\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:57
msgid "The following is an almost root lock (level end-1), meaning only the root look may be held when trying to acquire it:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:64
#, no-wrap
msgid ""
">   * typeinf\n"
">\n"
">     > this one is perhaps one of the most tricky ones, since type-inference can be invoked from many\n"
">     > points\n"
">     >\n"
">     > currently the lock is merged with the codegen lock, since they call each other recursively\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:68
msgid ""
"The following lock synchronizes IO operation. Be aware that doing any I/O (for example, printing warning messages or debug information) "
"while holding any other lock listed above may result in pernicious and hard-to-find deadlocks. BE VERY CAREFUL!"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:74
#, no-wrap
msgid ""
">   * iolock\n"
">   * Individual ThreadSynchronizers locks\n"
">\n"
">     > this may continue to be held after releasing the iolock, or acquired without it,\n"
">     > but be very careful to never attempt to acquire the iolock while holding it\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:77
msgid "The following is the root lock, meaning no other lock shall be held when trying to acquire it:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:86
#, no-wrap
msgid ""
">   * toplevel\n"
">\n"
">     > this should be held while attempting a top-level action (such as making a new type or defining\n"
">     > a new method): trying to obtain this lock inside a staged function will cause a deadlock condition!\n"
">     >\n"
">     >\n"
">     > additionally, it's unclear if *any* code can safely run in parallel with an arbitrary toplevel\n"
">     > expression, so it may require all threads to get to a safepoint first\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/locks.md:87
#, no-wrap
msgid "Broken Locks"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:90
msgid "The following locks are broken:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/locks.md:92
msgid "toplevel"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:96
#, no-wrap
msgid ""
"    > doesn't exist right now\n"
"    >\n"
"    > fix: create it\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/locks.md:97
#, no-wrap
msgid "Shared Global Data Structures"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:102
msgid ""
"These data structures each need locks due to being shared mutable global state. It is the inverse list for the above lock priority list. "
"This list does not include level 1 leaf resources due to their simplicity."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:104
#, no-wrap
msgid "MethodTable modifications (def, cache, kwsorter type) : MethodTable->writelock\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:106
msgid "Type declarations : toplevel lock"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:108
msgid "Type application : typecache lock"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:110
#, no-wrap
msgid "Global variable tables : Module->lock\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:112
msgid "Module serializer : toplevel lock"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:114
msgid "JIT & type-inference : codegen lock"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:116
#, no-wrap
msgid "MethodInstance/CodeInstance updates : Method->writelock, codegen lock\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:121
#, no-wrap
msgid ""
">   * These are set at construction and immutable:\n"
">       * specTypes\n"
">       * sparam_vals\n"
">       * def\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:127
#, no-wrap
msgid ""
">   * These are set by `jl_type_infer` (while holding codegen lock):\n"
">       * cache\n"
">       * rettype\n"
">       * inferred\n"
"        * valid ages\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:131
#, no-wrap
msgid ""
">   * `inInference` flag:\n"
">       * optimization to quickly avoid recurring into `jl_type_infer` while it is already running\n"
">       * actual state (of setting `inferred`, then `fptr`) is protected by codegen lock\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:142
#, no-wrap
msgid ""
">   * Function pointers:\n"
">       * these transition once, from `NULL` to a value, while the codegen lock is held\n"
">\n"
">   * Code-generator cache (the contents of `functionObjectsDecls`):\n"
">       * these can transition multiple times, but only while the codegen lock is held\n"
">       * it is valid to use old version of this, or block for new versions of this, so races are benign,\n"
">         as long as the code is careful not to reference other data in the method instance (such as `rettype`)\n"
">         and assume it is coordinated, unless also holding the codegen lock\n"
">\n"
"LLVMContext : codegen lock\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/locks.md:144
#, no-wrap
msgid "Method : Method->writelock\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/locks.md:146
msgid "roots array (serializer and codegen)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/locks.md:146
msgid "invoke / specializations / tfunc modifications"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/ast.md:1
#, no-wrap
msgid "Julia ASTs"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:10
msgid ""
"Julia has two representations of code. First there is a surface syntax AST returned by the parser (e.g. the [`Meta.parse`](@ref) function), "
"and manipulated by macros. It is a structured representation of code as it is written, constructed by `julia-parser.scm` from a character "
"stream. Next there is a lowered form, or IR (intermediate representation), which is used by type inference and code generation. In the "
"lowered form there are fewer types of nodes, all macros are expanded, and all control flow is converted to explicit branches and sequences "
"of statements. The lowered form is constructed by `julia-syntax.scm`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:12
msgid "First we will focus on the AST, since it is needed to write macros."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/ast.md:13
#, no-wrap
msgid "Surface syntax AST"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:20
msgid ""
"Front end ASTs consist almost entirely of [`Expr`](@ref)s and atoms (e.g. symbols, numbers).  There is generally a different expression head "
"for each visually distinct syntactic form.  Examples will be given in s-expression syntax.  Each parenthesized list corresponds to an Expr, "
"where the first element is the head.  For example `(call f x)` corresponds to `Expr(:call, :f, :x)` in Julia."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:21
#, no-wrap
msgid "Calls"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:29
#, no-wrap
msgid ""
"| Input            | AST                                |\n"
"|:---------------- |:---------------------------------- |\n"
"| `f(x)`           | `(call f x)`                       |\n"
"| `f(x, y=1, z=2)` | `(call f x (kw y 1) (kw z 2))`     |\n"
"| `f(x; y=1)`      | `(call f (parameters (kw y 1)) x)` |\n"
"| `f(x...)`        | `(call f (... x))`                 |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:31
msgid "`do` syntax:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:32
#, no-wrap
msgid ""
"f(x) do a,b\n"
"    body\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:39
#, no-wrap
msgid "parses as `(do (call f x) (-> (tuple a b) (block body)))`.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:40
#, no-wrap
msgid "Operators"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:47
msgid ""
"Most uses of operators are just function calls, so they are parsed with the head `call`. However some operators are special forms (not "
"necessarily function calls), and in those cases the operator itself is the expression head. In julia-parser.scm these are referred to as "
"\"syntactic operators\".  Some operators (`+` and `*`) use N-ary parsing; chained calls are parsed as a single N-argument call. Finally, "
"chains of comparisons have their own special expression structure."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:63
#, no-wrap
msgid ""
"| Input       | AST                       |\n"
"|:----------- |:------------------------- |\n"
"| `x+y`       | `(call + x y)`            |\n"
"| `a+b+c+d`   | `(call + a b c d)`        |\n"
"| `2x`        | `(call * 2 x)`            |\n"
"| `a&&b`      | `(&& a b)`                |\n"
"| `x += 1`    | `(+= x 1)`                |\n"
"| `a ? 1 : 2` | `(if a 1 2)`              |\n"
"| `a:b`       | `(: a b)`                 |\n"
"| `a:b:c`     | `(: a b c)`               |\n"
"| `a,b`       | `(tuple a b)`             |\n"
"| `a==b`      | `(call == a b)`           |\n"
"| `1<i<=n`    | `(comparison 1 < i <= n)` |\n"
"| `a.b`       | `(. a (quote b))`         |\n"
"| `a.(b)`     | `(. a b)`                 |\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:64
#, no-wrap
msgid "Bracketed forms"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:83
#, no-wrap
msgid ""
"| Input                    | AST                                  |\n"
"|:------------------------ |:------------------------------------ |\n"
"| `a[i]`                   | `(ref a i)`                          |\n"
"| `t[i;j]`                 | `(typed_vcat t i j)`                 |\n"
"| `t[i j]`                 | `(typed_hcat t i j)`                 |\n"
"| `t[a b; c d]`            | `(typed_vcat t (row a b) (row c d))` |\n"
"| `a{b}`                   | `(curly a b)`                        |\n"
"| `a{b;c}`                 | `(curly a (parameters c) b)`         |\n"
"| `[x]`                    | `(vect x)`                           |\n"
"| `[x,y]`                  | `(vect x y)`                         |\n"
"| `[x;y]`                  | `(vcat x y)`                         |\n"
"| `[x y]`                  | `(hcat x y)`                         |\n"
"| `[x y; z t]`             | `(vcat (row x y) (row z t))`         |\n"
"| `[x for y in z, a in b]` | `(comprehension x (= y z) (= a b))`  |\n"
"| `T[x for y in z]`        | `(typed_comprehension T x (= y z))`  |\n"
"| `(a, b, c)`              | `(tuple a b c)`                      |\n"
"| `(a; b; c)`              | `(block a (block b c))`              |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:91
#, no-wrap
msgid ""
"| Input         | AST                                          |\n"
"|:------------- |:-------------------------------------------- |\n"
"| `@m x y`      | `(macrocall @m (line) x y)`                  |\n"
"| `Base.@m x y` | `(macrocall (. Base (quote @m)) (line) x y)` |\n"
"| `@Base.m x y` | `(macrocall (. Base (quote @m)) (line) x y)` |\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:92
#, no-wrap
msgid "Strings"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:101
#, no-wrap
msgid ""
"| Input           | AST                                 |\n"
"|:--------------- |:----------------------------------- |\n"
"| `\"a\"`           | `\"a\"`                               |\n"
"| `x\"y\"`          | `(macrocall @x_str (line) \"y\")`     |\n"
"| `x\"y\"z`         | `(macrocall @x_str (line) \"y\" \"z\")` |\n"
"| `\"x = $x\"`      | `(string \"x = \" x)`                 |\n"
"| ``` `a b c` ``` | `(macrocall @cmd (line) \"a b c\")`   |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:103
msgid "Doc string syntax:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:104
#, no-wrap
msgid ""
"\"some docs\"\n"
"f(x) = x\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:110
msgid "parses as `(macrocall (|.| Core '@doc) (line) \"some docs\" (= (call f x) (block x)))`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:111
#, no-wrap
msgid "Imports and such"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:122
#, no-wrap
msgid ""
"| Input               | AST                                          |\n"
"|:------------------- |:-------------------------------------------- |\n"
"| `import a`          | `(import (. a))`                             |\n"
"| `import a.b.c`      | `(import (. a b c))`                         |\n"
"| `import ...a`       | `(import (. . . . a))`                       |\n"
"| `import a.b, c.d`   | `(import (. a b) (. c d))`                   |\n"
"| `import Base: x`    | `(import (: (. Base) (. x)))`                |\n"
"| `import Base: x, y` | `(import (: (. Base) (. x) (. y)))`          |\n"
"| `export a, b`       | `(export a b)`                               |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:125
msgid "`using` has the same representation as `import`, but with expression head `:using` instead of `:import`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:126
#, no-wrap
msgid "Numbers"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:130
msgid ""
"Julia supports more number types than many scheme implementations, so not all numbers are represented directly as scheme numbers in the AST."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:136
#, no-wrap
msgid ""
"| Input                   | AST                                                     |\n"
"|:----------------------- |:------------------------------------------------------- |\n"
"| `11111111111111111111`  | `(macrocall @int128_str (null) \"11111111111111111111\")` |\n"
"| `0xfffffffffffffffff`   | `(macrocall @uint128_str (null) \"0xfffffffffffffffff\")` |\n"
"| `1111...many digits...` | `(macrocall @big_str (null) \"1111....\")`                |\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:137
#, no-wrap
msgid "Block forms"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:140
msgid "A block of statements is parsed as `(block stmt1 stmt2 ...)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:142
msgid "If statement:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:143
#, no-wrap
msgid ""
"if a\n"
"    b\n"
"elseif c\n"
"    d\n"
"else\n"
"    e\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:154 ext/julia/doc/src/devdocs/ast.md:180 ext/julia/doc/src/devdocs/ast.md:197
msgid "parses as:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:155
#, no-wrap
msgid ""
"(if a (block (line 2) b)\n"
"    (elseif (block (line 3) c) (block (line 4) d)\n"
"            (block (line 5 e))))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:162
msgid "A `while` loop parses as `(while condition body)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:165
msgid ""
"A `for` loop parses as `(for (= var iter) body)`. If there is more than one iteration specification, they are parsed as a block: `(for "
"(block (= v1 iter1) (= v2 iter2)) body)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:167
msgid "`break` and `continue` are parsed as 0-argument expressions `(break)` and `(continue)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:170
msgid "`let` is parsed as `(let (= var val) body)` or `(let (block (= var1 val1) (= var2 val2) ...) body)`, like `for` loops."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:172
msgid "A basic function definition is parsed as `(function (call f x) body)`. A more complex example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:173
#, no-wrap
msgid ""
"function f(x::T; k = 1) where T\n"
"    return x+1\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:181
#, no-wrap
msgid ""
"(function (where (call f (parameters (kw k 1))\n"
"                       (:: x T))\n"
"                 T)\n"
"          (block (line 2) (return (call + x 1))))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:189
msgid "Type definition:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:190
#, no-wrap
msgid ""
"mutable struct Foo{T<:S}\n"
"    x::T\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:198
#, no-wrap
msgid ""
"(struct true (curly Foo (<: T S))\n"
"        (block (line 2) (:: x T)))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:204
msgid "The first argument is a boolean telling whether the type is mutable."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:207
msgid ""
"`try` blocks parse as `(try try_block var catch_block finally_block)`. If no variable is present after `catch`, `var` is `#f`. If there is "
"no `finally` clause, then the last argument is not present."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:208
#, no-wrap
msgid "Quote expressions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:214
msgid ""
"Julia source syntax forms for code quoting (`quote` and `:( )`) support interpolation with `$`.  In Lisp terminology, this means they are "
"actually \"backquote\" or \"quasiquote\" forms.  Internally, there is also a need for code quoting without interpolation.  In Julia's scheme "
"code, non-interpolating quote is represented with the expression head `inert`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:217
msgid ""
"`inert` expressions are converted to Julia `QuoteNode` objects.  These objects wrap a single value of any type, and when evaluated simply "
"return that value."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:219
msgid "A `quote` expression whose argument is an atom also gets converted to a `QuoteNode`."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:220
#, no-wrap
msgid "Line numbers"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:225
msgid ""
"Source location information is represented as `(line line_num file_name)` where the third component is optional (and omitted when the "
"current line number, but not file name, changes)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:227
msgid "These expressions are represented as `LineNumberNode`s in Julia."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:234
msgid ""
"Macro hygiene is represented through the expression head pair `escape` and `hygienic-scope`.  The result of a macro expansion is "
"automatically wrapped in `(hygienic-scope block module)`, to represent the result of the new scope. The user can insert `(escape block)` "
"inside to interpolate code from the caller."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/ast.md:236
#, no-wrap
msgid "Lowered form"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:241
msgid ""
"Lowered form (IR) is more important to the compiler, since it is used for type inference, optimizations like inlining, and code generation. "
"It is also less obvious to the human, since it results from a significant rearrangement of the input syntax."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:244
msgid "In addition to `Symbol`s and some number types, the following data types exist in lowered form:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:246
msgid "`Expr`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:251
#, no-wrap
msgid ""
"    Has a node type indicated by the `head` field, and an `args` field which is a `Vector{Any}` of\n"
"    subexpressions.\n"
"    While almost every part of a surface AST is represented by an `Expr`, the IR uses only a\n"
"    limited number of `Expr`s, mostly for calls, conditional branches (`gotoifnot`), and returns.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:253
msgid "`Slot`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:260
#, no-wrap
msgid ""
"    Identifies arguments and local variables by consecutive numbering. `Slot` is an abstract type\n"
"    with subtypes `SlotNumber` and `TypedSlot`. Both types have an integer-valued `id` field giving\n"
"    the slot index. Most slots have the same type at all uses, and so are represented with `SlotNumber`.\n"
"    The types of these slots are found in the `slottypes` field of their `MethodInstance` object.\n"
"    Slots that require per-use type annotations are represented with `TypedSlot`, which has a `typ`\n"
"    field.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:262
msgid "`CodeInfo`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:264
#, no-wrap
msgid "    Wraps the IR of a group of statements. Its `code` field is an array of expressions to execute.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:266
msgid "`GotoNode`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:269
#, no-wrap
msgid ""
"    Unconditional branch. The argument is the branch target, represented as an index in\n"
"    the code array to jump to.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:271
msgid "`QuoteNode`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:275
#, no-wrap
msgid ""
"    Wraps an arbitrary value to reference as data. For example, the function `f() = :a` contains a\n"
"    `QuoteNode` whose `value` field is the symbol `a`, in order to return the symbol itself instead\n"
"    of evaluating it.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:277
msgid "`GlobalRef`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:279
#, no-wrap
msgid "    Refers to global variable `name` in module `mod`.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:281
msgid "`SSAValue`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:285
#, no-wrap
msgid ""
"    Refers to a consecutively-numbered (starting at 1) static single assignment (SSA) variable inserted\n"
"    by the compiler. The number (`id`) of an `SSAValue` is the code array index of the expression whose\n"
"    value it represents.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:287
msgid "`NewvarNode`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:289
#, no-wrap
msgid "    Marks a point where a variable (slot) is created. This has the effect of resetting a variable to undefined.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:291
#, no-wrap
msgid "`Expr` types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:294
msgid "These symbols appear in the `head` field of [`Expr`](@ref)s in lowered form."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:296
msgid "`call`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:298
#, no-wrap
msgid "    Function call (dynamic dispatch). `args[1]` is the function to call, `args[2:end]` are the arguments.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:300
msgid "`invoke`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:303
#, no-wrap
msgid ""
"    Function call (static dispatch). `args[1]` is the MethodInstance to call, `args[2:end]` are the\n"
"    arguments (including the function that is being called, at `args[2]`).\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:305
msgid "`static_parameter`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:307
#, no-wrap
msgid "    Reference a static parameter by index.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:309
msgid "`gotoifnot`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:311
#, no-wrap
msgid "    Conditional branch. If `args[1]` is false, goes to the index identified in `args[2]`.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:313
msgid "`=`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:315
#, no-wrap
msgid "    Assignment. In the IR, the first argument is always a Slot or a GlobalRef.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:317
msgid "`method`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:319
#, no-wrap
msgid "    Adds a method to a generic function and assigns the result if necessary.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:328
#, no-wrap
msgid ""
"    Has a 1-argument form and a 3-argument form. The 1-argument form arises from the syntax `function foo end`.\n"
"    In the 1-argument form, the argument is a symbol. If this symbol already names a function in the\n"
"    current scope, nothing happens. If the symbol is undefined, a new function is created and assigned\n"
"    to the identifier specified by the symbol. If the symbol is defined but names a non-function,\n"
"    an error is raised. The definition of \"names a function\" is that the binding is constant, and\n"
"    refers to an object of singleton type. The rationale for this is that an instance of a singleton\n"
"    type uniquely identifies the type to add the method to. When the type has fields, it wouldn't\n"
"    be clear whether the method was being added to the instance or its type.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:330
#, no-wrap
msgid "    The 3-argument form has the following arguments:\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:332 ext/julia/doc/src/devdocs/ast.md:354
msgid "`args[1]`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:336
#, no-wrap
msgid ""
"        A function name, or `false` if unknown. If a symbol, then the expression first\n"
"        behaves like the 1-argument form above. This argument is ignored from then on. When\n"
"        this is `false`, it means a method is being added strictly by type, `(::T)(x) = x`.\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:338 ext/julia/doc/src/devdocs/ast.md:358
msgid "`args[2]`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:342
#, no-wrap
msgid ""
"        A `SimpleVector` of argument type data. `args[2][1]` is a `SimpleVector` of the\n"
"        argument types, and `args[2][2]` is a `SimpleVector` of type variables corresponding\n"
"        to the method's static parameters.\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:344 ext/julia/doc/src/devdocs/ast.md:362
msgid "`args[3]`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:348
#, no-wrap
msgid ""
"        A `CodeInfo` of the method itself. For \"out of scope\" method definitions (adding a\n"
"        method to a function that also has methods defined in different scopes) this is an\n"
"        expression that evaluates to a `:lambda` expression.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:350
msgid "`struct_type`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:352
#, no-wrap
msgid "    A 7-argument expression that defines a new `struct`:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:356
#, no-wrap
msgid "        The name of the `struct`\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:360
#, no-wrap
msgid "        A `call` expression that creates `SimpleVector` specifying its parameters\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:364
#, no-wrap
msgid "        A `call` expression that creates `SimpleVector` specifying its fieldnames\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:366
msgid "`args[4]`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:369
#, no-wrap
msgid ""
"        A `Symbol` or `GlobalRef` specifying the supertype (e.g., `:Integer` or\n"
"        `GlobalRef(Core, :Any)`)\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:371
msgid "`args[5]`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:373
#, no-wrap
msgid "        A `call` expression that creates `SimpleVector` specifying its fieldtypes\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:375
msgid "`args[6]`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:377
#, no-wrap
msgid "        A Bool, true if `mutable`\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:379
msgid "`args[7]`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:383
#, no-wrap
msgid ""
"        The number of arguments to initialize. This will be the number\n"
"        of fields, or the minimum number of fields called by an inner\n"
"        constructor's `new` statement.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:385
msgid "`abstract_type`"
msgstr "`abstract_type`"

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:389
#, no-wrap
msgid ""
"    A 3-argument expression that defines a new abstract type. The\n"
"    arguments are the same as the first three arguments of\n"
"    `struct_type` expressions.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:391
msgid "`primitive_type`"
msgstr "`primitive_type`"

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:394
#, no-wrap
msgid ""
"    A 4-argument expression that defines a new primitive type. Arguments 1, 2, and 4\n"
"    are the same as `struct_type`. Argument 3 is the number of bits.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:396
msgid "`global`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:398
#, no-wrap
msgid "    Declares a global binding.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:400
msgid "`const`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:402
#, no-wrap
msgid "    Declares a (global) variable as constant.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:404
msgid "`new`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:408
#, no-wrap
msgid ""
"    Allocates a new struct-like object. First argument is the type. The [`new`](@ref) pseudo-function is lowered\n"
"    to this, and the type is always inserted by the compiler.  This is very much an internal-only\n"
"    feature, and does no checking. Evaluating arbitrary `new` expressions can easily segfault.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:410
msgid "`splatnew`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:413
#, no-wrap
msgid ""
"    Similar to `new`, except field values are passed as a single tuple. Works similarly to\n"
"    `Base.splat(new)` if `new` were a first-class function, hence the name.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:415
msgid "`return`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:417
#, no-wrap
msgid "    Returns its argument as the value of the enclosing function.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:419
msgid "`isdefined`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:422
#, no-wrap
msgid ""
"    `Expr(:isdefined, :x)` returns a Bool indicating whether `x` has\n"
"    already been defined in the current scope.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:424
msgid "`the_exception`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:426
#, no-wrap
msgid "    Yields the caught exception inside a `catch` block, as returned by `jl_current_exception()`.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:428
msgid "`enter`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:431
#, no-wrap
msgid ""
"    Enters an exception handler (`setjmp`). `args[1]` is the label of the catch block to jump to on\n"
"    error.  Yields a token which is consumed by `pop_exception`.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:433
msgid "`leave`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:435
#, no-wrap
msgid "    Pop exception handlers. `args[1]` is the number of handlers to pop.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:437
msgid "`pop_exception`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:440
#, no-wrap
msgid ""
"    Pop the stack of current exceptions back to the state at the associated `enter` when leaving a\n"
"    catch block. `args[1]` contains the token from the associated `enter`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:443
#, no-wrap
msgid ""
"    !!! compat \"Julia 1.1\"\n"
"        `pop_exception` is new in Julia 1.1.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:445
msgid "`inbounds`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:449
#, no-wrap
msgid ""
"    Controls turning bounds checks on or off. A stack is maintained; if the first argument of this\n"
"    expression is true or false (`true` means bounds checks are disabled), it is pushed onto the stack.\n"
"    If the first argument is `:pop`, the stack is popped.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:451
msgid "`boundscheck`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:454
#, no-wrap
msgid ""
"    Has the value `false` if inlined into a section of code marked with `@inbounds`,\n"
"    otherwise has the value `true`.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:456
msgid "`loopinfo`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:459
#, no-wrap
msgid ""
"    Marks the end of the a loop. Contains metadata that is passed to `LowerSimdLoop` to either mark\n"
"    the inner loop of `@simd` expression, or to propagate information to LLVM loop passes.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:461
msgid "`copyast`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:464
#, no-wrap
msgid ""
"    Part of the implementation of quasi-quote. The argument is a surface syntax AST that is simply\n"
"    copied recursively and returned at run time.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:466
msgid "`meta`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:469
#, no-wrap
msgid ""
"    Metadata. `args[1]` is typically a symbol specifying the kind of metadata, and the rest of the\n"
"    arguments are free-form. The following kinds of metadata are commonly used:\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:471
msgid "`:inline` and `:noinline`: Inlining hints."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:473
msgid "`foreigncall`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:475
#, no-wrap
msgid "    Statically-computed container for `ccall` information. The fields are:\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:477
msgid "`args[1]` : name"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:479
#, no-wrap
msgid "        The expression that'll be parsed for the foreign function.\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:481
msgid "`args[2]::Type` : RT"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:483
#, no-wrap
msgid "        The (literal) return type, computed statically when the containing method was defined.\n"
msgstr "        ãã®æ»ãå¤ã®åã¯ãå¯¾è±¡ã®ã¡ã½ãããå®ç¾©ãããã¨ããéçã«è¨ç®ã»è©ä¾¡ããã¾ãã\n"

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:485
msgid "`args[3]::SimpleVector` (of Types) : AT"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:487
#, no-wrap
msgid "        The (literal) vector of argument types, computed statically when the containing method was defined.\n"
msgstr "        ãã®å¼æ°ã®åã®ãã¯ãã«ã¯ãå¯¾è±¡ã®ã¡ã½ãããå®ç¾©ãããã¨ããéçã«è¨ç®ããã¾ãã\n"

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:489
msgid "`args[4]::Int` : nreq"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:491
#, no-wrap
msgid "        The number of required arguments for a varargs function definition.\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:493
msgid "`args[5]::QuoteNode{Symbol}` : calling convention"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:495
#, no-wrap
msgid "        The calling convention for the call.\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:497
msgid "`args[6:length(args[3])]` : arguments"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:499
#, no-wrap
msgid "        The values for all the arguments (with types of each given in args[3]).\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:501
msgid "`args[(length(args[3]) + 1):end]` : gc-roots"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:504
#, no-wrap
msgid ""
"        The additional objects that may need to be gc-rooted for the duration of the call.\n"
"        See [Working with LLVM](@ref Working-with-LLVM) for where these are derived from and how they get handled.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:506
#, no-wrap
msgid "Method"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:509
msgid "A unique'd container describing the shared metadata for a single method."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:511
msgid "`name`, `module`, `file`, `line`, `sig`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:513
#, no-wrap
msgid "    Metadata to uniquely identify the method for the computer and the human.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:515
msgid "`ambig`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:517
#, no-wrap
msgid "    Cache of other methods that may be ambiguous with this one.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:519
msgid "`specializations`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:523
#, no-wrap
msgid ""
"    Cache of all MethodInstance ever created for this Method, used to ensure uniqueness.\n"
"    Uniqueness is required for efficiency, especially for incremental precompile and\n"
"    tracking of method invalidation.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:525
msgid "`source`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:527
#, no-wrap
msgid "    The original source code (if available, usually compressed).\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:529
msgid "`generator`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:531
#, no-wrap
msgid "    A callable object which can be executed to get specialized source for a specific method signature.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:533
msgid "`roots`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:536
#, no-wrap
msgid ""
"    Pointers to non-AST things that have been interpolated into the AST, required by\n"
"    compression of the AST, type-inference, or the generation of native code.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:538
msgid "`nargs`, `isva`, `called`, `isstaged`, `pure`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:540
#, no-wrap
msgid "    Descriptive bit-fields for the source code of this Method.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:542
msgid "`primary_world`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:544
#, no-wrap
msgid "    The world age that \"owns\" this Method.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:546
#, no-wrap
msgid "MethodInstance"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:550
msgid ""
"A unique'd container describing a single callable signature for a Method. See especially [Proper maintenance and care of multi-threading "
"locks](@ref)  for important details on how to modify these fields safely."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:552
msgid "`specTypes`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:555
#, no-wrap
msgid ""
"    The primary key for this MethodInstance. Uniqueness is guaranteed through a\n"
"    `def.specializations` lookup.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:557 ext/julia/doc/src/devdocs/ast.md:587
msgid "`def`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:560
#, no-wrap
msgid ""
"    The `Method` that this function describes a specialization of. Or a `Module`,\n"
"    if this is a top-level Lambda expanded in Module, and which is not part of a Method.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:562
msgid "`sparam_vals`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:567
#, no-wrap
msgid ""
"    The values of the static parameters in `specTypes` indexed by `def.sparam_syms`. For the\n"
"    `MethodInstance` at `Method.unspecialized`, this is the empty `SimpleVector`. But for a\n"
"    runtime `MethodInstance` from the `MethodTable` cache, this will always be defined and\n"
"    indexable.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:569
msgid "`uninferred`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:572
#, no-wrap
msgid ""
"    The uncompressed source code for a toplevel thunk. Additionally, for a generated function,\n"
"    this is one of many places that the source code might be found.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:574
msgid "`backedges`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:579
#, no-wrap
msgid ""
"    We store the reverse-list of cache dependencies for efficient tracking of incremental reanalysis/recompilation work that may be needed after a new method definitions.\n"
"    This works by keeping a list of the other `MethodInstance` that have been inferred or optimized to contain a possible call to this `MethodInstance`.\n"
"    Those optimization results might be stored somewhere in the `cache`, or it might have been the result of something we didn't want to cache, such as constant propagation.\n"
"    Thus we merge all of those backedges to various cache entries here (there's almost always only the one applicable cache entry with a sentinal value for max_world anyways).\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:581
msgid "`cache`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:583
#, no-wrap
msgid "    Cache of `CodeInstance` objects that share this template instantiation.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:584
#, no-wrap
msgid "CodeInstance"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:589
#, no-wrap
msgid "    The `MethodInstance` that this cache entry is derived from.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:592
msgid "`rettype`/`rettype_const`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:595
#, no-wrap
msgid ""
"    The inferred return type for the `specFunctionObject` field, which (in most cases) is\n"
"    also the computed return type for the function in general.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:597 ext/julia/doc/src/devdocs/ast.md:696
msgid "`inferred`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:600
#, no-wrap
msgid ""
"    May contain a cache of the inferred source for this function,\n"
"    or it could be set to `nothing` to just indicate `rettype` is inferred.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:602
msgid "`ftpr`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:604
#, no-wrap
msgid "    The generic jlcall entry point.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:606
msgid "`jlcall_api`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:608
#, no-wrap
msgid "    The ABI to use when calling `fptr`. Some significant ones include:\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:614
msgid "0 - Not compiled yet"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:614
msgid "1 - JL_CALLABLE `jl_value_t *(*)(jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)`"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:614
msgid "2 - Constant (value stored in `rettype_const`)"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:614
msgid "3 - With Static-parameters forwarded `jl_value_t *(*)(jl_svec_t *sparams, jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)`"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:614
msgid "4 - Run in interpreter `jl_value_t *(*)(jl_method_instance_t *meth, jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:616
msgid "`min_world` / `max_world`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:620
#, no-wrap
msgid ""
"    The range of world ages for which this method instance is valid to be called.\n"
"    If max_world is the special token value `-1`, the value is not yet known.\n"
"    It may continue to be used until we encounter a backedge that requires us to reconsider.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ast.md:622
#, no-wrap
msgid "CodeInfo"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:625
msgid "A (usually temporary) container for holding lowered source code."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:627
msgid "`code`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:629
#, no-wrap
msgid "    An `Any` array of statements\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:631
msgid "`slotnames`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:633
#, no-wrap
msgid "    An array of symbols giving names for each slot (argument or local variable).\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:635
msgid "`slotflags`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:637
#, no-wrap
msgid "    A `UInt8` array of slot properties, represented as bit flags:\n"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:642
msgid "2 - assigned (only false if there are *no* assignment statements with this var on the left)"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:642
msgid "8 - const (currently unused for local variables)"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:642
msgid "16 - statically assigned once"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/ast.md:642
msgid "32 - might be used before assigned. This flag is only valid after type inference."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:644
msgid "`ssavaluetypes`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:646
#, no-wrap
msgid "    Either an array or an `Int`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:649
#, no-wrap
msgid ""
"    If an `Int`, it gives the number of compiler-inserted temporary locations in the\n"
"    function (the length of `code` array). If an array, specifies a type for each location.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:651
msgid "`ssaflags`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:653
#, no-wrap
msgid "    Statement-level flags for each expression in the function. Many of these are reserved, but not yet implemented:\n"
msgstr ""

#. type: Bullet: '    * '
#: ext/julia/doc/src/devdocs/ast.md:659
msgid "0 = inbounds"
msgstr ""

#. type: Bullet: '    * '
#: ext/julia/doc/src/devdocs/ast.md:659
msgid "1,2 = <reserved> inlinehint,always-inline,noinline"
msgstr ""

#. type: Bullet: '    * '
#: ext/julia/doc/src/devdocs/ast.md:659
msgid "3 = <reserved> strict-ieee (strictfp)"
msgstr ""

#. type: Bullet: '    * '
#: ext/julia/doc/src/devdocs/ast.md:659
msgid "4-6 = <unused>"
msgstr ""

#. type: Bullet: '    * '
#: ext/julia/doc/src/devdocs/ast.md:659
msgid "7 = <reserved> has out-of-band info"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:661
msgid "`linetable`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:663
#, no-wrap
msgid "    An array of source location objects\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:665
msgid "`codelocs`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:668
#, no-wrap
msgid ""
"    An array of integer indices into the `linetable`, giving the location associated\n"
"    with each statement.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:670
msgid "Optional Fields:"
msgstr "ãªãã·ã§ã³å¼æ°:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:672
msgid "`slottypes`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:674
#, no-wrap
msgid "    An array of types for the slots.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:676
msgid "`rettype`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:678
#, no-wrap
msgid "    The inferred return type of the lowered form (IR). Default value is `Any`.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:680
msgid "`method_for_inference_limit_heuristics`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:683
#, no-wrap
msgid ""
"    The `method_for_inference_heuristics` will expand the given method's generator if\n"
"    necessary during inference.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:685
msgid "`parent`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:687
#, no-wrap
msgid "    The `MethodInstance` that \"owns\" this object (if applicable).\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:689
msgid "`min_world`/`max_world`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:691
#, no-wrap
msgid "    The range of world ages for which this code was valid at the time when it had been inferred.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:694
msgid "Boolean properties:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:698
#, no-wrap
msgid "    Whether this has been produced by type inference.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:700
msgid "`inlineable`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:702
#, no-wrap
msgid "    Whether this should be eligible for inlining.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:704
msgid "`propagate_inbounds`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:707
#, no-wrap
msgid ""
"    Whether this should propagate `@inbounds` when inlined for the purpose of eliding\n"
"    `@boundscheck` blocks.\n"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/ast.md:709
msgid "`pure`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ast.md:711
#, no-wrap
msgid ""
"    Whether this is known to be a pure function of its arguments, without respect to the\n"
"    state of the method caches or other mutable global state.\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/require.md:1
#, no-wrap
msgid "Module loading"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/require.md:5
msgid ""
"[`Base.require`](@ref) is responsible for loading modules and it also manages the precompilation cache. It is the implementation of the "
"`import` statement."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/require.md:6
#, no-wrap
msgid "Experimental features"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/require.md:9
msgid ""
"The features below are experimental and not part of the stable Julia API.  Before building upon them inform yourself about the current "
"thinking and whether they might change soon."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/require.md:10
#, no-wrap
msgid "Module loading callbacks"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/require.md:13
msgid "It is possible to listen to the modules loaded by `Base.require`, by registering a callback."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/require.md:14
#, no-wrap
msgid ""
"loaded_packages = Channel{Symbol}()\n"
"callback = (mod::Symbol) -> put!(loaded_packages, mod)\n"
"push!(Base.package_callbacks, callback)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/require.md:23
msgid ""
"Please note that the symbol given to the callback is a non-unique identifier and it is the responsibility of the callback provider to walk "
"the module chain to determine the fully qualified name of the loaded binding."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/require.md:25
msgid "The callback below is an example of how to do that:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/require.md:26
#, no-wrap
msgid ""
"# Get the fully-qualified name of a module.\n"
"function module_fqn(name::Symbol)\n"
"    fqn = fullname(Base.root_module(name))\n"
"    return join(fqn, '.')\n"
"end\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/callconv.md:1
#, no-wrap
msgid "Calling Conventions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/callconv.md:4
msgid "Julia uses three calling conventions for four distinct purposes:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/callconv.md:11
#, no-wrap
msgid ""
"| Name    | Prefix    | Purpose                          |\n"
"|:------- |:--------- |:-------------------------------- |\n"
"| Native  | `julia_`  | Speed via specialized signatures |\n"
"| JL Call | `jlcall_` | Wrapper for generic calls        |\n"
"| JL Call | `jl_`     | Builtins                         |\n"
"| C ABI   | `jlcapi_` | Wrapper callable from C          |\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/callconv.md:12
#, no-wrap
msgid "Julia Native Calling Convention"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/callconv.md:16
msgid "The native calling convention is designed for fast non-generic calls. It usually uses a specialized signature."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/callconv.md:20
msgid "LLVM ghosts (zero-length types) are omitted."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/callconv.md:20
msgid "LLVM scalars and vectors are passed by value."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/callconv.md:20
msgid "LLVM aggregates (arrays and structs) are passed by reference."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/callconv.md:23
msgid ""
"A small return values is returned as LLVM return values. A large return values is returned via the \"structure return\" (`sret`) convention, "
"where the caller provides a pointer to a return slot."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/callconv.md:26
msgid "An argument or return values that is a homogeneous tuple is sometimes represented as an LLVM vector instead of an LLVM array."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/callconv.md:27
#, no-wrap
msgid "JL Call Convention"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/callconv.md:31
msgid ""
"The JL Call convention is for builtins and generic dispatch. Hand-written functions using this convention are declared via the macro "
"`JL_CALLABLE`. The convention uses exactly 3 parameters:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/callconv.md:35
msgid "`F` - Julia representation of function that is being applied"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/callconv.md:35
msgid "`args` - pointer to array of pointers to boxes"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/callconv.md:35
msgid "`nargs` - length of the array"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/callconv.md:37
msgid "The return value is a pointer to a box."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/callconv.md:38
#, no-wrap
msgid "C ABI"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/callconv.md:42
msgid "C ABI wrappers enable calling Julia from C. The wrapper calls a function using the native calling convention."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/callconv.md:43
msgid "Tuples are always represented as C arrays."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/cartesian.md:1
#, no-wrap
msgid "Base.Cartesian"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:5
msgid ""
"The (non-exported) Cartesian module provides macros that facilitate writing multidimensional algorithms.  Most often you can write such "
"algorithms with [straightforward techniques](https://julialang.org/blog/2016/02/iteration); however, there are a few cases where `Base."
"Cartesian` is still useful or necessary."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/cartesian.md:6
#, no-wrap
msgid "Principles of usage"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:9
msgid "A simple example of usage is:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:10
#, no-wrap
msgid ""
"@nloops 3 i A begin\n"
"    s += @nref 3 A i\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:17
msgid "which generates the following code:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:18
#, no-wrap
msgid ""
"for i_3 = axes(A, 3)\n"
"    for i_2 = axes(A, 2)\n"
"        for i_1 = axes(A, 1)\n"
"            s += A[i_1, i_2, i_3]\n"
"        end\n"
"    end\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:32
msgid ""
"In general, Cartesian allows you to write generic code that contains repetitive elements, like the nested loops in this example.  Other "
"applications include repeated expressions (e.g., loop unwinding) or creating function calls with variable numbers of arguments without using "
"the \"splat\" construct (`i...`)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/cartesian.md:33
#, no-wrap
msgid "Basic syntax"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:36
msgid "The (basic) syntax of `@nloops` is as follows:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/cartesian.md:44
msgid "The first argument must be an integer (*not* a variable) specifying the number of loops."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/cartesian.md:44
msgid ""
"The second argument is the symbol-prefix used for the iterator variable. Here we used `i`, and variables `i_1, i_2, i_3` were generated."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/cartesian.md:44
msgid ""
"The third argument specifies the range for each iterator variable. If you use a variable (symbol)  here, it's taken as `axes(A, dim)`. More "
"flexibly, you can use the anonymous-function expression syntax described below."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/cartesian.md:44
msgid "The last argument is the body of the loop. Here, that's what appears between the `begin...end`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:46
msgid "There are some additional features of `@nloops` described in the [reference section](@ref dev-cartesian-reference)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:51
msgid ""
"`@nref` follows a similar pattern, generating `A[i_1,i_2,i_3]` from `@nref 3 A i`. The general practice is to read from left to right, which "
"is why `@nloops` is `@nloops 3 i A expr` (as in `for i_2 = axes(A, 2)`, where `i_2` is to the left and the range is to the right) whereas "
"`@nref` is `@nref 3 A i` (as in `A[i_1,i_2,i_3]`, where the array comes first)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:54
msgid ""
"If you're developing code with Cartesian, you may find that debugging is easier when you examine the generated code, using `@macroexpand`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:55
#, no-wrap
msgid ""
"DocTestSetup = quote\n"
"    import Base.Cartesian: @nref\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:61
#, no-wrap
msgid ""
"julia> @macroexpand @nref 2 A i\n"
":(A[i_1, i_2])\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/cartesian.md:70
#, no-wrap
msgid "Supplying the number of expressions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:76
msgid ""
"The first argument to both of these macros is the number of expressions, which must be an integer.  When you're writing a function that you "
"intend to work in multiple dimensions, this may not be something you want to hard-code. The recommended approach is to use a `@generated "
"function`.  Here's an example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:77
#, no-wrap
msgid ""
"@generated function mysum(A::Array{T,N}) where {T,N}\n"
"    quote\n"
"        s = zero(T)\n"
"        @nloops $N i A begin\n"
"            s += @nref $N A i\n"
"        end\n"
"        s\n"
"    end\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:90
msgid "Naturally, you can also prepare expressions or perform calculations before the `quote` block."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/cartesian.md:91
#, no-wrap
msgid "Anonymous-function expressions as macro arguments"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:95
msgid ""
"Perhaps the single most powerful feature in `Cartesian` is the ability to supply anonymous-function expressions that get evaluated at "
"parsing time.  Let's consider a simple example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:96
#, no-wrap
msgid "@nexprs 2 j->(i_j = 1)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:102
msgid "`@nexprs` generates `n` expressions that follow a pattern. This code would generate the following statements:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:103
#, no-wrap
msgid ""
"i_1 = 1\n"
"i_2 = 1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:111
msgid ""
"In each generated statement, an \"isolated\" `j` (the variable of the anonymous function) gets replaced by values in the range `1:2`. "
"Generally speaking, Cartesian employs a LaTeX-like syntax.  This allows you to do math on the index `j`.  Here's an example computing the "
"strides of an array:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:112
#, no-wrap
msgid ""
"s_1 = 1\n"
"@nexprs 3 j->(s_{j+1} = s_j * size(A, j))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:118
msgid "would generate expressions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:119
#, no-wrap
msgid ""
"s_1 = 1\n"
"s_2 = s_1 * size(A, 1)\n"
"s_3 = s_2 * size(A, 2)\n"
"s_4 = s_3 * size(A, 3)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:127
msgid "Anonymous-function expressions have many uses in practice."
msgstr ""

#. type: Title ####
#: ext/julia/doc/src/devdocs/cartesian.md:128
#, no-wrap
msgid "[Macro reference](@id dev-cartesian-reference)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/cartesian.md:130
#, no-wrap
msgid ""
"Base.Cartesian.@nloops\n"
"Base.Cartesian.@nref\n"
"Base.Cartesian.@nextract\n"
"Base.Cartesian.@nexprs\n"
"Base.Cartesian.@ncall\n"
"Base.Cartesian.@ntuple\n"
"Base.Cartesian.@nall\n"
"Base.Cartesian.@nany\n"
"Base.Cartesian.@nif\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/sysimg.md:1
#, no-wrap
msgid "System Image Building"
msgstr "ã·ã¹ãã ã¤ã¡ã¼ã¸ã®ãã«ã"

#. type: Title ##
#: ext/julia/doc/src/devdocs/sysimg.md:3
#, no-wrap
msgid "Building the Julia system image"
msgstr "[Julia ã®ã·ã¹ãã ã¤ã¡ã¼ã¸ããã«ããã](@id Building-the-Julia-system-image)"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:10
msgid ""
"Julia ships with a preparsed system image containing the contents of the `Base` module, named `sys.ji`.  This file is also precompiled into "
"a shared library called `sys.{so,dll,dylib}` on as many platforms as possible, so as to give vastly improved startup times.  On systems that "
"do not ship with a precompiled system image file, one can be generated from the source files shipped in Julia's `DATAROOTDIR/julia/base` "
"folder."
msgstr ""
"Julia ã«ã¯ã`sys.ji` ã¨ããååã®ã `Base` ã¢ã¸ã¥ã¼ã«ã®åå®¹ãå«ãäºåè§£ææ¸ã¿ã®ã·ã¹ãã  ã¤ã¡ã¼ã¸ãä»å±ãã¦ãã¾ãã ãã®ãã¡ã¤ã«ã¯ãèµ·åæéã"
"å¤§å¹ã«æ¹åã§ããããã«ãã§ããã ãå¤ãã®ãã©ãããã©ã¼ã ä¸ã§ã`sys.{so,dll,dylib}`ã¨ããå±æã©ã¤ãã©ãªã«ãããªã³ã³ãã¤ã«ããã¾ãã ããªã³ã³ã"
"ã¤ã«æ¸ã¿ã·ã¹ãã ã¤ã¡ã¼ã¸ãã¡ã¤ã« ã Julia ã«ä»å±ãããªããããªã·ã¹ãã ã§ã§ããã°ãJulia ã® `DATAROOTDIR/julia/base` ãã©ã«ãã¼ã«åæ¢±ããã¦ã"
"ãã½ã¼ã¹ã»ãã¡ã¤ã«ããã·ã¹ãã ã¤ã¡ã¼ã¸ãã¡ã¤ã«ãçæã§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:12
msgid "This operation is useful for multiple reasons.  A user may:"
msgstr "ã·ã¹ãã ã¤ã¡ã¼ã¸ã®èªåãã«ãã¯ãè¤æ°ã®çç±ã§å½¹ç«ã¡ã¾ãã ã¦ã¼ã¶ã¼ã¯ä»¥ä¸ãå®è¡ã§ãã¾ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/sysimg.md:18
msgid "Build a precompiled shared library system image on a platform that did not ship with one, thereby improving startup times."
msgstr ""
"Julia ã«ã·ã¹ãã ã¤ã¡ã¼ã¸ãä»å±ãã¦ããªããããªãã©ãããã©ã¼ã ä¸ã§ ããªã³ã³ãã¤ã«æ¸ã¿ã®å±æã©ã¤ãã©ãª ã·ã¹ãã  ã¤ã¡ã¼ã¸ããã«ãããèµ·åæéã"
"ç­ç¸®ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/sysimg.md:18
msgid "Modify `Base`, rebuild the system image and use the new `Base` next time Julia is started."
msgstr "`Base`ãå¤æ´ããã·ã¹ãã ã¤ã¡ã¼ã¸ãåãã«ãããæ¬¡å Julia ãèµ·åããæã«æ°ãã`Base`ãä½¿ç¨ãã¾ãã"

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/sysimg.md:18
msgid ""
"Include a `userimg.jl` file that includes packages into the system image, thereby creating a system image that has packages embedded into "
"the startup environment."
msgstr ""
"ããã±ã¼ã¸ã®include å¦çãè¡ã `userimg.jl` ãã·ã¹ãã ã¤ã¡ã¼ã¸ã«å«ãããã¨ã§ãã¹ã¿ã¼ãã¢ããç°å¢ã«ããã±ã¼ã¸ãåãè¾¼ã¾ããã·ã¹ãã  ã¤ã¡ã¼ã¸ã"
"ä½æãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:21
msgid ""
"The [`PackageCompiler.jl` package](https://github.com/JuliaLang/PackageCompiler.jl) contains convenient wrapper functions to automate this "
"process."
msgstr ""
"[`PackageCompiler.jl` package](https://github.com/JuliaLang/PackageCompiler.jl) ã«ã¯ããã®ãã­ã»ã¹ãèªååããããã®ä¾¿å©ãªã©ããã¼é¢æ°ãå«ã¾"
"ãã¦ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/devdocs/sysimg.md:22
#, no-wrap
msgid "System image optimized for multiple microarchitectures"
msgstr "è¤æ°ã®ãã¤ã¯ã­ã¢ã¼ã­ãã¯ãã£åãã«æé©åãããã·ã¹ãã ã¤ã¡ã¼ã¸"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:30
msgid ""
"The system image can be compiled simultaneously for multiple CPU microarchitectures under the same instruction set architecture (ISA). "
"Multiple versions of the same function may be created with minimum dispatch point inserted into shared functions in order to take advantage "
"of different ISA extensions or other microarchitecture features.  The version that offers the best performance will be selected "
"automatically at runtime based on available CPU features."
msgstr ""
"ã·ã¹ãã  ã¤ã¡ã¼ã¸ã¯ãåãå½ä»¤ã»ãã ã¢ã¼ã­ãã¯ãã£ (ISA) ã®ä¸ã§è¤æ°ã® CPU ãã¤ã¯ã­ã¢ã¼ã­ãã¯ãã£ã¼ã«å¯¾ãã¦åæã«ã³ã³ãã¤ã«ã§ãã¾ããç°ãªã "
"ISA æ¡å¼µæ©è½ããã®ä»ã®ãã¤ã¯ã­ã¢ã¼ã­ãã¯ãã£æ©è½ãå©ç¨ããããã«ãå±æé¢æ°ã«ã¯æå°éã®ãã£ã¹ããããã¤ã³ããæ¿å¥ãããã¨ã§ãè¤æ°ãã¼ã¸ã§ã³ã®"
"é¢æ°ãä½æã§ãã¾ããæé«ã®ããã©ã¼ãã³ã¹ãæä¾ãããã¼ã¸ã§ã³ã¯ãå©ç¨å¯è½ãª CPU æ©è½ã«åºã¥ãã¦å®è¡æã«èªåçã«é¸æããã¾ãã"

#. type: Title ###
#: ext/julia/doc/src/devdocs/sysimg.md:31
#, no-wrap
msgid "Specifying multiple system image targets"
msgstr "è¤æ°ã®ã·ã¹ãã ã»ã¤ã¡ã¼ã¸ã»ã¿ã¼ã²ãããæå®ãã"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:41
msgid ""
"A multi-microarchitecture system image can be enabled by passing multiple targets during system image compilation. This can be done either "
"with the `JULIA_CPU_TARGET` make option or with the `-C` command line option when running the compilation command manually.  Multiple "
"targets are separated by `;` in the option string.  The syntax for each target is a CPU name followed by multiple features separated by `,"
"`.  All features supported by LLVM are supported and a feature can be disabled with a `-` prefix.  (`+` prefix is also allowed and ignored "
"to be consistent with LLVM syntax).  Additionally, a few special features are supported to control the function cloning behavior."
msgstr ""
"ãã«ããã¤ã¯ã­ã¢ã¼ã­ãã¯ãã£ã¼ã®ã·ã¹ãã ã»ã¤ã¡ã¼ã¸ã¯ãã·ã¹ãã ã»ã¤ã¡ã¼ã¸ã®ã³ã³ãã¤ã«ä¸­ã«è¤æ°ã®ã¿ã¼ã²ãããæ¸¡ããã¨ã«ãã£ã¦ä½¿ç¨ãããã¨ãã§ã"
"ã¾ããè¤æ°ã¿ã¼ã²ããã®æå®ã¯ã`JULIA_CPU_TARGET` make ãªãã·ã§ã³ãã¤ãã£ã¦ãã§ãã¾ãããã³ã³ãã¤ã«ã³ãã³ããæåã§å®è¡ããå ´åã¯`-C` ã³ãã³ã"
"ã©ã¤ã³ãªãã·ã§ã³ãä½¿ç¨ãããã¨ãã§ãã¾ãã ãªãã·ã§ã³æå­ååã§è¤æ°ã®ã¿ã¼ã²ããã¯ `;` ã§åºåãã¾ãã åã¿ã¼ã²ããã®æ§æã¯ãCPU åã®å¾ã« `,` "
"ã§åºåãããè¤æ°ã®æ©è½ãè¨ãã¾ãã LLVM ã§ãµãã¼ãããã¦ãããã¹ã¦ã®æ©è½ããµãã¼ãããã¦ããã`-` ãã¬ãã£ãã¯ã¹ãä½¿ç¨ãã¦æ©è½ãç¡å¹ã«ããã"
"ã¨ãã§ãã¾ãã (`+` æ¥é ­é¨ãè¨±å¯ãããLLVM æ§æã¨ä¸è´ããããã«ç¡è¦ããã¾ã)ã ããã«ãé¢æ°ã®è¤è£½åä½ãå¶å¾¡ããããã¤ãã®ç¹å¥ãªæ©è½ããµãã¼ã"
"ããã¦ãã¾ãã"

#. type: Bullet: '1. '
#: ext/julia/doc/src/devdocs/sysimg.md:43
msgid "`clone_all`"
msgstr "`clone_all`"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:50
#, no-wrap
msgid ""
"    By default, only functions that are the most likely to benefit from\n"
"    the microarchitecture features will be cloned.\n"
"    When `clone_all` is specified for a target, however,\n"
"    **all** functions in the system image will be cloned for the target.\n"
"    The negative form `-clone_all` can be used to prevent the built-in\n"
"    heuristic from cloning all functions.\n"
msgstr ""
"    ããã©ã«ãã§ã¯ããã¤ã¯ã­ã¢ã¼ã­ãã¯ãã£æ©è½ããæãæ©æµãåããå¯è½æ§ãæãé«ãé¢æ°ã®ã¿ã¯ã­ã¼ã³ããã¾ãã\n"
"    ã¿ã¼ã²ããã« `clone_all` ãæå®ããã¦ããå ´åã¯ã**å¨ã¦ã®** é¢æ°ãã¿ã¼ã²ããã«å¯¾ãã¦è¤è£½ããã¾ãã\n"
"    è² å½¢å¼ `-clone_all` ãä½¿ç¨ããã¨ãå¨é¢æ°ã®ã¯ã­ã¼ã³ãããçµã¿è¾¼ã¿ã®ãã¥ã¼ãªã¹ãã£ãã¯æä½ãæå¶ãããã¨ãã§ãã¾ãã\n"

#. type: Bullet: '2. '
#: ext/julia/doc/src/devdocs/sysimg.md:52
msgid "`base(<n>)`"
msgstr "`base(<n>)`"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:60
#, no-wrap
msgid ""
"    Where `<n>` is a placeholder for a non-negative number (e.g. `base(0)`, `base(1)`).\n"
"    By default, a partially cloned (i.e. not `clone_all`) target will use functions\n"
"    from the default target (first one specified) if a function is not cloned.\n"
"    This behavior can be changed by specifying a different base with the `base(<n>)` option.\n"
"    The `n`th target (0-based) will be used as the base target instead of the default (`0`th) one.\n"
"    The base target has to be either `0` or another `clone_all` target.\n"
"    Specifying a non-`clone_all` target as the base target will cause an error.\n"
msgstr ""
"    ããã§ã`<n>` ã¯è² ã§ãªãæ°å¤ã®ãã¬ã¼ã¹ãã«ããç¤ºãã¾ã (ãã¨ãã°ã`base(0)`ã`base(1))ãªã©ã\n"
"    é¨åçã«è¤è£½ããã(ã¤ã¾ã`clone_all`ã§ã¯ãªã)ã¿ã¼ã²ããã§ãããé¢æ°ãè¤æ°ããã¦ããªããã°ãåºæ¬ã¿ã¼ã²ããã®é¢æ°ãä½¿ç¨ããã¾ããããã©ã«ãã§åºæ¬ã¿ã¼ã²ããã¯ã`0`çª (æåã«æå®ãããã¿ã¼ã²ãã)ã§ãã\n"
"    `base(<n>)` ãªãã·ã§ã³ã§`n`çªç®ã®ã¿ã¼ã²ãã (0 ããå§ã¾ã) ãåºæ¬ã¿ã¼ã²ããã¨ãã¦æå®ãããã¨ãã§ãã¾ãã\n"
"    åºæ¬ã¿ã¼ã²ããã«æå®ã§ããã®ã¯ã`0`ã¾ãã¯å¥ã®ã¿ã¼ã²ããã®ä¸­ã§ã`clone_all`æå®ãããã¦ãããã®ã§ãªããã°ããã¾ãã.ãããã§ãªãã¨ãã¨ã©ã¼ãçºçãã¾ãã\n"

#. type: Bullet: '3. '
#: ext/julia/doc/src/devdocs/sysimg.md:62
msgid "`opt_size`"
msgstr "`opt_size`"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:65
#, no-wrap
msgid ""
"    This causes the function for the target to be optimized for size when there isn't a significant\n"
"    runtime performance impact. This corresponds to `-Os` GCC and Clang option.\n"
msgstr ""
"    å®è¡æéæ§è½ã¸ã®å½±é¿ãéå¤§ã§ãªãéãã¯ãé¢æ°ã®ãµã¤ãºæé©åãè¡ããã¾ãã\n"
"    ããã¯GCCãClang ã§ããã¨ããã® `-Os` ãªãã·ã§ã³ã«ç¸å½ãã¾ãã\n"

#. type: Bullet: '4. '
#: ext/julia/doc/src/devdocs/sysimg.md:67
msgid "`min_size`"
msgstr "`min_size`"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:70
#, no-wrap
msgid ""
"    This causes the function for the target to be optimized for size that might have\n"
"    a significant runtime performance impact. This corresponds to `-Oz` Clang option.\n"
msgstr ""
"    å®è¡æéæ§è½ã«éå¤§ãªå½±é¿ããã£ãã¨ãã¦ããå¼·å¶çã«ãµã¤ãºæé©åããã¾ãã\n"
"    Clang ãªãã·ã§ã³ã§ããã¨ããã® `-Oz` ã«ç¸å½ãã¾ãã\n"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:73
msgid ""
"As an example, at the time of this writing, the following string is used in the creation of the official `x86_64` Julia binaries "
"downloadable from julialang.org:"
msgstr ""
"ä¾ã¨ãã¦ç¤ºãã¾ãããæ¬ãã¼ã¸å·ç­æç¹ã§ julialang.orgãããã¦ã³ã­ã¼ãå¯è½ãªå¬å¼ã®`x86_64` Julia ãã¤ããªã®ä½æã«ã¯ãæ¬¡ã®ãªãã·ã§ã³æå­åãä½¿ç¨"
"ããã¦ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:74
#, no-wrap
msgid "generic;sandybridge,-xsaveopt,clone_all;haswell,-rdrnd,base(1)\n"
msgstr "generic;sandybridge,-xsaveopt,clone_all;haswell,-rdrnd,base(1)\n"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:88
msgid ""
"This creates a system image with three separate targets; one for a generic `x86_64` processor, one with a `sandybridge` ISA (explicitly "
"excluding `xsaveopt`) that explicitly clones all functions, and one targeting the `haswell` ISA, based off of the `sandybridge` sysimg "
"version, and also excluding `rdrnd`.  When a Julia implementation loads the generated sysimg, it will check the host processor for matching "
"CPU capability flags, enabling the highest ISA level possible.  Note that the base level (`generic`) requires the `cx16` instruction, which "
"is disabled in some virtualization software and must be enabled for the `generic` target to be loaded.  Alternatively, a sysimg could be "
"generated with the target `generic,-cx16` for greater compatibility, however note that this may cause performance and stability problems in "
"some code."
msgstr ""
"ããã«ããã3 ã¤ã®å¥åã®ã¿ã¼ã²ãããæã¤ã·ã¹ãã  ã¤ã¡ã¼ã¸ãä½æããã¾ããä¸ã¤ã¯ãä¸è¬çãª `x86_64` ãã­ã»ããµãããä¸ã¤ã¯ `sandybridge` ISA "
"(æç¤ºçã« `xsaveopt` ãé¤ãã¦ãã¾ã) ãæã¤ãã­ã»ããµã§ããã¹ã¦ã®é¢æ°ãæç¤ºçã«ã¯ã­ã¼ã³åãããªãã·ã§ã³ãæå®ãã¾ãããæå¾ã¯ `haswell` ISA "
"ãã¿ã¼ã²ããã«ãã­ã»ããµã§ã `sandybridge` sysimg ãã¼ã¸ã§ã³ã«åºã¥ãã¦ããã`rdrnd` ãé¤å¤ãã¾ãããJulia å®è£ãçæããã sysimg ãèª­ã¿è¾¼ã"
"ã¨ããã¹ã ãã­ã»ããµã CPU æ©è½ãã©ã°ã¨ã®ä¸è´ããã§ãã¯ããå¯è½ãªéãæé«ã® ISA ã¬ãã«ãæå¹ã«ãã¾ãã åºæ¬ã¬ãã« (`generic`) ã«ã¯`cx16` å½"
"ä»¤ãå¿è¦ã§ãã ãããã¯ãäºææ§ãé«ããããã«ã¿ã¼ã²ãã `generic,-cx16` ã§ sysimg ãçæãããã¨ãã§ãã¾ãããä¸é¨ã®ã³ã¼ãã§ã¯ããã©ã¼ãã³ã¹"
"ã¨å®å®æ§ã®åé¡ãçºçããå¯è½æ§ããããã¨ã«æ³¨æãã¦ãã ããã"

#. type: Title ###
#: ext/julia/doc/src/devdocs/sysimg.md:89
#, no-wrap
msgid "Implementation overview"
msgstr "å®è£æ¦è¦"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:93
msgid ""
"This is a brief overview of different part involved in the implementation.  See code comments for each components for more implementation "
"details."
msgstr "ããã¯ãå®è£ã«é¢é£ãããã¾ãã¾ãªé¨åã®ç°¡åãªæ¦è¦ã§ãã å®è£ã®è©³ç´°ã«ã¤ãã¦ã¯ãåã³ã³ãã¼ãã³ãã®ã³ã¼ã ã³ã¡ã³ããåç§ãã¦ãã ããã"

#. type: Bullet: '1. '
#: ext/julia/doc/src/devdocs/sysimg.md:95
msgid "System image compilation"
msgstr "ã·ã¹ãã ã¤ã¡ã¼ã¸ã®ã³ã³ãã¤ã«"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:105
#, no-wrap
msgid ""
"    The parsing and cloning decision are done in `src/processor*`.\n"
"    We currently support cloning of function based on the present of loops, simd instructions,\n"
"    or other math operations (e.g. fastmath, fma, muladd).\n"
"    This information is passed on to `src/llvm-multiversioning.cpp` which does the actual cloning.\n"
"    In addition to doing the cloning and insert dispatch slots\n"
"    (see comments in `MultiVersioning::runOnModule` for how this is done),\n"
"    the pass also generates metadata so that the runtime can load and initialize the\n"
"    system image correctly.\n"
"    A detail description of the metadata is available in `src/processor.h`.\n"
msgstr ""
"    è§£æã¨ã¯ã­ã¼ã³ä½æã®æ±ºå®ã¯ `src/processor*` ã§è¡ããã¾ãã\n"
"    ç¾å¨ããµãã¼ããã¦ããã®ã¯ãã«ã¼ããsimdå½ä»¤ãã¾ãã¯ä»ã®æ°å­¦æ¼ç®(ä¾ãã°ãfastmath, fmaãmuladd)ãªã©ã®å­å¨ã«åºã¥ãé¢æ°ã®clone æ©è½ã§ãã\n"
"    ãã®æå ±ã¯ãå®éã®ã¯ã­ã¼ã³ä½æãè¡ã `src/llvm-multiversioning.cpp` ã«æ¸¡ããã¾ãã\n"
"    ãã®æå ±ã®åãæ¸¡ãã§ãã¯ã­ã¼ãã³ã°ã¨ãã£ã¹ãããã¹ã­ããã®æ¿å¥ã«å ãã¦ (ãã®æ¹æ³ã«ã¤ãã¦ã¯ã`MultiVersioning::runOnModule`ã®ã³ã¡ã³ããåç§ãã¦ãã ãã)ã ã¡ã¿ãã¼ã¿ã®çæãè¡ããããããã©ã³ã¿ã¤ã ã¯ãã·ã¹ãã  ã¤ã¡ã¼ã¸ãã­ã¼ãã»åæåãããã¨ãã§ãã¾ãã\n"
"    ã¡ã¿ãã¼ã¿ã®è©³ç´°ãªèª¬æã¯ `src/processor.h` ãã¿ãã¨åããã¾ãã\n"

#. type: Bullet: '2. '
#: ext/julia/doc/src/devdocs/sysimg.md:107
msgid "System image loading"
msgstr "ã·ã¹ãã ã¤ã¡ã¼ã¸ã®èª­ã¿è¾¼ã¿"

#. type: Plain text
#: ext/julia/doc/src/devdocs/sysimg.md:113
#, no-wrap
msgid ""
"    The loading and initialization of the system image is done in `src/processor*` by\n"
"    parsing the metadata saved during system image generation.\n"
"    Host feature detection and selection decision are done in `src/processor_*.cpp`\n"
"    depending on the ISA. The target selection will prefer exact CPU name match,\n"
"    larger vector register size, and larget number of features.\n"
"    An overview of this process is in `src/processor.cpp`.\n"
msgstr ""
"    ã·ã¹ãã  ã¤ã¡ã¼ã¸ã®èª­ã¿è¾¼ã¿ã¨åæåã¯`src/processor*` ã§ãã·ã¹ãã  ã¤ã¡ã¼ã¸ã®çæä¸­ã«ä¿å­ãããã¡ã¿ãã¼ã¿ã§è§£æãããã¨ã§è¡ããã¾ãã\n"
"    ãã¹ãæ©è½ã®æ¤åºã¨é¸æã®æ±ºå®ã¯`src/processor_*.cpp` ã§è¡ããã¾ãããã¡ã¤ã«ã¯ãISA ã«ãã£ã¦ç°ãªãã¾ãã\n"
"    ã¿ã¼ã²ããã®é¸æã§ã¯ãã¾ãã¯ãå®å¨ã«ä¸è´ãã CPU åãããå¤§ãããã¯ã¿ã¼ ã¬ã¸ã¹ã¿ãµã¤ãºãããã¦ããå¤ããã£ã¼ãã£ã¼ã®æ°ã®ãã®ãåªåããã¾ãã\n"
"    ãã®ãã­ã»ã¹ã®æ¦è¦ã¯`src/processor.cpp`ã«ããã¾ãã\n"

#. type: Title #
#: ext/julia/doc/src/devdocs/offset-arrays.md:1
#, no-wrap
msgid "[Arrays with custom indices](@id man-custom-indices)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:9
msgid ""
"Conventionally, Julia's arrays are indexed starting at 1, whereas some other languages start numbering at 0, and yet others (e.g., Fortran) "
"allow you to specify arbitrary starting indices.  While there is much merit in picking a standard (i.e., 1 for Julia), there are some "
"algorithms which simplify considerably if you can index outside the range `1:size(A,d)` (and not just `0:size(A,d)-1`, either).  To "
"facilitate such computations, Julia supports arrays with arbitrary indices."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:16
msgid ""
"The purpose of this page is to address the question, \"what do I have to do to support such arrays in my own code?\" First, let's address "
"the simplest case: if you know that your code will never need to handle arrays with unconventional indexing, hopefully the answer is "
"\"nothing.\" Old code, on conventional arrays, should function essentially without alteration as long as it was using the exported "
"interfaces of Julia.  If you find it more convenient to just force your users to supply traditional arrays where indexing starts at one, you "
"can add"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:17
#, no-wrap
msgid "Base.require_one_based_indexing(arrays...)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:23
msgid "where `arrays...` is a list of the array objects that you wish to check for anything that violates 1-based indexing."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/offset-arrays.md:24
#, no-wrap
msgid "Generalizing existing code"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:27
msgid "As an overview, the steps are:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/offset-arrays.md:31
msgid "replace many uses of `size` with `axes`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/offset-arrays.md:31
msgid "replace `1:length(A)` with `eachindex(A)`, or in some cases `LinearIndices(A)`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/offset-arrays.md:31
msgid "replace explicit allocations like `Array{Int}(undef, size(B))` with `similar(Array{Int}, axes(B))`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:33
msgid "These are described in more detail below."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/offset-arrays.md:34
#, no-wrap
msgid "Things to watch out for"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:41
msgid ""
"Because unconventional indexing breaks many people's assumptions that all arrays start indexing with 1, there is always the chance that "
"using such arrays will trigger errors.  The most frustrating bugs would be incorrect results or segfaults (total crashes of Julia).  For "
"example, consider the following function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:42
#, no-wrap
msgid ""
"function mycopy!(dest::AbstractVector, src::AbstractVector)\n"
"    length(dest) == length(src) || throw(DimensionMismatch(\"vectors must match\"))\n"
"    # OK, now we're safe to use @inbounds, right? (not anymore!)\n"
"    for i = 1:length(src)\n"
"        @inbounds dest[i] = src[i]\n"
"    end\n"
"    dest\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:56
msgid ""
"This code implicitly assumes that vectors are indexed from 1; if `dest` starts at a different index than `src`, there is a chance that this "
"code would trigger a segfault.  (If you do get segfaults, to help locate the cause try running julia with the option `--check-bounds=yes`.)"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/offset-arrays.md:57
#, no-wrap
msgid "Using `axes` for bounds checks and loop iteration"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:63
msgid ""
"`axes(A)` (reminiscent of `size(A)`) returns a tuple of `AbstractUnitRange` objects, specifying the range of valid indices along each "
"dimension of `A`.  When `A` has unconventional indexing, the ranges may not start at 1.  If you just want the range for a particular "
"dimension `d`, there is `axes(A, d)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:68
msgid ""
"Base implements a custom range type, `OneTo`, where `OneTo(n)` means the same thing as `1:n` but in a form that guarantees (via the type "
"system) that the lower index is 1. For any new [`AbstractArray`](@ref)  type, this is the default returned by `axes`, and it indicates that "
"this array type uses \"conventional\" 1-based indexing."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:71
msgid "For bounds checking, note that there are dedicated functions `checkbounds` and `checkindex` which can sometimes simplify such tests."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/offset-arrays.md:72
#, no-wrap
msgid "Linear indexing (`LinearIndices`)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:76
msgid ""
"Some algorithms are most conveniently (or efficiently) written in terms of a single linear index, `A[i]` even if `A` is multi-dimensional. "
"Regardless of the array's native indices, linear indices always range from `1:length(A)`. However, this raises an ambiguity for one-"
"dimensional arrays (a.k.a., [`AbstractVector`](@ref)): does `v[i]` mean linear indexing , or Cartesian indexing with the array's native "
"indices?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:78
msgid ""
"For this reason, your best option may be to iterate over the array with `eachindex(A)`, or, if you require the indices to be sequential "
"integers, to get the index range by calling `LinearIndices(A)`. This will return `axes(A, 1)` if A is an AbstractVector, and the equivalent "
"of `1:length(A)` otherwise."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:80
msgid ""
"By this definition, 1-dimensional arrays always use Cartesian indexing with the array's native indices. To help enforce this, it's worth "
"noting that the index conversion functions will throw an error if shape indicates a 1-dimensional array with unconventional indexing (i.e., "
"is a `Tuple{UnitRange}` rather than a tuple of `OneTo`). For arrays with conventional indexing, these functions continue to work the same as "
"always."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:82
msgid "Using `axes` and `LinearIndices`, here is one way you could rewrite `mycopy!`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:83
#, no-wrap
msgid ""
"function mycopy!(dest::AbstractVector, src::AbstractVector)\n"
"    axes(dest) == axes(src) || throw(DimensionMismatch(\"vectors must match\"))\n"
"    for i in LinearIndices(src)\n"
"        @inbounds dest[i] = src[i]\n"
"    end\n"
"    dest\n"
"end\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/offset-arrays.md:93
#, no-wrap
msgid "Allocating storage using generalizations of `similar`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:102
#, no-wrap
msgid ""
"Storage is often allocated with `Array{Int}(undef, dims)` or `similar(A, args...)`. When the result needs\n"
"to match the indices of some other array, this may not always suffice. The generic replacement\n"
"for such patterns is to use `similar(storagetype, shape)`.  `storagetype` indicates the kind of\n"
"underlying \"conventional\" behavior you'd like, e.g., `Array{Int}` or `BitArray` or even `dims->zeros(Float32, dims)`\n"
"(which would allocate an all-zeros array). `shape` is a tuple of [`Integer`](@ref) or\n"
"`AbstractUnitRange` values, specifying the indices that you want the result to use. Note that\n"
"a convenient way of producing an all-zeros array that matches the indices of A is simply `zeros(A)`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:109
msgid ""
"Let's walk through a couple of explicit examples. First, if `A` has conventional indices, then `similar(Array{Int}, axes(A))` would end up "
"calling `Array{Int}(undef, size(A))`, and thus return an array.  If `A` is an `AbstractArray` type with unconventional indexing, then "
"`similar(Array{Int}, axes(A))` should return something that \"behaves like\" an `Array{Int}` but with a shape (including indices)  that "
"matches `A`.  (The most obvious implementation is to allocate an `Array{Int}(undef, size(A))` and then \"wrap\" it in a type that shifts the "
"indices.)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:112
msgid ""
"Note also that `similar(Array{Int}, (axes(A, 2),))` would allocate an `AbstractVector{Int}` (i.e., 1-dimensional array) that matches the "
"indices of the columns of `A`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/offset-arrays.md:113
#, no-wrap
msgid "Writing custom array types with non-1 indexing"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:117
msgid ""
"Most of the methods you'll need to define are standard for any `AbstractArray` type, see [Abstract Arrays](@ref man-interface-array).  This "
"page focuses on the steps needed to define unconventional indexing."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/offset-arrays.md:118
#, no-wrap
msgid "Custom `AbstractUnitRange` types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:125
msgid ""
"If you're writing a non-1 indexed array type, you will want to specialize `axes` so it returns a `UnitRange`, or (perhaps better) a custom "
"`AbstractUnitRange`.  The advantage of a custom type is that it \"signals\" the allocation type for functions like `similar`. If we're "
"writing an array type for which indexing will start at 0, we likely want to begin by creating a new `AbstractUnitRange`, `ZeroRange`, where "
"`ZeroRange(n)` is equivalent to `0:n-1`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:131
#, no-wrap
msgid ""
"In general, you should probably *not* export `ZeroRange` from your package: there may be other\n"
"packages that implement their own `ZeroRange`, and having multiple distinct `ZeroRange` types\n"
"is (perhaps counterintuitively) an advantage: `ModuleA.ZeroRange` indicates that `similar` should\n"
"create a `ModuleA.ZeroArray`, whereas `ModuleB.ZeroRange` indicates a `ModuleB.ZeroArray` type.\n"
" This design allows peaceful coexistence among many different custom array types.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:134
msgid ""
"Note that the Julia package [CustomUnitRanges.jl](https://github.com/JuliaArrays/CustomUnitRanges.jl)  can sometimes be used to avoid the "
"need to write your own `ZeroRange` type."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/offset-arrays.md:135
#, no-wrap
msgid "Specializing `axes`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:138
msgid "Once you have your `AbstractUnitRange` type, then specialize `axes`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:139
#, no-wrap
msgid "Base.axes(A::ZeroArray) = map(n->ZeroRange(n), A.size)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:145
msgid "where here we imagine that `ZeroArray` has a field called `size` (there would be other ways to implement this)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:147
msgid "In some cases, the fallback definition for `axes(A, d)`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:148
#, no-wrap
msgid "axes(A::AbstractArray{T,N}, d) where {T,N} = d <= N ? axes(A)[d] : OneTo(1)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:156
#, no-wrap
msgid ""
"may not be what you want: you may need to specialize it to return something other than `OneTo(1)`\n"
"when `d > ndims(A)`.  Likewise, in `Base` there is a dedicated function `axes1` which is equivalent\n"
"to `axes(A, 1)` but which avoids checking (at runtime) whether `ndims(A) > 0`. (This is purely\n"
"a performance optimization.)  It is defined as:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:157
#, no-wrap
msgid ""
"axes1(A::AbstractArray{T,0}) where {T} = OneTo(1)\n"
"axes1(A::AbstractArray) = axes(A)[1]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:164
msgid "If the first of these (the zero-dimensional case) is problematic for your custom array type, be sure to specialize it appropriately."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/offset-arrays.md:165
#, no-wrap
msgid "Specializing `similar`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:169
msgid "Given your custom `ZeroRange` type, then you should also add the following two specializations for `similar`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:170
#, no-wrap
msgid ""
"function Base.similar(A::AbstractArray, T::Type, shape::Tuple{ZeroRange,Vararg{ZeroRange}})\n"
"    # body\n"
"end\n"
"\n"
"function Base.similar(f::Union{Function,DataType}, shape::Tuple{ZeroRange,Vararg{ZeroRange}})\n"
"    # body\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:181
msgid "Both of these should allocate your custom array type."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/offset-arrays.md:182
#, no-wrap
msgid "Specializing `reshape`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:185
msgid "Optionally, define a method"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:186
#, no-wrap
msgid "Base.reshape(A::AbstractArray, shape::Tuple{ZeroRange,Vararg{ZeroRange}}) = ...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:191
msgid "and you can `reshape` an array so that the result has custom indices."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/offset-arrays.md:192
#, no-wrap
msgid "For objects that mimic AbstractArray but are not subtypes"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:196
msgid ""
"`has_offset_axes` depends on having `axes` defined for the objects you call it on. If there is some reason you don't have an `axes` method "
"defined for your object, consider defining a method"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:196
#, no-wrap
msgid "Base.has_offset_axes(obj::MyNon1IndexedArraylikeObject) = true\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:202
msgid ""
"This will allow code that assumes 1-based indexing to detect a problem and throw a helpful error, rather than returning incorrect results or "
"segfaulting julia."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/offset-arrays.md:203
#, no-wrap
msgid "Catching errors"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:207
msgid ""
"If your new array type triggers errors in other code, one helpful debugging step can be to comment out `@boundscheck` in your `getindex` and "
"`setindex!` implementation.  This will ensure that every element access checks bounds. Or, restart julia with `--check-bounds=yes`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/offset-arrays.md:209
msgid ""
"In some cases it may also be helpful to temporarily disable `size` and `length` for your new array type, since code that makes incorrect "
"assumptions frequently uses these functions."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/functions.md:1
#, no-wrap
msgid "Julia Functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:4
msgid "This document will explain how functions, method definitions, and method tables work."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/functions.md:5
#, no-wrap
msgid "Method Tables"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:12
msgid ""
"Every function in Julia is a generic function. A generic function is conceptually a single function, but consists of many definitions, or "
"methods. The methods of a generic function are stored in a method table. Method tables (type `MethodTable`) are associated with `TypeName`s. "
"A `TypeName` describes a family of parameterized types. For example `Complex{Float32}` and `Complex{Float64}` share the same `Complex` type "
"name object."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:15
msgid "All objects in Julia are potentially callable, because every object has a type, which in turn has a `TypeName`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/functions.md:16
#, no-wrap
msgid "Function calls"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:23
msgid ""
"Given the call `f(x,y)`, the following steps are performed: first, the method table to use is accessed as `typeof(f).name.mt`. Second, an "
"argument tuple type is formed, `Tuple{typeof(f), typeof(x), typeof(y)}`.  Note that the type of the function itself is the first element. "
"This is because the type might have parameters, and so needs to take part in dispatch. This tuple type is looked up in the method table."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:26
msgid ""
"This dispatch process is performed by `jl_apply_generic`, which takes two arguments: a pointer to an array of the values f, x, and y, and "
"the number of values (in this case 3)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:32
msgid ""
"Throughout the system, there are two kinds of APIs that handle functions and argument lists: those that accept the function and arguments "
"separately, and those that accept a single argument structure.  In the first kind of API, the \"arguments\" part does *not* contain "
"information about the function, since that is passed separately. In the second kind of API, the function is the first element of the "
"argument structure."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:35
msgid ""
"For example, the following function for performing a call accepts just an `args` pointer, so the first element of the args array will be the "
"function to call:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:36
#, no-wrap
msgid "jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:42
msgid "This entry point for the same functionality accepts the function separately, so the `args` array does not contain the function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:43
#, no-wrap
msgid "jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/functions.md:47
#, no-wrap
msgid "Adding methods"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:54
msgid ""
"Given the above dispatch process, conceptually all that is needed to add a new method is (1) a tuple type, and (2) code for the body of the "
"method. `jl_method_def` implements this operation.  `jl_first_argument_datatype` is called to extract the relevant method table from what "
"would be the type of the first argument. This is much more complicated than the corresponding procedure during dispatch, since the argument "
"tuple type might be abstract. For example, we can define:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:55
#, no-wrap
msgid "(::Union{Foo{Int},Foo{Int8}})(x) = 0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:60
msgid "which works since all possible matching methods would belong to the same method table."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/functions.md:61
#, no-wrap
msgid "Creating generic functions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:68
msgid ""
"Since every object is callable, nothing special is needed to create a generic function. Therefore `jl_new_generic_function` simply creates a "
"new singleton (0 size) subtype of `Function` and returns its instance. A function can have a mnemonic \"display name\" which is used in "
"debug info and when printing objects. For example the name of `Base.sin` is `sin`. By convention, the name of the created *type* is the same "
"as the function name, with a `#` prepended. So `typeof(sin)` is `Base.#sin`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/functions.md:69
#, no-wrap
msgid "Closures"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:73
msgid "A closure is simply a callable object with field names corresponding to captured variables. For example, the following code:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:74
#, no-wrap
msgid ""
"function adder(x)\n"
"    return y->x+y\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:81
msgid "is lowered to (roughly):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:82
#, no-wrap
msgid ""
"struct ##1{T}\n"
"    x::T\n"
"end\n"
"\n"
"(_::##1)(y) = _.x + y\n"
"\n"
"function adder(x)\n"
"    return ##1(x)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:99
msgid ""
"A constructor call is just a call to a type. The method table for `Type` contains all constructor definitions. All subtypes of `Type` "
"(`Type`, `UnionAll`, `Union`, and `DataType`)  currently share a method table via special arrangement."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/functions.md:100
#, no-wrap
msgid "Builtins"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:103
msgid "The \"builtin\" functions, defined in the `Core` module, are:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:104
#, no-wrap
msgid ""
"=== typeof sizeof <: isa typeassert throw tuple getfield setfield! fieldtype\n"
"nfields isdefined arrayref arrayset arraysize applicable invoke apply_type _apply\n"
"_expr svec\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:113
msgid ""
"These are all singleton objects whose types are subtypes of `Builtin`, which is a subtype of `Function`. Their purpose is to expose entry "
"points in the run time that use the \"jlcall\" calling convention:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:114
#, no-wrap
msgid "jl_value_t *(jl_value_t*, jl_value_t**, uint32_t)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:121
msgid ""
"The method tables of builtins are empty. Instead, they have a single catch-all method cache entry (`Tuple{Vararg{Any}}`) whose jlcall fptr "
"points to the correct function. This is kind of a hack but works reasonably well."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/functions.md:122
#, no-wrap
msgid "Keyword arguments"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:133
msgid ""
"Keyword arguments work by associating a special, hidden function object with each method table that has definitions with keyword arguments. "
"This function is called the \"keyword argument sorter\" or \"keyword sorter\", or \"kwsorter\", and is stored in the `kwsorter` field of "
"`MethodTable` objects.  Every definition in the kwsorter function has the same arguments as some definition in the normal method table, "
"except with a single `NamedTuple` argument prepended, which gives the names and values of passed keyword arguments. The kwsorter's job is to "
"move keyword arguments into their canonical positions based on name, plus evaluate and substitute any needed default value expressions. The "
"result is a normal positional argument list, which is then passed to yet another compiler-generated function."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:136
msgid "The easiest way to understand the process is to look at how a keyword argument method definition is lowered. The code:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:137
#, no-wrap
msgid ""
"function circle(center, radius; color = black, fill::Bool = true, options...)\n"
"    # draw\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:146
msgid ""
"actually produces *three* method definitions. The first is a function that accepts all arguments (including keyword arguments) as positional "
"arguments, and includes the code for the method body.  It has an auto-generated name:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:147
#, no-wrap
msgid ""
"function #circle#1(color, fill::Bool, options, circle, center, radius)\n"
"    # draw\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:155
msgid ""
"The second method is an ordinary definition for the original `circle` function, which handles the case where no keyword arguments are passed:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:156
#, no-wrap
msgid ""
"function circle(center, radius)\n"
"    #circle#1(black, true, pairs(NamedTuple()), circle, center, radius)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:166
msgid ""
"This simply dispatches to the first method, passing along default values.  `pairs` is applied to the named tuple of rest arguments to "
"provide key-value pair iteration.  Note that if the method doesn't accept rest keyword arguments then this argument is absent."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:168
msgid "Finally there is the kwsorter definition:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:169
#, no-wrap
msgid ""
"function (::Core.kwftype(typeof(circle)))(kws, circle, center, radius)\n"
"    if haskey(kws, :color)\n"
"        color = kws.color\n"
"    else\n"
"        color = black\n"
"    end\n"
"    # etc.\n"
"\n"
"    # put remaining kwargs in `options`\n"
"    options = structdiff(kws, NamedTuple{(:color, :fill)})\n"
"\n"
"    # if the method doesn't accept rest keywords, throw an error\n"
"    # unless `options` is empty\n"
"\n"
"    #circle#1(color, fill, pairs(options), circle, center, radius)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:190
msgid ""
"The function `Core.kwftype(t)` creates the field `t.name.mt.kwsorter` (if it hasn't been created yet), and returns the type of that function."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:195
msgid ""
"This design has the feature that call sites that don't use keyword arguments require no special handling; everything works as if they were "
"not part of the language at all. Call sites that do use keyword arguments are dispatched directly to the called function's kwsorter. For "
"example the call:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:196
#, no-wrap
msgid "circle((0,0), 1.0, color = red; other...)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:201
msgid "is lowered to:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:202
#, no-wrap
msgid "kwfunc(circle)(merge((color = red,), other), circle, (0,0), 1.0)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:212
#, no-wrap
msgid ""
" `kwfunc` (also in`Core`) fetches the kwsorter for the called function.\n"
"The keyword splatting operation (written as `other...`) calls the named tuple `merge` function.\n"
"This function further unpacks each *element* of `other`, expecting each one to contain two values\n"
"(a symbol and a value).\n"
"Naturally, a more efficient implementation is available if all splatted arguments are named tuples.\n"
"Notice that the original `circle` function is passed through, to handle closures.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/functions.md:213
#, no-wrap
msgid "Compiler efficiency issues"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:221
msgid ""
"Generating a new type for every function has potentially serious consequences for compiler resource use when combined with Julia's "
"\"specialize on all arguments by default\" design. Indeed, the initial implementation of this design suffered from much longer build and "
"test times, higher memory use, and a system image nearly 2x larger than the baseline. In a naive implementation, the problem is bad enough "
"to make the system nearly unusable. Several significant optimizations were needed to make the design practical."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:233
msgid ""
"The first issue is excessive specialization of functions for different values of function-valued arguments. Many functions simply \"pass "
"through\" an argument to somewhere else, e.g. to another function or to a storage location. Such functions do not need to be specialized for "
"every closure that might be passed in. Fortunately this case is easy to distinguish by simply considering whether a function *calls* one of "
"its arguments (i.e. the argument appears in \"head position\" somewhere).  Performance-critical higher-order functions like `map` certainly "
"call their argument function and so will still be specialized as expected. This optimization is implemented by recording which arguments are "
"called during the `analyze-variables` pass in the front end. When `cache_method` sees an argument in the `Function` type hierarchy passed to "
"a slot declared as `Any` or `Function`, it behaves as if the `@nospecialize` annotation were applied. This heuristic seems to be extremely "
"effective in practice."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:246
msgid ""
"The next issue concerns the structure of method cache hash tables. Empirical studies show that the vast majority of dynamically-dispatched "
"calls involve one or two arguments. In turn, many of these cases can be resolved by considering only the first argument. (Aside: proponents "
"of single dispatch would not be surprised by this at all. However, this argument means \"multiple dispatch is easy to optimize in practice"
"\", and that we should therefore use it, *not* \"we should use single dispatch\"!) So the method cache uses the type of the first argument "
"as its primary key. Note, however, that this corresponds to the *second* element of the tuple type for a function call (the first element "
"being the type of the function itself). Typically, type variation in head position is extremely low -- indeed, the majority of functions "
"belong to singleton types with no parameters.  However, this is not the case for constructors, where a single method table holds "
"constructors for every type. Therefore the `Type` method table is special-cased to use the *first* tuple type element instead of the second."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:254
msgid ""
"The front end generates type declarations for all closures. Initially, this was implemented by generating normal type declarations. However, "
"this produced an extremely large number of constructors, all of which were trivial (simply passing all arguments through to [`new`](@ref)). "
"Since methods are partially ordered, inserting all of these methods is O(n^2), plus there are just too many of them to keep around. This was "
"optimized by generating `struct_type` expressions directly (bypassing default constructor generation), and using `new` directly to create "
"closure instances. Not the prettiest thing ever, but you do what you gotta do."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/functions.md:258
msgid ""
"The next problem was the `@test` macro, which generated a 0-argument closure for each test case.  This is not really necessary, since each "
"test case is simply run once in place. Therefore, `@test` was modified to expand to a try-catch block that records the test result (true, "
"false, or exception raised) and calls the test suite handler on it."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/stdio.md:1
#, no-wrap
msgid "printf() and stdio in the Julia runtime"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/stdio.md:3
#, no-wrap
msgid "Libuv wrappers for stdio"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:6
msgid "`julia.h` defines [libuv](http://docs.libuv.org) wrappers for the `stdio.h` streams:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:7
#, no-wrap
msgid ""
"uv_stream_t *JL_STDIN;\n"
"uv_stream_t *JL_STDOUT;\n"
"uv_stream_t *JL_STDERR;\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:14
msgid "... and corresponding output functions:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:15
#, no-wrap
msgid ""
"int jl_printf(uv_stream_t *s, const char *format, ...);\n"
"int jl_vprintf(uv_stream_t *s, const char *format, va_list args);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:22
msgid ""
"These `printf` functions are used by the `.c` files in the `src/` and `ui/` directories wherever stdio is needed to ensure that output "
"buffering is handled in a unified way."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:25
msgid ""
"In special cases, like signal handlers, where the full libuv infrastructure is too heavy, `jl_safe_printf()` can be used to [`write(2)`]"
"(@ref) directly to `STDERR_FILENO`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:26
#, no-wrap
msgid "void jl_safe_printf(const char *str, ...);\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/stdio.md:30
#, no-wrap
msgid "Interface between JL_STD* and Julia code"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:34
msgid "[`Base.stdin`](@ref), [`Base.stdout`](@ref) and [`Base.stderr`](@ref) are bound to the `JL_STD*` libuv streams defined in the runtime."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:37
msgid ""
"Julia's `__init__()` function (in `base/sysimg.jl`) calls `reinit_stdio()` (in `base/stream.jl`)  to create Julia objects for [`Base.stdin`]"
"(@ref), [`Base.stdout`](@ref) and [`Base.stderr`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:41
msgid ""
"`reinit_stdio()` uses [`ccall`](@ref) to retrieve pointers to `JL_STD*` and calls `jl_uv_handle_type()` to inspect the type of each stream.  "
"It then creates a Julia `Base.IOStream`, `Base.TTY` or `Base.PipeEndpoint` object to represent each stream, e.g.:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:42
#, no-wrap
msgid ""
"$ julia -e 'println(typeof((stdin, stdout, stderr)))'\n"
"Tuple{Base.TTY,Base.TTY,Base.TTY}\n"
"\n"
"$ julia -e 'println(typeof((stdin, stdout, stderr)))' < /dev/null 2>/dev/null\n"
"Tuple{IOStream,Base.TTY,IOStream}\n"
"\n"
"$ echo hello | julia -e 'println(typeof((stdin, stdout, stderr)))' | cat\n"
"Tuple{Base.PipeEndpoint,Base.PipeEndpoint,Base.TTY}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:55
msgid ""
"The [`Base.read`](@ref) and [`Base.write`](@ref) methods for these streams use [`ccall`](@ref)  to call libuv wrappers in `src/jl_uv.c`, e."
"g.:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:56
#, no-wrap
msgid ""
"stream.jl: function write(s::IO, p::Ptr, nb::Integer)\n"
"               -> ccall(:jl_uv_write, ...)\n"
"  jl_uv.c:          -> int jl_uv_write(uv_stream_t *stream, ...)\n"
"                        -> uv_write(uvw, stream, buf, ...)\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/stdio.md:63
#, no-wrap
msgid "printf() during initialization"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:69
msgid ""
"The libuv streams relied upon by `jl_printf()` etc., are not available until midway through initialization of the runtime (see `init.c`, "
"`init_stdio()`).  Error messages or warnings that need to be printed before this are routed to the standard C library `fwrite()` function by "
"the following mechanism:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:73
msgid ""
"In `sys.c`, the `JL_STD*` stream pointers are statically initialized to integer constants: `STD*_FILENO (0, 1 and 2)`.  In `jl_uv.c` the "
"`jl_uv_puts()` function checks its `uv_stream_t* stream` argument and calls `fwrite()` if stream is set to `STDOUT_FILENO` or "
"`STDERR_FILENO`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:76
msgid ""
"This allows for uniform use of `jl_printf()` throughout the runtime regardless of whether or not any particular piece of code is reachable "
"before initialization is complete."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/stdio.md:77
#, no-wrap
msgid "Legacy `ios.c` library"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:81
msgid ""
"The `src/support/ios.c` library is inherited from [femtolisp](https://github.com/JeffBezanson/femtolisp).  It provides cross-platform "
"buffered file IO and in-memory temporary buffers."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:83
msgid "`ios.c` is still used by:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/stdio.md:88
msgid "`src/flisp/*.c`"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/stdio.md:88
msgid "`src/dump.c` â for serialization file IO and for memory buffers."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/stdio.md:88
msgid "`src/staticdata.c` â for serialization file IO and for memory buffers."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/stdio.md:88
msgid "`base/iostream.jl` â for file IO (see `base/fs.jl` for libuv equivalent)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:92
msgid ""
"Use of `ios.c` in these modules is mostly self-contained and separated from the libuv I/O system.  However, there is [one place](https://"
"github.com/JuliaLang/julia/blob/master/src/flisp/print.c#L654)  where femtolisp calls through to `jl_printf()` with a legacy `ios_t` stream."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:96
#, no-wrap
msgid ""
"There is a hack in `ios.h` that makes the `ios_t.bm` field line up with the `uv_stream_t.type`\n"
"and ensures that the values used for `ios_t.bm` to not overlap with valid `UV_HANDLE_TYPE` values.\n"
" This allows `uv_stream_t` pointers to point to `ios_t` streams.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:99
msgid ""
"This is needed because `jl_printf()` caller `jl_static_show()` is passed an `ios_t` stream by femtolisp's `fl_print()` function. Julia's "
"`jl_uv_puts()` function has special handling for this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/stdio.md:100
#, no-wrap
msgid ""
"if (stream->type > UV_HANDLE_TYPE_MAX) {\n"
"    return ios_write((ios_t*)stream, str, n);\n"
"}\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/valgrind.md:1
#, no-wrap
msgid "Using Valgrind with Julia"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:6
#, no-wrap
msgid ""
"[Valgrind](http://valgrind.org/) is a tool for memory debugging, memory leak detection, and profiling.\n"
" This section describes things to keep in mind when using Valgrind to debug memory issues with\n"
"Julia.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/valgrind.md:7 ext/julia/doc/src/devdocs/sanitizers.md:3
#, no-wrap
msgid "General considerations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:13
msgid ""
"By default, Valgrind assumes that there is no self modifying code in the programs it runs.  This assumption works fine in most instances but "
"fails miserably for a just-in-time compiler like `julia`.  For this reason it is crucial to pass `--smc-check=all-non-file` to `valgrind`, "
"else code may crash or behave unexpectedly (often in subtle ways)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:18
msgid ""
"In some cases, to better detect memory errors using Valgrind it can help to compile `julia` with memory pools disabled.  The compile-time "
"flag `MEMDEBUG` disables memory pools in Julia, and `MEMDEBUG2` disables memory pools in FemtoLisp.  To build `julia` with both flags, add "
"the following line to `Make.user`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:19
#, no-wrap
msgid "CFLAGS = -DMEMDEBUG -DMEMDEBUG2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:26
msgid ""
"Another thing to note: if your program uses multiple workers processes, it is likely that you want all such worker processes to run under "
"Valgrind, not just the parent process.  To do this, pass `--trace-children=yes` to `valgrind`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/valgrind.md:27
#, no-wrap
msgid "Suppressions"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:32
msgid ""
"Valgrind will typically display spurious warnings as it runs.  To reduce the number of such warnings, it helps to provide a [suppressions "
"file](http://valgrind.org/docs/manual/manual-core.html#manual-core.suppress)  to Valgrind.  A sample suppressions file is included in the "
"Julia source distribution at `contrib/valgrind-julia.supp`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:34
msgid "The suppressions file can be used from the `julia/` source directory as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:35
#, no-wrap
msgid "$ valgrind --smc-check=all-non-file --suppressions=contrib/valgrind-julia.supp ./julia progname.jl\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:42
msgid ""
"Any memory errors that are displayed should either be reported as bugs or contributed as additional suppressions.  Note that some versions "
"of Valgrind are [shipped with insufficient default suppressions](https://github.com/JuliaLang/julia/issues/8314#issuecomment-55766210), so "
"that may be one thing to consider before submitting any bugs."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/valgrind.md:43
#, no-wrap
msgid "Running the Julia test suite under Valgrind"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:47
msgid ""
"It is possible to run the entire Julia test suite under Valgrind, but it does take quite some time (typically several hours).  To do so, run "
"the following command from the `julia/test/` directory:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:48
#, no-wrap
msgid "valgrind --smc-check=all-non-file --trace-children=yes --suppressions=$PWD/../contrib/valgrind-julia.supp ../julia runtests.jl all\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:54
msgid ""
"If you would like to see a report of \"definite\" memory leaks, pass the flags `--leak-check=full --show-leak-kinds=definite` to `valgrind` "
"as well."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/valgrind.md:55
#, no-wrap
msgid "Caveats"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:59
msgid ""
"Valgrind currently [does not support multiple rounding modes](https://bugs.kde.org/show_bug.cgi?id=136779), so code that adjusts the "
"rounding mode will behave differently when run under Valgrind."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/valgrind.md:63
#, no-wrap
msgid ""
"In general, if after setting `--smc-check=all-non-file` you find that your program behaves differently\n"
"when run under Valgrind, it may help to pass `--tool=none` to `valgrind` as you investigate further.\n"
" This will enable the minimal Valgrind machinery but will also run much faster than when the full\n"
"memory checker is enabled.\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/boundscheck.md:1
#, no-wrap
msgid "Bounds checking"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:10
msgid ""
"Like many modern programming languages, Julia uses bounds checking to ensure program safety when accessing arrays. In tight inner loops or "
"other performance critical situations, you may wish to skip these bounds checks to improve runtime performance. For instance, in order to "
"emit vectorized (SIMD) instructions, your loop body cannot contain branches, and thus cannot contain bounds checks.  Consequently, Julia "
"includes an `@inbounds(...)` macro to tell the compiler to skip such bounds checks within the given block. User-defined array types can use "
"the `@boundscheck(...)` macro to achieve context-sensitive code selection."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/boundscheck.md:11
#, no-wrap
msgid "Eliding bounds checks"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:17
msgid ""
"The `@boundscheck(...)` macro marks blocks of code that perform bounds checking.  When such blocks are inlined into an `@inbounds(...)` "
"block, the compiler may remove these blocks.  The compiler removes the `@boundscheck` block *only if it is inlined* into the calling "
"function.  For example, you might write the method `sum` as:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:18
#, no-wrap
msgid ""
"function sum(A::AbstractArray)\n"
"    r = zero(eltype(A))\n"
"    for i = 1:length(A)\n"
"        @inbounds r += A[i]\n"
"    end\n"
"    return r\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:29
msgid "With a custom array-like type `MyArray` having:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:30
#, no-wrap
msgid "@inline getindex(A::MyArray, i::Real) = (@boundscheck checkbounds(A,i); A.data[to_index(i)])\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:38
msgid ""
"Then when `getindex` is inlined into `sum`, the call to `checkbounds(A,i)` will be elided. If your function contains multiple layers of "
"inlining, only `@boundscheck` blocks at most one level of inlining deeper are eliminated. The rule prevents unintended changes in program "
"behavior from code further up the stack."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/boundscheck.md:39
#, no-wrap
msgid "Propagating inbounds"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:45
msgid ""
"There may be certain scenarios where for code-organization reasons you want more than one layer between the `@inbounds` and `@boundscheck` "
"declarations. For instance, the default `getindex` methods have the chain `getindex(A::AbstractArray, i::Real)` calls "
"`getindex(IndexStyle(A), A, i)` calls `_getindex(::IndexLinear, A, i)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:49
msgid ""
"To override the \"one layer of inlining\" rule, a function may be marked with [`Base.@propagate_inbounds`](@ref) to propagate an inbounds "
"context (or out of bounds context) through one additional layer of inlining."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/boundscheck.md:50
#, no-wrap
msgid "The bounds checking call hierarchy"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:53
msgid "The overall hierarchy is:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/boundscheck.md:55
msgid "`checkbounds(A, I...)` which calls"
msgstr ""

#. type: Bullet: '      * '
#: ext/julia/doc/src/devdocs/boundscheck.md:57
msgid "`checkbounds(Bool, A, I...)` which calls"
msgstr ""

#. type: Bullet: '          * '
#: ext/julia/doc/src/devdocs/boundscheck.md:59
msgid "`checkbounds_indices(Bool, axes(A), I)` which recursively calls"
msgstr ""

#. type: Bullet: '              * '
#: ext/julia/doc/src/devdocs/boundscheck.md:61
msgid "`checkindex` for each dimension"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:64
msgid "Here `A` is the array, and `I` contains the \"requested\" indices. `axes(A)` returns a tuple of \"permitted\" indices of `A`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:71
msgid ""
"`checkbounds(A, I...)` throws an error if the indices are invalid, whereas `checkbounds(Bool, A, I...)` returns `false` in that "
"circumstance.  `checkbounds_indices` discards any information about the array other than its `axes` tuple, and performs a pure indices-vs-"
"indices comparison: this allows relatively few compiled methods to serve a huge variety of array types. Indices are specified as tuples, and "
"are usually compared in a 1-1 fashion with individual dimensions handled by calling another important function, `checkindex`: typically,"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:72
#, no-wrap
msgid ""
"checkbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &\n"
"                                                      checkbounds_indices(Bool, IA, I)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:79
msgid ""
"so `checkindex` checks a single dimension.  All of these functions, including the unexported `checkbounds_indices` have docstrings "
"accessible with `?` ."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:83
msgid ""
"If you have to customize bounds checking for a specific array type, you should specialize `checkbounds(Bool, A, I...)`.  However, in most "
"cases you should be able to rely on `checkbounds_indices` as long as you supply useful `axes` for your array type."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:87
msgid ""
"If you have novel index types, first consider specializing `checkindex`, which handles a single index for a particular dimension of an "
"array.  If you have a custom multidimensional index type (similar to `CartesianIndex`), then you may have to consider specializing "
"`checkbounds_indices`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/boundscheck.md:91
msgid ""
"Note this hierarchy has been designed to reduce the likelihood of method ambiguities.  We try to make `checkbounds` the place to specialize "
"on array type, and try to avoid specializations on index types; conversely, `checkindex` is intended to be specialized only on index type "
"(especially, the last argument)."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/init.md:1
#, no-wrap
msgid "Initialization of the Julia runtime"
msgstr "Julia ã©ã³ã¿ã¤ã ã®åæå"

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:4
msgid "How does the Julia runtime execute `julia -e 'println(\"Hello World!\")'` ?"
msgstr "Julia ã®ã©ã³ã¿ã¤ã ã¯ãã³ãã³ã `julia -e 'println(\"Hello World!\")'`  ãã©ã®æ§ã«å®è¡ããã§ãããã?"

#. type: Title ##
#: ext/julia/doc/src/devdocs/init.md:5
#, no-wrap
msgid "`main()`"
msgstr "`main()`"

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:8
msgid "Execution starts at [`main()` in `ui/repl.c`](https://github.com/JuliaLang/julia/blob/master/ui/repl.c)."
msgstr "ãã­ã°ã©ã ã®å®è¡ã¯ã [`ui/repl.c`ã®`main()`é¢æ°](https://github.com/JuliaLang/julia/blob/master/ui/repl.c) ããéå§ãã¾ãã"

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:12
msgid ""
"`main()` calls [`libsupport_init()`](https://github.com/JuliaLang/julia/blob/master/src/support/libsupportinit.c)  to set the C library "
"locale and to initialize the \"ios\" library (see [`ios_init_stdstreams()`](https://github.com/JuliaLang/julia/blob/master/src/support/ios."
"c)  and [Legacy `ios.c` library](@ref))."
msgstr ""
"`main()` ã¯ã [`libsupport_init()`](https://github.com/JuliaLang/julia/blob/master/src/support/libsupportinit.c) ãå¼ãã§ãCã©ã¤ãã©ãªã® ã­"
"ã±ã¼ã«ãè¨­å®ãã to set the C library locale and to initialize the \"ios\" ã©ã¤ãã©ãªãåæåãã¾ã( [`ios_init_stdstreams()`](https://"
"github.com/JuliaLang/julia/blob/master/src/support/ios.c) ã¨ [Legacy `ios.c` library](@ref) ãåç§)ã"

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:16
msgid ""
"Next [`jl_parse_opts()`](https://github.com/JuliaLang/julia/blob/master/src/jloptions.c) is called to process command line options. Note "
"that `jl_parse_opts()` only deals with options that affect code generation or early initialization. Other options are handled later by "
"[`process_options()` in `base/client.jl`](https://github.com/JuliaLang/julia/blob/master/base/client.jl)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:18
msgid ""
"`jl_parse_opts()` stores command line options in the [global `jl_options` struct](https://github.com/JuliaLang/julia/blob/master/src/julia."
"h)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/init.md:19
#, no-wrap
msgid "`julia_init()`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:23
msgid ""
"[`julia_init()` in `task.c`](https://github.com/JuliaLang/julia/blob/master/src/task.c) is called by `main()` and calls [`_julia_init()` in "
"`init.c`](https://github.com/JuliaLang/julia/blob/master/src/init.c)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:25
msgid "`_julia_init()` begins by calling `libsupport_init()` again (it does nothing the second time)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:28
msgid "[`restore_signals()`](https://github.com/JuliaLang/julia/blob/master/src/signals-unix.c) is called to zero the signal handler mask."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:31
msgid ""
"[`jl_resolve_sysimg_location()`](https://github.com/JuliaLang/julia/blob/master/src/init.c) searches configured paths for the base system "
"image. See [Building the Julia system image](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:34
msgid ""
"[`jl_gc_init()`](https://github.com/JuliaLang/julia/blob/master/src/gc.c) sets up allocation pools and lists for weak refs, preserved values "
"and finalization."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:37
msgid ""
"[`jl_init_frontend()`](https://github.com/JuliaLang/julia/blob/master/src/ast.c) loads and initializes a pre-compiled femtolisp image "
"containing the scanner/parser."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:41
msgid ""
"[`jl_init_types()`](https://github.com/JuliaLang/julia/blob/master/src/jltypes.c) creates `jl_datatype_t` type description objects for the "
"[built-in types defined in `julia.h`](https://github.com/JuliaLang/julia/blob/master/src/julia.h).  e.g."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:42
#, no-wrap
msgid ""
"jl_any_type = jl_new_abstracttype(jl_symbol(\"Any\"), core, NULL, jl_emptysvec);\n"
"jl_any_type->super = jl_any_type;\n"
"\n"
"jl_type_type = jl_new_abstracttype(jl_symbol(\"Type\"), core, jl_any_type, jl_emptysvec);\n"
"\n"
"jl_int32_type = jl_new_primitivetype(jl_symbol(\"Int32\"), core,\n"
"                                     jl_any_type, jl_emptysvec, 32);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:54
msgid ""
"[`jl_init_tasks()`](https://github.com/JuliaLang/julia/blob/master/src/task.c) creates the `jl_datatype_t* jl_task_type` object; initializes "
"the global `jl_root_task` struct; and sets `jl_current_task` to the root task."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:57
msgid "[`jl_init_codegen()`](https://github.com/JuliaLang/julia/blob/master/src/codegen.cpp) initializes the [LLVM library](http://llvm.org)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:60
msgid ""
"[`jl_init_serializer()`](https://github.com/JuliaLang/julia/blob/master/src/staticdata.c) initializes 8-bit serialization tags for builtin "
"`jl_value_t` values."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:63
msgid "If there is no sysimg file (`!jl_options.image_file`) then the `Core` and `Main` modules are created and `boot.jl` is evaluated:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:65
msgid "`jl_core_module = jl_new_module(jl_symbol(\"Core\"))` creates the Julia `Core` module."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:71
msgid ""
"[`jl_init_intrinsic_functions()`](https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp)  creates a new Julia module "
"`Intrinsics` containing constant `jl_intrinsic_type` symbols. These define an integer code for each [intrinsic function](https://github.com/"
"JuliaLang/julia/blob/master/src/intrinsics.cpp).  [`emit_intrinsic()`](https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp) "
"translates these symbols into LLVM instructions during code generation."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:75
msgid ""
"[`jl_init_primitives()`](https://github.com/JuliaLang/julia/blob/master/src/builtins.c) hooks C functions up to Julia function symbols. e.g. "
"the symbol `Core.:(===)()` is bound to C function pointer `jl_f_is()` by calling `add_builtin_func(\"===\", jl_f_is)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:78
#, no-wrap
msgid ""
"[`jl_new_main_module()`](https://github.com/JuliaLang/julia/blob/master/src/toplevel.c) creates\n"
"the global \"Main\" module and sets `jl_current_task->current_module = jl_main_module`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:82
#, no-wrap
msgid ""
"Note: `_julia_init()` [then sets](https://github.com/JuliaLang/julia/blob/master/src/init.c) `jl_root_task->current_module = jl_core_module`.\n"
"`jl_root_task` is an alias of `jl_current_task` at this point, so the `current_module` set by `jl_new_main_module()`\n"
"above is overwritten.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:88
#, no-wrap
msgid ""
"[`jl_load(\"boot.jl\", sizeof(\"boot.jl\"))`](https://github.com/JuliaLang/julia/blob/master/src/init.c)\n"
"calls [`jl_parse_eval_all`](https://github.com/JuliaLang/julia/blob/master/src/ast.c) which repeatedly\n"
"calls [`jl_toplevel_eval_flex()`](https://github.com/JuliaLang/julia/blob/master/src/toplevel.c)\n"
"to execute [`boot.jl`](https://github.com/JuliaLang/julia/blob/master/base/boot.jl). <!-- TODO â drill\n"
"down into eval? -->\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:91
msgid ""
"[`jl_get_builtin_hooks()`](https://github.com/JuliaLang/julia/blob/master/src/init.c) initializes global C pointers to Julia globals defined "
"in `boot.jl`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:95
msgid ""
"[`jl_init_box_caches()`](https://github.com/JuliaLang/julia/blob/master/src/datatype.c) pre-allocates global boxed integer value objects for "
"values up to 1024. This speeds up allocation of boxed ints later on. e.g.:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:96
#, no-wrap
msgid ""
"jl_value_t *jl_box_uint8(uint32_t x)\n"
"{\n"
"    return boxed_uint8_cache[(uint8_t)x];\n"
"}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:106
#, no-wrap
msgid ""
"[`_julia_init()` iterates](https://github.com/JuliaLang/julia/blob/master/src/init.c) over the\n"
"`jl_core_module->bindings.table` looking for `jl_datatype_t` values and sets the type name's module\n"
"prefix to `jl_core_module`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:109
msgid ""
"[`jl_add_standard_imports(jl_main_module)`](https://github.com/JuliaLang/julia/blob/master/src/toplevel.c)  does \"using Base\" in the \"Main"
"\" module."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:112
#, no-wrap
msgid ""
"Note: `_julia_init()` now reverts to `jl_root_task->current_module = jl_main_module` as it was\n"
"before being set to `jl_core_module` above.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:114
msgid "Platform specific signal handlers are initialized for `SIGSEGV` (OSX, Linux), and `SIGFPE` (Windows)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:118
msgid ""
"Other signals (`SIGINFO, SIGBUS, SIGILL, SIGTERM, SIGABRT, SIGQUIT, SIGSYS` and `SIGPIPE`) are hooked up to [`sigdie_handler()`](https://"
"github.com/JuliaLang/julia/blob/master/src/signals-unix.c)  which prints a backtrace."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:122
msgid ""
"[`jl_init_restored_modules()`](https://github.com/JuliaLang/julia/blob/master/src/staticdata.c) calls [`jl_module_run_initializer()`]"
"(https://github.com/JuliaLang/julia/blob/master/src/module.c) for each deserialized module to run the `__init__()` function."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:125
msgid ""
"Finally [`sigint_handler()`](https://github.com/JuliaLang/julia/blob/master/src/signals-unix.c)  is hooked up to `SIGINT` and calls "
"`jl_throw(jl_interrupt_exception)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:128
msgid ""
"`_julia_init()` then returns [back to `main()` in `ui/repl.c`](https://github.com/JuliaLang/julia/blob/master/ui/repl.c)  and `main()` calls "
"`true_main(argc, (char**)argv)`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:132
#, no-wrap
msgid ""
"!!! sidebar \"sysimg\"\n"
"    If there is a sysimg file, it contains a pre-cooked image of the `Core` and `Main` modules (and\n"
"    whatever else is created by `boot.jl`). See [Building the Julia system image](@ref).\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:136
#, no-wrap
msgid ""
"    [`jl_restore_system_image()`](https://github.com/JuliaLang/julia/blob/master/src/staticdata.c) deserializes\n"
"    the saved sysimg into the current Julia runtime environment and initialization continues after\n"
"    `jl_init_box_caches()` below...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:139
#, no-wrap
msgid ""
"    Note: [`jl_restore_system_image()` (and `staticdata.c` in general)](https://github.com/JuliaLang/julia/blob/master/src/staticdata.c)\n"
"    uses the [Legacy `ios.c` library](@ref).\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/init.md:140
#, no-wrap
msgid "`true_main()`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:144
msgid "[`true_main()`](https://github.com/JuliaLang/julia/blob/master/ui/repl.c) loads the contents of `argv[]` into [`Base.ARGS`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:150
msgid ""
"If a `.jl` \"program\" file was supplied on the command line, then [`exec_program()`](https://github.com/JuliaLang/julia/blob/master/ui/repl."
"c)  calls [`jl_load(program,len)`](https://github.com/JuliaLang/julia/blob/master/src/toplevel.c) which calls [`jl_parse_eval_all`](https://"
"github.com/JuliaLang/julia/blob/master/src/ast.c) which repeatedly calls [`jl_toplevel_eval_flex()`](https://github.com/JuliaLang/julia/blob/"
"master/src/toplevel.c)  to execute the program."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:154
msgid ""
"However, in our example (`julia -e 'println(\"Hello World!\")'`), [`jl_get_global(jl_base_module, jl_symbol(\"_start\"))`](https://github."
"com/JuliaLang/julia/blob/master/src/module.c)  looks up [`Base._start`](https://github.com/JuliaLang/julia/blob/master/base/client.jl) and "
"[`jl_apply()`](https://github.com/JuliaLang/julia/blob/master/src/julia.h)  executes it."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/init.md:155
#, no-wrap
msgid "`Base._start`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:160
msgid ""
"[`Base._start`](https://github.com/JuliaLang/julia/blob/master/base/client.jl) calls [`Base.process_options`](https://github.com/JuliaLang/"
"julia/blob/master/base/client.jl)  which calls [`jl_parse_input_line(\"println(\"Hello World!\")\")`](https://github.com/JuliaLang/julia/"
"blob/master/src/ast.c)  to create an expression object and [`Base.eval()`](@ref eval) to execute it."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/init.md:161
#, no-wrap
msgid "`Base.eval`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:165
msgid ""
"[`Base.eval()`](@ref eval) was [mapped to `jl_f_top_eval`](https://github.com/JuliaLang/julia/blob/master/src/builtins.c)  by "
"`jl_init_primitives()`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:168
msgid ""
"[`jl_f_top_eval()`](https://github.com/JuliaLang/julia/blob/master/src/builtins.c) calls [`jl_toplevel_eval_in(jl_main_module, ex)`](https://"
"github.com/JuliaLang/julia/blob/master/src/builtins.c), where `ex` is the parsed expression `println(\"Hello World!\")`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:172
msgid ""
"[`jl_toplevel_eval_in()`](https://github.com/JuliaLang/julia/blob/master/src/builtins.c) calls [`jl_toplevel_eval_flex()`](https://github."
"com/JuliaLang/julia/blob/master/src/toplevel.c) which calls [`eval()` in `interpreter.c`](https://github.com/JuliaLang/julia/blob/master/src/"
"interpreter.c)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:176
#, no-wrap
msgid ""
"The stack dump below shows how the interpreter works its way through various methods of [`Base.println()`](@ref)\n"
"and [`Base.print()`](@ref) before arriving at [`write(s::IO, a::Array{T}) where T`](https://github.com/JuliaLang/julia/blob/master/base/stream.jl)\n"
" which does `ccall(jl_uv_write())`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:179
msgid ""
"[`jl_uv_write()`](https://github.com/JuliaLang/julia/blob/master/src/jl_uv.c) calls `uv_write()` to write \"Hello World!\" to `JL_STDOUT`. "
"See [Libuv wrappers for stdio](@ref).:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:180
#, no-wrap
msgid "Hello World!\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:216
#, no-wrap
msgid ""
"| Stack frame                    | Source code     | Notes                                                |\n"
"|:------------------------------ |:--------------- |:---------------------------------------------------- |\n"
"| `jl_uv_write()`                | `jl_uv.c`       | called though [`ccall`](@ref)                        |\n"
"| `julia_write_282942`           | `stream.jl`     | function `write!(s::IO, a::Array{T}) where T`        |\n"
"| `julia_print_284639`           | `ascii.jl`      | `print(io::IO, s::String) = (write(io, s); nothing)` |\n"
"| `jlcall_print_284639`          | Â                | Â                                                     |\n"
"| `jl_apply()`                   | `julia.h`       | Â                                                     |\n"
"| `jl_trampoline()`              | `builtins.c`    | Â                                                     |\n"
"| `jl_apply()`                   | `julia.h`       | Â                                                     |\n"
"| `jl_apply_generic()`           | `gf.c`          | `Base.print(Base.TTY, String)`                       |\n"
"| `jl_apply()`                   | `julia.h`       | Â                                                     |\n"
"| `jl_trampoline()`              | `builtins.c`    | Â                                                     |\n"
"| `jl_apply()`                   | `julia.h`       | Â                                                     |\n"
"| `jl_apply_generic()`           | `gf.c`          | `Base.print(Base.TTY, String, Char, Char...)`        |\n"
"| `jl_apply()`                   | `julia.h`       | Â                                                     |\n"
"| `jl_f_apply()`                 | `builtins.c`    | Â                                                     |\n"
"| `jl_apply()`                   | `julia.h`       | Â                                                     |\n"
"| `jl_trampoline()`              | `builtins.c`    | Â                                                     |\n"
"| `jl_apply()`                   | `julia.h`       | Â                                                     |\n"
"| `jl_apply_generic()`           | `gf.c`          | `Base.println(Base.TTY, String, String...)`          |\n"
"| `jl_apply()`                   | `julia.h`       | Â                                                     |\n"
"| `jl_trampoline()`              | `builtins.c`    | Â                                                     |\n"
"| `jl_apply()`                   | `julia.h`       | Â                                                     |\n"
"| `jl_apply_generic()`           | `gf.c`          | `Base.println(String,)`                              |\n"
"| `jl_apply()`                   | `julia.h`       | Â                                                     |\n"
"| `do_call()`                    | `interpreter.c` | Â                                                     |\n"
"| `eval()`                       | `interpreter.c` | Â                                                     |\n"
"| `jl_interpret_toplevel_expr()` | `interpreter.c` | Â                                                     |\n"
"| `jl_toplevel_eval_flex()`      | `toplevel.c`    | Â                                                     |\n"
"| `jl_toplevel_eval()`           | `toplevel.c`    | Â                                                     |\n"
"| `jl_toplevel_eval_in()`        | `builtins.c`    | Â                                                     |\n"
"| `jl_f_top_eval()`              | `builtins.c`    | Â                                                     |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:219
msgid ""
"Since our example has just one function call, which has done its job of printing \"Hello World!\", the stack now rapidly unwinds back to "
"`main()`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/init.md:220
#, no-wrap
msgid "`jl_atexit_hook()`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:225
msgid ""
"`main()` calls [`jl_atexit_hook()`](https://github.com/JuliaLang/julia/blob/master/src/init.c).  This calls `_atexit` for each module, then "
"calls [`jl_gc_run_all_finalizers()`](https://github.com/JuliaLang/julia/blob/master/src/gc.c)  and cleans up libuv handles."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/init.md:226
#, no-wrap
msgid "`julia_save()`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/init.md:230
msgid ""
"Finally, `main()` calls [`julia_save()`](https://github.com/JuliaLang/julia/blob/master/src/init.c), which if requested on the command line, "
"saves the runtime state to a new system image. See [`jl_compile_all()`](https://github.com/JuliaLang/julia/blob/master/src/gf.c)  and "
"[`jl_save_system_image()`](https://github.com/JuliaLang/julia/blob/master/src/staticdata.c)."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/llvm.md:1
#, no-wrap
msgid "Working with LLVM"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:5
msgid "This is not a replacement for the LLVM documentation, but a collection of tips for working on LLVM for Julia."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/llvm.md:6
#, no-wrap
msgid "Overview of Julia to LLVM Interface"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:9
msgid "Julia dynamically links against LLVM by default. Build with `USE_LLVM_SHLIB=0` to link statically."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:11
msgid "The code for lowering Julia AST to LLVM IR or interpreting it directly is in directory `src/`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:24
#, no-wrap
msgid ""
"| File                | Description                                                |\n"
"|:------------------- |:---------------------------------------------------------- |\n"
"| `builtins.c`        | Builtin functions                                          |\n"
"| `ccall.cpp`         | Lowering [`ccall`](@ref)                                   |\n"
"| `cgutils.cpp`       | Lowering utilities, notably for array and tuple accesses   |\n"
"| `codegen.cpp`       | Top-level of code generation, pass list, lowering builtins |\n"
"| `debuginfo.cpp`     | Tracks debug information for JIT code                      |\n"
"| `disasm.cpp`        | Handles native object file and JIT code diassembly         |\n"
"| `gf.c`              | Generic functions                                          |\n"
"| `intrinsics.cpp`    | Lowering intrinsics                                        |\n"
"| `llvm-simdloop.cpp` | Custom LLVM pass for [`@simd`](@ref)                       |\n"
"| `sys.c`             | I/O and operating system utility functions                 |\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:26
msgid "Some of the `.cpp` files form a group that compile to a single object."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:30
msgid ""
"The difference between an intrinsic and a builtin is that a builtin is a first class function that can be used like any other Julia "
"function.  An intrinsic can operate only on unboxed data, and therefore its arguments must be statically typed."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/llvm.md:31
#, no-wrap
msgid "Alias Analysis"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:36
msgid ""
"Julia currently uses LLVM's [Type Based Alias Analysis](http://llvm.org/docs/LangRef.html#tbaa-metadata).  To find the comments that "
"document the inclusion relationships, look for `static MDNode*` in `src/codegen.cpp`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:38
msgid "The `-O` option enables LLVM's [Basic Alias Analysis](http://llvm.org/docs/AliasAnalysis.html#the-basicaa-pass)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/llvm.md:39
#, no-wrap
msgid "Building Julia with a different version of LLVM"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:43
msgid ""
"The default version of LLVM is specified in `deps/Versions.make`. You can override it by creating a file called `Make.user` in the top-level "
"directory and adding a line to it such as:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:44
#, no-wrap
msgid "LLVM_VER = 6.0.1\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:50
msgid "Besides the LLVM release numerals, you can also use `LLVM_VER = svn` to build against the latest development version of LLVM."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:57
msgid ""
"You can also specify to build a debug version of LLVM, by setting either `LLVM_DEBUG = 1` or `LLVM_DEBUG = Release` in your `Make.user` "
"file. The former will be a fully unoptimized build of LLVM and the latter will produce an optimized build of LLVM. Depending on your needs "
"the latter will suffice and it quite a bit faster. If you use `LLVM_DEBUG = Release` you will also want to set `LLVM_ASSERTIONS = 1` to "
"enable diagonstics for different passes. Only `LLVM_DEBUG = 1` implies that option by default."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/llvm.md:58
#, no-wrap
msgid "Passing options to LLVM"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:62
msgid "You can pass options to LLVM via the environment variable `JULIA_LLVM_ARGS`.  Here are example settings using `bash` syntax:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/llvm.md:67
msgid "`export JULIA_LLVM_ARGS = -print-after-all` dumps IR after each pass."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/llvm.md:67
msgid ""
"`export JULIA_LLVM_ARGS = -debug-only=loop-vectorize` dumps LLVM `DEBUG(...)` diagnostics for loop vectorizer. If you get warnings about "
"\"Unknown command line argument\", rebuild LLVM with `LLVM_ASSERTIONS = 1`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/llvm.md:68
#, no-wrap
msgid "Debugging LLVM transformations in isolation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:81
msgid ""
"On occasion, it can be useful to debug LLVM's transformations in isolation from the rest of the Julia system, e.g. because reproducing the "
"issue inside `julia` would take too long, or because one wants to take advantage of LLVM's tooling (e.g. bugpoint). To get unoptimized IR "
"for the entire system image, pass the `--output-unopt-bc unopt.bc` option to the system image build process, which will output the "
"unoptimized IR to an `unopt.bc` file. This file can then be passed to LLVM tools as usual. `libjulia` can function as an LLVM pass plugin "
"and can be loaded into LLVM tools, to make julia-specific passes available in this environment. In addition, it exposes the `-julia` meta-"
"pass, which runs the entire Julia pass-pipeline over the IR. As an example, to generate a system image, one could do:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:81
#, no-wrap
msgid ""
"opt -load libjulia.so -julia -o opt.bc unopt.bc\n"
"llc -o sys.o opt.bc\n"
"cc -shared -o sys.so sys.o\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:87
msgid "This system image can then be loaded by `julia` as usual."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:93
msgid ""
"Alternatively, you can use `--output-jit-bc jit.bc` to obtain a trace of all IR passed to the JIT.  This is useful for code that cannot be "
"run as part of the sysimg generation process (e.g. because it creates unserializable state). However, the resulting `jit.bc` does not "
"include sysimage data, and can thus not be used as such."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:96
msgid "It is also possible to dump an LLVM IR module for just one Julia function, using:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:96
#, no-wrap
msgid ""
"fun, T = +, Tuple{Int,Int} # Substitute your function of interest here\n"
"optimize = false\n"
"open(\"plus.ll\", \"w\") do file\n"
"    println(file, InteractiveUtils._dump_function(fun, T, false, false, false, true, :att, optimize))\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:105
msgid "These files can be processed the same way as the unoptimized sysimg IR shown above."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/llvm.md:106
#, no-wrap
msgid "Improving LLVM optimizations for Julia"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:110
msgid ""
"Improving LLVM code generation usually involves either changing Julia lowering to be more friendly to LLVM's passes, or improving a pass."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:114
msgid ""
"If you are planning to improve a pass, be sure to read the [LLVM developer policy](http://llvm.org/docs/DeveloperPolicy.html).  The best "
"strategy is to create a code example in a form where you can use LLVM's `opt` tool to study it and the pass of interest in isolation."
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/devdocs/llvm.md:119
msgid "Create an example Julia code of interest."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/devdocs/llvm.md:119
msgid "Use `JULIA_LLVM_ARGS = -print-after-all` to dump the IR."
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/devdocs/llvm.md:119
msgid "Pick out the IR at the point just before the pass of interest runs."
msgstr ""

#. type: Bullet: '4. '
#: ext/julia/doc/src/devdocs/llvm.md:119
msgid "Strip the debug metadata and fix up the TBAA metadata by hand."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:121
msgid "The last step is labor intensive.  Suggestions on a better way would be appreciated."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/llvm.md:122
#, no-wrap
msgid "The jlcall calling convention"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:126
msgid "Julia has a generic calling convention for unoptimized code, which looks somewhat as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:126
#, no-wrap
msgid "jl_value_t *any_unoptimized_call(jl_value_t *, jl_value_t **, int);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:135
msgid ""
"where the first argument is the boxed function object, the second argument is an on-stack array of arguments and the third is the number of "
"arguments. Now, we could perform a straightforward lowering and emit an alloca for the argument array. However, this would betray the SSA "
"nature of the uses at the call site, making optimizations (including GC root placement), significantly harder.  Instead, we emit it as "
"follows:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/devdocs/llvm.md:135 ext/julia/doc/src/devdocs/llvm.md:287 ext/julia/doc/src/devdocs/llvm.md:300
#, no-wrap
msgid "llvm"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:135
#, no-wrap
msgid ""
"%bitcast = bitcast @any_unoptimized_call to %jl_value_t *(*)(%jl_value_t *, %jl_value_t *)\n"
"call cc 37 %jl_value_t *%bitcast(%jl_value_t *%arg1, %jl_value_t *%arg2)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:145
msgid ""
"The special `cc 37` annotation marks the fact that this call site is really using the jlcall calling convention. This allows us to retain "
"the SSA-ness of the uses throughout the optimizer. GC root placement will later lower this call to the original C ABI. In the code the "
"calling convention number is represented by the `JLCALL_F_CC` constant. In addition, there is the `JLCALL_CC` calling convention which "
"functions similarly, but omits the first argument."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/llvm.md:146
#, no-wrap
msgid "GC root placement"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:155
msgid ""
"GC root placement is done by an LLVM pass late in the pass pipeline. Doing GC root placement this late enables LLVM to make more aggressive "
"optimizations around code that requires GC roots, as well as allowing us to reduce the number of required GC roots and GC root store "
"operations (since LLVM doesn't understand our GC, it wouldn't otherwise know what it is and is not allowed to do with values stored to the "
"GC frame, so it'll conservatively do very little). As an example, consider an error path"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:155
#, no-wrap
msgid ""
"if some_condition()\n"
"    #= Use some variables maybe =#\n"
"    error(\"An error occurred\")\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:169
msgid ""
"During constant folding, LLVM may discover that the condition is always false, and can remove the basic block. However, if GC root lowering "
"is done early, the GC root slots used in the deleted block, as well as any values kept alive in those slots only because they were used in "
"the error path, would be kept alive by LLVM. By doing GC root lowering late, we give LLVM the license to do any of its usual optimizations "
"(constant folding, dead code elimination, etc.), without having to worry (too much) about which values may or may not be GC tracked."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:173
msgid ""
"However, in order to be able to do late GC root placement, we need to be able to identify a) which pointers are GC tracked and b) all uses "
"of such pointers. The goal of the GC placement pass is thus simple:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:177
msgid ""
"Minimize the number of needed GC roots/stores to them subject to the constraint that at every safepoint, any live GC-tracked pointer (i.e. "
"for which there is a path after this point that contains a use of this pointer) is in some GC slot."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/llvm.md:178
#, no-wrap
msgid "Representation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:187
msgid ""
"The primary difficulty is thus choosing an IR representation that allows us to identify GC-tracked pointers and their uses, even after the "
"program has been run through the optimizer. Our design makes use of three LLVM features to achieve this: - Custom address spaces - Operand "
"Bundles - Non-integral pointers"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:198
msgid ""
"Custom address spaces allow us to tag every point with an integer that needs to be preserved through optimizations. The compiler may not "
"insert casts between address spaces that did not exist in the original program and it must never change the address space of a pointer on a "
"load/store/etc operation. This allows us to annotate which pointers are GC-tracked in an optimizer-resistant way. Note that metadata would "
"not be able to achieve the same purpose. Metadata is supposed to always be discardable without altering the semantics of the program. "
"However, failing to identify a GC-tracked pointer alters the resulting program behavior dramatically - it'll probably crash or return wrong "
"results. We currently use three different address spaces (their numbers are defined in `src/codegen_shared.cpp`):"
msgstr ""

#. type: Bullet: '- '
#: ext/julia/doc/src/devdocs/llvm.md:219
msgid ""
"GC Tracked Pointers (currently 10): These are pointers to boxed values that may be put into a GC frame. It is loosely equivalent to a "
"`jl_value_t*` pointer on the C side. N.B. It is illegal to ever have a pointer in this address space that may not be stored to a GC slot."
msgstr ""

#. type: Bullet: '- '
#: ext/julia/doc/src/devdocs/llvm.md:219
msgid ""
"Derived Pointers (currently 11): These are pointers that are derived from some GC tracked pointer. Uses of these pointers generate uses of "
"the original pointer.  However, they need not themselves be known to the GC. The GC root placement pass MUST always find the GC tracked "
"pointer from which this pointer is derived and use that as the pointer to root."
msgstr ""

#. type: Bullet: '- '
#: ext/julia/doc/src/devdocs/llvm.md:219
msgid ""
"Callee Rooted Pointers (currently 12): This is a utility address space to express the notion of a callee rooted value. All values of this "
"address space MUST be storable to a GC root (though it is possible to relax this condition in the future), but unlike the other pointers "
"need not be rooted if passed to a call (they do still need to be rooted if they are live across another safepoint between the definition and "
"the call)."
msgstr ""

#. type: Bullet: '- '
#: ext/julia/doc/src/devdocs/llvm.md:219
msgid ""
"Pointers loaded from tracked object (currently 13): This is used by arrays, which themselves contain a pointer to the managed data. This "
"data area is owned by the array, but is not a GC-tracked object by itself. The compiler guarantees that as long as this pointer is live, the "
"object that this pointer was loaded from will keep being live."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/llvm.md:220
#, no-wrap
msgid "Invariants"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:224
msgid ""
"The GC root placement pass makes use of several invariants, which need to be observed by the frontend and are preserved by the optimizer."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:235
#, no-wrap
msgid ""
"First, only the following address space casts are allowed:\n"
"- 0->{Tracked,Derived,CalleeRooted}: It is allowable to decay an untracked pointer to any of the\n"
"  others. However, do note that the optimizer has broad license to not root\n"
"  such a value. It is never safe to have a value in address space 0 in any part\n"
"  of the program if it is (or is derived from) a value that requires a GC root.\n"
"- Tracked->Derived: This is the standard decay route for interior values. The placement\n"
"  pass will look for these to identify the base pointer for any use.\n"
"- Tracked->CalleeRooted: Addrspace CalleeRooted serves merely as a hint that a GC root is not\n"
"  required. However, do note that the Derived->CalleeRooted decay is prohibited, since\n"
"  pointers should generally be storable to a GC slot, even in this address space.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:243
msgid ""
"Now let us consider what constitutes a use: - Loads whose loaded values is in one of the address spaces - Stores of a value in one of the "
"address spaces to a location - Stores to a pointer in one of the address spaces - Calls for which a value in one of the address spaces is an "
"operand - Calls in jlcall ABI, for which the argument array contains a value - Return instructions."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:250
msgid ""
"We explicitly allow load/stores and simple calls in address spaces Tracked/Derived. Elements of jlcall argument arrays must always be in "
"address space Tracked (it is required by the ABI that they are valid `jl_value_t*` pointers). The same is true for return instructions "
"(though note that struct return arguments are allowed to have any of the address spaces). The only allowable use of an address space "
"CalleeRooted pointer is to pass it to a call (which must have an appropriately typed operand)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:255
msgid ""
"Further, we disallow `getelementptr` in addrspace Tracked. This is because unless the operation is a noop, the resulting pointer will not be "
"validly storable to a GC slot and may thus not be in this address space. If such a pointer is required, it should be decayed to addrspace "
"Derived first."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:264
msgid ""
"Lastly, we disallow `inttoptr`/`ptrtoint` instructions in these address spaces.  Having these instructions would mean that some `i64` values "
"are really GC tracked.  This is problematic, because it breaks that stated requirement that we're able to identify GC-relevant pointers. "
"This invariant is accomplished using the LLVM \"non-integral pointers\" feature, which is new in LLVM 5.0. It prohibits the optimizer from "
"making optimizations that would introduce these operations. Note we can still insert static constants at JIT time by using `inttoptr` in "
"address space 0 and then decaying to the appropriate address space afterwards."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/llvm.md:265
#, no-wrap
msgid "Supporting [`ccall`](@ref)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:270
msgid ""
"One important aspect missing from the discussion so far is the handling of [`ccall`](@ref). [`ccall`](@ref) has the peculiar feature that "
"the location and scope of a use do not coincide. As an example consider:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:270
#, no-wrap
msgid ""
"A = randn(1024)\n"
"ccall(:foo, Cvoid, (Ptr{Float64},), A)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:279
msgid ""
"In lowering, the compiler will insert a conversion from the array to the pointer which drops the reference to the array value. However, we "
"of course need to make sure that the array does stay alive while we're doing the [`ccall`](@ref). To understand how this is done, first "
"recall the lowering of the above code:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:279
#, no-wrap
msgid "return $(Expr(:foreigncall, :(:foo), Cvoid, svec(Ptr{Float64}), 0, :(:ccall), Expr(:foreigncall, :(:jl_array_ptr), Ptr{Float64}, svec(Any), 0, :(:ccall), :(A)), :(A)))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:287
msgid ""
"The last `:(A)`, is an extra argument list inserted during lowering that informs the code generator which Julia level values need to be kept "
"alive for the duration of this [`ccall`](@ref). We then take this information and represent it in an \"operand bundle\" at the IR level. An "
"operand bundle is essentially a fake use that is attached to the call site. At the IR level, this looks like so:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:287
#, no-wrap
msgid "call void inttoptr (i64 ... to void (double*)*)(double* %5) [ \"jl_roots\"(%jl_value_t addrspace(10)* %A) ]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:293
msgid ""
"The GC root placement pass will treat the `jl_roots` operand bundle as if it were a regular operand. However, as a final step, after the GC "
"roots are inserted, it will drop the operand bundle to avoid confusing instruction selection."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/llvm.md:294
#, no-wrap
msgid "Supporting [`pointer_from_objref`](@ref)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:300
msgid ""
"[`pointer_from_objref`](@ref) is special because it requires the user to take explicit control of GC rooting. By our above invariants, this "
"function is illegal, because it performs an address space cast from 10 to 0. However, it can be useful, in certain situations, so we provide "
"a special intrinsic:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:300
#, no-wrap
msgid "declared %jl_value_t *julia.pointer_from_objref(%jl_value_t addrspace(10)*)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:311
msgid ""
"which is lowered to the corresponding address space cast after GC root lowering.  Do note however that by using this intrinsic, the caller "
"assumes all responsibility for making sure that the value in question is rooted. Further this intrinsic is not considered a use, so the GC "
"root placement pass will not provide a GC root for the function. As a result, the external rooting must be arranged while the value is still "
"tracked by the system. I.e. it is not valid to attempt to use the result of this operation to establish a global root - the optimizer may "
"have already dropped the value."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/llvm.md:312
#, no-wrap
msgid "Keeping values alive in the absence of uses"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:319
msgid ""
"In certain cases it is necessary to keep an object alive, even though there is no compiler-visible use of said object. This may be case for "
"low level code that operates on the memory-representation of an object directly or code that needs to interface with C code. In order to "
"allow this, we provide the following intrinsics at the LLVM level:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:319
#, no-wrap
msgid ""
"token @llvm.julia.gc_preserve_begin(...)\n"
"void @llvm.julia.gc_preserve_end(token)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/llvm.md:331
msgid ""
"(The `llvm.` in the name is required in order to be able to use the `token` type). The semantics of these intrinsics are as follows: At any "
"safepoint that is dominated by a `gc_preserve_begin` call, but that is not not dominated by a corresponding `gc_preserve_end` call (i.e. a "
"call whose argument is the token returned by a `gc_preserve_begin` call), the values passed as arguments to that `gc_preserve_begin` will be "
"kept live. Note that the `gc_preserve_begin` still counts as a regular use of those values, so the standard lifetime semantics will ensure "
"that the values will be kept alive before entering the preserve region."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/isbitsunionarrays.md:1
#, no-wrap
msgid "isbits Union Optimizations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/isbitsunionarrays.md:4
msgid ""
"In Julia, the `Array` type holds both \"bits\" values as well as heap-allocated \"boxed\" values. The distinction is whether the value "
"itself is stored inline (in the direct allocated memory of the array), or if the memory of the array is simply a collection of pointers to "
"objects allocated elsewhere. In terms of performance, accessing values inline is clearly an advantage over having to follow a pointer to the "
"actual value. The definition of \"isbits\" generally means any Julia type with a fixed, determinate size, meaning no \"pointer\" fields, see "
"`?isbitstype`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/isbitsunionarrays.md:6
msgid ""
"Julia also supports Union types, quite literally the union of a set of types. Custom Union type definitions can be extremely handy for "
"applications wishing to \"cut across\" the nominal type system (i.e. explicit subtype relationships) and define methods or functionality on "
"these, otherwise unrelated, set of types. A compiler challenge, however, is in determining how to treat these Union types. The naive "
"approach (and indeed, what Julia itself did pre-0.7), is to simply make a \"box\" and then a pointer in the box to the actual value, similar "
"to the previously mentioned \"boxed\" values. This is unfortunate, however, because of the number of small, primitive \"bits\" types (think "
"`UInt8`, `Int32`, `Float64`, etc.) that would easily fit themselves inline in this \"box\" without needing any indirection for value access. "
"There are two main ways Julia can take advantage of this optimization as of 0.7: isbits Union fields in types, and isbits Union Arrays."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/isbitsunionarrays.md:7
#, no-wrap
msgid "isbits Union Structs"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/isbitsunionarrays.md:10
msgid ""
"Julia now includes an optimization wherein \"isbits Union\" fields in types (`mutable struct`, `struct`, etc.) will be stored inline. This "
"is accomplished by determining the \"inline size\" of the Union type (e.g. `Union{UInt8, Int16}` will have a size of two bytes, which "
"represents the size needed of the largest Union type `Int16`), and in addition, allocating an extra \"type tag byte\" (`UInt8`), whose value "
"signals the type of the actual value stored inline of the \"Union bytes\". The type tag byte value is the index of the actual value's type "
"in the Union type's order of types. For example, a type tag value of `0x02` for a field with type `Union{Nothing, UInt8, Int16}` would "
"indicate that an `Int16` value is stored in the 2 bytes of the field in the structure's memory; a `0x01` value would indicate that a `UInt8` "
"value was stored in the first 1 byte of the 2 bytes of the field's memory. Lastly, a value of `0x00` signals that the `nothing` value will "
"be returned for this field, even though, as a singleton type with a single type instance, it technically has a size of 0. The type tag byte "
"for a type's Union field is stored directly after the field's computed Union memory."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/isbitsunionarrays.md:11
#, no-wrap
msgid "isbits Union Arrays"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/isbitsunionarrays.md:13
#, no-wrap
msgid "Julia can now also store \"isbits Union\" values inline in an Array, as opposed to requiring an indirection box. The optimization is accomplished by storing an extra \"type tag array\" of bytes, one byte per array element, alongside the bytes of the actual array data. This type tag array serves the same function as the type field case: its value signals the type of the actual stored Union value in the array. In terms of layout, a Julia Array can include extra \"buffer\" space before and after its actual data values, which are tracked in the `a->offset` and `a->maxsize` fields of the `jl_array_t*` type. The \"type tag array\" is treated exactly as another `jl_array_t*`, but which shares the same `a->offset`, `a->maxsize`, and `a->len` fields. So the formula to access an isbits Union Array's type tag bytes is `a->data + (a->maxsize - a->offset) * a->elsize + a->offset`; i.e. the Array's `a->data` pointer is already shifted by `a->offset`, so correcting for that, we follow the data all the way to the max of what it can hold `a->maxsize`, then adjust by `a->ofset` more bytes to account for any present \"front buffering\" the array might be doing. This layout in particular allows for very efficient resizing operations as the type tag data only ever has to move when the actual array's data has to move.\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/reflection.md:1
#, no-wrap
msgid "Reflection and introspection"
msgstr "ãªãã¬ã¯ã·ã§ã³ã¨ã¤ã³ã¹ãã­ã¹ãã¯ã·ã§ã³"

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:4
msgid "Julia provides a variety of runtime reflection capabilities."
msgstr "Julia ã¯ããã¾ãã¾ãªå®è¡æãªãã¬ã¯ã·ã§ã³æ©è½ãæä¾ãã¾ãã"

#. type: Title ##
#: ext/julia/doc/src/devdocs/reflection.md:5
#, no-wrap
msgid "Module bindings"
msgstr "ã¢ã¸ã¥ã¼ã«ãã¤ã³ãã£ã³ã°"

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:10
msgid ""
"The exported names for a `Module` are available using [`names(m::Module)`](@ref), which will return an array of [`Symbol`](@ref) elements "
"representing the exported bindings. `names(m::Module, all = true)` returns symbols for all bindings in `m`, regardless of export status."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/reflection.md:11
#, no-wrap
msgid "DataType fields"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:16
msgid ""
"The names of `DataType` fields may be interrogated using [`fieldnames`](@ref). For example, given the following type, `fieldnames(Point)` "
"returns a tuple of [`Symbol`](@ref)s representing the field names:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/devdocs/reflection.md:17 ext/julia/doc/src/devdocs/reflection.md:30 ext/julia/doc/src/devdocs/reflection.md:40
#, no-wrap
msgid "jldoctest struct_point"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:17
#, no-wrap
msgid ""
"julia> struct Point\n"
"           x::Int\n"
"           y\n"
"       end\n"
"\n"
"julia> fieldnames(Point)\n"
"(:x, :y)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:29
msgid "The type of each field in a `Point` object is stored in the `types` field of the `Point` variable itself:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:30
#, no-wrap
msgid ""
"julia> Point.types\n"
"svec(Int64, Any)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:37
msgid "While `x` is annotated as an `Int`, `y` was unannotated in the type definition, therefore `y` defaults to the `Any` type."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:39
msgid "Types are themselves represented as a structure called `DataType`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:40
#, no-wrap
msgid ""
"julia> typeof(Point)\n"
"DataType\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:47
msgid ""
"Note that `fieldnames(DataType)` gives the names for each field of `DataType` itself, and one of these fields is the `types` field observed "
"in the example above."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/reflection.md:48
#, no-wrap
msgid "Subtypes"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:52
msgid ""
"The *direct* subtypes of any `DataType` may be listed using [`subtypes`](@ref). For example, the abstract `DataType` [`AbstractFloat`](@ref) "
"has four (concrete) subtypes:"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/devdocs/reflection.md:53 ext/julia/doc/src/devdocs/reflection.md:84
#, no-wrap
msgid "jldoctest; setup = :(using InteractiveUtils)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:53
#, no-wrap
msgid ""
"julia> subtypes(AbstractFloat)\n"
"4-element Array{Any,1}:\n"
" BigFloat\n"
" Float16\n"
" Float32\n"
" Float64\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:64
msgid ""
"Any abstract subtype will also be included in this list, but further subtypes thereof will not; recursive application of [`subtypes`](@ref) "
"may be used to inspect the full type tree."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/reflection.md:65
#, no-wrap
msgid "DataType layout"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:71
msgid ""
"The internal representation of a `DataType` is critically important when interfacing with C code and several functions are available to "
"inspect these details. [`isbits(T::DataType)`](@ref) returns true if `T` is stored with C-compatible alignment. [`fieldoffset(T::DataType, "
"i::Integer)`](@ref)  returns the (byte) offset for field *i* relative to the start of the type."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/reflection.md:72
#, no-wrap
msgid "Function methods"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:76
msgid ""
"The methods of any generic function may be listed using [`methods`](@ref). The method dispatch table may be searched for methods accepting a "
"given type using [`methodswith`](@ref)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/reflection.md:77
#, no-wrap
msgid "Expansion and lowering"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:83
msgid ""
"As discussed in the [Metaprogramming](@ref) section, the [`macroexpand`](@ref) function gives the unquoted and interpolated expression "
"([`Expr`](@ref)) form for a given macro. To use `macroexpand`, `quote` the expression block itself (otherwise, the macro will be evaluated "
"and the result will be passed instead!). For example:"
msgstr ""
"[ã¡ã¿ãã­ã°ã©ãã³ã°](@ref Metaprogramming)ã»ã¯ã·ã§ã³ã§èª¬æããããã«ã[`macroexpand`](@ref) é¢æ°ã¯ãå¼ç¨ç¬¦ãã¨ããããå¼å±éããããå¼"
"([`Expr`](@ref )) ã®å½¢å¼ãæä¾ãã¾ãã`macroexpand` ãä½¿ç¨ããã«ã¯ãå¼ãã­ãã¯èªä½ã«å¼ç¨ç¬¦ãä»ãã¾ã (ããã§ãªããã°ããã¯ã­ãè©ä¾¡ãããä»£ã"
"ãã«çµæãæ¸¡ããã¾ã)ãä¾ãã°:"

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:84
#, no-wrap
msgid ""
"julia> macroexpand(@__MODULE__, :(@edit println(\"\")) )\n"
":(InteractiveUtils.edit(println, (Base.typesof)(\"\")))\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:91
msgid ""
"The functions `Base.Meta.show_sexpr` and [`dump`](@ref) are used to display S-expr style views and depth-nested detail views for any "
"expression."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:95
msgid ""
"Finally, the [`Meta.lower`](@ref) function gives the `lowered` form of any expression and is of particular interest for understanding how "
"language constructs map to primitive operations such as assignments, branches, and calls:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:96
#, no-wrap
msgid ""
"julia> Meta.lower(@__MODULE__, :( [1+2, sin(0.5)] ))\n"
":($(Expr(:thunk, CodeInfo(\n"
"    @ none within `top-level scope'\n"
"1 â %1 = 1 + 2\n"
"â   %2 = sin(0.5)\n"
"â   %3 = Base.vect(%1, %2)\n"
"âââ      return %3\n"
"))))\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/reflection.md:107
#, no-wrap
msgid "Intermediate and compiled representations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:114
msgid ""
"Inspecting the lowered form for functions requires selection of the specific method to display, because generic functions may have many "
"methods with different type signatures. For this purpose, method-specific code-lowering is available using [`code_lowered`](@ref), and the "
"type-inferred form is available using [`code_typed`](@ref).  [`code_warntype`](@ref) adds highlighting to the output of [`code_typed`](@ref)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:119
msgid ""
"Closer to the machine, the LLVM intermediate representation of a function may be printed using by [`code_llvm`](@ref), and finally the "
"compiled machine code is available using [`code_native`](@ref) (this will trigger JIT compilation/code generation for any function which has "
"not previously been called)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:122
msgid ""
"For convenience, there are macro versions of the above functions which take standard function calls and expand argument types automatically:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:123
#, no-wrap
msgid ""
"julia> @code_llvm +(1,1)\n"
"\n"
"define i64 @\"julia_+_130862\"(i64, i64) {\n"
"top:\n"
"    %2 = add i64 %1, %0\n"
"    ret i64 %2\n"
"}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:135
msgid ""
"For more informations see [`@code_lowered`](@ref), [`@code_typed`](@ref), [`@code_warntype`](@ref), [`@code_llvm`](@ref), and "
"[`@code_native`](@ref)."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/reflection.md:136
#, no-wrap
msgid "Printing of debug information"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:140
msgid "The aforementioned functions and macros take the keyword argument `debuginfo` that controls the level debug information printed."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:141
#, no-wrap
msgid ""
"julia> @code_typed debuginfo=:source +(1,1)\n"
"CodeInfo(\n"
"    @ int.jl:53 within `+'\n"
"1 â %1 = Base.add_int(x, y)::Int64\n"
"âââ      return %1\n"
") => Int64\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/reflection.md:153
msgid ""
"Possible values for `debuginfo` are: `:none`, `:source`, and`:default`.  Per default debug information is not printed, but that can be "
"changed by setting `Base.IRShow.default_debuginfo[] = :source`."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/eval.md:1
#, no-wrap
msgid "Eval of Julia code"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:5
msgid ""
"One of the hardest parts about learning how the Julia Language runs code is learning how all of the pieces work together to execute a block "
"of code."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:10
msgid ""
"Each chunk of code typically makes a trip through many steps with potentially unfamiliar names, such as (in no particular order): flisp, "
"AST, C++, LLVM, `eval`, `typeinf`, `macroexpand`, sysimg (or system image), bootstrapping, compile, parse, execute, JIT, interpret, box, "
"unbox, intrinsic function, and primitive function, before turning into the desired result (hopefully)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:13
#, no-wrap
msgid ""
"!!! sidebar \"Definitions\"\n"
"      * REPL\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:17
#, no-wrap
msgid ""
"        REPL stands for Read-Eval-Print Loop. It's just what we call the command line environment for\n"
"        short.\n"
"      * AST\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:20
#, no-wrap
msgid ""
"        Abstract Syntax Tree The AST is the digital representation of the code structure. In this form\n"
"        the code has been tokenized for meaning so that it is more suitable for manipulation and execution.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/eval.md:21
#, no-wrap
msgid "Julia Execution"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:24
msgid "The 10,000 foot view of the whole process is as follows:"
msgstr ""

#. type: Bullet: '1. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid "The user starts `julia`."
msgstr ""

#. type: Bullet: '2. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid ""
"The C function `main()` from `ui/repl.c` gets called. This function processes the command line arguments, filling in the `jl_options` struct "
"and setting the variable `ARGS`. It then initializes Julia (by calling [`julia_init` in `task.c`](https://github.com/JuliaLang/julia/blob/"
"master/src/task.c), which may load a previously compiled [sysimg](@ref dev-sysimg)). Finally, it passes off control to Julia by calling "
"[`Base._start()`](https://github.com/JuliaLang/julia/blob/master/base/client.jl)."
msgstr ""

#. type: Bullet: '3. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid ""
"When `_start()` takes over control, the subsequent sequence of commands depends on the command line arguments given. For example, if a "
"filename was supplied, it will proceed to execute that file. Otherwise, it will start an interactive REPL."
msgstr ""

#. type: Bullet: '4. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid ""
"Skipping the details about how the REPL interacts with the user, let's just say the program ends up with a block of code that it wants to "
"run."
msgstr ""

#. type: Bullet: '5. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid ""
"If the block of code to run is in a file, [`jl_load(char *filename)`](https://github.com/JuliaLang/julia/blob/master/src/toplevel.c)  gets "
"invoked to load the file and [parse](@ref dev-parsing) it. Each fragment of code is then passed to `eval` to execute."
msgstr ""

#. type: Bullet: '6. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid "Each fragment of code (or AST), is handed off to [`eval()`](@ref) to turn into results."
msgstr ""

#. type: Bullet: '7. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid ""
"[`eval()`](@ref) takes each code fragment and tries to run it in [`jl_toplevel_eval_flex()`](https://github.com/JuliaLang/julia/blob/master/"
"src/toplevel.c)."
msgstr ""

#. type: Bullet: '8. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid ""
"`jl_toplevel_eval_flex()` decides whether the code is a \"toplevel\" action (such as `using` or `module`), which would be invalid inside a "
"function. If so, it passes off the code to the toplevel interpreter."
msgstr ""

#. type: Bullet: '9. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid ""
"`jl_toplevel_eval_flex()` then [expands](@ref dev-macro-expansion) the code to eliminate any macros and to \"lower\" the AST to make it "
"simpler to execute."
msgstr ""

#. type: Bullet: '10. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid "`jl_toplevel_eval_flex()` then uses some simple heuristics to decide whether to JIT compiler the AST or to interpret it directly."
msgstr ""

#. type: Bullet: '11. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid ""
"The bulk of the work to interpret code is handled by [`eval` in `interpreter.c`](https://github.com/JuliaLang/julia/blob/master/src/"
"interpreter.c)."
msgstr ""

#. type: Bullet: '12. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid ""
"If instead, the code is compiled, the bulk of the work is handled by `codegen.cpp`. Whenever a Julia function is called for the first time "
"with a given set of argument types, [type inference](@ref dev-type-inference)  will be run on that function. This information is used by the "
"[codegen](@ref dev-codegen) step to generate faster code."
msgstr ""
"ä»£ããã«ãã³ã¼ããã³ã³ãã¤ã«ããã¦ããå ´åãä½æ¥­ã®å¤§é¨åã¯ `codegen.cpp` ã«ãã£ã¦å¦çããã¾ããåæå®ãããå¼æ°ã¨ã¨ãã«ãJulia é¢æ°ãåãã¦å¼"
"ã°ããã¨ãã¯ãã¤ãããã®é¢æ°ã§ \n"
"[åæ¨è«](@ref dev-type-inference) ãå®è¡ããã¾ãããã®æå ±ã¯ã\n"
"[codegen](@ref dev-codegen) ã¹ãããã§ããé«éãªã³ã¼ããçæããããã«ä½¿ç¨ããã¾ãã"

#. type: Bullet: '13. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid "Eventually, the user quits the REPL, or the end of the program is reached, and the `_start()` method returns."
msgstr ""

#. type: Bullet: '14. '
#: ext/julia/doc/src/devdocs/eval.md:59
msgid ""
"Just before exiting, `main()` calls [`jl_atexit_hook(exit_code)`](https://github.com/JuliaLang/julia/blob/master/src/init.c).  This calls "
"`Base._atexit()` (which calls any functions registered to [`atexit()`](@ref) inside Julia). Then it calls [`jl_gc_run_all_finalizers()`]"
"(https://github.com/JuliaLang/julia/blob/master/src/gc.c).  Finally, it gracefully cleans up all `libuv` handles and waits for them to flush "
"and close."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/eval.md:60
#, no-wrap
msgid "[Parsing](@id dev-parsing)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:64
msgid ""
"The Julia parser is a small lisp program written in femtolisp, the source-code for which is distributed inside Julia in [src/flisp](https://"
"github.com/JuliaLang/julia/tree/master/src/flisp)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:68
msgid ""
"The interface functions for this are primarily defined in [`jlfrontend.scm`](https://github.com/JuliaLang/julia/blob/master/src/jlfrontend."
"scm).  The code in [`ast.c`](https://github.com/JuliaLang/julia/blob/master/src/ast.c) handles this handoff on the Julia side."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:73
msgid ""
"The other relevant files at this stage are [`julia-parser.scm`](https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm), which "
"handles tokenizing Julia code and turning it into an AST, and [`julia-syntax.scm`](https://github.com/JuliaLang/julia/blob/master/src/julia-"
"syntax.scm), which handles transforming complex AST representations into simpler, \"lowered\" AST representations which are more suitable "
"for analysis and execution."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/eval.md:74
#, no-wrap
msgid "[Macro Expansion](@id dev-macro-expansion)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:80
msgid ""
"When [`eval()`](@ref) encounters a macro, it expands that AST node before attempting to evaluate the expression. Macro expansion involves a "
"handoff from [`eval()`](@ref) (in Julia), to the parser function `jl_macroexpand()` (written in `flisp`) to the Julia macro itself (written "
"in - what else - Julia) via `fl_invoke_julia_macro()`, and back."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:83
msgid ""
"Typically, macro expansion is invoked as a first step during a call to [`Meta.lower()`](@ref)/`jl_expand()`, although it can also be invoked "
"directly by a call to [`macroexpand()`](@ref)/`jl_macroexpand()`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/eval.md:84
#, no-wrap
msgid "[Type Inference](@id dev-type-inference)"
msgstr "[åæ¨è«](@id dev-type-inference)"

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:92
msgid ""
"Type inference is implemented in Julia by [`typeinf()` in `compiler/typeinfer.jl`](https://github.com/JuliaLang/julia/blob/master/base/"
"compiler/typeinfer.jl).  Type inference is the process of examining a Julia function and determining bounds for the types of each of its "
"variables, as well as bounds on the type of the return value from the function.  This enables many future optimizations, such as unboxing of "
"known immutable values, and compile-time hoisting of various run-time operations such as computing field offsets and function pointers.  "
"Type inference may also include other steps such as constant propagation and inlining."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:95
#, no-wrap
msgid ""
"!!! sidebar \"More Definitions\"\n"
"      * JIT\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:99
#, no-wrap
msgid ""
"        Just-In-Time Compilation The process of generating native-machine code into memory right when\n"
"        it is needed.\n"
"      * LLVM\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:104
#, no-wrap
msgid ""
"        Low-Level Virtual Machine (a compiler) The Julia JIT compiler is a program/library called libLLVM.\n"
"        Codegen in Julia refers both to the process of taking a Julia AST and turning it into LLVM instructions,\n"
"        and the process of LLVM optimizing that and turning it into native assembly instructions.\n"
"      * C++\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:109
#, no-wrap
msgid ""
"        The programming language that LLVM is implemented in, which means that codegen is also implemented\n"
"        in this language. The rest of Julia's library is implemented in C, in part because its smaller\n"
"        feature set makes it more usable as a cross-language interface layer.\n"
"      * box\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:113
#, no-wrap
msgid ""
"        This term is used to describe the process of taking a value and allocating a wrapper around the\n"
"        data that is tracked by the garbage collector (gc) and is tagged with the object's type.\n"
"      * unbox\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:117
#, no-wrap
msgid ""
"        The reverse of boxing a value. This operation enables more efficient manipulation of data when\n"
"        the type of that data is fully known at compile-time (through type inference).\n"
"      * generic function\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:121
#, no-wrap
msgid ""
"        A Julia function composed of multiple \"methods\" that are selected for dynamic dispatch based on\n"
"        the argument type-signature\n"
"      * anonymous function or \"method\"\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:124
#, no-wrap
msgid ""
"        A Julia function without a name and without type-dispatch capabilities\n"
"      * primitive function\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:128
#, no-wrap
msgid ""
"        A function implemented in C but exposed in Julia as a named function \"method\" (albeit without\n"
"        generic function dispatch capabilities, similar to a anonymous function)\n"
"      * intrinsic function\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:133
#, no-wrap
msgid ""
"        A low-level operation exposed as a function in Julia. These pseudo-functions implement operations\n"
"        on raw bits such as add and sign extend that cannot be expressed directly in any other way. Since\n"
"        they operate on bits directly, they must be compiled into a function and surrounded by a call\n"
"        to `Core.Intrinsics.box(T, ...)` to reassign type information to the value.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/eval.md:134
#, no-wrap
msgid "[JIT Code Generation](@id dev-codegen)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:137
msgid "Codegen is the process of turning a Julia AST into native machine code."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:139
msgid ""
"The JIT environment is initialized by an early call to [`jl_init_codegen` in `codegen.cpp`](https://github.com/JuliaLang/julia/blob/master/"
"src/codegen.cpp)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:143
msgid ""
"On demand, a Julia method is converted into a native function by the function `emit_function(jl_method_instance_t*)`.  (note, when using the "
"MCJIT (in LLVM v3.4+), each function must be JIT into a new module.) This function recursively calls `emit_expr()` until the entire function "
"has been emitted."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:148
msgid ""
"Much of the remaining bulk of this file is devoted to various manual optimizations of specific code patterns. For example, "
"`emit_known_call()` knows how to inline many of the primitive functions (defined in [`builtins.c`](https://github.com/JuliaLang/julia/blob/"
"master/src/builtins.c)) for various combinations of argument types."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:150
msgid "Other parts of codegen are handled by various helper files:"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/eval.md:152
msgid "[`debuginfo.cpp`](https://github.com/JuliaLang/julia/blob/master/src/debuginfo.cpp)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:155
#, no-wrap
msgid ""
"    Handles backtraces for JIT functions\n"
"  * [`ccall.cpp`](https://github.com/JuliaLang/julia/blob/master/src/ccall.cpp)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:158
#, no-wrap
msgid ""
"    Handles the ccall and llvmcall FFI, along with various `abi_*.cpp` files\n"
"  * [`intrinsics.cpp`](https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:160
#, no-wrap
msgid "    Handles the emission of various low-level intrinsic functions\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:163
#, no-wrap
msgid ""
"!!! sidebar \"Bootstrapping\"\n"
"    The process of creating a new system image is called \"bootstrapping\".\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:167
#, no-wrap
msgid ""
"    The etymology of this word comes from the phrase \"pulling oneself up by the bootstraps\", and\n"
"    refers to the idea of starting from a very limited set of available functions and definitions\n"
"    and ending with the creation of a full-featured environment.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/eval.md:168
#, no-wrap
msgid "[System Image](@id dev-sysimg)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:176
msgid ""
"The system image is a precompiled archive of a set of Julia files. The `sys.ji` file distributed with Julia is one such system image, "
"generated by executing the file [`sysimg.jl`](https://github.com/JuliaLang/julia/blob/master/base/sysimg.jl), and serializing the resulting "
"environment (including Types, Functions, Modules, and all other defined values) into a file. Therefore, it contains a frozen version of the "
"`Main`, `Core`, and `Base` modules (and whatever else was in the environment at the end of bootstrapping). This serializer/deserializer is "
"implemented by [`jl_save_system_image`/`jl_restore_system_image` in `staticdata.c`](https://github.com/JuliaLang/julia/blob/master/src/"
"staticdata.c)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/eval.md:182
msgid ""
"If there is no sysimg file (`jl_options.image_file == NULL`), this also implies that `--build` was given on the command line, so the final "
"result should be a new sysimg file. During Julia initialization, minimal `Core` and `Main` modules are created. Then a file named `boot.jl` "
"is evaluated from the current directory. Julia then evaluates any file given as a command line argument until it reaches the end. Finally, "
"it saves the resulting environment to a \"sysimg\" file for use as a starting point for a future Julia run."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/gc-sa.md:1
#, no-wrap
msgid "Static analyzer annotations for GC correctness in C code"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/gc-sa.md:3
#, no-wrap
msgid "Running the analysis"
msgstr "è§£æã®å®è¡"

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:12
msgid ""
"The analyzer plugin that drives the anlysis ships with julia. Its source code can be found in `src/clangsa`. Running it requires the clang "
"dependency to be build. Set the `BUILD_LLVM_CLANG` variable in your Make.user in order to build an appropriate version of clang.  You may "
"also want to use the prebuilt binaries using the `USE_BINARYBUILDER_LLVM` options. Afterwards, running the analysis over the source tree is "
"as simple as running `make -C src analyzegc`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/gc-sa.md:13
#, no-wrap
msgid "General Overview"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:20
msgid ""
"Since Julia's GC is precise, it needs to maintain correct rooting information for any value that may be referenced at any time GC may occur. "
"These places are known as `safepoints` and in the function local context, we extend this designation to any function call that may "
"recursively end up at a safepoint."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:25
msgid ""
"In generated code, this is taken care of automatically by the GC root placement pass (see the chapter on GC rooting in the LLVM codegen "
"devdocs). However, in C code, we need to inform the runtime of any GC roots manually. This is done using the following macros:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:26
#, no-wrap
msgid ""
"// The value assigned to any slot passed as an argument to these\n"
"// is rooted for the duration of this GC frame.\n"
"JL_GC_PUSH{1,...,6}(args...)\n"
"// The values assigned into the size `n` array `rts` are rooted\n"
"// for the duration of this GC frame.\n"
"JL_GC_PUSHARGS(rts, n)\n"
"// Pop a GC frame\n"
"JL_GC_POP\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:41
msgid ""
"If these macros are not used where they need to be, or they are used incorrectly, the result is silent memory corruption. As such it is very "
"important that they are placed correctly in all applicable code."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:47
msgid ""
"As such, we employ static analysis (and in particular the clang static analyzer) to help ensure that these macros are used correctly. The "
"remainder of this document gives an overview of this static analysis and describes the support needed in the julia code base to make things "
"work."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/gc-sa.md:48
#, no-wrap
msgid "GC Invariants"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:55
#, no-wrap
msgid ""
"There is two simple invariants correctness:\n"
"- All `GC_PUSH` calls need to be followed by an appropriate `GC_POP` (in practice we enforce this\n"
"  at the function level)\n"
"- If a value was previously not rooted at any safepoint, it may no longer be referenced\n"
"  afterwards\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:61
msgid ""
"Of course the devil is in the details here. In particular to satisfy the second of the above conditions, we need to know: - Which calls are "
"safepoints and which are not - Which values are rooted at any given safepoint and which are not - When is a value referenced"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:66
msgid ""
"For the second point in particular, we need to know which memory locations will be considered rooting at runtime (i.e. values assigned to "
"such locations are rooted). This includes locations explicitly designated as such by passing them to one of the `GC_PUSH` macros, globally "
"rooted locations and values, as well as any location recursively reachable from one of those locations."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/gc-sa.md:67
#, no-wrap
msgid "Static Analysis Algorithm"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:75
msgid ""
"The idea itself is very simple, although the implementation is quite a bit more complicated (mainly due to a large number of special cases "
"and intricacies of C and C++). In essence, we keep track of all locations that are rooting, all values that are rootable and any expression "
"(assignments, allocations, etc) affect the rootedness of any rootable values.  Then, at any safepoint, we perform a \"symbolic GC\" and "
"poison any values that are not rooted at said location. If these values are later referenced, we emit an error."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:79
msgid ""
"The clang static analyzer works by constructing a graph of states and exploring this graph for sources of errors. Several nodes in this "
"graph are generated by the analyzer itself (e.g. for control flow), but the definitions above augment this graph with our own state."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:87
msgid ""
"The static analyzer is interprocedural and can analyze control flow across function boundaries.  However, the static analyzer is not fully "
"recursive and makes heuristic decisions about which calls to explore (additionally some calls are cross-translation unit and invisible to "
"the analyzer).  In our case, our definition of correctness requires total information.  As such, we need to annotate the prototypes of all "
"function calls with whatever information the analysis required, even if that information would otherwise be available by interprocedural "
"static analysis."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:90
msgid ""
"Luckily however, we can still use this interprocedural analysis to ensure that the annotations we place on a given function are indeed "
"correct given the implementation of said function."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/gc-sa.md:91
#, no-wrap
msgid "The analyzer annotations"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:96
msgid ""
"These annotations are found in src/support/analyzer_annotations.h.  The are only active when the analyzer is being used and expand either to "
"nothing (for prototype annotations) or to no-ops (for function like annotations)."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/gc-sa.md:97
#, no-wrap
msgid "`JL_NOTSAFEPOINT`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:104
msgid ""
"This is perhaps the most common annotation, and should be placed on any function that is known not to possibly lead to reaching a GC "
"safepoint. In general, it is only safe for such a function to perform arithmetic, memory accesses and calls to functions either annotated "
"`JL_NOTSAFEPOINT` or otherwise known not to be safepoints (e.g.  function in the C standard library, which are hardcoded as such in the "
"analyzer)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:107
msgid "It is valid to keep values unrooted across calls to any function annotated with this attribute:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:109 ext/julia/doc/src/devdocs/gc-sa.md:170 ext/julia/doc/src/devdocs/gc-sa.md:189
msgid "Usage Example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:109
#, no-wrap
msgid ""
"void jl_get_one() JL_NOTSAFEPOINT {\n"
"  return 1;\n"
"}\n"
"\n"
"jl_value_t *example() {\n"
"  jl_value_t *val = jl_alloc_whatever();\n"
"  // This is valid, even though `val` is unrooted, because\n"
"  // jl_get_one is not a safepoint\n"
"  jl_get_one();\n"
"  return val;\n"
"}\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/gc-sa.md:123
#, no-wrap
msgid "`JL_MAYBE_UNROOTED`/`JL_ROOTS_TEMPORARILY`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:135
msgid ""
"When `JL_MAYBE_UNROOTED` is annotated as an argument on a function, indicates that said argument may be passed, even if it is not rooted.  "
"In the ordinary course of events, the julia ABI guarantees that callers root values before passing them to callees. However, some functions "
"do not follow this ABI and allow values to be passed to them even though they are not rooted. Note however, that this does not automatically "
"imply that said argument will be preserved.  The `ROOTS_TEMPORARILY` annotation provides the stronger guarantee that, not only may the value "
"be unrooted when passed, it will also be preserved across any internal safepoints by the callee."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:139
msgid ""
"Note that `JL_NOTSAFEPOINT` essentially implies `JL_MAYBE_UNROOTED`/`JL_ROOTS_TEMPORARILY`, because the rootedness of an argument is "
"irrelevant if the function contains no safepoints."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:145
msgid ""
"One additional point to note is that these annotations apply on both the caller and the callee side. On the caller side, they lift "
"rootedness restrictions that are normally required for julia ABI functions. On the callee side, they have the reverse effect of preventing "
"these arguments from being considered implicitly rooted."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:149
msgid ""
"If either of these annotations is applied to the function as a whole, it applies to all arguments of the function. This should generally "
"only be necessary for varargs functions."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:151 ext/julia/doc/src/devdocs/gc-sa.md:212 ext/julia/doc/src/devdocs/gc-sa.md:230
#: ext/julia/doc/src/devdocs/gc-sa.md:255
msgid "Usage example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:151
#, no-wrap
msgid ""
"JL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e JL_MAYBE_UNROOTED);\n"
"jl_value_t *jl_alloc_error();\n"
"\n"
"void example() {\n"
"  // The return value of the allocation is unrooted. This would normally\n"
"  // be an error, but is allowed because of the above annotation.\n"
"  jl_throw(jl_alloc_error());\n"
"}\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/gc-sa.md:162
#, no-wrap
msgid "`JL_PROPAGATES_ROOT`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:168
msgid ""
"This annotation is commonly found on accessor functions that return one rootable object stored within another. When annotated on a function "
"argument, it tells the analyzer that the root for that argument also applies to the value returned by the function."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:170
#, no-wrap
msgid ""
"jl_value_t *jl_svecref(jl_svec_t *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;\n"
"\n"
"size_t example(jl_svec_t *svec) {\n"
"  jl_value_t *val = jl_svecref(svec, 1)\n"
"  // This is valid, because, as annotated by the PROPAGATES_ROOT annotation,\n"
"  // jl_svecref propagates the rooted-ness from `svec` to `val`\n"
"  jl_gc_safepoint();\n"
"  return jl_unbox_long(val);\n"
"}\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/gc-sa.md:182
#, no-wrap
msgid "`JL_ROOTING_ARGUMENT`/`JL_ROOTED_ARGUMENT`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:187
msgid ""
"This is essentially the assignment counterpart to `JL_PROPAGATES_ROOT`.  When assigning a value to a field of another value that is already "
"rooted, the assigned value will inherit the root of the value it is assigned into."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:189
#, no-wrap
msgid ""
"void jl_svecset(void *t JL_ROOTING_ARGUMENT, size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT\n"
"\n"
"\n"
"size_t example(jl_svec_t *svec) {\n"
"  jl_value_t *val = jl_box_long(10000);\n"
"  jl_svecset(svec, val);\n"
"  // This is valid, because the annotations imply that the\n"
"  // jl_svecset propagates the rooted-ness from `svec` to `val`\n"
"  jl_gc_safepoint();\n"
"  return jl_unbox_long(val);\n"
"}\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/gc-sa.md:203
#, no-wrap
msgid "`JL_GC_DISABLED`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:210
msgid ""
"This annotation implies that this function is only called with the GC runtime-disabled.  Functions of this kind are most often encountered "
"during startup and in the GC code itself.  Note that this annotation is checked against the runtime enable/disable calls, so clang will know "
"if you lie. This is not a good way to disable processing of a given function if the GC is not actually disabled (use `ifdef "
"__clang_analyzer__` for that if you must)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:212
#, no-wrap
msgid ""
"void jl_do_magic() JL_GC_DISABLED {\n"
"  // Wildly allocate here with no regard for roots\n"
"}\n"
"\n"
"void example() {\n"
"  int en = jl_gc_enable(0);\n"
"  jl_do_magic();\n"
"  jl_gc_enable(en);\n"
"}\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/gc-sa.md:224
#, no-wrap
msgid "`JL_REQUIRE_ROOTED_SLOT`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:228
msgid "This annotation requires the caller to pass in a slot that is rooted (i.e. values assigned to this slot will be rooted)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:230
#, no-wrap
msgid ""
"void jl_do_processing(jl_value_t **slot JL_REQUIRE_ROOTED_SLOT) {\n"
"  *slot = jl_box_long(1);\n"
"  // Ok, only, because the slot was annotated as rooting\n"
"  jl_gc_safepoint();\n"
"}\n"
"\n"
"void example() {\n"
"  jl_value_t *slot = NULL;\n"
"  JL_GC_PUSH1(&slot);\n"
"  jl_do_processing(&slot);\n"
"  JL_GC_POP();\n"
"}\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/gc-sa.md:245
#, no-wrap
msgid "`JL_GLOBALLY_ROOTED`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:253
msgid ""
"This annotation implies that a given value is always globally rooted.  It can be applied to global variable declarations, in which case it "
"will apply to the value of those variables (or values if the declaration if for an array), or to functions, in which case it will apply to "
"the return value of such functions (e.g. for functions that always return some private, globally rooted value)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:255
#, no-wrap
msgid ""
"extern JL_DLLEXPORT jl_datatype_t *jl_any_type JL_GLOBALLY_ROOTED;\n"
"jl_ast_context_t *jl_ast_ctx(fl_context_t *fl) JL_GLOBALLY_ROOTED;\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/gc-sa.md:260
#, no-wrap
msgid "`JL_ALWAYS_LEAFTYPE`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:270
msgid ""
"This annotations is essentially equivalent to `JL_GLOBALLY_ROOTED`, except that is should only be used if those values are globally rooted "
"by virtue of being a leaftype. The rooting of leaftypes is a bit complicated. They are generally rooted through `cache` field of the "
"corresponding `TypeName`, which itself is rooted by the containing module (so they're rooted as long as the containing module is ok) and we "
"can generally assume that leaftypes are rooted where they are used, but we may refine this property in the future, so the separate "
"annotation helps split out the reason for being globally rooted."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:273
msgid "The analyzer also automatically detects checks for leaftype-ness and will not complain about missing GC roots on these paths."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:274
#, no-wrap
msgid "JL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_value_t *type, size_t dim) JL_ALWAYS_LEAFTYPE;\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/gc-sa.md:278
#, no-wrap
msgid "`JL_GC_PROMISE_ROOTED`"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:284
msgid ""
"This is a function-like annotation. Any value passed to this annotation will be considered rooted for the scope of the current function. It "
"is designed as an escape hatch for analyzer inadequacy or complicated situations. However, it should be used sparingly, in favor of "
"improving the analyzer itself."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:285
#, no-wrap
msgid ""
"void example() {\n"
"  jl_value_t *val = jl_alloc_something();\n"
"  if (some_condition) {\n"
"    // We happen to know for complicated external reasons\n"
"    // that val is rooted under these conditions\n"
"    JL_GC_PROMISE_ROOTED(val);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/gc-sa.md:296
#, no-wrap
msgid "Completeness of analysis"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/gc-sa.md:303
msgid ""
"The analyzer only looks at local information. In particular, e.g. in the `PROPAGATES_ROOT` case above, it assumes that such memory is only "
"modified in ways it can see, not in any called functions (unless it happens to decide to consider them in its analysis) and not in any "
"concurrently running threads. As such, it may miss a few problematic cases, though in practice such concurrent modification is fairly rare. "
"Improving the analyzer to handle more such cases may be an interesting topic for future work."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/subarrays.md:1
#, no-wrap
msgid "SubArrays"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:5
msgid ""
"Julia's `SubArray` type is a container encoding a \"view\" of a parent [`AbstractArray`](@ref).  This page documents some of the design "
"principles and implementation of `SubArray`s."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:9
msgid ""
"One of the major design goals is to ensure high performance for views of both [`IndexLinear`](@ref) and [`IndexCartesian`](@ref) arrays. "
"Furthermore, views of `IndexLinear` arrays should themselves be `IndexLinear` to the extent that it is possible."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/subarrays.md:10
#, no-wrap
msgid "Index replacement"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:13
msgid "Consider making 2d slices of a 3d array:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:14
#, no-wrap
msgid "DocTestSetup = :(import Random; Random.seed!(1234))\n"
msgstr ""

#. type: Code fence info string
#: ext/julia/doc/src/devdocs/subarrays.md:17 ext/julia/doc/src/devdocs/subarrays.md:70 ext/julia/doc/src/devdocs/subarrays.md:133
#, no-wrap
msgid "jldoctest subarray"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:17
#, no-wrap
msgid ""
"julia> A = rand(2,3,4);\n"
"\n"
"julia> S1 = view(A, :, 1, 2:3)\n"
"2Ã2 view(::Array{Float64,3}, :, 1, 2:3) with eltype Float64:\n"
" 0.200586  0.066423\n"
" 0.298614  0.956753\n"
"\n"
"julia> S2 = view(A, 1, :, 2:3)\n"
"3Ã2 view(::Array{Float64,3}, 1, :, 2:3) with eltype Float64:\n"
" 0.200586  0.066423\n"
" 0.246837  0.646691\n"
" 0.648882  0.276021\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:39
msgid ""
"`view` drops \"singleton\" dimensions (ones that are specified by an `Int`), so both `S1` and `S2` are two-dimensional `SubArray`s. "
"Consequently, the natural way to index these is with `S1[i,j]`.  To extract the value from the parent array `A`, the natural approach is to "
"replace `S1[i,j]` with `A[i,1,(2:3)[j]]` and `S2[i,j]` with `A[1,i,(2:3)[j]]`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:42
msgid "The key feature of the design of SubArrays is that this index replacement can be performed without any runtime overhead."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/subarrays.md:43
#, no-wrap
msgid "SubArray design"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/subarrays.md:45
#, no-wrap
msgid "Type parameters and fields"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:48
msgid "The strategy adopted is first and foremost expressed in the definition of the type:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:49
#, no-wrap
msgid ""
"struct SubArray{T,N,P,I,L} <: AbstractArray{T,N}\n"
"    parent::P\n"
"    indices::I\n"
"    offset1::Int       # for linear indexing and pointer, only valid when L==true\n"
"    stride1::Int       # used only for linear indexing\n"
"    ...\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:64
#, no-wrap
msgid ""
"`SubArray` has 5 type parameters.  The first two are the standard element type and dimensionality.\n"
" The next is the type of the parent `AbstractArray`.  The most heavily-used is the fourth parameter,\n"
"a `Tuple` of the types of the indices for each dimension. The final one, `L`, is only provided\n"
"as a convenience for dispatch; it's a boolean that represents whether the index types support\n"
"fast linear indexing. More on that later.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:69
msgid ""
"If in our example above `A` is a `Array{Float64, 3}`, our `S1` case above would be a `SubArray{Float64,2,Array{Float64,3},Tuple{Base."
"Slice{Base.OneTo{Int64}},Int64,UnitRange{Int64}},false}`.  Note in particular the tuple parameter, which stores the types of the indices "
"used to create `S1`. Likewise,"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:70
#, no-wrap
msgid ""
"julia> S1.indices\n"
"(Base.Slice(Base.OneTo(2)), 1, 2:3)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:77
msgid ""
"Storing these values allows index replacement, and having the types encoded as parameters allows one to dispatch to efficient algorithms."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/subarrays.md:78
#, no-wrap
msgid "Index translation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:84
msgid ""
"Performing index translation requires that you do different things for different concrete `SubArray` types.  For example, for `S1`, one "
"needs to apply the `i,j` indices to the first and third dimensions of the parent array, whereas for `S2` one needs to apply them to the "
"second and third.  The simplest approach to indexing would be to do the type-analysis at runtime:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:85
#, no-wrap
msgid ""
"parentindices = Vector{Any}()\n"
"for thisindex in S.indices\n"
"    ...\n"
"    if isa(thisindex, Int)\n"
"        # Don't consume one of the input indices\n"
"        push!(parentindices, thisindex)\n"
"    elseif isa(thisindex, AbstractVector)\n"
"        # Consume an input index\n"
"        push!(parentindices, thisindex[inputindex[j]])\n"
"        j += 1\n"
"    elseif isa(thisindex, AbstractMatrix)\n"
"        # Consume two input indices\n"
"        push!(parentindices, thisindex[inputindex[j], inputindex[j+1]])\n"
"        j += 2\n"
"    elseif ...\n"
"end\n"
"S.parent[parentindices...]\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:107
msgid ""
"Unfortunately, this would be disastrous in terms of performance: each element access would allocate memory, and involves the running of a "
"lot of poorly-typed code."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:112
msgid ""
"The better approach is to dispatch to specific methods to handle each type of stored index. That's what `reindex` does: it dispatches on the "
"type of the first stored index and consumes the appropriate number of input indices, and then it recurses on the remaining indices. In the "
"case of `S1`, this expands to"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:113
#, no-wrap
msgid "Base.reindex(S1, S1.indices, (i, j)) == (i, S1.indices[2], S1.indices[3][j])\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:118
msgid "for any pair of indices `(i,j)` (except [`CartesianIndex`](@ref)s and arrays thereof, see below)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:121
msgid ""
"This is the core of a `SubArray`; indexing methods depend upon `reindex` to do this index translation.  Sometimes, though, we can avoid the "
"indirection and make it even faster."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:128
msgid ""
"Linear indexing can be implemented efficiently when the entire array has a single stride that separates successive elements, starting from "
"some offset. This means that we can pre-compute these values and represent linear indexing simply as an addition and multiplication, "
"avoiding the indirection of `reindex` and (more importantly) the slow computation of the cartesian coordinates entirely."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:132
msgid ""
"For `SubArray` types, the availability of efficient linear indexing is based purely on the types of the indices, and does not depend on "
"values like the size of the parent array. You can ask whether a given set of indices supports fast linear indexing with the internal `Base."
"viewindexing` function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:133
#, no-wrap
msgid ""
"julia> Base.viewindexing(S1.indices)\n"
"IndexCartesian()\n"
"\n"
"julia> Base.viewindexing(S2.indices)\n"
"IndexLinear()\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:144
msgid ""
"This is computed during construction of the `SubArray` and stored in the `L` type parameter as a boolean that encodes fast linear indexing "
"support. While not strictly necessary, it means that we can define dispatch directly on `SubArray{T,N,A,I,true}` without any intermediaries."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:147
msgid "Since this computation doesn't depend on runtime values, it can miss some cases in which the stride happens to be uniform:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:148
#, no-wrap
msgid ""
"julia> A = reshape(1:4*2, 4, 2)\n"
"4Ã2 reshape(::UnitRange{Int64}, 4, 2) with eltype Int64:\n"
" 1  5\n"
" 2  6\n"
" 3  7\n"
" 4  8\n"
"\n"
"julia> diff(A[2:2:4,:][:])\n"
"3-element Array{Int64,1}:\n"
" 2\n"
" 2\n"
" 2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:166
msgid ""
"A view constructed as `view(A, 2:2:4, :)` happens to have uniform stride, and therefore linear indexing indeed could be performed "
"efficiently.  However, success in this case depends on the size of the array: if the first dimension instead were odd,"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:167
#, no-wrap
msgid ""
"julia> A = reshape(1:5*2, 5, 2)\n"
"5Ã2 reshape(::UnitRange{Int64}, 5, 2) with eltype Int64:\n"
" 1   6\n"
" 2   7\n"
" 3   8\n"
" 4   9\n"
" 5  10\n"
"\n"
"julia> diff(A[2:2:4,:][:])\n"
"3-element Array{Int64,1}:\n"
" 2\n"
" 3\n"
" 2\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:186
#, no-wrap
msgid ""
"then `A[2:2:4,:]` does not have uniform stride, so we cannot guarantee efficient linear indexing.\n"
" Since we have to base this decision based purely on types encoded in the parameters of the `SubArray`,\n"
"`S = view(A, 2:2:4, :)` cannot implement efficient linear indexing.\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/subarrays.md:187
#, no-wrap
msgid "A few details"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/subarrays.md:198
msgid ""
"Note that the `Base.reindex` function is agnostic to the types of the input indices; it simply determines how and where the stored indices "
"should be reindexed. It not only supports integer indices, but it supports non-scalar indexing, too. This means that views of views don't "
"need two levels of indirection; they can simply re-compute the indices into the original parent array!"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/subarrays.md:198
msgid ""
"Hopefully by now it's fairly clear that supporting slices means that the dimensionality, given by the parameter `N`, is not necessarily "
"equal to the dimensionality of the parent array or the length of the `indices` tuple.  Neither do user-supplied indices necessarily line up "
"with entries in the `indices` tuple (e.g., the second user-supplied index might correspond to the third dimension of the parent array, and "
"the third element in the `indices` tuple)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:201
#, no-wrap
msgid ""
"    What might be less obvious is that the dimensionality of the stored parent array must be equal\n"
"    to the number of effective indices in the `indices` tuple. Some examples:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:207
#, no-wrap
msgid ""
"    ```julia\n"
"    A = reshape(1:35, 5, 7) # A 2d parent Array\n"
"    S = view(A, 2:7)         # A 1d view created by linear indexing\n"
"    S = view(A, :, :, 1:1)   # Appending extra indices is supported\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:213
#, no-wrap
msgid ""
"    Naively, you'd think you could just set `S.parent = A` and `S.indices = (:,:,1:1)`, but supporting\n"
"    this dramatically complicates the reindexing process, especially for views of views. Not only\n"
"    do you need to dispatch on the types of the stored indices, but you need to examine whether a\n"
"    given index is the final one and \"merge\" any remaining stored indices together. This is not an\n"
"    easy task, and even worse: it's slow since it implicitly depends upon linear indexing.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:225
#, no-wrap
msgid ""
"    Fortunately, this is precisely the computation that `ReshapedArray` performs, and it does so linearly\n"
"    if possible. Consequently, `view` ensures that the parent array is the appropriate dimensionality\n"
"    for the given indices by reshaping it if needed. The inner `SubArray` constructor ensures that\n"
"    this invariant is satisfied.\n"
"  * [`CartesianIndex`](@ref) and arrays thereof throw a nasty wrench into the `reindex` scheme. Recall that\n"
"    `reindex` simply dispatches on the type of the stored indices in order to determine how many passed\n"
"    indices should be used and where they should go. But with `CartesianIndex`, there's no longer\n"
"    a one-to-one correspondence between the number of passed arguments and the number of dimensions\n"
"    that they index into. If we return to the above example of `Base.reindex(S1, S1.indices, (i, j))`,\n"
"    you can see that the expansion is incorrect for `i, j = CartesianIndex(), CartesianIndex(2,1)`.\n"
"    It should *skip* the `CartesianIndex()` entirely and return:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:229
#, no-wrap
msgid ""
"    ```julia\n"
"    (CartesianIndex(2,1)[1], S1.indices[2], S1.indices[3][CartesianIndex(2,1)[2]])\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:231
#, no-wrap
msgid "    Instead, though, we get:\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:235
#, no-wrap
msgid ""
"    ```julia\n"
"    (CartesianIndex(), S1.indices[2], S1.indices[3][CartesianIndex(2,1)])\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/subarrays.md:243
#, no-wrap
msgid ""
"    Doing this correctly would require *combined* dispatch on both the stored and passed indices across\n"
"    all combinations of dimensionalities in an intractable manner. As such, `reindex` must never be\n"
"    called with `CartesianIndex` indices. Fortunately, the scalar case is easily handled by first\n"
"    flattening the `CartesianIndex` arguments to plain integers. Arrays of `CartesianIndex`, however,\n"
"    cannot be split apart into orthogonal pieces so easily. Before attempting to use `reindex`, `view`\n"
"    must ensure that there are no arrays of `CartesianIndex` in the argument list. If there are, it\n"
"    can simply \"punt\" by avoiding the `reindex` calculation entirely, constructing a nested `SubArray`\n"
"    with two levels of indirection instead.\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/ssair.md:1
#, no-wrap
msgid "Julia SSA-form IR"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/ssair.md:3
#, no-wrap
msgid "Background"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:14
msgid ""
"Beginning in Julia 0.7, parts of the compiler use a new [SSA-form](https://en.wikipedia.org/wiki/Static_single_assignment_form)  "
"intermediate representation. Historically, the compiler used to directly generate LLVM IR, from a lowered form of the Julia AST. This form "
"had most syntactic abstractions removed, but still looked a lot like an abstract syntax tree.  Over time, in order to facilitate "
"optimizations, SSA values were introduced to this IR and the IR was linearized (i.e. a form where function arguments may only be SSA values "
"or constants). However, non-ssa values (slots) remained in the IR due to the lack of Phi nodes in the IR (necessary for back-edges and re-"
"merging of conditional control flow), negating much of the usefulfulness of the SSA form representation to perform middle end optimizations. "
"Some heroic effort was put into making these optimizations work without a complete SSA form representation, but the lack of such a "
"representation ultimately proved prohibitive."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/ssair.md:15
#, no-wrap
msgid "New IR nodes"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:19
msgid ""
"With the new IR representation, the compiler learned to handle four new IR nodes, Phi nodes, Pi nodes as well as PhiC nodes and Upsilon "
"nodes (the latter two are only used for exception handling)."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ssair.md:20
#, no-wrap
msgid "Phi nodes and Pi nodes"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:24
msgid ""
"Phi nodes are part of generic SSA abstraction (see the link above if you're not familiar with the concept). In the Julia IR, these nodes are "
"represented as:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:24
#, no-wrap
msgid ""
"struct PhiNode\n"
"    edges::Vector{Int}\n"
"    values::Vector{Any}\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:39
msgid ""
"where we ensure that both vectors always have the same length. In the canonical representation (the one handles by codegen and the "
"interpreter), the edge values indicate come-from statement numbers (i.e.  if edge has an entry of `15`, there must be a `goto`, `gotoifnot` "
"or implicit fall through from statement `15` that targets this phi node). Values are either SSA values or constants. It is also possible for "
"a value to be unassigned if the variable was not defined on this path. However, undefinedness checks get explicitly inserted and represented "
"as booleans after middle end optimizations, so code generators may assume that any use of a phi node will have an assigned value in the "
"corresponding slot. It is also legal for the mapping to be incomplete, i.e. for a phi node to have missing incoming edges. In that case, it "
"must be dynamically guaranteed that the corresponding value will not be used."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:44
msgid ""
"PiNodes encode statically proven information that may be implicitly assumed in basic blocks dominated by a given pi node. They are "
"conceptually equivalent to the technique introduced in the paper \"ABCD: Eliminating Array Bounds Checks on Demand\" or the predicate info "
"nodes in LLVM. To see how they work, consider, e.g."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:45
#, no-wrap
msgid ""
"%x::Union{Int, Float64} # %x is some Union{Int, Float64} typed ssa value\n"
"if isa(x, Int)\n"
"    # use x\n"
"else\n"
"    # use x\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:55
msgid "we can perform predicate insertion and turn this into:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:56
#, no-wrap
msgid ""
"%x::Union{Int, Float64} # %x is some Union{Int, Float64} typed ssa value\n"
"if isa(x, Int)\n"
"    %x_int = PiNode(x, Int)\n"
"    # use %x_int\n"
"else\n"
"    %x_float = PiNode(x, Float64)\n"
"    # use %x_float\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:72
msgid ""
"Pi nodes are generally ignored in the interpreter, since they don't have any effect on the values, but they may sometimes lead to code "
"generation in the compiler (e.g. to change from an implicitly union split representation to a plain unboxed representation). The main "
"usefulness of PiNodes stems from the fact that path conditions of the values can be accumulated simply by def-use chain walking that is "
"generally done for most optimizations that care about these conditions anyway."
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/ssair.md:73
#, no-wrap
msgid "PhiC nodes and Upsilon nodes"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:79
msgid ""
"Exception handling complicates the SSA story moderately, because exception handling introduces additional control flow edges into the IR "
"across which values must be tracked.  One approach to do so, which is followed by LLVM is to make calls which may throw exceptions into "
"basic block terminators and add an explicit control flow edge to the catch handler:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:80
#, no-wrap
msgid ""
"invoke @function_that_may_throw() to label %regular unwind to %catch\n"
"\n"
"regular:\n"
"# Control flow continues here\n"
"\n"
"catch:\n"
"# Exceptions go here\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:110
msgid ""
"However, this is problematic in a language like julia where at the start of the optimization pipeline, we do not know which calls throw. We "
"would have to conservatively assume that every call (which in julia is every statement) throws. This would have several negative effects.  "
"On the one hand, it would essentially recuce the scope of every basic block to a single call, defeating the purpose of having operations be "
"performed at the basic block level. On the other hand, every catch basic block would have `n*m` phi node arguments (`n`, the number of "
"statements in the critical region, `m` the number of live values through the catch block). To work around this, we use a combination of "
"`Upsilon` and `PhiC` (the C standing for `catch`, written `Ïá¶` in the IR pretty printer, because unicode subscript c is not available) "
"nodes. There is several ways to think of these nodes, but perhaps the easiest is to think of each `PhiC` as a load from a unique store-many, "
"read-once slot, with `Upsilon` being the corresponding store operation. The `PhiC` has an operand list of all the upsilon nodes that store "
"to its implicit slot. The `Upsilon` nodes however, do not record which `PhiC` node they store to. This is done for more natural integration "
"with the rest of the SSA IR. E.g.  if there are no more uses of a `PhiC` node, it is safe to delete is and the same is true of an `Upsilon` "
"node. In most IR passes, `PhiC` nodes can be treated similar to `Phi` nodes. One can follow use-def chains through them, and they can be "
"lifted to new `PhiC` nodes and new Upsilon nodes (in the same places as the original `Upsilon` nodes). The result of this scheme is that the "
"number of Upsilon nodes (and `PhiC` arguments) is proportional to the number of assigned values to a particular variable (before SSA "
"conversion), rather than the number of statements in the critical region."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:112
msgid "To see this scheme in action, consider the function"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:113
#, no-wrap
msgid ""
"function foo()\n"
"    x = 1\n"
"    try\n"
"        y = 2\n"
"        error()\n"
"    catch\n"
"    end\n"
"    (x, y)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:126
msgid "The corresponding IR (with irrelevant types stripped) is:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:127
#, no-wrap
msgid ""
"ir = Code\n"
"1 â       nothing\n"
"2 â       $(Expr(:enter, 5))\n"
"3 â %3  = Ï (#undef)\n"
"â   %4  = Ï (1)\n"
"â   %5  = Ï (2)\n"
"â         Main.bar()\n"
"â   %7  = Ï (3)\n"
"âââ       $(Expr(:leave, 1))\n"
"4 â       goto 6\n"
"5 â %10 = Ïá¶ (%3, %5)\n"
"â   %11 = Ïá¶ (%4, %7)\n"
"âââ       $(Expr(:leave, 1))\n"
"6 â %13 = Ï (4 => 2, 5 => %10)::NotInferenceDontLookHere.MaybeUndef(NotInferenceDontLookHere.Const(2, false))\n"
"â   %14 = Ï (4 => 3, 5 => %11)::Int64\n"
"â         $(Expr(:undefcheck, :y, Core.SSAValue(13)))\n"
"â   %16 = Core.tuple(%14, %13)\n"
"âââ       return %17\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:153
msgid ""
"Note in particular that every value live into the critical region gets an upsilon node at the top of the critical region. This is because "
"catch blocks are considered to have an invisible control flow edge from outside the function. As a result, no SSA value dominates the catch "
"blocks, and all incoming values have to come through a `Ïá¶` node."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/ssair.md:154
#, no-wrap
msgid "Main SSA data structure"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:166
msgid ""
"The main `SSAIR` data structure is worthy of discussion. It draws inspiration from LLVM and Webkit's B3 IR.  The core of the data structure "
"is a flat vector of statements. Each statement is implicitly assigned an SSA values based on its position in the vector (i.e. the result of "
"the statement at idx 1 can be accessed using `SSAValue(1)` etc). For each SSA value, we additionally maintain its type. Since, SSA values "
"are definitionally assigned only once, this type is also the result type of the expression at the corresponding index. However, while this "
"representation is rather efficient (since the assignments don't need to be explicitly)  encoded, if of course carries the drawback that "
"order is semantically significant, so reorderings and insertions change statement numbers. Additionally, we do not keep use lists (i.e. it "
"is impossible to walk from a def to all its uses without explicitly computing this map - def lists however are trivial since you can lookup "
"the corresponding statement from the index), so the LLVM-style RAUW (replace-all-uses-with) operation is unavailable."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:168
msgid "Instead, we do the following:"
msgstr ""

#. type: Bullet: '- '
#: ext/julia/doc/src/devdocs/ssair.md:178
msgid ""
"We keep a separate buffer of nodes to insert (including the position to insert them at, the type of the corresponding value and the node "
"itself). These nodes are numbered by their occurrence in the insertion buffer, allowing their values to be immediately used elesewhere in "
"the IR (i.e. if there is 12 statements in the original statement list, the first new statement will be accessible as `SSAValue(13)`)"
msgstr ""

#. type: Bullet: '- '
#: ext/julia/doc/src/devdocs/ssair.md:178
msgid "RAUW style operations are performed by setting the corresponding statement index to the replacement value."
msgstr ""

#. type: Bullet: '- '
#: ext/julia/doc/src/devdocs/ssair.md:178
msgid ""
"Statements are erased by setting the corresponding statement to `nothing` (this is essentially just a special-case convention of the above"
msgstr ""

#. type: Bullet: '- '
#: ext/julia/doc/src/devdocs/ssair.md:178
msgid "if there are any uses of the statement being erased they will be set to `nothing`)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:185
msgid ""
"There is a `compact!` function that compacts the above data structure by performing the insertion of nodes in the appropriate place, trivial "
"copy propagation and renaming of uses to any changed SSA values. However, the clever part of this scheme is that this compaction can be done "
"lazily as part of the subsequent pass. Most optimization passes need to walk over the entire list of statements, performing analysis or "
"modifications along the way. We provide an `IncrementalCompact` iterator that can be used to iterate over the statement list. It will "
"perform any necessary compaction, and return the new index of the node, as well as the node itself. It is legal at this point to walk def-"
"use chains, as well as make any modifications or deletions to the IR (insertions are disallowed however)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/ssair.md:188
msgid ""
"The idea behind this arrangement is that, since the optimization passes need to touch the corresponding memory anyway, and incur the "
"corresponding memory access penalty, performing the extra housekeeping should have comparatively little overhead (and save the overhead of "
"maintaining these data structures during IR modification)."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/compiler.md:1
#, no-wrap
msgid "High-level Overview of the Native-Code Generation Process"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/compiler.md:3
#, no-wrap
msgid "Representation of Pointers"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:8
msgid ""
"When emitting code to an object file, pointers will be emitted as relocations.  The deserialization code will ensure any object that pointed "
"to one of these constants gets recreated and contains the right runtime pointer."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:10
msgid "Otherwise, they will be emitted as literal constants."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:14
msgid ""
"To emit one of these objects, call `literal_pointer_val`.  It'll handle tracking the Julia value and the LLVM global, ensuring they are "
"valid both for the current runtime and after deserialization."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:18
msgid ""
"When emitted into the object file, these globals are stored as references in a large `gvals` table. This allows the deserializer to "
"reference them by index, and implement a custom manual mechanism similar to a Global Offset Table (GOT) to restore them."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:22
msgid ""
"Function pointers are handled similarly.  They are stored as values in a large `fvals` table.  Like globals, this allows the deserializer to "
"reference them by index."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:25
msgid "Note that `extern` functions are handled separately, with names, via the usual symbol resolution mechanism in the linker."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:28
msgid "Note too that `ccall` functions are also handled separately, via a manual GOT and Procedure Linkage Table (PLT)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/compiler.md:30
#, no-wrap
msgid "Representation of Intermediate Values"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:35
msgid ""
"Values are passed around in a `jl_cgval_t` struct.  This represents an R-value, and includes enough information to determine how to assign "
"or pass it somewhere."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:38
msgid ""
"They are created via one of the helper constructors, usually: `mark_julia_type` (for immediate values) and `mark_julia_slot` (for pointers "
"to values)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:44
msgid ""
"The function `convert_julia_type` can transform between any two types.  It returns an R-value with `cgval.typ` set to `typ`.  It'll cast the "
"object to the requested representation, making heap boxes, allocating stack copies, and computing tagged unions as needed to change the "
"representation."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:47
msgid "By contrast `update_julia_type` will change `cgval.typ` to `typ`, only if it can be done at zero-cost (i.e. without emitting any code)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/compiler.md:49
#, no-wrap
msgid "Union representation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:52
msgid "Inferred union types may be stack allocated via a tagged type representation."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:64
msgid ""
"The primitive routines that need to be able to handle tagged unions are: - mark-type - load-local - store-local - isa - is - emit_typeof - "
"emit_sizeof - boxed - unbox - specialized cc-ret"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:67
msgid "Everything else should be possible to handle in inference by using these primitives to implement union-splitting."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:77
#, no-wrap
msgid ""
"The representation of the tagged-union is as a pair\n"
"of `< void* union, byte selector >`.\n"
"The selector is fixed-size as `byte & 0x7f`,\n"
"and will union-tag the first 126 isbits.\n"
"It records the one-based depth-first count into the type-union of the\n"
"isbits objects inside. An index of zero indicates that the `union*` is\n"
"actually a tagged heap-allocated `jl_value_t*`,\n"
"and needs to be treated as normal for a boxed object rather than as a\n"
"tagged union.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:82
msgid ""
"The high bit of the selector (`byte & 0x80`) can be tested to determine if the `void*` is actually a heap-allocated (`jl_value_t*`) box, "
"thus avoiding the cost of re-allocating a box, while maintaining the ability to efficiently handle union-splitting based on the low bits."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:86
msgid ""
"It is guaranteed that `byte & 0x7f` is an exact test for the type, if the value can be represented by a tag â it will never be marked `byte "
"= 0x80`.  It is not necessary to also test the type-tag when testing `isa`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:93
msgid ""
"The `union*` memory region may be allocated at *any* size.  The only constraint is that it is big enough to contain the data currently "
"specified by `selector`.  It might not be big enough to contain the union of all types that could be stored there according to the "
"associated Union type field.  Use appropriate care when copying."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/compiler.md:95
#, no-wrap
msgid "Specialized Calling Convention Signature Representation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:98
msgid "A `jl_returninfo_t` object describes the calling convention details of any callable."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:102
msgid ""
"If any of the arguments or return type of a method can be represented unboxed, and the method is not varargs, it'll be given an optimized "
"calling convention signature based on its `specTypes` and `rettype` fields."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:104
msgid "The general principles are that:"
msgstr ""

#. type: Bullet: '- '
#: ext/julia/doc/src/devdocs/compiler.md:110
msgid "Primitive types get passed in int/float registers."
msgstr ""

#. type: Bullet: '- '
#: ext/julia/doc/src/devdocs/compiler.md:110
msgid "Tuples of VecElement types get passed in vector registers."
msgstr ""

#. type: Bullet: '- '
#: ext/julia/doc/src/devdocs/compiler.md:110
msgid "Structs get passed on the stack."
msgstr ""

#. type: Bullet: '- '
#: ext/julia/doc/src/devdocs/compiler.md:110
msgid "Return values are handle similarly to arguments, with a size-cutoff at which they will instead be returned via a hidden sret argument."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:112
msgid "The total logic for this is implemented by `get_specsig_function` and `deserves_sret`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/compiler.md:115
msgid ""
"Additionally, if the return type is a union, it may be returned as a pair of values (a pointer and a tag).  If the union values can be stack-"
"allocated, then sufficient space to store them will also be passed as a hidden first argument.  It is up to the callee whether the returned "
"pointer will point to this space, a boxed object, or even other constant memory."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/types.md:1
#, no-wrap
msgid "More about types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:5
msgid ""
"If you've used Julia for a while, you understand the fundamental role that types play.  Here we try to get under the hood, focusing "
"particularly on [Parametric Types](@ref)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/types.md:6
#, no-wrap
msgid "Types and sets (and `Any` and `Union{}`/`Bottom`)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:13
msgid ""
"It's perhaps easiest to conceive of Julia's type system in terms of sets. While programs manipulate individual values, a type refers to a "
"set of values. This is not the same thing as a collection; for example a [`Set`](@ref) of values is itself a single `Set` value.  Rather, a "
"type describes a set of *possible* values, expressing uncertainty about which value we have."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:16
msgid ""
"A *concrete* type `T` describes the set of values whose direct tag, as returned by the [`typeof`](@ref)  function, is `T`. An *abstract* "
"type describes some possibly-larger set of values."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:21
msgid ""
"[`Any`](@ref) describes the entire universe of possible values. [`Integer`](@ref) is a subset of `Any` that includes `Int`, [`Int8`](@ref), "
"and other concrete types.  Internally, Julia also makes heavy use of another type known as `Bottom`, which can also be written as `Union{}`. "
"This corresponds to the empty set."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:25
#, no-wrap
msgid ""
"Julia's types support the standard operations of set theory: you can ask whether `T1` is a \"subset\"\n"
"(subtype) of `T2` with `T1 <: T2`. Likewise, you intersect two types using [`typeintersect`](@ref), take\n"
"their union with [`Union`](@ref), and compute a type that contains their union with [`typejoin`](@ref):\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:26
#, no-wrap
msgid ""
"julia> typeintersect(Int, Float64)\n"
"Union{}\n"
"\n"
"julia> Union{Int, Float64}\n"
"Union{Float64, Int64}\n"
"\n"
"julia> typejoin(Int, Float64)\n"
"Real\n"
"\n"
"julia> typeintersect(Signed, Union{UInt8, Int8})\n"
"Int8\n"
"\n"
"julia> Union{Signed, Union{UInt8, Int8}}\n"
"Union{UInt8, Signed}\n"
"\n"
"julia> typejoin(Signed, Union{UInt8, Int8})\n"
"Integer\n"
"\n"
"julia> typeintersect(Tuple{Integer,Float64}, Tuple{Int,Real})\n"
"Tuple{Int64,Float64}\n"
"\n"
"julia> Union{Tuple{Integer,Float64}, Tuple{Int,Real}}\n"
"Union{Tuple{Int64,Real}, Tuple{Integer,Float64}}\n"
"\n"
"julia> typejoin(Tuple{Integer,Float64}, Tuple{Int,Real})\n"
"Tuple{Integer,Real}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:62
#, no-wrap
msgid ""
"While these operations may seem abstract, they lie at the heart of Julia.  For example, method\n"
"dispatch is implemented by stepping through the items in a method list until reaching one for which\n"
"the type of the argument tuple is a subtype of the method signature.\n"
"For this algorithm to work, it's important that methods be sorted by their specificity, and that the\n"
"search begins with the most specific methods. Consequently, Julia also implements a partial order on\n"
"types; this is achieved by functionality that is similar to `<:`, but with differences that will\n"
"be discussed below.\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/types.md:63
#, no-wrap
msgid "UnionAll types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:68
msgid ""
"Julia's type system can also express an *iterated union* of types: a union of types over all values of some variable. This is needed to "
"describe parametric types where the values of some parameters are not known."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:72
msgid ""
"For example, [`Array`](@ref) has two parameters as in `Array{Int,2}`. If we did not know the element type, we could write `Array{T,2} where "
"T`, which is the union of `Array{T,2}` for all values of `T`: `Union{Array{Int8,2}, Array{Int16,2}, ...}`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:75
msgid ""
"Such a type is represented by a `UnionAll` object, which contains a variable (`T` in this example, of type `TypeVar`), and a wrapped type "
"(`Array{T,2}` in this example)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:77
msgid "Consider the following methods:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:78
#, no-wrap
msgid ""
"f1(A::Array) = 1\n"
"f2(A::Array{Int}) = 2\n"
"f3(A::Array{T}) where {T<:Any} = 3\n"
"f4(A::Array{Any}) = 4\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:87
msgid ""
"The signature - as decribed in [Function calls](@ref) - of `f3` is a `UnionAll` type wrapping a tuple type: `Tuple{typeof(f3), Array{T}} "
"where T`.  All but `f4` can be called with `a = [1,2]`; all but `f2` can be called with `b = Any[1,2]`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:89
msgid "Let's look at these types a little more closely:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:90
#, no-wrap
msgid ""
"julia> dump(Array)\n"
"UnionAll\n"
"  var: TypeVar\n"
"    name: Symbol T\n"
"    lb: Core.TypeofBottom Union{}\n"
"    ub: Any\n"
"  body: UnionAll\n"
"    var: TypeVar\n"
"      name: Symbol N\n"
"      lb: Core.TypeofBottom Union{}\n"
"      ub: Any\n"
"    body: Array{T,N} <: DenseArray{T,N}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:110
msgid ""
"This indicates that `Array` actually names a `UnionAll` type. There is one `UnionAll` type for each parameter, nested. The syntax "
"`Array{Int,2}` is equivalent to `Array{Int}{2}`; internally each `UnionAll` is instantiated with a particular variable value, one at a time, "
"outermost-first. This gives a natural meaning to the omission of trailing type parameters; `Array{Int}` gives a type equivalent to "
"`Array{Int,N} where N`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:116
msgid ""
"A `TypeVar` is not itself a type, but rather should be considered part of the structure of a `UnionAll` type. Type variables have lower and "
"upper bounds on their values (in the fields `lb` and `ub`). The symbol `name` is purely cosmetic. Internally, `TypeVar`s are compared by "
"address, so they are defined as mutable types to ensure that \"different\" type variables can be distinguished. However, by convention they "
"should not be mutated."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:118
msgid "One can construct `TypeVar`s manually:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:119
#, no-wrap
msgid ""
"julia> TypeVar(:V, Signed, Real)\n"
"Signed<:V<:Real\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:126
msgid "There are convenience versions that allow you to omit any of these arguments except the `name` symbol."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:128
#, no-wrap
msgid "The syntax `Array{T} where T<:Integer` is lowered to\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:129
#, no-wrap
msgid ""
"let T = TypeVar(:T,Integer)\n"
"    UnionAll(T, Array{T})\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:136
msgid "so it is seldom necessary to construct a `TypeVar` manually (indeed, this is to be avoided)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/types.md:137
#, no-wrap
msgid "Free variables"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:143
#, no-wrap
msgid ""
"The concept of a *free* type variable is extremely important in the type system. We say that a\n"
"variable `V` is free in type `T` if `T` does not contain the `UnionAll` that introduces variable\n"
"`V`. For example, the type `Array{Array{V} where V<:Integer}` has no free variables, but the\n"
"`Array{V}` part inside of it does have a free variable, `V`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:150
msgid ""
"A type with free variables is, in some sense, not really a type at all. Consider the type `Array{Array{T}} where T`, which refers to all "
"homogeneous arrays of arrays.  The inner type `Array{T}`, seen by itself, might seem to refer to any kind of array.  However, every element "
"of the outer array must have the *same* array type, so `Array{T}` cannot refer to just any old array. One could say that `Array{T}` "
"effectively \"occurs\" multiple times, and `T` must have the same value each \"time\"."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:153
msgid ""
"For this reason, the function `jl_has_free_typevars` in the C API is very important. Types for which it returns true will not give "
"meaningful answers in subtyping and other type functions."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/types.md:154
#, no-wrap
msgid "TypeNames"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:157
msgid "The following two [`Array`](@ref) types are functionally equivalent, yet print differently:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:158
#, no-wrap
msgid ""
"julia> TV, NV = TypeVar(:T), TypeVar(:N)\n"
"(T, N)\n"
"\n"
"julia> Array\n"
"Array\n"
"\n"
"julia> Array{TV,NV}\n"
"Array{T,N}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:171
msgid "These can be distinguished by examining the `name` field of the type, which is an object of type `TypeName`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:172
#, no-wrap
msgid ""
"julia> dump(Array{Int,1}.name)\n"
"TypeName\n"
"  name: Symbol Array\n"
"  module: Module Core\n"
"  names: empty SimpleVector\n"
"  wrapper: UnionAll\n"
"    var: TypeVar\n"
"      name: Symbol T\n"
"      lb: Core.TypeofBottom Union{}\n"
"      ub: Any\n"
"    body: UnionAll\n"
"      var: TypeVar\n"
"        name: Symbol N\n"
"        lb: Core.TypeofBottom Union{}\n"
"        ub: Any\n"
"      body: Array{T,N} <: DenseArray{T,N}\n"
"  cache: SimpleVector\n"
"    ...\n"
"\n"
"  linearcache: SimpleVector\n"
"    ...\n"
"\n"
"  hash: Int64 -7900426068641098781\n"
"  mt: MethodTable\n"
"    name: Symbol Array\n"
"    defs: Nothing nothing\n"
"    cache: Nothing nothing\n"
"    max_args: Int64 0\n"
"    kwsorter: #undef\n"
"    module: Module Core\n"
"    : Int64 0\n"
"    : Int64 0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:209
msgid "In this case, the relevant field is `wrapper`, which holds a reference to the top-level type used to make new `Array` types."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:210
#, no-wrap
msgid ""
"julia> pointer_from_objref(Array)\n"
"Ptr{Cvoid} @0x00007fcc7de64850\n"
"\n"
"julia> pointer_from_objref(Array.body.body.name.wrapper)\n"
"Ptr{Cvoid} @0x00007fcc7de64850\n"
"\n"
"julia> pointer_from_objref(Array{TV,NV})\n"
"Ptr{Cvoid} @0x00007fcc80c4d930\n"
"\n"
"julia> pointer_from_objref(Array{TV,NV}.name.wrapper)\n"
"Ptr{Cvoid} @0x00007fcc7de64850\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:226
msgid "The `wrapper` field of [`Array`](@ref) points to itself, but for `Array{TV,NV}` it points back to the original definition of the type."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:230
msgid ""
"What about the other fields? `hash` assigns an integer to each type.  To examine the `cache` field, it's helpful to pick a type that is less "
"heavily used than Array. Let's first create our own type:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:231
#, no-wrap
msgid ""
"julia> struct MyType{T,N} end\n"
"\n"
"julia> MyType{Int,2}\n"
"MyType{Int64,2}\n"
"\n"
"julia> MyType{Float32, 5}\n"
"MyType{Float32,5}\n"
"\n"
"julia> MyType.body.body.name.cache\n"
"svec(MyType{Int64,2}, MyType{Float32,5}, #undef, #undef, #undef, #undef, #undef, #undef)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:247
msgid ""
"(The cache is pre-allocated to have length 8, but only the first two entries are populated.) Consequently, when you instantiate a parametric "
"type, each concrete type gets saved in a type cache.  However, instances containing free type variables are not cached."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/types.md:248
#, no-wrap
msgid "Tuple types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:252
msgid ""
"Tuple types constitute an interesting special case.  For dispatch to work on declarations like `x::Tuple`, the type has to be able to "
"accommodate any tuple.  Let's check the parameters:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:253
#, no-wrap
msgid ""
"julia> Tuple\n"
"Tuple\n"
"\n"
"julia> Tuple.parameters\n"
"svec(Vararg{Any,N} where N)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:263
msgid "Unlike other types, tuple types are covariant in their parameters, so this definition permits `Tuple` to match any type of tuple:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:264
#, no-wrap
msgid ""
"julia> typeintersect(Tuple, Tuple{Int,Float64})\n"
"Tuple{Int64,Float64}\n"
"\n"
"julia> typeintersect(Tuple{Vararg{Any}}, Tuple{Int,Float64})\n"
"Tuple{Int64,Float64}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:274
msgid "However, if a variadic (`Vararg`) tuple type has free variables it can describe different kinds of tuples:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:275
#, no-wrap
msgid ""
"julia> typeintersect(Tuple{Vararg{T} where T}, Tuple{Int,Float64})\n"
"Tuple{Int64,Float64}\n"
"\n"
"julia> typeintersect(Tuple{Vararg{T}} where T, Tuple{Int,Float64})\n"
"Union{}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:286
msgid ""
"Notice that when `T` is free with respect to the `Tuple` type (i.e. its binding `UnionAll` type is outside the `Tuple` type), only one `T` "
"value must work over the whole type.  Therefore a heterogeneous tuple does not match."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:288
msgid "Finally, it's worth noting that `Tuple{}` is distinct:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:289
#, no-wrap
msgid ""
"julia> Tuple{}\n"
"Tuple{}\n"
"\n"
"julia> Tuple{}.parameters\n"
"svec()\n"
"\n"
"julia> typeintersect(Tuple{}, Tuple{Int})\n"
"Union{}\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:301
msgid "What is the \"primary\" tuple-type?"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:302
#, no-wrap
msgid ""
"julia> pointer_from_objref(Tuple)\n"
"Ptr{Cvoid} @0x00007f5998a04370\n"
"\n"
"julia> pointer_from_objref(Tuple{})\n"
"Ptr{Cvoid} @0x00007f5998a570d0\n"
"\n"
"julia> pointer_from_objref(Tuple.name.wrapper)\n"
"Ptr{Cvoid} @0x00007f5998a04370\n"
"\n"
"julia> pointer_from_objref(Tuple{}.name.wrapper)\n"
"Ptr{Cvoid} @0x00007f5998a04370\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:317
msgid "so `Tuple == Tuple{Vararg{Any}}` is indeed the primary type."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/types.md:318
#, no-wrap
msgid "Diagonal types"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:322
msgid "Consider the type `Tuple{T,T} where T`.  A method with this signature would look like:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:323
#, no-wrap
msgid "f(x::T, y::T) where {T} = ...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:330
msgid ""
"According to the usual interpretation of a `UnionAll` type, this `T` ranges over all types, including `Any`, so this type should be "
"equivalent to `Tuple{Any,Any}`.  However, this interpretation causes some practical problems."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:337
msgid ""
"First, a value of `T` needs to be available inside the method definition.  For a call like `f(1, 1.0)`, it's not clear what `T` should be.  "
"It could be `Union{Int,Float64}`, or perhaps [`Real`](@ref).  Intuitively, we expect the declaration `x::T` to mean `T === typeof(x)`.  To "
"make sure that invariant holds, we need `typeof(x) === typeof(y) === T` in this method.  That implies the method should only be called for "
"arguments of the exact same type."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:347
msgid ""
"It turns out that being able to dispatch on whether two values have the same type is very useful (this is used by the promotion system for "
"example), so we have multiple reasons to want a different interpretation of `Tuple{T,T} where T`.  To make this work we add the following "
"rule to subtyping: if a variable occurs more than once in covariant position, it is restricted to ranging over only concrete types.  "
"(\"Covariant position\" means that only `Tuple` and `Union` types occur between an occurrence of a variable and the `UnionAll` type that "
"introduces it.)  Such variables are called \"diagonal variables\" or \"concrete variables\"."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:359
#, no-wrap
msgid ""
"So for example, `Tuple{T,T} where T` can be seen as\n"
"`Union{Tuple{Int8,Int8}, Tuple{Int16,Int16}, ...}`, where `T` ranges over all\n"
"concrete types.\n"
"This gives rise to some interesting subtyping results.\n"
"For example `Tuple{Real,Real}` is not a subtype of `Tuple{T,T} where T`, because\n"
"it includes some types like `Tuple{Int8,Int16}` where the two elements have\n"
"different types.\n"
"`Tuple{Real,Real}` and `Tuple{T,T} where T` have the non-trivial intersection\n"
"`Tuple{T,T} where T<:Real`.\n"
"However, `Tuple{Real}` *is* a subtype of `Tuple{T} where T`, because in that case\n"
"`T` occurs only once and so is not diagonal.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:361
msgid "Next consider a signature like the following:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:362
#, no-wrap
msgid "f(a::Array{T}, x::T, y::T) where {T} = ...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:375
msgid ""
"In this case, `T` occurs in invariant position inside `Array{T}`.  That means whatever type of array is passed unambiguously determines the "
"value of `T` -- we say `T` has an *equality constraint* on it.  Therefore in this case the diagonal rule is not really necessary, since the "
"array determines `T` and we can then allow `x` and `y` to be of any subtypes of `T`.  So variables that occur in invariant position are "
"never considered diagonal.  This choice of behavior is slightly controversial --- some feel this definition should be written as"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:376
#, no-wrap
msgid "f(a::Array{T}, x::S, y::S) where {T, S<:T} = ...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:383
msgid ""
"to clarify whether `x` and `y` need to have the same type.  In this version of the signature they would, or we could introduce a third "
"variable for the type of `y` if `x` and `y` can have different types."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:385
msgid "The next complication is the interaction of unions and diagonal variables, e.g."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:386
#, no-wrap
msgid "f(x::Union{Nothing,T}, y::T) where {T} = ...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:393
msgid ""
"Consider what this declaration means.  `y` has type `T`. `x` then can have either the same type `T`, or else be of type [`Nothing`](@ref).  "
"So all of the following calls should match:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:394
#, no-wrap
msgid ""
"f(1, 1)\n"
"f(\"\", \"\")\n"
"f(2.0, 2.0)\n"
"f(nothing, 1)\n"
"f(nothing, \"\")\n"
"f(nothing, 2.0)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:412
msgid ""
"These examples are telling us something: when `x` is `nothing::Nothing`, there are no extra constraints on `y`.  It is as if the method "
"signature had `y::Any`.  This means that whether a variable is diagonal is not a static property based on where it appears in a type.  "
"Rather, it depends on where a variable appears when the subtyping algorithm *uses* it.  When `x` has type `Nothing`, we don't need to use "
"the `T` in `Union{Nothing,T}`, so `T` does not \"occur\".  Indeed, we have the following type equivalence:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:413
#, no-wrap
msgid "(Tuple{Union{Nothing,T},T} where T) == Union{Tuple{Nothing,Any}, Tuple{T,T} where T}\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/types.md:417
#, no-wrap
msgid "Subtyping diagonal variables"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:422
msgid ""
"The subtyping algorithm for diagonal variables has two components: (1) identifying variable occurrences, and (2) ensuring that diagonal "
"variables range over concrete types only."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:427
#, no-wrap
msgid ""
"The first task is accomplished by keeping counters `occurs_inv` and `occurs_cov`\n"
"(in `src/subtype.c`) for each variable in the environment, tracking the number\n"
"of invariant and covariant occurrences, respectively.\n"
"A variable is diagonal when `occurs_inv == 0 && occurs_cov > 1`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:439
msgid ""
"The second task is accomplished by imposing a condition on a variable's lower bound.  As the subtyping algorithm runs, it narrows the bounds "
"of each variable (raising lower bounds and lowering upper bounds) to keep track of the range of variable values for which the subtype "
"relation would hold.  When we are done evaluating the body of a `UnionAll` type whose variable is diagonal, we look at the final values of "
"the bounds.  Since the variable must be concrete, a contradiction occurs if its lower bound could not be a subtype of a concrete type.  For "
"example, an abstract type like [`AbstractArray`](@ref) cannot be a subtype of a concrete type, but a concrete type like `Int` can be, and "
"the empty type `Bottom` can be as well.  If a lower bound fails this test the algorithm stops with the answer `false`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:443
#, no-wrap
msgid ""
"For example, in the problem `Tuple{Int,String} <: Tuple{T,T} where T`, we derive that\n"
"this would be true if `T` were a supertype of `Union{Int,String}`.\n"
"However, `Union{Int,String}` is an abstract type, so the relation does not hold.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:453
msgid ""
"This concreteness test is done by the function `is_leaf_bound`.  Note that this test is slightly different from `jl_is_leaf_type`, since it "
"also returns `true` for `Bottom`.  Currently this function is heuristic, and does not catch all possible concrete types.  The difficulty is "
"that whether a lower bound is concrete might depend on the values of other type variable bounds.  For example, `Vector{T}` is equivalent to "
"the concrete type `Vector{Int}` only if both the upper and lower bounds of `T` equal `Int`.  We have not yet worked out a complete algorithm "
"for this."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/types.md:454
#, no-wrap
msgid "Introduction to the internal machinery"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:460
msgid ""
"Most operations for dealing with types are found in the files `jltypes.c` and `subtype.c`.  A good way to start is to watch subtyping in "
"action.  Build Julia with `make debug` and fire up Julia within a debugger.  [gdb debugging tips](@ref) has some tips which may be useful."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:463
msgid ""
"Because the subtyping code is used heavily in the REPL itself--and hence breakpoints in this code get triggered often--it will be easiest if "
"you make the following definition:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:464
#, no-wrap
msgid ""
"julia> function mysubtype(a,b)\n"
"           ccall(:jl_breakpoint, Cvoid, (Any,), nothing)\n"
"           a <: b\n"
"       end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:473
msgid "and then set a breakpoint in `jl_breakpoint`.  Once this breakpoint gets triggered, you can set breakpoints in other functions."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:475
msgid "As a warm-up, try the following:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:476
#, no-wrap
msgid "mysubtype(Tuple{Int,Float64}, Tuple{Integer,Real})\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:481
msgid "We can make it more interesting by trying a more complex case:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:482
#, no-wrap
msgid "mysubtype(Tuple{Array{Int,2}, Int8}, Tuple{Array{T}, T} where T)\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/types.md:486
#, no-wrap
msgid "Subtyping and method sorting"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:491
msgid ""
"The `type_morespecific` functions are used for imposing a partial order on functions in method tables (from most-to-least specific). "
"Specificity is strict; if `a` is more specific than `b`, then `a` does not equal `b` and `b` is not more specific than `a`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:500
msgid ""
"If `a` is a strict subtype of `b`, then it is automatically considered more specific.  From there, `type_morespecific` employs some less "
"formal rules.  For example, `subtype` is sensitive to the number of arguments, but `type_morespecific` may not be.  In particular, "
"`Tuple{Int,AbstractFloat}` is more specific than `Tuple{Integer}`, even though it is not a subtype.  (Of `Tuple{Int,AbstractFloat}` and "
"`Tuple{Integer,Float64}`, neither is more specific than the other.)  Likewise, `Tuple{Int,Vararg{Int}}` is not a subtype of `Tuple{Integer}"
"`, but it is considered more specific. However, `morespecific` does get a bonus for length: in particular, `Tuple{Int,Int}` is more specific "
"than `Tuple{Int,Vararg{Int}}`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:502
msgid "If you're debugging how methods get sorted, it can be convenient to define the function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:503
#, no-wrap
msgid "type_morespecific(a, b) = ccall(:jl_type_morespecific, Cint, (Any,Any), a, b)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/types.md:507
msgid "which allows you to test whether tuple type `a` is more specific than tuple type `b`."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/meta.md:1
#, no-wrap
msgid "Talking to the compiler (the `:meta` mechanism)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/meta.md:8
msgid ""
"In some circumstances, one might wish to provide hints or instructions that a given block of code has special properties: you might always "
"want to inline it, or you might want to turn on special compiler optimization passes.  Starting with version 0.4, Julia has a convention "
"that these instructions can be placed inside a `:meta` expression, which is typically (but not necessarily) the first expression in the body "
"of a function."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/meta.md:11
msgid "`:meta` expressions are created with macros. As an example, consider the implementation of the `@inline` macro:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/meta.md:12
#, no-wrap
msgid ""
"macro inline(ex)\n"
"    esc(isa(ex, Expr) ? pushmeta!(ex, :inline) : ex)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/meta.md:19
msgid "Here, `ex` is expected to be an expression defining a function. A statement like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/meta.md:20
#, no-wrap
msgid ""
"@inline function myfunction(x)\n"
"    x*(x+3)\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/meta.md:27
msgid "gets turned into an expression like this:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/meta.md:28
#, no-wrap
msgid ""
"quote\n"
"    function myfunction(x)\n"
"        Expr(:meta, :inline)\n"
"        x*(x+3)\n"
"    end\n"
"end\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/meta.md:40
msgid ""
"`Base.pushmeta!(ex, :symbol, args...)` appends `:symbol` to the end of the `:meta` expression, creating a new `:meta` expression if "
"necessary. If `args` is specified, a nested expression containing `:symbol` and these arguments is appended instead, which can be used to "
"specify additional information."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/meta.md:47
msgid ""
"To use the metadata, you have to parse these `:meta` expressions. If your implementation can be performed within Julia, `Base.popmeta!` is "
"very handy: `Base.popmeta!(body, :symbol)` will scan a function *body* expression (one without the function signature) for the first `:meta` "
"expression containing `:symbol`, extract any arguments, and return a tuple `(found::Bool, args::Array{Any})`.  If the metadata did not have "
"any arguments, or `:symbol` was not found, the `args` array will be empty."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/meta.md:48
msgid "Not yet provided is a convenient infrastructure for parsing `:meta` expressions from C++."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/object.md:1
#, no-wrap
msgid "Memory layout of Julia Objects"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/object.md:3
#, no-wrap
msgid "Object layout (`jl_value_t`)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:8
msgid ""
"The `jl_value_t` struct is the name for a block of memory owned by the Julia Garbage Collector, representing the data associated with a "
"Julia object in memory. Absent any type information, it is simply an opaque pointer:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:9
#, no-wrap
msgid "typedef struct jl_value_t* jl_pvalue_t;\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:15
msgid ""
"Each `jl_value_t` struct is contained in a `jl_typetag_t` struct that contains metadata information about the Julia object, such as its type "
"and garbage collector (gc) reachability:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:16
#, no-wrap
msgid ""
"typedef struct {\n"
"    opaque metadata;\n"
"    jl_value_t value;\n"
"} jl_typetag_t;\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:25
msgid "The type of any Julia object is an instance of a leaf `jl_datatype_t` object. The `jl_typeof()` function can be used to query for it:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:26
#, no-wrap
msgid "jl_value_t *jl_typeof(jl_value_t *v);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:32
msgid ""
"The layout of the object depends on its type. Reflection methods can be used to inspect that layout.  A field can be accessed by calling one "
"of the get-field methods:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:33
#, no-wrap
msgid ""
"jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);\n"
"jl_value_t *jl_get_field(jl_value_t *o, char *fld);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:40
msgid "If the field types are known, a priori, to be all pointers, the values can also be extracted directly as an array access:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:41
#, no-wrap
msgid "jl_value_t *v = value->fieldptr[n];\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:46
msgid "As an example, a \"boxed\" `uint16_t` is stored as follows:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:47
#, no-wrap
msgid ""
"struct {\n"
"    opaque metadata;\n"
"    struct {\n"
"        uint16_t data;        // -- 2 bytes\n"
"    } jl_value_t;\n"
"};\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:58
msgid ""
"This object is created by `jl_box_uint16()`. Note that the `jl_value_t` pointer references the data portion, not the metadata at the top of "
"the struct."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:63
msgid ""
"A value may be stored \"unboxed\" in many circumstances (just the data, without the metadata, and possibly not even stored but just kept in "
"registers), so it is unsafe to assume that the address of a box is a unique identifier. The \"egal\" test (corresponding to the `===` "
"function in Julia), should instead be used to compare two unknown objects for equivalence:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:64
#, no-wrap
msgid "int jl_egal(jl_value_t *a, jl_value_t *b);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:70
msgid ""
"This optimization should be relatively transparent to the API, since the object will be \"boxed\" on-demand, whenever a `jl_value_t` pointer "
"is needed."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:74
msgid ""
"Note that modification of a `jl_value_t` pointer in memory is permitted only if the object is mutable. Otherwise, modification of the value "
"may corrupt the program and the result will be undefined.  The mutability property of a value can be queried for with:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:75
#, no-wrap
msgid "int jl_is_mutable(jl_value_t *v);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:80
msgid "If the object being stored is a `jl_value_t`, the Julia garbage collector must be notified also:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:81
#, no-wrap
msgid "void jl_gc_wb(jl_value_t *parent, jl_value_t *ptr);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:87
msgid ""
"However, the [Embedding Julia](@ref) section of the manual is also required reading at this point, for covering other details of boxing and "
"unboxing various types, and understanding the gc interactions."
msgstr ""
"ãã ããããã¥ã¢ã«ã® [Julia ã®åãè¾¼ã¿](@ref embedding-julia)ã»ã¯ã·ã§ã³ã¯ããã®æç¹ã§èª­ãã§ç½®ãã¹ãã§ããæ§ããªåã®boxing/unboxing ã®è©³ç´°ãã"
"gc ã®ç¸äºä½ç¨ãªã©ã®ãããã¯ãã«ãã¼ã§ããã§ãããã"

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:90
msgid ""
"Mirror structs for some of the built-in types are [defined in `julia.h`](https://github.com/JuliaLang/julia/blob/master/src/julia.h).  The "
"corresponding global `jl_datatype_t` objects are created by [`jl_init_types` in `jltypes.c`](https://github.com/JuliaLang/julia/blob/master/"
"src/jltypes.c)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/object.md:91
#, no-wrap
msgid "Garbage collector mark bits"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:96
msgid ""
"The garbage collector uses several bits from the metadata portion of the `jl_typetag_t` to track each object in the system. Further details "
"about this algorithm can be found in the comments of the [garbage collector implementation in `gc.c`](https://github.com/JuliaLang/julia/"
"blob/master/src/gc.c)."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/object.md:97
#, no-wrap
msgid "Object allocation"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:100
msgid "Most new objects are allocated by `jl_new_structv()`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:101
#, no-wrap
msgid ""
"jl_value_t *jl_new_struct(jl_datatype_t *type, ...);\n"
"jl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:107
msgid "Although, [`isbits`](@ref) objects can be also constructed directly from memory:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:108
#, no-wrap
msgid "jl_value_t *jl_new_bits(jl_value_t *bt, void *data)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:113
msgid "And some objects have special constructors that must be used instead of the above functions:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:115
msgid "Types:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:116
#, no-wrap
msgid ""
"jl_datatype_t *jl_apply_type(jl_datatype_t *tc, jl_tuple_t *params);\n"
"jl_datatype_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:125
msgid ""
"While these are the most commonly used options, there are more low-level constructors too, which you can find declared in [`julia.h`]"
"(https://github.com/JuliaLang/julia/blob/master/src/julia.h).  These are used in `jl_init_types()` to create the initial types needed to "
"bootstrap the creation of the Julia system image."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:127
msgid "Tuples:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:128
#, no-wrap
msgid ""
"jl_tuple_t *jl_tuple(size_t n, ...);\n"
"jl_tuple_t *jl_tuplev(size_t n, jl_value_t **v);\n"
"jl_tuple_t *jl_alloc_tuple(size_t n);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:137
msgid ""
"The representation of tuples is highly unique in the Julia object representation ecosystem. In some cases, a [`Base.tuple()`](@ref) object "
"may be an array of pointers to the objects contained by the tuple equivalent to:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:138
#, no-wrap
msgid ""
"typedef struct {\n"
"    size_t length;\n"
"    jl_value_t *data[length];\n"
"} jl_tuple_t;\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:148
msgid ""
"However, in other cases, the tuple may be converted to an anonymous [`isbits`](@ref) type and stored unboxed, or it may not stored at all "
"(if it is not being used in a generic context as a `jl_value_t*`)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:150
msgid "Symbols:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:151
#, no-wrap
msgid "jl_sym_t *jl_symbol(const char *str);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:156
msgid "Functions and MethodInstance:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:157
#, no-wrap
msgid ""
"jl_function_t *jl_new_generic_function(jl_sym_t *name);\n"
"jl_method_instance_t *jl_new_method_instance(jl_value_t *ast, jl_tuple_t *sparams);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:163
msgid "Arrays:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:164
#, no-wrap
msgid ""
"jl_array_t *jl_new_array(jl_value_t *atype, jl_tuple_t *dims);\n"
"jl_array_t *jl_new_arrayv(jl_value_t *atype, ...);\n"
"jl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);\n"
"jl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr, size_t nc);\n"
"jl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr, size_t nc, size_t z);\n"
"jl_array_t *jl_alloc_vec_any(size_t n);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:176
msgid ""
"Note that many of these have alternative allocation functions for various special-purposes. The list here reflects the more common usages, "
"but a more complete list can be found by reading the [`julia.h` header file](https://github.com/JuliaLang/julia/blob/master/src/julia.h)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:179
msgid "Internal to Julia, storage is typically allocated by `newstruct()` (or `newobj()` for the special types):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:180
#, no-wrap
msgid ""
"jl_value_t *newstruct(jl_value_t *type);\n"
"jl_value_t *newobj(jl_value_t *type, size_t nfields);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:187
msgid "And at the lowest level, memory is getting allocated by a call to the garbage collector (in `gc.c`), then tagged with its type:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:188
#, no-wrap
msgid ""
"jl_value_t *jl_gc_allocobj(size_t nbytes);\n"
"void jl_set_typeof(jl_value_t *v, jl_datatype_t *type);\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:196
msgid ""
"Note that all objects are allocated in multiples of 4 bytes and aligned to the platform pointer size. Memory is allocated from a pool for "
"smaller objects, or directly with `malloc()` for large objects."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:200
#, no-wrap
msgid ""
"!!! sidebar \"Singleton Types\"\n"
"    Singleton types have only one instance and no data fields. Singleton instances have a size of\n"
"    0 bytes, and consist only of their metadata. e.g. `nothing::Nothing`.\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/object.md:202
#, no-wrap
msgid "    See [Singleton Types](@ref man-singleton-types) and [Nothingness and missing values](@ref)\n"
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/debuggingtips.md:1
#, no-wrap
msgid "gdb debugging tips"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/debuggingtips.md:3
#, no-wrap
msgid "Displaying Julia variables"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:6
msgid "Within `gdb`, any `jl_value_t*` object `obj` can be displayed using"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:7
#, no-wrap
msgid "(gdb) call jl_(obj)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:13
msgid ""
"The object will be displayed in the `julia` session, not in the gdb session. This is a useful way to discover the types and values of "
"objects being manipulated by Julia's C code."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:16
msgid "Similarly, if you're debugging some of Julia's internals (e.g., `compiler.jl`), you can print `obj` using"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:17
#, no-wrap
msgid "ccall(:jl_, Cvoid, (Any,), obj)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:23
msgid "This is a good way to circumvent problems that arise from the order in which julia's output streams are initialized."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:25
msgid "Julia's flisp interpreter uses `value_t` objects; these can be displayed with `call fl_print(fl_ctx, ios_stdout, obj)`."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/debuggingtips.md:26
#, no-wrap
msgid "Useful Julia variables for Inspecting"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:31
msgid ""
"While the addresses of many variables, like singletons, can be be useful to print for many failures, there are a number of additional "
"variables (see `julia.h` for a complete list) that are even more useful."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/debuggingtips.md:41
msgid "(when in `jl_apply_generic`) `mfunc` and `jl_uncompress_ast(mfunc->def, mfunc->code)` :: for figuring out a bit about the call-stack"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/debuggingtips.md:41
msgid ""
"`jl_lineno` and `jl_filename` :: for figuring out what line in a test to go start debugging from (or figure out how far into a file has been "
"parsed)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/debuggingtips.md:41
msgid "`$1` :: not really a variable, but still a useful shorthand for referring to the result of the last gdb command (such as `print`)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/debuggingtips.md:41
msgid "`jl_options` :: sometimes useful, since it lists all of the command line options that were successfully parsed"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/debuggingtips.md:41
msgid "`jl_uv_stderr` :: because who doesn't like to be able to interact with stdio"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/debuggingtips.md:42
#, no-wrap
msgid "Useful Julia functions for Inspecting those variables"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/debuggingtips.md:55
msgid "`jl_gdblookup($rip)` :: For looking up the current function and line. (use `$eip` on i686 platforms)"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/debuggingtips.md:55
msgid "`jlbacktrace()` :: For dumping the current Julia backtrace stack to stderr. Only usable after `record_backtrace()` has been called."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/debuggingtips.md:55
msgid ""
"`jl_dump_llvm_value(Value*)` :: For invoking `Value->dump()` in gdb, where it doesn't work natively.  For example, `f->linfo-"
">functionObject`, `f->linfo->specFunctionObject`, and `to_function(f->linfo)`."
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/debuggingtips.md:55
msgid "`Type->dump()` :: only works in lldb. Note: add something like `;1` to prevent lldb from printing its prompt over the output"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/debuggingtips.md:55
msgid "`jl_eval_string(\"expr\")` :: for invoking side-effects to modify the current state or to lookup symbols"
msgstr ""

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/debuggingtips.md:55
msgid ""
"`jl_typeof(jl_value_t*)` :: for extracting the type tag of a Julia value (in gdb, call `macro define jl_typeof jl_typeof` first, or pick "
"something short like `ty` for the first arg to define a shorthand)"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/debuggingtips.md:56
#, no-wrap
msgid "Inserting breakpoints for inspection from gdb"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:59
msgid "In your `gdb` session, set a breakpoint in `jl_breakpoint` like so:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:60
#, no-wrap
msgid "(gdb) break jl_breakpoint\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:65
msgid "Then within your Julia code, insert a call to `jl_breakpoint` by adding"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:66
#, no-wrap
msgid "ccall(:jl_breakpoint, Cvoid, (Any,), obj)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:71
msgid "where `obj` can be any variable or tuple you want to be accessible in the breakpoint."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:74
msgid "It's particularly helpful to back up to the `jl_apply` frame, from which you can display the arguments to a function using, e.g.,"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:75
#, no-wrap
msgid "(gdb) call jl_(args[0])\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:83
msgid ""
"Another useful frame is `to_function(jl_method_instance_t *li, bool cstyle)`. The `jl_method_instance_t*` argument is a struct with a "
"reference to the final AST sent into the compiler. However, the AST at this point will usually be compressed; to view the AST, call "
"`jl_uncompress_ast` and then pass the result to `jl_`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:84
#, no-wrap
msgid ""
"#2  0x00007ffff7928bf7 in to_function (li=0x2812060, cstyle=false) at codegen.cpp:584\n"
"584          abort();\n"
"(gdb) p jl_(jl_uncompress_ast(li, li->ast))\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/debuggingtips.md:90
#, no-wrap
msgid "Inserting breakpoints upon certain conditions"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/debuggingtips.md:92
#, no-wrap
msgid "Loading a particular file"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:95
msgid "Let's say the file is `sysimg.jl`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:96
#, no-wrap
msgid "(gdb) break jl_load if strcmp(fname, \"sysimg.jl\")==0\n"
msgstr ""

#. type: Title ###
#: ext/julia/doc/src/devdocs/debuggingtips.md:100
#, no-wrap
msgid "Calling a particular method"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:102
#, no-wrap
msgid "(gdb) break jl_apply_generic if strcmp((char*)(jl_symbol_name)(jl_gf_mtable(F)->name), \"method_to_break\")==0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:107
msgid "Since this function is used for every call, you will make everything 1000x slower if you do this."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/debuggingtips.md:108
#, no-wrap
msgid "Dealing with signals"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:115
msgid ""
"Julia requires a few signal to function property. The profiler uses `SIGUSR2` for sampling and the garbage collector uses `SIGSEGV` for "
"threads synchronization. If you are debugging some code that uses the profiler or multiple threads, you may want to let the debugger ignore "
"these signals since they can be triggered very often during normal operations. The command to do this in GDB is (replace `SIGSEGV` with "
"`SIGUSRS` or other signals you want to ignore):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:116
#, no-wrap
msgid "(gdb) handle SIGSEGV noprint nostop pass\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:121
msgid "The corresponding LLDB command is (after the process is started):"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:122
#, no-wrap
msgid "(lldb) pro hand -p true -s false -n false SIGSEGV\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:129
msgid ""
"If you are debugging a segfault with threaded code, you can set a breakpoint on `jl_critical_error` (`sigdie_handler` should also work on "
"Linux and BSD) in order to only catch the actual segfault rather than the GC synchronization points."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/debuggingtips.md:130
#, no-wrap
msgid "Debugging during Julia's build process (bootstrap)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:134
msgid ""
"Errors that occur during `make` need special handling. Julia is built in two stages, constructing `sys0` and `sys.ji`. To see what commands "
"are running at the time of failure, use `make VERBOSE=1`."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:137
msgid "At the time of this writing, you can debug build errors during the `sys0` phase from the `base` directory using:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:138
#, no-wrap
msgid "julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys0 sysimg.jl\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:143
msgid "You might need to delete all the files in `usr/lib/julia/` to get this to work."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:145
msgid "You can debug the `sys.ji` phase using:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:146
#, no-wrap
msgid "julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys -J ../usr/lib/julia/sys0.ji sysimg.jl\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:153
msgid ""
"By default, any errors will cause Julia to exit, even under gdb. To catch an error \"in the act\", set a breakpoint in `jl_error` (there are "
"several other useful spots, for specific kinds of failures, including: `jl_too_few_args`, `jl_too_many_args`, and `jl_throw`)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:156
msgid ""
"Once an error is caught, a useful technique is to walk up the stack and examine the function by inspecting the related call to `jl_apply`. "
"To take a real-world example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:157
#, no-wrap
msgid ""
"Breakpoint 1, jl_throw (e=0x7ffdf42de400) at task.c:802\n"
"802 {\n"
"(gdb) p jl_(e)\n"
"ErrorException(\"auto_unbox: unable to determine argument type\")\n"
"$2 = void\n"
"(gdb) bt 10\n"
"#0  jl_throw (e=0x7ffdf42de400) at task.c:802\n"
"#1  0x00007ffff65412fe in jl_error (str=0x7ffde56be000 <_j_str267> \"auto_unbox:\n"
"   unable to determine argument type\")\n"
"   at builtins.c:39\n"
"#2  0x00007ffde56bd01a in julia_convert_16886 ()\n"
"#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281\n"
"...\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:177
msgid ""
"The most recent `jl_apply` is at frame #3, so we can go back there and look at the AST for the function `julia_convert_16886`. This is the "
"uniqued name for some method of `convert`. `f` in this frame is a `jl_function_t*`, so we can look at the type signature, if any, from the "
"`specTypes` field:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:178
#, no-wrap
msgid ""
"(gdb) f 3\n"
"#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281\n"
"1281            return f->fptr((jl_value_t*)f, args, nargs);\n"
"(gdb) p f->linfo->specTypes\n"
"$4 = (jl_tupletype_t *) 0x7ffdf39b1030\n"
"(gdb) p jl_( f->linfo->specTypes )\n"
"Tuple{Type{Float32}, Float64}           # <-- type signature for julia_convert_16886\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:189
msgid "Then, we can look at the AST for this function:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:190
#, no-wrap
msgid ""
"(gdb) p jl_( jl_uncompress_ast(f->linfo, f->linfo->ast) )\n"
"Expr(:lambda, Array{Any, 1}[:#s29, :x], Array{Any, 1}[Array{Any, 1}[], Array{Any, 1}[Array{Any, 1}[:#s29, :Any, 0], Array{Any, 1}[:x, :Any, 0]], Array{Any, 1}[], 0], Expr(:body,\n"
"Expr(:line, 90, :float.jl)::Any,\n"
"Expr(:return, Expr(:call, :box, :Float32, Expr(:call, :fptrunc, :Float32, :x)::Any)::Any)::Any)::Any)::Any\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:199
msgid ""
"Finally, and perhaps most usefully, we can force the function to be recompiled in order to step through the codegen process. To do this, "
"clear the cached `functionObject` from the `jl_lamdbda_info_t*`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:200
#, no-wrap
msgid ""
"(gdb) p f->linfo->functionObject\n"
"$8 = (void *) 0x1289d070\n"
"(gdb) set f->linfo->functionObject = NULL\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:208
msgid "Then, set a breakpoint somewhere useful (e.g. `emit_function`, `emit_expr`, `emit_call`, etc.), and run codegen:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:209
#, no-wrap
msgid ""
"(gdb) p jl_compile(f)\n"
"... # your breakpoint here\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/debuggingtips.md:214
#, no-wrap
msgid "Debugging precompilation errors"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:219
msgid ""
"Module precompilation spawns a separate Julia process to precompile each module. Setting a breakpoint or catching failures in a precompile "
"worker requires attaching a debugger to the worker. The easiest approach is to set the debugger watch for new process launches matching a "
"given name. For example:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:220
#, no-wrap
msgid "(gdb) attach -w -n julia-debug\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:225
msgid "or:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:226
#, no-wrap
msgid "(lldb) process attach -w -n julia-debug\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:234
msgid ""
"Then run a script/command to start precompilation. As described earlier, use conditional breakpoints in the parent process to catch specific "
"file-loading events and narrow the debugging window. (some operating systems may require alternative approaches, such as following each "
"`fork` from the parent process)"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/debuggingtips.md:235
#, no-wrap
msgid "Mozilla's Record and Replay Framework (rr)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:241
msgid ""
"Julia now works out of the box with [rr](http://rr-project.org/), the lightweight recording and deterministic debugging framework from "
"Mozilla. This allows you to replay the trace of an execution deterministically.  The replayed execution's address spaces, register contents, "
"syscall data etc are exactly the same in every run."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/debuggingtips.md:242
msgid "A recent version of rr (3.1.0 or higher) is required."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/backtraces.md:1
#, no-wrap
msgid "Reporting and analyzing crashes (segfaults)"
msgstr "ã¯ã©ãã·ã¥(ã»ã°ã¡ã³ãã¼ã·ã§ã³ãã©ã«ã)ã®å ±åã¨åæ"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:7
msgid ""
"So you managed to break Julia.  Congratulations! Collected here are some general procedures you can undergo for common symptoms encountered "
"when something goes awry.  Including the information from these debugging steps can greatly help the maintainers when tracking down a "
"segfault or trying to figure out why your script is running slower than expected."
msgstr ""
"Julia ãå£ãã?ããã§ã¨ããããã¾ã!  ä½ããããããã¨ãèµ·ããæã«ããé­éããçç¶ã«å¯¾ããä¸è¬çãªæé ãããã«éãã¾ãããã»ã°ã¡ã³ãã¼ã·ã§ã³"
"ãã©ã¼ã«ããè¿½è·¡ããããããªãã®ã¹ã¯ãªãããäºæ³ãããéãçç±ãçªãæ­¢ããéã«ã¯ãããã§è¿°ã¹ããããã°æé ããå¾ãããæå ±ãå«ãã¦å ±åãã"
"ã¨ãã¡ã³ããã¯å¤§ãã«å©ããã§ãããã"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:10
msgid ""
"If you've been directed to this page, find the symptom that best matches what you're experiencing and follow the instructions to generate "
"the debugging information requested.  Table of symptoms:"
msgstr ""
"ããããªããããã®ãã¼ã¸ãè¦ãããã«ãã¨è¨ãããã®ã§ããã°ãä»ç´é¢ãã¦ããåé¡ã«æãä¸è´ããç¾è±¡ãè¦ã¤ãã¦ããã®ãã¼ã¸ã«æ¸ãããæç¤ºã«å¾ã£"
"ã¦ãè¦æ±ããããããã°æå ±ãçæãã¦ãã ãããç¾è±¡ã®ä¸è¦§ã¯ä¸è¨ã®éãã§ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/backtraces.md:14
msgid "[Segfaults during bootstrap (`sysimg.jl`)](@ref)"
msgstr "[ãã¼ãã¹ãã©ãã(`sysimg.jl`)ä¸­ã®ã»ã°ã¡ã³ãã¼ã·ã§ã³ãã©ã«ã](@ref Segfaults-during-bootstrap-(sysimg.jl))"

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/backtraces.md:14
msgid "[Segfaults when running a script](@ref)"
msgstr "[ã¹ã¯ãªããã®å®è¡æã®ã»ã°ãã©ã¼ã«ã](@ref segfaults-when-running-a-script)"

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/backtraces.md:14
msgid "[Errors during Julia startup](@ref)"
msgstr "[Juliaèµ·åä¸­ã®ã¨ã©ã¼](@ref errors-during-julia-startup)"

#. type: Title ##
#: ext/julia/doc/src/devdocs/backtraces.md:15
#, no-wrap
msgid "[Version/Environment info](@id dev-version-info)"
msgstr "[ãã¼ã¸ã§ã³æå ±/ç°å¢æå ±](@id dev-version-info)"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:19
msgid ""
"No matter the error, we will always need to know what version of Julia you are running. When Julia first starts up, a header is printed out "
"with a version number and date. Please also include the output of `versioninfo()` (exported from the [`InteractiveUtils`](@ref "
"InteractiveUtils.versioninfo) standard library) in any report you create:"
msgstr ""
"ã¨ã©ã¼ã®åå®¹ã«é¢ä¿ãªããå¸¸ã«ãå®è¡ãã¦ããJulia ã®ãã¼ã¸ã§ã³ãç¥ãå¿è¦ãããã¾ããJulia ãæåã«èµ·åããã¨ããããã¼ã«ãã¼ã¸ã§ã³çªå·ã¨æ¥ä»ã"
"åºåããã¾ããã¾ããä½æããã¬ãã¼ãã«ã¯ã`versioninfo()`([`InteractiveUtils`](@ref InteractiveUtils.versioninfo) æ¨æºã©ã¤ãã©ãªããã¨ã¯ã¹"
"ãã¼ãããã¦ãã¾ã) ã®åºåãå«ãã¦ãã ãã:"

#. type: Code fence info string
#: ext/julia/doc/src/devdocs/backtraces.md:20
#, no-wrap
msgid "@repl"
msgstr "@repl"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:20
#, no-wrap
msgid ""
"using InteractiveUtils\n"
"versioninfo()\n"
msgstr ""
"using InteractiveUtils\n"
"versioninfo()\n"

#. type: Title ##
#: ext/julia/doc/src/devdocs/backtraces.md:25
#, no-wrap
msgid "Segfaults during bootstrap (`sysimg.jl`)"
msgstr "[ãã¼ãã¹ãã©ãã(`sysimg.jl`)ä¸­ã®ã»ã°ã¡ã³ãã¼ã·ã§ã³ãã©ã«ã](@id Segfaults-during-bootstrap-(sysimg.jl))"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:32
msgid ""
"Segfaults toward the end of the `make` process of building Julia are a common symptom of something going wrong while Julia is preparsing the "
"corpus of code in the `base/` folder.  Many factors can contribute toward this process dying unexpectedly, however it is as often as not due "
"to an error in the C-code portion of Julia, and as such must typically be debugged with a debug build inside of `gdb`.  Explicitly:"
msgstr ""
"Julia ããã«ããã `make` ãã­ã»ã¹ã®çµç¤ã§ã®ã»ã°ã¡ã³ãã¼ã·ã§ã³ãã©ã¼ã«ãã¯ãä¸è¬çãªçç¶ã§ããJulia ã`base/`ãã©ã«ãåã®ã³ã¼ãã®ã³ã¼ãã¹ãäº"
"åè§£æãã¦ããéã«ä½ãããããããã¨ãèµ·ããããã¾ãã ãã­ã»ã¹ãçªç¶è½ã¡ã¦ãã¾ãåå ã«ã¯ãå¤ãã®è¦å ãèãããã¾ãããã©ã¡ããã¨ããã¨ã"
"Julia ã® C ã³ã¼ãé¨åã®ã¨ã©ã¼ãåå ã§ãããã¨ãå¤ããéå¸¸ã¯ `gdb` ã®ãããã°ãã«ãã§ãããã°ããªããã°ãªããªããã¨ãå¤ãã§ãããããã°ãã«ã"
"ãä½ãã«ã¯æç¤ºçã«ï¼"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:34
msgid "Create a debug build of Julia:"
msgstr "Julia ã®ãããã°ãã«ããä½æãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:35
#, no-wrap
msgid ""
"$ cd <julia_root>\n"
"$ make debug\n"
msgstr ""
"$ cd <julia_root>\n"
"$ make debug\n"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:43
msgid ""
"Note that this process will likely fail with the same error as a normal `make` incantation, however this will create a debug executable that "
"will offer `gdb` the debugging symbols needed to get accurate backtraces.  Next, manually run the bootstrap process inside of `gdb`:"
msgstr ""
"ãã®ãããã°ãã«ãã®ãã­ã»ã¹ã¯ãéå¸¸ã®`make` ã¨åãã¨ã©ã¼ã§å¤±æããå¯è½æ§ãããã¾ããã(ãããªããªããã°) æ­£ç¢ºãªããã¯ãã¬ã¼ã¹ãããããã«å¿"
"è¦ãªãããã°ã·ã³ãã«ã `gdb`ã«æä¾ããããããã°ç¨å®è¡å¯è½ãã¡ã¤ã«ãä½æããã¾ãã æ¬¡ã«ã`gdb`åã§ãã¼ãã¹ãã©ãããã­ã»ã¹ãæåã§å®è¡ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:44
#, no-wrap
msgid ""
"$ cd base/\n"
"$ gdb -x ../contrib/debug_bootstrap.gdb\n"
msgstr ""
"$ cd base/\n"
"$ gdb -x ../contrib/debug_bootstrap.gdb\n"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:54
#, no-wrap
msgid ""
"This will start `gdb`, attempt to run the bootstrap process using the debug build of Julia, and\n"
"print out a backtrace if (when) it segfaults.  You may need to hit `<enter>` a few times to get\n"
"the full backtrace.  Create a [gist](https://gist.github.com) with the backtrace, the [version info](@ref dev-version-info),\n"
"and any other pertinent information you can think of and open a new [issue](https://github.com/JuliaLang/julia/issues?q=is%3Aopen)\n"
"on Github with a link to the gist.\n"
msgstr "ãã®ã³ãã³ãã§ã`gdb`ãéå§ããJulia ã®ãããã°ãã«ããä½¿ç¨ãããã¼ãã¹ãã©ãããã­ã»ã¹ãå®è¡ãããã¨ããããã»ã°ã¡ã³ãã¼ã·ã§ã³ãã©ã«ããèµ·ããã°ãããã¯ãã¼ã¬ã¹ã®çµæãåºåãã¾ããå¨ã¦ã®åºåãå¾ãã«ã¯ããªãã©ã `<enter>`ã­ã¼ãæ¼ãå¿è¦ãããããããã¾ããããããã¦å¾ãããããã¯ãã¬ã¼ã¹ã¨ããã¼ã¸ã§ã³æå ±ããã®ä»é¢é£æå ±ãã¾ã¨ãã gist ãä½æãã¦ãGithub ã® issue ããªã¼ãã³ããä½æããgistã¸ã®ãªã³ã¯ãè²¼ã£ã¦ãã ããã\n"

#. type: Title ##
#: ext/julia/doc/src/devdocs/backtraces.md:55
#, no-wrap
msgid "Segfaults when running a script"
msgstr "[ã¹ã¯ãªããã®å®è¡æã®ã»ã°ãã©ã¼ã«ã](@id segfaults-when-running-a-script)"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:59
msgid ""
"The procedure is very similar to [Segfaults during bootstrap (`sysimg.jl`)](@ref).  Create a debug build of Julia, and run your script "
"inside of a debugged Julia process:"
msgstr ""
"ãã®æé ã¯ã[ã¹ã¯ãªããã®å®è¡æã®ã»ã°ãã©ã¼ã«ã](@ref segfaults-when-running-a-script)ã«éå¸¸ã«ããä¼¼ã¦ãã¾ãã Julia ã®ãããã° ãã«ããä½æ"
"ãããããã°ããã Julia ãã­ã»ã¹åã§ã¹ã¯ãªãããå®è¡ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:60
#, no-wrap
msgid ""
"$ cd <julia_root>\n"
"$ make debug\n"
"$ gdb --args usr/bin/julia-debug <path_to_your_script>\n"
msgstr ""
"$ cd <julia_root>\n"
"$ make debug\n"
"$ gdb --args usr/bin/julia-debug <path_to_your_script>\n"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:68
msgid ""
"Note that `gdb` will sit there, waiting for instructions.  Type `r` to run the process, and `bt` to generate a backtrace once it segfaults:"
msgstr ""
"`gdb` ã¯èµ·åããã ãã§ã¯ä½ããã¾ããããã å½ä»¤ãå¾ã£ã¦ããç¶æã§ãã`r` ã¨æã£ã¦ããã­ã»ã¹ãå®è¡ãã¾ãã`bt`ã§ã»ã°ã¡ã³ãã¼ã·ã§ã³ãã©ã«ããçº"
"çããæã«ãããã¯ãã¬ã¼ã¹ãçæãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:69
#, no-wrap
msgid ""
"(gdb) r\n"
"Starting program: /home/sabae/src/julia/usr/bin/julia-debug ./test.jl\n"
"...\n"
"(gdb) bt\n"
msgstr ""
"(gdb) r\n"
"Starting program: /home/sabae/src/julia/usr/bin/julia-debug ./test.jl\n"
"...\n"
"(gdb) bt\n"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:79
msgid ""
"Create a [gist](https://gist.github.com) with the backtrace, the [version info](@ref dev-version-info), and any other pertinent information "
"you can think of and open a new [issue](https://github.com/JuliaLang/julia/issues?q=is%3Aopen)  on Github with a link to the gist."
msgstr ""
"å¾ãããããã¯ãã¼ã¬ã¹ã®åå®¹ã[ãã¼ã¸ã§ã³æå ±](@ref dev-version-info)ããã®ä»é¢é£æå ±ãã¾ã¨ãã¦ã[gist](https://gist.github.com) ãä½æãã¦ã"
"Github ã® [issue](https://github.com/JuliaLang/julia/issues?q=is%3Aopen) ããªã¼ãã³ãä½æããgistã¸ã®ãªã³ã¯ãè²¼ã£ã¦ãã ããã"

#. type: Title ##
#: ext/julia/doc/src/devdocs/backtraces.md:80
#, no-wrap
msgid "Errors during Julia startup"
msgstr "[Juliaèµ·åä¸­ã®ã¨ã©ã¼](@id errors-during-julia-startup)"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:84
msgid ""
"Occasionally errors occur during Julia's startup process (especially when using binary distributions, as opposed to compiling from source) "
"such as the following:"
msgstr ""
"Julia ã®èµ·åä¸­ (ã½ã¼ã¹ããã³ã³ãã¤ã«ãããã®ã§ãªããç¹ã«ãã¤ããªéå¸ããã¦ãããã®å®è¡ããã¨ã)ã«æãã¨ã©ã¼ãèµ·ãã¾ããä¾ãã°ä¸è¨ã®æ§ãªãã®ã§"
"ã:"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:85
#, no-wrap
msgid ""
"$ julia\n"
"exec: error -5\n"
msgstr ""
"$ julia\n"
"exec: error -5\n"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:93
msgid ""
"These errors typically indicate something is not getting loaded properly very early on in the bootup phase, and our best bet in determining "
"what's going wrong is to use external tools to audit the disk activity of the `julia` process:"
msgstr ""
"ãã®ãããªã¨ã©ã¼ã®å¸åçãªåå ã¯ãJulia èµ·åã®ããããåææ®µéã§ãä½ããæ­£ããã­ã¼ãããã¦ããªããã¨ã ã£ãããã¾ããä½ãæªãããå¤æ­ããã®ã«"
"æããããããªã®ã¯ã`Julia` processããã£ã¹ã¯ã«ã©ãã¢ã¯ã»ã¹ãã¦ããããç£æ»ããå¤é¨ãã¼ã«ãä½¿ããã¨ã§ã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/backtraces.md:95
msgid "On Linux, use `strace`:"
msgstr "Linux ã§ã¯ `strace` ãä½¿ãã¾ã:"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:100
#, no-wrap
msgid ""
"    ```\n"
"    $ strace julia\n"
"    ```\n"
"  * On OSX, use `dtruss`:\n"
msgstr ""
"    ```\n"
"    $ strace julia\n"
"    ```\n"
"  * OSX(Mac)ã§ã¯ã`dtruss` ãä½¿ãã¾ã:\n"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:104
#, no-wrap
msgid ""
"    ```\n"
"    $ dtruss -f julia\n"
"    ```\n"
msgstr ""
"    ```\n"
"    $ dtruss -f julia\n"
"    ```\n"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:108
msgid ""
"Create a [gist](https://gist.github.com) with the `strace`/ `dtruss` output, the [version info](@ref dev-version-info), and any other "
"pertinent information and open a new [issue](https://github.com/JuliaLang/julia/issues?q=is%3Aopen)  on Github with a link to the gist."
msgstr ""
"`strace`/`dtruss`ã®åºåã[ãã¼ã¸ã§ã³æå ±](@ref dev-version-info)ããã®ä»é¢é£æå ±ãã¾ã¨ãã¦ã[gist](https://gist.github.com) ãä½æãã¦ã"
"Github ã® [issue](https://github.com/JuliaLang/julia/issues?q=is%3Aopen) ããªã¼ãã³ãä½æããgistã¸ã®ãªã³ã¯ãè²¼ã£ã¦ãã ããã"

#. type: Title ##
#: ext/julia/doc/src/devdocs/backtraces.md:109
#, no-wrap
msgid "Glossary"
msgstr "ç¨èªé"

#. type: Plain text
#: ext/julia/doc/src/devdocs/backtraces.md:112
msgid "A few terms have been used as shorthand in this guide:"
msgstr "ãã®ã¬ã¤ãã¨ãã¦ã¯ãããã¤ãã®ç¨èªãç­ç¸®è¨å·ã¨ãã¦ä½¿ããã¦ãã:"

#. type: Bullet: '  * '
#: ext/julia/doc/src/devdocs/backtraces.md:114
msgid ""
"`<julia_root>` refers to the root directory of the Julia source tree; e.g. it should contain folders such as `base`, `deps`, `src`, `test`, "
"etc....."
msgstr ""
"`<julia_root>` ã¯ãJulia ã®ã½ã¼ã¹ããªã¼ã®ã«ã¼ããã£ã¬ã¯ããªãæããã®ã§ã; ããªãã¡ã`base`, `deps`, `src`, `test`, ãªã©ã®ãã©ã«ãã¼ãå«ãã§"
"ããã¯ãã§ãã"

#. type: Title #
#: ext/julia/doc/src/devdocs/inference.md:1
#, no-wrap
msgid "Inference"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/inference.md:3
#, no-wrap
msgid "How inference works"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:11
msgid ""
"[Type inference](https://en.wikipedia.org/wiki/Type_inference) refers to the process of deducing the types of later values from the types of "
"input values. Julia's approach to inference has been described in blog posts ([1](https://juliacomputing.com/blog/2016/04/04/inference-"
"convergence.html), [2](https://juliacomputing.com/blog/2017/05/15/inference-converage2.html))."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/inference.md:12
#, no-wrap
msgid "Debugging compiler.jl"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:19
msgid ""
"You can start a Julia session, edit `compiler/*.jl` (for example to insert `print` statements), and then replace `Core.Compiler` in your "
"running session by navigating to `base/compiler` and executing `include(\"compiler.jl\")`. This trick typically leads to much faster "
"development than if you rebuild Julia for each change."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:22
msgid "A convenient entry point into inference is `typeinf_code`. Here's a demo running inference on `convert(Int, UInt(1))`:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:23
#, no-wrap
msgid ""
"# Get the method\n"
"atypes = Tuple{Type{Int}, UInt}  # argument types\n"
"mths = methods(convert, atypes)  # worth checking that there is only one\n"
"m = first(mths)\n"
"\n"
"# Create variables needed to call `typeinf_code`\n"
"params = Core.Compiler.Params(typemax(UInt))  # parameter is the world age,\n"
"                                                        #   typemax(UInt) -> most recent\n"
"sparams = Core.svec()      # this particular method doesn't have type-parameters\n"
"optimize = true            # run all inference optimizations\n"
"cached = false             # force inference to happen (do not use cached results)\n"
"Core.Compiler.typeinf_code(m, atypes, sparams, optimize, cached, params)\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:41
msgid ""
"If your debugging adventures require a `MethodInstance`, you can look it up by calling `Core.Compiler.specialize_method` using many of the "
"variables above.  A `CodeInfo` object may be obtained with"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:41
#, no-wrap
msgid ""
"# Returns the CodeInfo object for `convert(Int, ::UInt)`:\n"
"ci = (@code_typed convert(Int, UInt(1)))[1]\n"
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/inference.md:46
#, no-wrap
msgid "The inlining algorithm (inline_worthy)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:56
msgid ""
"Much of the hardest work for inlining runs in `inlining_pass`. However, if your question is \"why didn't my function inline?\" then you will "
"most likely be interested in `isinlineable` and its primary callee, `inline_worthy`. `isinlineable` handles a number of special cases (e.g., "
"critical functions like `next` and `done`, incorporating a bonus for functions that return tuples, etc.). The main decision-making happens "
"in `inline_worthy`, which returns `true` if the function should be inlined."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:71
msgid ""
"`inline_worthy` implements a cost-model, where \"cheap\" functions get inlined; more specifically, we inline functions if their anticipated "
"run-time is not large compared to the time it would take to [issue a call](https://en.wikipedia.org/wiki/Calling_convention) to them if they "
"were not inlined. The cost-model is extremely simple and ignores many important details: for example, all `for` loops are analyzed as if "
"they will be executed once, and the cost of an `if...else...end` includes the summed cost of all branches. It's also worth acknowledging "
"that we currently lack a suite of functions suitable for testing how well the cost model predicts the actual run-time cost, although "
"[BaseBenchmarks](https://github.com/JuliaCI/BaseBenchmarks.jl)  provides a great deal of indirect information about the successes and "
"failures of any modification to the inlining algorithm."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:80
msgid ""
"The foundation of the cost-model is a lookup table, implemented in `add_tfunc` and its callers, that assigns an estimated cost (measured in "
"CPU cycles) to each of Julia's intrinsic functions. These costs are based on [standard ranges for common architectures](http://ithare.com/wp-"
"content/uploads/part101_infographics_v08.png)  (see [Agner Fog's analysis](https://www.agner.org/optimize/instruction_tables.pdf)  for more "
"detail)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:91
msgid ""
"We supplement this low-level lookup table with a number of special cases. For example, an `:invoke` expression (a call for which all input "
"and output types were inferred in advance) is assigned a fixed cost (currently 20 cycles). In contrast, a `:call` expression, for functions "
"other than intrinsics/builtins, indicates that the call will require dynamic dispatch, in which case we assign a cost set by `Params."
"inline_nonleaf_penalty` (currently set at 1000). Note that this is not a \"first-principles\" estimate of the raw cost of dynamic dispatch, "
"but a mere heuristic indicating that dynamic dispatch is extremely expensive."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:95
msgid ""
"Each statement gets analyzed for its total cost in a function called `statement_cost`. You can run this yourself by following the sketch "
"below, where `f` is your function and `tt` is the Tuple-type of the arguments:"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:96
#, no-wrap
msgid ""
"# A demo on `fill(3.5, (2, 3))\n"
"f = fill\n"
"tt = Tuple{Float64, Tuple{Int,Int}}\n"
"# Create the objects we need to interact with the compiler\n"
"params = Core.Compiler.Params(typemax(UInt))\n"
"mi = Base.method_instances(f, tt)[1]\n"
"ci = code_typed(f, tt)[1][1]\n"
"opt = Core.Compiler.OptimizationState(mi, params)\n"
"# Calculate cost of each statement\n"
"cost(stmt::Expr) = Core.Compiler.statement_cost(stmt, -1, ci, opt.sptypes, opt.slottypes, opt.params)\n"
"cost(stmt) = 0\n"
"cst = map(cost, ci.code)\n"
"\n"
"# output\n"
"\n"
"5-element Array{Int64,1}:\n"
"  0\n"
"  0\n"
" 20\n"
" 20\n"
"  0\n"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/inference.md:122
msgid ""
"The output is a `Vector{Int}` holding the estimated cost of each statement in `ci.code`.  Note that `ci` includes the consequences of "
"inlining callees, and consequently the costs do too."
msgstr ""

#. type: Title #
#: ext/julia/doc/src/devdocs/sanitizers.md:1
#, no-wrap
msgid "Sanitizer support"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/sanitizers.md:9
msgid ""
"Using Clang's sanitizers obviously require you to use Clang (`USECLANG=1`), but there's another catch: most sanitizers require a run-time "
"library, provided by the host compiler, while the instrumented code generated by Julia's JIT relies on functionality from that library. This "
"implies that the LLVM version of your host compiler matches that of the LLVM library used within Julia."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/sanitizers.md:13
msgid ""
"An easy solution is to have an dedicated build folder for providing a matching toolchain, by building with `BUILD_LLVM_CLANG=1`. You can "
"then refer to this toolchain from another build folder by specifying `USECLANG=1` while overriding the `CC` and `CXX` variables."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/sanitizers.md:14
#, no-wrap
msgid "Address Sanitizer (ASAN)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/sanitizers.md:22
msgid ""
"For detecting or debugging memory bugs, you can use Clang's [address sanitizer (ASAN)](http://clang.llvm.org/docs/AddressSanitizer.html).  "
"By compiling with `SANITIZE=1` you enable ASAN for the Julia compiler and its generated code.  In addition, you can specify "
"`LLVM_SANITIZE=1` to sanitize the LLVM library as well. Note that these options incur a high performance and memory cost. For example, using "
"ASAN for Julia and LLVM makes `testall1` takes 8-10 times as long while using 20 times as much memory (this can be reduced to respectively a "
"factor of 3 and 4 by using the options described below)."
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/sanitizers.md:29
msgid ""
"By default, Julia sets the `allow_user_segv_handler=1` ASAN flag, which is required for signal delivery to work properly. You can define "
"other options using the `ASAN_OPTIONS` environment flag, in which case you'll need to repeat the default option mentioned before. For "
"example, memory usage can be reduced by specifying `fast_unwind_on_malloc=0` and `malloc_context_size=2`, at the cost of backtrace accuracy. "
"For now, Julia also sets `detect_leaks=0`, but this should be removed in the future."
msgstr ""

#. type: Title ##
#: ext/julia/doc/src/devdocs/sanitizers.md:30
#, no-wrap
msgid "Memory Sanitizer (MSAN)"
msgstr ""

#. type: Plain text
#: ext/julia/doc/src/devdocs/sanitizers.md:33
msgid ""
"For detecting use of uninitialized memory, you can use Clang's [memory sanitizer (MSAN)](http://clang.llvm.org/docs/MemorySanitizer.html)  "
"by compiling with `SANITIZE_MEMORY=1`."
msgstr ""

#~ msgid "[ãã­ãã¡ã¤ãªã³ã°](@id lib-profiling)"
#~ msgstr "[Profiling](@id lib-profiling)"

#~ msgid "Code blocks"
#~ msgstr "[ã³ã¼ããã­ãã¯](@id Code-blocks)"

#~ msgid "Examples"
#~ msgstr "ä¾"

#~ msgid "Logger installation and inspection:"
#~ msgstr "ã­ã¬ã¼ã®ã¤ã³ã¹ãã¼ã«ã¨ã¤ã³ã¹ãã­ã¹ãã¯ã·ã§ã³:"

#~ msgid "Pkg is Julia's builtin package manager, and handles operations such as installing, updating and removing packages."
#~ msgstr "Pkg ã¯ Julia ã®çµã¿è¾¼ã¿ããã±ã¼ã¸ ããã¼ã¸ã£ã§ãããããã±ã¼ã¸ã®ã¤ã³ã¹ãã¼ã«ãæ´æ°ãåé¤ãªã©ã®æä½ãå¦çãã¾ãã"

#~ msgid "Special matrices"
#~ msgstr "ç¹æ®è¡å"

#~ msgid ""
#~ "The syntax of [`remotecall`](@ref) is not especially convenient. The macro [`@spawn`](@ref)  makes things easier. It operates on an "
#~ "expression rather than a function, and picks where to do the operation for you:"
#~ msgstr ""
#~ "[`remotecall`](@ref)ã®æ§æã¯ç¹ã«ä¾¿å©ã§ã¯ãªãããã¯ã­[`@spawn`](@ref) ã¯ç©äºãå®¹æã«ãã¾ããé¢æ°ã§ãªãå¼ãæå®ãããã¨ãã§ãã¾ãããæä½ã"
#~ "å®è¡ãããã­ã»ããµãé¸æã§ãã¾ã:"

#~ msgid "Return type (see below for mapping the declared C type to Julia)"
#~ msgstr "æ»ãå¤ã®åï¼Cã®åããJuliaã¸ã®ãããã³ã°ã«ã¤ãã¦ã¯å¾è¿°ï¼"

#~ msgid "A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression."
#~ msgstr "é¢æ°ã¸ã®å¥åå¼æ°ã®ãã¼ã¿åãã¿ãã«ã«ãããã®ãã¿ãã«å¤ã®å¤æ°ãå¼ã§ã¯ãªãããªãã©ã«ã¿ãã«ã¨ãã¦è¨è¿°ããå¿è¦ãããã¾ãã"

#~ msgid "The following arguments, if any, are the actual argument values passed to the function."
#~ msgstr "ãã®ãã¨ã«ç¶ãå¼æ°(ããããã°)ã¯ããã®é¢æ°ã«å®éã«æ¸¡ãããå¼æ°ã®å¤ã§ãã"

#~ msgid "Here is a slightly more complex example that discovers the local machine's hostname:"
#~ msgstr "ã­ã¼ã«ã« ãã·ã³ã®ãã¹ãåãæ¤åºããããå°ãè¤éãªä¾ãæ¬¡ã«ç¤ºãã¾ã:"

#~ msgid "Return type"
#~ msgstr "æ»ãå¤"

#~ msgid "A literal tuple of input types"
#~ msgstr "å¥åå¼æ°ã®åãè¦ç´ ã«ãã¤ãªãã©ã«ã¿ãã«"

#~ msgid "Like ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined."
#~ msgstr "ããããã¹ã¦ã®å¼æ°ã¯ ccall  ã®ããã«ãã³ã³ãã¤ã«æã«è©ä¾¡ããã¾ãããã®ã¨ããã¡ã½ãããå®ç¾©ããã¾ãã"

#~ msgid "DocTestSetup = :(using InteractiveUtils)\n"
#~ msgstr "DocTestSetup = :(using InteractiveUtils)\n"

#, fuzzy
#~| msgid "Rounding Functions"
#~ msgid "[ä¸¸ãé¢æ°](@id Rounding-Functions)"
#~ msgstr "[ä¸¸ãé¢æ°](@id Rounding-Functions)"

#~ msgid ""
#~ "An *exception stack* is maintained on each task to make exception handling more robust and enable root cause analysis. The stack may be "
#~ "accessed using the experimental function `Base.catch_stack` ([#28878](https://github.com/JuliaLang/julia/issues/28878))."
#~ msgstr ""
#~ "*ä¾å¤ã¹ã¿ãã¯* ã¯ãä¾å¤å¦çãããå ç¢ã«ããæ ¹æ¬åå åæãæå¹ã«ããããã«ãåã¿ã¹ã¯ã§ç¶­æããã¾ããã¹ã¿ãã¯ã¯ãå®é¨çé¢æ° `Base."
#~ "catch_stack` ([#28878](https://github.com/JuliaLang/julia/issues/28878)ãä½¿ç¨ãã¦ã¢ã¯ã»ã¹ã§ãã¾ãã"

#~ msgid ""
#~ "Parser inputs ending with a comma are now consistently treated as incomplete.  Previously they were sometimes parsed as tuples, depending "
#~ "on whitespace ([#28506](https://github.com/JuliaLang/julia/issues/28506))."
#~ msgstr ""
#~ "ã³ã³ãã§çµãããã¼ãµã¼å¥åã¯ãä¸è²«ãã¦ä¸å®å¨è¡ã¨ãã¦æ±ãããããã«ãªãã¾ããã ä»¥åã¯ãç©ºç½ã«å¿ãã¦ã¿ãã«ã¨ãã¦è§£æããããã¨ãããã¾ãã"
#~ "([#28506](https://github.com/JuliaLang/julia/issues/28506)ã"

#~ msgid ""
#~ "Spaces were accidentally allowed in broadcast call syntax, e.g. `f. (x)`. They are now disallowed, consistent with normal function call "
#~ "syntax ([#29781](https://github.com/JuliaLang/julia/issues/29781))."
#~ msgstr ""
#~ "ä»¥åã¯(`f. (x))` ãªã©ã®ãã­ã¼ãã­ã£ã¹ãã³ã¼ã«æ§æã«ã¹ãã¼ã¹ãèª¤ã£ã¦è¨±å¯ããã¦ãã¾ããããéå¸¸ã®é¢æ°å¼ã³åºãæ§æ ([#29781](https://github."
#~ "com/JuliaLang/julia/issues/29781)ã¨åããã¦ç¾å¨ã¯è¨±å¯ãããªãããã«ãªãã¾ããã"

#, fuzzy
#~ msgid ""
#~ "Big integer literals and command syntax (backticks) are now parsed with the name of the macro (`@int128_str`, `@uint128_str`, `@big_str`, "
#~ "`@cmd`) qualified to refer to the `Core` module ([#29968](https://github.com/JuliaLang/julia/issues/29968))."
#~ msgstr ""
#~ "Big Integer ãªãã©ã«ã¨ã³ãã³ãæ§æ(ããã¯ã¯ãªã¼ã)ã¯ããã¯ã­ã®åå(`@int128_str`, `@uint128_str`, `@big_str`, `@cmd` )ã§è§£æããããã³ã¢ã"
#~ "ã¢ã¸ã¥ã¼ã«([#29968](https://github.com/JuliaLang/julia/issues/29968)ãåç§ãããã¨ãã§ãã¾ãã"

#~ msgid ""
#~ "The `try/catch` statement allows for `Exception`s to be tested for. For example, a customized square root function can be written to "
#~ "automatically call either the real or complex square root method on demand using `Exception`s :"
#~ msgstr ""
#~ "`try/catch` æãä½¿ç¨ããã¨ãä¾å¤ãæ¤æ»ã§ãã¾ãããã¨ãã°ã `Exception` ãä½¿ç¨ãã¦ãå®æ°å¼æ°åãå¹³æ¹æ ¹ã¡ã½ããã¨è¤ç´ æ°å¼æ°åãã®å¹³æ¹æ ¹ã¡"
#~ "ã½ããããªã³ããã³ãã§å¼ã³åããããã«ã«ã¹ã¿ãã¤ãºãããå¹³æ¹æ ¹é¢æ°ãä»¥ä¸ã®ããã«æ¸ããã¨ãã§ãã¾ã:"

#~ msgid ""
#~ "julia> f(x) = try\n"
#~ "           sqrt(x)\n"
#~ "       catch\n"
#~ "           sqrt(complex(x, 0))\n"
#~ "       end\n"
#~ "f (generic function with 1 method)\n"
#~ "\n"
#~ "julia> f(1)\n"
#~ "1.0\n"
#~ "\n"
#~ "julia> f(-1)\n"
#~ "0.0 + 1.0im\n"
#~ msgstr ""
#~ "julia> f(x) = try\n"
#~ "           sqrt(x)\n"
#~ "       catch\n"
#~ "           sqrt(complex(x, 0))\n"
#~ "       end\n"
#~ "f (generic function with 1 method)\n"
#~ "\n"
#~ "julia> f(1)\n"
#~ "1.0\n"
#~ "\n"
#~ "julia> f(-1)\n"
#~ "0.0 + 1.0im\n"

#~ msgid ""
#~ "It is important to note that in real code computing this function, one would compare `x` to zero instead of catching an exception. The "
#~ "exception is much slower than simply comparing and branching."
#~ msgstr ""
#~ "å®éã«ãã®é¢æ°ãè¨ç®ãããã¨ãã«ã¯ãä¾å¤ãè£è¶³ããã®ã§ã¯ãªãã`x` ã¨0ãæ¯è¼ããç¹ã«æ³¨æãã¦ä¸ãããä¾å¤ã¯ãåç´ãªæ¯è¼ãåå²ãããã¯ããã«"
#~ "éãã®ã§ãã"

#~ msgid "There are three important standard modules: Main, Core, and Base."
#~ msgstr "3ã¤ã®éè¦ãªæ¨æºã¢ã¸ã¥ã¼ã«ãããã¾ãã Mainã¢ã¸ã¥ã¼ã«ãCoreã¢ã¸ã¥ã¼ã«ãBaseã¢ã¸ã¥ã¼ã«ã§ãã"

#~ msgid ""
#~ "Main is the top-level module, and Julia starts with Main set as the current module.  Variables defined at the prompt go in Main, and "
#~ "`varinfo()` lists variables in Main."
#~ msgstr ""
#~ "Mainã¯æä¸ä½ã®ã¢ã¸ã¥ã¼ã«ã§ãããJuliaã¯Mainãç¾å¨ã®ã¢ã¸ã¥ã¼ã«ã«è¨­å®ãããã¨ããå¦çãéå§ãã¾ãã ãã­ã³ããã§å®ç¾©ãããå¤æ°ã¯Mainã«æ ¼ç´ã"
#~ "ãã`varinfo()` ã§ Mainã®å¤æ°ã®ä¸è¦§ãç¢ºèªãããã¨ãã§ãã¾ãã"

#~ msgid ""
#~ "Core contains all identifiers considered \"built in\" to the language, i.e. part of the core language and not libraries. Every module "
#~ "implicitly specifies `using Core`, since you can't do anything without those definitions."
#~ msgstr ""
#~ "Core ã«ã¯ãè¨èªã«å¯¾ãã¦ãçµã¿è¾¼ã¿ãã¨è¦ãªããããã¹ã¦ã®è­å¥å­ãã¤ã¾ãã©ã¤ãã©ãªã§ã¯ãªãè¨èªã®ã³ã¢å®è£ã®ä¸é¨ãå«ã¾ãã¾ãããããã®å®ç¾©ãªã"
#~ "ã§ã¯ä½ãå®è¡ã§ããªãããããã¹ã¦ã®ã¢ã¸ã¥ã¼ã«ã¯æé»çã« `using Core` ãè¡ã£ã¦ãã¾ãã"

#~ msgid ""
#~ "Base is a module that contains basic functionality (the contents of base/). All modules implicitly contain `using Base`, since this is "
#~ "needed in the vast majority of cases."
#~ msgstr ""
#~ "Baseã¯ãåºæ¬æ©è½(Base/ã®åå®¹)ãå«ãã¢ã¸ã¥ã¼ã«ã§ããã»ã¨ãã©ã®å ´åå¿è¦ã¨ãããã®ã§ããã¹ã¦ã®ã¢ã¸ã¥ã¼ã«ã«æé»çã« `using Base` ãå«ã¾ãã¦ã"
#~ "ã¾ãã"

#~ msgid "Module file paths"
#~ msgstr "ã¢ã¸ã¥ã¼ã«ãã¡ã¤ã«ãã¹"

#~ msgid ""
#~ "The global variable [`LOAD_PATH`](@ref) contains the directories Julia searches for modules when calling `require`. It can be extended "
#~ "using [`push!`](@ref):"
#~ msgstr ""
#~ "ã°ã­ã¼ãã«å¤æ° [`LOAD_PATH`](@ref) ã«ã¯ã`require` ãå¼ã³åºãã¨ãã«Julia ãã¢ã¸ã¥ã¼ã«ãæ¤ç´¢ãããã£ã¬ã¯ããªãå«ã¾ãã¦ãã¾ããããã¯ "
#~ "[`push!`](@ref)ãä½¿ç¨ãã¦æ¡å¼µãããã¨ãã§ãã¾ã:"

#~ msgid "push!(LOAD_PATH, \"/Path/To/My/Module/\")\n"
#~ msgstr "push!(LOAD_PATH, \"/Path/To/My/Module/\")\n"

#~ msgid ""
#~ "Putting this statement in the file `~/.julia/config/startup.jl` will extend [`LOAD_PATH`](@ref) on every Julia startup. Alternatively, "
#~ "the module load path can be extended by defining the environment variable `JULIA_LOAD_PATH`."
#~ msgstr ""
#~ "ãã®æããã¡ã¤ã« `~/.julia/config/startup.jl`ã«å¥ãã¦ããã¨ãJulia ã®èµ·åã®ãã³ã« [`LOAD_PATH`](@ref)ãæ¡å¼µããã¾ããã¾ããç°å¢å¤æ° "
#~ "`JULIA_LOAD_PATH`ãå®ç¾©ãããã¨ã§ãã¢ã¸ã¥ã¼ã«ã®ã­ã¼ããã¹ãæ¡å¼µãããã¨ãã§ãã¾ãã"
